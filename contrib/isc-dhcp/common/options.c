begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* options.c     DHCP options parsing and reassembly. */
end_comment

begin_comment
comment|/*  * Copyright (c) 1995-2002 Internet Software Consortium.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of The Internet Software Consortium nor the names  *    of its contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND  * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * This software has been written for the Internet Software Consortium  * by Ted Lemon in cooperation with Vixie Enterprises and Nominum, Inc.  * To learn more about the Internet Software Consortium, see  * ``http://www.isc.org/''.  To learn more about Vixie Enterprises,  * see ``http://www.vix.com''.   To learn more about Nominum, Inc., see  * ``http://www.nominum.com''.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"$Id: options.c,v 1.85.2.9 2002/11/17 02:26:58 dhankins Exp $ Copyright (c) 1995-2002 The Internet Software Consortium.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_define
define|#
directive|define
name|DHCP_OPTION_DATA
end_define

begin_include
include|#
directive|include
file|"dhcpd.h"
end_include

begin_include
include|#
directive|include
file|<omapip/omapip_p.h>
end_include

begin_decl_stmt
name|struct
name|option
modifier|*
name|vendor_cfg_option
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_option_set
name|PROTO
argument_list|(
operator|(
name|pair
operator|*
operator|,
expr|struct
name|option_cache
operator|*
operator|,
expr|enum
name|statement_op
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse all available options out of the specified packet. */
end_comment

begin_function
name|int
name|parse_options
parameter_list|(
name|packet
parameter_list|)
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|option_cache
modifier|*
name|op
init|=
operator|(
expr|struct
name|option_cache
operator|*
operator|)
literal|0
decl_stmt|;
comment|/* Allocate a new option state. */
if|if
condition|(
operator|!
name|option_state_allocate
argument_list|(
operator|&
name|packet
operator|->
name|options
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
name|packet
operator|->
name|options_valid
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If we don't see the magic cookie, there's nothing to parse. */
if|if
condition|(
name|memcmp
argument_list|(
name|packet
operator|->
name|raw
operator|->
name|options
argument_list|,
name|DHCP_OPTIONS_COOKIE
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|packet
operator|->
name|options_valid
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Go through the options field, up to the end of the packet 	   or the End field. */
if|if
condition|(
operator|!
name|parse_option_buffer
argument_list|(
name|packet
operator|->
name|options
argument_list|,
operator|&
name|packet
operator|->
name|raw
operator|->
name|options
index|[
literal|4
index|]
argument_list|,
operator|(
name|packet
operator|->
name|packet_length
operator|-
name|DHCP_FIXED_NON_UDP
operator|-
literal|4
operator|)
argument_list|,
operator|&
name|dhcp_universe
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If we parsed a DHCP Option Overload option, parse more 	   options out of the buffer(s) containing them. */
if|if
condition|(
name|packet
operator|->
name|options_valid
operator|&&
operator|(
name|op
operator|=
name|lookup_option
argument_list|(
operator|&
name|dhcp_universe
argument_list|,
name|packet
operator|->
name|options
argument_list|,
name|DHO_DHCP_OPTION_OVERLOAD
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|op
operator|->
name|data
operator|.
name|data
index|[
literal|0
index|]
operator|&
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|parse_option_buffer
argument_list|(
name|packet
operator|->
name|options
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|packet
operator|->
name|raw
operator|->
name|file
argument_list|,
sizeof|sizeof
name|packet
operator|->
name|raw
operator|->
name|file
argument_list|,
operator|&
name|dhcp_universe
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|op
operator|->
name|data
operator|.
name|data
index|[
literal|0
index|]
operator|&
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|parse_option_buffer
argument_list|(
name|packet
operator|->
name|options
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|packet
operator|->
name|raw
operator|->
name|sname
argument_list|,
sizeof|sizeof
name|packet
operator|->
name|raw
operator|->
name|sname
argument_list|,
operator|&
name|dhcp_universe
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
name|packet
operator|->
name|options_valid
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Parse options out of the specified buffer, storing addresses of option    values in packet -> options and setting packet -> options_valid if no    errors are encountered. */
end_comment

begin_function
name|int
name|parse_option_buffer
parameter_list|(
name|options
parameter_list|,
name|buffer
parameter_list|,
name|length
parameter_list|,
name|universe
parameter_list|)
name|struct
name|option_state
modifier|*
name|options
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|length
decl_stmt|;
name|struct
name|universe
modifier|*
name|universe
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|t
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|end
init|=
name|buffer
operator|+
name|length
decl_stmt|;
name|unsigned
name|len
decl_stmt|,
name|offset
decl_stmt|;
name|int
name|code
decl_stmt|;
name|struct
name|option_cache
modifier|*
name|op
init|=
operator|(
expr|struct
name|option_cache
operator|*
operator|)
literal|0
decl_stmt|;
name|struct
name|buffer
modifier|*
name|bp
init|=
operator|(
expr|struct
name|buffer
operator|*
operator|)
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|buffer_allocate
argument_list|(
operator|&
name|bp
argument_list|,
name|length
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
literal|"no memory for option buffer."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memcpy
argument_list|(
name|bp
operator|->
name|data
argument_list|,
name|buffer
argument_list|,
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|buffer
index|[
name|offset
index|]
operator|!=
name|DHO_END
operator|&&
name|offset
operator|<
name|length
condition|;
control|)
block|{
name|code
operator|=
name|buffer
index|[
name|offset
index|]
expr_stmt|;
comment|/* Pad options don't have a length - just skip them. */
if|if
condition|(
name|code
operator|==
name|DHO_PAD
condition|)
block|{
operator|++
name|offset
expr_stmt|;
continue|continue;
block|}
comment|/* Don't look for length if the buffer isn't that big. */
if|if
condition|(
name|offset
operator|+
literal|2
operator|>
name|length
condition|)
block|{
name|len
operator|=
literal|65536
expr_stmt|;
goto|goto
name|bogus
goto|;
block|}
comment|/* All other fields (except end, see above) have a 		   one-byte length. */
name|len
operator|=
name|buffer
index|[
name|offset
operator|+
literal|1
index|]
expr_stmt|;
comment|/* If the length is outrageous, the options are bad. */
if|if
condition|(
name|offset
operator|+
name|len
operator|+
literal|2
operator|>
name|length
condition|)
block|{
name|bogus
label|:
name|log_error
argument_list|(
literal|"parse_option_buffer: option %s (%d) %s."
argument_list|,
name|dhcp_options
index|[
name|code
index|]
operator|.
name|name
argument_list|,
name|len
argument_list|,
literal|"larger than buffer"
argument_list|)
expr_stmt|;
name|buffer_dereference
argument_list|(
operator|&
name|bp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If the option contains an encapsulation, parse it.   If 		   the parse fails, or the option isn't an encapsulation (by 		   far the most common case), or the option isn't entirely 		   an encapsulation, keep the raw data as well. */
if|if
condition|(
operator|!
operator|(
operator|(
name|universe
operator|->
name|options
index|[
name|code
index|]
operator|->
name|format
index|[
literal|0
index|]
operator|==
literal|'e'
operator|||
name|universe
operator|->
name|options
index|[
name|code
index|]
operator|->
name|format
index|[
literal|0
index|]
operator|==
literal|'E'
operator|)
operator|&&
operator|(
name|parse_encapsulated_suboptions
argument_list|(
name|options
argument_list|,
name|universe
operator|->
name|options
index|[
name|code
index|]
argument_list|,
name|buffer
operator|+
name|offset
operator|+
literal|2
argument_list|,
name|len
argument_list|,
name|universe
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|)
condition|)
block|{
name|save_option_buffer
argument_list|(
name|universe
argument_list|,
name|options
argument_list|,
name|bp
argument_list|,
operator|&
name|bp
operator|->
name|data
index|[
name|offset
operator|+
literal|2
index|]
argument_list|,
name|len
argument_list|,
name|universe
operator|->
name|options
index|[
name|code
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|offset
operator|+=
name|len
operator|+
literal|2
expr_stmt|;
block|}
name|buffer_dereference
argument_list|(
operator|&
name|bp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* If an option in an option buffer turns out to be an encapsulation,    figure out what to do.   If we don't know how to de-encapsulate it,    or it's not well-formed, return zero; otherwise, return 1, indicating    that we succeeded in de-encapsulating it. */
end_comment

begin_function
name|struct
name|universe
modifier|*
name|find_option_universe
parameter_list|(
name|struct
name|option
modifier|*
name|eopt
parameter_list|,
specifier|const
name|char
modifier|*
name|uname
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|struct
name|universe
modifier|*
name|universe
init|=
operator|(
expr|struct
name|universe
operator|*
operator|)
literal|0
decl_stmt|;
comment|/* Look for the E option in the option format. */
name|s
operator|=
name|strchr
argument_list|(
name|eopt
operator|->
name|format
argument_list|,
literal|'E'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|log_error
argument_list|(
literal|"internal encapsulation format error 1."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Look for the universe name in the option format. */
name|t
operator|=
name|strchr
argument_list|(
operator|++
name|s
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
comment|/* If there was no trailing '.', or there's something after the 	   trailing '.', the option is bogus and we can't use it. */
if|if
condition|(
operator|!
name|t
operator|||
name|t
index|[
literal|1
index|]
condition|)
block|{
name|log_error
argument_list|(
literal|"internal encapsulation format error 2."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|t
operator|==
name|s
operator|&&
name|uname
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|universe_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|universes
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|uname
argument_list|)
condition|)
block|{
name|universe
operator|=
name|universes
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|t
operator|!=
name|s
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|universe_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|universes
index|[
name|i
index|]
operator|->
name|name
argument_list|)
operator|==
name|t
operator|-
name|s
operator|&&
operator|!
name|memcmp
argument_list|(
name|universes
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|s
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|t
operator|-
name|s
argument_list|)
argument_list|)
condition|)
block|{
name|universe
operator|=
name|universes
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|universe
return|;
block|}
end_function

begin_comment
comment|/* If an option in an option buffer turns out to be an encapsulation,    figure out what to do.   If we don't know how to de-encapsulate it,    or it's not well-formed, return zero; otherwise, return 1, indicating    that we succeeded in de-encapsulating it. */
end_comment

begin_function
name|int
name|parse_encapsulated_suboptions
parameter_list|(
name|struct
name|option_state
modifier|*
name|options
parameter_list|,
name|struct
name|option
modifier|*
name|eopt
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|,
name|unsigned
name|len
parameter_list|,
name|struct
name|universe
modifier|*
name|eu
parameter_list|,
specifier|const
name|char
modifier|*
name|uname
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|universe
modifier|*
name|universe
init|=
name|find_option_universe
argument_list|(
name|eopt
argument_list|,
name|uname
argument_list|)
decl_stmt|;
comment|/* If we didn't find the universe, we can't do anything with it 	   right now (e.g., we can't decode vendor options until we've 	   decoded the packet and executed the scopes that it matches). */
if|if
condition|(
operator|!
name|universe
condition|)
return|return
literal|0
return|;
comment|/* If we don't have a decoding function for it, we can't decode 	   it. */
if|if
condition|(
operator|!
name|universe
operator|->
name|decode
condition|)
return|return
literal|0
return|;
name|i
operator|=
call|(
modifier|*
name|universe
operator|->
name|decode
call|)
argument_list|(
name|options
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|,
name|universe
argument_list|)
expr_stmt|;
comment|/* If there is stuff before the suboptions, we have to keep it. */
if|if
condition|(
name|eopt
operator|->
name|format
index|[
literal|0
index|]
operator|!=
literal|'E'
condition|)
return|return
literal|0
return|;
comment|/* Otherwise, return the status of the decode function. */
return|return
name|i
return|;
block|}
end_function

begin_function
name|int
name|fqdn_universe_decode
parameter_list|(
name|struct
name|option_state
modifier|*
name|options
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|,
name|unsigned
name|length
parameter_list|,
name|struct
name|universe
modifier|*
name|u
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|buffer
modifier|*
name|bp
init|=
operator|(
expr|struct
name|buffer
operator|*
operator|)
literal|0
decl_stmt|;
comment|/* FQDN options have to be at least four bytes long. */
if|if
condition|(
name|length
operator|<
literal|3
condition|)
return|return
literal|0
return|;
comment|/* Save the contents of the option in a buffer. */
if|if
condition|(
operator|!
name|buffer_allocate
argument_list|(
operator|&
name|bp
argument_list|,
name|length
operator|+
literal|4
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
literal|"no memory for option buffer."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|bp
operator|->
name|data
index|[
literal|3
index|]
argument_list|,
name|buffer
operator|+
literal|1
argument_list|,
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
index|[
literal|0
index|]
operator|&
literal|4
condition|)
comment|/* encoded */
name|bp
operator|->
name|data
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
else|else
name|bp
operator|->
name|data
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|save_option_buffer
argument_list|(
operator|&
name|fqdn_universe
argument_list|,
name|options
argument_list|,
name|bp
argument_list|,
operator|&
name|bp
operator|->
name|data
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
operator|&
name|fqdn_options
index|[
name|FQDN_ENCODED
index|]
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|bad
label|:
name|buffer_dereference
argument_list|(
operator|&
name|bp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|buffer
index|[
literal|0
index|]
operator|&
literal|1
condition|)
comment|/* server-update */
name|bp
operator|->
name|data
index|[
literal|2
index|]
operator|=
literal|1
expr_stmt|;
else|else
name|bp
operator|->
name|data
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|buffer
index|[
literal|0
index|]
operator|&
literal|2
condition|)
comment|/* no-client-update */
name|bp
operator|->
name|data
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
else|else
name|bp
operator|->
name|data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* XXX Ideally we should store the name in DNS format, so if the 	   XXX label isn't in DNS format, we convert it to DNS format, 	   XXX rather than converting labels specified in DNS format to 	   XXX the plain ASCII representation.   But that's hard, so 	   XXX not now. */
comment|/* Not encoded using DNS format? */
if|if
condition|(
operator|!
name|bp
operator|->
name|data
index|[
literal|0
index|]
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
comment|/* Some broken clients NUL-terminate this option. */
if|if
condition|(
name|buffer
index|[
name|length
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
block|{
operator|--
name|length
expr_stmt|;
name|bp
operator|->
name|data
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Determine the length of the hostname component of the 		   name.  If the name contains no '.' character, it 		   represents a non-qualified label. */
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|length
operator|&&
name|buffer
index|[
name|i
index|]
operator|!=
literal|'.'
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|i
operator|-=
literal|3
expr_stmt|;
comment|/* Note: If the client sends a FQDN, the first '.' will 		   be used as a NUL terminator for the hostname. */
if|if
condition|(
name|i
condition|)
if|if
condition|(
operator|!
name|save_option_buffer
argument_list|(
operator|&
name|fqdn_universe
argument_list|,
name|options
argument_list|,
name|bp
argument_list|,
operator|&
name|bp
operator|->
name|data
index|[
literal|5
index|]
argument_list|,
name|i
argument_list|,
operator|&
name|fqdn_options
index|[
name|FQDN_HOSTNAME
index|]
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|bad
goto|;
comment|/* Note: If the client sends a single label, the 		   FQDN_DOMAINNAME option won't be set. */
if|if
condition|(
name|length
operator|>
literal|4
operator|+
name|i
operator|&&
operator|!
name|save_option_buffer
argument_list|(
operator|&
name|fqdn_universe
argument_list|,
name|options
argument_list|,
name|bp
argument_list|,
operator|&
name|bp
operator|->
name|data
index|[
literal|6
operator|+
name|i
index|]
argument_list|,
name|length
operator|-
literal|4
operator|-
name|i
argument_list|,
operator|&
name|fqdn_options
index|[
name|FQDN_DOMAINNAME
index|]
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|bad
goto|;
comment|/* Also save the whole name. */
if|if
condition|(
name|length
operator|>
literal|3
condition|)
if|if
condition|(
operator|!
name|save_option_buffer
argument_list|(
operator|&
name|fqdn_universe
argument_list|,
name|options
argument_list|,
name|bp
argument_list|,
operator|&
name|bp
operator|->
name|data
index|[
literal|5
index|]
argument_list|,
name|length
operator|-
literal|3
argument_list|,
operator|&
name|fqdn_options
index|[
name|FQDN_FQDN
index|]
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|bad
goto|;
block|}
else|else
block|{
name|unsigned
name|len
decl_stmt|;
name|unsigned
name|total_len
init|=
literal|0
decl_stmt|;
name|unsigned
name|first_len
init|=
literal|0
decl_stmt|;
name|int
name|terminated
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
operator|&
name|bp
operator|->
name|data
index|[
literal|5
index|]
expr_stmt|;
while|while
condition|(
name|s
operator|<
operator|&
name|bp
operator|->
name|data
index|[
literal|0
index|]
operator|+
name|length
operator|+
literal|2
condition|)
block|{
name|len
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|63
condition|)
block|{
name|log_info
argument_list|(
literal|"fancy bits in fqdn option"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|terminated
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|s
operator|+
name|len
operator|>
operator|&
name|bp
operator|->
name|data
index|[
literal|0
index|]
operator|+
name|length
operator|+
literal|3
condition|)
block|{
name|log_info
argument_list|(
literal|"fqdn tag longer than buffer"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|first_len
operator|==
literal|0
condition|)
block|{
name|first_len
operator|=
name|len
expr_stmt|;
block|}
operator|*
name|s
operator|=
literal|'.'
expr_stmt|;
name|s
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|total_len
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
block|}
comment|/* We wind up with a length that's one too many because 		   we shouldn't increment for the last label, but there's 		   no way to tell we're at the last label until we exit 		   the loop.   :'*/
if|if
condition|(
name|total_len
operator|>
literal|0
condition|)
name|total_len
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|terminated
condition|)
block|{
name|first_len
operator|=
name|total_len
expr_stmt|;
block|}
if|if
condition|(
name|first_len
operator|>
literal|0
operator|&&
operator|!
name|save_option_buffer
argument_list|(
operator|&
name|fqdn_universe
argument_list|,
name|options
argument_list|,
name|bp
argument_list|,
operator|&
name|bp
operator|->
name|data
index|[
literal|6
index|]
argument_list|,
name|first_len
argument_list|,
operator|&
name|fqdn_options
index|[
name|FQDN_HOSTNAME
index|]
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|total_len
operator|>
literal|0
operator|&&
name|first_len
operator|!=
name|total_len
condition|)
block|{
if|if
condition|(
operator|!
name|save_option_buffer
argument_list|(
operator|&
name|fqdn_universe
argument_list|,
name|options
argument_list|,
name|bp
argument_list|,
operator|&
name|bp
operator|->
name|data
index|[
literal|6
operator|+
name|first_len
index|]
argument_list|,
name|total_len
operator|-
name|first_len
argument_list|,
operator|&
name|fqdn_options
index|[
name|FQDN_DOMAINNAME
index|]
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|total_len
operator|>
literal|0
condition|)
if|if
condition|(
operator|!
name|save_option_buffer
argument_list|(
operator|&
name|fqdn_universe
argument_list|,
name|options
argument_list|,
name|bp
argument_list|,
operator|&
name|bp
operator|->
name|data
index|[
literal|6
index|]
argument_list|,
name|total_len
argument_list|,
operator|&
name|fqdn_options
index|[
name|FQDN_FQDN
index|]
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|!
name|save_option_buffer
argument_list|(
operator|&
name|fqdn_universe
argument_list|,
name|options
argument_list|,
name|bp
argument_list|,
operator|&
name|bp
operator|->
name|data
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|,
operator|&
name|fqdn_options
index|[
name|FQDN_NO_CLIENT_UPDATE
index|]
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
operator|!
name|save_option_buffer
argument_list|(
operator|&
name|fqdn_universe
argument_list|,
name|options
argument_list|,
name|bp
argument_list|,
operator|&
name|bp
operator|->
name|data
index|[
literal|2
index|]
argument_list|,
literal|1
argument_list|,
operator|&
name|fqdn_options
index|[
name|FQDN_SERVER_UPDATE
index|]
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
operator|!
name|save_option_buffer
argument_list|(
operator|&
name|fqdn_universe
argument_list|,
name|options
argument_list|,
name|bp
argument_list|,
operator|&
name|bp
operator|->
name|data
index|[
literal|3
index|]
argument_list|,
literal|1
argument_list|,
operator|&
name|fqdn_options
index|[
name|FQDN_RCODE1
index|]
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
operator|!
name|save_option_buffer
argument_list|(
operator|&
name|fqdn_universe
argument_list|,
name|options
argument_list|,
name|bp
argument_list|,
operator|&
name|bp
operator|->
name|data
index|[
literal|4
index|]
argument_list|,
literal|1
argument_list|,
operator|&
name|fqdn_options
index|[
name|FQDN_RCODE2
index|]
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|buffer_dereference
argument_list|(
operator|&
name|bp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* cons options into a big buffer, and then split them out into the    three seperate buffers if needed.  This allows us to cons up a set    of vendor options using the same routine. */
end_comment

begin_function
name|int
name|cons_options
parameter_list|(
name|inpacket
parameter_list|,
name|outpacket
parameter_list|,
name|lease
parameter_list|,
name|client_state
parameter_list|,
name|mms
parameter_list|,
name|in_options
parameter_list|,
name|cfg_options
parameter_list|,
name|scope
parameter_list|,
name|overload
parameter_list|,
name|terminate
parameter_list|,
name|bootpp
parameter_list|,
name|prl
parameter_list|,
name|vuname
parameter_list|)
name|struct
name|packet
modifier|*
name|inpacket
decl_stmt|;
name|struct
name|dhcp_packet
modifier|*
name|outpacket
decl_stmt|;
name|struct
name|lease
modifier|*
name|lease
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client_state
decl_stmt|;
name|int
name|mms
decl_stmt|;
name|struct
name|option_state
modifier|*
name|in_options
decl_stmt|;
name|struct
name|option_state
modifier|*
name|cfg_options
decl_stmt|;
name|struct
name|binding_scope
modifier|*
modifier|*
name|scope
decl_stmt|;
name|int
name|overload
decl_stmt|;
comment|/* Overload flags that may be set. */
name|int
name|terminate
decl_stmt|;
name|int
name|bootpp
decl_stmt|;
name|struct
name|data_string
modifier|*
name|prl
decl_stmt|;
specifier|const
name|char
modifier|*
name|vuname
decl_stmt|;
block|{
define|#
directive|define
name|PRIORITY_COUNT
value|300
name|unsigned
name|priority_list
index|[
name|PRIORITY_COUNT
index|]
decl_stmt|;
name|int
name|priority_len
decl_stmt|;
name|unsigned
name|char
name|buffer
index|[
literal|4096
index|]
decl_stmt|;
comment|/* Really big buffer... */
name|unsigned
name|main_buffer_size
decl_stmt|;
name|unsigned
name|mainbufix
decl_stmt|,
name|bufix
decl_stmt|,
name|agentix
decl_stmt|;
name|unsigned
name|option_size
decl_stmt|;
name|unsigned
name|length
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|option_cache
modifier|*
name|op
decl_stmt|;
name|struct
name|data_string
name|ds
decl_stmt|;
name|pair
name|pp
decl_stmt|,
modifier|*
name|hash
decl_stmt|;
name|int
name|need_endopt
init|=
literal|0
decl_stmt|;
name|int
name|have_sso
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ds
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ds
argument_list|)
expr_stmt|;
comment|/* If there's a Maximum Message Size option in the incoming packet 	   and no alternate maximum message size has been specified, take the 	   one in the packet. */
if|if
condition|(
operator|!
name|mms
operator|&&
name|inpacket
operator|&&
operator|(
name|op
operator|=
name|lookup_option
argument_list|(
operator|&
name|dhcp_universe
argument_list|,
name|inpacket
operator|->
name|options
argument_list|,
name|DHO_DHCP_MAX_MESSAGE_SIZE
argument_list|)
operator|)
condition|)
block|{
name|evaluate_option_cache
argument_list|(
operator|&
name|ds
argument_list|,
name|inpacket
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|op
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|len
operator|>=
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
condition|)
name|mms
operator|=
name|getUShort
argument_list|(
name|ds
operator|.
name|data
argument_list|)
expr_stmt|;
name|data_string_forget
argument_list|(
operator|&
name|ds
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
comment|/* If the client has provided a maximum DHCP message size, 	   use that; otherwise, if it's BOOTP, only 64 bytes; otherwise 	   use up to the minimum IP MTU size (576 bytes). */
comment|/* XXX if a BOOTP client specifies a max message size, we will 	   honor it. */
if|if
condition|(
name|mms
condition|)
block|{
name|main_buffer_size
operator|=
name|mms
operator|-
name|DHCP_FIXED_LEN
expr_stmt|;
comment|/* Enforce a minimum packet size... */
if|if
condition|(
name|main_buffer_size
operator|<
operator|(
literal|576
operator|-
name|DHCP_FIXED_LEN
operator|)
condition|)
name|main_buffer_size
operator|=
literal|576
operator|-
name|DHCP_FIXED_LEN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bootpp
condition|)
block|{
if|if
condition|(
name|inpacket
condition|)
block|{
name|main_buffer_size
operator|=
name|inpacket
operator|->
name|packet_length
operator|-
name|DHCP_FIXED_LEN
expr_stmt|;
if|if
condition|(
name|main_buffer_size
operator|<
literal|64
condition|)
name|main_buffer_size
operator|=
literal|64
expr_stmt|;
block|}
else|else
name|main_buffer_size
operator|=
literal|64
expr_stmt|;
block|}
else|else
name|main_buffer_size
operator|=
literal|576
operator|-
name|DHCP_FIXED_LEN
expr_stmt|;
comment|/* Set a hard limit at the size of the output buffer. */
if|if
condition|(
name|main_buffer_size
operator|>
sizeof|sizeof
name|buffer
condition|)
name|main_buffer_size
operator|=
sizeof|sizeof
name|buffer
expr_stmt|;
comment|/* Preload the option priority list with mandatory options. */
name|priority_len
operator|=
literal|0
expr_stmt|;
name|priority_list
index|[
name|priority_len
operator|++
index|]
operator|=
name|DHO_DHCP_MESSAGE_TYPE
expr_stmt|;
name|priority_list
index|[
name|priority_len
operator|++
index|]
operator|=
name|DHO_DHCP_SERVER_IDENTIFIER
expr_stmt|;
name|priority_list
index|[
name|priority_len
operator|++
index|]
operator|=
name|DHO_DHCP_LEASE_TIME
expr_stmt|;
name|priority_list
index|[
name|priority_len
operator|++
index|]
operator|=
name|DHO_DHCP_MESSAGE
expr_stmt|;
name|priority_list
index|[
name|priority_len
operator|++
index|]
operator|=
name|DHO_DHCP_REQUESTED_ADDRESS
expr_stmt|;
name|priority_list
index|[
name|priority_len
operator|++
index|]
operator|=
name|DHO_FQDN
expr_stmt|;
if|if
condition|(
name|prl
operator|&&
name|prl
operator|->
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|op
operator|=
name|lookup_option
argument_list|(
operator|&
name|dhcp_universe
argument_list|,
name|cfg_options
argument_list|,
name|DHO_SUBNET_SELECTION
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|priority_len
operator|<
name|PRIORITY_COUNT
condition|)
name|priority_list
index|[
name|priority_len
operator|++
index|]
operator|=
name|DHO_SUBNET_SELECTION
expr_stmt|;
block|}
name|data_string_truncate
argument_list|(
name|prl
argument_list|,
operator|(
name|PRIORITY_COUNT
operator|-
name|priority_len
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prl
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
comment|/* Prevent client from changing order of delivery 			   of relay agent information option. */
if|if
condition|(
name|prl
operator|->
name|data
index|[
name|i
index|]
operator|!=
name|DHO_DHCP_AGENT_OPTIONS
condition|)
name|priority_list
index|[
name|priority_len
operator|++
index|]
operator|=
name|prl
operator|->
name|data
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* First, hardcode some more options that ought to be 		   sent first... */
name|priority_list
index|[
name|priority_len
operator|++
index|]
operator|=
name|DHO_SUBNET_MASK
expr_stmt|;
name|priority_list
index|[
name|priority_len
operator|++
index|]
operator|=
name|DHO_ROUTERS
expr_stmt|;
name|priority_list
index|[
name|priority_len
operator|++
index|]
operator|=
name|DHO_DOMAIN_NAME_SERVERS
expr_stmt|;
name|priority_list
index|[
name|priority_len
operator|++
index|]
operator|=
name|DHO_HOST_NAME
expr_stmt|;
comment|/* Append a list of the standard DHCP options from the 		   standard DHCP option space.  Actually, if a site 		   option space hasn't been specified, we wind up 		   treating the dhcp option space as the site option 		   space, and the first for loop is skipped, because 		   it's slightly more general to do it this way, 		   taking the 1Q99 DHCP futures work into account. */
if|if
condition|(
name|cfg_options
operator|->
name|site_code_min
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OPTION_HASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|hash
operator|=
name|cfg_options
operator|->
name|universes
index|[
name|dhcp_universe
operator|.
name|index
index|]
expr_stmt|;
if|if
condition|(
name|hash
condition|)
block|{
for|for
control|(
name|pp
operator|=
name|hash
index|[
name|i
index|]
init|;
name|pp
condition|;
name|pp
operator|=
name|pp
operator|->
name|cdr
control|)
block|{
name|op
operator|=
operator|(
expr|struct
name|option_cache
operator|*
operator|)
operator|(
name|pp
operator|->
name|car
operator|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|option
operator|->
name|code
operator|<
name|cfg_options
operator|->
name|site_code_min
operator|&&
name|priority_len
operator|<
name|PRIORITY_COUNT
operator|&&
operator|(
name|op
operator|->
name|option
operator|->
name|code
operator|!=
name|DHO_DHCP_AGENT_OPTIONS
operator|)
condition|)
name|priority_list
index|[
name|priority_len
operator|++
index|]
operator|=
name|op
operator|->
name|option
operator|->
name|code
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Now cycle through the site option space, or if there 		   is no site option space, we'll be cycling through the 		   dhcp option space. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OPTION_HASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|hash
operator|=
operator|(
name|cfg_options
operator|->
name|universes
index|[
name|cfg_options
operator|->
name|site_universe
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|hash
condition|)
for|for
control|(
name|pp
operator|=
name|hash
index|[
name|i
index|]
init|;
name|pp
condition|;
name|pp
operator|=
name|pp
operator|->
name|cdr
control|)
block|{
name|op
operator|=
operator|(
expr|struct
name|option_cache
operator|*
operator|)
operator|(
name|pp
operator|->
name|car
operator|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|option
operator|->
name|code
operator|>=
name|cfg_options
operator|->
name|site_code_min
operator|&&
name|priority_len
operator|<
name|PRIORITY_COUNT
operator|&&
operator|(
name|op
operator|->
name|option
operator|->
name|code
operator|!=
name|DHO_DHCP_AGENT_OPTIONS
operator|)
condition|)
name|priority_list
index|[
name|priority_len
operator|++
index|]
operator|=
name|op
operator|->
name|option
operator|->
name|code
expr_stmt|;
block|}
block|}
comment|/* Now go through all the universes for which options 		   were set and see if there are encapsulations for 		   them; if there are, put the encapsulation options 		   on the priority list as well. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cfg_options
operator|->
name|universe_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cfg_options
operator|->
name|universes
index|[
name|i
index|]
operator|&&
name|universes
index|[
name|i
index|]
operator|->
name|enc_opt
operator|&&
name|priority_len
operator|<
name|PRIORITY_COUNT
operator|&&
name|universes
index|[
name|i
index|]
operator|->
name|enc_opt
operator|->
name|universe
operator|==
operator|&
name|dhcp_universe
condition|)
block|{
if|if
condition|(
name|universes
index|[
name|i
index|]
operator|->
name|enc_opt
operator|->
name|code
operator|!=
name|DHO_DHCP_AGENT_OPTIONS
condition|)
name|priority_list
index|[
name|priority_len
operator|++
index|]
operator|=
name|universes
index|[
name|i
index|]
operator|->
name|enc_opt
operator|->
name|code
expr_stmt|;
block|}
block|}
comment|/* The vendor option space can't stand on its own, so always 		   add it to the list. */
if|if
condition|(
name|priority_len
operator|<
name|PRIORITY_COUNT
condition|)
name|priority_list
index|[
name|priority_len
operator|++
index|]
operator|=
name|DHO_VENDOR_ENCAPSULATED_OPTIONS
expr_stmt|;
block|}
comment|/* Copy the options into the big buffer... */
name|option_size
operator|=
name|store_options
argument_list|(
name|buffer
argument_list|,
operator|(
name|main_buffer_size
operator|-
literal|7
operator|+
operator|(
operator|(
name|overload
operator|&
literal|1
operator|)
condition|?
name|DHCP_FILE_LEN
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|overload
operator|&
literal|2
operator|)
condition|?
name|DHCP_SNAME_LEN
else|:
literal|0
operator|)
operator|)
argument_list|,
name|inpacket
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|priority_list
argument_list|,
name|priority_len
argument_list|,
name|main_buffer_size
argument_list|,
operator|(
name|main_buffer_size
operator|+
operator|(
operator|(
name|overload
operator|&
literal|1
operator|)
condition|?
name|DHCP_FILE_LEN
else|:
literal|0
operator|)
operator|)
argument_list|,
name|terminate
argument_list|,
name|vuname
argument_list|)
expr_stmt|;
comment|/* Put the cookie up front... */
name|memcpy
argument_list|(
name|outpacket
operator|->
name|options
argument_list|,
name|DHCP_OPTIONS_COOKIE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|mainbufix
operator|=
literal|4
expr_stmt|;
comment|/* If we're going to have to overload, store the overload 	   option at the beginning.  If we can, though, just store the 	   whole thing in the packet's option buffer and leave it at 	   that. */
if|if
condition|(
name|option_size
operator|<=
name|main_buffer_size
operator|-
name|mainbufix
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|outpacket
operator|->
name|options
index|[
name|mainbufix
index|]
argument_list|,
name|buffer
argument_list|,
name|option_size
argument_list|)
expr_stmt|;
name|mainbufix
operator|+=
name|option_size
expr_stmt|;
name|agentix
operator|=
name|mainbufix
expr_stmt|;
if|if
condition|(
name|mainbufix
operator|<
name|main_buffer_size
condition|)
name|need_endopt
operator|=
literal|1
expr_stmt|;
name|length
operator|=
name|DHCP_FIXED_NON_UDP
operator|+
name|mainbufix
expr_stmt|;
block|}
else|else
block|{
name|outpacket
operator|->
name|options
index|[
name|mainbufix
operator|++
index|]
operator|=
name|DHO_DHCP_OPTION_OVERLOAD
expr_stmt|;
name|outpacket
operator|->
name|options
index|[
name|mainbufix
operator|++
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|option_size
operator|>
name|main_buffer_size
operator|-
name|mainbufix
operator|+
name|DHCP_FILE_LEN
condition|)
name|outpacket
operator|->
name|options
index|[
name|mainbufix
operator|++
index|]
operator|=
literal|3
expr_stmt|;
else|else
name|outpacket
operator|->
name|options
index|[
name|mainbufix
operator|++
index|]
operator|=
literal|1
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|outpacket
operator|->
name|options
index|[
name|mainbufix
index|]
argument_list|,
name|buffer
argument_list|,
name|main_buffer_size
operator|-
name|mainbufix
argument_list|)
expr_stmt|;
name|length
operator|=
name|DHCP_FIXED_NON_UDP
operator|+
name|main_buffer_size
expr_stmt|;
name|agentix
operator|=
name|main_buffer_size
expr_stmt|;
name|bufix
operator|=
name|main_buffer_size
operator|-
name|mainbufix
expr_stmt|;
if|if
condition|(
name|overload
operator|&
literal|1
condition|)
block|{
if|if
condition|(
name|option_size
operator|-
name|bufix
operator|<=
name|DHCP_FILE_LEN
condition|)
block|{
name|memcpy
argument_list|(
name|outpacket
operator|->
name|file
argument_list|,
operator|&
name|buffer
index|[
name|bufix
index|]
argument_list|,
name|option_size
operator|-
name|bufix
argument_list|)
expr_stmt|;
name|mainbufix
operator|=
name|option_size
operator|-
name|bufix
expr_stmt|;
if|if
condition|(
name|mainbufix
operator|<
name|DHCP_FILE_LEN
condition|)
name|outpacket
operator|->
name|file
index|[
name|mainbufix
operator|++
index|]
operator|=
name|DHO_END
expr_stmt|;
while|while
condition|(
name|mainbufix
operator|<
name|DHCP_FILE_LEN
condition|)
name|outpacket
operator|->
name|file
index|[
name|mainbufix
operator|++
index|]
operator|=
name|DHO_PAD
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|outpacket
operator|->
name|file
argument_list|,
operator|&
name|buffer
index|[
name|bufix
index|]
argument_list|,
name|DHCP_FILE_LEN
argument_list|)
expr_stmt|;
name|bufix
operator|+=
name|DHCP_FILE_LEN
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|overload
operator|&
literal|2
operator|)
operator|&&
name|option_size
operator|<
name|bufix
condition|)
block|{
name|memcpy
argument_list|(
name|outpacket
operator|->
name|sname
argument_list|,
operator|&
name|buffer
index|[
name|bufix
index|]
argument_list|,
name|option_size
operator|-
name|bufix
argument_list|)
expr_stmt|;
name|mainbufix
operator|=
name|option_size
operator|-
name|bufix
expr_stmt|;
if|if
condition|(
name|mainbufix
operator|<
name|DHCP_SNAME_LEN
condition|)
name|outpacket
operator|->
name|file
index|[
name|mainbufix
operator|++
index|]
operator|=
name|DHO_END
expr_stmt|;
while|while
condition|(
name|mainbufix
operator|<
name|DHCP_SNAME_LEN
condition|)
name|outpacket
operator|->
name|file
index|[
name|mainbufix
operator|++
index|]
operator|=
name|DHO_PAD
expr_stmt|;
block|}
block|}
comment|/* Now hack in the agent options if there are any. */
name|priority_list
index|[
literal|0
index|]
operator|=
name|DHO_DHCP_AGENT_OPTIONS
expr_stmt|;
name|priority_len
operator|=
literal|1
expr_stmt|;
name|agentix
operator|+=
name|store_options
argument_list|(
operator|&
name|outpacket
operator|->
name|options
index|[
name|agentix
index|]
argument_list|,
literal|1500
operator|-
name|DHCP_FIXED_LEN
operator|-
name|agentix
argument_list|,
name|inpacket
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|priority_list
argument_list|,
name|priority_len
argument_list|,
literal|1500
operator|-
name|DHCP_FIXED_LEN
operator|-
name|agentix
argument_list|,
literal|1500
operator|-
name|DHCP_FIXED_LEN
operator|-
name|agentix
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Tack a DHO_END option onto the packet if we need to. */
if|if
condition|(
name|agentix
operator|<
literal|1500
operator|-
name|DHCP_FIXED_LEN
operator|&&
name|need_endopt
condition|)
name|outpacket
operator|->
name|options
index|[
name|agentix
operator|++
index|]
operator|=
name|DHO_END
expr_stmt|;
comment|/* Figure out the length. */
name|length
operator|=
name|DHCP_FIXED_NON_UDP
operator|+
name|agentix
expr_stmt|;
return|return
name|length
return|;
block|}
end_function

begin_comment
comment|/* Store all the requested options into the requested buffer. */
end_comment

begin_function
name|int
name|store_options
parameter_list|(
name|buffer
parameter_list|,
name|buflen
parameter_list|,
name|packet
parameter_list|,
name|lease
parameter_list|,
name|client_state
parameter_list|,
name|in_options
parameter_list|,
name|cfg_options
parameter_list|,
name|scope
parameter_list|,
name|priority_list
parameter_list|,
name|priority_len
parameter_list|,
name|first_cutoff
parameter_list|,
name|second_cutoff
parameter_list|,
name|terminate
parameter_list|,
name|vuname
parameter_list|)
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|buflen
decl_stmt|;
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
name|struct
name|lease
modifier|*
name|lease
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client_state
decl_stmt|;
name|struct
name|option_state
modifier|*
name|in_options
decl_stmt|;
name|struct
name|option_state
modifier|*
name|cfg_options
decl_stmt|;
name|struct
name|binding_scope
modifier|*
modifier|*
name|scope
decl_stmt|;
name|unsigned
modifier|*
name|priority_list
decl_stmt|;
name|int
name|priority_len
decl_stmt|;
name|unsigned
name|first_cutoff
decl_stmt|,
name|second_cutoff
decl_stmt|;
name|int
name|terminate
decl_stmt|;
specifier|const
name|char
modifier|*
name|vuname
decl_stmt|;
block|{
name|int
name|bufix
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ix
decl_stmt|;
name|int
name|tto
decl_stmt|;
name|struct
name|data_string
name|od
decl_stmt|;
name|struct
name|option_cache
modifier|*
name|oc
decl_stmt|;
name|unsigned
name|code
decl_stmt|;
name|int
name|optstart
decl_stmt|;
name|memset
argument_list|(
operator|&
name|od
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|od
argument_list|)
expr_stmt|;
comment|/* Eliminate duplicate options in the parameter request list. 	   There's got to be some clever knuthian way to do this: 	   Eliminate all but the first occurance of a value in an array 	   of values without otherwise disturbing the order of the array. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|priority_len
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|tto
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ix
operator|=
name|i
operator|+
literal|1
init|;
name|ix
operator|<
name|priority_len
operator|+
name|tto
condition|;
name|ix
operator|++
control|)
block|{
if|if
condition|(
name|tto
condition|)
name|priority_list
index|[
name|ix
operator|-
name|tto
index|]
operator|=
name|priority_list
index|[
name|ix
index|]
expr_stmt|;
if|if
condition|(
name|priority_list
index|[
name|i
index|]
operator|==
name|priority_list
index|[
name|ix
index|]
condition|)
block|{
name|tto
operator|++
expr_stmt|;
name|priority_len
operator|--
expr_stmt|;
block|}
block|}
block|}
comment|/* Copy out the options in the order that they appear in the 	   priority list... */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|priority_len
condition|;
name|i
operator|++
control|)
block|{
comment|/* Number of bytes left to store (some may already 	       have been stored by a previous pass). */
name|unsigned
name|length
decl_stmt|;
name|int
name|optstart
decl_stmt|;
name|struct
name|universe
modifier|*
name|u
decl_stmt|;
name|int
name|have_encapsulation
init|=
literal|0
decl_stmt|;
name|struct
name|data_string
name|encapsulation
decl_stmt|;
name|memset
argument_list|(
operator|&
name|encapsulation
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|encapsulation
argument_list|)
expr_stmt|;
comment|/* Code for next option to try to store. */
name|code
operator|=
name|priority_list
index|[
name|i
index|]
expr_stmt|;
comment|/* Look up the option in the site option space if the code 	       is above the cutoff, otherwise in the DHCP option space. */
if|if
condition|(
name|code
operator|>=
name|cfg_options
operator|->
name|site_code_min
condition|)
name|u
operator|=
name|universes
index|[
name|cfg_options
operator|->
name|site_universe
index|]
expr_stmt|;
else|else
name|u
operator|=
operator|&
name|dhcp_universe
expr_stmt|;
name|oc
operator|=
name|lookup_option
argument_list|(
name|u
argument_list|,
name|cfg_options
argument_list|,
name|code
argument_list|)
expr_stmt|;
comment|/* It's an encapsulation, try to find the universe 	       to be encapsulated first, except that if it's a straight 	       encapsulation and the user has provided a value for the 	       encapsulation option, use the user-provided value. */
if|if
condition|(
name|u
operator|->
name|options
index|[
name|code
index|]
operator|&&
operator|(
operator|(
name|u
operator|->
name|options
index|[
name|code
index|]
operator|->
name|format
index|[
literal|0
index|]
operator|==
literal|'E'
operator|&&
operator|!
name|oc
operator|)
operator|||
name|u
operator|->
name|options
index|[
name|code
index|]
operator|->
name|format
index|[
literal|0
index|]
operator|==
literal|'e'
operator|)
condition|)
block|{
name|int
name|uix
decl_stmt|;
specifier|static
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|struct
name|option_cache
modifier|*
name|tmp
decl_stmt|;
name|struct
name|data_string
name|name
decl_stmt|;
name|s
operator|=
name|strchr
argument_list|(
name|u
operator|->
name|options
index|[
name|code
index|]
operator|->
name|format
argument_list|,
literal|'E'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|t
operator|=
name|strchr
argument_list|(
operator|++
name|s
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&&
name|t
condition|)
block|{
name|memset
argument_list|(
operator|&
name|name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|name
argument_list|)
expr_stmt|;
comment|/* A zero-length universe name means the vendor 		       option space, if one is defined. */
if|if
condition|(
name|t
operator|==
name|s
condition|)
block|{
if|if
condition|(
name|vendor_cfg_option
condition|)
block|{
name|tmp
operator|=
name|lookup_option
argument_list|(
name|vendor_cfg_option
operator|->
name|universe
argument_list|,
name|cfg_options
argument_list|,
name|vendor_cfg_option
operator|->
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
name|evaluate_option_cache
argument_list|(
operator|&
name|name
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|tmp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vuname
condition|)
block|{
name|name
operator|.
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
expr_stmt|;
name|name
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|name
operator|.
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
expr_stmt|;
name|name
operator|.
name|len
operator|=
name|t
operator|-
name|s
expr_stmt|;
block|}
comment|/* If we found a universe, and there are options configured 		       for that universe, try to encapsulate it. */
if|if
condition|(
name|name
operator|.
name|len
condition|)
block|{
name|have_encapsulation
operator|=
operator|(
name|option_space_encapsulate
argument_list|(
operator|&
name|encapsulation
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
operator|&
name|name
argument_list|)
operator|)
expr_stmt|;
name|data_string_forget
argument_list|(
operator|&
name|name
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* In order to avoid memory leaks, we have to get to here 	       with any option cache that we allocated in tmp not being 	       referenced by tmp, and whatever option cache is referenced 	       by oc being an actual reference.   lookup_option doesn't 	       generate a reference (this needs to be fixed), so the 	       preceding goop ensures that if we *didn't* generate a new 	       option cache, oc still winds up holding an actual reference. */
comment|/* If no data is available for this option, skip it. */
if|if
condition|(
operator|!
name|oc
operator|&&
operator|!
name|have_encapsulation
condition|)
block|{
continue|continue;
block|}
comment|/* Find the value of the option... */
if|if
condition|(
name|oc
condition|)
block|{
name|evaluate_option_cache
argument_list|(
operator|&
name|od
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|oc
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|od
operator|.
name|len
condition|)
block|{
name|data_string_forget
argument_list|(
operator|&
name|encapsulation
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|data_string_forget
argument_list|(
operator|&
name|od
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|have_encapsulation
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* We should now have a constant length for the option. */
name|length
operator|=
name|od
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|have_encapsulation
condition|)
block|{
name|length
operator|+=
name|encapsulation
operator|.
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|od
operator|.
name|len
condition|)
block|{
name|data_string_copy
argument_list|(
operator|&
name|od
argument_list|,
operator|&
name|encapsulation
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|data_string_forget
argument_list|(
operator|&
name|encapsulation
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|buffer
modifier|*
name|bp
init|=
operator|(
expr|struct
name|buffer
operator|*
operator|)
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|buffer_allocate
argument_list|(
operator|&
name|bp
argument_list|,
name|length
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
name|option_cache_dereference
argument_list|(
operator|&
name|oc
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|data_string_forget
argument_list|(
operator|&
name|od
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|data_string_forget
argument_list|(
operator|&
name|encapsulation
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|memcpy
argument_list|(
operator|&
name|bp
operator|->
name|data
index|[
literal|0
index|]
argument_list|,
name|od
operator|.
name|data
argument_list|,
name|od
operator|.
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|bp
operator|->
name|data
index|[
name|od
operator|.
name|len
index|]
argument_list|,
name|encapsulation
operator|.
name|data
argument_list|,
name|encapsulation
operator|.
name|len
argument_list|)
expr_stmt|;
name|data_string_forget
argument_list|(
operator|&
name|od
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|data_string_forget
argument_list|(
operator|&
name|encapsulation
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|od
operator|.
name|data
operator|=
operator|&
name|bp
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|buffer_reference
argument_list|(
operator|&
name|od
operator|.
name|buffer
argument_list|,
name|bp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|buffer_dereference
argument_list|(
operator|&
name|bp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|od
operator|.
name|len
operator|=
name|length
expr_stmt|;
name|od
operator|.
name|terminated
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Do we add a NUL? */
if|if
condition|(
name|terminate
operator|&&
name|dhcp_options
index|[
name|code
index|]
operator|.
name|format
index|[
literal|0
index|]
operator|==
literal|'t'
condition|)
block|{
name|length
operator|++
expr_stmt|;
name|tto
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tto
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Try to store the option. */
comment|/* If the option's length is more than 255, we must store it 	       in multiple hunks.   Store 255-byte hunks first.  However, 	       in any case, if the option data will cross a buffer 	       boundary, split it across that boundary. */
name|ix
operator|=
literal|0
expr_stmt|;
name|optstart
operator|=
name|bufix
expr_stmt|;
while|while
condition|(
name|length
condition|)
block|{
name|unsigned
name|char
name|incr
init|=
name|length
operator|>
literal|255
condition|?
literal|255
else|:
name|length
decl_stmt|;
name|int
name|consumed
init|=
literal|0
decl_stmt|;
comment|/* If this hunk of the buffer will cross a 		       boundary, only go up to the boundary in this 		       pass. */
if|if
condition|(
name|bufix
operator|<
name|first_cutoff
operator|&&
name|bufix
operator|+
name|incr
operator|>
name|first_cutoff
condition|)
name|incr
operator|=
name|first_cutoff
operator|-
name|bufix
expr_stmt|;
elseif|else
if|if
condition|(
name|bufix
operator|<
name|second_cutoff
operator|&&
name|bufix
operator|+
name|incr
operator|>
name|second_cutoff
condition|)
name|incr
operator|=
name|second_cutoff
operator|-
name|bufix
expr_stmt|;
comment|/* If this option is going to overflow the buffer, 		       skip it. */
if|if
condition|(
name|bufix
operator|+
literal|2
operator|+
name|incr
operator|>
name|buflen
condition|)
block|{
name|bufix
operator|=
name|optstart
expr_stmt|;
break|break;
block|}
comment|/* Everything looks good - copy it in! */
name|buffer
index|[
name|bufix
index|]
operator|=
name|code
expr_stmt|;
name|buffer
index|[
name|bufix
operator|+
literal|1
index|]
operator|=
name|incr
expr_stmt|;
if|if
condition|(
name|tto
operator|&&
name|incr
operator|==
name|length
condition|)
block|{
name|memcpy
argument_list|(
name|buffer
operator|+
name|bufix
operator|+
literal|2
argument_list|,
name|od
operator|.
name|data
operator|+
name|ix
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|incr
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
index|[
name|bufix
operator|+
literal|2
operator|+
name|incr
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|buffer
operator|+
name|bufix
operator|+
literal|2
argument_list|,
name|od
operator|.
name|data
operator|+
name|ix
argument_list|,
operator|(
name|unsigned
operator|)
name|incr
argument_list|)
expr_stmt|;
block|}
name|length
operator|-=
name|incr
expr_stmt|;
name|ix
operator|+=
name|incr
expr_stmt|;
name|bufix
operator|+=
literal|2
operator|+
name|incr
expr_stmt|;
block|}
name|data_string_forget
argument_list|(
operator|&
name|od
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
return|return
name|bufix
return|;
block|}
end_function

begin_comment
comment|/* Format the specified option so that a human can easily read it. */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|pretty_print_option
parameter_list|(
name|option
parameter_list|,
name|data
parameter_list|,
name|len
parameter_list|,
name|emit_commas
parameter_list|,
name|emit_quotes
parameter_list|)
name|struct
name|option
modifier|*
name|option
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|int
name|emit_commas
decl_stmt|;
name|int
name|emit_quotes
decl_stmt|;
block|{
specifier|static
name|char
name|optbuf
index|[
literal|32768
index|]
decl_stmt|;
comment|/* XXX */
name|int
name|hunksize
init|=
literal|0
decl_stmt|;
name|int
name|opthunk
init|=
literal|0
decl_stmt|;
name|int
name|hunkinc
init|=
literal|0
decl_stmt|;
name|int
name|numhunk
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|numelem
init|=
literal|0
decl_stmt|;
name|char
name|fmtbuf
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|enumeration
modifier|*
name|enumbuf
index|[
literal|32
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|l
decl_stmt|;
name|char
modifier|*
name|op
init|=
name|optbuf
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|dp
init|=
name|data
decl_stmt|;
name|struct
name|in_addr
name|foo
decl_stmt|;
name|char
name|comma
decl_stmt|;
name|unsigned
name|long
name|tval
decl_stmt|;
if|if
condition|(
name|emit_commas
condition|)
name|comma
operator|=
literal|','
expr_stmt|;
else|else
name|comma
operator|=
literal|' '
expr_stmt|;
name|memset
argument_list|(
name|enumbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|enumbuf
argument_list|)
expr_stmt|;
comment|/* Figure out the size of the data. */
for|for
control|(
name|l
operator|=
name|i
operator|=
literal|0
init|;
name|option
operator|->
name|format
index|[
name|i
index|]
condition|;
name|i
operator|++
operator|,
name|l
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|numhunk
condition|)
block|{
name|log_error
argument_list|(
literal|"%s: Extra codes in format string: %s"
argument_list|,
name|option
operator|->
name|name
argument_list|,
operator|&
operator|(
name|option
operator|->
name|format
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|numelem
operator|++
expr_stmt|;
name|fmtbuf
index|[
name|l
index|]
operator|=
name|option
operator|->
name|format
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|option
operator|->
name|format
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'a'
case|:
operator|--
name|numelem
expr_stmt|;
name|fmtbuf
index|[
name|l
index|]
operator|=
literal|0
expr_stmt|;
name|numhunk
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
operator|--
name|numelem
expr_stmt|;
name|fmtbuf
index|[
name|l
index|]
operator|=
literal|0
expr_stmt|;
name|numhunk
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* Skip the universe name. */
while|while
condition|(
name|option
operator|->
name|format
index|[
name|i
index|]
operator|&&
name|option
operator|->
name|format
index|[
name|i
index|]
operator|!=
literal|'.'
condition|)
name|i
operator|++
expr_stmt|;
case|case
literal|'X'
case|:
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|len
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isascii
argument_list|(
name|data
index|[
name|k
index|]
argument_list|)
operator|||
operator|!
name|isprint
argument_list|(
name|data
index|[
name|k
index|]
argument_list|)
condition|)
break|break;
block|}
comment|/* If we found no bogus characters, or the bogus 			   character we found is a trailing NUL, it's 			   okay to print this option as text. */
if|if
condition|(
name|k
operator|==
name|len
operator|||
operator|(
name|k
operator|+
literal|1
operator|==
name|len
operator|&&
name|data
index|[
name|k
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|fmtbuf
index|[
name|l
index|]
operator|=
literal|'t'
expr_stmt|;
name|numhunk
operator|=
operator|-
literal|2
expr_stmt|;
block|}
else|else
block|{
name|fmtbuf
index|[
name|l
index|]
operator|=
literal|'x'
expr_stmt|;
name|hunksize
operator|++
expr_stmt|;
name|comma
operator|=
literal|':'
expr_stmt|;
name|numhunk
operator|=
literal|0
expr_stmt|;
block|}
name|fmtbuf
index|[
name|l
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'t'
case|:
name|fmtbuf
index|[
name|l
index|]
operator|=
literal|'t'
expr_stmt|;
name|fmtbuf
index|[
name|l
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|numhunk
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|k
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|option
operator|->
name|format
index|[
name|i
index|]
operator|&&
name|option
operator|->
name|format
index|[
name|i
index|]
operator|!=
literal|'.'
condition|)
name|i
operator|++
expr_stmt|;
name|enumbuf
index|[
name|l
index|]
operator|=
name|find_enumeration
argument_list|(
operator|&
name|option
operator|->
name|format
index|[
name|k
index|]
operator|+
literal|1
argument_list|,
name|i
operator|-
name|k
operator|-
literal|1
argument_list|)
expr_stmt|;
name|hunksize
operator|+=
literal|1
expr_stmt|;
name|hunkinc
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
case|case
literal|'T'
case|:
name|hunksize
operator|+=
literal|4
expr_stmt|;
name|hunkinc
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|hunksize
operator|+=
literal|2
expr_stmt|;
name|hunkinc
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
case|case
literal|'f'
case|:
name|hunksize
operator|++
expr_stmt|;
name|hunkinc
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
break|break;
case|case
literal|'o'
case|:
name|opthunk
operator|+=
name|hunkinc
expr_stmt|;
break|break;
default|default:
name|log_error
argument_list|(
literal|"%s: garbage in format string: %s"
argument_list|,
name|option
operator|->
name|name
argument_list|,
operator|&
operator|(
name|option
operator|->
name|format
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Check for too few bytes... */
if|if
condition|(
name|hunksize
operator|-
name|opthunk
operator|>
name|len
condition|)
block|{
name|log_error
argument_list|(
literal|"%s: expecting at least %d bytes; got %d"
argument_list|,
name|option
operator|->
name|name
argument_list|,
name|hunksize
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|"<error>"
return|;
block|}
comment|/* Check for too many bytes... */
if|if
condition|(
name|numhunk
operator|==
operator|-
literal|1
operator|&&
name|hunksize
operator|<
name|len
condition|)
name|log_error
argument_list|(
literal|"%s: %d extra bytes"
argument_list|,
name|option
operator|->
name|name
argument_list|,
name|len
operator|-
name|hunksize
argument_list|)
expr_stmt|;
comment|/* If this is an array, compute its size. */
if|if
condition|(
operator|!
name|numhunk
condition|)
name|numhunk
operator|=
name|len
operator|/
name|hunksize
expr_stmt|;
comment|/* See if we got an exact number of hunks. */
if|if
condition|(
name|numhunk
operator|>
literal|0
operator|&&
name|numhunk
operator|*
name|hunksize
operator|<
name|len
condition|)
name|log_error
argument_list|(
literal|"%s: %d extra bytes at end of array\n"
argument_list|,
name|option
operator|->
name|name
argument_list|,
name|len
operator|-
name|numhunk
operator|*
name|hunksize
argument_list|)
expr_stmt|;
comment|/* A one-hunk array prints the same as a single hunk. */
if|if
condition|(
name|numhunk
operator|<
literal|0
condition|)
name|numhunk
operator|=
literal|1
expr_stmt|;
comment|/* Cycle through the array (or hunk) printing the data. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numhunk
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numelem
condition|;
name|j
operator|++
control|)
block|{
switch|switch
condition|(
name|fmtbuf
index|[
name|j
index|]
condition|)
block|{
case|case
literal|'t'
case|:
if|if
condition|(
name|emit_quotes
condition|)
operator|*
name|op
operator|++
operator|=
literal|'"'
expr_stmt|;
for|for
control|(
init|;
name|dp
operator|<
name|data
operator|+
name|len
condition|;
name|dp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|dp
argument_list|)
operator|||
operator|!
name|isprint
argument_list|(
operator|*
name|dp
argument_list|)
condition|)
block|{
comment|/* Skip trailing NUL. */
if|if
condition|(
name|dp
operator|+
literal|1
operator|!=
name|data
operator|+
name|len
operator|||
operator|*
name|dp
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"\\%03o"
argument_list|,
operator|*
name|dp
argument_list|)
expr_stmt|;
name|op
operator|+=
literal|4
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|dp
operator|==
literal|'"'
operator|||
operator|*
name|dp
operator|==
literal|'\''
operator|||
operator|*
name|dp
operator|==
literal|'$'
operator|||
operator|*
name|dp
operator|==
literal|'`'
operator|||
operator|*
name|dp
operator|==
literal|'\\'
condition|)
block|{
operator|*
name|op
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|op
operator|++
operator|=
operator|*
name|dp
expr_stmt|;
block|}
else|else
operator|*
name|op
operator|++
operator|=
operator|*
name|dp
expr_stmt|;
block|}
if|if
condition|(
name|emit_quotes
condition|)
operator|*
name|op
operator|++
operator|=
literal|'"'
expr_stmt|;
operator|*
name|op
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* pretty-printing an array of enums is 				   going to get ugly. */
case|case
literal|'N'
case|:
if|if
condition|(
operator|!
name|enumbuf
index|[
name|j
index|]
condition|)
goto|goto
name|enum_as_num
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|enumbuf
index|[
name|j
index|]
operator|->
name|values
index|[
name|i
index|]
operator|.
name|name
condition|)
goto|goto
name|enum_as_num
goto|;
if|if
condition|(
name|enumbuf
index|[
name|j
index|]
operator|->
name|values
index|[
name|i
index|]
operator|.
name|value
operator|==
operator|*
name|dp
condition|)
break|break;
block|}
name|strcpy
argument_list|(
name|op
argument_list|,
name|enumbuf
index|[
name|j
index|]
operator|->
name|values
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|foo
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|getULong
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|op
argument_list|,
name|inet_ntoa
argument_list|(
name|foo
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|getLong
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|tval
operator|=
name|getULong
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tval
operator|==
operator|-
literal|1
condition|)
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"%s"
argument_list|,
literal|"infinite"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"%ld"
argument_list|,
name|tval
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|getULong
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|getShort
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|unsigned
operator|)
name|getUShort
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"%d"
argument_list|,
operator|*
operator|(
specifier|const
name|char
operator|*
operator|)
name|dp
operator|++
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|enum_as_num
label|:
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"%d"
argument_list|,
operator|*
name|dp
operator|++
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"%x"
argument_list|,
operator|*
name|dp
operator|++
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|strcpy
argument_list|(
name|op
argument_list|,
operator|*
name|dp
operator|++
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log_error
argument_list|(
literal|"Unexpected format code %c"
argument_list|,
name|fmtbuf
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|data
operator|+
name|len
condition|)
break|break;
if|if
condition|(
name|j
operator|+
literal|1
operator|<
name|numelem
operator|&&
name|comma
operator|!=
literal|':'
condition|)
operator|*
name|op
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|numhunk
condition|)
block|{
operator|*
name|op
operator|++
operator|=
name|comma
expr_stmt|;
block|}
if|if
condition|(
name|dp
operator|==
name|data
operator|+
name|len
condition|)
break|break;
block|}
return|return
name|optbuf
return|;
block|}
end_function

begin_function
name|int
name|get_option
parameter_list|(
name|result
parameter_list|,
name|universe
parameter_list|,
name|packet
parameter_list|,
name|lease
parameter_list|,
name|client_state
parameter_list|,
name|in_options
parameter_list|,
name|cfg_options
parameter_list|,
name|options
parameter_list|,
name|scope
parameter_list|,
name|code
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|struct
name|data_string
modifier|*
name|result
decl_stmt|;
name|struct
name|universe
modifier|*
name|universe
decl_stmt|;
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
name|struct
name|lease
modifier|*
name|lease
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client_state
decl_stmt|;
name|struct
name|option_state
modifier|*
name|in_options
decl_stmt|;
name|struct
name|option_state
modifier|*
name|cfg_options
decl_stmt|;
name|struct
name|option_state
modifier|*
name|options
decl_stmt|;
name|struct
name|binding_scope
modifier|*
modifier|*
name|scope
decl_stmt|;
name|unsigned
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|struct
name|option_cache
modifier|*
name|oc
decl_stmt|;
if|if
condition|(
operator|!
name|universe
operator|->
name|lookup_func
condition|)
return|return
literal|0
return|;
name|oc
operator|=
operator|(
call|(
modifier|*
name|universe
operator|->
name|lookup_func
call|)
argument_list|(
name|universe
argument_list|,
name|options
argument_list|,
name|code
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|oc
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|evaluate_option_cache
argument_list|(
name|result
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|oc
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|set_option
parameter_list|(
name|universe
parameter_list|,
name|options
parameter_list|,
name|option
parameter_list|,
name|op
parameter_list|)
name|struct
name|universe
modifier|*
name|universe
decl_stmt|;
name|struct
name|option_state
modifier|*
name|options
decl_stmt|;
name|struct
name|option_cache
modifier|*
name|option
decl_stmt|;
name|enum
name|statement_op
name|op
decl_stmt|;
block|{
name|struct
name|option_cache
modifier|*
name|oc
decl_stmt|,
modifier|*
name|noc
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|if_statement
case|:
case|case
name|add_statement
case|:
case|case
name|eval_statement
case|:
case|case
name|break_statement
case|:
default|default:
name|log_error
argument_list|(
literal|"bogus statement type in do_option_set."
argument_list|)
expr_stmt|;
break|break;
case|case
name|default_option_statement
case|:
name|oc
operator|=
name|lookup_option
argument_list|(
name|universe
argument_list|,
name|options
argument_list|,
name|option
operator|->
name|option
operator|->
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|oc
condition|)
break|break;
name|save_option
argument_list|(
name|universe
argument_list|,
name|options
argument_list|,
name|option
argument_list|)
expr_stmt|;
break|break;
case|case
name|supersede_option_statement
case|:
case|case
name|send_option_statement
case|:
comment|/* Install the option, replacing any existing version. */
name|save_option
argument_list|(
name|universe
argument_list|,
name|options
argument_list|,
name|option
argument_list|)
expr_stmt|;
break|break;
case|case
name|append_option_statement
case|:
case|case
name|prepend_option_statement
case|:
name|oc
operator|=
name|lookup_option
argument_list|(
name|universe
argument_list|,
name|options
argument_list|,
name|option
operator|->
name|option
operator|->
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oc
condition|)
block|{
name|save_option
argument_list|(
name|universe
argument_list|,
name|options
argument_list|,
name|option
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If it's not an expression, make it into one. */
if|if
condition|(
operator|!
name|oc
operator|->
name|expression
operator|&&
name|oc
operator|->
name|data
operator|.
name|len
condition|)
block|{
if|if
condition|(
operator|!
name|expression_allocate
argument_list|(
operator|&
name|oc
operator|->
name|expression
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
literal|"Can't allocate const expression."
argument_list|)
expr_stmt|;
break|break;
block|}
name|oc
operator|->
name|expression
operator|->
name|op
operator|=
name|expr_const_data
expr_stmt|;
name|data_string_copy
argument_list|(
operator|&
name|oc
operator|->
name|expression
operator|->
name|data
operator|.
name|const_data
argument_list|,
operator|&
name|oc
operator|->
name|data
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|data_string_forget
argument_list|(
operator|&
name|oc
operator|->
name|data
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
name|noc
operator|=
operator|(
expr|struct
name|option_cache
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|option_cache_allocate
argument_list|(
operator|&
name|noc
argument_list|,
name|MDL
argument_list|)
condition|)
break|break;
if|if
condition|(
name|op
operator|==
name|append_option_statement
condition|)
block|{
if|if
condition|(
operator|!
name|make_concat
argument_list|(
operator|&
name|noc
operator|->
name|expression
argument_list|,
name|oc
operator|->
name|expression
argument_list|,
name|option
operator|->
name|expression
argument_list|)
condition|)
block|{
name|option_cache_dereference
argument_list|(
operator|&
name|noc
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|make_concat
argument_list|(
operator|&
name|noc
operator|->
name|expression
argument_list|,
name|option
operator|->
name|expression
argument_list|,
name|oc
operator|->
name|expression
argument_list|)
condition|)
block|{
name|option_cache_dereference
argument_list|(
operator|&
name|noc
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|noc
operator|->
name|option
operator|=
name|oc
operator|->
name|option
expr_stmt|;
name|save_option
argument_list|(
name|universe
argument_list|,
name|options
argument_list|,
name|noc
argument_list|)
expr_stmt|;
name|option_cache_dereference
argument_list|(
operator|&
name|noc
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|struct
name|option_cache
modifier|*
name|lookup_option
parameter_list|(
name|universe
parameter_list|,
name|options
parameter_list|,
name|code
parameter_list|)
name|struct
name|universe
modifier|*
name|universe
decl_stmt|;
name|struct
name|option_state
modifier|*
name|options
decl_stmt|;
name|unsigned
name|code
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|options
condition|)
return|return
operator|(
expr|struct
name|option_cache
operator|*
operator|)
literal|0
return|;
if|if
condition|(
name|universe
operator|->
name|lookup_func
condition|)
return|return
call|(
modifier|*
name|universe
operator|->
name|lookup_func
call|)
argument_list|(
name|universe
argument_list|,
name|options
argument_list|,
name|code
argument_list|)
return|;
else|else
name|log_error
argument_list|(
literal|"can't look up options in %s space."
argument_list|,
name|universe
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|option_cache
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|option_cache
modifier|*
name|lookup_hashed_option
parameter_list|(
name|universe
parameter_list|,
name|options
parameter_list|,
name|code
parameter_list|)
name|struct
name|universe
modifier|*
name|universe
decl_stmt|;
name|struct
name|option_state
modifier|*
name|options
decl_stmt|;
name|unsigned
name|code
decl_stmt|;
block|{
name|int
name|hashix
decl_stmt|;
name|pair
name|bptr
decl_stmt|;
name|pair
modifier|*
name|hash
decl_stmt|;
comment|/* Make sure there's a hash table. */
if|if
condition|(
name|universe
operator|->
name|index
operator|>=
name|options
operator|->
name|universe_count
operator|||
operator|!
operator|(
name|options
operator|->
name|universes
index|[
name|universe
operator|->
name|index
index|]
operator|)
condition|)
return|return
operator|(
expr|struct
name|option_cache
operator|*
operator|)
literal|0
return|;
name|hash
operator|=
name|options
operator|->
name|universes
index|[
name|universe
operator|->
name|index
index|]
expr_stmt|;
name|hashix
operator|=
name|compute_option_hash
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|bptr
operator|=
name|hash
index|[
name|hashix
index|]
init|;
name|bptr
condition|;
name|bptr
operator|=
name|bptr
operator|->
name|cdr
control|)
block|{
if|if
condition|(
operator|(
operator|(
expr|struct
name|option_cache
operator|*
operator|)
operator|(
name|bptr
operator|->
name|car
operator|)
operator|)
operator|->
name|option
operator|->
name|code
operator|==
name|code
condition|)
return|return
operator|(
expr|struct
name|option_cache
operator|*
operator|)
operator|(
name|bptr
operator|->
name|car
operator|)
return|;
block|}
return|return
operator|(
expr|struct
name|option_cache
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_function
name|int
name|save_option_buffer
parameter_list|(
name|struct
name|universe
modifier|*
name|universe
parameter_list|,
name|struct
name|option_state
modifier|*
name|options
parameter_list|,
name|struct
name|buffer
modifier|*
name|bp
parameter_list|,
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|,
name|unsigned
name|length
parameter_list|,
name|struct
name|option
modifier|*
name|option
parameter_list|,
name|int
name|tp
parameter_list|)
block|{
name|struct
name|buffer
modifier|*
name|lbp
init|=
operator|(
expr|struct
name|buffer
operator|*
operator|)
literal|0
decl_stmt|;
name|struct
name|option_cache
modifier|*
name|op
init|=
operator|(
expr|struct
name|option_cache
operator|*
operator|)
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|option_cache_allocate
argument_list|(
operator|&
name|op
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
literal|"No memory for option %s.%s."
argument_list|,
name|universe
operator|->
name|name
argument_list|,
name|option
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If we weren't passed a buffer in which the data are saved and 	   refcounted, allocate one now. */
if|if
condition|(
operator|!
name|bp
condition|)
block|{
if|if
condition|(
operator|!
name|buffer_allocate
argument_list|(
operator|&
name|lbp
argument_list|,
name|length
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
literal|"no memory for option buffer."
argument_list|)
expr_stmt|;
name|option_cache_dereference
argument_list|(
operator|&
name|op
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memcpy
argument_list|(
name|lbp
operator|->
name|data
argument_list|,
name|buffer
argument_list|,
name|length
operator|+
name|tp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|lbp
expr_stmt|;
name|buffer
operator|=
operator|&
name|bp
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
comment|/* Refer to saved buffer. */
block|}
comment|/* Reference buffer copy to option cache. */
name|op
operator|->
name|data
operator|.
name|buffer
operator|=
operator|(
expr|struct
name|buffer
operator|*
operator|)
literal|0
expr_stmt|;
name|buffer_reference
argument_list|(
operator|&
name|op
operator|->
name|data
operator|.
name|buffer
argument_list|,
name|bp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
comment|/* Point option cache into buffer. */
name|op
operator|->
name|data
operator|.
name|data
operator|=
name|buffer
expr_stmt|;
name|op
operator|->
name|data
operator|.
name|len
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|tp
condition|)
block|{
comment|/* NUL terminate (we can get away with this because we (or 		   the caller!) allocated one more than the buffer size, and 		   because the byte following the end of an option is always 		   the code of the next option, which the caller is getting 		   out of the *original* buffer. */
name|buffer
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|data
operator|.
name|terminated
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|op
operator|->
name|data
operator|.
name|terminated
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|option
operator|=
name|option
expr_stmt|;
comment|/* Now store the option. */
name|save_option
argument_list|(
name|universe
argument_list|,
name|options
argument_list|,
name|op
argument_list|)
expr_stmt|;
comment|/* And let go of our reference. */
name|option_cache_dereference
argument_list|(
operator|&
name|op
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|save_option
parameter_list|(
name|struct
name|universe
modifier|*
name|universe
parameter_list|,
name|struct
name|option_state
modifier|*
name|options
parameter_list|,
name|struct
name|option_cache
modifier|*
name|oc
parameter_list|)
block|{
if|if
condition|(
name|universe
operator|->
name|save_func
condition|)
call|(
modifier|*
name|universe
operator|->
name|save_func
call|)
argument_list|(
name|universe
argument_list|,
name|options
argument_list|,
name|oc
argument_list|)
expr_stmt|;
else|else
name|log_error
argument_list|(
literal|"can't store options in %s space."
argument_list|,
name|universe
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|save_hashed_option
parameter_list|(
name|universe
parameter_list|,
name|options
parameter_list|,
name|oc
parameter_list|)
name|struct
name|universe
modifier|*
name|universe
decl_stmt|;
name|struct
name|option_state
modifier|*
name|options
decl_stmt|;
name|struct
name|option_cache
modifier|*
name|oc
decl_stmt|;
block|{
name|int
name|hashix
decl_stmt|;
name|pair
name|bptr
decl_stmt|;
name|pair
modifier|*
name|hash
init|=
name|options
operator|->
name|universes
index|[
name|universe
operator|->
name|index
index|]
decl_stmt|;
if|if
condition|(
name|oc
operator|->
name|refcnt
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Compute the hash. */
name|hashix
operator|=
name|compute_option_hash
argument_list|(
name|oc
operator|->
name|option
operator|->
name|code
argument_list|)
expr_stmt|;
comment|/* If there's no hash table, make one. */
if|if
condition|(
operator|!
name|hash
condition|)
block|{
name|hash
operator|=
operator|(
name|pair
operator|*
operator|)
name|dmalloc
argument_list|(
name|OPTION_HASH_SIZE
operator|*
sizeof|sizeof
expr|*
name|hash
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hash
condition|)
block|{
name|log_error
argument_list|(
literal|"no memory to store %s.%s"
argument_list|,
name|universe
operator|->
name|name
argument_list|,
name|oc
operator|->
name|option
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
name|hash
argument_list|,
literal|0
argument_list|,
name|OPTION_HASH_SIZE
operator|*
sizeof|sizeof
expr|*
name|hash
argument_list|)
expr_stmt|;
name|options
operator|->
name|universes
index|[
name|universe
operator|->
name|index
index|]
operator|=
operator|(
name|VOIDPTR
operator|)
name|hash
expr_stmt|;
block|}
else|else
block|{
comment|/* Try to find an existing option matching the new one. */
for|for
control|(
name|bptr
operator|=
name|hash
index|[
name|hashix
index|]
init|;
name|bptr
condition|;
name|bptr
operator|=
name|bptr
operator|->
name|cdr
control|)
block|{
if|if
condition|(
operator|(
operator|(
expr|struct
name|option_cache
operator|*
operator|)
operator|(
name|bptr
operator|->
name|car
operator|)
operator|)
operator|->
name|option
operator|->
name|code
operator|==
name|oc
operator|->
name|option
operator|->
name|code
condition|)
break|break;
block|}
comment|/* If we find one, dereference it and put the new one 		   in its place. */
if|if
condition|(
name|bptr
condition|)
block|{
name|option_cache_dereference
argument_list|(
operator|(
expr|struct
name|option_cache
operator|*
operator|*
operator|)
operator|&
name|bptr
operator|->
name|car
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|option_cache_reference
argument_list|(
operator|(
expr|struct
name|option_cache
operator|*
operator|*
operator|)
operator|&
name|bptr
operator|->
name|car
argument_list|,
name|oc
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Otherwise, just put the new one at the head of the list. */
name|bptr
operator|=
name|new_pair
argument_list|(
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bptr
condition|)
block|{
name|log_error
argument_list|(
literal|"No memory for option_cache reference."
argument_list|)
expr_stmt|;
return|return;
block|}
name|bptr
operator|->
name|cdr
operator|=
name|hash
index|[
name|hashix
index|]
expr_stmt|;
name|bptr
operator|->
name|car
operator|=
literal|0
expr_stmt|;
name|option_cache_reference
argument_list|(
operator|(
expr|struct
name|option_cache
operator|*
operator|*
operator|)
operator|&
name|bptr
operator|->
name|car
argument_list|,
name|oc
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|hash
index|[
name|hashix
index|]
operator|=
name|bptr
expr_stmt|;
block|}
end_function

begin_function
name|void
name|delete_option
parameter_list|(
name|universe
parameter_list|,
name|options
parameter_list|,
name|code
parameter_list|)
name|struct
name|universe
modifier|*
name|universe
decl_stmt|;
name|struct
name|option_state
modifier|*
name|options
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
if|if
condition|(
name|universe
operator|->
name|delete_func
condition|)
call|(
modifier|*
name|universe
operator|->
name|delete_func
call|)
argument_list|(
name|universe
argument_list|,
name|options
argument_list|,
name|code
argument_list|)
expr_stmt|;
else|else
name|log_error
argument_list|(
literal|"can't delete options from %s space."
argument_list|,
name|universe
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|delete_hashed_option
parameter_list|(
name|universe
parameter_list|,
name|options
parameter_list|,
name|code
parameter_list|)
name|struct
name|universe
modifier|*
name|universe
decl_stmt|;
name|struct
name|option_state
modifier|*
name|options
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
name|int
name|hashix
decl_stmt|;
name|pair
name|bptr
decl_stmt|,
name|prev
init|=
operator|(
name|pair
operator|)
literal|0
decl_stmt|;
name|pair
modifier|*
name|hash
init|=
name|options
operator|->
name|universes
index|[
name|universe
operator|->
name|index
index|]
decl_stmt|;
comment|/* There may not be any options in this space. */
if|if
condition|(
operator|!
name|hash
condition|)
return|return;
comment|/* Try to find an existing option matching the new one. */
name|hashix
operator|=
name|compute_option_hash
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|bptr
operator|=
name|hash
index|[
name|hashix
index|]
init|;
name|bptr
condition|;
name|bptr
operator|=
name|bptr
operator|->
name|cdr
control|)
block|{
if|if
condition|(
operator|(
operator|(
expr|struct
name|option_cache
operator|*
operator|)
operator|(
name|bptr
operator|->
name|car
operator|)
operator|)
operator|->
name|option
operator|->
name|code
operator|==
name|code
condition|)
break|break;
name|prev
operator|=
name|bptr
expr_stmt|;
block|}
comment|/* If we found one, wipe it out... */
if|if
condition|(
name|bptr
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|cdr
operator|=
name|bptr
operator|->
name|cdr
expr_stmt|;
else|else
name|hash
index|[
name|hashix
index|]
operator|=
name|bptr
operator|->
name|cdr
expr_stmt|;
name|option_cache_dereference
argument_list|(
operator|(
expr|struct
name|option_cache
operator|*
operator|*
operator|)
operator|(
operator|&
name|bptr
operator|->
name|car
operator|)
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|free_pair
argument_list|(
name|bptr
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|extern
name|struct
name|option_cache
modifier|*
name|free_option_caches
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_function
name|int
name|option_cache_dereference
parameter_list|(
name|ptr
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|struct
name|option_cache
modifier|*
modifier|*
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|ptr
operator|||
operator|!
operator|*
name|ptr
condition|)
block|{
name|log_error
argument_list|(
literal|"Null pointer in option_cache_dereference: %s(%d)"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
operator|(
operator|*
name|ptr
operator|)
operator|->
name|refcnt
operator|--
expr_stmt|;
name|rc_register
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|ptr
argument_list|,
operator|*
name|ptr
argument_list|,
operator|(
operator|*
name|ptr
operator|)
operator|->
name|refcnt
argument_list|,
literal|1
argument_list|,
name|RC_MISC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|ptr
operator|)
operator|->
name|refcnt
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|ptr
operator|)
operator|->
name|data
operator|.
name|buffer
condition|)
name|data_string_forget
argument_list|(
operator|&
operator|(
operator|*
name|ptr
operator|)
operator|->
name|data
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|ptr
operator|)
operator|->
name|expression
condition|)
name|expression_dereference
argument_list|(
operator|&
operator|(
operator|*
name|ptr
operator|)
operator|->
name|expression
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|ptr
operator|)
operator|->
name|next
condition|)
name|option_cache_dereference
argument_list|(
operator|&
operator|(
operator|(
operator|*
name|ptr
operator|)
operator|->
name|next
operator|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* Put it back on the free list... */
operator|(
operator|*
name|ptr
operator|)
operator|->
name|expression
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
name|free_option_caches
expr_stmt|;
name|free_option_caches
operator|=
operator|*
name|ptr
expr_stmt|;
name|dmalloc_reuse
argument_list|(
name|free_option_caches
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|ptr
operator|)
operator|->
name|refcnt
operator|<
literal|0
condition|)
block|{
name|log_error
argument_list|(
literal|"%s(%d): negative refcnt!"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_RC_HISTORY
argument_list|)
name|dump_rc_history
argument_list|(
operator|*
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|POINTER_DEBUG
argument_list|)
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
operator|*
name|ptr
operator|=
operator|(
expr|struct
name|option_cache
operator|*
operator|)
literal|0
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
operator|*
name|ptr
operator|=
operator|(
expr|struct
name|option_cache
operator|*
operator|)
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|hashed_option_state_dereference
parameter_list|(
name|universe
parameter_list|,
name|state
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|struct
name|universe
modifier|*
name|universe
decl_stmt|;
name|struct
name|option_state
modifier|*
name|state
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|pair
modifier|*
name|heads
decl_stmt|;
name|pair
name|cp
decl_stmt|,
name|next
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Get the pointer to the array of hash table bucket heads. */
name|heads
operator|=
operator|(
name|pair
operator|*
operator|)
operator|(
name|state
operator|->
name|universes
index|[
name|universe
operator|->
name|index
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|heads
condition|)
return|return
literal|0
return|;
comment|/* For each non-null head, loop through all the buckets dereferencing 	   the attached option cache structures and freeing the buckets. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OPTION_HASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|cp
operator|=
name|heads
index|[
name|i
index|]
init|;
name|cp
condition|;
name|cp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|cp
operator|->
name|cdr
expr_stmt|;
name|option_cache_dereference
argument_list|(
operator|(
expr|struct
name|option_cache
operator|*
operator|*
operator|)
operator|&
name|cp
operator|->
name|car
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|free_pair
argument_list|(
name|cp
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
name|dfree
argument_list|(
name|heads
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|state
operator|->
name|universes
index|[
name|universe
operator|->
name|index
index|]
operator|=
operator|(
name|void
operator|*
operator|)
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|store_option
parameter_list|(
name|result
parameter_list|,
name|universe
parameter_list|,
name|packet
parameter_list|,
name|lease
parameter_list|,
name|client_state
parameter_list|,
name|in_options
parameter_list|,
name|cfg_options
parameter_list|,
name|scope
parameter_list|,
name|oc
parameter_list|)
name|struct
name|data_string
modifier|*
name|result
decl_stmt|;
name|struct
name|universe
modifier|*
name|universe
decl_stmt|;
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
name|struct
name|lease
modifier|*
name|lease
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client_state
decl_stmt|;
name|struct
name|option_state
modifier|*
name|in_options
decl_stmt|;
name|struct
name|option_state
modifier|*
name|cfg_options
decl_stmt|;
name|struct
name|binding_scope
modifier|*
modifier|*
name|scope
decl_stmt|;
name|struct
name|option_cache
modifier|*
name|oc
decl_stmt|;
block|{
name|struct
name|data_string
name|d1
decl_stmt|,
name|d2
decl_stmt|;
name|memset
argument_list|(
operator|&
name|d1
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|d1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|d2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|d2
argument_list|)
expr_stmt|;
if|if
condition|(
name|evaluate_option_cache
argument_list|(
operator|&
name|d2
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|oc
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|buffer_allocate
argument_list|(
operator|&
name|d1
operator|.
name|buffer
argument_list|,
operator|(
name|result
operator|->
name|len
operator|+
name|universe
operator|->
name|length_size
operator|+
name|universe
operator|->
name|tag_size
operator|+
name|d2
operator|.
name|len
operator|)
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
name|data_string_forget
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|data_string_forget
argument_list|(
operator|&
name|d2
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|d1
operator|.
name|data
operator|=
operator|&
name|d1
operator|.
name|buffer
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|len
condition|)
name|memcpy
argument_list|(
name|d1
operator|.
name|buffer
operator|->
name|data
argument_list|,
name|result
operator|->
name|data
argument_list|,
name|result
operator|->
name|len
argument_list|)
expr_stmt|;
name|d1
operator|.
name|len
operator|=
name|result
operator|->
name|len
expr_stmt|;
call|(
modifier|*
name|universe
operator|->
name|store_tag
call|)
argument_list|(
operator|&
name|d1
operator|.
name|buffer
operator|->
name|data
index|[
name|d1
operator|.
name|len
index|]
argument_list|,
name|oc
operator|->
name|option
operator|->
name|code
argument_list|)
expr_stmt|;
name|d1
operator|.
name|len
operator|+=
name|universe
operator|->
name|tag_size
expr_stmt|;
call|(
modifier|*
name|universe
operator|->
name|store_length
call|)
argument_list|(
operator|&
name|d1
operator|.
name|buffer
operator|->
name|data
index|[
name|d1
operator|.
name|len
index|]
argument_list|,
name|d2
operator|.
name|len
argument_list|)
expr_stmt|;
name|d1
operator|.
name|len
operator|+=
name|universe
operator|->
name|length_size
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|d1
operator|.
name|buffer
operator|->
name|data
index|[
name|d1
operator|.
name|len
index|]
argument_list|,
name|d2
operator|.
name|data
argument_list|,
name|d2
operator|.
name|len
argument_list|)
expr_stmt|;
name|d1
operator|.
name|len
operator|+=
name|d2
operator|.
name|len
expr_stmt|;
name|data_string_forget
argument_list|(
operator|&
name|d2
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|data_string_forget
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|data_string_copy
argument_list|(
name|result
argument_list|,
operator|&
name|d1
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|data_string_forget
argument_list|(
operator|&
name|d1
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|option_space_encapsulate
parameter_list|(
name|result
parameter_list|,
name|packet
parameter_list|,
name|lease
parameter_list|,
name|client_state
parameter_list|,
name|in_options
parameter_list|,
name|cfg_options
parameter_list|,
name|scope
parameter_list|,
name|name
parameter_list|)
name|struct
name|data_string
modifier|*
name|result
decl_stmt|;
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
name|struct
name|lease
modifier|*
name|lease
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client_state
decl_stmt|;
name|struct
name|option_state
modifier|*
name|in_options
decl_stmt|;
name|struct
name|option_state
modifier|*
name|cfg_options
decl_stmt|;
name|struct
name|binding_scope
modifier|*
modifier|*
name|scope
decl_stmt|;
name|struct
name|data_string
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|universe
modifier|*
name|u
decl_stmt|;
name|u
operator|=
operator|(
expr|struct
name|universe
operator|*
operator|)
literal|0
expr_stmt|;
name|universe_hash_lookup
argument_list|(
operator|&
name|u
argument_list|,
name|universe_hash
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|name
operator|->
name|data
argument_list|,
name|name
operator|->
name|len
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|u
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|u
operator|->
name|encapsulate
condition|)
return|return
call|(
modifier|*
name|u
operator|->
name|encapsulate
call|)
argument_list|(
name|result
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|u
argument_list|)
return|;
name|log_error
argument_list|(
literal|"encapsulation requested for %s with no support."
argument_list|,
name|name
operator|->
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|hashed_option_space_encapsulate
parameter_list|(
name|result
parameter_list|,
name|packet
parameter_list|,
name|lease
parameter_list|,
name|client_state
parameter_list|,
name|in_options
parameter_list|,
name|cfg_options
parameter_list|,
name|scope
parameter_list|,
name|universe
parameter_list|)
name|struct
name|data_string
modifier|*
name|result
decl_stmt|;
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
name|struct
name|lease
modifier|*
name|lease
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client_state
decl_stmt|;
name|struct
name|option_state
modifier|*
name|in_options
decl_stmt|;
name|struct
name|option_state
modifier|*
name|cfg_options
decl_stmt|;
name|struct
name|binding_scope
modifier|*
modifier|*
name|scope
decl_stmt|;
name|struct
name|universe
modifier|*
name|universe
decl_stmt|;
block|{
name|pair
name|p
decl_stmt|,
modifier|*
name|hash
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|universe
operator|->
name|index
operator|>=
name|cfg_options
operator|->
name|universe_count
condition|)
return|return
literal|0
return|;
name|hash
operator|=
name|cfg_options
operator|->
name|universes
index|[
name|universe
operator|->
name|index
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|hash
condition|)
return|return
literal|0
return|;
name|status
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OPTION_HASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|p
operator|=
name|hash
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|cdr
control|)
block|{
if|if
condition|(
name|store_option
argument_list|(
name|result
argument_list|,
name|universe
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
operator|(
expr|struct
name|option_cache
operator|*
operator|)
name|p
operator|->
name|car
argument_list|)
condition|)
name|status
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
name|int
name|nwip_option_space_encapsulate
parameter_list|(
name|result
parameter_list|,
name|packet
parameter_list|,
name|lease
parameter_list|,
name|client_state
parameter_list|,
name|in_options
parameter_list|,
name|cfg_options
parameter_list|,
name|scope
parameter_list|,
name|universe
parameter_list|)
name|struct
name|data_string
modifier|*
name|result
decl_stmt|;
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
name|struct
name|lease
modifier|*
name|lease
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client_state
decl_stmt|;
name|struct
name|option_state
modifier|*
name|in_options
decl_stmt|;
name|struct
name|option_state
modifier|*
name|cfg_options
decl_stmt|;
name|struct
name|binding_scope
modifier|*
modifier|*
name|scope
decl_stmt|;
name|struct
name|universe
modifier|*
name|universe
decl_stmt|;
block|{
name|pair
name|ocp
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|struct
name|option_cache
modifier|*
name|no_nwip
decl_stmt|;
name|struct
name|data_string
name|ds
decl_stmt|;
name|struct
name|option_chain_head
modifier|*
name|head
decl_stmt|;
if|if
condition|(
name|universe
operator|->
name|index
operator|>=
name|cfg_options
operator|->
name|universe_count
condition|)
return|return
literal|0
return|;
name|head
operator|=
operator|(
operator|(
expr|struct
name|option_chain_head
operator|*
operator|)
name|cfg_options
operator|->
name|universes
index|[
name|fqdn_universe
operator|.
name|index
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|head
condition|)
return|return
literal|0
return|;
name|status
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ocp
operator|=
name|head
operator|->
name|first
init|;
name|ocp
condition|;
name|ocp
operator|=
name|ocp
operator|->
name|cdr
control|)
block|{
name|struct
name|option_cache
modifier|*
name|oc
init|=
operator|(
expr|struct
name|option_cache
operator|*
operator|)
operator|(
name|ocp
operator|->
name|car
operator|)
decl_stmt|;
if|if
condition|(
name|store_option
argument_list|(
name|result
argument_list|,
name|universe
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
operator|(
expr|struct
name|option_cache
operator|*
operator|)
name|ocp
operator|->
name|car
argument_list|)
condition|)
name|status
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If there's no data, the nwip suboption is supposed to contain 	   a suboption saying there's no data. */
if|if
condition|(
operator|!
name|status
condition|)
block|{
if|if
condition|(
operator|!
name|no_nwip
condition|)
block|{
specifier|static
name|unsigned
name|char
name|nni
index|[]
init|=
block|{
literal|1
block|,
literal|0
block|}
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ds
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ds
argument_list|)
expr_stmt|;
name|ds
operator|.
name|data
operator|=
name|nni
expr_stmt|;
name|ds
operator|.
name|len
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|option_cache_allocate
argument_list|(
operator|&
name|no_nwip
argument_list|,
name|MDL
argument_list|)
condition|)
name|data_string_copy
argument_list|(
operator|&
name|no_nwip
operator|->
name|data
argument_list|,
operator|&
name|ds
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|no_nwip
operator|->
name|option
operator|=
name|nwip_universe
operator|.
name|options
index|[
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|no_nwip
condition|)
block|{
if|if
condition|(
name|store_option
argument_list|(
name|result
argument_list|,
name|universe
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|no_nwip
argument_list|)
condition|)
name|status
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|memset
argument_list|(
operator|&
name|ds
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ds
argument_list|)
expr_stmt|;
comment|/* If we have nwip options, the first one has to be the 		   nwip-exists-in-option-area option. */
if|if
condition|(
operator|!
name|buffer_allocate
argument_list|(
operator|&
name|ds
operator|.
name|buffer
argument_list|,
name|result
operator|->
name|len
operator|+
literal|2
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
name|data_string_forget
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ds
operator|.
name|data
operator|=
operator|&
name|ds
operator|.
name|buffer
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|ds
operator|.
name|buffer
operator|->
name|data
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
name|ds
operator|.
name|buffer
operator|->
name|data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ds
operator|.
name|buffer
operator|->
name|data
index|[
literal|2
index|]
argument_list|,
name|result
operator|->
name|data
argument_list|,
name|result
operator|->
name|len
argument_list|)
expr_stmt|;
name|data_string_forget
argument_list|(
name|result
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|data_string_copy
argument_list|(
name|result
argument_list|,
operator|&
name|ds
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|data_string_forget
argument_list|(
operator|&
name|ds
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
name|int
name|fqdn_option_space_encapsulate
parameter_list|(
name|result
parameter_list|,
name|packet
parameter_list|,
name|lease
parameter_list|,
name|client_state
parameter_list|,
name|in_options
parameter_list|,
name|cfg_options
parameter_list|,
name|scope
parameter_list|,
name|universe
parameter_list|)
name|struct
name|data_string
modifier|*
name|result
decl_stmt|;
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
name|struct
name|lease
modifier|*
name|lease
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client_state
decl_stmt|;
name|struct
name|option_state
modifier|*
name|in_options
decl_stmt|;
name|struct
name|option_state
modifier|*
name|cfg_options
decl_stmt|;
name|struct
name|binding_scope
modifier|*
modifier|*
name|scope
decl_stmt|;
name|struct
name|universe
modifier|*
name|universe
decl_stmt|;
block|{
name|pair
name|ocp
decl_stmt|;
name|struct
name|data_string
name|results
index|[
name|FQDN_SUBOPTION_COUNT
operator|+
literal|1
index|]
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|struct
name|buffer
modifier|*
name|bp
init|=
operator|(
expr|struct
name|buffer
operator|*
operator|)
literal|0
decl_stmt|;
name|struct
name|option_chain_head
modifier|*
name|head
decl_stmt|;
comment|/* If there's no FQDN universe, don't encapsulate. */
if|if
condition|(
name|fqdn_universe
operator|.
name|index
operator|>=
name|cfg_options
operator|->
name|universe_count
condition|)
return|return
literal|0
return|;
name|head
operator|=
operator|(
operator|(
expr|struct
name|option_chain_head
operator|*
operator|)
name|cfg_options
operator|->
name|universes
index|[
name|fqdn_universe
operator|.
name|index
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|head
condition|)
return|return
literal|0
return|;
comment|/* Figure out the values of all the suboptions. */
name|memset
argument_list|(
name|results
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|results
argument_list|)
expr_stmt|;
for|for
control|(
name|ocp
operator|=
name|head
operator|->
name|first
init|;
name|ocp
condition|;
name|ocp
operator|=
name|ocp
operator|->
name|cdr
control|)
block|{
name|struct
name|option_cache
modifier|*
name|oc
init|=
operator|(
expr|struct
name|option_cache
operator|*
operator|)
operator|(
name|ocp
operator|->
name|car
operator|)
decl_stmt|;
if|if
condition|(
name|oc
operator|->
name|option
operator|->
name|code
operator|>
name|FQDN_SUBOPTION_COUNT
condition|)
continue|continue;
name|evaluate_option_cache
argument_list|(
operator|&
name|results
index|[
name|oc
operator|->
name|option
operator|->
name|code
index|]
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|oc
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
literal|4
operator|+
name|results
index|[
name|FQDN_FQDN
index|]
operator|.
name|len
expr_stmt|;
comment|/* Save the contents of the option in a buffer. */
if|if
condition|(
operator|!
name|buffer_allocate
argument_list|(
operator|&
name|bp
argument_list|,
name|len
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
literal|"no memory for option buffer."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|buffer_reference
argument_list|(
operator|&
name|result
operator|->
name|buffer
argument_list|,
name|bp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|result
operator|->
name|len
operator|=
literal|3
expr_stmt|;
name|result
operator|->
name|data
operator|=
operator|&
name|bp
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|memset
argument_list|(
operator|&
name|bp
operator|->
name|data
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
index|[
name|FQDN_NO_CLIENT_UPDATE
index|]
operator|.
name|len
operator|&&
name|results
index|[
name|FQDN_NO_CLIENT_UPDATE
index|]
operator|.
name|data
index|[
literal|0
index|]
condition|)
name|bp
operator|->
name|data
index|[
literal|0
index|]
operator||=
literal|2
expr_stmt|;
if|if
condition|(
name|results
index|[
name|FQDN_SERVER_UPDATE
index|]
operator|.
name|len
operator|&&
name|results
index|[
name|FQDN_SERVER_UPDATE
index|]
operator|.
name|data
index|[
literal|0
index|]
condition|)
name|bp
operator|->
name|data
index|[
literal|0
index|]
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|results
index|[
name|FQDN_RCODE1
index|]
operator|.
name|len
condition|)
name|bp
operator|->
name|data
index|[
literal|1
index|]
operator|=
name|results
index|[
name|FQDN_RCODE1
index|]
operator|.
name|data
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|results
index|[
name|FQDN_RCODE2
index|]
operator|.
name|len
condition|)
name|bp
operator|->
name|data
index|[
literal|2
index|]
operator|=
name|results
index|[
name|FQDN_RCODE2
index|]
operator|.
name|data
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|results
index|[
name|FQDN_ENCODED
index|]
operator|.
name|len
operator|&&
name|results
index|[
name|FQDN_ENCODED
index|]
operator|.
name|data
index|[
literal|0
index|]
condition|)
block|{
name|unsigned
name|char
modifier|*
name|out
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bp
operator|->
name|data
index|[
literal|0
index|]
operator||=
literal|4
expr_stmt|;
name|out
operator|=
operator|&
name|bp
operator|->
name|data
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|results
index|[
name|FQDN_FQDN
index|]
operator|.
name|len
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|results
index|[
name|FQDN_FQDN
index|]
operator|.
name|len
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
operator|(
literal|'.'
operator|!=
name|results
index|[
name|FQDN_FQDN
index|]
operator|.
name|data
index|[
name|j
index|]
operator|)
operator|&&
name|j
operator|<
name|results
index|[
name|FQDN_FQDN
index|]
operator|.
name|len
condition|;
name|j
operator|++
control|)
empty_stmt|;
operator|*
name|out
operator|++
operator|=
name|j
operator|-
name|i
expr_stmt|;
name|memcpy
argument_list|(
name|out
argument_list|,
operator|&
name|results
index|[
name|FQDN_FQDN
index|]
operator|.
name|data
index|[
name|i
index|]
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|j
operator|-
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|+=
name|j
operator|-
name|i
expr_stmt|;
name|i
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|results
index|[
name|FQDN_FQDN
index|]
operator|.
name|data
index|[
name|j
index|]
operator|==
literal|'.'
condition|)
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|results
index|[
name|FQDN_FQDN
index|]
operator|.
name|data
index|[
name|results
index|[
name|FQDN_FQDN
index|]
operator|.
name|len
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|)
condition|)
operator|*
name|out
operator|++
operator|=
literal|0
expr_stmt|;
name|result
operator|->
name|len
operator|=
name|out
operator|-
name|result
operator|->
name|data
expr_stmt|;
name|result
operator|->
name|terminated
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|results
index|[
name|FQDN_FQDN
index|]
operator|.
name|len
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|bp
operator|->
name|data
index|[
literal|3
index|]
argument_list|,
name|results
index|[
name|FQDN_FQDN
index|]
operator|.
name|data
argument_list|,
name|results
index|[
name|FQDN_FQDN
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|result
operator|->
name|len
operator|+=
name|results
index|[
name|FQDN_FQDN
index|]
operator|.
name|len
expr_stmt|;
name|result
operator|->
name|terminated
operator|=
literal|0
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|FQDN_SUBOPTION_COUNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|results
index|[
name|i
index|]
operator|.
name|len
condition|)
name|data_string_forget
argument_list|(
operator|&
name|results
index|[
name|i
index|]
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
name|buffer_dereference
argument_list|(
operator|&
name|bp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|option_space_foreach
parameter_list|(
name|struct
name|packet
modifier|*
name|packet
parameter_list|,
name|struct
name|lease
modifier|*
name|lease
parameter_list|,
name|struct
name|client_state
modifier|*
name|client_state
parameter_list|,
name|struct
name|option_state
modifier|*
name|in_options
parameter_list|,
name|struct
name|option_state
modifier|*
name|cfg_options
parameter_list|,
name|struct
name|binding_scope
modifier|*
modifier|*
name|scope
parameter_list|,
name|struct
name|universe
modifier|*
name|u
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|option_cache
modifier|*
parameter_list|,
name|struct
name|packet
modifier|*
parameter_list|,
name|struct
name|lease
modifier|*
parameter_list|,
name|struct
name|client_state
modifier|*
parameter_list|,
name|struct
name|option_state
modifier|*
parameter_list|,
name|struct
name|option_state
modifier|*
parameter_list|,
name|struct
name|binding_scope
modifier|*
modifier|*
parameter_list|,
name|struct
name|universe
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
if|if
condition|(
name|u
operator|->
name|foreach
condition|)
call|(
modifier|*
name|u
operator|->
name|foreach
call|)
argument_list|(
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|u
argument_list|,
name|stuff
argument_list|,
name|func
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|suboption_foreach
parameter_list|(
name|struct
name|packet
modifier|*
name|packet
parameter_list|,
name|struct
name|lease
modifier|*
name|lease
parameter_list|,
name|struct
name|client_state
modifier|*
name|client_state
parameter_list|,
name|struct
name|option_state
modifier|*
name|in_options
parameter_list|,
name|struct
name|option_state
modifier|*
name|cfg_options
parameter_list|,
name|struct
name|binding_scope
modifier|*
modifier|*
name|scope
parameter_list|,
name|struct
name|universe
modifier|*
name|u
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|option_cache
modifier|*
parameter_list|,
name|struct
name|packet
modifier|*
parameter_list|,
name|struct
name|lease
modifier|*
parameter_list|,
name|struct
name|client_state
modifier|*
parameter_list|,
name|struct
name|option_state
modifier|*
parameter_list|,
name|struct
name|option_state
modifier|*
parameter_list|,
name|struct
name|binding_scope
modifier|*
modifier|*
parameter_list|,
name|struct
name|universe
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|struct
name|option_cache
modifier|*
name|oc
parameter_list|,
specifier|const
name|char
modifier|*
name|vsname
parameter_list|)
block|{
name|struct
name|universe
modifier|*
name|universe
init|=
name|find_option_universe
argument_list|(
name|oc
operator|->
name|option
argument_list|,
name|vsname
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|universe
operator|->
name|foreach
condition|)
call|(
modifier|*
name|universe
operator|->
name|foreach
call|)
argument_list|(
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|universe
argument_list|,
name|stuff
argument_list|,
name|func
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|hashed_option_space_foreach
parameter_list|(
name|struct
name|packet
modifier|*
name|packet
parameter_list|,
name|struct
name|lease
modifier|*
name|lease
parameter_list|,
name|struct
name|client_state
modifier|*
name|client_state
parameter_list|,
name|struct
name|option_state
modifier|*
name|in_options
parameter_list|,
name|struct
name|option_state
modifier|*
name|cfg_options
parameter_list|,
name|struct
name|binding_scope
modifier|*
modifier|*
name|scope
parameter_list|,
name|struct
name|universe
modifier|*
name|u
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|option_cache
modifier|*
parameter_list|,
name|struct
name|packet
modifier|*
parameter_list|,
name|struct
name|lease
modifier|*
parameter_list|,
name|struct
name|client_state
modifier|*
parameter_list|,
name|struct
name|option_state
modifier|*
parameter_list|,
name|struct
name|option_state
modifier|*
parameter_list|,
name|struct
name|binding_scope
modifier|*
modifier|*
parameter_list|,
name|struct
name|universe
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|pair
modifier|*
name|hash
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|option_cache
modifier|*
name|oc
decl_stmt|;
if|if
condition|(
name|cfg_options
operator|->
name|universe_count
operator|<=
name|u
operator|->
name|index
condition|)
return|return;
name|hash
operator|=
name|cfg_options
operator|->
name|universes
index|[
name|u
operator|->
name|index
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|hash
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OPTION_HASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|pair
name|p
decl_stmt|;
comment|/* XXX save _all_ options! XXX */
for|for
control|(
name|p
operator|=
name|hash
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|cdr
control|)
block|{
name|oc
operator|=
operator|(
expr|struct
name|option_cache
operator|*
operator|)
name|p
operator|->
name|car
expr_stmt|;
call|(
modifier|*
name|func
call|)
argument_list|(
name|oc
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|u
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|save_linked_option
parameter_list|(
name|universe
parameter_list|,
name|options
parameter_list|,
name|oc
parameter_list|)
name|struct
name|universe
modifier|*
name|universe
decl_stmt|;
name|struct
name|option_state
modifier|*
name|options
decl_stmt|;
name|struct
name|option_cache
modifier|*
name|oc
decl_stmt|;
block|{
name|pair
modifier|*
name|tail
decl_stmt|;
name|pair
name|np
init|=
operator|(
name|pair
operator|)
literal|0
decl_stmt|;
name|struct
name|option_chain_head
modifier|*
name|head
decl_stmt|;
if|if
condition|(
name|universe
operator|->
name|index
operator|>=
name|options
operator|->
name|universe_count
condition|)
return|return;
name|head
operator|=
operator|(
operator|(
expr|struct
name|option_chain_head
operator|*
operator|)
name|options
operator|->
name|universes
index|[
name|universe
operator|->
name|index
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|head
condition|)
block|{
if|if
condition|(
operator|!
name|option_chain_head_allocate
argument_list|(
operator|(
operator|(
expr|struct
name|option_chain_head
operator|*
operator|*
operator|)
operator|&
name|options
operator|->
name|universes
index|[
name|universe
operator|->
name|index
index|]
operator|)
argument_list|,
name|MDL
argument_list|)
condition|)
return|return;
name|head
operator|=
operator|(
operator|(
expr|struct
name|option_chain_head
operator|*
operator|)
name|options
operator|->
name|universes
index|[
name|universe
operator|->
name|index
index|]
operator|)
expr_stmt|;
block|}
comment|/* Find the tail of the list. */
for|for
control|(
name|tail
operator|=
operator|&
name|head
operator|->
name|first
init|;
operator|*
name|tail
condition|;
name|tail
operator|=
operator|&
operator|(
operator|(
operator|*
name|tail
operator|)
operator|->
name|cdr
operator|)
control|)
block|{
if|if
condition|(
name|oc
operator|->
name|option
operator|==
operator|(
operator|(
expr|struct
name|option_cache
operator|*
operator|)
operator|(
operator|(
operator|*
name|tail
operator|)
operator|->
name|car
operator|)
operator|)
operator|->
name|option
condition|)
block|{
name|option_cache_dereference
argument_list|(
operator|(
expr|struct
name|option_cache
operator|*
operator|*
operator|)
operator|(
operator|&
operator|(
operator|*
name|tail
operator|)
operator|->
name|car
operator|)
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|option_cache_reference
argument_list|(
operator|(
expr|struct
name|option_cache
operator|*
operator|*
operator|)
operator|(
operator|&
operator|(
operator|*
name|tail
operator|)
operator|->
name|car
operator|)
argument_list|,
name|oc
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
operator|*
name|tail
operator|=
name|cons
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tail
condition|)
block|{
name|option_cache_reference
argument_list|(
operator|(
expr|struct
name|option_cache
operator|*
operator|*
operator|)
operator|(
operator|&
operator|(
operator|*
name|tail
operator|)
operator|->
name|car
operator|)
argument_list|,
name|oc
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|linked_option_space_encapsulate
parameter_list|(
name|result
parameter_list|,
name|packet
parameter_list|,
name|lease
parameter_list|,
name|client_state
parameter_list|,
name|in_options
parameter_list|,
name|cfg_options
parameter_list|,
name|scope
parameter_list|,
name|universe
parameter_list|)
name|struct
name|data_string
modifier|*
name|result
decl_stmt|;
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
name|struct
name|lease
modifier|*
name|lease
decl_stmt|;
name|struct
name|client_state
modifier|*
name|client_state
decl_stmt|;
name|struct
name|option_state
modifier|*
name|in_options
decl_stmt|;
name|struct
name|option_state
modifier|*
name|cfg_options
decl_stmt|;
name|struct
name|binding_scope
modifier|*
modifier|*
name|scope
decl_stmt|;
name|struct
name|universe
modifier|*
name|universe
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|pair
name|oc
decl_stmt|;
name|struct
name|option_chain_head
modifier|*
name|head
decl_stmt|;
if|if
condition|(
name|universe
operator|->
name|index
operator|>=
name|cfg_options
operator|->
name|universe_count
condition|)
return|return
literal|0
return|;
name|head
operator|=
operator|(
operator|(
expr|struct
name|option_chain_head
operator|*
operator|)
name|cfg_options
operator|->
name|universes
index|[
name|universe
operator|->
name|index
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|head
condition|)
return|return
literal|0
return|;
name|status
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|oc
operator|=
name|head
operator|->
name|first
init|;
name|oc
condition|;
name|oc
operator|=
name|oc
operator|->
name|cdr
control|)
block|{
if|if
condition|(
name|store_option
argument_list|(
name|result
argument_list|,
name|universe
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
operator|(
expr|struct
name|option_cache
operator|*
operator|)
operator|(
name|oc
operator|->
name|car
operator|)
argument_list|)
condition|)
name|status
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
name|void
name|delete_linked_option
parameter_list|(
name|universe
parameter_list|,
name|options
parameter_list|,
name|code
parameter_list|)
name|struct
name|universe
modifier|*
name|universe
decl_stmt|;
name|struct
name|option_state
modifier|*
name|options
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
name|pair
modifier|*
name|tail
decl_stmt|,
name|tmp
init|=
operator|(
name|pair
operator|)
literal|0
decl_stmt|;
name|struct
name|option_chain_head
modifier|*
name|head
decl_stmt|;
if|if
condition|(
name|universe
operator|->
name|index
operator|>=
name|options
operator|->
name|universe_count
condition|)
return|return;
name|head
operator|=
operator|(
operator|(
expr|struct
name|option_chain_head
operator|*
operator|)
name|options
operator|->
name|universes
index|[
name|universe
operator|->
name|index
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|head
condition|)
return|return;
for|for
control|(
name|tail
operator|=
operator|&
name|head
operator|->
name|first
init|;
operator|*
name|tail
condition|;
name|tail
operator|=
operator|&
operator|(
operator|(
operator|*
name|tail
operator|)
operator|->
name|cdr
operator|)
control|)
block|{
if|if
condition|(
name|code
operator|==
operator|(
operator|(
expr|struct
name|option_cache
operator|*
operator|)
operator|(
operator|*
name|tail
operator|)
operator|->
name|car
operator|)
operator|->
name|option
operator|->
name|code
condition|)
block|{
name|tmp
operator|=
operator|(
operator|*
name|tail
operator|)
operator|->
name|cdr
expr_stmt|;
name|option_cache_dereference
argument_list|(
operator|(
expr|struct
name|option_cache
operator|*
operator|*
operator|)
operator|(
operator|&
operator|(
operator|*
name|tail
operator|)
operator|->
name|car
operator|)
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|dfree
argument_list|(
operator|*
name|tail
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
operator|(
operator|*
name|tail
operator|)
operator|=
name|tmp
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
name|struct
name|option_cache
modifier|*
name|lookup_linked_option
parameter_list|(
name|universe
parameter_list|,
name|options
parameter_list|,
name|code
parameter_list|)
name|struct
name|universe
modifier|*
name|universe
decl_stmt|;
name|struct
name|option_state
modifier|*
name|options
decl_stmt|;
name|unsigned
name|code
decl_stmt|;
block|{
name|pair
name|oc
decl_stmt|;
name|struct
name|option_chain_head
modifier|*
name|head
decl_stmt|;
if|if
condition|(
name|universe
operator|->
name|index
operator|>=
name|options
operator|->
name|universe_count
condition|)
return|return
literal|0
return|;
name|head
operator|=
operator|(
operator|(
expr|struct
name|option_chain_head
operator|*
operator|)
name|options
operator|->
name|universes
index|[
name|universe
operator|->
name|index
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|head
condition|)
return|return
literal|0
return|;
for|for
control|(
name|oc
operator|=
name|head
operator|->
name|first
init|;
name|oc
condition|;
name|oc
operator|=
name|oc
operator|->
name|cdr
control|)
block|{
if|if
condition|(
name|code
operator|==
operator|(
operator|(
expr|struct
name|option_cache
operator|*
operator|)
operator|(
name|oc
operator|->
name|car
operator|)
operator|)
operator|->
name|option
operator|->
name|code
condition|)
block|{
return|return
operator|(
expr|struct
name|option_cache
operator|*
operator|)
operator|(
name|oc
operator|->
name|car
operator|)
return|;
block|}
block|}
return|return
operator|(
expr|struct
name|option_cache
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_function
name|int
name|linked_option_state_dereference
parameter_list|(
name|universe
parameter_list|,
name|state
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|struct
name|universe
modifier|*
name|universe
decl_stmt|;
name|struct
name|option_state
modifier|*
name|state
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
return|return
operator|(
name|option_chain_head_dereference
argument_list|(
operator|(
expr|struct
name|option_chain_head
operator|*
operator|*
operator|)
operator|(
operator|&
name|state
operator|->
name|universes
index|[
name|universe
operator|->
name|index
index|]
operator|)
argument_list|,
name|MDL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|linked_option_space_foreach
parameter_list|(
name|struct
name|packet
modifier|*
name|packet
parameter_list|,
name|struct
name|lease
modifier|*
name|lease
parameter_list|,
name|struct
name|client_state
modifier|*
name|client_state
parameter_list|,
name|struct
name|option_state
modifier|*
name|in_options
parameter_list|,
name|struct
name|option_state
modifier|*
name|cfg_options
parameter_list|,
name|struct
name|binding_scope
modifier|*
modifier|*
name|scope
parameter_list|,
name|struct
name|universe
modifier|*
name|u
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|option_cache
modifier|*
parameter_list|,
name|struct
name|packet
modifier|*
parameter_list|,
name|struct
name|lease
modifier|*
parameter_list|,
name|struct
name|client_state
modifier|*
parameter_list|,
name|struct
name|option_state
modifier|*
parameter_list|,
name|struct
name|option_state
modifier|*
parameter_list|,
name|struct
name|binding_scope
modifier|*
modifier|*
parameter_list|,
name|struct
name|universe
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|pair
name|car
decl_stmt|;
name|struct
name|option_chain_head
modifier|*
name|head
decl_stmt|;
if|if
condition|(
name|u
operator|->
name|index
operator|>=
name|cfg_options
operator|->
name|universe_count
condition|)
return|return;
name|head
operator|=
operator|(
operator|(
expr|struct
name|option_chain_head
operator|*
operator|)
name|cfg_options
operator|->
name|universes
index|[
name|u
operator|->
name|index
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|head
condition|)
return|return;
for|for
control|(
name|car
operator|=
name|head
operator|->
name|first
init|;
name|car
condition|;
name|car
operator|=
name|car
operator|->
name|cdr
control|)
block|{
call|(
modifier|*
name|func
call|)
argument_list|(
operator|(
expr|struct
name|option_cache
operator|*
operator|)
operator|(
name|car
operator|->
name|car
operator|)
argument_list|,
name|packet
argument_list|,
name|lease
argument_list|,
name|client_state
argument_list|,
name|in_options
argument_list|,
name|cfg_options
argument_list|,
name|scope
argument_list|,
name|u
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|do_packet
parameter_list|(
name|interface
parameter_list|,
name|packet
parameter_list|,
name|len
parameter_list|,
name|from_port
parameter_list|,
name|from
parameter_list|,
name|hfrom
parameter_list|)
name|struct
name|interface_info
modifier|*
name|interface
decl_stmt|;
name|struct
name|dhcp_packet
modifier|*
name|packet
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|unsigned
name|int
name|from_port
decl_stmt|;
name|struct
name|iaddr
name|from
decl_stmt|;
name|struct
name|hardware
modifier|*
name|hfrom
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|option_cache
modifier|*
name|op
decl_stmt|;
name|struct
name|packet
modifier|*
name|decoded_packet
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_MEMORY_LEAKAGE
argument_list|)
name|unsigned
name|long
name|previous_outstanding
init|=
name|dmalloc_outstanding
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|TRACING
argument_list|)
name|trace_inpacket_stash
argument_list|(
name|interface
argument_list|,
name|packet
argument_list|,
name|len
argument_list|,
name|from_port
argument_list|,
name|from
argument_list|,
name|hfrom
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|decoded_packet
operator|=
operator|(
expr|struct
name|packet
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|packet_allocate
argument_list|(
operator|&
name|decoded_packet
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
name|log_error
argument_list|(
literal|"do_packet: no memory for incoming packet!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|decoded_packet
operator|->
name|raw
operator|=
name|packet
expr_stmt|;
name|decoded_packet
operator|->
name|packet_length
operator|=
name|len
expr_stmt|;
name|decoded_packet
operator|->
name|client_port
operator|=
name|from_port
expr_stmt|;
name|decoded_packet
operator|->
name|client_addr
operator|=
name|from
expr_stmt|;
name|interface_reference
argument_list|(
operator|&
name|decoded_packet
operator|->
name|interface
argument_list|,
name|interface
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|decoded_packet
operator|->
name|haddr
operator|=
name|hfrom
expr_stmt|;
if|if
condition|(
name|packet
operator|->
name|hlen
operator|>
sizeof|sizeof
name|packet
operator|->
name|chaddr
condition|)
block|{
name|packet_dereference
argument_list|(
operator|&
name|decoded_packet
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
literal|"Discarding packet with bogus hlen."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If there's an option buffer, try to parse it. */
if|if
condition|(
name|decoded_packet
operator|->
name|packet_length
operator|>=
name|DHCP_FIXED_NON_UDP
operator|+
literal|4
condition|)
block|{
if|if
condition|(
operator|!
name|parse_options
argument_list|(
name|decoded_packet
argument_list|)
condition|)
block|{
if|if
condition|(
name|decoded_packet
operator|->
name|options
condition|)
name|option_state_dereference
argument_list|(
operator|&
name|decoded_packet
operator|->
name|options
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
name|packet_dereference
argument_list|(
operator|&
name|decoded_packet
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|decoded_packet
operator|->
name|options_valid
operator|&&
operator|(
name|op
operator|=
name|lookup_option
argument_list|(
operator|&
name|dhcp_universe
argument_list|,
name|decoded_packet
operator|->
name|options
argument_list|,
name|DHO_DHCP_MESSAGE_TYPE
argument_list|)
operator|)
condition|)
block|{
name|struct
name|data_string
name|dp
decl_stmt|;
name|memset
argument_list|(
operator|&
name|dp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|dp
argument_list|)
expr_stmt|;
name|evaluate_option_cache
argument_list|(
operator|&
name|dp
argument_list|,
name|decoded_packet
argument_list|,
operator|(
expr|struct
name|lease
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|client_state
operator|*
operator|)
literal|0
argument_list|,
name|decoded_packet
operator|->
name|options
argument_list|,
operator|(
expr|struct
name|option_state
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|binding_scope
operator|*
operator|*
operator|)
literal|0
argument_list|,
name|op
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|.
name|len
operator|>
literal|0
condition|)
name|decoded_packet
operator|->
name|packet_type
operator|=
name|dp
operator|.
name|data
index|[
literal|0
index|]
expr_stmt|;
else|else
name|decoded_packet
operator|->
name|packet_type
operator|=
literal|0
expr_stmt|;
name|data_string_forget
argument_list|(
operator|&
name|dp
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|decoded_packet
operator|->
name|packet_type
condition|)
name|dhcp
argument_list|(
name|decoded_packet
argument_list|)
expr_stmt|;
else|else
name|bootp
argument_list|(
name|decoded_packet
argument_list|)
expr_stmt|;
comment|/* If the caller kept the packet, they'll have upped the refcnt. */
name|packet_dereference
argument_list|(
operator|&
name|decoded_packet
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_MEMORY_LEAKAGE
argument_list|)
name|log_info
argument_list|(
literal|"generation %ld: %ld new, %ld outstanding, %ld long-term"
argument_list|,
name|dmalloc_generation
argument_list|,
name|dmalloc_outstanding
operator|-
name|previous_outstanding
argument_list|,
name|dmalloc_outstanding
argument_list|,
name|dmalloc_longterm
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_MEMORY_LEAKAGE
argument_list|)
name|dmalloc_dump_outstanding
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_RC_HISTORY_EXHAUSTIVELY
argument_list|)
name|dump_rc_history
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

