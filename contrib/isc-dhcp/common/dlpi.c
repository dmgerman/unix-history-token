begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dlpi.c      Data Link Provider Interface (DLPI) network interface code. */
end_comment

begin_comment
comment|/*  * Copyright (c) 2004 by Internet Systems Consortium, Inc. ("ISC")  * Copyright (c) 1996-2003 by Internet Software Consortium  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT  * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  *   Internet Systems Consortium, Inc.  *   950 Charter Street  *   Redwood City, CA 94063  *<info@isc.org>  *   http://www.isc.org/  *  * This software was written for Internet Systems Consortium  * by Eric James Negaard,<lmdejn@lmd.ericsson.se>.  To learn more about  * Internet Systems Consortium, see ``http://www.isc.org''.  *  * Joost Mulders has also done considerable work in debugging the DLPI API  * support on Solaris and getting this code to work properly on a variety  * of different Solaris platforms.  */
end_comment

begin_comment
comment|/*  * Based largely in part to the existing NIT code in nit.c.  *  * This code has been developed and tested on sparc-based machines running  * SunOS 5.5.1, with le and hme network interfaces.  It should be pretty  * generic, though.  */
end_comment

begin_comment
comment|/*  * Implementation notes:  *  * I first tried to write this code to the "vanilla" DLPI 2.0 API.  * It worked on a Sun Ultra-1 with a hme interface, but didn't work  * on Sun SparcStation 5's with "le" interfaces (the packets sent out  * via dlpiunitdatareq contained an Ethernet type of 0x0000 instead  * of the expected 0x0800).  *  * Therefore I added the "DLPI_RAW" code which is a Sun extension to  * the DLPI standard.  This code works on both of the above machines.  * This is configurable in the OS-dependent include file by defining  * USE_DLPI_RAW.  *  * It quickly became apparant that I should also use the "pfmod"  * STREAMS module to cut down on the amount of user level packet  * processing.  I don't know how widely available "pfmod" is, so it's  * use is conditionally included. This is configurable in the  * OS-dependent include file by defining USE_DLPI_PFMOD.  *  * A major quirk on the Sun's at least, is that no packets seem to get  * sent out the interface until six seconds after the interface is  * first "attached" to [per system reboot] (it's actually from when  * the interface is attached, not when it is plumbed, so putting a  * sleep into the dhclient-script at PREINIT time doesn't help).  I  * HAVE tried, without success to poll the fd to see when it is ready  * for writing.  This doesn't help at all. If the sleeps are not done,  * the initial DHCPREQUEST or DHCPDISCOVER never gets sent out, so  * I've put them here, when register_send and register_receive are  * called (split up into two three-second sleeps between the notices,  * so that it doesn't seem like so long when you're watching :-).  The  * amount of time to sleep is configurable in the OS-dependent include  * file by defining DLPI_FIRST_SEND_WAIT to be the number of seconds  * to sleep.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"$Id: dlpi.c,v 1.28.2.2 2004/06/10 17:59:17 dhankins Exp $ Copyright (c) 2004 Internet Systems Consortium.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"dhcpd.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_DLPI_SEND
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_DLPI_RECEIVE
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/dlpi.h>
end_include

begin_include
include|#
directive|include
file|<stropts.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_DLPI_PFMOD
end_ifdef

begin_include
include|#
directive|include
file|<sys/pfmod.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_POLL
end_ifdef

begin_include
include|#
directive|include
file|<poll.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|"includes/netinet/ip.h"
end_include

begin_include
include|#
directive|include
file|"includes/netinet/udp.h"
end_include

begin_include
include|#
directive|include
file|"includes/netinet/if_ether.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_DLPI_PFMOD
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|USE_DLPI_RAW
end_ifdef

begin_define
define|#
directive|define
name|DLPI_MODNAME
value|"DLPI+RAW+PFMOD"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DLPI_MODNAME
value|"DLPI+PFMOD"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|USE_DLPI_RAW
end_ifdef

begin_define
define|#
directive|define
name|DLPI_MODNAME
value|"DLPI+RAW"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DLPI_MODNAME
value|"DLPI"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ABS
end_ifndef

begin_define
define|#
directive|define
name|ABS
parameter_list|(
name|x
parameter_list|)
value|((x)>= 0 ? (x) : 0-(x))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|strioctl
name|PROTO
argument_list|(
operator|(
name|int
name|fd
operator|,
name|int
name|cmd
operator|,
name|int
name|timeout
operator|,
name|int
name|len
operator|,
name|char
operator|*
name|dp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DLPI_MAXDLBUF
value|8192
end_define

begin_comment
comment|/* Buffer size */
end_comment

begin_define
define|#
directive|define
name|DLPI_MAXDLADDR
value|1024
end_define

begin_comment
comment|/* Max address size */
end_comment

begin_define
define|#
directive|define
name|DLPI_DEVDIR
value|"/dev/"
end_define

begin_comment
comment|/* Device directory */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dlpiopen
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|ifname
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dlpiunit
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|ifname
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dlpiinforeq
name|PROTO
argument_list|(
operator|(
name|int
name|fd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dlpiphysaddrreq
name|PROTO
argument_list|(
operator|(
name|int
name|fd
operator|,
name|unsigned
name|long
name|addrtype
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dlpiattachreq
name|PROTO
argument_list|(
operator|(
name|int
name|fd
operator|,
name|unsigned
name|long
name|ppa
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dlpibindreq
name|PROTO
argument_list|(
operator|(
name|int
name|fd
operator|,
name|unsigned
name|long
name|sap
operator|,
name|unsigned
name|long
name|max_conind
operator|,
name|unsigned
name|long
name|service_mode
operator|,
name|unsigned
name|long
name|conn_mgmt
operator|,
name|unsigned
name|long
name|xidtest
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dlpidetachreq
name|PROTO
argument_list|(
operator|(
name|int
name|fd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dlpiunbindreq
name|PROTO
argument_list|(
operator|(
name|int
name|fd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dlpiokack
name|PROTO
argument_list|(
operator|(
name|int
name|fd
operator|,
name|char
operator|*
name|bufp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dlpiinfoack
name|PROTO
argument_list|(
operator|(
name|int
name|fd
operator|,
name|char
operator|*
name|bufp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dlpiphysaddrack
name|PROTO
argument_list|(
operator|(
name|int
name|fd
operator|,
name|char
operator|*
name|bufp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dlpibindack
name|PROTO
argument_list|(
operator|(
name|int
name|fd
operator|,
name|char
operator|*
name|bufp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dlpiunitdatareq
name|PROTO
argument_list|(
operator|(
name|int
name|fd
operator|,
name|unsigned
name|char
operator|*
name|addr
operator|,
name|int
name|addrlen
operator|,
name|unsigned
name|long
name|minpri
operator|,
name|unsigned
name|long
name|maxpri
operator|,
name|unsigned
name|char
operator|*
name|data
operator|,
name|int
name|datalen
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dlpiunitdataind
name|PROTO
argument_list|(
operator|(
name|int
name|fd
operator|,
name|unsigned
name|char
operator|*
name|dstaddr
operator|,
name|unsigned
name|long
operator|*
name|dstaddrlen
operator|,
name|unsigned
name|char
operator|*
name|srcaddr
operator|,
name|unsigned
name|long
operator|*
name|srcaddrlen
operator|,
name|unsigned
name|long
operator|*
name|grpaddr
operator|,
name|unsigned
name|char
operator|*
name|data
operator|,
name|int
name|datalen
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|USE_POLL
end_ifndef

begin_decl_stmt
specifier|static
name|void
name|sigalrm
name|PROTO
argument_list|(
operator|(
name|int
name|sig
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|expected
name|PROTO
argument_list|(
operator|(
name|unsigned
name|long
name|prim
operator|,
expr|union
name|DL_primitives
operator|*
name|dlp
operator|,
name|int
name|msgflags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|strgetmsg
name|PROTO
argument_list|(
operator|(
name|int
name|fd
operator|,
expr|struct
name|strbuf
operator|*
name|ctlp
operator|,
expr|struct
name|strbuf
operator|*
name|datap
operator|,
name|int
operator|*
name|flagsp
operator|,
name|char
operator|*
name|caller
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Reinitializes the specified interface after an address change.   This    is not required for packet-filter APIs. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_DLPI_SEND
end_ifdef

begin_function
name|void
name|if_reinitialize_send
parameter_list|(
name|info
parameter_list|)
name|struct
name|interface_info
modifier|*
name|info
decl_stmt|;
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_DLPI_RECEIVE
end_ifdef

begin_function
name|void
name|if_reinitialize_receive
parameter_list|(
name|info
parameter_list|)
name|struct
name|interface_info
modifier|*
name|info
decl_stmt|;
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Called by get_interface_list for each interface that's discovered.    Opens a packet filter for each interface and adds it to the select    mask. */
end_comment

begin_function
name|int
name|if_register_dlpi
parameter_list|(
name|info
parameter_list|)
name|struct
name|interface_info
modifier|*
name|info
decl_stmt|;
block|{
name|int
name|sock
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|long
name|buf
index|[
name|DLPI_MAXDLBUF
index|]
decl_stmt|;
name|union
name|DL_primitives
modifier|*
name|dlp
decl_stmt|;
name|dlp
operator|=
operator|(
expr|union
name|DL_primitives
operator|*
operator|)
name|buf
expr_stmt|;
comment|/* Open a DLPI device */
if|if
condition|(
operator|(
name|sock
operator|=
name|dlpiopen
argument_list|(
name|info
operator|->
name|name
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|log_fatal
argument_list|(
literal|"Can't open DLPI device for %s: %m"
argument_list|,
name|info
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/*        * Submit a DL_INFO_REQ request, to find the dl_mac_type and           * dl_provider_style 	 */
if|if
condition|(
name|dlpiinforeq
argument_list|(
name|sock
argument_list|)
operator|<
literal|0
operator|||
name|dlpiinfoack
argument_list|(
name|sock
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_fatal
argument_list|(
literal|"Can't get DLPI MAC type for %s: %m"
argument_list|,
name|info
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|dlp
operator|->
name|info_ack
operator|.
name|dl_mac_type
condition|)
block|{
case|case
name|DL_CSMACD
case|:
comment|/* IEEE 802.3 */
case|case
name|DL_ETHER
case|:
name|info
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|0
index|]
operator|=
name|HTYPE_ETHER
expr_stmt|;
break|break;
comment|/* adding token ring 5/1999 - mayer@ping.at  */
case|case
name|DL_TPR
case|:
name|info
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|0
index|]
operator|=
name|HTYPE_IEEE802
expr_stmt|;
break|break;
case|case
name|DL_FDDI
case|:
name|info
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|0
index|]
operator|=
name|HTYPE_FDDI
expr_stmt|;
break|break;
default|default:
name|log_fatal
argument_list|(
literal|"%s: unsupported DLPI MAC type %ld"
argument_list|,
name|info
operator|->
name|name
argument_list|,
name|dlp
operator|->
name|info_ack
operator|.
name|dl_mac_type
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*              * copy the sap length and broadcast address of this interface              * to interface_info. This fixes nothing but seemed nicer than to              * assume -2 and ffffff.              */
name|info
operator|->
name|dlpi_sap_length
operator|=
name|dlp
operator|->
name|info_ack
operator|.
name|dl_sap_length
expr_stmt|;
name|info
operator|->
name|dlpi_broadcast_addr
operator|.
name|hlen
operator|=
name|dlp
operator|->
name|info_ack
operator|.
name|dl_brdcst_addr_length
expr_stmt|;
name|memcpy
argument_list|(
name|info
operator|->
name|dlpi_broadcast_addr
operator|.
name|hbuf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dlp
operator|+
name|dlp
operator|->
name|info_ack
operator|.
name|dl_brdcst_addr_offset
argument_list|,
name|dlp
operator|->
name|info_ack
operator|.
name|dl_brdcst_addr_length
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dlp
operator|->
name|info_ack
operator|.
name|dl_provider_style
operator|==
name|DL_STYLE2
condition|)
block|{
comment|/* 	     * Attach to the device.  If this fails, the device 	     * does not exist. 	     */
name|unit
operator|=
name|dlpiunit
argument_list|(
name|info
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dlpiattachreq
argument_list|(
name|sock
argument_list|,
name|unit
argument_list|)
operator|<
literal|0
operator|||
name|dlpiokack
argument_list|(
name|sock
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_fatal
argument_list|(
literal|"Can't attach DLPI device for %s: %m"
argument_list|,
name|info
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Bind to the IP service access point (SAP), connectionless (CLDLS). 	 */
if|if
condition|(
name|dlpibindreq
argument_list|(
name|sock
argument_list|,
name|ETHERTYPE_IP
argument_list|,
literal|0
argument_list|,
name|DL_CLDLS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|||
name|dlpibindack
argument_list|(
name|sock
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_fatal
argument_list|(
literal|"Can't bind DLPI device for %s: %m"
argument_list|,
name|info
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Submit a DL_PHYS_ADDR_REQ request, to find 	 * the hardware address 	 */
if|if
condition|(
name|dlpiphysaddrreq
argument_list|(
name|sock
argument_list|,
name|DL_CURR_PHYS_ADDR
argument_list|)
operator|<
literal|0
operator|||
name|dlpiphysaddrack
argument_list|(
name|sock
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_fatal
argument_list|(
literal|"Can't get DLPI hardware address for %s: %m"
argument_list|,
name|info
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|info
operator|->
name|hw_address
operator|.
name|hlen
operator|=
name|dlp
operator|->
name|physaddr_ack
operator|.
name|dl_addr_length
operator|+
literal|1
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|info
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|1
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|dlp
operator|->
name|physaddr_ack
operator|.
name|dl_addr_offset
argument_list|,
name|dlp
operator|->
name|physaddr_ack
operator|.
name|dl_addr_length
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_DLPI_RAW
if|if
condition|(
name|strioctl
argument_list|(
name|sock
argument_list|,
name|DLIOCRAW
argument_list|,
name|INFTIM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_fatal
argument_list|(
literal|"Can't set DLPI RAW mode for %s: %m"
argument_list|,
name|info
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_DLPI_PFMOD
if|if
condition|(
name|ioctl
argument_list|(
name|sock
argument_list|,
name|I_PUSH
argument_list|,
literal|"pfmod"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_fatal
argument_list|(
literal|"Can't push packet filter onto DLPI for %s: %m"
argument_list|,
name|info
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|sock
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|strioctl
parameter_list|(
name|fd
parameter_list|,
name|cmd
parameter_list|,
name|timeout
parameter_list|,
name|len
parameter_list|,
name|dp
parameter_list|)
name|int
name|fd
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|int
name|timeout
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|dp
decl_stmt|;
block|{
name|struct
name|strioctl
name|sio
decl_stmt|;
name|int
name|rslt
decl_stmt|;
name|sio
operator|.
name|ic_cmd
operator|=
name|cmd
expr_stmt|;
name|sio
operator|.
name|ic_timout
operator|=
name|timeout
expr_stmt|;
name|sio
operator|.
name|ic_len
operator|=
name|len
expr_stmt|;
name|sio
operator|.
name|ic_dp
operator|=
name|dp
expr_stmt|;
if|if
condition|(
operator|(
name|rslt
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|I_STR
argument_list|,
operator|&
name|sio
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
return|return
name|rslt
return|;
block|}
else|else
block|{
return|return
name|sio
operator|.
name|ic_len
return|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_DLPI_SEND
end_ifdef

begin_function
name|void
name|if_register_send
parameter_list|(
name|info
parameter_list|)
name|struct
name|interface_info
modifier|*
name|info
decl_stmt|;
block|{
comment|/* If we're using the DLPI API for sending and receiving, 	   we don't need to register this interface twice. */
ifndef|#
directive|ifndef
name|USE_DLPI_RECEIVE
ifdef|#
directive|ifdef
name|USE_DLPI_PFMOD
name|struct
name|packetfilt
name|pf
decl_stmt|;
endif|#
directive|endif
name|info
operator|->
name|wfdesc
operator|=
name|if_register_dlpi
argument_list|(
name|info
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_DLPI_PFMOD
comment|/* Set up an PFMOD filter that rejects everything... */
name|pf
operator|.
name|Pf_Priority
operator|=
literal|0
expr_stmt|;
name|pf
operator|.
name|Pf_FilterLen
operator|=
literal|1
expr_stmt|;
name|pf
operator|.
name|Pf_Filter
index|[
literal|0
index|]
operator|=
name|ENF_PUSHZERO
expr_stmt|;
comment|/* Install the filter */
if|if
condition|(
name|strioctl
argument_list|(
name|info
operator|->
name|wfdesc
argument_list|,
name|PFIOCSETF
argument_list|,
name|INFTIM
argument_list|,
sizeof|sizeof
argument_list|(
name|pf
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_fatal
argument_list|(
literal|"Can't set PFMOD send filter on %s: %m"
argument_list|,
name|info
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_DLPI_PFMOD */
else|#
directive|else
comment|/* !defined (USE_DLPI_RECEIVE) */
comment|/* 	 * If using DLPI for both send and receive, simply re-use 	 * the read file descriptor that was set up earlier. 	 */
name|info
operator|->
name|wfdesc
operator|=
name|info
operator|->
name|rfdesc
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|quiet_interface_discovery
condition|)
name|log_info
argument_list|(
literal|"Sending on   DLPI/%s/%s%s%s"
argument_list|,
name|info
operator|->
name|name
argument_list|,
name|print_hw_addr
argument_list|(
name|info
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|0
index|]
argument_list|,
name|info
operator|->
name|hw_address
operator|.
name|hlen
operator|-
literal|1
argument_list|,
operator|&
name|info
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|1
index|]
argument_list|)
argument_list|,
operator|(
name|info
operator|->
name|shared_network
condition|?
literal|"/"
else|:
literal|""
operator|)
argument_list|,
operator|(
name|info
operator|->
name|shared_network
condition|?
name|info
operator|->
name|shared_network
operator|->
name|name
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DLPI_FIRST_SEND_WAIT
comment|/* See the implementation notes at the beginning of this file */
ifdef|#
directive|ifdef
name|USE_DLPI_RECEIVE
name|sleep
argument_list|(
name|DLPI_FIRST_SEND_WAIT
operator|-
operator|(
name|DLPI_FIRST_SEND_WAIT
operator|/
literal|2
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|sleep
argument_list|(
name|DLPI_FIRST_SEND_WAIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|if_deregister_send
parameter_list|(
name|info
parameter_list|)
name|struct
name|interface_info
modifier|*
name|info
decl_stmt|;
block|{
comment|/* If we're using the DLPI API for sending and receiving, 	   we don't need to register this interface twice. */
ifndef|#
directive|ifndef
name|USE_DLPI_RECEIVE
name|close
argument_list|(
name|info
operator|->
name|wfdesc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|info
operator|->
name|wfdesc
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|quiet_interface_discovery
condition|)
name|log_info
argument_list|(
literal|"Disabling output on DLPI/%s/%s%s%s"
argument_list|,
name|info
operator|->
name|name
argument_list|,
name|print_hw_addr
argument_list|(
name|info
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|0
index|]
argument_list|,
name|info
operator|->
name|hw_address
operator|.
name|hlen
operator|-
literal|1
argument_list|,
operator|&
name|info
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|1
index|]
argument_list|)
argument_list|,
operator|(
name|info
operator|->
name|shared_network
condition|?
literal|"/"
else|:
literal|""
operator|)
argument_list|,
operator|(
name|info
operator|->
name|shared_network
condition|?
name|info
operator|->
name|shared_network
operator|->
name|name
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_DLPI_SEND */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_DLPI_RECEIVE
end_ifdef

begin_comment
comment|/* Packet filter program...    XXX Changes to the filter program may require changes to the constant    offsets used in if_register_send to patch the NIT program! XXX */
end_comment

begin_function
name|void
name|if_register_receive
parameter_list|(
name|info
parameter_list|)
name|struct
name|interface_info
modifier|*
name|info
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|USE_DLPI_PFMOD
name|struct
name|packetfilt
name|pf
decl_stmt|;
name|struct
name|ip
name|iphdr
decl_stmt|;
name|u_int16_t
name|offset
decl_stmt|;
endif|#
directive|endif
comment|/* Open a DLPI device and hang it on this interface... */
name|info
operator|->
name|rfdesc
operator|=
name|if_register_dlpi
argument_list|(
name|info
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_DLPI_PFMOD
comment|/* Set up the PFMOD filter program. */
comment|/* XXX Unlike the BPF filter program, this one won't work if the 	   XXX IP packet is fragmented or if there are options on the IP 	   XXX header. */
name|pf
operator|.
name|Pf_Priority
operator|=
literal|0
expr_stmt|;
name|pf
operator|.
name|Pf_FilterLen
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_DLPI_RAW
argument_list|)
define|#
directive|define
name|ETHER_H_PREFIX
value|(14)
comment|/* sizeof (ethernet_header) */
comment|/*      * ethertype == ETHERTYPE_IP      */
name|offset
operator|=
literal|12
expr_stmt|;
name|pf
operator|.
name|Pf_Filter
index|[
name|pf
operator|.
name|Pf_FilterLen
operator|++
index|]
operator|=
name|ENF_PUSHWORD
operator|+
operator|(
name|offset
operator|/
literal|2
operator|)
expr_stmt|;
name|pf
operator|.
name|Pf_Filter
index|[
name|pf
operator|.
name|Pf_FilterLen
operator|++
index|]
operator|=
name|ENF_PUSHLIT
operator||
name|ENF_CAND
expr_stmt|;
name|pf
operator|.
name|Pf_Filter
index|[
name|pf
operator|.
name|Pf_FilterLen
operator|++
index|]
operator|=
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
expr_stmt|;
else|#
directive|else
define|#
directive|define
name|ETHER_H_PREFIX
value|(0)
endif|#
directive|endif
comment|/* USE_DLPI_RAW */
comment|/* 	 * The packets that will be received on this file descriptor 	 * will be IP packets (due to the SAP that was specified in 	 * the dlbind call).  There will be no ethernet header. 	 * Therefore, setup the packet filter to check the protocol 	 * field for UDP, and the destination port number equal 	 * to the local port.  All offsets are relative to the start 	 * of an IP packet. 	 */
comment|/*          * BOOTPS destination port          */
name|offset
operator|=
name|ETHER_H_PREFIX
operator|+
sizeof|sizeof
argument_list|(
name|iphdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
expr_stmt|;
name|pf
operator|.
name|Pf_Filter
index|[
name|pf
operator|.
name|Pf_FilterLen
operator|++
index|]
operator|=
name|ENF_PUSHWORD
operator|+
operator|(
name|offset
operator|/
literal|2
operator|)
expr_stmt|;
name|pf
operator|.
name|Pf_Filter
index|[
name|pf
operator|.
name|Pf_FilterLen
operator|++
index|]
operator|=
name|ENF_PUSHLIT
operator||
name|ENF_CAND
expr_stmt|;
name|pf
operator|.
name|Pf_Filter
index|[
name|pf
operator|.
name|Pf_FilterLen
operator|++
index|]
operator|=
name|local_port
expr_stmt|;
comment|/*          * protocol should be udp. this is a byte compare, test for          * endianess.          */
name|offset
operator|=
name|ETHER_H_PREFIX
operator|+
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
operator|(
name|iphdr
operator|.
name|ip_p
operator|)
operator|-
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|iphdr
operator|)
expr_stmt|;
name|pf
operator|.
name|Pf_Filter
index|[
name|pf
operator|.
name|Pf_FilterLen
operator|++
index|]
operator|=
name|ENF_PUSHWORD
operator|+
operator|(
name|offset
operator|/
literal|2
operator|)
expr_stmt|;
name|pf
operator|.
name|Pf_Filter
index|[
name|pf
operator|.
name|Pf_FilterLen
operator|++
index|]
operator|=
name|ENF_PUSHLIT
operator||
name|ENF_AND
expr_stmt|;
name|pf
operator|.
name|Pf_Filter
index|[
name|pf
operator|.
name|Pf_FilterLen
operator|++
index|]
operator|=
name|htons
argument_list|(
literal|0x00FF
argument_list|)
expr_stmt|;
name|pf
operator|.
name|Pf_Filter
index|[
name|pf
operator|.
name|Pf_FilterLen
operator|++
index|]
operator|=
name|ENF_PUSHLIT
operator||
name|ENF_CAND
expr_stmt|;
name|pf
operator|.
name|Pf_Filter
index|[
name|pf
operator|.
name|Pf_FilterLen
operator|++
index|]
operator|=
name|htons
argument_list|(
name|IPPROTO_UDP
argument_list|)
expr_stmt|;
comment|/* Install the filter... */
if|if
condition|(
name|strioctl
argument_list|(
name|info
operator|->
name|rfdesc
argument_list|,
name|PFIOCSETF
argument_list|,
name|INFTIM
argument_list|,
sizeof|sizeof
argument_list|(
name|pf
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_fatal
argument_list|(
literal|"Can't set PFMOD receive filter on %s: %m"
argument_list|,
name|info
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_DLPI_PFMOD */
if|if
condition|(
operator|!
name|quiet_interface_discovery
condition|)
name|log_info
argument_list|(
literal|"Listening on DLPI/%s/%s%s%s"
argument_list|,
name|info
operator|->
name|name
argument_list|,
name|print_hw_addr
argument_list|(
name|info
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|0
index|]
argument_list|,
name|info
operator|->
name|hw_address
operator|.
name|hlen
operator|-
literal|1
argument_list|,
operator|&
name|info
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|1
index|]
argument_list|)
argument_list|,
operator|(
name|info
operator|->
name|shared_network
condition|?
literal|"/"
else|:
literal|""
operator|)
argument_list|,
operator|(
name|info
operator|->
name|shared_network
condition|?
name|info
operator|->
name|shared_network
operator|->
name|name
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DLPI_FIRST_SEND_WAIT
comment|/* See the implementation notes at the beginning of this file */
ifdef|#
directive|ifdef
name|USE_DLPI_SEND
name|sleep
argument_list|(
name|DLPI_FIRST_SEND_WAIT
operator|/
literal|2
argument_list|)
expr_stmt|;
else|#
directive|else
name|sleep
argument_list|(
name|DLPI_FIRST_SEND_WAIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|if_deregister_receive
parameter_list|(
name|info
parameter_list|)
name|struct
name|interface_info
modifier|*
name|info
decl_stmt|;
block|{
comment|/* If we're using the DLPI API for sending and receiving, 	   we don't need to register this interface twice. */
ifndef|#
directive|ifndef
name|USE_DLPI_SEND
name|close
argument_list|(
name|info
operator|->
name|rfdesc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|info
operator|->
name|rfdesc
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|quiet_interface_discovery
condition|)
name|log_info
argument_list|(
literal|"Disabling input on DLPI/%s/%s%s%s"
argument_list|,
name|info
operator|->
name|name
argument_list|,
name|print_hw_addr
argument_list|(
name|info
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|0
index|]
argument_list|,
name|info
operator|->
name|hw_address
operator|.
name|hlen
operator|-
literal|1
argument_list|,
operator|&
name|info
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|1
index|]
argument_list|)
argument_list|,
operator|(
name|info
operator|->
name|shared_network
condition|?
literal|"/"
else|:
literal|""
operator|)
argument_list|,
operator|(
name|info
operator|->
name|shared_network
condition|?
name|info
operator|->
name|shared_network
operator|->
name|name
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_DLPI_RECEIVE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_DLPI_SEND
end_ifdef

begin_function
name|ssize_t
name|send_packet
parameter_list|(
name|interface
parameter_list|,
name|packet
parameter_list|,
name|raw
parameter_list|,
name|len
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|,
name|hto
parameter_list|)
name|struct
name|interface_info
modifier|*
name|interface
decl_stmt|;
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
name|struct
name|dhcp_packet
modifier|*
name|raw
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|struct
name|in_addr
name|from
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|to
decl_stmt|;
name|struct
name|hardware
modifier|*
name|hto
decl_stmt|;
block|{
name|unsigned
name|hbufp
init|=
literal|0
decl_stmt|;
name|double
name|hh
index|[
literal|32
index|]
decl_stmt|;
name|double
name|ih
index|[
literal|1536
operator|/
sizeof|sizeof
argument_list|(
name|double
argument_list|)
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dbuf
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ih
decl_stmt|;
name|unsigned
name|dbuflen
decl_stmt|;
name|unsigned
name|char
name|dstaddr
index|[
name|DLPI_MAXDLADDR
index|]
decl_stmt|;
name|unsigned
name|addrlen
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|fudge
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|interface
operator|->
name|name
argument_list|,
literal|"fallback"
argument_list|)
condition|)
return|return
name|send_fallback
argument_list|(
name|interface
argument_list|,
name|packet
argument_list|,
name|raw
argument_list|,
name|len
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|hto
argument_list|)
return|;
name|dbuflen
operator|=
literal|0
expr_stmt|;
comment|/* Assemble the headers... */
ifdef|#
directive|ifdef
name|USE_DLPI_RAW
name|assemble_hw_header
argument_list|(
name|interface
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|hh
argument_list|,
operator|&
name|dbuflen
argument_list|,
name|hto
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuflen
operator|>
sizeof|sizeof
name|hh
condition|)
name|log_fatal
argument_list|(
literal|"send_packet: hh buffer too small.\n"
argument_list|)
expr_stmt|;
name|fudge
operator|=
name|dbuflen
operator|%
literal|4
expr_stmt|;
comment|/* IP header must be word-aligned. */
name|memcpy
argument_list|(
name|dbuf
operator|+
name|fudge
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|hh
argument_list|,
name|dbuflen
argument_list|)
expr_stmt|;
name|dbuflen
operator|+=
name|fudge
expr_stmt|;
else|#
directive|else
name|fudge
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|assemble_udp_ip_header
argument_list|(
name|interface
argument_list|,
name|dbuf
argument_list|,
operator|&
name|dbuflen
argument_list|,
name|from
operator|.
name|s_addr
argument_list|,
name|to
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|to
operator|->
name|sin_port
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|raw
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Copy the data into the buffer (yuk). */
name|memcpy
argument_list|(
name|dbuf
operator|+
name|dbuflen
argument_list|,
name|raw
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dbuflen
operator|+=
name|len
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_DLPI_RAW
name|result
operator|=
name|write
argument_list|(
name|interface
operator|->
name|wfdesc
argument_list|,
name|dbuf
operator|+
name|fudge
argument_list|,
name|dbuflen
operator|-
name|fudge
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/*          * Setup the destination address (DLSAP) in dstaddr           *          * If sap_length< 0 we must deliver the DLSAP as phys+sap.           * If sap_length> 0 we must deliver the DLSAP as sap+phys.          *          * sap = Service Access Point == ETHERTYPE_IP          * sap + datalink address is called DLSAP in dlpi speak.          */
block|{
comment|/* ENCODE DLSAP */
name|unsigned
name|char
name|phys
index|[
name|DLPI_MAXDLADDR
index|]
decl_stmt|;
name|unsigned
name|char
name|sap
index|[
literal|4
index|]
decl_stmt|;
name|int
name|sap_len
init|=
name|interface
operator|->
name|dlpi_sap_length
decl_stmt|;
name|int
name|phys_len
init|=
name|interface
operator|->
name|hw_address
operator|.
name|hlen
operator|-
literal|1
decl_stmt|;
comment|/* sap = htons (ETHERTYPE_IP) kludge */
name|memset
argument_list|(
name|sap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sap
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
operator|)
name|sap
index|[
literal|0
index|]
operator|=
literal|0x00
expr_stmt|;
name|sap
index|[
literal|1
index|]
operator|=
literal|0x08
expr_stmt|;
else|#
directive|else
name|sap
index|[
literal|0
index|]
operator|=
literal|0x08
expr_stmt|;
name|sap
index|[
literal|1
index|]
operator|=
literal|0x00
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hto
operator|&&
name|hto
operator|->
name|hlen
operator|==
name|interface
operator|->
name|hw_address
operator|.
name|hlen
condition|)
name|memcpy
argument_list|(
name|phys
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|hto
operator|->
name|hbuf
index|[
literal|1
index|]
argument_list|,
name|phys_len
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|phys
argument_list|,
name|interface
operator|->
name|dlpi_broadcast_addr
operator|.
name|hbuf
argument_list|,
name|interface
operator|->
name|dlpi_broadcast_addr
operator|.
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sap_len
operator|<
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|dstaddr
argument_list|,
name|phys
argument_list|,
name|phys_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dstaddr
index|[
name|phys_len
index|]
argument_list|,
name|sap
argument_list|,
name|ABS
argument_list|(
name|sap_len
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|dstaddr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sap
argument_list|,
name|sap_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dstaddr
index|[
name|sap_len
index|]
argument_list|,
name|phys
argument_list|,
name|phys_len
argument_list|)
expr_stmt|;
block|}
name|addrlen
operator|=
name|phys_len
operator|+
name|ABS
argument_list|(
name|sap_len
argument_list|)
expr_stmt|;
block|}
comment|/* ENCODE DLSAP */
name|result
operator|=
name|dlpiunitdatareq
argument_list|(
name|interface
operator|->
name|wfdesc
argument_list|,
name|dstaddr
argument_list|,
name|addrlen
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dbuf
argument_list|,
name|dbuflen
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_DLPI_RAW */
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|log_error
argument_list|(
literal|"send_packet: %m"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_DLPI_SEND */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_DLPI_RECEIVE
end_ifdef

begin_function
name|ssize_t
name|receive_packet
parameter_list|(
name|interface
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|from
parameter_list|,
name|hfrom
parameter_list|)
name|struct
name|interface_info
modifier|*
name|interface
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|from
decl_stmt|;
name|struct
name|hardware
modifier|*
name|hfrom
decl_stmt|;
block|{
name|unsigned
name|char
name|dbuf
index|[
literal|1536
index|]
decl_stmt|;
name|unsigned
name|char
name|srcaddr
index|[
name|DLPI_MAXDLADDR
index|]
decl_stmt|;
name|unsigned
name|long
name|srcaddrlen
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|rslt
decl_stmt|;
name|int
name|bufix
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_DLPI_RAW
name|length
operator|=
name|read
argument_list|(
name|interface
operator|->
name|rfdesc
argument_list|,
name|dbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|dbuf
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|length
operator|=
name|dlpiunitdataind
argument_list|(
name|interface
operator|->
name|rfdesc
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|NULL
argument_list|,
name|srcaddr
argument_list|,
operator|&
name|srcaddrlen
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|NULL
argument_list|,
name|dbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|dbuf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|length
operator|<=
literal|0
condition|)
block|{
return|return
name|length
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|USE_DLPI_RAW
argument_list|)
comment|/*          * Copy the sender's hw address into hfrom          * If sap_len< 0 the DLSAP is as phys+sap.          * If sap_len> 0 the DLSAP is as sap+phys.          *          * sap is discarded here.          */
block|{
comment|/* DECODE DLSAP */
name|int
name|sap_len
init|=
name|interface
operator|->
name|dlpi_sap_length
decl_stmt|;
name|int
name|phys_len
init|=
name|interface
operator|->
name|hw_address
operator|.
name|hlen
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|hfrom
operator|&&
operator|(
name|srcaddrlen
operator|==
name|ABS
argument_list|(
name|sap_len
argument_list|)
operator|+
name|phys_len
operator|)
condition|)
block|{
name|hfrom
operator|->
name|hbuf
index|[
literal|0
index|]
operator|=
name|interface
operator|->
name|hw_address
operator|.
name|hbuf
index|[
literal|0
index|]
expr_stmt|;
name|hfrom
operator|->
name|hlen
operator|=
name|interface
operator|->
name|hw_address
operator|.
name|hlen
expr_stmt|;
if|if
condition|(
name|sap_len
operator|<
literal|0
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|hfrom
operator|->
name|hbuf
index|[
literal|1
index|]
argument_list|,
name|srcaddr
argument_list|,
name|phys_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|hfrom
operator|->
name|hbuf
index|[
literal|1
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|srcaddr
index|[
name|phys_len
index|]
argument_list|,
name|phys_len
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|hfrom
condition|)
block|{
name|memset
argument_list|(
name|hfrom
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
expr|*
name|hfrom
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* DECODE_DLSAP */
endif|#
directive|endif
comment|/* !defined (USE_DLPI_RAW) */
comment|/* Decode the IP and UDP headers... */
name|bufix
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_DLPI_RAW
comment|/* Decode the physical header... */
name|offset
operator|=
name|decode_hw_header
argument_list|(
name|interface
argument_list|,
name|dbuf
argument_list|,
name|bufix
argument_list|,
name|hfrom
argument_list|)
expr_stmt|;
comment|/* If a physical layer checksum failed (dunno of any 	   physical layer that supports this, but WTH), skip this 	   packet. */
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|bufix
operator|+=
name|offset
expr_stmt|;
name|length
operator|-=
name|offset
expr_stmt|;
endif|#
directive|endif
name|offset
operator|=
name|decode_udp_ip_header
argument_list|(
name|interface
argument_list|,
name|dbuf
argument_list|,
name|bufix
argument_list|,
name|from
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/* If the IP or UDP checksum was bad, skip the packet... */
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|bufix
operator|+=
name|offset
expr_stmt|;
name|length
operator|-=
name|offset
expr_stmt|;
comment|/* Copy out the data in the packet... */
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|dbuf
index|[
name|bufix
index|]
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Common DLPI routines ...  *  * Written by Eric James Negaard,<lmdejn@lmd.ericsson.se>  *  * Based largely in part to the example code contained in the document  * "How to Use the STREAMS Data Link Provider Interface (DLPI)", written  * by Neal Nuckolls of SunSoft Internet Engineering.  *   * This code has been developed and tested on sparc-based machines running  * SunOS 5.5.1, with le and hme network interfaces.  It should be pretty  * generic, though.  *   * The usual disclaimers apply.  This code works for me.  Don't blame me  * if it makes your machine or network go down in flames.  That taken  * into consideration, use this code as you wish.  If you make usefull  * modifications I'd appreciate hearing about it.  */
end_comment

begin_define
define|#
directive|define
name|DLPI_MAXWAIT
value|15
end_define

begin_comment
comment|/* Max timeout */
end_comment

begin_comment
comment|/*  * Parse an interface name and extract the unit number  */
end_comment

begin_function
specifier|static
name|int
name|dlpiunit
parameter_list|(
name|ifname
parameter_list|)
name|char
modifier|*
name|ifname
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|int
name|unit
decl_stmt|;
if|if
condition|(
operator|!
name|ifname
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* Advance to the end of the name */
name|cp
operator|=
name|ifname
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* Back up to the start of the first digit */
while|while
condition|(
operator|(
operator|*
operator|(
name|cp
operator|-
literal|1
operator|)
operator|>=
literal|'0'
operator|&&
operator|*
operator|(
name|cp
operator|-
literal|1
operator|)
operator|<=
literal|'9'
operator|)
operator|||
operator|*
operator|(
name|cp
operator|-
literal|1
operator|)
operator|==
literal|':'
condition|)
name|cp
operator|--
expr_stmt|;
comment|/* Convert the unit number */
name|unit
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|>=
literal|'0'
operator|&&
operator|*
name|cp
operator|<=
literal|'9'
condition|)
block|{
name|unit
operator|*=
literal|10
expr_stmt|;
name|unit
operator|+=
operator|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
return|return
name|unit
return|;
block|}
end_function

begin_comment
comment|/*  * dlpiopen - open the DLPI device for a given interface name  */
end_comment

begin_function
specifier|static
name|int
name|dlpiopen
parameter_list|(
name|ifname
parameter_list|)
name|char
modifier|*
name|ifname
decl_stmt|;
block|{
name|char
name|devname
index|[
literal|50
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
operator|!
name|ifname
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
comment|/* Open a DLPI device */
if|if
condition|(
operator|*
name|ifname
operator|==
literal|'/'
condition|)
block|{
name|dp
operator|=
name|devname
expr_stmt|;
block|}
else|else
block|{
comment|/* Prepend the device directory */
name|memcpy
argument_list|(
name|devname
argument_list|,
name|DLPI_DEVDIR
argument_list|,
name|strlen
argument_list|(
name|DLPI_DEVDIR
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|=
operator|&
name|devname
index|[
name|strlen
argument_list|(
name|DLPI_DEVDIR
argument_list|)
index|]
expr_stmt|;
block|}
comment|/* Find the end of the interface name */
name|ep
operator|=
name|cp
operator|=
name|ifname
expr_stmt|;
while|while
condition|(
operator|*
name|ep
condition|)
name|ep
operator|++
expr_stmt|;
comment|/* And back up to the first digit (unit number) */
while|while
condition|(
operator|(
operator|*
operator|(
name|ep
operator|-
literal|1
operator|)
operator|>=
literal|'0'
operator|&&
operator|*
operator|(
name|ep
operator|-
literal|1
operator|)
operator|<=
literal|'9'
operator|)
operator|||
operator|*
operator|(
name|ep
operator|-
literal|1
operator|)
operator|==
literal|':'
condition|)
name|ep
operator|--
expr_stmt|;
comment|/* Copy everything up to the unit number */
while|while
condition|(
name|cp
operator|<
name|ep
condition|)
block|{
operator|*
name|dp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
operator|*
name|dp
operator|=
literal|'\0'
expr_stmt|;
return|return
name|open
argument_list|(
name|devname
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * dlpiinforeq - request information about the data link provider.  */
end_comment

begin_function
specifier|static
name|int
name|dlpiinforeq
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
name|dl_info_req_t
name|info_req
decl_stmt|;
name|struct
name|strbuf
name|ctl
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|info_req
operator|.
name|dl_primitive
operator|=
name|DL_INFO_REQ
expr_stmt|;
name|ctl
operator|.
name|maxlen
operator|=
literal|0
expr_stmt|;
name|ctl
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
name|info_req
argument_list|)
expr_stmt|;
name|ctl
operator|.
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|info_req
expr_stmt|;
name|flags
operator|=
name|RS_HIPRI
expr_stmt|;
return|return
name|putmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|ctl
argument_list|,
operator|(
expr|struct
name|strbuf
operator|*
operator|)
name|NULL
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * dlpiphysaddrreq - request the current physical address.  */
end_comment

begin_function
specifier|static
name|int
name|dlpiphysaddrreq
parameter_list|(
name|fd
parameter_list|,
name|addrtype
parameter_list|)
name|int
name|fd
decl_stmt|;
name|unsigned
name|long
name|addrtype
decl_stmt|;
block|{
name|dl_phys_addr_req_t
name|physaddr_req
decl_stmt|;
name|struct
name|strbuf
name|ctl
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|physaddr_req
operator|.
name|dl_primitive
operator|=
name|DL_PHYS_ADDR_REQ
expr_stmt|;
name|physaddr_req
operator|.
name|dl_addr_type
operator|=
name|addrtype
expr_stmt|;
name|ctl
operator|.
name|maxlen
operator|=
literal|0
expr_stmt|;
name|ctl
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
name|physaddr_req
argument_list|)
expr_stmt|;
name|ctl
operator|.
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|physaddr_req
expr_stmt|;
name|flags
operator|=
name|RS_HIPRI
expr_stmt|;
return|return
name|putmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|ctl
argument_list|,
operator|(
expr|struct
name|strbuf
operator|*
operator|)
name|NULL
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * dlpiattachreq - send a request to attach to a specific unit.  */
end_comment

begin_function
specifier|static
name|int
name|dlpiattachreq
parameter_list|(
name|fd
parameter_list|,
name|ppa
parameter_list|)
name|unsigned
name|long
name|ppa
decl_stmt|;
name|int
name|fd
decl_stmt|;
block|{
name|dl_attach_req_t
name|attach_req
decl_stmt|;
name|struct
name|strbuf
name|ctl
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|attach_req
operator|.
name|dl_primitive
operator|=
name|DL_ATTACH_REQ
expr_stmt|;
name|attach_req
operator|.
name|dl_ppa
operator|=
name|ppa
expr_stmt|;
name|ctl
operator|.
name|maxlen
operator|=
literal|0
expr_stmt|;
name|ctl
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
name|attach_req
argument_list|)
expr_stmt|;
name|ctl
operator|.
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|attach_req
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
return|return
name|putmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|ctl
argument_list|,
operator|(
expr|struct
name|strbuf
operator|*
operator|)
name|NULL
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * dlpibindreq - send a request to bind to a specific SAP address.  */
end_comment

begin_function
specifier|static
name|int
name|dlpibindreq
parameter_list|(
name|fd
parameter_list|,
name|sap
parameter_list|,
name|max_conind
parameter_list|,
name|service_mode
parameter_list|,
name|conn_mgmt
parameter_list|,
name|xidtest
parameter_list|)
name|unsigned
name|long
name|sap
decl_stmt|;
name|unsigned
name|long
name|max_conind
decl_stmt|;
name|unsigned
name|long
name|service_mode
decl_stmt|;
name|unsigned
name|long
name|conn_mgmt
decl_stmt|;
name|unsigned
name|long
name|xidtest
decl_stmt|;
name|int
name|fd
decl_stmt|;
block|{
name|dl_bind_req_t
name|bind_req
decl_stmt|;
name|struct
name|strbuf
name|ctl
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|bind_req
operator|.
name|dl_primitive
operator|=
name|DL_BIND_REQ
expr_stmt|;
name|bind_req
operator|.
name|dl_sap
operator|=
name|sap
expr_stmt|;
name|bind_req
operator|.
name|dl_max_conind
operator|=
name|max_conind
expr_stmt|;
name|bind_req
operator|.
name|dl_service_mode
operator|=
name|service_mode
expr_stmt|;
name|bind_req
operator|.
name|dl_conn_mgmt
operator|=
name|conn_mgmt
expr_stmt|;
name|bind_req
operator|.
name|dl_xidtest_flg
operator|=
name|xidtest
expr_stmt|;
name|ctl
operator|.
name|maxlen
operator|=
literal|0
expr_stmt|;
name|ctl
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
name|bind_req
argument_list|)
expr_stmt|;
name|ctl
operator|.
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|bind_req
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
return|return
name|putmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|ctl
argument_list|,
operator|(
expr|struct
name|strbuf
operator|*
operator|)
name|NULL
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * dlpiunbindreq - send a request to unbind.  */
end_comment

begin_function
specifier|static
name|int
name|dlpiunbindreq
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
name|dl_unbind_req_t
name|unbind_req
decl_stmt|;
name|struct
name|strbuf
name|ctl
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|unbind_req
operator|.
name|dl_primitive
operator|=
name|DL_UNBIND_REQ
expr_stmt|;
name|ctl
operator|.
name|maxlen
operator|=
literal|0
expr_stmt|;
name|ctl
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
name|unbind_req
argument_list|)
expr_stmt|;
name|ctl
operator|.
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|unbind_req
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
return|return
name|putmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|ctl
argument_list|,
operator|(
expr|struct
name|strbuf
operator|*
operator|)
name|NULL
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * dlpidetachreq - send a request to detach.  */
end_comment

begin_function
specifier|static
name|int
name|dlpidetachreq
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
name|dl_detach_req_t
name|detach_req
decl_stmt|;
name|struct
name|strbuf
name|ctl
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|detach_req
operator|.
name|dl_primitive
operator|=
name|DL_DETACH_REQ
expr_stmt|;
name|ctl
operator|.
name|maxlen
operator|=
literal|0
expr_stmt|;
name|ctl
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
name|detach_req
argument_list|)
expr_stmt|;
name|ctl
operator|.
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|detach_req
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
return|return
name|putmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|ctl
argument_list|,
operator|(
expr|struct
name|strbuf
operator|*
operator|)
name|NULL
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * dlpibindack - receive an ack to a dlbindreq.  */
end_comment

begin_function
specifier|static
name|int
name|dlpibindack
parameter_list|(
name|fd
parameter_list|,
name|bufp
parameter_list|)
name|char
modifier|*
name|bufp
decl_stmt|;
name|int
name|fd
decl_stmt|;
block|{
name|union
name|DL_primitives
modifier|*
name|dlp
decl_stmt|;
name|struct
name|strbuf
name|ctl
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|ctl
operator|.
name|maxlen
operator|=
name|DLPI_MAXDLBUF
expr_stmt|;
name|ctl
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|ctl
operator|.
name|buf
operator|=
name|bufp
expr_stmt|;
if|if
condition|(
name|strgetmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|ctl
argument_list|,
operator|(
expr|struct
name|strbuf
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|flags
argument_list|,
literal|"dlpibindack"
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|dlp
operator|=
operator|(
expr|union
name|DL_primitives
operator|*
operator|)
name|ctl
operator|.
name|buf
expr_stmt|;
if|if
condition|(
operator|!
name|expected
argument_list|(
name|DL_BIND_ACK
argument_list|,
name|dlp
argument_list|,
name|flags
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ctl
operator|.
name|len
operator|<
sizeof|sizeof
argument_list|(
name|dl_bind_ack_t
argument_list|)
condition|)
block|{
comment|/* Returned structure is too short */
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * dlpiokack - general acknowledgement reception.  */
end_comment

begin_function
specifier|static
name|int
name|dlpiokack
parameter_list|(
name|fd
parameter_list|,
name|bufp
parameter_list|)
name|char
modifier|*
name|bufp
decl_stmt|;
name|int
name|fd
decl_stmt|;
block|{
name|union
name|DL_primitives
modifier|*
name|dlp
decl_stmt|;
name|struct
name|strbuf
name|ctl
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|ctl
operator|.
name|maxlen
operator|=
name|DLPI_MAXDLBUF
expr_stmt|;
name|ctl
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|ctl
operator|.
name|buf
operator|=
name|bufp
expr_stmt|;
if|if
condition|(
name|strgetmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|ctl
argument_list|,
operator|(
expr|struct
name|strbuf
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|flags
argument_list|,
literal|"dlpiokack"
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|dlp
operator|=
operator|(
expr|union
name|DL_primitives
operator|*
operator|)
name|ctl
operator|.
name|buf
expr_stmt|;
if|if
condition|(
operator|!
name|expected
argument_list|(
name|DL_OK_ACK
argument_list|,
name|dlp
argument_list|,
name|flags
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ctl
operator|.
name|len
operator|<
sizeof|sizeof
argument_list|(
name|dl_ok_ack_t
argument_list|)
condition|)
block|{
comment|/* Returned structure is too short */
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * dlpiinfoack - receive an ack to a dlinforeq.  */
end_comment

begin_function
specifier|static
name|int
name|dlpiinfoack
parameter_list|(
name|fd
parameter_list|,
name|bufp
parameter_list|)
name|char
modifier|*
name|bufp
decl_stmt|;
name|int
name|fd
decl_stmt|;
block|{
name|union
name|DL_primitives
modifier|*
name|dlp
decl_stmt|;
name|struct
name|strbuf
name|ctl
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|ctl
operator|.
name|maxlen
operator|=
name|DLPI_MAXDLBUF
expr_stmt|;
name|ctl
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|ctl
operator|.
name|buf
operator|=
name|bufp
expr_stmt|;
if|if
condition|(
name|strgetmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|ctl
argument_list|,
operator|(
expr|struct
name|strbuf
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|flags
argument_list|,
literal|"dlpiinfoack"
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|dlp
operator|=
operator|(
expr|union
name|DL_primitives
operator|*
operator|)
name|ctl
operator|.
name|buf
expr_stmt|;
if|if
condition|(
operator|!
name|expected
argument_list|(
name|DL_INFO_ACK
argument_list|,
name|dlp
argument_list|,
name|flags
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ctl
operator|.
name|len
operator|<
sizeof|sizeof
argument_list|(
name|dl_info_ack_t
argument_list|)
condition|)
block|{
comment|/* Returned structure is too short */
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * dlpiphysaddrack - receive an ack to a dlpiphysaddrreq.  */
end_comment

begin_function
name|int
name|dlpiphysaddrack
parameter_list|(
name|fd
parameter_list|,
name|bufp
parameter_list|)
name|char
modifier|*
name|bufp
decl_stmt|;
name|int
name|fd
decl_stmt|;
block|{
name|union
name|DL_primitives
modifier|*
name|dlp
decl_stmt|;
name|struct
name|strbuf
name|ctl
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|ctl
operator|.
name|maxlen
operator|=
name|DLPI_MAXDLBUF
expr_stmt|;
name|ctl
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|ctl
operator|.
name|buf
operator|=
name|bufp
expr_stmt|;
if|if
condition|(
name|strgetmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|ctl
argument_list|,
operator|(
expr|struct
name|strbuf
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|flags
argument_list|,
literal|"dlpiphysaddrack"
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|dlp
operator|=
operator|(
expr|union
name|DL_primitives
operator|*
operator|)
name|ctl
operator|.
name|buf
expr_stmt|;
if|if
condition|(
operator|!
name|expected
argument_list|(
name|DL_PHYS_ADDR_ACK
argument_list|,
name|dlp
argument_list|,
name|flags
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ctl
operator|.
name|len
operator|<
sizeof|sizeof
argument_list|(
name|dl_phys_addr_ack_t
argument_list|)
condition|)
block|{
comment|/* Returned structure is too short */
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|dlpiunitdatareq
parameter_list|(
name|fd
parameter_list|,
name|addr
parameter_list|,
name|addrlen
parameter_list|,
name|minpri
parameter_list|,
name|maxpri
parameter_list|,
name|dbuf
parameter_list|,
name|dbuflen
parameter_list|)
name|int
name|fd
decl_stmt|;
name|unsigned
name|char
modifier|*
name|addr
decl_stmt|;
name|int
name|addrlen
decl_stmt|;
name|unsigned
name|long
name|minpri
decl_stmt|;
name|unsigned
name|long
name|maxpri
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dbuf
decl_stmt|;
name|int
name|dbuflen
decl_stmt|;
block|{
name|long
name|buf
index|[
name|DLPI_MAXDLBUF
index|]
decl_stmt|;
name|union
name|DL_primitives
modifier|*
name|dlp
decl_stmt|;
name|struct
name|strbuf
name|ctl
decl_stmt|,
name|data
decl_stmt|;
comment|/* Set up the control information... */
name|dlp
operator|=
operator|(
expr|union
name|DL_primitives
operator|*
operator|)
name|buf
expr_stmt|;
name|dlp
operator|->
name|unitdata_req
operator|.
name|dl_primitive
operator|=
name|DL_UNITDATA_REQ
expr_stmt|;
name|dlp
operator|->
name|unitdata_req
operator|.
name|dl_dest_addr_length
operator|=
name|addrlen
expr_stmt|;
name|dlp
operator|->
name|unitdata_req
operator|.
name|dl_dest_addr_offset
operator|=
sizeof|sizeof
argument_list|(
name|dl_unitdata_req_t
argument_list|)
expr_stmt|;
name|dlp
operator|->
name|unitdata_req
operator|.
name|dl_priority
operator|.
name|dl_min
operator|=
name|minpri
expr_stmt|;
name|dlp
operator|->
name|unitdata_req
operator|.
name|dl_priority
operator|.
name|dl_max
operator|=
name|maxpri
expr_stmt|;
comment|/* Append the destination address */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|dlp
operator|->
name|unitdata_req
operator|.
name|dl_dest_addr_offset
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|ctl
operator|.
name|maxlen
operator|=
literal|0
expr_stmt|;
name|ctl
operator|.
name|len
operator|=
name|dlp
operator|->
name|unitdata_req
operator|.
name|dl_dest_addr_offset
operator|+
name|addrlen
expr_stmt|;
name|ctl
operator|.
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
expr_stmt|;
name|data
operator|.
name|maxlen
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|dbuf
expr_stmt|;
name|data
operator|.
name|len
operator|=
name|dbuflen
expr_stmt|;
comment|/* Send the packet down the wire... */
return|return
name|putmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|ctl
argument_list|,
operator|&
name|data
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dlpiunitdataind
parameter_list|(
name|fd
parameter_list|,
name|daddr
parameter_list|,
name|daddrlen
parameter_list|,
name|saddr
parameter_list|,
name|saddrlen
parameter_list|,
name|grpaddr
parameter_list|,
name|dbuf
parameter_list|,
name|dlen
parameter_list|)
name|int
name|fd
decl_stmt|;
name|unsigned
name|char
modifier|*
name|daddr
decl_stmt|;
name|unsigned
name|long
modifier|*
name|daddrlen
decl_stmt|;
name|unsigned
name|char
modifier|*
name|saddr
decl_stmt|;
name|unsigned
name|long
modifier|*
name|saddrlen
decl_stmt|;
name|unsigned
name|long
modifier|*
name|grpaddr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dbuf
decl_stmt|;
name|int
name|dlen
decl_stmt|;
block|{
name|long
name|buf
index|[
name|DLPI_MAXDLBUF
index|]
decl_stmt|;
name|union
name|DL_primitives
modifier|*
name|dlp
decl_stmt|;
name|struct
name|strbuf
name|ctl
decl_stmt|,
name|data
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/* Set up the msg_buf structure... */
name|dlp
operator|=
operator|(
expr|union
name|DL_primitives
operator|*
operator|)
name|buf
expr_stmt|;
name|dlp
operator|->
name|unitdata_ind
operator|.
name|dl_primitive
operator|=
name|DL_UNITDATA_IND
expr_stmt|;
name|ctl
operator|.
name|maxlen
operator|=
name|DLPI_MAXDLBUF
expr_stmt|;
name|ctl
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|ctl
operator|.
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
expr_stmt|;
name|data
operator|.
name|maxlen
operator|=
name|dlen
expr_stmt|;
name|data
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|dbuf
expr_stmt|;
name|result
operator|=
name|getmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|ctl
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ctl
operator|.
name|len
operator|<
sizeof|sizeof
argument_list|(
name|dl_unitdata_ind_t
argument_list|)
operator|||
name|dlp
operator|->
name|unitdata_ind
operator|.
name|dl_primitive
operator|!=
name|DL_UNITDATA_IND
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|data
operator|.
name|len
operator|<=
literal|0
condition|)
block|{
return|return
name|data
operator|.
name|len
return|;
block|}
comment|/* Copy sender info */
if|if
condition|(
name|saddr
condition|)
block|{
name|memcpy
argument_list|(
name|saddr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|dlp
operator|->
name|unitdata_ind
operator|.
name|dl_src_addr_offset
argument_list|,
name|dlp
operator|->
name|unitdata_ind
operator|.
name|dl_src_addr_length
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|saddrlen
condition|)
block|{
operator|*
name|saddrlen
operator|=
name|dlp
operator|->
name|unitdata_ind
operator|.
name|dl_src_addr_length
expr_stmt|;
block|}
comment|/* Copy destination info */
if|if
condition|(
name|daddr
condition|)
block|{
name|memcpy
argument_list|(
name|daddr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|dlp
operator|->
name|unitdata_ind
operator|.
name|dl_dest_addr_offset
argument_list|,
name|dlp
operator|->
name|unitdata_ind
operator|.
name|dl_dest_addr_length
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|daddrlen
condition|)
block|{
operator|*
name|daddrlen
operator|=
name|dlp
operator|->
name|unitdata_ind
operator|.
name|dl_dest_addr_length
expr_stmt|;
block|}
if|if
condition|(
name|grpaddr
condition|)
block|{
operator|*
name|grpaddr
operator|=
name|dlp
operator|->
name|unitdata_ind
operator|.
name|dl_group_address
expr_stmt|;
block|}
return|return
name|data
operator|.
name|len
return|;
block|}
end_function

begin_comment
comment|/*  * expected - see if we got what we wanted.  */
end_comment

begin_function
specifier|static
name|int
name|expected
parameter_list|(
name|prim
parameter_list|,
name|dlp
parameter_list|,
name|msgflags
parameter_list|)
name|unsigned
name|long
name|prim
decl_stmt|;
name|union
name|DL_primitives
modifier|*
name|dlp
decl_stmt|;
name|int
name|msgflags
decl_stmt|;
block|{
if|if
condition|(
name|msgflags
operator|!=
name|RS_HIPRI
condition|)
block|{
comment|/* Message was not M_PCPROTO */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|dlp
operator|->
name|dl_primitive
operator|!=
name|prim
condition|)
block|{
comment|/* Incorrect/unexpected return message */
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * strgetmsg - get a message from a stream, with timeout.  */
end_comment

begin_function
specifier|static
name|int
name|strgetmsg
parameter_list|(
name|fd
parameter_list|,
name|ctlp
parameter_list|,
name|datap
parameter_list|,
name|flagsp
parameter_list|,
name|caller
parameter_list|)
name|struct
name|strbuf
modifier|*
name|ctlp
decl_stmt|,
decl|*
name|datap
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|caller
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|flagsp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_POLL
name|struct
name|pollfd
name|pfd
decl_stmt|;
name|int
name|count
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|time_t
name|starttime
decl_stmt|;
name|int
name|to_msec
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_POLL
name|pfd
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
name|pfd
operator|.
name|events
operator|=
name|POLLPRI
expr_stmt|;
comment|/* We're only interested in knowing 				 * when we can receive the next high 				 * priority message. 				 */
name|pfd
operator|.
name|revents
operator|=
literal|0
expr_stmt|;
name|now
operator|=
name|time
argument_list|(
operator|&
name|starttime
argument_list|)
expr_stmt|;
while|while
condition|(
name|now
operator|<=
name|starttime
operator|+
name|DLPI_MAXWAIT
condition|)
block|{
name|to_msec
operator|=
operator|(
operator|(
name|starttime
operator|+
name|DLPI_MAXWAIT
operator|)
operator|-
name|now
operator|)
operator|*
literal|1000
expr_stmt|;
name|count
operator|=
name|poll
argument_list|(
operator|&
name|pfd
argument_list|,
literal|1
argument_list|,
name|to_msec
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
comment|/* log_fatal ("strgetmsg: timeout"); */
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EINTR
condition|)
block|{
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* log_fatal ("poll: %m"); */
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
else|#
directive|else
comment|/* defined (USE_POLL) */
comment|/* 	 * Start timer.  Can't use select, since it might return true if there 	 * were non High-Priority data available on the stream. 	 */
operator|(
name|void
operator|)
name|sigset
argument_list|(
name|SIGALRM
argument_list|,
name|sigalrm
argument_list|)
expr_stmt|;
if|if
condition|(
name|alarm
argument_list|(
name|DLPI_MAXWAIT
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* log_fatal ("alarm: %m"); */
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* !defined (USE_POLL) */
comment|/* 	 * Set flags argument and issue getmsg (). 	 */
operator|*
name|flagsp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|=
name|getmsg
argument_list|(
name|fd
argument_list|,
name|ctlp
argument_list|,
name|datap
argument_list|,
name|flagsp
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
return|return
name|result
return|;
block|}
ifndef|#
directive|ifndef
name|USE_POLL
comment|/* 	 * Stop timer. 	 */
if|if
condition|(
name|alarm
argument_list|(
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* log_fatal ("alarm: %m"); */
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* 	 * Check for MOREDATA and/or MORECTL. 	 */
if|if
condition|(
name|result
operator|&
operator|(
name|MORECTL
operator||
name|MOREDATA
operator|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * Check for at least sizeof (long) control data portion. 	 */
if|if
condition|(
name|ctlp
operator|->
name|len
operator|<
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|USE_POLL
end_ifndef

begin_comment
comment|/*  * sigalrm - handle alarms.  */
end_comment

begin_function
specifier|static
name|void
name|sigalrm
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"strgetmsg: timeout"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined (USE_POLL) */
end_comment

begin_function
name|int
name|can_unicast_without_arp
parameter_list|(
name|ip
parameter_list|)
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|can_receive_unicast_unconfigured
parameter_list|(
name|ip
parameter_list|)
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|supports_multiple_interfaces
parameter_list|(
name|ip
parameter_list|)
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|maybe_setup_fallback
parameter_list|()
block|{
name|isc_result_t
name|status
decl_stmt|;
name|struct
name|interface_info
modifier|*
name|fbi
init|=
operator|(
expr|struct
name|interface_info
operator|*
operator|)
literal|0
decl_stmt|;
if|if
condition|(
name|setup_fallback
argument_list|(
operator|&
name|fbi
argument_list|,
name|MDL
argument_list|)
condition|)
block|{
name|if_register_fallback
argument_list|(
name|fbi
argument_list|)
expr_stmt|;
name|status
operator|=
name|omapi_register_io_object
argument_list|(
operator|(
name|omapi_object_t
operator|*
operator|)
name|fbi
argument_list|,
name|if_readsocket
argument_list|,
literal|0
argument_list|,
name|fallback_discard
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ISC_R_SUCCESS
condition|)
name|log_fatal
argument_list|(
literal|"Can't register I/O handle for %s: %s"
argument_list|,
name|fbi
operator|->
name|name
argument_list|,
name|isc_result_totext
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|interface_dereference
argument_list|(
operator|&
name|fbi
argument_list|,
name|MDL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_DLPI */
end_comment

end_unit

