begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dispatch.c     Network input dispatcher... */
end_comment

begin_comment
comment|/*  * Copyright (c) 1995, 1996, 1997, 1998, 1999  * The Internet Software Consortium.   All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of The Internet Software Consortium nor the names  *    of its contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND  * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * This software has been written for the Internet Software Consortium  * by Ted Lemon<mellon@fugue.com> in cooperation with Vixie  * Enterprises.  To learn more about the Internet Software Consortium,  * see ``http://www.vix.com/isc''.  To learn more about Vixie  * Enterprises, see ``http://www.vix.com''.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"$Id: dispatch.c,v 1.47.2.15 1999/07/13 12:51:55 mellon Exp $ Copyright (c) 1995, 1996, 1997, 1998, 1999 The Internet Software Consortium.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"dhcpd.h"
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_decl_stmt
name|struct
name|interface_info
modifier|*
name|interfaces
decl_stmt|,
modifier|*
name|dummy_interfaces
decl_stmt|,
modifier|*
name|fallback_interface
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|protocol
modifier|*
name|protocols
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|timeout
modifier|*
name|timeouts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timeout
modifier|*
name|free_timeouts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|interfaces_invalidated
decl_stmt|;
end_decl_stmt

begin_macro
name|void
argument_list|(
argument|*bootp_packet_handler
argument_list|)
end_macro

begin_expr_stmt
name|PROTO
argument_list|(
operator|(
expr|struct
name|interface_info
operator|*
operator|,
expr|struct
name|dhcp_packet
operator|*
operator|,
name|int
operator|,
name|unsigned
name|int
operator|,
expr|struct
name|iaddr
operator|,
expr|struct
name|hardware
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|quiet_interface_discovery
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use the SIOCGIFCONF ioctl to get a list of all the attached interfaces.    For each interface that's of type INET and not the loopback interface,    register that interface with the network I/O software, figure out what    subnet it's on, and add it to the list of interfaces. */
end_comment

begin_function
name|void
name|discover_interfaces
parameter_list|(
name|state
parameter_list|)
name|int
name|state
decl_stmt|;
block|{
name|struct
name|interface_info
modifier|*
name|tmp
decl_stmt|;
name|struct
name|interface_info
modifier|*
name|last
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|char
name|buf
index|[
literal|8192
index|]
decl_stmt|;
name|struct
name|ifconf
name|ic
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|sock
decl_stmt|;
name|struct
name|subnet
modifier|*
name|subnet
decl_stmt|;
name|struct
name|shared_network
modifier|*
name|share
decl_stmt|;
name|struct
name|sockaddr_in
name|foo
decl_stmt|;
name|int
name|ir
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|tif
decl_stmt|;
ifdef|#
directive|ifdef
name|ALIAS_NAMES_PERMUTED
name|char
modifier|*
name|s
decl_stmt|;
endif|#
directive|endif
comment|/* Create an unbound datagram socket to do the SIOCGIFADDR ioctl on. */
if|if
condition|(
operator|(
name|sock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
name|IPPROTO_UDP
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Can't create addrlist socket"
argument_list|)
expr_stmt|;
comment|/* Get the interface configuration information... */
name|ic
operator|.
name|ifc_len
operator|=
sizeof|sizeof
name|buf
expr_stmt|;
name|ic
operator|.
name|ifc_ifcu
operator|.
name|ifcu_buf
operator|=
operator|(
name|caddr_t
operator|)
name|buf
expr_stmt|;
name|i
operator|=
name|ioctl
argument_list|(
name|sock
argument_list|,
name|SIOCGIFCONF
argument_list|,
operator|&
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"ioctl: SIOCGIFCONF: %m"
argument_list|)
expr_stmt|;
comment|/* If we already have a list of interfaces, and we're running as 	   a DHCP server, the interfaces were requested. */
if|if
condition|(
name|interfaces
operator|&&
operator|(
name|state
operator|==
name|DISCOVER_SERVER
operator|||
name|state
operator|==
name|DISCOVER_RELAY
operator|||
name|state
operator|==
name|DISCOVER_REQUESTED
operator|)
condition|)
name|ir
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|==
name|DISCOVER_UNCONFIGURED
condition|)
name|ir
operator|=
name|INTERFACE_REQUESTED
operator||
name|INTERFACE_AUTOMATIC
expr_stmt|;
else|else
name|ir
operator|=
name|INTERFACE_REQUESTED
expr_stmt|;
comment|/* Cycle through the list of interfaces looking for IP addresses. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ic
operator|.
name|ifc_len
condition|;
control|)
block|{
name|struct
name|ifreq
modifier|*
name|ifp
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ic
operator|.
name|ifc_req
operator|+
name|i
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SA_LEN
if|if
condition|(
name|ifp
operator|->
name|ifr_addr
operator|.
name|sa_len
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
condition|)
name|i
operator|+=
operator|(
sizeof|sizeof
name|ifp
operator|->
name|ifr_name
operator|)
operator|+
name|ifp
operator|->
name|ifr_addr
operator|.
name|sa_len
expr_stmt|;
else|else
endif|#
directive|endif
name|i
operator|+=
sizeof|sizeof
expr|*
name|ifp
expr_stmt|;
ifdef|#
directive|ifdef
name|ALIAS_NAMES_PERMUTED
if|if
condition|(
operator|(
name|s
operator|=
name|strrchr
argument_list|(
name|ifp
operator|->
name|ifr_name
argument_list|,
literal|':'
argument_list|)
operator|)
condition|)
block|{
operator|*
name|s
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SKIP_DUMMY_INTERFACES
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ifp
operator|->
name|ifr_name
argument_list|,
literal|"dummy"
argument_list|,
literal|5
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
comment|/* See if this is the sort of interface we want to 		   deal with. */
name|strcpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|ifp
operator|->
name|ifr_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Can't get interface flags for %s: %m"
argument_list|,
name|ifr
operator|.
name|ifr_name
argument_list|)
expr_stmt|;
comment|/* Skip loopback, point-to-point and down interfaces, 		   except don't skip down interfaces if we're trying to 		   get a list of configurable interfaces. */
if|if
condition|(
operator|(
name|ifr
operator|.
name|ifr_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|||
ifdef|#
directive|ifdef
name|HAVE_IFF_POINTOPOINT
operator|(
name|ifr
operator|.
name|ifr_flags
operator|&
name|IFF_POINTOPOINT
operator|)
operator|||
endif|#
directive|endif
operator|(
operator|!
operator|(
name|ifr
operator|.
name|ifr_flags
operator|&
name|IFF_UP
operator|)
operator|&&
name|state
operator|!=
name|DISCOVER_UNCONFIGURED
operator|)
condition|)
continue|continue;
comment|/* See if we've seen an interface that matches this one. */
for|for
control|(
name|tmp
operator|=
name|interfaces
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tmp
operator|->
name|name
argument_list|,
name|ifp
operator|->
name|ifr_name
argument_list|)
condition|)
break|break;
comment|/* If there isn't already an interface by this name, 		   allocate one. */
if|if
condition|(
operator|!
name|tmp
condition|)
block|{
name|tmp
operator|=
operator|(
operator|(
expr|struct
name|interface_info
operator|*
operator|)
name|dmalloc
argument_list|(
sizeof|sizeof
expr|*
name|tmp
argument_list|,
literal|"discover_interfaces"
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
name|error
argument_list|(
literal|"Insufficient memory to %s %s"
argument_list|,
literal|"record interface"
argument_list|,
name|ifp
operator|->
name|ifr_name
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
operator|->
name|name
argument_list|,
name|ifp
operator|->
name|ifr_name
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|next
operator|=
name|interfaces
expr_stmt|;
name|tmp
operator|->
name|flags
operator|=
name|ir
expr_stmt|;
name|interfaces
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* If we have the capability, extract link information 		   and record it in a linked list. */
ifdef|#
directive|ifdef
name|HAVE_AF_LINK
if|if
condition|(
name|ifp
operator|->
name|ifr_addr
operator|.
name|sa_family
operator|==
name|AF_LINK
condition|)
block|{
name|struct
name|sockaddr_dl
modifier|*
name|foo
init|=
operator|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
operator|(
operator|&
name|ifp
operator|->
name|ifr_addr
operator|)
operator|)
decl_stmt|;
name|tmp
operator|->
name|hw_address
operator|.
name|hlen
operator|=
name|foo
operator|->
name|sdl_alen
expr_stmt|;
name|tmp
operator|->
name|hw_address
operator|.
name|htype
operator|=
name|HTYPE_ETHER
expr_stmt|;
comment|/* XXX */
name|memcpy
argument_list|(
name|tmp
operator|->
name|hw_address
operator|.
name|haddr
argument_list|,
name|LLADDR
argument_list|(
name|foo
argument_list|)
argument_list|,
name|foo
operator|->
name|sdl_alen
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* AF_LINK */
if|if
condition|(
name|ifp
operator|->
name|ifr_addr
operator|.
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|struct
name|iaddr
name|addr
decl_stmt|;
comment|/* Get a pointer to the address... */
name|memcpy
argument_list|(
operator|&
name|foo
argument_list|,
operator|&
name|ifp
operator|->
name|ifr_addr
argument_list|,
sizeof|sizeof
name|ifp
operator|->
name|ifr_addr
argument_list|)
expr_stmt|;
comment|/* We don't want the loopback interface. */
if|if
condition|(
name|foo
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|htonl
argument_list|(
name|INADDR_LOOPBACK
argument_list|)
condition|)
continue|continue;
comment|/* If this is the first real IP address we've 			   found, keep a pointer to ifreq structure in 			   which we found it. */
if|if
condition|(
operator|!
name|tmp
operator|->
name|ifp
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SA_LEN
name|int
name|len
init|=
operator|(
operator|(
sizeof|sizeof
name|ifp
operator|->
name|ifr_name
operator|)
operator|+
name|ifp
operator|->
name|ifr_addr
operator|.
name|sa_len
operator|)
decl_stmt|;
else|#
directive|else
name|int
name|len
init|=
sizeof|sizeof
expr|*
name|ifp
decl_stmt|;
endif|#
directive|endif
name|tif
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tif
condition|)
name|error
argument_list|(
literal|"no space to remember ifp."
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tif
argument_list|,
name|ifp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|ifp
operator|=
name|tif
expr_stmt|;
name|tmp
operator|->
name|primary_address
operator|=
name|foo
operator|.
name|sin_addr
expr_stmt|;
block|}
comment|/* Grab the address... */
name|addr
operator|.
name|len
operator|=
literal|4
expr_stmt|;
name|memcpy
argument_list|(
name|addr
operator|.
name|iabuf
argument_list|,
operator|&
name|foo
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|addr
operator|.
name|len
argument_list|)
expr_stmt|;
comment|/* If there's a registered subnet for this address, 			   connect it together... */
if|if
condition|(
operator|(
name|subnet
operator|=
name|find_subnet
argument_list|(
name|addr
argument_list|)
operator|)
condition|)
block|{
comment|/* If this interface has multiple aliases 				   on the same subnet, ignore all but the 				   first we encounter. */
if|if
condition|(
operator|!
name|subnet
operator|->
name|interface
condition|)
block|{
name|subnet
operator|->
name|interface
operator|=
name|tmp
expr_stmt|;
name|subnet
operator|->
name|interface_address
operator|=
name|addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|subnet
operator|->
name|interface
operator|!=
name|tmp
condition|)
block|{
name|warn
argument_list|(
literal|"Multiple %s %s: %s %s"
argument_list|,
literal|"interfaces match the"
argument_list|,
literal|"same subnet"
argument_list|,
name|subnet
operator|->
name|interface
operator|->
name|name
argument_list|,
name|tmp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|share
operator|=
name|subnet
operator|->
name|shared_network
expr_stmt|;
if|if
condition|(
name|tmp
operator|->
name|shared_network
operator|&&
name|tmp
operator|->
name|shared_network
operator|!=
name|share
condition|)
block|{
name|warn
argument_list|(
literal|"Interface %s matches %s"
argument_list|,
name|tmp
operator|->
name|name
argument_list|,
literal|"multiple shared networks"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|->
name|shared_network
operator|=
name|share
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|share
operator|->
name|interface
condition|)
block|{
name|share
operator|->
name|interface
operator|=
name|tmp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|share
operator|->
name|interface
operator|!=
name|tmp
condition|)
block|{
name|warn
argument_list|(
literal|"Multiple %s %s: %s %s"
argument_list|,
literal|"interfaces match the"
argument_list|,
literal|"same shared network"
argument_list|,
name|share
operator|->
name|interface
operator|->
name|name
argument_list|,
name|tmp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|LINUX_SLASHPROC_DISCOVERY
argument_list|)
comment|/* On Linux, interfaces that don't have IP addresses don't show up 	   in the SIOCGIFCONF syscall.   We got away with this prior to 	   Linux 2.1 because we would give each interface an IP address of 	   0.0.0.0 before trying to boot, but that doesn't work after 2.1 	   because we're using LPF, because we can't configure interfaces 	   with IP addresses of 0.0.0.0 anymore (grumble).   This only 	   matters for the DHCP client, of course - the relay agent and 	   server should only care about interfaces that are configured 	   with IP addresses anyway.  	   The PROCDEV_DEVICE (/proc/net/dev) is a kernel-supplied file 	   that, when read, prints a human readable network status.   We 	   extract the names of the network devices by skipping the first 	   two lines (which are header) and then parsing off everything 	   up to the colon in each subsequent line - these lines start 	   with the interface name, then a colon, then a bunch of 	   statistics.   Yes, Virgina, this is a kludge, but you work 	   with what you have. */
if|if
condition|(
name|state
operator|==
name|DISCOVER_UNCONFIGURED
condition|)
block|{
name|FILE
modifier|*
name|proc_dev
decl_stmt|;
name|char
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|int
name|skip
init|=
literal|2
decl_stmt|;
name|proc_dev
operator|=
name|fopen
argument_list|(
name|PROCDEV_DEVICE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|proc_dev
condition|)
name|error
argument_list|(
literal|"%s: %m"
argument_list|,
name|PROCDEV_DEVICE
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|proc_dev
argument_list|)
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|buffer
decl_stmt|;
name|char
modifier|*
name|sep
decl_stmt|;
comment|/* Skip the first two blocks, which are header 			   lines. */
if|if
condition|(
name|skip
condition|)
block|{
operator|--
name|skip
expr_stmt|;
continue|continue;
block|}
name|sep
operator|=
name|strrchr
argument_list|(
name|buffer
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
condition|)
operator|*
name|sep
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|name
operator|==
literal|' '
condition|)
name|name
operator|++
expr_stmt|;
comment|/* See if we've seen an interface that matches 			   this one. */
for|for
control|(
name|tmp
operator|=
name|interfaces
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tmp
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
break|break;
comment|/* If we found one, nothing more to do.. */
if|if
condition|(
name|tmp
condition|)
continue|continue;
comment|/* Otherwise, allocate one. */
name|tmp
operator|=
operator|(
operator|(
expr|struct
name|interface_info
operator|*
operator|)
name|dmalloc
argument_list|(
sizeof|sizeof
expr|*
name|tmp
argument_list|,
literal|"discover_interfaces"
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
name|error
argument_list|(
literal|"Insufficient memory to %s %s"
argument_list|,
literal|"record interface"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|tmp
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|flags
operator|=
name|ir
expr_stmt|;
name|tmp
operator|->
name|next
operator|=
name|interfaces
expr_stmt|;
name|interfaces
operator|=
name|tmp
expr_stmt|;
block|}
name|fclose
argument_list|(
name|proc_dev
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Now cycle through all the interfaces we found, looking for 	   hardware addresses. */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SIOCGIFHWADDR
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_AF_LINK
argument_list|)
for|for
control|(
name|tmp
operator|=
name|interfaces
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
block|{
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|struct
name|sockaddr
name|sa
decl_stmt|;
name|int
name|b
decl_stmt|,
name|sk
decl_stmt|;
if|if
condition|(
operator|!
name|tmp
operator|->
name|ifp
condition|)
block|{
comment|/* Make up an ifreq structure. */
name|tif
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tif
condition|)
name|error
argument_list|(
literal|"no space to remember ifp."
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tif
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tif
operator|->
name|ifr_name
argument_list|,
name|tmp
operator|->
name|name
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|ifp
operator|=
name|tif
expr_stmt|;
block|}
comment|/* Read the hardware address from this interface. */
name|ifr
operator|=
operator|*
name|tmp
operator|->
name|ifp
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock
argument_list|,
name|SIOCGIFHWADDR
argument_list|,
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
name|sa
operator|=
operator|*
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ifr
operator|.
name|ifr_hwaddr
expr_stmt|;
switch|switch
condition|(
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_ARPHRD_TUNNEL
case|case
name|ARPHRD_TUNNEL
case|:
comment|/* ignore tunnel interfaces. */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ARPHRD_ROSE
case|case
name|ARPHRD_ROSE
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ARPHRD_LOOPBACK
case|case
name|ARPHRD_LOOPBACK
case|:
comment|/* ignore loopback interface */
break|break;
endif|#
directive|endif
case|case
name|ARPHRD_ETHER
case|:
name|tmp
operator|->
name|hw_address
operator|.
name|hlen
operator|=
literal|6
expr_stmt|;
name|tmp
operator|->
name|hw_address
operator|.
name|htype
operator|=
name|ARPHRD_ETHER
expr_stmt|;
name|memcpy
argument_list|(
name|tmp
operator|->
name|hw_address
operator|.
name|haddr
argument_list|,
name|sa
operator|.
name|sa_data
argument_list|,
literal|6
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|HAVE_ARPHRD_IEEE802
define|#
directive|define
name|ARPHRD_IEEE802
value|HTYPE_IEEE802
endif|#
directive|endif
case|case
name|ARPHRD_IEEE802
case|:
name|tmp
operator|->
name|hw_address
operator|.
name|hlen
operator|=
literal|6
expr_stmt|;
name|tmp
operator|->
name|hw_address
operator|.
name|htype
operator|=
name|ARPHRD_IEEE802
expr_stmt|;
name|memcpy
argument_list|(
name|tmp
operator|->
name|hw_address
operator|.
name|haddr
argument_list|,
name|sa
operator|.
name|sa_data
argument_list|,
literal|6
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|HAVE_ARPHRD_FDDI
define|#
directive|define
name|ARPHRD_FDDI
value|HTYPE_FDDI
endif|#
directive|endif
case|case
name|ARPHRD_FDDI
case|:
name|tmp
operator|->
name|hw_address
operator|.
name|hlen
operator|=
literal|16
expr_stmt|;
name|tmp
operator|->
name|hw_address
operator|.
name|htype
operator|=
name|HTYPE_FDDI
expr_stmt|;
comment|/* XXX */
name|memcpy
argument_list|(
name|tmp
operator|->
name|hw_address
operator|.
name|haddr
argument_list|,
name|sa
operator|.
name|sa_data
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAVE_ARPHRD_METRICOM
case|case
name|ARPHRD_METRICOM
case|:
name|tmp
operator|->
name|hw_address
operator|.
name|hlen
operator|=
literal|6
expr_stmt|;
name|tmp
operator|->
name|hw_address
operator|.
name|htype
operator|=
name|ARPHRD_METRICOM
expr_stmt|;
name|memcpy
argument_list|(
name|tmp
operator|->
name|hw_address
operator|.
name|haddr
argument_list|,
name|sa
operator|.
name|sa_data
argument_list|,
literal|6
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ARPHRD_AX25
case|case
name|ARPHRD_AX25
case|:
name|tmp
operator|->
name|hw_address
operator|.
name|hlen
operator|=
literal|6
expr_stmt|;
name|tmp
operator|->
name|hw_address
operator|.
name|htype
operator|=
name|ARPHRD_AX25
expr_stmt|;
name|memcpy
argument_list|(
name|tmp
operator|->
name|hw_address
operator|.
name|haddr
argument_list|,
name|sa
operator|.
name|sa_data
argument_list|,
literal|6
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ARPHRD_NETROM
case|case
name|ARPHRD_NETROM
case|:
name|tmp
operator|->
name|hw_address
operator|.
name|hlen
operator|=
literal|6
expr_stmt|;
name|tmp
operator|->
name|hw_address
operator|.
name|htype
operator|=
name|ARPHRD_NETROM
expr_stmt|;
name|memcpy
argument_list|(
name|tmp
operator|->
name|hw_address
operator|.
name|haddr
argument_list|,
name|sa
operator|.
name|sa_data
argument_list|,
literal|6
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|warn
argument_list|(
literal|"%s: unknown hardware address type %d"
argument_list|,
name|ifr
operator|.
name|ifr_name
argument_list|,
name|sa
operator|.
name|sa_family
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* defined (HAVE_SIOCGIFHWADDR)&& !defined (HAVE_AF_LINK) */
comment|/* If we're just trying to get a list of interfaces that we might 	   be able to configure, we can quit now. */
if|if
condition|(
name|state
operator|==
name|DISCOVER_UNCONFIGURED
condition|)
return|return;
comment|/* Weed out the interfaces that did not have IP addresses. */
name|last
operator|=
operator|(
expr|struct
name|interface_info
operator|*
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|tmp
operator|=
name|interfaces
init|;
name|tmp
condition|;
name|tmp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|->
name|flags
operator|&
name|INTERFACE_AUTOMATIC
operator|)
operator|&&
name|state
operator|==
name|DISCOVER_REQUESTED
condition|)
name|tmp
operator|->
name|flags
operator|&=
operator|~
operator|(
name|INTERFACE_AUTOMATIC
operator||
name|INTERFACE_REQUESTED
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
operator|->
name|ifp
operator|||
operator|!
operator|(
name|tmp
operator|->
name|flags
operator|&
name|INTERFACE_REQUESTED
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|tmp
operator|->
name|flags
operator|&
name|INTERFACE_REQUESTED
operator|)
operator|!=
name|ir
condition|)
name|error
argument_list|(
literal|"%s: not found"
argument_list|,
name|tmp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|last
condition|)
name|interfaces
operator|=
name|interfaces
operator|->
name|next
expr_stmt|;
else|else
name|last
operator|->
name|next
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
comment|/* Remember the interface in case we need to know 			   about it later. */
name|tmp
operator|->
name|next
operator|=
name|dummy_interfaces
expr_stmt|;
name|dummy_interfaces
operator|=
name|tmp
expr_stmt|;
continue|continue;
block|}
name|last
operator|=
name|tmp
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|foo
argument_list|,
operator|&
name|tmp
operator|->
name|ifp
operator|->
name|ifr_addr
argument_list|,
sizeof|sizeof
name|tmp
operator|->
name|ifp
operator|->
name|ifr_addr
argument_list|)
expr_stmt|;
comment|/* We must have a subnet declaration for each interface. */
if|if
condition|(
operator|!
name|tmp
operator|->
name|shared_network
operator|&&
operator|(
name|state
operator|==
name|DISCOVER_SERVER
operator|)
condition|)
block|{
name|warn
argument_list|(
literal|"No subnet declaration for %s (%s)."
argument_list|,
name|tmp
operator|->
name|name
argument_list|,
name|inet_ntoa
argument_list|(
name|foo
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"Please write a subnet declaration in your %s"
argument_list|,
literal|"dhcpd.conf file for the"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"network segment to which interface %s %s"
argument_list|,
name|tmp
operator|->
name|name
argument_list|,
literal|"is attached."
argument_list|)
expr_stmt|;
block|}
comment|/* Find subnets that don't have valid interface 		   addresses... */
for|for
control|(
name|subnet
operator|=
operator|(
name|tmp
operator|->
name|shared_network
condition|?
name|tmp
operator|->
name|shared_network
operator|->
name|subnets
else|:
operator|(
expr|struct
name|subnet
operator|*
operator|)
literal|0
operator|)
init|;
name|subnet
condition|;
name|subnet
operator|=
name|subnet
operator|->
name|next_sibling
control|)
block|{
if|if
condition|(
operator|!
name|subnet
operator|->
name|interface_address
operator|.
name|len
condition|)
block|{
comment|/* Set the interface address for this subnet 				   to the first address we found. */
name|subnet
operator|->
name|interface_address
operator|.
name|len
operator|=
literal|4
expr_stmt|;
name|memcpy
argument_list|(
name|subnet
operator|->
name|interface_address
operator|.
name|iabuf
argument_list|,
operator|&
name|foo
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Register the interface... */
name|if_register_receive
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|if_register_send
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* Now register all the remaining interfaces as protocols. */
for|for
control|(
name|tmp
operator|=
name|interfaces
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
name|add_protocol
argument_list|(
name|tmp
operator|->
name|name
argument_list|,
name|tmp
operator|->
name|rfdesc
argument_list|,
name|got_one
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|maybe_setup_fallback
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|interface_info
modifier|*
name|setup_fallback
parameter_list|()
block|{
name|fallback_interface
operator|=
operator|(
operator|(
expr|struct
name|interface_info
operator|*
operator|)
name|dmalloc
argument_list|(
sizeof|sizeof
expr|*
name|fallback_interface
argument_list|,
literal|"discover_interfaces"
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|fallback_interface
condition|)
name|error
argument_list|(
literal|"Insufficient memory to record fallback interface."
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fallback_interface
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|fallback_interface
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|fallback_interface
operator|->
name|name
argument_list|,
literal|"fallback"
argument_list|)
expr_stmt|;
name|fallback_interface
operator|->
name|shared_network
operator|=
name|new_shared_network
argument_list|(
literal|"parse_statement"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fallback_interface
operator|->
name|shared_network
condition|)
name|error
argument_list|(
literal|"No memory for shared subnet"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fallback_interface
operator|->
name|shared_network
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|shared_network
argument_list|)
argument_list|)
expr_stmt|;
name|fallback_interface
operator|->
name|shared_network
operator|->
name|name
operator|=
literal|"fallback-net"
expr_stmt|;
return|return
name|fallback_interface
return|;
block|}
end_function

begin_function
name|void
name|reinitialize_interfaces
parameter_list|()
block|{
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
for|for
control|(
name|ip
operator|=
name|interfaces
init|;
name|ip
condition|;
name|ip
operator|=
name|ip
operator|->
name|next
control|)
block|{
name|if_reinitialize_receive
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|if_reinitialize_send
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fallback_interface
condition|)
name|if_reinitialize_send
argument_list|(
name|fallback_interface
argument_list|)
expr_stmt|;
name|interfaces_invalidated
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_POLL
end_ifdef

begin_comment
comment|/* Wait for packets to come in using poll().  When a packet comes in,    call receive_packet to receive the packet and possibly strip hardware    addressing information from it, and then call through the    bootp_packet_handler hook to try to do something with it. */
end_comment

begin_function
name|void
name|dispatch
parameter_list|()
block|{
name|struct
name|protocol
modifier|*
name|l
decl_stmt|;
name|int
name|nfds
init|=
literal|0
decl_stmt|;
name|struct
name|pollfd
modifier|*
name|fds
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|to_msec
decl_stmt|;
name|nfds
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|l
operator|=
name|protocols
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
operator|++
name|nfds
expr_stmt|;
block|}
name|fds
operator|=
operator|(
expr|struct
name|pollfd
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|nfds
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pollfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fds
condition|)
name|error
argument_list|(
literal|"Can't allocate poll structures."
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* Call any expired timeouts, and then if there's 		   still a timeout registered, time out the select 		   call then. */
name|another
label|:
if|if
condition|(
name|timeouts
condition|)
block|{
name|struct
name|timeout
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|timeouts
operator|->
name|when
operator|<=
name|cur_time
condition|)
block|{
name|t
operator|=
name|timeouts
expr_stmt|;
name|timeouts
operator|=
name|timeouts
operator|->
name|next
expr_stmt|;
operator|(
operator|*
operator|(
name|t
operator|->
name|func
operator|)
operator|)
operator|(
name|t
operator|->
name|what
operator|)
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|free_timeouts
expr_stmt|;
name|free_timeouts
operator|=
name|t
expr_stmt|;
goto|goto
name|another
goto|;
block|}
comment|/* Figure timeout in milliseconds, and check for 			   potential overflow.   We assume that integers 			   are 32 bits, which is harmless if they're 64 			   bits - we'll just get extra timeouts in that 			   case.    Lease times would have to be quite 			   long in order for a 32-bit integer to overflow, 			   anyway. */
name|to_msec
operator|=
name|timeouts
operator|->
name|when
operator|-
name|cur_time
expr_stmt|;
if|if
condition|(
name|to_msec
operator|>
literal|2147483
condition|)
name|to_msec
operator|=
literal|2147483
expr_stmt|;
name|to_msec
operator|*=
literal|1000
expr_stmt|;
block|}
else|else
name|to_msec
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Set up the descriptors to be polled. */
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|l
operator|=
name|protocols
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|fds
index|[
name|i
index|]
operator|.
name|fd
operator|=
name|l
operator|->
name|fd
expr_stmt|;
name|fds
index|[
name|i
index|]
operator|.
name|events
operator|=
name|POLLIN
expr_stmt|;
name|fds
index|[
name|i
index|]
operator|.
name|revents
operator|=
literal|0
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
comment|/* Wait for a packet or a timeout... XXX */
name|count
operator|=
name|poll
argument_list|(
name|fds
argument_list|,
name|nfds
argument_list|,
name|to_msec
argument_list|)
expr_stmt|;
comment|/* Get the current time... */
name|GET_TIME
argument_list|(
operator|&
name|cur_time
argument_list|)
expr_stmt|;
comment|/* Not likely to be transitory... */
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
else|else
name|error
argument_list|(
literal|"poll: %m"
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|l
operator|=
name|protocols
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|fds
index|[
name|i
index|]
operator|.
name|revents
operator|&
name|POLLIN
operator|)
condition|)
block|{
name|fds
index|[
name|i
index|]
operator|.
name|revents
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|handler
condition|)
operator|(
operator|*
operator|(
name|l
operator|->
name|handler
operator|)
operator|)
operator|(
name|l
operator|)
expr_stmt|;
if|if
condition|(
name|interfaces_invalidated
condition|)
break|break;
block|}
operator|++
name|i
expr_stmt|;
block|}
name|interfaces_invalidated
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Wait for packets to come in using select().   When one does, call    receive_packet to receive the packet and possibly strip hardware    addressing information from it, and then call through the    bootp_packet_handler hook to try to do something with it. */
end_comment

begin_function
name|void
name|dispatch
parameter_list|()
block|{
name|fd_set
name|r
decl_stmt|,
name|w
decl_stmt|,
name|x
decl_stmt|;
name|struct
name|protocol
modifier|*
name|l
decl_stmt|;
name|int
name|max
init|=
literal|0
decl_stmt|;
name|int
name|count
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|,
modifier|*
name|tvp
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|w
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* Call any expired timeouts, and then if there's 		   still a timeout registered, time out the select 		   call then. */
name|another
label|:
if|if
condition|(
name|timeouts
condition|)
block|{
name|struct
name|timeout
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|timeouts
operator|->
name|when
operator|<=
name|cur_time
condition|)
block|{
name|t
operator|=
name|timeouts
expr_stmt|;
name|timeouts
operator|=
name|timeouts
operator|->
name|next
expr_stmt|;
operator|(
operator|*
operator|(
name|t
operator|->
name|func
operator|)
operator|)
operator|(
name|t
operator|->
name|what
operator|)
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|free_timeouts
expr_stmt|;
name|free_timeouts
operator|=
name|t
expr_stmt|;
goto|goto
name|another
goto|;
block|}
name|tv
operator|.
name|tv_sec
operator|=
name|timeouts
operator|->
name|when
operator|-
name|cur_time
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|tvp
operator|=
operator|&
name|tv
expr_stmt|;
block|}
else|else
name|tvp
operator|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Set up the read mask. */
name|FD_ZERO
argument_list|(
operator|&
name|r
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|protocols
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|FD_SET
argument_list|(
name|l
operator|->
name|fd
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|fd
operator|>
name|max
condition|)
name|max
operator|=
name|l
operator|->
name|fd
expr_stmt|;
block|}
comment|/* Wait for a packet or a timeout... XXX */
name|count
operator|=
name|select
argument_list|(
name|max
operator|+
literal|1
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|w
argument_list|,
operator|&
name|x
argument_list|,
name|tvp
argument_list|)
expr_stmt|;
comment|/* Get the current time... */
name|GET_TIME
argument_list|(
operator|&
name|cur_time
argument_list|)
expr_stmt|;
comment|/* Not likely to be transitory... */
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"select: %m"
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|protocols
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|FD_ISSET
argument_list|(
name|l
operator|->
name|fd
argument_list|,
operator|&
name|r
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|l
operator|->
name|handler
condition|)
operator|(
operator|*
operator|(
name|l
operator|->
name|handler
operator|)
operator|)
operator|(
name|l
operator|)
expr_stmt|;
if|if
condition|(
name|interfaces_invalidated
condition|)
break|break;
block|}
name|interfaces_invalidated
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_POLL */
end_comment

begin_function
name|void
name|got_one
parameter_list|(
name|l
parameter_list|)
name|struct
name|protocol
modifier|*
name|l
decl_stmt|;
block|{
name|struct
name|sockaddr_in
name|from
decl_stmt|;
name|struct
name|hardware
name|hfrom
decl_stmt|;
name|struct
name|iaddr
name|ifrom
decl_stmt|;
name|int
name|result
decl_stmt|;
union|union
block|{
name|unsigned
name|char
name|packbuf
index|[
literal|4095
index|]
decl_stmt|;
comment|/* Packet input buffer. 					 	 Must be as large as largest 						 possible MTU. */
name|struct
name|dhcp_packet
name|packet
decl_stmt|;
block|}
name|u
union|;
name|struct
name|interface_info
modifier|*
name|ip
init|=
name|l
operator|->
name|local
decl_stmt|;
if|if
condition|(
operator|(
name|result
operator|=
name|receive_packet
argument_list|(
name|ip
argument_list|,
name|u
operator|.
name|packbuf
argument_list|,
sizeof|sizeof
name|u
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|hfrom
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"receive_packet failed on %s: %m"
argument_list|,
name|ip
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|result
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|bootp_packet_handler
condition|)
block|{
name|ifrom
operator|.
name|len
operator|=
literal|4
expr_stmt|;
name|memcpy
argument_list|(
name|ifrom
operator|.
name|iabuf
argument_list|,
operator|&
name|from
operator|.
name|sin_addr
argument_list|,
name|ifrom
operator|.
name|len
argument_list|)
expr_stmt|;
call|(
modifier|*
name|bootp_packet_handler
call|)
argument_list|(
name|ip
argument_list|,
operator|&
name|u
operator|.
name|packet
argument_list|,
name|result
argument_list|,
name|from
operator|.
name|sin_port
argument_list|,
name|ifrom
argument_list|,
operator|&
name|hfrom
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|locate_network
parameter_list|(
name|packet
parameter_list|)
name|struct
name|packet
modifier|*
name|packet
decl_stmt|;
block|{
name|struct
name|iaddr
name|ia
decl_stmt|;
comment|/* If this came through a gateway, find the corresponding subnet... */
if|if
condition|(
name|packet
operator|->
name|raw
operator|->
name|giaddr
operator|.
name|s_addr
condition|)
block|{
name|struct
name|subnet
modifier|*
name|subnet
decl_stmt|;
name|ia
operator|.
name|len
operator|=
literal|4
expr_stmt|;
name|memcpy
argument_list|(
name|ia
operator|.
name|iabuf
argument_list|,
operator|&
name|packet
operator|->
name|raw
operator|->
name|giaddr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|subnet
operator|=
name|find_subnet
argument_list|(
name|ia
argument_list|)
expr_stmt|;
if|if
condition|(
name|subnet
condition|)
name|packet
operator|->
name|shared_network
operator|=
name|subnet
operator|->
name|shared_network
expr_stmt|;
else|else
name|packet
operator|->
name|shared_network
operator|=
operator|(
expr|struct
name|shared_network
operator|*
operator|)
literal|0
expr_stmt|;
block|}
else|else
block|{
name|packet
operator|->
name|shared_network
operator|=
name|packet
operator|->
name|interface
operator|->
name|shared_network
expr_stmt|;
block|}
if|if
condition|(
name|packet
operator|->
name|shared_network
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function_decl
name|void
name|add_timeout
parameter_list|(
name|when
parameter_list|,
name|where
parameter_list|,
name|what
parameter_list|)
name|TIME
name|when
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*where
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
modifier|*
name|what
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|timeout
modifier|*
name|t
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* See if this timeout supersedes an existing timeout. */
name|t
operator|=
operator|(
expr|struct
name|timeout
operator|*
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|q
operator|=
name|timeouts
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
block|{
if|if
condition|(
name|q
operator|->
name|func
operator|==
name|where
operator|&&
name|q
operator|->
name|what
operator|==
name|what
condition|)
block|{
if|if
condition|(
name|t
condition|)
name|t
operator|->
name|next
operator|=
name|q
operator|->
name|next
expr_stmt|;
else|else
name|timeouts
operator|=
name|q
operator|->
name|next
expr_stmt|;
break|break;
block|}
name|t
operator|=
name|q
expr_stmt|;
block|}
comment|/* If we didn't supersede a timeout, allocate a timeout 	   structure now. */
if|if
condition|(
operator|!
name|q
condition|)
block|{
if|if
condition|(
name|free_timeouts
condition|)
block|{
name|q
operator|=
name|free_timeouts
expr_stmt|;
name|free_timeouts
operator|=
name|q
operator|->
name|next
expr_stmt|;
name|q
operator|->
name|func
operator|=
name|where
expr_stmt|;
name|q
operator|->
name|what
operator|=
name|what
expr_stmt|;
block|}
else|else
block|{
name|q
operator|=
operator|(
expr|struct
name|timeout
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|timeout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
condition|)
name|error
argument_list|(
literal|"Can't allocate timeout structure!"
argument_list|)
expr_stmt|;
name|q
operator|->
name|func
operator|=
name|where
expr_stmt|;
name|q
operator|->
name|what
operator|=
name|what
expr_stmt|;
block|}
block|}
name|q
operator|->
name|when
operator|=
name|when
expr_stmt|;
comment|/* Now sort this timeout into the timeout list. */
comment|/* Beginning of list? */
if|if
condition|(
operator|!
name|timeouts
operator|||
name|timeouts
operator|->
name|when
operator|>
name|q
operator|->
name|when
condition|)
block|{
name|q
operator|->
name|next
operator|=
name|timeouts
expr_stmt|;
name|timeouts
operator|=
name|q
expr_stmt|;
return|return;
block|}
comment|/* Middle of list? */
for|for
control|(
name|t
operator|=
name|timeouts
init|;
name|t
operator|->
name|next
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
if|if
condition|(
name|t
operator|->
name|next
operator|->
name|when
operator|>
name|q
operator|->
name|when
condition|)
block|{
name|q
operator|->
name|next
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|q
expr_stmt|;
return|return;
block|}
block|}
comment|/* End of list. */
name|t
operator|->
name|next
operator|=
name|q
expr_stmt|;
name|q
operator|->
name|next
operator|=
operator|(
expr|struct
name|timeout
operator|*
operator|)
literal|0
expr_stmt|;
block|}
end_block

begin_function_decl
name|void
name|cancel_timeout
parameter_list|(
name|where
parameter_list|,
name|what
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*where
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
modifier|*
name|what
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|timeout
modifier|*
name|t
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* Look for this timeout on the list, and unlink it if we find it. */
name|t
operator|=
operator|(
expr|struct
name|timeout
operator|*
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|q
operator|=
name|timeouts
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
block|{
if|if
condition|(
name|q
operator|->
name|func
operator|==
name|where
operator|&&
name|q
operator|->
name|what
operator|==
name|what
condition|)
block|{
if|if
condition|(
name|t
condition|)
name|t
operator|->
name|next
operator|=
name|q
operator|->
name|next
expr_stmt|;
else|else
name|timeouts
operator|=
name|q
operator|->
name|next
expr_stmt|;
break|break;
block|}
name|t
operator|=
name|q
expr_stmt|;
block|}
comment|/* If we found the timeout, put it on the free list. */
if|if
condition|(
name|q
condition|)
block|{
name|q
operator|->
name|next
operator|=
name|free_timeouts
expr_stmt|;
name|free_timeouts
operator|=
name|q
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Add a protocol to the list of protocols... */
end_comment

begin_function_decl
name|void
name|add_protocol
parameter_list|(
name|name
parameter_list|,
name|fd
parameter_list|,
name|handler
parameter_list|,
name|local
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|fd
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*handler
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
expr|struct
name|protocol
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
modifier|*
name|local
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|protocol
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|protocol
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|error
argument_list|(
literal|"can't allocate protocol struct for %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|p
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|p
operator|->
name|handler
operator|=
name|handler
expr_stmt|;
name|p
operator|->
name|local
operator|=
name|local
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|protocols
expr_stmt|;
name|protocols
operator|=
name|p
expr_stmt|;
block|}
end_block

begin_function
name|void
name|remove_protocol
parameter_list|(
name|proto
parameter_list|)
name|struct
name|protocol
modifier|*
name|proto
decl_stmt|;
block|{
name|struct
name|protocol
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|prev
operator|=
operator|(
expr|struct
name|protocol
operator|*
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|protocols
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|proto
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
else|else
name|protocols
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

