begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004 Apple Computer, Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1.  Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.   * 2.  Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.   * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of  *     its contributors may be used to endorse or promote products derived  *     from this software without specific prior written permission.   *   * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  * $P4: //depot/projects/trustedbsd/openbsm/bin/auditreduce/auditreduce.c#13 $  */
end_comment

begin_comment
comment|/*   * Tool used to merge and select audit records from audit trail files   */
end_comment

begin_comment
comment|/*  * XXX Currently we do not support merging of records from multiple  * XXX audit trail files  * XXX We assume that records are sorted chronologically - both wrt to   * XXX the records present within the file and between the files themselves  */
end_comment

begin_include
include|#
directive|include
file|<bsm/libbsm.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"auditreduce.h"
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|optind
decl_stmt|,
name|optopt
decl_stmt|,
name|opterr
decl_stmt|,
name|optreset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|au_mask_t
name|maskp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Class. */
end_comment

begin_decl_stmt
specifier|static
name|time_t
name|p_atime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Created after this time. */
end_comment

begin_decl_stmt
specifier|static
name|time_t
name|p_btime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Created before this time. */
end_comment

begin_decl_stmt
specifier|static
name|uint16_t
name|p_evtype
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Event that we are searching for. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|p_auid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Audit id. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|p_euid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Effective user id. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|p_egid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Effective group id. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|p_rgid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Real group id. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|p_ruid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Real user id. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|p_subid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Subject id. */
end_comment

begin_comment
comment|/*  * Following are the objects (-o option) that we can select upon.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|p_fileobj
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|p_msgqobj
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|p_pidobj
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|p_semobj
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|p_shmobj
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|p_sockobj
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|opttochk
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|usage
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: auditreduce [options] audit-trail-file [....] \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tOptions are : \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-A : all records\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-a YYYYMMDD[HH[[MM[SS]]] : after date\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-b YYYYMMDD[HH[[MM[SS]]] : before date\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-c<flags> : matching class\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-d YYYYMMDD : on date\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-e<uid|name>  : effective user\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-f<gid|group> : effective group\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-g<gid|group> : real group\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-j<pid> : subject id \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-m<evno|evname> : matching event\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-o objecttype=objectvalue\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t file=<pathname>\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t msgqid=<ID>\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t pid=<ID>\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t semid=<ID>\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t shmid=<ID>\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-r<uid|name> : real user\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-u<uid|name> : audit user\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check if the given auid matches the selection criteria.  */
end_comment

begin_function
specifier|static
name|int
name|select_auid
parameter_list|(
name|int
name|au
parameter_list|)
block|{
comment|/* Check if we want to select on auid. */
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_u
argument_list|)
condition|)
block|{
if|if
condition|(
name|au
operator|!=
name|p_auid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the given euid matches the selection criteria.  */
end_comment

begin_function
specifier|static
name|int
name|select_euid
parameter_list|(
name|int
name|euser
parameter_list|)
block|{
comment|/* Check if we want to select on euid. */
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_e
argument_list|)
condition|)
block|{
if|if
condition|(
name|euser
operator|!=
name|p_euid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the given egid matches the selection criteria.  */
end_comment

begin_function
specifier|static
name|int
name|select_egid
parameter_list|(
name|int
name|egrp
parameter_list|)
block|{
comment|/* Check if we want to select on egid. */
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_f
argument_list|)
condition|)
block|{
if|if
condition|(
name|egrp
operator|!=
name|p_egid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the given rgid matches the selection criteria.  */
end_comment

begin_function
specifier|static
name|int
name|select_rgid
parameter_list|(
name|int
name|grp
parameter_list|)
block|{
comment|/* Check if we want to select on rgid. */
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_g
argument_list|)
condition|)
block|{
if|if
condition|(
name|grp
operator|!=
name|p_rgid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the given ruid matches the selection criteria.  */
end_comment

begin_function
specifier|static
name|int
name|select_ruid
parameter_list|(
name|int
name|user
parameter_list|)
block|{
comment|/* Check if we want to select on rgid. */
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_r
argument_list|)
condition|)
block|{
if|if
condition|(
name|user
operator|!=
name|p_ruid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the given subject id (pid) matches the selection criteria.  */
end_comment

begin_function
specifier|static
name|int
name|select_subid
parameter_list|(
name|int
name|subid
parameter_list|)
block|{
comment|/* Check if we want to select on subject uid. */
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_j
argument_list|)
condition|)
block|{
if|if
condition|(
name|subid
operator|!=
name|p_subid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if object's pid maches the given pid.  */
end_comment

begin_function
specifier|static
name|int
name|select_pidobj
parameter_list|(
name|uint32_t
name|pid
parameter_list|)
block|{
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_op
argument_list|)
condition|)
block|{
if|if
condition|(
name|pid
operator|!=
name|strtol
argument_list|(
name|p_pidobj
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the given ipc object with the given type matches the selection  * criteria.  */
end_comment

begin_function
specifier|static
name|int
name|select_ipcobj
parameter_list|(
name|u_char
name|type
parameter_list|,
name|uint32_t
name|id
parameter_list|,
name|uint32_t
modifier|*
name|optchkd
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|AT_IPC_MSG
condition|)
block|{
name|SETOPT
argument_list|(
operator|(
operator|*
name|optchkd
operator|)
argument_list|,
name|OPT_om
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_om
argument_list|)
condition|)
block|{
if|if
condition|(
name|id
operator|!=
name|strtol
argument_list|(
name|p_msgqobj
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|AT_IPC_SEM
condition|)
block|{
name|SETOPT
argument_list|(
operator|(
operator|*
name|optchkd
operator|)
argument_list|,
name|OPT_ose
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_ose
argument_list|)
condition|)
block|{
if|if
condition|(
name|id
operator|!=
name|strtol
argument_list|(
name|p_semobj
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|AT_IPC_SHM
condition|)
block|{
name|SETOPT
argument_list|(
operator|(
operator|*
name|optchkd
operator|)
argument_list|,
name|OPT_osh
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_osh
argument_list|)
condition|)
block|{
if|if
condition|(
name|id
operator|!=
name|strtol
argument_list|(
name|p_shmobj
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Unknown type -- filter if *any* ipc filtering is required. */
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_om
argument_list|)
operator|||
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_ose
argument_list|)
operator|||
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_osh
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the file name matches selection criteria.  */
end_comment

begin_function
specifier|static
name|int
name|select_filepath
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|uint32_t
modifier|*
name|optchkd
parameter_list|)
block|{
name|char
modifier|*
name|loc
decl_stmt|;
name|SETOPT
argument_list|(
operator|(
operator|*
name|optchkd
operator|)
argument_list|,
name|OPT_of
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_of
argument_list|)
condition|)
block|{
if|if
condition|(
name|p_fileobj
index|[
literal|0
index|]
operator|==
literal|'~'
condition|)
block|{
comment|/* Object should not be in path. */
name|loc
operator|=
name|strstr
argument_list|(
name|path
argument_list|,
name|p_fileobj
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|loc
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|loc
operator|==
name|path
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* Object should be in path. */
name|loc
operator|=
name|strstr
argument_list|(
name|path
argument_list|,
name|p_fileobj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|loc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|loc
operator|!=
name|path
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns 1 if the following pass the selection rules:  *  * before-time,   * after time,   * date,   * class,   * event   */
end_comment

begin_function
specifier|static
name|int
name|select_hdr32
parameter_list|(
name|tokenstr_t
name|tok
parameter_list|,
name|uint32_t
modifier|*
name|optchkd
parameter_list|)
block|{
name|SETOPT
argument_list|(
operator|(
operator|*
name|optchkd
operator|)
argument_list|,
operator|(
name|OPT_A
operator||
name|OPT_a
operator||
name|OPT_b
operator||
name|OPT_c
operator||
name|OPT_m
operator|)
argument_list|)
expr_stmt|;
comment|/* The A option overrides a, b and d. */
if|if
condition|(
operator|!
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_A
argument_list|)
condition|)
block|{
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_a
argument_list|)
condition|)
block|{
if|if
condition|(
name|difftime
argument_list|(
operator|(
name|time_t
operator|)
name|tok
operator|.
name|tt
operator|.
name|hdr32
operator|.
name|s
argument_list|,
name|p_atime
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Record was created before p_atime. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_b
argument_list|)
condition|)
block|{
if|if
condition|(
name|difftime
argument_list|(
name|p_btime
argument_list|,
operator|(
name|time_t
operator|)
name|tok
operator|.
name|tt
operator|.
name|hdr32
operator|.
name|s
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Record was created after p_btime. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_c
argument_list|)
condition|)
block|{
comment|/* 		 * Check if the classes represented by the event matches 		 * given class. 		 */
if|if
condition|(
name|au_preselect
argument_list|(
name|tok
operator|.
name|tt
operator|.
name|hdr32
operator|.
name|e_type
argument_list|,
operator|&
name|maskp
argument_list|,
name|AU_PRS_BOTH
argument_list|,
name|AU_PRS_USECACHE
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Check if event matches. */
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_m
argument_list|)
condition|)
block|{
if|if
condition|(
name|tok
operator|.
name|tt
operator|.
name|hdr32
operator|.
name|e_type
operator|!=
name|p_evtype
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return 1 if checks for the the following succeed  * auid,   * euid,   * egid,   * rgid,   * ruid,   * process id  */
end_comment

begin_function
specifier|static
name|int
name|select_proc32
parameter_list|(
name|tokenstr_t
name|tok
parameter_list|,
name|uint32_t
modifier|*
name|optchkd
parameter_list|)
block|{
name|SETOPT
argument_list|(
operator|(
operator|*
name|optchkd
operator|)
argument_list|,
operator|(
name|OPT_u
operator||
name|OPT_e
operator||
name|OPT_f
operator||
name|OPT_g
operator||
name|OPT_r
operator||
name|OPT_op
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|select_auid
argument_list|(
name|tok
operator|.
name|tt
operator|.
name|proc32
operator|.
name|auid
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|select_euid
argument_list|(
name|tok
operator|.
name|tt
operator|.
name|proc32
operator|.
name|euid
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|select_egid
argument_list|(
name|tok
operator|.
name|tt
operator|.
name|proc32
operator|.
name|egid
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|select_rgid
argument_list|(
name|tok
operator|.
name|tt
operator|.
name|proc32
operator|.
name|rgid
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|select_ruid
argument_list|(
name|tok
operator|.
name|tt
operator|.
name|proc32
operator|.
name|ruid
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|select_pidobj
argument_list|(
name|tok
operator|.
name|tt
operator|.
name|proc32
operator|.
name|pid
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return 1 if checks for the the following succeed  * auid,   * euid,   * egid,   * rgid,   * ruid,   * subject id  */
end_comment

begin_function
specifier|static
name|int
name|select_subj32
parameter_list|(
name|tokenstr_t
name|tok
parameter_list|,
name|uint32_t
modifier|*
name|optchkd
parameter_list|)
block|{
name|SETOPT
argument_list|(
operator|(
operator|*
name|optchkd
operator|)
argument_list|,
operator|(
name|OPT_u
operator||
name|OPT_e
operator||
name|OPT_f
operator||
name|OPT_g
operator||
name|OPT_r
operator||
name|OPT_j
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|select_auid
argument_list|(
name|tok
operator|.
name|tt
operator|.
name|subj32
operator|.
name|auid
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|select_euid
argument_list|(
name|tok
operator|.
name|tt
operator|.
name|subj32
operator|.
name|euid
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|select_egid
argument_list|(
name|tok
operator|.
name|tt
operator|.
name|subj32
operator|.
name|egid
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|select_rgid
argument_list|(
name|tok
operator|.
name|tt
operator|.
name|subj32
operator|.
name|rgid
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|select_ruid
argument_list|(
name|tok
operator|.
name|tt
operator|.
name|subj32
operator|.
name|ruid
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|select_subid
argument_list|(
name|tok
operator|.
name|tt
operator|.
name|subj32
operator|.
name|pid
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read each record from the audit trail.  Check if it is selected after  * passing through each of the options   */
end_comment

begin_function
specifier|static
name|int
name|select_records
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|u_char
modifier|*
name|buf
decl_stmt|;
name|tokenstr_t
name|tok
decl_stmt|;
name|int
name|reclen
decl_stmt|;
name|int
name|bytesread
decl_stmt|;
name|int
name|selected
decl_stmt|;
name|uint32_t
name|optchkd
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|reclen
operator|=
name|au_read_rec
argument_list|(
name|fp
argument_list|,
operator|&
name|buf
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|optchkd
operator|=
literal|0
expr_stmt|;
name|bytesread
operator|=
literal|0
expr_stmt|;
name|selected
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|selected
operator|==
literal|1
operator|)
operator|&&
operator|(
name|bytesread
operator|<
name|reclen
operator|)
condition|)
block|{
if|if
condition|(
operator|-
literal|1
operator|==
name|au_fetch_tok
argument_list|(
operator|&
name|tok
argument_list|,
name|buf
operator|+
name|bytesread
argument_list|,
name|reclen
operator|-
name|bytesread
argument_list|)
condition|)
block|{
comment|/* Is this an incomplete record? */
name|err
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 			 * For each token type we have have different 			 * selection criteria. 			 */
switch|switch
condition|(
name|tok
operator|.
name|id
condition|)
block|{
case|case
name|AU_HEADER_32_TOKEN
case|:
name|selected
operator|=
name|select_hdr32
argument_list|(
name|tok
argument_list|,
operator|&
name|optchkd
argument_list|)
expr_stmt|;
break|break;
case|case
name|AU_PROCESS_32_TOKEN
case|:
name|selected
operator|=
name|select_proc32
argument_list|(
name|tok
argument_list|,
operator|&
name|optchkd
argument_list|)
expr_stmt|;
break|break;
case|case
name|AU_SUBJECT_32_TOKEN
case|:
name|selected
operator|=
name|select_subj32
argument_list|(
name|tok
argument_list|,
operator|&
name|optchkd
argument_list|)
expr_stmt|;
break|break;
case|case
name|AU_IPC_TOKEN
case|:
name|selected
operator|=
name|select_ipcobj
argument_list|(
name|tok
operator|.
name|tt
operator|.
name|ipc
operator|.
name|type
argument_list|,
name|tok
operator|.
name|tt
operator|.
name|ipc
operator|.
name|id
argument_list|,
operator|&
name|optchkd
argument_list|)
expr_stmt|;
break|break;
case|case
name|AU_FILE_TOKEN
case|:
name|selected
operator|=
name|select_filepath
argument_list|(
name|tok
operator|.
name|tt
operator|.
name|file
operator|.
name|name
argument_list|,
operator|&
name|optchkd
argument_list|)
expr_stmt|;
break|break;
case|case
name|AU_PATH_TOKEN
case|:
name|selected
operator|=
name|select_filepath
argument_list|(
name|tok
operator|.
name|tt
operator|.
name|path
operator|.
name|path
argument_list|,
operator|&
name|optchkd
argument_list|)
expr_stmt|;
break|break;
comment|/*  			 * The following tokens dont have any relevant 			 * attributes that we can select upon. 			 */
case|case
name|AU_TRAILER_TOKEN
case|:
case|case
name|AU_ARG32_TOKEN
case|:
case|case
name|AU_ATTR32_TOKEN
case|:
case|case
name|AU_EXIT_TOKEN
case|:
case|case
name|AU_NEWGROUPS_TOKEN
case|:
case|case
name|AU_IN_ADDR_TOKEN
case|:
case|case
name|AU_IP_TOKEN
case|:
case|case
name|AU_IPCPERM_TOKEN
case|:
case|case
name|AU_IPORT_TOKEN
case|:
case|case
name|AU_OPAQUE_TOKEN
case|:
case|case
name|AU_RETURN_32_TOKEN
case|:
case|case
name|AU_SEQ_TOKEN
case|:
case|case
name|AU_TEXT_TOKEN
case|:
case|case
name|AU_ARB_TOKEN
case|:
case|case
name|AU_SOCK_TOKEN
case|:
default|default:
break|break;
block|}
name|bytesread
operator|+=
name|tok
operator|.
name|len
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|selected
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|!
name|err
operator|)
condition|)
block|{
comment|/* Check if all the options were matched. */
if|if
condition|(
operator|!
operator|(
name|opttochk
operator|&
operator|~
name|optchkd
operator|)
condition|)
block|{
comment|/* XXX Write this record to the output file. */
comment|/* default to stdout */
name|fwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|reclen
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * The -o option has the form object_type=object_value.  Identify the object  * components.  */
end_comment

begin_function
name|void
name|parse_object_type
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|val
parameter_list|)
block|{
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|FILEOBJ
argument_list|)
condition|)
block|{
name|p_fileobj
operator|=
name|val
expr_stmt|;
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_of
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|MSGQIDOBJ
argument_list|)
condition|)
block|{
name|p_msgqobj
operator|=
name|val
expr_stmt|;
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_om
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|PIDOBJ
argument_list|)
condition|)
block|{
name|p_pidobj
operator|=
name|val
expr_stmt|;
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|SEMIDOBJ
argument_list|)
condition|)
block|{
name|p_semobj
operator|=
name|val
expr_stmt|;
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_ose
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|SHMIDOBJ
argument_list|)
condition|)
block|{
name|p_shmobj
operator|=
name|val
expr_stmt|;
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_osh
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|SOCKOBJ
argument_list|)
condition|)
block|{
name|p_sockobj
operator|=
name|val
expr_stmt|;
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_oso
argument_list|)
expr_stmt|;
block|}
else|else
name|usage
argument_list|(
literal|"unknown value for -o"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|struct
name|tm
name|tm
decl_stmt|;
name|au_event_t
modifier|*
name|n
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|objval
decl_stmt|,
modifier|*
name|converr
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|char
name|timestr
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|converr
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"Aa:b:c:d:e:f:g:j:m:o:r:u:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'A'
case|:
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_A
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_a
argument_list|)
condition|)
block|{
name|usage
argument_list|(
literal|"d is exclusive with a and b"
argument_list|)
expr_stmt|;
block|}
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_a
argument_list|)
expr_stmt|;
name|strptime
argument_list|(
name|optarg
argument_list|,
literal|"%Y%m%d%H%M%S"
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
name|strftime
argument_list|(
name|timestr
argument_list|,
sizeof|sizeof
argument_list|(
name|timestr
argument_list|)
argument_list|,
literal|"%Y%m%d%H%M%S"
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
comment|/* fprintf(stderr, "Time converted = %s\n", timestr); */
name|p_atime
operator|=
name|mktime
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_b
argument_list|)
condition|)
block|{
name|usage
argument_list|(
literal|"d is exclusive with a and b"
argument_list|)
expr_stmt|;
block|}
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_b
argument_list|)
expr_stmt|;
name|strptime
argument_list|(
name|optarg
argument_list|,
literal|"%Y%m%d%H%M%S"
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
name|strftime
argument_list|(
name|timestr
argument_list|,
sizeof|sizeof
argument_list|(
name|timestr
argument_list|)
argument_list|,
literal|"%Y%m%d%H%M%S"
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
comment|/* fprintf(stderr, "Time converted = %s\n", timestr); */
name|p_btime
operator|=
name|mktime
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
literal|0
operator|!=
name|getauditflagsbin
argument_list|(
name|optarg
argument_list|,
operator|&
name|maskp
argument_list|)
condition|)
block|{
comment|/* Incorrect class */
name|usage
argument_list|(
literal|"Incorrect class"
argument_list|)
expr_stmt|;
block|}
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_b
argument_list|)
operator|||
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_a
argument_list|)
condition|)
name|usage
argument_list|(
literal|"'d' is exclusive with 'a' and 'b'"
argument_list|)
expr_stmt|;
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_d
argument_list|)
expr_stmt|;
name|strptime
argument_list|(
name|optarg
argument_list|,
literal|"%Y%m%d"
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
name|strftime
argument_list|(
name|timestr
argument_list|,
sizeof|sizeof
argument_list|(
name|timestr
argument_list|)
argument_list|,
literal|"%Y%m%d"
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
comment|/* fprintf(stderr, "Time converted = %s\n", timestr); */
name|p_atime
operator|=
name|mktime
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
name|tm
operator|.
name|tm_hour
operator|=
literal|23
expr_stmt|;
name|tm
operator|.
name|tm_min
operator|=
literal|59
expr_stmt|;
name|tm
operator|.
name|tm_sec
operator|=
literal|59
expr_stmt|;
name|strftime
argument_list|(
name|timestr
argument_list|,
sizeof|sizeof
argument_list|(
name|timestr
argument_list|)
argument_list|,
literal|"%Y%m%d"
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
comment|/* fprintf(stderr, "Time converted = %s\n", timestr); */
name|p_btime
operator|=
name|mktime
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|p_euid
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|converr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|converr
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Try the actual name */
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|optarg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|p_euid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
block|}
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_e
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|p_egid
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|converr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|converr
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Try actual group name. */
if|if
condition|(
operator|(
name|grp
operator|=
name|getgrnam
argument_list|(
name|optarg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|p_egid
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
block|}
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_f
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|p_rgid
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|converr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|converr
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Try actual group name. */
if|if
condition|(
operator|(
name|grp
operator|=
name|getgrnam
argument_list|(
name|optarg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|p_rgid
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
block|}
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_g
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|p_subid
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_j
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|p_evtype
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_evtype
operator|==
literal|0
condition|)
block|{
comment|/* Could be the string representation. */
name|n
operator|=
name|getauevnonam
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
name|usage
argument_list|(
literal|"Incorrect event name"
argument_list|)
expr_stmt|;
name|p_evtype
operator|=
operator|*
name|n
expr_stmt|;
name|free
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_m
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|objval
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|objval
operator|!=
name|NULL
condition|)
block|{
operator|*
name|objval
operator|=
literal|'\0'
expr_stmt|;
name|objval
operator|+=
literal|1
expr_stmt|;
name|parse_object_type
argument_list|(
name|optarg
argument_list|,
name|objval
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'r'
case|:
name|p_ruid
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|converr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|converr
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|optarg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|p_ruid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
block|}
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_r
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|p_auid
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|converr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|converr
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|optarg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|p_auid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
block|}
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_u
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
literal|"Unknown option"
argument_list|)
expr_stmt|;
block|}
block|}
name|argv
operator|+=
name|optind
expr_stmt|;
name|argc
operator|-=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
name|usage
argument_list|(
literal|"Filename needed"
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: We should actually be merging records here. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|fname
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"Couldn't open %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|select_records
argument_list|(
name|fp
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"Couldn't select records %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

