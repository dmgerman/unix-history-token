begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004-2008 Apple Inc.  * Copyright (c) 2016 Robert N. M. Watson  * All rights reserved.  *  * Portions of this software were developed by BAE Systems, the University of  * Cambridge Computer Laboratory, and Memorial University under DARPA/AFRL  * contract FA8650-15-C-7558 ("CADETS"), as part of the DARPA Transparent  * Computing (TC) research program.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1.  Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.   * 2.  Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.   * 3.  Neither the name of Apple Inc. ("Apple") nor the names of  *     its contributors may be used to endorse or promote products derived  *     from this software without specific prior written permission.   *   * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*   * Tool used to merge and select audit records from audit trail files   */
end_comment

begin_comment
comment|/*  * XXX Currently we do not support merging of records from multiple  * XXX audit trail files  * XXX We assume that records are sorted chronologically - both wrt to   * XXX the records present within the file and between the files themselves  */
end_comment

begin_include
include|#
directive|include
file|<config/config.h>
end_include

begin_define
define|#
directive|define
name|_GNU_SOURCE
end_define

begin_comment
comment|/* Required for strptime() on glibc2. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FULL_QUEUE_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<compat/queue.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CAP_ENTER
end_ifdef

begin_include
include|#
directive|include
file|<sys/capsicum.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<bsm/libbsm.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STRLCPY
end_ifndef

begin_include
include|#
directive|include
file|<compat/strlcpy.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"auditreduce.h"
end_include

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument|tailhead
argument_list|,
argument|re_entry
argument_list|)
name|re_head
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|re_head
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|optind
decl_stmt|,
name|optopt
decl_stmt|,
name|opterr
decl_stmt|,
name|optreset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|au_mask_t
name|maskp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Class. */
end_comment

begin_decl_stmt
specifier|static
name|time_t
name|p_atime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Created after this time. */
end_comment

begin_decl_stmt
specifier|static
name|time_t
name|p_btime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Created before this time. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|p_auid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Audit id. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|p_euid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Effective user id. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|p_egid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Effective group id. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|p_rgid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Real group id. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|p_ruid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Real user id. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|p_subid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Subject id. */
end_comment

begin_comment
comment|/*  * Maintain a dynamically sized array of events for -m  */
end_comment

begin_decl_stmt
specifier|static
name|uint16_t
modifier|*
name|p_evec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Event type list */
end_comment

begin_decl_stmt
specifier|static
name|int
name|p_evec_used
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of events used */
end_comment

begin_decl_stmt
specifier|static
name|int
name|p_evec_alloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of events allocated */
end_comment

begin_comment
comment|/*  * Following are the objects (-o option) that we can select upon.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|p_fileobj
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|p_msgqobj
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|p_pidobj
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|p_semobj
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|p_shmobj
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|p_sockobj
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|opttochk
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|parse_regexp
parameter_list|(
name|char
modifier|*
name|re_string
parameter_list|)
block|{
name|char
modifier|*
name|orig
decl_stmt|,
modifier|*
name|copy
decl_stmt|,
name|re_error
index|[
literal|64
index|]
decl_stmt|;
name|struct
name|re_entry
modifier|*
name|rep
decl_stmt|;
name|int
name|error
decl_stmt|,
name|nstrs
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|;
name|copy
operator|=
name|strdup
argument_list|(
name|re_string
argument_list|)
expr_stmt|;
name|orig
operator|=
name|copy
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|copy
argument_list|)
expr_stmt|;
for|for
control|(
name|nstrs
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|copy
index|[
name|i
index|]
operator|==
literal|','
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|copy
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
name|strlcpy
argument_list|(
operator|&
name|copy
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
operator|&
name|copy
index|[
name|i
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
block|{
name|nstrs
operator|++
expr_stmt|;
name|copy
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|re_head
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nstrs
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|rep
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rep
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"calloc: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|copy
operator|==
literal|'~'
condition|)
block|{
name|copy
operator|++
expr_stmt|;
name|rep
operator|->
name|re_negate
operator|=
literal|1
expr_stmt|;
block|}
name|rep
operator|->
name|re_pattern
operator|=
name|strdup
argument_list|(
name|copy
argument_list|)
expr_stmt|;
name|error
operator|=
name|regcomp
argument_list|(
operator|&
name|rep
operator|->
name|re_regexp
argument_list|,
name|rep
operator|->
name|re_pattern
argument_list|,
name|REG_EXTENDED
operator||
name|REG_NOSUB
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|regerror
argument_list|(
name|error
argument_list|,
operator|&
name|rep
operator|->
name|re_regexp
argument_list|,
name|re_error
argument_list|,
literal|64
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"regcomp: %s\n"
argument_list|,
name|re_error
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|re_head
argument_list|,
name|rep
argument_list|,
name|re_glue
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|copy
argument_list|)
expr_stmt|;
name|copy
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|orig
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: auditreduce [options] [file ...]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tOptions are : \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-A : all records\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-a YYYYMMDD[HH[[MM[SS]]] : after date\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-b YYYYMMDD[HH[[MM[SS]]] : before date\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-c<flags> : matching class\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-d YYYYMMDD : on date\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-e<uid|name>  : effective user\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-f<gid|group> : effective group\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-g<gid|group> : real group\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-j<pid> : subject id \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-m<evno|evname> : matching event\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-o objecttype=objectvalue\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t file=<pathname>\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t msgqid=<ID>\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t pid=<ID>\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t semid=<ID>\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t shmid=<ID>\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-r<uid|name> : real user\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-u<uid|name> : audit user\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-v : select non-matching records\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check if the given auid matches the selection criteria.  */
end_comment

begin_function
specifier|static
name|int
name|select_auid
parameter_list|(
name|int
name|au
parameter_list|)
block|{
comment|/* Check if we want to select on auid. */
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_u
argument_list|)
condition|)
block|{
if|if
condition|(
name|au
operator|!=
name|p_auid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the given euid matches the selection criteria.  */
end_comment

begin_function
specifier|static
name|int
name|select_euid
parameter_list|(
name|int
name|euser
parameter_list|)
block|{
comment|/* Check if we want to select on euid. */
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_e
argument_list|)
condition|)
block|{
if|if
condition|(
name|euser
operator|!=
name|p_euid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the given egid matches the selection criteria.  */
end_comment

begin_function
specifier|static
name|int
name|select_egid
parameter_list|(
name|int
name|egrp
parameter_list|)
block|{
comment|/* Check if we want to select on egid. */
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_f
argument_list|)
condition|)
block|{
if|if
condition|(
name|egrp
operator|!=
name|p_egid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the given rgid matches the selection criteria.  */
end_comment

begin_function
specifier|static
name|int
name|select_rgid
parameter_list|(
name|int
name|grp
parameter_list|)
block|{
comment|/* Check if we want to select on rgid. */
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_g
argument_list|)
condition|)
block|{
if|if
condition|(
name|grp
operator|!=
name|p_rgid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the given ruid matches the selection criteria.  */
end_comment

begin_function
specifier|static
name|int
name|select_ruid
parameter_list|(
name|int
name|user
parameter_list|)
block|{
comment|/* Check if we want to select on rgid. */
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_r
argument_list|)
condition|)
block|{
if|if
condition|(
name|user
operator|!=
name|p_ruid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the given subject id (pid) matches the selection criteria.  */
end_comment

begin_function
specifier|static
name|int
name|select_subid
parameter_list|(
name|int
name|subid
parameter_list|)
block|{
comment|/* Check if we want to select on subject uid. */
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_j
argument_list|)
condition|)
block|{
if|if
condition|(
name|subid
operator|!=
name|p_subid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if object's pid maches the given pid.  */
end_comment

begin_function
specifier|static
name|int
name|select_pidobj
parameter_list|(
name|uint32_t
name|pid
parameter_list|)
block|{
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_op
argument_list|)
condition|)
block|{
if|if
condition|(
name|pid
operator|!=
operator|(
name|uint32_t
operator|)
name|strtol
argument_list|(
name|p_pidobj
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the given ipc object with the given type matches the selection  * criteria.  */
end_comment

begin_function
specifier|static
name|int
name|select_ipcobj
parameter_list|(
name|u_char
name|type
parameter_list|,
name|uint32_t
name|id
parameter_list|,
name|uint32_t
modifier|*
name|optchkd
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|AT_IPC_MSG
condition|)
block|{
name|SETOPT
argument_list|(
operator|(
operator|*
name|optchkd
operator|)
argument_list|,
name|OPT_om
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_om
argument_list|)
condition|)
block|{
if|if
condition|(
name|id
operator|!=
operator|(
name|uint32_t
operator|)
name|strtol
argument_list|(
name|p_msgqobj
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|AT_IPC_SEM
condition|)
block|{
name|SETOPT
argument_list|(
operator|(
operator|*
name|optchkd
operator|)
argument_list|,
name|OPT_ose
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_ose
argument_list|)
condition|)
block|{
if|if
condition|(
name|id
operator|!=
operator|(
name|uint32_t
operator|)
name|strtol
argument_list|(
name|p_semobj
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|AT_IPC_SHM
condition|)
block|{
name|SETOPT
argument_list|(
operator|(
operator|*
name|optchkd
operator|)
argument_list|,
name|OPT_osh
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_osh
argument_list|)
condition|)
block|{
if|if
condition|(
name|id
operator|!=
operator|(
name|uint32_t
operator|)
name|strtol
argument_list|(
name|p_shmobj
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Unknown type -- filter if *any* ipc filtering is required. */
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_om
argument_list|)
operator|||
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_ose
argument_list|)
operator|||
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_osh
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the file name matches selection criteria.  */
end_comment

begin_function
specifier|static
name|int
name|select_filepath
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|uint32_t
modifier|*
name|optchkd
parameter_list|)
block|{
name|struct
name|re_entry
modifier|*
name|rep
decl_stmt|;
name|int
name|match
decl_stmt|;
name|SETOPT
argument_list|(
operator|(
operator|*
name|optchkd
operator|)
argument_list|,
name|OPT_of
argument_list|)
expr_stmt|;
name|match
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_of
argument_list|)
condition|)
block|{
name|match
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|rep
argument_list|,
argument|&re_head
argument_list|,
argument|re_glue
argument_list|)
block|{
if|if
condition|(
name|regexec
argument_list|(
operator|&
name|rep
operator|->
name|re_regexp
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
name|REG_NOMATCH
condition|)
return|return
operator|(
operator|!
name|rep
operator|->
name|re_negate
operator|)
return|;
block|}
block|}
return|return
operator|(
name|match
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns 1 if the following pass the selection rules:  *  * before-time,   * after time,   * date,   * class,   * event   */
end_comment

begin_function
specifier|static
name|int
name|select_hdr32
parameter_list|(
name|tokenstr_t
name|tok
parameter_list|,
name|uint32_t
modifier|*
name|optchkd
parameter_list|)
block|{
name|uint16_t
modifier|*
name|ev
decl_stmt|;
name|int
name|match
decl_stmt|;
name|SETOPT
argument_list|(
operator|(
operator|*
name|optchkd
operator|)
argument_list|,
operator|(
name|OPT_A
operator||
name|OPT_a
operator||
name|OPT_b
operator||
name|OPT_c
operator||
name|OPT_m
operator||
name|OPT_v
operator|)
argument_list|)
expr_stmt|;
comment|/* The A option overrides a, b and d. */
if|if
condition|(
operator|!
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_A
argument_list|)
condition|)
block|{
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_a
argument_list|)
condition|)
block|{
if|if
condition|(
name|difftime
argument_list|(
operator|(
name|time_t
operator|)
name|tok
operator|.
name|tt
operator|.
name|hdr32
operator|.
name|s
argument_list|,
name|p_atime
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Record was created before p_atime. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_b
argument_list|)
condition|)
block|{
if|if
condition|(
name|difftime
argument_list|(
name|p_btime
argument_list|,
operator|(
name|time_t
operator|)
name|tok
operator|.
name|tt
operator|.
name|hdr32
operator|.
name|s
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Record was created after p_btime. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_c
argument_list|)
condition|)
block|{
comment|/* 		 * Check if the classes represented by the event matches 		 * given class. 		 */
if|if
condition|(
name|au_preselect
argument_list|(
name|tok
operator|.
name|tt
operator|.
name|hdr32
operator|.
name|e_type
argument_list|,
operator|&
name|maskp
argument_list|,
name|AU_PRS_BOTH
argument_list|,
name|AU_PRS_USECACHE
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Check if event matches. */
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_m
argument_list|)
condition|)
block|{
name|match
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ev
operator|=
name|p_evec
init|;
name|ev
operator|<
operator|&
name|p_evec
index|[
name|p_evec_used
index|]
condition|;
name|ev
operator|++
control|)
if|if
condition|(
name|tok
operator|.
name|tt
operator|.
name|hdr32
operator|.
name|e_type
operator|==
operator|*
name|ev
condition|)
name|match
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|match
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|select_return32
parameter_list|(
name|tokenstr_t
name|tok_ret32
parameter_list|,
name|tokenstr_t
name|tok_hdr32
parameter_list|,
name|uint32_t
modifier|*
name|optchkd
parameter_list|)
block|{
name|int
name|sorf
decl_stmt|;
name|SETOPT
argument_list|(
operator|(
operator|*
name|optchkd
operator|)
argument_list|,
operator|(
name|OPT_c
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok_ret32
operator|.
name|tt
operator|.
name|ret32
operator|.
name|status
operator|==
literal|0
condition|)
name|sorf
operator|=
name|AU_PRS_SUCCESS
expr_stmt|;
else|else
name|sorf
operator|=
name|AU_PRS_FAILURE
expr_stmt|;
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_c
argument_list|)
condition|)
block|{
if|if
condition|(
name|au_preselect
argument_list|(
name|tok_hdr32
operator|.
name|tt
operator|.
name|hdr32
operator|.
name|e_type
argument_list|,
operator|&
name|maskp
argument_list|,
name|sorf
argument_list|,
name|AU_PRS_USECACHE
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return 1 if checks for the the following succeed  * auid,   * euid,   * egid,   * rgid,   * ruid,   * process id  */
end_comment

begin_function
specifier|static
name|int
name|select_proc32
parameter_list|(
name|tokenstr_t
name|tok
parameter_list|,
name|uint32_t
modifier|*
name|optchkd
parameter_list|)
block|{
name|SETOPT
argument_list|(
operator|(
operator|*
name|optchkd
operator|)
argument_list|,
operator|(
name|OPT_u
operator||
name|OPT_e
operator||
name|OPT_f
operator||
name|OPT_g
operator||
name|OPT_r
operator||
name|OPT_op
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|select_auid
argument_list|(
name|tok
operator|.
name|tt
operator|.
name|proc32
operator|.
name|auid
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|select_euid
argument_list|(
name|tok
operator|.
name|tt
operator|.
name|proc32
operator|.
name|euid
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|select_egid
argument_list|(
name|tok
operator|.
name|tt
operator|.
name|proc32
operator|.
name|egid
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|select_rgid
argument_list|(
name|tok
operator|.
name|tt
operator|.
name|proc32
operator|.
name|rgid
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|select_ruid
argument_list|(
name|tok
operator|.
name|tt
operator|.
name|proc32
operator|.
name|ruid
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|select_pidobj
argument_list|(
name|tok
operator|.
name|tt
operator|.
name|proc32
operator|.
name|pid
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return 1 if checks for the the following succeed  * auid,   * euid,   * egid,   * rgid,   * ruid,   * subject id  */
end_comment

begin_function
specifier|static
name|int
name|select_subj32
parameter_list|(
name|tokenstr_t
name|tok
parameter_list|,
name|uint32_t
modifier|*
name|optchkd
parameter_list|)
block|{
name|SETOPT
argument_list|(
operator|(
operator|*
name|optchkd
operator|)
argument_list|,
operator|(
name|OPT_u
operator||
name|OPT_e
operator||
name|OPT_f
operator||
name|OPT_g
operator||
name|OPT_r
operator||
name|OPT_j
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|select_auid
argument_list|(
name|tok
operator|.
name|tt
operator|.
name|subj32
operator|.
name|auid
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|select_euid
argument_list|(
name|tok
operator|.
name|tt
operator|.
name|subj32
operator|.
name|euid
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|select_egid
argument_list|(
name|tok
operator|.
name|tt
operator|.
name|subj32
operator|.
name|egid
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|select_rgid
argument_list|(
name|tok
operator|.
name|tt
operator|.
name|subj32
operator|.
name|rgid
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|select_ruid
argument_list|(
name|tok
operator|.
name|tt
operator|.
name|subj32
operator|.
name|ruid
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|select_subid
argument_list|(
name|tok
operator|.
name|tt
operator|.
name|subj32
operator|.
name|pid
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read each record from the audit trail.  Check if it is selected after  * passing through each of the options   */
end_comment

begin_function
specifier|static
name|int
name|select_records
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|tokenstr_t
name|tok_hdr32_copy
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|tokenstr_t
name|tok
decl_stmt|;
name|int
name|reclen
decl_stmt|;
name|int
name|bytesread
decl_stmt|;
name|int
name|selected
decl_stmt|;
name|uint32_t
name|optchkd
decl_stmt|;
name|int
name|print
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|reclen
operator|=
name|au_read_rec
argument_list|(
name|fp
argument_list|,
operator|&
name|buf
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|optchkd
operator|=
literal|0
expr_stmt|;
name|bytesread
operator|=
literal|0
expr_stmt|;
name|selected
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|selected
operator|==
literal|1
operator|)
operator|&&
operator|(
name|bytesread
operator|<
name|reclen
operator|)
condition|)
block|{
if|if
condition|(
operator|-
literal|1
operator|==
name|au_fetch_tok
argument_list|(
operator|&
name|tok
argument_list|,
name|buf
operator|+
name|bytesread
argument_list|,
name|reclen
operator|-
name|bytesread
argument_list|)
condition|)
block|{
comment|/* Is this an incomplete record? */
name|err
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 			 * For each token type we have have different 			 * selection criteria. 			 */
switch|switch
condition|(
name|tok
operator|.
name|id
condition|)
block|{
case|case
name|AUT_HEADER32
case|:
name|selected
operator|=
name|select_hdr32
argument_list|(
name|tok
argument_list|,
operator|&
name|optchkd
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|tok
argument_list|,
operator|&
name|tok_hdr32_copy
argument_list|,
sizeof|sizeof
argument_list|(
name|tok
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUT_PROCESS32
case|:
name|selected
operator|=
name|select_proc32
argument_list|(
name|tok
argument_list|,
operator|&
name|optchkd
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUT_SUBJECT32
case|:
name|selected
operator|=
name|select_subj32
argument_list|(
name|tok
argument_list|,
operator|&
name|optchkd
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUT_IPC
case|:
name|selected
operator|=
name|select_ipcobj
argument_list|(
name|tok
operator|.
name|tt
operator|.
name|ipc
operator|.
name|type
argument_list|,
name|tok
operator|.
name|tt
operator|.
name|ipc
operator|.
name|id
argument_list|,
operator|&
name|optchkd
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUT_PATH
case|:
name|selected
operator|=
name|select_filepath
argument_list|(
name|tok
operator|.
name|tt
operator|.
name|path
operator|.
name|path
argument_list|,
operator|&
name|optchkd
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUT_RETURN32
case|:
name|selected
operator|=
name|select_return32
argument_list|(
name|tok
argument_list|,
name|tok_hdr32_copy
argument_list|,
operator|&
name|optchkd
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|bytesread
operator|+=
name|tok
operator|.
name|len
expr_stmt|;
block|}
comment|/* Check if all the options were matched. */
name|print
operator|=
operator|(
operator|(
name|selected
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|!
name|err
operator|)
operator|&&
operator|(
operator|!
operator|(
name|opttochk
operator|&
operator|~
name|optchkd
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_v
argument_list|)
condition|)
name|print
operator|=
operator|!
name|print
expr_stmt|;
if|if
condition|(
name|print
condition|)
operator|(
name|void
operator|)
name|fwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|reclen
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * The -o option has the form object_type=object_value.  Identify the object  * components.  */
end_comment

begin_function
specifier|static
name|void
name|parse_object_type
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|val
parameter_list|)
block|{
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|FILEOBJ
argument_list|)
condition|)
block|{
name|p_fileobj
operator|=
name|val
expr_stmt|;
name|parse_regexp
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_of
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|MSGQIDOBJ
argument_list|)
condition|)
block|{
name|p_msgqobj
operator|=
name|val
expr_stmt|;
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_om
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|PIDOBJ
argument_list|)
condition|)
block|{
name|p_pidobj
operator|=
name|val
expr_stmt|;
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|SEMIDOBJ
argument_list|)
condition|)
block|{
name|p_semobj
operator|=
name|val
expr_stmt|;
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_ose
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|SHMIDOBJ
argument_list|)
condition|)
block|{
name|p_shmobj
operator|=
name|val
expr_stmt|;
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_osh
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|SOCKOBJ
argument_list|)
condition|)
block|{
name|p_sockobj
operator|=
name|val
expr_stmt|;
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_oso
argument_list|)
expr_stmt|;
block|}
else|else
name|usage
argument_list|(
literal|"unknown value for -o"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|struct
name|tm
name|tm
decl_stmt|;
name|au_event_t
modifier|*
name|n
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|objval
decl_stmt|,
modifier|*
name|converr
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|char
name|timestr
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|uint16_t
modifier|*
name|etp
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_CAP_ENTER
name|int
name|retval
decl_stmt|,
name|status
decl_stmt|;
name|pid_t
name|childpid
decl_stmt|,
name|pid
decl_stmt|;
endif|#
directive|endif
name|converr
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"Aa:b:c:d:e:f:g:j:m:o:r:u:v"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'A'
case|:
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_A
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_a
argument_list|)
condition|)
block|{
name|usage
argument_list|(
literal|"d is exclusive with a and b"
argument_list|)
expr_stmt|;
block|}
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_a
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|tm
argument_list|,
sizeof|sizeof
argument_list|(
name|tm
argument_list|)
argument_list|)
expr_stmt|;
name|strptime
argument_list|(
name|optarg
argument_list|,
literal|"%Y%m%d%H%M%S"
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
name|strftime
argument_list|(
name|timestr
argument_list|,
sizeof|sizeof
argument_list|(
name|timestr
argument_list|)
argument_list|,
literal|"%Y%m%d%H%M%S"
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
comment|/* fprintf(stderr, "Time converted = %s\n", timestr); */
name|p_atime
operator|=
name|mktime
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_b
argument_list|)
condition|)
block|{
name|usage
argument_list|(
literal|"d is exclusive with a and b"
argument_list|)
expr_stmt|;
block|}
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_b
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|tm
argument_list|,
sizeof|sizeof
argument_list|(
name|tm
argument_list|)
argument_list|)
expr_stmt|;
name|strptime
argument_list|(
name|optarg
argument_list|,
literal|"%Y%m%d%H%M%S"
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
name|strftime
argument_list|(
name|timestr
argument_list|,
sizeof|sizeof
argument_list|(
name|timestr
argument_list|)
argument_list|,
literal|"%Y%m%d%H%M%S"
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
comment|/* fprintf(stderr, "Time converted = %s\n", timestr); */
name|p_btime
operator|=
name|mktime
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
literal|0
operator|!=
name|getauditflagsbin
argument_list|(
name|optarg
argument_list|,
operator|&
name|maskp
argument_list|)
condition|)
block|{
comment|/* Incorrect class */
name|usage
argument_list|(
literal|"Incorrect class"
argument_list|)
expr_stmt|;
block|}
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_b
argument_list|)
operator|||
name|ISOPTSET
argument_list|(
name|opttochk
argument_list|,
name|OPT_a
argument_list|)
condition|)
name|usage
argument_list|(
literal|"'d' is exclusive with 'a' and 'b'"
argument_list|)
expr_stmt|;
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_d
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|tm
argument_list|,
sizeof|sizeof
argument_list|(
name|tm
argument_list|)
argument_list|)
expr_stmt|;
name|strptime
argument_list|(
name|optarg
argument_list|,
literal|"%Y%m%d"
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
name|strftime
argument_list|(
name|timestr
argument_list|,
sizeof|sizeof
argument_list|(
name|timestr
argument_list|)
argument_list|,
literal|"%Y%m%d"
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
comment|/* fprintf(stderr, "Time converted = %s\n", timestr); */
name|p_atime
operator|=
name|mktime
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
name|tm
operator|.
name|tm_hour
operator|=
literal|23
expr_stmt|;
name|tm
operator|.
name|tm_min
operator|=
literal|59
expr_stmt|;
name|tm
operator|.
name|tm_sec
operator|=
literal|59
expr_stmt|;
name|strftime
argument_list|(
name|timestr
argument_list|,
sizeof|sizeof
argument_list|(
name|timestr
argument_list|)
argument_list|,
literal|"%Y%m%d"
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
comment|/* fprintf(stderr, "Time converted = %s\n", timestr); */
name|p_btime
operator|=
name|mktime
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|p_euid
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|converr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|converr
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Try the actual name */
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|optarg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|p_euid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
block|}
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_e
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|p_egid
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|converr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|converr
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Try actual group name. */
if|if
condition|(
operator|(
name|grp
operator|=
name|getgrnam
argument_list|(
name|optarg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|p_egid
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
block|}
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_f
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|p_rgid
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|converr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|converr
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Try actual group name. */
if|if
condition|(
operator|(
name|grp
operator|=
name|getgrnam
argument_list|(
name|optarg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|p_rgid
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
block|}
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_g
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|p_subid
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_j
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|p_evec
operator|==
name|NULL
condition|)
block|{
name|p_evec_alloc
operator|=
literal|32
expr_stmt|;
name|p_evec
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|etp
argument_list|)
operator|*
name|p_evec_alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_evec
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_evec_alloc
operator|==
name|p_evec_used
condition|)
block|{
name|p_evec_alloc
operator|<<=
literal|1
expr_stmt|;
name|p_evec
operator|=
name|realloc
argument_list|(
name|p_evec
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_evec
argument_list|)
operator|*
name|p_evec_alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_evec
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"realloc"
argument_list|)
expr_stmt|;
block|}
name|etp
operator|=
operator|&
name|p_evec
index|[
name|p_evec_used
operator|++
index|]
expr_stmt|;
operator|*
name|etp
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|etp
operator|==
literal|0
condition|)
block|{
comment|/* Could be the string representation. */
name|n
operator|=
name|getauevnonam
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
name|usage
argument_list|(
literal|"Incorrect event name"
argument_list|)
expr_stmt|;
operator|*
name|etp
operator|=
operator|*
name|n
expr_stmt|;
block|}
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_m
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|objval
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|objval
operator|!=
name|NULL
condition|)
block|{
operator|*
name|objval
operator|=
literal|'\0'
expr_stmt|;
name|objval
operator|+=
literal|1
expr_stmt|;
name|parse_object_type
argument_list|(
name|optarg
argument_list|,
name|objval
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'r'
case|:
name|p_ruid
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|converr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|converr
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|optarg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|p_ruid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
block|}
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_r
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|p_auid
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|converr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|converr
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|optarg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|p_auid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
block|}
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_u
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|SETOPT
argument_list|(
name|opttochk
argument_list|,
name|OPT_v
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
literal|"Unknown option"
argument_list|)
expr_stmt|;
block|}
block|}
name|argv
operator|+=
name|optind
expr_stmt|;
name|argc
operator|-=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_CAP_ENTER
name|retval
operator|=
name|cap_enter
argument_list|()
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
operator|&&
name|errno
operator|!=
name|ENOSYS
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"cap_enter"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|select_records
argument_list|(
name|stdin
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"Couldn't select records from stdin"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * XXX: We should actually be merging records here. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|fname
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"Couldn't open %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
comment|/* 		 * If operating with sandboxing, create a sandbox process for 		 * each trail file we operate on.  This avoids the need to do 		 * fancy things with file descriptors, etc, when iterating on 		 * a list of arguments. 		 * 		 * NB: Unlike praudit(1), auditreduce(1) terminates if it hits 		 * any errors.  Propagate the error from the child to the 		 * parent if any problems arise. 		 */
ifdef|#
directive|ifdef
name|HAVE_CAP_ENTER
name|childpid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|childpid
operator|==
literal|0
condition|)
block|{
comment|/* Child. */
name|retval
operator|=
name|cap_enter
argument_list|()
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
operator|&&
name|errno
operator|!=
name|ENOSYS
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"cap_enter"
argument_list|)
expr_stmt|;
if|if
condition|(
name|select_records
argument_list|(
name|fp
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"Couldn't select records %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Parent.  Await child termination, check exit value. */
while|while
condition|(
operator|(
name|pid
operator|=
name|waitpid
argument_list|(
name|childpid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|childpid
condition|)
empty_stmt|;
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|!=
literal|0
condition|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|select_records
argument_list|(
name|fp
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"Couldn't select records %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

