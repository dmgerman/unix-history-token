begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004-2008 Apple Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1.  Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  * 2.  Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.  * 3.  Neither the name of Apple Inc. ("Apple") nor the names of  *     its contributors may be used to endorse or promote products derived  *     from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $P4: //depot/projects/trustedbsd/openbsm/bin/auditd/auditd.c#39 $  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<config/config.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FULL_QUEUE_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !HAVE_FULL_QUEUE_H */
end_comment

begin_include
include|#
directive|include
file|<compat/queue.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_FULL_QUEUE_H */
end_comment

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<bsm/audit.h>
end_include

begin_include
include|#
directive|include
file|<bsm/audit_uevents.h>
end_include

begin_include
include|#
directive|include
file|<bsm/libbsm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|"auditd.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_MACH_IPC
end_ifdef

begin_include
include|#
directive|include
file|<notify.h>
end_include

begin_include
include|#
directive|include
file|<mach/port.h>
end_include

begin_include
include|#
directive|include
file|<mach/mach_error.h>
end_include

begin_include
include|#
directive|include
file|<mach/mach_traps.h>
end_include

begin_include
include|#
directive|include
file|<mach/mach.h>
end_include

begin_include
include|#
directive|include
file|<mach/host_special_ports.h>
end_include

begin_include
include|#
directive|include
file|"auditd_control_server.h"
end_include

begin_include
include|#
directive|include
file|"audit_triggers_server.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_MACH_IPC */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STRLCPY
end_ifndef

begin_include
include|#
directive|include
file|<compat/strlcpy.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NA_EVENT_STR_SIZE
value|25
end_define

begin_define
define|#
directive|define
name|POL_STR_SIZE
value|128
end_define

begin_decl_stmt
specifier|static
name|int
name|ret
decl_stmt|,
name|minval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lastfile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|allhardcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sigchlds
decl_stmt|,
name|sigchlds_handled
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sighups
decl_stmt|,
name|sighups_handled
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|USE_MACH_IPC
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|sigterms
decl_stmt|,
name|sigterms_handled
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|triggerfd
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* USE_MACH_IPC */
end_comment

begin_decl_stmt
specifier|static
name|mach_port_t
name|control_port
init|=
name|MACH_PORT_NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mach_port_t
name|signal_port
init|=
name|MACH_PORT_NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mach_port_t
name|port_set
init|=
name|MACH_PORT_NULL
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|__BSM_INTERNAL_NOTIFY_KEY
end_ifndef

begin_define
define|#
directive|define
name|__BSM_INTERNAL_NOTIFY_KEY
value|"com.apple.audit.change"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __BSM_INTERNAL_NOTIFY_KEY */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_MACH_IPC */
end_comment

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|dir_ent
argument_list|)
name|dir_q
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|config_audit_controls
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Error starting auditd  */
end_comment

begin_function
specifier|static
name|void
name|fail_exit
parameter_list|(
name|void
parameter_list|)
block|{
name|audit_warn_nostart
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free our local list of directory names.  */
end_comment

begin_function
specifier|static
name|void
name|free_dir_q
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dir_ent
modifier|*
name|dirent
decl_stmt|;
while|while
condition|(
operator|(
name|dirent
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|dir_q
argument_list|)
operator|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|dir_q
argument_list|,
name|dirent
argument_list|,
name|dirs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dirent
operator|->
name|dirname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dirent
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Generate the timestamp string.  */
end_comment

begin_function
specifier|static
name|int
name|getTSstr
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|timeval
name|ts
decl_stmt|;
name|struct
name|timezone
name|tzp
decl_stmt|;
name|time_t
name|tt
decl_stmt|;
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|ts
argument_list|,
operator|&
name|tzp
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|tt
operator|=
operator|(
name|time_t
operator|)
name|ts
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
operator|!
name|strftime
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%Y%m%d%H%M%S"
argument_list|,
name|gmtime
argument_list|(
operator|&
name|tt
argument_list|)
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Concat the directory name to the given file name.  * XXX We should affix the hostname also  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|affixdir
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|dir_ent
modifier|*
name|dirent
parameter_list|)
block|{
name|char
modifier|*
name|fn
init|=
name|NULL
decl_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"dir = %s"
argument_list|,
name|dirent
operator|->
name|dirname
argument_list|)
expr_stmt|;
comment|/*  	 * Sanity check on file name. 	 */
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|!=
operator|(
name|FILENAME_LEN
operator|-
literal|1
operator|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Invalid file name: %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|asprintf
argument_list|(
operator|&
name|fn
argument_list|,
literal|"%s/%s"
argument_list|,
name|dirent
operator|->
name|dirname
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|fn
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close the previous audit trail file.  */
end_comment

begin_function
specifier|static
name|int
name|close_lastfile
parameter_list|(
name|char
modifier|*
name|TS
parameter_list|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|oldname
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|lastfile
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|lastfile
argument_list|)
operator|+
literal|1
expr_stmt|;
name|oldname
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldname
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|strlcpy
argument_list|(
name|oldname
argument_list|,
name|lastfile
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Rename the last file -- append timestamp. */
if|if
condition|(
operator|(
name|ptr
operator|=
name|strstr
argument_list|(
name|lastfile
argument_list|,
name|NOT_TERMINATED
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strlcpy
argument_list|(
name|ptr
argument_list|,
name|TS
argument_list|,
name|TIMESTAMP_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|oldname
argument_list|,
name|lastfile
argument_list|)
operator|!=
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Could not rename %s to %s: %m"
argument_list|,
name|oldname
argument_list|,
name|lastfile
argument_list|)
expr_stmt|;
else|else
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"renamed %s to %s"
argument_list|,
name|oldname
argument_list|,
name|lastfile
argument_list|)
expr_stmt|;
name|audit_warn_closefile
argument_list|(
name|lastfile
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Could not rename %s to %s"
argument_list|,
name|oldname
argument_list|,
name|lastfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lastfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|oldname
argument_list|)
expr_stmt|;
name|lastfile
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create the new audit file with appropriate permissions and ownership.  Try  * to clean up if something goes wrong.  */
end_comment

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|AUDIT_REVIEW_GROUP
name|open_trail
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|uid_t
name|uid
parameter_list|,
name|gid_t
name|gid
parameter_list|)
else|#
directive|else
function|open_trail
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|error
decl_stmt|,
name|fd
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_RDONLY
operator||
name|O_CREAT
argument_list|,
name|S_IRUSR
operator||
name|S_IRGRP
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|AUDIT_REVIEW_GROUP
if|if
condition|(
name|fchown
argument_list|(
name|fd
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|errno
operator|=
name|error
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create the new file name, swap with existing audit file.  */
end_comment

begin_function
specifier|static
name|int
name|swap_audit_file
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|timestr
index|[
name|FILENAME_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|fn
decl_stmt|;
name|char
name|TS
index|[
name|TIMESTAMP_LEN
index|]
decl_stmt|;
name|struct
name|dir_ent
modifier|*
name|dirent
decl_stmt|;
ifdef|#
directive|ifdef
name|AUDIT_REVIEW_GROUP
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
endif|#
directive|endif
name|int
name|error
decl_stmt|,
name|fd
decl_stmt|;
if|if
condition|(
name|getTSstr
argument_list|(
name|TS
argument_list|,
name|TIMESTAMP_LEN
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|snprintf
argument_list|(
name|timestr
argument_list|,
name|FILENAME_LEN
argument_list|,
literal|"%s.%s"
argument_list|,
name|TS
argument_list|,
name|NOT_TERMINATED
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUDIT_REVIEW_GROUP
comment|/* 	 * XXXRW: Currently, this code falls back to the daemon gid, which is 	 * likely the wheel group.  Is there a better way to deal with this? 	 */
name|grp
operator|=
name|getgrnam
argument_list|(
name|AUDIT_REVIEW_GROUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|grp
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Audit review group '%s' not available, using daemon gid"
argument_list|,
name|AUDIT_REVIEW_GROUP
argument_list|)
expr_stmt|;
name|gid
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|gid
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Try until we succeed. */
while|while
condition|(
operator|(
name|dirent
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|dir_q
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|fn
operator|=
name|affixdir
argument_list|(
name|timestr
argument_list|,
name|dirent
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Failed to swap log at time %s"
argument_list|,
name|timestr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * Create and open the file; then close and pass to the 		 * kernel if all went well. 		 */
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"New audit file is %s"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUDIT_REVIEW_GROUP
name|fd
operator|=
name|open_trail
argument_list|(
name|fn
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|)
expr_stmt|;
else|#
directive|else
name|fd
operator|=
name|open_trail
argument_list|(
name|fn
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|warn
argument_list|(
literal|"open(%s)"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
name|error
operator|=
name|auditctl
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"auditctl failed setting log file! : %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Success. */
ifdef|#
directive|ifdef
name|USE_MACH_IPC
comment|/*  			 	 * auditctl() potentially changes the audit 				 * state so post that the audit config (may 				 * have) changed.  			 	 */
name|notify_post
argument_list|(
name|__BSM_INTERNAL_NOTIFY_KEY
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|close_lastfile
argument_list|(
name|TS
argument_list|)
expr_stmt|;
name|lastfile
operator|=
name|fn
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 		 * Tell the administrator about lack of permissions for dir. 		 */
name|audit_warn_getacdir
argument_list|(
name|dirent
operator|->
name|dirname
argument_list|)
expr_stmt|;
comment|/* Try again with a different directory. */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|dir_q
argument_list|,
name|dirent
argument_list|,
name|dirs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dirent
operator|->
name|dirname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dirent
argument_list|)
expr_stmt|;
block|}
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Log directories exhausted"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read the audit_control file contents.  */
end_comment

begin_function
specifier|static
name|int
name|read_control_file
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|cur_dir
index|[
name|MAXNAMLEN
index|]
decl_stmt|;
name|struct
name|dir_ent
modifier|*
name|dirent
decl_stmt|;
name|au_qctrl_t
name|qctrl
decl_stmt|;
comment|/* 	 * Clear old values.  Force a re-read of the file the next time. 	 */
name|free_dir_q
argument_list|()
expr_stmt|;
name|endac
argument_list|()
expr_stmt|;
comment|/* 	 * Read the list of directories into a local linked list. 	 * 	 * XXX We should use the reentrant interfaces once they are 	 * available. 	 */
while|while
condition|(
name|getacdir
argument_list|(
name|cur_dir
argument_list|,
name|MAXNAMLEN
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|dirent
operator|=
operator|(
expr|struct
name|dir_ent
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dir_ent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirent
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|dirent
operator|->
name|softlim
operator|=
literal|0
expr_stmt|;
name|dirent
operator|->
name|dirname
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|MAXNAMLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirent
operator|->
name|dirname
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|dirent
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|strlcpy
argument_list|(
name|dirent
operator|->
name|dirname
argument_list|,
name|cur_dir
argument_list|,
name|MAXNAMLEN
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dir_q
argument_list|,
name|dirent
argument_list|,
name|dirs
argument_list|)
expr_stmt|;
block|}
name|allhardcount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|swap_audit_file
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Could not swap audit file"
argument_list|)
expr_stmt|;
comment|/* 		 * XXX Faulty directory listing? - user should be given 		 * XXX an opportunity to change the audit_control file 		 * XXX switch to a reduced mode of auditing? 		 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * XXX There are synchronization problems here  	 * XXX what should we do if a trigger for the earlier limit 	 * XXX is generated here? 	 */
if|if
condition|(
literal|0
operator|==
operator|(
name|ret
operator|=
name|getacmin
argument_list|(
operator|&
name|minval
argument_list|)
operator|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"min free = %d"
argument_list|,
name|minval
argument_list|)
expr_stmt|;
if|if
condition|(
name|auditon
argument_list|(
name|A_GETQCTRL
argument_list|,
operator|&
name|qctrl
argument_list|,
sizeof|sizeof
argument_list|(
name|qctrl
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"could not get audit queue settings"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|qctrl
operator|.
name|aq_minfree
operator|=
name|minval
expr_stmt|;
if|if
condition|(
name|auditon
argument_list|(
name|A_SETQCTRL
argument_list|,
operator|&
name|qctrl
argument_list|,
sizeof|sizeof
argument_list|(
name|qctrl
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"could not set audit queue settings"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close all log files, control files, and tell the audit system.  */
end_comment

begin_function
specifier|static
name|int
name|close_all
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|auditinfo
name|ai
decl_stmt|;
name|int
name|err_ret
init|=
literal|0
decl_stmt|;
name|char
name|TS
index|[
name|TIMESTAMP_LEN
index|]
decl_stmt|;
name|int
name|aufd
decl_stmt|;
name|token_t
modifier|*
name|tok
decl_stmt|;
name|long
name|cond
decl_stmt|;
comment|/* Generate an audit record. */
if|if
condition|(
operator|(
name|aufd
operator|=
name|au_open
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Could not create audit shutdown event."
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|tok
operator|=
name|au_to_text
argument_list|(
literal|"auditd::Audit shutdown"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|au_write
argument_list|(
name|aufd
argument_list|,
name|tok
argument_list|)
expr_stmt|;
comment|/* 		 * XXX we need to implement extended subject tokens so we can 		 * effectively represent terminal lines with this token type. 		 */
name|bzero
argument_list|(
operator|&
name|ai
argument_list|,
sizeof|sizeof
argument_list|(
name|ai
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tok
operator|=
name|au_to_subject32
argument_list|(
name|getuid
argument_list|()
argument_list|,
name|geteuid
argument_list|()
argument_list|,
name|getegid
argument_list|()
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|getgid
argument_list|()
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|getpid
argument_list|()
argument_list|,
operator|&
name|ai
operator|.
name|ai_termid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|au_write
argument_list|(
name|aufd
argument_list|,
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tok
operator|=
name|au_to_return32
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|au_write
argument_list|(
name|aufd
argument_list|,
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
name|au_close
argument_list|(
name|aufd
argument_list|,
literal|1
argument_list|,
name|AUE_audit_shutdown
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Could not close audit shutdown event."
argument_list|)
expr_stmt|;
block|}
comment|/* Flush contents. */
name|cond
operator|=
name|AUC_DISABLED
expr_stmt|;
name|err_ret
operator|=
name|auditon
argument_list|(
name|A_SETCOND
argument_list|,
operator|&
name|cond
argument_list|,
sizeof|sizeof
argument_list|(
name|cond
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err_ret
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Disabling audit failed! : %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|err_ret
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_MACH_IPC
comment|/*  	 * Post a notification that the audit config changed.  	 */
name|notify_post
argument_list|(
name|__BSM_INTERNAL_NOTIFY_KEY
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|getTSstr
argument_list|(
name|TS
argument_list|,
name|TIMESTAMP_LEN
argument_list|)
operator|==
literal|0
condition|)
name|close_lastfile
argument_list|(
name|TS
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastfile
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|lastfile
argument_list|)
expr_stmt|;
name|free_dir_q
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|remove
argument_list|(
name|AUDITD_PIDFILE
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|||
name|err_ret
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Could not unregister"
argument_list|)
expr_stmt|;
name|audit_warn_postsigterm
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|endac
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_MACH_IPC
if|if
condition|(
name|close
argument_list|(
name|triggerfd
argument_list|)
operator|!=
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Error closing control file"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Finished"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * When we get a signal, we are often not at a clean point.  So, little can  * be done in the signal handler itself.  Instead,  we send a message to the  * main servicing loop to do proper handling from a non-signal-handler  * context.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_MACH_IPC
end_ifdef

begin_function
specifier|static
name|void
name|relay_signal
parameter_list|(
name|int
name|signal
parameter_list|)
block|{
name|mach_msg_empty_send_t
name|msg
decl_stmt|;
name|msg
operator|.
name|header
operator|.
name|msgh_id
operator|=
name|signal
expr_stmt|;
name|msg
operator|.
name|header
operator|.
name|msgh_remote_port
operator|=
name|signal_port
expr_stmt|;
name|msg
operator|.
name|header
operator|.
name|msgh_local_port
operator|=
name|MACH_PORT_NULL
expr_stmt|;
name|msg
operator|.
name|header
operator|.
name|msgh_bits
operator|=
name|MACH_MSGH_BITS
argument_list|(
name|MACH_MSG_TYPE_MAKE_SEND
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mach_msg
argument_list|(
operator|&
operator|(
name|msg
operator|.
name|header
operator|)
argument_list|,
name|MACH_SEND_MSG
operator||
name|MACH_SEND_TIMEOUT
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|0
argument_list|,
name|MACH_PORT_NULL
argument_list|,
name|MACH_MSG_TIMEOUT_NONE
argument_list|,
name|MACH_PORT_NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! USE_MACH_IPC */
end_comment

begin_function
specifier|static
name|void
name|relay_signal
parameter_list|(
name|int
name|signal
parameter_list|)
block|{
if|if
condition|(
name|signal
operator|==
name|SIGHUP
condition|)
name|sighups
operator|++
expr_stmt|;
if|if
condition|(
name|signal
operator|==
name|SIGTERM
condition|)
name|sigterms
operator|++
expr_stmt|;
if|if
condition|(
name|signal
operator|==
name|SIGCHLD
condition|)
name|sigchlds
operator|++
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! USE_MACH_IPC */
end_comment

begin_comment
comment|/*  * Registering the daemon.  */
end_comment

begin_function
specifier|static
name|int
name|register_daemon
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|pidfile
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
comment|/* Set up the signal hander. */
if|if
condition|(
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|relay_signal
argument_list|)
operator|==
name|SIG_ERR
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Could not set signal handler for SIGTERM"
argument_list|)
expr_stmt|;
name|fail_exit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|relay_signal
argument_list|)
operator|==
name|SIG_ERR
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Could not set signal handler for SIGCHLD"
argument_list|)
expr_stmt|;
name|fail_exit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|relay_signal
argument_list|)
operator|==
name|SIG_ERR
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Could not set signal handler for SIGHUP"
argument_list|)
expr_stmt|;
name|fail_exit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pidfile
operator|=
name|fopen
argument_list|(
name|AUDITD_PIDFILE
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Could not open PID file"
argument_list|)
expr_stmt|;
name|audit_warn_tmpfile
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Attempt to lock the pid file; if a lock is present, exit. */
name|fd
operator|=
name|fileno
argument_list|(
name|pidfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|flock
argument_list|(
name|fd
argument_list|,
name|LOCK_EX
operator||
name|LOCK_NB
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"PID file is locked (is another auditd running?)."
argument_list|)
expr_stmt|;
name|audit_warn_ebusy
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|ftruncate
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|pidfile
argument_list|,
literal|"%u\n"
argument_list|,
name|pid
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Should not start the daemon. */
name|fail_exit
argument_list|()
expr_stmt|;
block|}
name|fflush
argument_list|(
name|pidfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_MACH_IPC
end_ifdef

begin_comment
comment|/*  * Implementation of the auditd_control() MIG simpleroutine.  *  * React to input from the audit(1) tool.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|kern_return_t
name|auditd_control
parameter_list|(
name|mach_port_t
name|__unused
name|auditd_port
parameter_list|,
name|int
name|trigger
parameter_list|)
block|{
name|int
name|err_ret
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|trigger
condition|)
block|{
case|case
name|AUDIT_TRIGGER_ROTATE_USER
case|:
comment|/* 		 * Create a new file and swap with the one 		 * being used in kernel. 		 */
if|if
condition|(
name|swap_audit_file
argument_list|()
operator|==
operator|-
literal|1
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Error swapping audit file"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUDIT_TRIGGER_READ_FILE
case|:
if|if
condition|(
name|read_control_file
argument_list|()
operator|==
operator|-
literal|1
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Error in audit control file"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUDIT_TRIGGER_CLOSE_AND_DIE
case|:
name|err_ret
operator|=
name|close_all
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|err_ret
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_MACH_IPC */
end_comment

begin_comment
comment|/*  * Handle the audit trigger event.  *  * We suppress (ignore) duplicated triggers in close succession in order to  * try to avoid thrashing-like behavior.  However, not all triggers can be  * ignored, as triggers generally represent edge triggers, not level  * triggers, and won't be retransmitted if the condition persists.  Of  * specific concern is the rotate trigger -- if one is dropped, then it will  * not be retransmitted, and the log file will grow in an unbounded fashion.  */
end_comment

begin_define
define|#
directive|define
name|DUPLICATE_INTERVAL
value|30
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|USE_MACH_IPC
end_ifdef

begin_define
define|#
directive|define
name|AT_SUCCESS
value|KERN_SUCCESS
end_define

begin_comment
comment|/* ARGSUSED */
end_comment

begin_decl_stmt
name|kern_return_t
name|audit_triggers
argument_list|(
name|mach_port_t
name|__unused
name|audit_port
argument_list|,
name|int
name|trigger
argument_list|)
else|#
directive|else
define|#
directive|define
name|AT_SUCCESS
value|0
decl|static
name|int
name|handle_audit_trigger
argument_list|(
name|int
name|trigger
argument_list|)
endif|#
directive|endif
block|{
specifier|static
name|int
name|last_trigger
decl_stmt|,
name|last_warning
decl_stmt|;
specifier|static
name|time_t
name|last_time
decl_stmt|;
name|struct
name|dir_ent
modifier|*
name|dirent
decl_stmt|;
name|struct
name|timeval
name|ts
decl_stmt|;
name|struct
name|timezone
name|tzp
decl_stmt|;
name|time_t
name|tt
decl_stmt|;
comment|/* 	 * Suppress duplicate messages from the kernel within the specified 	 * interval. 	 */
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|ts
argument_list|,
operator|&
name|tzp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tt
operator|=
operator|(
name|time_t
operator|)
name|ts
operator|.
name|tv_sec
expr_stmt|;
switch|switch
condition|(
name|trigger
condition|)
block|{
case|case
name|AUDIT_TRIGGER_LOW_SPACE
case|:
case|case
name|AUDIT_TRIGGER_NO_SPACE
case|:
comment|/* 			 * Triggers we can suppress.  Of course, we also need 			 * to rate limit the warnings, so apply the same 			 * interval limit on syslog messages. 			 */
if|if
condition|(
operator|(
name|trigger
operator|==
name|last_trigger
operator|)
operator|&&
operator|(
name|tt
operator|<
operator|(
name|last_time
operator|+
name|DUPLICATE_INTERVAL
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|tt
operator|>=
operator|(
name|last_warning
operator|+
name|DUPLICATE_INTERVAL
operator|)
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Suppressing duplicate trigger %d"
argument_list|,
name|trigger
argument_list|)
expr_stmt|;
return|return
operator|(
name|AT_SUCCESS
operator|)
return|;
block|}
name|last_warning
operator|=
name|tt
expr_stmt|;
break|break;
case|case
name|AUDIT_TRIGGER_ROTATE_KERNEL
case|:
case|case
name|AUDIT_TRIGGER_ROTATE_USER
case|:
case|case
name|AUDIT_TRIGGER_READ_FILE
case|:
comment|/* 			 * Triggers that we cannot suppress. 			 */
break|break;
block|}
comment|/* 		 * Only update last_trigger after aborting due to a duplicate 		 * trigger, not before, or we will never allow that trigger 		 * again. 		 */
name|last_trigger
operator|=
name|trigger
expr_stmt|;
name|last_time
operator|=
name|tt
expr_stmt|;
block|}
comment|/* 	 * Message processing is done here.  	 */
name|dirent
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|dir_q
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|trigger
condition|)
block|{
case|case
name|AUDIT_TRIGGER_LOW_SPACE
case|:
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Got low space trigger"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirent
operator|&&
operator|(
name|dirent
operator|->
name|softlim
operator|!=
literal|1
operator|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|dir_q
argument_list|,
name|dirent
argument_list|,
name|dirs
argument_list|)
expr_stmt|;
comment|/* Add this node to the end of the list. */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dir_q
argument_list|,
name|dirent
argument_list|,
name|dirs
argument_list|)
expr_stmt|;
name|audit_warn_soft
argument_list|(
name|dirent
operator|->
name|dirname
argument_list|)
expr_stmt|;
name|dirent
operator|->
name|softlim
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TAILQ_NEXT
argument_list|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|dir_q
argument_list|)
argument_list|,
name|dirs
argument_list|)
operator|!=
name|NULL
operator|&&
name|swap_audit_file
argument_list|()
operator|==
operator|-
literal|1
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Error swapping audit file"
argument_list|)
expr_stmt|;
comment|/* 			 * Check if the next dir has already reached its soft 			 * limit. 			 */
name|dirent
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|dir_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirent
operator|->
name|softlim
operator|==
literal|1
condition|)
block|{
comment|/* All dirs have reached their soft limit. */
name|audit_warn_allsoft
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * Continue auditing to the current file.  Also 			 * generate an allsoft warning. 			 * 			 * XXX do we want to do this ? 			 */
name|audit_warn_allsoft
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|AUDIT_TRIGGER_NO_SPACE
case|:
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Got no space trigger"
argument_list|)
expr_stmt|;
comment|/* Delete current dir, go on to next. */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|dir_q
argument_list|,
name|dirent
argument_list|,
name|dirs
argument_list|)
expr_stmt|;
name|audit_warn_hard
argument_list|(
name|dirent
operator|->
name|dirname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dirent
operator|->
name|dirname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dirent
argument_list|)
expr_stmt|;
if|if
condition|(
name|swap_audit_file
argument_list|()
operator|==
operator|-
literal|1
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Error swapping audit file"
argument_list|)
expr_stmt|;
comment|/* We are out of log directories. */
name|audit_warn_allhard
argument_list|(
operator|++
name|allhardcount
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUDIT_TRIGGER_ROTATE_KERNEL
case|:
case|case
name|AUDIT_TRIGGER_ROTATE_USER
case|:
comment|/* 		 * Create a new file and swap with the one being used in 		 * kernel 		 */
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Got open new trigger from %s"
argument_list|,
name|trigger
operator|==
name|AUDIT_TRIGGER_ROTATE_KERNEL
condition|?
literal|"kernel"
else|:
literal|"user"
argument_list|)
expr_stmt|;
if|if
condition|(
name|swap_audit_file
argument_list|()
operator|==
operator|-
literal|1
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Error swapping audit file"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUDIT_TRIGGER_READ_FILE
case|:
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Got read file trigger"
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_control_file
argument_list|()
operator|==
operator|-
literal|1
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Error in audit control file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_audit_controls
argument_list|()
operator|==
operator|-
literal|1
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Error setting audit controls"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Got unknown trigger %d"
argument_list|,
name|trigger
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|AT_SUCCESS
operator|)
return|;
block|}
end_decl_stmt

begin_undef
undef|#
directive|undef
name|AT_SUCCESS
end_undef

begin_function
specifier|static
name|void
name|handle_sighup
parameter_list|(
name|void
parameter_list|)
block|{
name|sighups_handled
operator|=
name|sighups
expr_stmt|;
name|config_audit_controls
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|config_audit_host
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|hoststr
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|res
decl_stmt|;
name|struct
name|auditinfo_addr
name|aia
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|getachost
argument_list|(
name|hoststr
argument_list|,
name|MAXHOSTNAMELEN
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"warning: failed to read 'host' param in control file"
argument_list|)
expr_stmt|;
comment|/* 		 * To maintain reverse compatability with older audit_control 		 * files, simply drop a warning if the host parameter has not 		 * been set.  However, we will explicitly disable the 		 * generation of extended audit header by passing in a zeroed 		 * termid structure. 		 */
name|bzero
argument_list|(
operator|&
name|aia
argument_list|,
sizeof|sizeof
argument_list|(
name|aia
argument_list|)
argument_list|)
expr_stmt|;
name|aia
operator|.
name|ai_termid
operator|.
name|at_type
operator|=
name|AU_IPv4
expr_stmt|;
name|error
operator|=
name|auditon
argument_list|(
name|A_SETKAUDIT
argument_list|,
operator|&
name|aia
argument_list|,
sizeof|sizeof
argument_list|(
name|aia
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|<
literal|0
operator|&&
name|errno
operator|==
name|ENOSYS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
name|error
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Failed to set audit host info"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|error
operator|=
name|getaddrinfo
argument_list|(
name|hoststr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Failed to lookup hostname: %s"
argument_list|,
name|hoststr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
switch|switch
condition|(
name|res
operator|->
name|ai_family
condition|)
block|{
case|case
name|PF_INET6
case|:
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|res
operator|->
name|ai_addr
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
operator|.
name|s6_addr
argument_list|,
operator|&
name|aia
operator|.
name|ai_termid
operator|.
name|at_addr
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|aia
operator|.
name|ai_termid
operator|.
name|at_type
operator|=
name|AU_IPv6
expr_stmt|;
break|break;
case|case
name|PF_INET
case|:
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|res
operator|->
name|ai_addr
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|,
operator|&
name|aia
operator|.
name|ai_termid
operator|.
name|at_addr
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|aia
operator|.
name|ai_termid
operator|.
name|at_type
operator|=
name|AU_IPv4
expr_stmt|;
break|break;
default|default:
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Un-supported address family in host parameter"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|auditon
argument_list|(
name|A_SETKAUDIT
argument_list|,
operator|&
name|aia
argument_list|,
sizeof|sizeof
argument_list|(
name|aia
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"auditon: failed to set audit host information"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reap our children.  */
end_comment

begin_function
specifier|static
name|void
name|reap_children
parameter_list|(
name|void
parameter_list|)
block|{
name|pid_t
name|child
decl_stmt|;
name|int
name|wstatus
decl_stmt|;
while|while
condition|(
operator|(
name|child
operator|=
name|waitpid
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|wstatus
argument_list|,
name|WNOHANG
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|wstatus
condition|)
continue|continue;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"warn process [pid=%d] %s %d."
argument_list|,
name|child
argument_list|,
operator|(
operator|(
name|WIFEXITED
argument_list|(
name|wstatus
argument_list|)
operator|)
condition|?
literal|"exited with non-zero status"
else|:
literal|"exited as a result of signal"
operator|)
argument_list|,
operator|(
operator|(
name|WIFEXITED
argument_list|(
name|wstatus
argument_list|)
operator|)
condition|?
name|WEXITSTATUS
argument_list|(
name|wstatus
argument_list|)
else|:
name|WTERMSIG
argument_list|(
name|wstatus
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|handle_sigchld
parameter_list|(
name|void
parameter_list|)
block|{
name|sigchlds_handled
operator|=
name|sigchlds
expr_stmt|;
name|reap_children
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read the control file for triggers/signals and handle appropriately.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_MACH_IPC
end_ifdef

begin_define
define|#
directive|define
name|MAX_MSG_SIZE
value|4096
end_define

begin_function
specifier|static
name|boolean_t
name|auditd_combined_server
parameter_list|(
name|mach_msg_header_t
modifier|*
name|InHeadP
parameter_list|,
name|mach_msg_header_t
modifier|*
name|OutHeadP
parameter_list|)
block|{
name|mach_port_t
name|local_port
init|=
name|InHeadP
operator|->
name|msgh_local_port
decl_stmt|;
if|if
condition|(
name|local_port
operator|==
name|signal_port
condition|)
block|{
name|int
name|signo
init|=
name|InHeadP
operator|->
name|msgh_id
decl_stmt|;
name|int
name|ret
decl_stmt|;
switch|switch
condition|(
name|signo
condition|)
block|{
case|case
name|SIGTERM
case|:
name|ret
operator|=
name|close_all
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|ret
argument_list|)
expr_stmt|;
case|case
name|SIGCHLD
case|:
name|handle_sigchld
argument_list|()
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
name|SIGHUP
case|:
name|handle_sighup
argument_list|()
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
default|default:
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Received signal %d"
argument_list|,
name|signo
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|local_port
operator|==
name|control_port
condition|)
block|{
name|boolean_t
name|result
decl_stmt|;
name|result
operator|=
name|audit_triggers_server
argument_list|(
name|InHeadP
argument_list|,
name|OutHeadP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|result
operator|=
name|auditd_control_server
argument_list|(
name|InHeadP
argument_list|,
name|OutHeadP
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Recevied msg on bad port 0x%x."
argument_list|,
name|local_port
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wait_for_events
parameter_list|(
name|void
parameter_list|)
block|{
name|kern_return_t
name|result
decl_stmt|;
name|result
operator|=
name|mach_msg_server
argument_list|(
name|auditd_combined_server
argument_list|,
name|MAX_MSG_SIZE
argument_list|,
name|port_set
argument_list|,
name|MACH_MSG_OPTION_NONE
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"abnormal exit\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|close_all
argument_list|()
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! USE_MACH_IPC */
end_comment

begin_function
specifier|static
name|int
name|wait_for_events
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|num
decl_stmt|;
name|unsigned
name|int
name|trigger
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|num
operator|=
name|read
argument_list|(
name|triggerfd
argument_list|,
operator|&
name|trigger
argument_list|,
sizeof|sizeof
argument_list|(
name|trigger
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|num
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|!=
name|EINTR
operator|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: error %d"
argument_list|,
name|__FUNCTION__
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|sigterms
operator|!=
name|sigterms_handled
condition|)
block|{
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s: SIGTERM"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sigchlds
operator|!=
name|sigchlds_handled
condition|)
name|handle_sigchld
argument_list|()
expr_stmt|;
if|if
condition|(
name|sighups
operator|!=
name|sighups_handled
condition|)
block|{
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s: SIGHUP"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|handle_sighup
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|num
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|)
condition|)
continue|continue;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: read EOF"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|trigger
operator|==
name|AUDIT_TRIGGER_CLOSE_AND_DIE
condition|)
break|break;
else|else
operator|(
name|void
operator|)
name|handle_audit_trigger
argument_list|(
name|trigger
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|close_all
argument_list|()
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! USE_MACH_IPC */
end_comment

begin_comment
comment|/*  * Configure the audit controls in the kernel: the event to class mapping,  * kernel preselection mask, etc.  */
end_comment

begin_function
specifier|static
name|int
name|config_audit_controls
parameter_list|(
name|void
parameter_list|)
block|{
name|au_event_ent_t
name|ev
decl_stmt|,
modifier|*
name|evp
decl_stmt|;
name|au_evclass_map_t
name|evc_map
decl_stmt|;
name|au_mask_t
name|aumask
decl_stmt|;
name|int
name|ctr
init|=
literal|0
decl_stmt|;
name|char
name|naeventstr
index|[
name|NA_EVENT_STR_SIZE
index|]
decl_stmt|;
name|char
name|polstr
index|[
name|POL_STR_SIZE
index|]
decl_stmt|;
name|long
name|policy
decl_stmt|;
name|au_fstat_t
name|au_fstat
decl_stmt|;
name|size_t
name|filesz
decl_stmt|;
comment|/* 	 * Process the audit event file, obtaining a class mapping for each 	 * event, and send that mapping into the kernel. 	 * 	 * XXX There's a risk here that the BSM library will return NULL 	 * for an event when it can't properly map it to a class. In that 	 * case, we will not process any events beyond the one that failed, 	 * but should. We need a way to get a count of the events. 	*/
name|ev
operator|.
name|ae_name
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|AU_EVENT_NAME_MAX
argument_list|)
expr_stmt|;
name|ev
operator|.
name|ae_desc
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|AU_EVENT_DESC_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ev
operator|.
name|ae_name
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ev
operator|.
name|ae_desc
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|ev
operator|.
name|ae_name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ev
operator|.
name|ae_name
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Memory allocation error when configuring audit controls."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * XXXRW: Currently we have no way to remove mappings from the kernel 	 * when they are removed from the file-based mappings. 	 */
name|evp
operator|=
operator|&
name|ev
expr_stmt|;
name|setauevent
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|evp
operator|=
name|getauevent_r
argument_list|(
name|evp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|evc_map
operator|.
name|ec_number
operator|=
name|evp
operator|->
name|ae_number
expr_stmt|;
name|evc_map
operator|.
name|ec_class
operator|=
name|evp
operator|->
name|ae_class
expr_stmt|;
if|if
condition|(
name|auditon
argument_list|(
name|A_SETCLASS
argument_list|,
operator|&
name|evc_map
argument_list|,
sizeof|sizeof
argument_list|(
name|au_evclass_map_t
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Failed to register class mapping for event %s"
argument_list|,
name|evp
operator|->
name|ae_name
argument_list|)
expr_stmt|;
else|else
name|ctr
operator|++
expr_stmt|;
block|}
name|endauevent
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|ev
operator|.
name|ae_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ev
operator|.
name|ae_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctr
operator|==
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"No events to class mappings registered."
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Registered %d event to class mappings."
argument_list|,
name|ctr
argument_list|)
expr_stmt|;
comment|/* 	 * Get the non-attributable event string and set the kernel mask from 	 * that. 	 */
if|if
condition|(
operator|(
name|getacna
argument_list|(
name|naeventstr
argument_list|,
name|NA_EVENT_STR_SIZE
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|getauditflagsbin
argument_list|(
name|naeventstr
argument_list|,
operator|&
name|aumask
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|auditon
argument_list|(
name|A_SETKMASK
argument_list|,
operator|&
name|aumask
argument_list|,
sizeof|sizeof
argument_list|(
name|au_mask_t
argument_list|)
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Failed to register non-attributable event mask."
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Registered non-attributable event mask."
argument_list|)
expr_stmt|;
block|}
else|else
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Failed to obtain non-attributable event mask."
argument_list|)
expr_stmt|;
comment|/* 	 * If a policy is configured in audit_control(5), implement the 	 * policy.  However, if one isn't defined, set AUDIT_CNT to avoid 	 * leaving the system in a fragile state. 	 */
if|if
condition|(
operator|(
name|getacpol
argument_list|(
name|polstr
argument_list|,
name|POL_STR_SIZE
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|au_strtopol
argument_list|(
name|polstr
argument_list|,
operator|&
name|policy
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|auditon
argument_list|(
name|A_SETPOLICY
argument_list|,
operator|&
name|policy
argument_list|,
sizeof|sizeof
argument_list|(
name|policy
argument_list|)
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Failed to set audit policy: %m"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Failed to obtain policy flags: %m"
argument_list|)
expr_stmt|;
name|policy
operator|=
name|AUDIT_CNT
expr_stmt|;
if|if
condition|(
name|auditon
argument_list|(
name|A_SETPOLICY
argument_list|,
operator|&
name|policy
argument_list|,
sizeof|sizeof
argument_list|(
name|policy
argument_list|)
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Failed to set default audit policy: %m"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set trail rotation size. 	 */
if|if
condition|(
name|getacfilesz
argument_list|(
operator|&
name|filesz
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|au_fstat
argument_list|,
sizeof|sizeof
argument_list|(
name|au_fstat
argument_list|)
argument_list|)
expr_stmt|;
name|au_fstat
operator|.
name|af_filesz
operator|=
name|filesz
expr_stmt|;
if|if
condition|(
name|auditon
argument_list|(
name|A_SETFSIZE
argument_list|,
operator|&
name|au_fstat
argument_list|,
sizeof|sizeof
argument_list|(
name|au_fstat
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Failed to set filesz: %m"
argument_list|)
expr_stmt|;
block|}
else|else
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Failed to obtain filesz: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
name|config_audit_host
argument_list|()
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_MACH_IPC
end_ifdef

begin_function
specifier|static
name|void
name|mach_setup
parameter_list|(
name|void
parameter_list|)
block|{
name|mach_msg_type_name_t
name|poly
decl_stmt|;
comment|/* 	 * Allocate a port set 	 */
if|if
condition|(
name|mach_port_allocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|MACH_PORT_RIGHT_PORT_SET
argument_list|,
operator|&
name|port_set
argument_list|)
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Allocation of port set failed"
argument_list|)
expr_stmt|;
name|fail_exit
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Allocate a signal reflection port 	 */
if|if
condition|(
name|mach_port_allocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|MACH_PORT_RIGHT_RECEIVE
argument_list|,
operator|&
name|signal_port
argument_list|)
operator|!=
name|KERN_SUCCESS
operator|||
name|mach_port_move_member
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|signal_port
argument_list|,
name|port_set
argument_list|)
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Allocation of signal port failed"
argument_list|)
expr_stmt|;
name|fail_exit
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Allocate a trigger port 	 */
if|if
condition|(
name|mach_port_allocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|MACH_PORT_RIGHT_RECEIVE
argument_list|,
operator|&
name|control_port
argument_list|)
operator|!=
name|KERN_SUCCESS
operator|||
name|mach_port_move_member
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|control_port
argument_list|,
name|port_set
argument_list|)
operator|!=
name|KERN_SUCCESS
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Allocation of trigger port failed"
argument_list|)
expr_stmt|;
comment|/* 	 * Create a send right on our trigger port. 	 */
name|mach_port_extract_right
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|control_port
argument_list|,
name|MACH_MSG_TYPE_MAKE_SEND
argument_list|,
operator|&
name|control_port
argument_list|,
operator|&
name|poly
argument_list|)
expr_stmt|;
comment|/* 	 * Register the trigger port with the kernel. 	 */
if|if
condition|(
name|host_set_audit_control_port
argument_list|(
name|mach_host_self
argument_list|()
argument_list|,
name|control_port
argument_list|)
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Cannot set Mach control port"
argument_list|)
expr_stmt|;
name|fail_exit
argument_list|()
expr_stmt|;
block|}
else|else
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Mach control port registered"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_MACH_IPC */
end_comment

begin_function
specifier|static
name|void
name|setup
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|auditinfo
name|ai
decl_stmt|;
name|auditinfo_t
name|auinfo
decl_stmt|;
name|int
name|aufd
decl_stmt|;
name|token_t
modifier|*
name|tok
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_MACH_IPC
name|mach_setup
argument_list|()
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|triggerfd
operator|=
name|open
argument_list|(
name|AUDIT_TRIGGER_FILE
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Error opening trigger file"
argument_list|)
expr_stmt|;
name|fail_exit
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * To prevent event feedback cycles and avoid auditd becoming 	 * stalled if auditing is suspended, auditd and its children run 	 * without their events being audited.  We allow the uid, tid, and 	 * mask fields to be implicitly set to zero, but do set the pid.  We 	 * run this after opening the trigger device to avoid configuring 	 * audit state without audit present in the system. 	 * 	 * XXXRW: Is there more to it than this? 	 */
name|bzero
argument_list|(
operator|&
name|auinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|auinfo
argument_list|)
argument_list|)
expr_stmt|;
name|auinfo
operator|.
name|ai_asid
operator|=
name|getpid
argument_list|()
expr_stmt|;
if|if
condition|(
name|setaudit
argument_list|(
operator|&
name|auinfo
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Error setting audit stat"
argument_list|)
expr_stmt|;
name|fail_exit
argument_list|()
expr_stmt|;
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|dir_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_control_file
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Error reading control file"
argument_list|)
expr_stmt|;
name|fail_exit
argument_list|()
expr_stmt|;
block|}
comment|/* Generate an audit record. */
if|if
condition|(
operator|(
name|aufd
operator|=
name|au_open
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Could not create audit startup event."
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 		 * XXXCSJP Perhaps we want more robust audit records for 		 * audit start up and shutdown. This might include capturing 		 * failures to initialize the audit subsystem? 		 */
name|bzero
argument_list|(
operator|&
name|ai
argument_list|,
sizeof|sizeof
argument_list|(
name|ai
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tok
operator|=
name|au_to_subject32
argument_list|(
name|getuid
argument_list|()
argument_list|,
name|geteuid
argument_list|()
argument_list|,
name|getegid
argument_list|()
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|getgid
argument_list|()
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|getpid
argument_list|()
argument_list|,
operator|&
name|ai
operator|.
name|ai_termid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|au_write
argument_list|(
name|aufd
argument_list|,
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tok
operator|=
name|au_to_text
argument_list|(
literal|"auditd::Audit startup"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|au_write
argument_list|(
name|aufd
argument_list|,
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tok
operator|=
name|au_to_return32
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|au_write
argument_list|(
name|aufd
argument_list|,
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
name|au_close
argument_list|(
name|aufd
argument_list|,
literal|1
argument_list|,
name|AUE_audit_startup
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Could not close audit startup event."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|config_audit_controls
argument_list|()
operator|==
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Audit controls init successful"
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Audit controls init failed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
name|int
name|debug
init|=
literal|0
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|logopts
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"d"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'d'
case|:
comment|/* Debug option. */
name|debug
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: auditd [-d] \n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|logopts
operator|=
name|LOG_CONS
operator||
name|LOG_PID
expr_stmt|;
if|if
condition|(
name|debug
operator|!=
literal|0
condition|)
name|logopts
operator||=
name|LOG_PERROR
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG_SECURITY
name|openlog
argument_list|(
literal|"auditd"
argument_list|,
name|logopts
argument_list|,
name|LOG_SECURITY
argument_list|)
expr_stmt|;
else|#
directive|else
name|openlog
argument_list|(
literal|"auditd"
argument_list|,
name|logopts
argument_list|,
name|LOG_AUTH
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"starting..."
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|==
literal|0
operator|&&
name|daemon
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Failed to daemonize"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|register_daemon
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Could not register as daemon"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|setup
argument_list|()
expr_stmt|;
name|rc
operator|=
name|wait_for_events
argument_list|()
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"auditd exiting."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|rc
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

