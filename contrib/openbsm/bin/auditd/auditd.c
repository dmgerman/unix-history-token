begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004-2008 Apple Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1.  Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  * 2.  Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.  * 3.  Neither the name of Apple Inc. ("Apple") nor the names of  *     its contributors may be used to endorse or promote products derived  *     from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $P4: //depot/projects/trustedbsd/openbsm/bin/auditd/auditd.c#40 $  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<config/config.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FULL_QUEUE_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !HAVE_FULL_QUEUE_H */
end_comment

begin_include
include|#
directive|include
file|<compat/queue.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_FULL_QUEUE_H */
end_comment

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<bsm/audit.h>
end_include

begin_include
include|#
directive|include
file|<bsm/audit_uevents.h>
end_include

begin_include
include|#
directive|include
file|<bsm/auditd_lib.h>
end_include

begin_include
include|#
directive|include
file|<bsm/libbsm.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"auditd.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STRLCPY
end_ifndef

begin_include
include|#
directive|include
file|<compat/strlcpy.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * XXX the following is temporary until this can be added to the kernel  * audit.h header.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|AUDIT_TRIGGER_INITIALIZE
end_ifndef

begin_define
define|#
directive|define
name|AUDIT_TRIGGER_INITIALIZE
value|7
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * LaunchD flag (Mac OS X and, maybe, FreeBSD only.)  See launchd(8) and   * http://wiki.freebsd.org/launchd for more information.  *  *      In order for auditd to work "on demand" with launchd(8) it can't:  *              call daemon(3)  *              call fork and having the parent process exit  *              change uids or gids.  *              set up the current working directory or chroot.  *              set the session id  *              change stdio to /dev/null.  *              call setrusage(2)  *              call setpriority(2)  *              Ignore SIGTERM.  *      auditd (in 'launchd mode') is launched on demand so it must catch  *      SIGTERM to exit cleanly.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|launchd_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The GID of the audit review group (if used).  The audit trail files and  * system logs (Mac OS X only) can only be reviewed by members of this group  * or the audit administrator (aka. "root").  */
end_comment

begin_decl_stmt
specifier|static
name|gid_t
name|audit_review_gid
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The path and file name of the last audit trail file.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lastfile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Error starting auditd. Run warn script and exit.  */
end_comment

begin_function
specifier|static
name|void
name|fail_exit
parameter_list|(
name|void
parameter_list|)
block|{
name|audit_warn_nostart
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Follow the 'current' symlink to get the active trail file name.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_curfile
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|cf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|cf
operator|=
name|malloc
argument_list|(
name|MAXPATHLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|cf
operator|==
name|NULL
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"malloc failed: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|len
operator|=
name|readlink
argument_list|(
name|AUDIT_CURRENT_LINK
argument_list|,
name|cf
argument_list|,
name|MAXPATHLEN
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|cf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* readlink() doesn't terminate string. */
name|cf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|cf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close the previous audit trail file.  */
end_comment

begin_function
specifier|static
name|int
name|close_lastfile
parameter_list|(
name|char
modifier|*
name|TS
parameter_list|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|oldname
decl_stmt|;
name|size_t
name|len
decl_stmt|;
comment|/* If lastfile is NULL try to get it from the 'current' link.  */
if|if
condition|(
name|lastfile
operator|==
name|NULL
condition|)
name|lastfile
operator|=
name|get_curfile
argument_list|()
expr_stmt|;
if|if
condition|(
name|lastfile
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|lastfile
argument_list|)
operator|+
literal|1
expr_stmt|;
name|oldname
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldname
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|strlcpy
argument_list|(
name|oldname
argument_list|,
name|lastfile
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Rename the last file -- append timestamp. */
if|if
condition|(
operator|(
name|ptr
operator|=
name|strstr
argument_list|(
name|lastfile
argument_list|,
name|NOT_TERMINATED
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strlcpy
argument_list|(
name|ptr
argument_list|,
name|TS
argument_list|,
name|TIMESTAMP_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|oldname
argument_list|,
name|lastfile
argument_list|)
operator|!=
literal|0
condition|)
name|auditd_log_err
argument_list|(
literal|"Could not rename %s to %s: %m"
argument_list|,
name|oldname
argument_list|,
name|lastfile
argument_list|)
expr_stmt|;
else|else
block|{
comment|/*  				 * Remove the 'current' symlink since the link 				 * is now invalid.  				 */
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|AUDIT_CURRENT_LINK
argument_list|)
expr_stmt|;
name|auditd_log_notice
argument_list|(
literal|"renamed %s to %s"
argument_list|,
name|oldname
argument_list|,
name|lastfile
argument_list|)
expr_stmt|;
name|audit_warn_closefile
argument_list|(
name|lastfile
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|auditd_log_err
argument_list|(
literal|"Could not rename %s to %s"
argument_list|,
name|oldname
argument_list|,
name|lastfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lastfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|oldname
argument_list|)
expr_stmt|;
name|lastfile
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create the new file name, swap with existing audit file.  */
end_comment

begin_function
specifier|static
name|int
name|swap_audit_file
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|newfile
decl_stmt|;
name|char
name|TS
index|[
name|TIMESTAMP_LEN
index|]
decl_stmt|;
name|time_t
name|tt
decl_stmt|;
if|if
condition|(
name|getTSstr
argument_list|(
name|tt
argument_list|,
name|TS
argument_list|,
name|TIMESTAMP_LEN
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|err
operator|=
name|auditd_swap_trail
argument_list|(
name|TS
argument_list|,
operator|&
name|newfile
argument_list|,
name|audit_review_gid
argument_list|,
name|audit_warn_getacdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ADE_NOERR
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"%s: %m"
argument_list|,
name|auditd_strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ADE_ACTL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Only close the last file if were in an auditing state before 	 * calling swap_audit_file().  We may need to recover from a crash. 	 */
if|if
condition|(
name|auditd_get_state
argument_list|()
operator|==
name|AUD_STATE_ENABLED
condition|)
name|close_lastfile
argument_list|(
name|TS
argument_list|)
expr_stmt|;
comment|/* 	 * auditd_swap_trail() potentially enables auditing (if not already 	 * enabled) so updated the cached state as well. 	 */
name|auditd_set_state
argument_list|(
name|AUD_STATE_ENABLED
argument_list|)
expr_stmt|;
comment|/* 	 *  Create 'current' symlink.  Recover from crash, if needed. 	 */
if|if
condition|(
name|auditd_new_curlink
argument_list|(
name|newfile
argument_list|)
operator|!=
literal|0
condition|)
name|auditd_log_err
argument_list|(
literal|"auditd_new_curlink(\"%s\") failed: %s: %m"
argument_list|,
name|newfile
argument_list|,
name|auditd_strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|lastfile
operator|=
name|newfile
expr_stmt|;
name|auditd_log_notice
argument_list|(
literal|"New audit file is %s"
argument_list|,
name|newfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a new audit log trail file and swap with the current one, if any.  */
end_comment

begin_function
specifier|static
name|int
name|do_trail_file
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
comment|/* 	 * First, refresh the list of audit log directories. 	 */
name|err
operator|=
name|auditd_read_dirs
argument_list|(
name|audit_warn_soft
argument_list|,
name|audit_warn_hard
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"auditd_read_dirs() %s: %m"
argument_list|,
name|auditd_strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ADE_HARDLIM
condition|)
name|audit_warn_allhard
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ADE_SOFTLIM
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
name|audit_warn_allsoft
argument_list|()
expr_stmt|;
comment|/* continue on with soft limit error */
block|}
comment|/* 	 * Create a new file and swap with the one being used in kernel. 	 */
if|if
condition|(
name|swap_audit_file
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * XXX Faulty directory listing? - user should be given 		 * XXX an opportunity to change the audit_control file 		 * XXX switch to a reduced mode of auditing? 		 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start up auditing.  */
end_comment

begin_function
specifier|static
name|void
name|audit_setup
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
name|do_trail_file
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"Error creating audit trail file"
argument_list|)
expr_stmt|;
name|fail_exit
argument_list|()
expr_stmt|;
block|}
comment|/* Generate an audit record. */
name|err
operator|=
name|auditd_gen_record
argument_list|(
name|AUE_audit_startup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|auditd_log_err
argument_list|(
literal|"auditd_gen_record(AUE_audit_startup) %s: %m"
argument_list|,
name|auditd_strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|auditd_config_controls
argument_list|()
operator|==
literal|0
condition|)
name|auditd_log_info
argument_list|(
literal|"Audit controls init successful"
argument_list|)
expr_stmt|;
else|else
name|auditd_log_err
argument_list|(
literal|"Audit controls init failed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Close auditd pid file and trigger mechanism.   */
end_comment

begin_function
specifier|static
name|int
name|close_misc
parameter_list|(
name|void
parameter_list|)
block|{
name|auditd_close_dirs
argument_list|()
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|AUDITD_PIDFILE
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"Couldn't remove %s: %m"
argument_list|,
name|AUDITD_PIDFILE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|endac
argument_list|()
expr_stmt|;
if|if
condition|(
name|auditd_close_trigger
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"Error closing trigger messaging mechanism"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close all log files, control files, and tell the audit system.  */
end_comment

begin_function
specifier|static
name|int
name|close_all
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|err_ret
init|=
literal|0
decl_stmt|;
name|char
name|TS
index|[
name|TIMESTAMP_LEN
index|]
decl_stmt|;
name|int
name|err
decl_stmt|;
name|long
name|cond
decl_stmt|;
name|time_t
name|tt
decl_stmt|;
name|err
operator|=
name|auditd_gen_record
argument_list|(
name|AUE_audit_shutdown
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|auditd_log_err
argument_list|(
literal|"auditd_gen_record(AUE_audit_shutdown) %s: %m"
argument_list|,
name|auditd_strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Flush contents. */
name|cond
operator|=
name|AUC_DISABLED
expr_stmt|;
name|err_ret
operator|=
name|auditon
argument_list|(
name|A_SETCOND
argument_list|,
operator|&
name|cond
argument_list|,
sizeof|sizeof
argument_list|(
name|cond
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err_ret
operator|!=
literal|0
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"Disabling audit failed! : %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|err_ret
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Updated the cached state that auditing has been disabled. 	 */
name|auditd_set_state
argument_list|(
name|AUD_STATE_DISABLED
argument_list|)
expr_stmt|;
if|if
condition|(
name|getTSstr
argument_list|(
name|tt
argument_list|,
name|TS
argument_list|,
name|TIMESTAMP_LEN
argument_list|)
operator|==
literal|0
condition|)
name|close_lastfile
argument_list|(
name|TS
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastfile
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|lastfile
argument_list|)
expr_stmt|;
name|err_ret
operator|+=
name|close_misc
argument_list|()
expr_stmt|;
if|if
condition|(
name|err_ret
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"Could not unregister"
argument_list|)
expr_stmt|;
name|audit_warn_postsigterm
argument_list|()
expr_stmt|;
block|}
name|auditd_log_info
argument_list|(
literal|"Finished"
argument_list|)
expr_stmt|;
return|return
operator|(
name|err_ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Register the daemon with the signal handler and the auditd pid file.  */
end_comment

begin_function
specifier|static
name|int
name|register_daemon
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|pidfile
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
comment|/* Set up the signal hander. */
if|if
condition|(
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|auditd_relay_signal
argument_list|)
operator|==
name|SIG_ERR
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"Could not set signal handler for SIGTERM"
argument_list|)
expr_stmt|;
name|fail_exit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|auditd_relay_signal
argument_list|)
operator|==
name|SIG_ERR
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"Could not set signal handler for SIGCHLD"
argument_list|)
expr_stmt|;
name|fail_exit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|auditd_relay_signal
argument_list|)
operator|==
name|SIG_ERR
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"Could not set signal handler for SIGHUP"
argument_list|)
expr_stmt|;
name|fail_exit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|auditd_relay_signal
argument_list|)
operator|==
name|SIG_ERR
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"Could not set signal handler for SIGALRM"
argument_list|)
expr_stmt|;
name|fail_exit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pidfile
operator|=
name|fopen
argument_list|(
name|AUDITD_PIDFILE
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"Could not open PID file"
argument_list|)
expr_stmt|;
name|audit_warn_tmpfile
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Attempt to lock the pid file; if a lock is present, exit. */
name|fd
operator|=
name|fileno
argument_list|(
name|pidfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|flock
argument_list|(
name|fd
argument_list|,
name|LOCK_EX
operator||
name|LOCK_NB
argument_list|)
operator|<
literal|0
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"PID file is locked (is another auditd running?)."
argument_list|)
expr_stmt|;
name|audit_warn_ebusy
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|ftruncate
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|pidfile
argument_list|,
literal|"%u\n"
argument_list|,
name|pid
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Should not start the daemon. */
name|fail_exit
argument_list|()
expr_stmt|;
block|}
name|fflush
argument_list|(
name|pidfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle the audit trigger event.  *  * We suppress (ignore) duplicated triggers in close succession in order to  * try to avoid thrashing-like behavior.  However, not all triggers can be  * ignored, as triggers generally represent edge triggers, not level  * triggers, and won't be retransmitted if the condition persists.  Of  * specific concern is the rotate trigger -- if one is dropped, then it will  * not be retransmitted, and the log file will grow in an unbounded fashion.  */
end_comment

begin_define
define|#
directive|define
name|DUPLICATE_INTERVAL
value|30
end_define

begin_function
name|void
name|auditd_handle_trigger
parameter_list|(
name|int
name|trigger
parameter_list|)
block|{
specifier|static
name|int
name|last_trigger
decl_stmt|,
name|last_warning
decl_stmt|;
specifier|static
name|time_t
name|last_time
decl_stmt|;
name|struct
name|timeval
name|ts
decl_stmt|;
name|struct
name|timezone
name|tzp
decl_stmt|;
name|time_t
name|tt
decl_stmt|;
name|int
name|au_state
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/* 	 * Suppress duplicate messages from the kernel within the specified 	 * interval. 	 */
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|ts
argument_list|,
operator|&
name|tzp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tt
operator|=
operator|(
name|time_t
operator|)
name|ts
operator|.
name|tv_sec
expr_stmt|;
switch|switch
condition|(
name|trigger
condition|)
block|{
case|case
name|AUDIT_TRIGGER_LOW_SPACE
case|:
case|case
name|AUDIT_TRIGGER_NO_SPACE
case|:
comment|/* 			 * Triggers we can suppress.  Of course, we also need 			 * to rate limit the warnings, so apply the same 			 * interval limit on syslog messages. 			 */
if|if
condition|(
operator|(
name|trigger
operator|==
name|last_trigger
operator|)
operator|&&
operator|(
name|tt
operator|<
operator|(
name|last_time
operator|+
name|DUPLICATE_INTERVAL
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|tt
operator|>=
operator|(
name|last_warning
operator|+
name|DUPLICATE_INTERVAL
operator|)
condition|)
name|auditd_log_info
argument_list|(
literal|"Suppressing duplicate trigger %d"
argument_list|,
name|trigger
argument_list|)
expr_stmt|;
return|return;
block|}
name|last_warning
operator|=
name|tt
expr_stmt|;
break|break;
case|case
name|AUDIT_TRIGGER_ROTATE_KERNEL
case|:
case|case
name|AUDIT_TRIGGER_ROTATE_USER
case|:
case|case
name|AUDIT_TRIGGER_READ_FILE
case|:
case|case
name|AUDIT_TRIGGER_CLOSE_AND_DIE
case|:
case|case
name|AUDIT_TRIGGER_INITIALIZE
case|:
comment|/* 			 * Triggers that we cannot suppress. 			 */
break|break;
block|}
comment|/* 		 * Only update last_trigger after aborting due to a duplicate 		 * trigger, not before, or we will never allow that trigger 		 * again. 		 */
name|last_trigger
operator|=
name|trigger
expr_stmt|;
name|last_time
operator|=
name|tt
expr_stmt|;
block|}
name|au_state
operator|=
name|auditd_get_state
argument_list|()
expr_stmt|;
comment|/* 	 * Message processing is done here.  	 */
switch|switch
condition|(
name|trigger
condition|)
block|{
case|case
name|AUDIT_TRIGGER_LOW_SPACE
case|:
name|auditd_log_notice
argument_list|(
literal|"Got low space trigger"
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_trail_file
argument_list|()
operator|==
operator|-
literal|1
condition|)
name|auditd_log_err
argument_list|(
literal|"Error swapping audit file"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUDIT_TRIGGER_NO_SPACE
case|:
name|auditd_log_notice
argument_list|(
literal|"Got no space trigger"
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_trail_file
argument_list|()
operator|==
operator|-
literal|1
condition|)
name|auditd_log_err
argument_list|(
literal|"Error swapping audit file"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUDIT_TRIGGER_ROTATE_KERNEL
case|:
case|case
name|AUDIT_TRIGGER_ROTATE_USER
case|:
name|auditd_log_info
argument_list|(
literal|"Got open new trigger from %s"
argument_list|,
name|trigger
operator|==
name|AUDIT_TRIGGER_ROTATE_KERNEL
condition|?
literal|"kernel"
else|:
literal|"user"
argument_list|)
expr_stmt|;
if|if
condition|(
name|au_state
operator|==
name|AUD_STATE_ENABLED
operator|&&
name|do_trail_file
argument_list|()
operator|==
operator|-
literal|1
condition|)
name|auditd_log_err
argument_list|(
literal|"Error swapping audit file"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUDIT_TRIGGER_READ_FILE
case|:
name|auditd_log_info
argument_list|(
literal|"Got read file trigger"
argument_list|)
expr_stmt|;
if|if
condition|(
name|au_state
operator|==
name|AUD_STATE_ENABLED
operator|&&
name|auditd_config_controls
argument_list|()
operator|==
operator|-
literal|1
condition|)
name|auditd_log_err
argument_list|(
literal|"Error setting audit controls"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUDIT_TRIGGER_CLOSE_AND_DIE
case|:
name|auditd_log_info
argument_list|(
literal|"Got close and die trigger"
argument_list|)
expr_stmt|;
if|if
condition|(
name|au_state
operator|==
name|AUD_STATE_ENABLED
condition|)
name|err
operator|=
name|close_all
argument_list|()
expr_stmt|;
comment|/* 		 * Running under launchd don't exit.  Wait for launchd to 		 * send SIGTERM. 		 */
if|if
condition|(
operator|!
name|launchd_flag
condition|)
block|{
name|auditd_log_info
argument_list|(
literal|"auditd exiting."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AUDIT_TRIGGER_INITIALIZE
case|:
name|auditd_log_info
argument_list|(
literal|"Got audit initialize trigger"
argument_list|)
expr_stmt|;
if|if
condition|(
name|au_state
operator|==
name|AUD_STATE_DISABLED
condition|)
name|audit_setup
argument_list|()
expr_stmt|;
break|break;
default|default:
name|auditd_log_err
argument_list|(
literal|"Got unknown trigger %d"
argument_list|,
name|trigger
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Reap our children.  */
end_comment

begin_function
name|void
name|auditd_reap_children
parameter_list|(
name|void
parameter_list|)
block|{
name|pid_t
name|child
decl_stmt|;
name|int
name|wstatus
decl_stmt|;
while|while
condition|(
operator|(
name|child
operator|=
name|waitpid
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|wstatus
argument_list|,
name|WNOHANG
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|wstatus
condition|)
continue|continue;
name|auditd_log_info
argument_list|(
literal|"warn process [pid=%d] %s %d."
argument_list|,
name|child
argument_list|,
operator|(
operator|(
name|WIFEXITED
argument_list|(
name|wstatus
argument_list|)
operator|)
condition|?
literal|"exited with non-zero status"
else|:
literal|"exited as a result of signal"
operator|)
argument_list|,
operator|(
operator|(
name|WIFEXITED
argument_list|(
name|wstatus
argument_list|)
operator|)
condition|?
name|WEXITSTATUS
argument_list|(
name|wstatus
argument_list|)
else|:
name|WTERMSIG
argument_list|(
name|wstatus
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Reap any children and terminate.  If under launchd don't shutdown auditing  * but just the other stuff.  */
end_comment

begin_function
name|void
name|auditd_terminate
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|auditd_reap_children
argument_list|()
expr_stmt|;
if|if
condition|(
name|launchd_flag
condition|)
name|ret
operator|=
name|close_misc
argument_list|()
expr_stmt|;
else|else
name|ret
operator|=
name|close_all
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Configure the audit controls in the kernel: the event to class mapping,  * kernel preselection mask, etc.  */
end_comment

begin_function
name|int
name|auditd_config_controls
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|cnt
decl_stmt|,
name|err
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* 	 * Configure event to class mappings in kernel. 	 */
name|cnt
operator|=
name|auditd_set_evcmap
argument_list|()
expr_stmt|;
if|if
condition|(
name|cnt
operator|<
literal|0
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"auditd_set_evcmap() failed: %m"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"No events to class mappings registered."
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|auditd_log_debug
argument_list|(
literal|"Registered %d event to class mappings."
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
comment|/* 	 * Configure non-attributable event mask in kernel. 	 */
name|err
operator|=
name|auditd_set_namask
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"auditd_set_namask() %s: %m"
argument_list|,
name|auditd_strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|auditd_log_debug
argument_list|(
literal|"Registered non-attributable event mask."
argument_list|)
expr_stmt|;
comment|/* 	 * Configure audit policy in kernel. 	 */
name|err
operator|=
name|auditd_set_policy
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"auditd_set_policy() %s: %m"
argument_list|,
name|auditd_strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|auditd_log_debug
argument_list|(
literal|"Set audit policy in kernel."
argument_list|)
expr_stmt|;
comment|/* 	 * Configure audit trail log size in kernel. 	 */
name|err
operator|=
name|auditd_set_fsize
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"audit_set_fsize() %s: %m"
argument_list|,
name|auditd_strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|auditd_log_debug
argument_list|(
literal|"Set audit trail size in kernel."
argument_list|)
expr_stmt|;
comment|/* 	 * Configure audit trail volume minimum free percentage of blocks in  	 * kernel. 	 */
name|err
operator|=
name|auditd_set_minfree
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"auditd_set_minfree() %s: %m"
argument_list|,
name|auditd_strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|auditd_log_debug
argument_list|(
literal|"Set audit trail min free percent in kernel."
argument_list|)
expr_stmt|;
comment|/* 	 * Configure host address in the audit kernel information.  	 */
name|err
operator|=
name|auditd_set_host
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"auditd_set_host() %s: %m"
argument_list|,
name|auditd_strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|auditd_log_debug
argument_list|(
literal|"Set audit host address information in kernel."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Setup and initialize auditd.  */
end_comment

begin_function
specifier|static
name|void
name|setup
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
name|auditd_open_trigger
argument_list|(
name|launchd_flag
argument_list|)
operator|<
literal|0
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"Error opening trigger messaging mechanism"
argument_list|)
expr_stmt|;
name|fail_exit
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * To prevent event feedback cycles and avoid auditd becoming 	 * stalled if auditing is suspended, auditd and its children run 	 * without their events being audited.  We allow the uid, tid, and 	 * mask fields to be implicitly set to zero, but do set the pid.  We 	 * run this after opening the trigger device to avoid configuring 	 * audit state without audit present in the system. 	 */
name|err
operator|=
name|auditd_prevent_audit
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"auditd_prevent_audit() %s: %m"
argument_list|,
name|auditd_strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|fail_exit
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Make sure auditd auditing state is correct. 	 */
name|auditd_set_state
argument_list|(
name|AUD_STATE_INIT
argument_list|)
expr_stmt|;
comment|/* 	 * If under launchd, don't start auditing.  Wait for a trigger to 	 * do so. 	 */
if|if
condition|(
operator|!
name|launchd_flag
condition|)
name|audit_setup
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
name|int
name|debug
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|AUDIT_REVIEW_GROUP
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"dl"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'d'
case|:
comment|/* Debug option. */
name|debug
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* Be launchd friendly. */
name|launchd_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: auditd [-d] [-l]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|audit_review_gid
operator|=
name|getgid
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|AUDIT_REVIEW_GROUP
comment|/* 	 * XXXRW: Currently, this code falls back to the daemon gid, which is 	 * likely the wheel group.  Is there a better way to deal with this? 	 */
name|grp
operator|=
name|getgrnam
argument_list|(
name|AUDIT_REVIEW_GROUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|grp
operator|!=
name|NULL
condition|)
name|audit_review_gid
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
endif|#
directive|endif
name|auditd_openlog
argument_list|(
name|debug
argument_list|,
name|audit_review_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|launchd_flag
condition|)
name|auditd_log_info
argument_list|(
literal|"started by launchd..."
argument_list|)
expr_stmt|;
else|else
name|auditd_log_info
argument_list|(
literal|"starting..."
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUDIT_REVIEW_GROUP
if|if
condition|(
name|grp
operator|==
name|NULL
condition|)
name|auditd_log_info
argument_list|(
literal|"Audit review group '%s' not available, using daemon gid (%d)"
argument_list|,
name|AUDIT_REVIEW_GROUP
argument_list|,
name|audit_review_gid
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|debug
operator|==
literal|0
operator|&&
name|launchd_flag
operator|==
literal|0
operator|&&
name|daemon
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"Failed to daemonize"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|register_daemon
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"Could not register as daemon"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|setup
argument_list|()
expr_stmt|;
comment|/* 	 * auditd_wait_for_events() shouldn't return unless something is wrong.  	 */
name|auditd_wait_for_events
argument_list|()
expr_stmt|;
name|auditd_log_err
argument_list|(
literal|"abnormal exit."
argument_list|)
expr_stmt|;
name|close_all
argument_list|()
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

