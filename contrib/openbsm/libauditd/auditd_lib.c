begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Apple Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1.  Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  * 2.  Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.  * 3.  Neither the name of Apple Inc. ("Apple") nor the names of  *     its contributors may be used to endorse or promote products derived  *     from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  * $P4: //depot/projects/trustedbsd/openbsm/libauditd/auditd_lib.c#1 $  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<config/config.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FULL_QUEUE_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !HAVE_FULL_QUEUE_H */
end_comment

begin_include
include|#
directive|include
file|<compat/queue.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_FULL_QUEUE_H */
end_comment

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<bsm/audit.h>
end_include

begin_include
include|#
directive|include
file|<bsm/audit_uevents.h>
end_include

begin_include
include|#
directive|include
file|<bsm/auditd_lib.h>
end_include

begin_include
include|#
directive|include
file|<bsm/libbsm.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__APPLE__
end_ifdef

begin_include
include|#
directive|include
file|<notify.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__BSM_INTERNAL_NOTIFY_KEY
end_ifndef

begin_define
define|#
directive|define
name|__BSM_INTERNAL_NOTIFY_KEY
value|"com.apple.audit.change"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __BSM_INTERNAL_NOTIFY_KEY */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __APPLE__ */
end_comment

begin_comment
comment|/*  * XXX This is temporary until this is moved to<bsm/audit.h> and shared with  * the kernel.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|AUDIT_HARD_LIMIT_FREE_BLOCKS
end_ifndef

begin_define
define|#
directive|define
name|AUDIT_HARD_LIMIT_FREE_BLOCKS
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|dir_ent
block|{
name|char
modifier|*
name|dirname
decl_stmt|;
name|uint8_t
name|softlim
decl_stmt|;
name|uint8_t
name|hardlim
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|dir_ent
argument_list|)
name|dirs
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|dir_ent
argument_list|)
name|dir_q
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|minval
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|auditd_errmsg
index|[]
init|=
block|{
literal|"no error"
block|,
comment|/* ADE_NOERR 	( 0) */
literal|"could not parse audit_control(5) file"
block|,
comment|/* ADE_PARSE 	( 1) */
literal|"auditon(2) failed"
block|,
comment|/* ADE_AUDITON 	( 2) */
literal|"malloc(3) failed"
block|,
comment|/* ADE_NOMEM 	( 3) */
literal|"all audit log directories over soft limit"
block|,
comment|/* ADE_SOFTLIM  ( 4) */
literal|"all audit log directories over hard limit"
block|,
comment|/* ADE_HARDLIM 	( 5) */
literal|"could not create file name string"
block|,
comment|/* ADE_STRERR 	( 6) */
literal|"could not open audit record"
block|,
comment|/* ADE_AU_OPEN 	( 7) */
literal|"could not close audit record"
block|,
comment|/* ADE_AU_CLOSE ( 8) */
literal|"could not set active audit session state"
block|,
comment|/* ADE_SETAUDIT ( 9) */
literal|"auditctl(2) failed (trail still swapped)"
block|,
comment|/* ADE_ACTL 	(10) */
literal|"auditctl(2) failed (trail not swapped)"
block|,
comment|/* ADE_ACTLERR  (11) */
literal|"could not swap audit trail file"
block|,
comment|/* ADE_SWAPERR 	(12) */
literal|"could not rename crash recovery file"
block|,
comment|/* ADE_RENAME	(13) */
literal|"could not read 'current' link file"
block|,
comment|/* ADE_READLINK	(14) */
literal|"could not create 'current' link file"
block|,
comment|/* ADE_SYMLINK  (15) */
literal|"invalid argument"
block|,
comment|/* ADE_INVAL	(16) */
literal|"could not resolve hostname to address"
block|,
comment|/* ADE_GETADDR	(17) */
literal|"address family not supported"
block|,
comment|/* ADE_ADDRFAM	(18) */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAXERRCODE
value|(sizeof(auditd_errmsg) / sizeof(auditd_errmsg[0]))
end_define

begin_define
define|#
directive|define
name|NA_EVENT_STR_SIZE
value|25
end_define

begin_define
define|#
directive|define
name|POL_STR_SIZE
value|128
end_define

begin_comment
comment|/*  * Look up and return the error string for the given audit error code.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|auditd_strerror
parameter_list|(
name|int
name|errcode
parameter_list|)
block|{
name|int
name|idx
init|=
operator|-
name|errcode
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
name|idx
operator|>
operator|(
name|int
operator|)
name|MAXERRCODE
condition|)
return|return
operator|(
literal|"Invalid auditd error code"
operator|)
return|;
return|return
operator|(
name|auditd_errmsg
index|[
name|idx
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free our local list of directory names and init list   */
end_comment

begin_function
specifier|static
name|void
name|free_dir_q
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dir_ent
modifier|*
name|d1
decl_stmt|,
modifier|*
name|d2
decl_stmt|;
name|d1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|dir_q
argument_list|)
expr_stmt|;
while|while
condition|(
name|d1
operator|!=
name|NULL
condition|)
block|{
name|d2
operator|=
name|TAILQ_NEXT
argument_list|(
name|d1
argument_list|,
name|dirs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|d1
operator|->
name|dirname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|d1
argument_list|)
expr_stmt|;
name|d1
operator|=
name|d2
expr_stmt|;
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|dir_q
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Concat the directory name to the given file name.  * XXX We should affix the hostname also  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|affixdir
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|dir_ent
modifier|*
name|dirent
parameter_list|)
block|{
name|char
modifier|*
name|fn
init|=
name|NULL
decl_stmt|;
comment|/* 	 * Sanity check on file name. 	 */
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|!=
operator|(
name|FILENAME_LEN
operator|-
literal|1
operator|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|asprintf
argument_list|(
operator|&
name|fn
argument_list|,
literal|"%s/%s"
argument_list|,
name|dirent
operator|->
name|dirname
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|fn
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert the directory entry in the list by the way they are ordered in  * audit_control(5).  Move the entries that are over the soft and hard limits  * toward the tail.  */
end_comment

begin_function
specifier|static
name|void
name|insert_orderly
parameter_list|(
name|struct
name|dir_ent
modifier|*
name|denew
parameter_list|)
block|{
name|struct
name|dir_ent
modifier|*
name|dep
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|dep
argument_list|,
argument|&dir_q
argument_list|,
argument|dirs
argument_list|)
block|{
if|if
condition|(
name|dep
operator|->
name|softlim
operator|==
literal|1
operator|&&
name|denew
operator|->
name|softlim
operator|==
literal|0
condition|)
block|{
name|TAILQ_INSERT_BEFORE
argument_list|(
name|dep
argument_list|,
name|denew
argument_list|,
name|dirs
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dep
operator|->
name|hardlim
operator|==
literal|1
operator|&&
name|denew
operator|->
name|hardlim
operator|==
literal|0
condition|)
block|{
name|TAILQ_INSERT_BEFORE
argument_list|(
name|dep
argument_list|,
name|denew
argument_list|,
name|dirs
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dir_q
argument_list|,
name|denew
argument_list|,
name|dirs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the host from audit_control(5) and set it in the audit kernel  * information.  Return:  *	ADE_NOERR	on success.  *	ADE_PARSE	error parsing audit_control(5).  *	ADE_AUDITON	error getting/setting auditon(2) value.  *	ADE_GETADDR 	error getting address info for host.   *	ADE_ADDRFAM	un-supported address family. 	  */
end_comment

begin_function
name|int
name|auditd_set_host
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|hoststr
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|res
decl_stmt|;
name|struct
name|auditinfo_addr
name|aia
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ret
init|=
name|ADE_NOERR
decl_stmt|;
if|if
condition|(
name|getachost
argument_list|(
name|hoststr
argument_list|,
name|MAXHOSTNAMELEN
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|ADE_PARSE
expr_stmt|;
comment|/* 		 * To maintain reverse compatability with older audit_control 		 * files, simply drop a warning if the host parameter has not 		 * been set.  However, we will explicitly disable the 		 * generation of extended audit header by passing in a zeroed 		 * termid structure. 		 */
name|bzero
argument_list|(
operator|&
name|aia
argument_list|,
sizeof|sizeof
argument_list|(
name|aia
argument_list|)
argument_list|)
expr_stmt|;
name|aia
operator|.
name|ai_termid
operator|.
name|at_type
operator|=
name|AU_IPv4
expr_stmt|;
name|error
operator|=
name|auditon
argument_list|(
name|A_SETKAUDIT
argument_list|,
operator|&
name|aia
argument_list|,
sizeof|sizeof
argument_list|(
name|aia
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOSYS
condition|)
name|ret
operator|=
name|ADE_AUDITON
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|error
operator|=
name|getaddrinfo
argument_list|(
name|hoststr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|ADE_GETADDR
operator|)
return|;
switch|switch
condition|(
name|res
operator|->
name|ai_family
condition|)
block|{
case|case
name|PF_INET6
case|:
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|res
operator|->
name|ai_addr
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
operator|.
name|s6_addr
argument_list|,
operator|&
name|aia
operator|.
name|ai_termid
operator|.
name|at_addr
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|aia
operator|.
name|ai_termid
operator|.
name|at_type
operator|=
name|AU_IPv6
expr_stmt|;
break|break;
case|case
name|PF_INET
case|:
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|res
operator|->
name|ai_addr
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|,
operator|&
name|aia
operator|.
name|ai_termid
operator|.
name|at_addr
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|aia
operator|.
name|ai_termid
operator|.
name|at_type
operator|=
name|AU_IPv4
expr_stmt|;
break|break;
default|default:
comment|/* Un-supported address family in host parameter. */
name|errno
operator|=
name|EAFNOSUPPORT
expr_stmt|;
return|return
operator|(
name|ADE_ADDRFAM
operator|)
return|;
block|}
if|if
condition|(
name|auditon
argument_list|(
name|A_SETKAUDIT
argument_list|,
operator|&
name|aia
argument_list|,
sizeof|sizeof
argument_list|(
name|aia
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|ret
operator|=
name|ADE_AUDITON
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * Get the min percentage of free blocks from audit_control(5) and that  * value in the kernel.  Return:  *	ADE_NOERR	on success,  *	ADE_PARSE 	error parsing audit_control(5),  *	ADE_AUDITON	error getting/setting auditon(2) value.  */
end_comment

begin_function
name|int
name|auditd_set_minfree
parameter_list|(
name|void
parameter_list|)
block|{
name|au_qctrl_t
name|qctrl
decl_stmt|;
if|if
condition|(
name|getacmin
argument_list|(
operator|&
name|minval
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ADE_PARSE
operator|)
return|;
if|if
condition|(
name|auditon
argument_list|(
name|A_GETQCTRL
argument_list|,
operator|&
name|qctrl
argument_list|,
sizeof|sizeof
argument_list|(
name|qctrl
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ADE_AUDITON
operator|)
return|;
if|if
condition|(
name|qctrl
operator|.
name|aq_minfree
operator|!=
name|minval
condition|)
block|{
name|qctrl
operator|.
name|aq_minfree
operator|=
name|minval
expr_stmt|;
if|if
condition|(
name|auditon
argument_list|(
name|A_SETQCTRL
argument_list|,
operator|&
name|qctrl
argument_list|,
sizeof|sizeof
argument_list|(
name|qctrl
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ADE_AUDITON
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parses the "dir" entry in audit_control(5) into an ordered list.  Also, will  * set the minfree value if not already set.  Arguments include function  * pointers to audit_warn functions for soft and hard limits. Returns:  *	ADE_NOERR	on success,  *	ADE_PARSE	error parsing audit_control(5),  *	ADE_AUDITON	error getting/setting auditon(2) value,  *	ADE_NOMEM	error allocating memory,  *	ADE_SOFTLIM	if all the directories are over the soft limit,  *	ADE_HARDLIM	if all the directories are over the hard limit,  */
end_comment

begin_function
name|int
name|auditd_read_dirs
parameter_list|(
name|int
function_decl|(
modifier|*
name|warn_soft
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|)
parameter_list|,
name|int
function_decl|(
modifier|*
name|warn_hard
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|)
parameter_list|)
block|{
name|char
name|cur_dir
index|[
name|MAXNAMLEN
index|]
decl_stmt|;
name|struct
name|dir_ent
modifier|*
name|dirent
decl_stmt|;
name|struct
name|statfs
name|sfs
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
name|soft
decl_stmt|,
name|hard
decl_stmt|;
name|int
name|tcnt
init|=
literal|0
decl_stmt|;
name|int
name|scnt
init|=
literal|0
decl_stmt|;
name|int
name|hcnt
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|minval
operator|==
operator|-
literal|1
operator|&&
operator|(
name|err
operator|=
name|auditd_set_minfree
argument_list|()
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/*          * Init directory q.  Force a re-read of the file the next time.          */
name|free_dir_q
argument_list|()
expr_stmt|;
name|endac
argument_list|()
expr_stmt|;
comment|/* 	 * Read the list of directories into an ordered linked list 	 * admin's preference, then those over soft limit and, finally, 	 * those over the hard limit. 	 *          * XXX We should use the reentrant interfaces once they are          * available.          */
while|while
condition|(
name|getacdir
argument_list|(
name|cur_dir
argument_list|,
name|MAXNAMLEN
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|statfs
argument_list|(
name|cur_dir
argument_list|,
operator|&
name|sfs
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
comment|/* XXX should warn */
name|soft
operator|=
operator|(
name|sfs
operator|.
name|f_bfree
operator|<
operator|(
name|sfs
operator|.
name|f_blocks
operator|/
operator|(
literal|100
operator|/
name|minval
operator|)
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|hard
operator|=
operator|(
name|sfs
operator|.
name|f_bfree
operator|<
name|AUDIT_HARD_LIMIT_FREE_BLOCKS
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|soft
condition|)
block|{
if|if
condition|(
name|warn_soft
condition|)
call|(
modifier|*
name|warn_soft
call|)
argument_list|(
name|cur_dir
argument_list|)
expr_stmt|;
name|scnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|hard
condition|)
block|{
if|if
condition|(
name|warn_hard
condition|)
call|(
modifier|*
name|warn_hard
call|)
argument_list|(
name|cur_dir
argument_list|)
expr_stmt|;
name|hcnt
operator|++
expr_stmt|;
block|}
name|dirent
operator|=
operator|(
expr|struct
name|dir_ent
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dir_ent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirent
operator|==
name|NULL
condition|)
return|return
operator|(
name|ADE_NOMEM
operator|)
return|;
name|dirent
operator|->
name|softlim
operator|=
name|soft
expr_stmt|;
name|dirent
operator|->
name|hardlim
operator|=
name|hard
expr_stmt|;
name|dirent
operator|->
name|dirname
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|MAXNAMLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirent
operator|->
name|dirname
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|dirent
argument_list|)
expr_stmt|;
return|return
operator|(
name|ADE_NOMEM
operator|)
return|;
block|}
name|strlcpy
argument_list|(
name|dirent
operator|->
name|dirname
argument_list|,
name|cur_dir
argument_list|,
name|MAXNAMLEN
argument_list|)
expr_stmt|;
name|insert_orderly
argument_list|(
name|dirent
argument_list|)
expr_stmt|;
name|tcnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|hcnt
operator|==
name|tcnt
condition|)
return|return
operator|(
name|ADE_HARDLIM
operator|)
return|;
if|if
condition|(
name|scnt
operator|==
name|tcnt
condition|)
return|return
operator|(
name|ADE_SOFTLIM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|auditd_close_dirs
parameter_list|(
name|void
parameter_list|)
block|{
name|free_dir_q
argument_list|()
expr_stmt|;
name|minval
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process the audit event file, obtaining a class mapping for each event, and  * set that mapping into the kernel. Return:  * 	 n	number of event mappings that were successfully processed,  *   ADE_NOMEM	if there was an error allocating memory.	  */
end_comment

begin_function
name|int
name|auditd_set_evcmap
parameter_list|(
name|void
parameter_list|)
block|{
name|au_event_ent_t
name|ev
decl_stmt|,
modifier|*
name|evp
decl_stmt|;
name|au_evclass_map_t
name|evc_map
decl_stmt|;
name|int
name|ctr
init|=
literal|0
decl_stmt|;
comment|/* 	 * XXX There's a risk here that the BSM library will return NULL 	 * for an event when it can't properly map it to a class. In that 	 * case, we will not process any events beyond the one that failed, 	 * but should. We need a way to get a count of the events. 	 */
name|ev
operator|.
name|ae_name
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|AU_EVENT_NAME_MAX
argument_list|)
expr_stmt|;
name|ev
operator|.
name|ae_desc
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|AU_EVENT_DESC_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ev
operator|.
name|ae_name
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ev
operator|.
name|ae_desc
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|ev
operator|.
name|ae_name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ev
operator|.
name|ae_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ADE_NOMEM
operator|)
return|;
block|}
comment|/* 	 * XXXRW: Currently we have no way to remove mappings from the kernel 	 * when they are removed from the file-based mappings. 	 */
name|evp
operator|=
operator|&
name|ev
expr_stmt|;
name|setauevent
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|evp
operator|=
name|getauevent_r
argument_list|(
name|evp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|evc_map
operator|.
name|ec_number
operator|=
name|evp
operator|->
name|ae_number
expr_stmt|;
name|evc_map
operator|.
name|ec_class
operator|=
name|evp
operator|->
name|ae_class
expr_stmt|;
if|if
condition|(
name|auditon
argument_list|(
name|A_SETCLASS
argument_list|,
operator|&
name|evc_map
argument_list|,
sizeof|sizeof
argument_list|(
name|au_evclass_map_t
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|ctr
operator|++
expr_stmt|;
block|}
name|endauevent
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|ev
operator|.
name|ae_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ev
operator|.
name|ae_desc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ctr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the non-attributable event string and set the kernel mask.  Return:  *	ADE_NOERR 	on success,  *	ADE_PARSE	error parsing audit_control(5),  *	ADE_AUDITON	error setting the mask using auditon(2).  */
end_comment

begin_function
name|int
name|auditd_set_namask
parameter_list|(
name|void
parameter_list|)
block|{
name|au_mask_t
name|aumask
decl_stmt|;
name|char
name|naeventstr
index|[
name|NA_EVENT_STR_SIZE
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|getacna
argument_list|(
name|naeventstr
argument_list|,
name|NA_EVENT_STR_SIZE
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|getauditflagsbin
argument_list|(
name|naeventstr
argument_list|,
operator|&
name|aumask
argument_list|)
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
name|ADE_PARSE
operator|)
return|;
if|if
condition|(
name|auditon
argument_list|(
name|A_SETKMASK
argument_list|,
operator|&
name|aumask
argument_list|,
sizeof|sizeof
argument_list|(
name|au_mask_t
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|ADE_AUDITON
operator|)
return|;
return|return
operator|(
name|ADE_NOERR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the audit control policy if a policy is configured in audit_control(5),  * implement the policy. However, if one isn't defined or if there is an error  * parsing the control file, set AUDIT_CNT to avoid leaving the system in a  * fragile state.  Return:  *	ADE_NOERR 	on success,  *	ADE_PARSE	error parsing audit_control(5),  *	ADE_AUDITON	error setting policy using auditon(2).  */
end_comment

begin_function
name|int
name|auditd_set_policy
parameter_list|(
name|void
parameter_list|)
block|{
name|long
name|policy
decl_stmt|;
name|char
name|polstr
index|[
name|POL_STR_SIZE
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|getacpol
argument_list|(
name|polstr
argument_list|,
name|POL_STR_SIZE
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|au_strtopol
argument_list|(
name|polstr
argument_list|,
operator|&
name|policy
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|policy
operator|=
name|AUDIT_CNT
expr_stmt|;
if|if
condition|(
name|auditon
argument_list|(
name|A_SETPOLICY
argument_list|,
operator|&
name|policy
argument_list|,
sizeof|sizeof
argument_list|(
name|policy
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|ADE_AUDITON
operator|)
return|;
return|return
operator|(
name|ADE_PARSE
operator|)
return|;
block|}
if|if
condition|(
name|auditon
argument_list|(
name|A_SETPOLICY
argument_list|,
operator|&
name|policy
argument_list|,
sizeof|sizeof
argument_list|(
name|policy
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|ADE_AUDITON
operator|)
return|;
return|return
operator|(
name|ADE_NOERR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * Set trail rotation size.  Return:  *	ADE_NOERR 	on success,  *	ADE_PARSE	error parsing audit_control(5),  *	ADE_AUDITON	error setting file size using auditon(2).  */
end_comment

begin_function
name|int
name|auditd_set_fsize
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|filesz
decl_stmt|;
name|au_fstat_t
name|au_fstat
decl_stmt|;
comment|/* 	 * Set trail rotation size. 	 */
if|if
condition|(
name|getacfilesz
argument_list|(
operator|&
name|filesz
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ADE_PARSE
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|au_fstat
argument_list|,
sizeof|sizeof
argument_list|(
name|au_fstat
argument_list|)
argument_list|)
expr_stmt|;
name|au_fstat
operator|.
name|af_filesz
operator|=
name|filesz
expr_stmt|;
if|if
condition|(
name|auditon
argument_list|(
name|A_SETFSIZE
argument_list|,
operator|&
name|au_fstat
argument_list|,
sizeof|sizeof
argument_list|(
name|au_fstat
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|ADE_AUDITON
operator|)
return|;
return|return
operator|(
name|ADE_NOERR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create the new audit file with appropriate permissions and ownership.  Try  * to clean up if something goes wrong.  */
end_comment

begin_function
specifier|static
name|int
name|open_trail
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|,
name|gid_t
name|gid
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|fd
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_RDONLY
operator||
name|O_CREAT
argument_list|,
name|S_IRUSR
operator||
name|S_IRGRP
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|fchown
argument_list|(
name|fd
argument_list|,
operator|-
literal|1
argument_list|,
name|gid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|errno
operator|=
name|error
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create the new audit trail file, swap with existing audit file.  Arguments  * include timestamp for the filename, a pointer to a string for returning the  * new file name, GID for trail file, and audit_warn function pointer for   * 'getacdir()' errors.  Returns:  *  	ADE_NOERR	on success,  *  	ADE_STRERR	if the file name string could not be created,  *  	ADE_SWAPERR	if the audit trail file could not be swapped,  *	ADE_ACTL 	if the auditctl(2) call failed but file swap still  *			successful.  *	ADE_ACTLERR	if the auditctl(2) call failed and file swap failed.  *	ADE_SYMLINK	if symlink(2) failed updating the current link.  */
end_comment

begin_function
name|int
name|auditd_swap_trail
parameter_list|(
name|char
modifier|*
name|TS
parameter_list|,
name|char
modifier|*
modifier|*
name|newfile
parameter_list|,
name|gid_t
name|gid
parameter_list|,
name|int
function_decl|(
modifier|*
name|warn_getacdir
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|)
parameter_list|)
block|{
name|char
name|timestr
index|[
name|FILENAME_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|fn
decl_stmt|;
name|struct
name|dir_ent
modifier|*
name|dirent
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|saverrno
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|TS
argument_list|)
operator|!=
operator|(
name|TIMESTAMP_LEN
operator|-
literal|1
operator|)
operator|||
name|snprintf
argument_list|(
name|timestr
argument_list|,
name|FILENAME_LEN
argument_list|,
literal|"%s.%s"
argument_list|,
name|TS
argument_list|,
name|NOT_TERMINATED
argument_list|)
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|ADE_STRERR
operator|)
return|;
block|}
comment|/* Try until we succeed. */
while|while
condition|(
operator|(
name|dirent
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|dir_q
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|dirent
operator|->
name|hardlim
condition|)
continue|continue;
if|if
condition|(
operator|(
name|fn
operator|=
name|affixdir
argument_list|(
name|timestr
argument_list|,
name|dirent
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ADE_STRERR
operator|)
return|;
comment|/* 		 * Create and open the file; then close and pass to the 		 * kernel if all went well. 		 */
name|fd
operator|=
name|open_trail
argument_list|(
name|fn
argument_list|,
name|gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
name|error
operator|=
name|auditctl
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/*  				 * auditctl failed setting log file.   				 * Try again. 				 */
name|saverrno
operator|=
name|errno
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Success. */
operator|*
name|newfile
operator|=
name|fn
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|saverrno
condition|)
block|{
comment|/* 					 * auditctl() failed but still 					 * successful. Return errno and "soft"  					 * error. 					 */
name|errno
operator|=
name|saverrno
expr_stmt|;
return|return
operator|(
name|ADE_ACTL
operator|)
return|;
block|}
return|return
operator|(
name|ADE_NOERR
operator|)
return|;
block|}
block|}
comment|/* 		 * Tell the administrator about lack of permissions for dir. 		 */
if|if
condition|(
name|warn_getacdir
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|warn_getacdir
call|)
argument_list|(
name|dirent
operator|->
name|dirname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|saverrno
condition|)
block|{
name|errno
operator|=
name|saverrno
expr_stmt|;
return|return
operator|(
name|ADE_ACTLERR
operator|)
return|;
block|}
else|else
return|return
operator|(
name|ADE_SWAPERR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mask calling process from being audited. Returns:  *	ADE_NOERR	on success,  *	ADE_SETAUDIT	if setaudit(2) fails.  */
end_comment

begin_function
name|int
name|auditd_prevent_audit
parameter_list|(
name|void
parameter_list|)
block|{
name|auditinfo_t
name|ai
decl_stmt|;
comment|/*  	 * To prevent event feedback cycles and avoid audit becoming stalled if 	 * auditing is suspended we mask this processes events from being 	 * audited.  We allow the uid, tid, and mask fields to be implicitly 	 * set to zero, but do set the audit session ID to the PID.  	 * 	 * XXXRW: Is there more to it than this? 	 */
name|bzero
argument_list|(
operator|&
name|ai
argument_list|,
sizeof|sizeof
argument_list|(
name|ai
argument_list|)
argument_list|)
expr_stmt|;
name|ai
operator|.
name|ai_asid
operator|=
name|getpid
argument_list|()
expr_stmt|;
if|if
condition|(
name|setaudit
argument_list|(
operator|&
name|ai
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ADE_SETAUDIT
operator|)
return|;
return|return
operator|(
name|ADE_NOERR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate and submit audit record for audit startup or shutdown.  The event  * argument can be AUE_audit_recovery, AUE_audit_startup or  * AUE_audit_shutdown. The path argument will add a path token, if not NULL.  * Returns:  *	AUE_NOERR	on success,  *	ADE_NOMEM	if memory allocation fails,  * 	ADE_AU_OPEN	if au_open(3) fails,  *	ADE_AU_CLOSE	if au_close(3) fails.  */
end_comment

begin_function
name|int
name|auditd_gen_record
parameter_list|(
name|int
name|event
parameter_list|,
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|aufd
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|char
modifier|*
name|autext
init|=
name|NULL
decl_stmt|;
name|token_t
modifier|*
name|tok
decl_stmt|;
name|struct
name|auditinfo_addr
name|aia
decl_stmt|;
if|if
condition|(
name|event
operator|==
name|AUE_audit_startup
condition|)
name|asprintf
argument_list|(
operator|&
name|autext
argument_list|,
literal|"%s::Audit startup"
argument_list|,
name|getprogname
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|event
operator|==
name|AUE_audit_shutdown
condition|)
name|asprintf
argument_list|(
operator|&
name|autext
argument_list|,
literal|"%s::Audit shutdown"
argument_list|,
name|getprogname
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|event
operator|==
name|AUE_audit_recovery
condition|)
name|asprintf
argument_list|(
operator|&
name|autext
argument_list|,
literal|"%s::Audit recovery"
argument_list|,
name|getprogname
argument_list|()
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|ADE_INVAL
operator|)
return|;
if|if
condition|(
name|autext
operator|==
name|NULL
condition|)
return|return
operator|(
name|ADE_NOMEM
operator|)
return|;
if|if
condition|(
operator|(
name|aufd
operator|=
name|au_open
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|autext
argument_list|)
expr_stmt|;
return|return
operator|(
name|ADE_AU_OPEN
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
name|aia
argument_list|,
sizeof|sizeof
argument_list|(
name|aia
argument_list|)
argument_list|)
expr_stmt|;
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|tok
operator|=
name|au_to_subject32_ex
argument_list|(
name|uid
argument_list|,
name|geteuid
argument_list|()
argument_list|,
name|getegid
argument_list|()
argument_list|,
name|uid
argument_list|,
name|getgid
argument_list|()
argument_list|,
name|pid
argument_list|,
name|pid
argument_list|,
operator|&
name|aia
operator|.
name|ai_termid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|au_write
argument_list|(
name|aufd
argument_list|,
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tok
operator|=
name|au_to_text
argument_list|(
name|autext
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|au_write
argument_list|(
name|aufd
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|autext
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|!=
name|NULL
operator|&&
operator|(
name|tok
operator|=
name|au_to_path
argument_list|(
name|path
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|au_write
argument_list|(
name|aufd
argument_list|,
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tok
operator|=
name|au_to_return32
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|au_write
argument_list|(
name|aufd
argument_list|,
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
name|au_close
argument_list|(
name|aufd
argument_list|,
literal|1
argument_list|,
name|event
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|ADE_AU_CLOSE
operator|)
return|;
return|return
operator|(
name|ADE_NOERR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check for a 'current' symlink and do crash recovery, if needed. Create a new  * 'current' symlink. The argument 'curfile' is the file the 'current' symlink  * should point to.  Returns:  *	ADE_NOERR	on success,  *  	ADE_AU_OPEN	if au_open(3) fails,  *  	ADE_AU_CLOSE	if au_close(3) fails.  *	ADE_RENAME	if error renaming audit trail file,  *	ADE_READLINK	if error reading the 'current' link,  *	ADE_SYMLINK	if error creating 'current' link.  */
end_comment

begin_function
name|int
name|auditd_new_curlink
parameter_list|(
name|char
modifier|*
name|curfile
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|err
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|path
init|=
name|NULL
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|char
name|recoveredname
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|newname
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
comment|/* 	 * Check to see if audit was shutdown properly.  If not, clean up, 	 * recover previous audit trail file, and generate audit record. 	 */
name|len
operator|=
name|readlink
argument_list|(
name|AUDIT_CURRENT_LINK
argument_list|,
name|recoveredname
argument_list|,
name|MAXPATHLEN
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* 'current' exist but is it pointing at a valid file?  */
name|recoveredname
index|[
name|len
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|recoveredname
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yes, rename it to a crash recovery file. */
name|strlcpy
argument_list|(
name|newname
argument_list|,
name|recoveredname
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|strstr
argument_list|(
name|newname
argument_list|,
name|NOT_TERMINATED
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strlcpy
argument_list|(
name|ptr
argument_list|,
name|CRASH_RECOVERY
argument_list|,
name|TIMESTAMP_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|recoveredname
argument_list|,
name|newname
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ADE_RENAME
operator|)
return|;
block|}
else|else
return|return
operator|(
name|ADE_STRERR
operator|)
return|;
name|path
operator|=
name|newname
expr_stmt|;
block|}
comment|/* 'current' symlink is (now) invalid so remove it. */
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|AUDIT_CURRENT_LINK
argument_list|)
expr_stmt|;
comment|/* Note the crash recovery in current audit trail */
name|err
operator|=
name|auditd_gen_record
argument_list|(
name|AUE_audit_recovery
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|ADE_READLINK
operator|)
return|;
if|if
condition|(
name|symlink
argument_list|(
name|curfile
argument_list|,
name|AUDIT_CURRENT_LINK
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ADE_SYMLINK
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do just what we need to quickly start auditing.  Assume no system logging or  * notify.  Return:  *   0	 on success,  *  -1   on failure.  */
end_comment

begin_function
name|int
name|audit_quick_start
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|newfile
decl_stmt|;
name|time_t
name|tt
decl_stmt|;
name|char
name|TS
index|[
name|TIMESTAMP_LEN
index|]
decl_stmt|;
comment|/*  	 * Mask auditing of this process. 	 */
if|if
condition|(
name|auditd_prevent_audit
argument_list|()
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Read audit_control and get log directories. 	 */
name|err
operator|=
name|auditd_read_dirs
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ADE_NOERR
operator|&&
name|err
operator|!=
name|ADE_SOFTLIM
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 *  Create a new audit trail log. 	 */
if|if
condition|(
name|getTSstr
argument_list|(
name|tt
argument_list|,
name|TS
argument_list|,
name|TIMESTAMP_LEN
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|err
operator|=
name|auditd_swap_trail
argument_list|(
name|TS
argument_list|,
operator|&
name|newfile
argument_list|,
name|getgid
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ADE_NOERR
operator|&&
name|err
operator|!=
name|ADE_ACTL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Add the current symlink and recover from crash, if needed.  	 */
if|if
condition|(
name|auditd_new_curlink
argument_list|(
name|newfile
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * At this point auditing has started so generate audit start-up record. 	 */
if|if
condition|(
name|auditd_gen_record
argument_list|(
name|AUE_audit_startup
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 *  Configure the audit controls. 	 */
operator|(
name|void
operator|)
name|auditd_set_evcmap
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|auditd_set_namask
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|auditd_set_policy
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|auditd_set_fsize
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|auditd_set_minfree
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|auditd_set_host
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Shut down auditing quickly.  Assumes that is only called on system shutdown.  * Returns:  *	 0	on success,  *	-1	on failure.  */
end_comment

begin_function
name|int
name|audit_quick_stop
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|long
name|cond
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|time_t
name|tt
decl_stmt|;
name|char
name|oldname
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|newname
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|TS
index|[
name|TIMESTAMP_LEN
index|]
decl_stmt|;
comment|/* 	 * Auditing already disabled? 	 */
if|if
condition|(
name|auditon
argument_list|(
name|A_GETCOND
argument_list|,
operator|&
name|cond
argument_list|,
sizeof|sizeof
argument_list|(
name|cond
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|cond
operator|==
name|AUC_DISABLED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 *  Generate audit shutdown record. 	 */
operator|(
name|void
operator|)
name|auditd_gen_record
argument_list|(
name|AUE_audit_shutdown
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Shutdown auditing in the kernel. 	 */
name|cond
operator|=
name|AUC_DISABLED
expr_stmt|;
if|if
condition|(
name|auditon
argument_list|(
name|A_SETCOND
argument_list|,
operator|&
name|cond
argument_list|,
sizeof|sizeof
argument_list|(
name|cond
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|__BSM_INTERNAL_NOTIFY_KEY
name|notify_post
argument_list|(
name|__BSM_INTERNAL_NOTIFY_KEY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Rename last audit trail and remove 'current' link. 	 */
name|len
operator|=
name|readlink
argument_list|(
name|AUDIT_CURRENT_LINK
argument_list|,
name|oldname
argument_list|,
name|MAXPATHLEN
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|oldname
index|[
name|len
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|getTSstr
argument_list|(
name|tt
argument_list|,
name|TS
argument_list|,
name|TIMESTAMP_LEN
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|strlcpy
argument_list|(
name|newname
argument_list|,
name|oldname
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|strstr
argument_list|(
name|newname
argument_list|,
name|NOT_TERMINATED
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strlcpy
argument_list|(
name|ptr
argument_list|,
name|TS
argument_list|,
name|TIMESTAMP_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|oldname
argument_list|,
name|newname
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|AUDIT_CURRENT_LINK
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

