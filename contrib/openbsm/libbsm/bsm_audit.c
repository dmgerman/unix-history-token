begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004 Apple Computer, Inc.  * Copyright (c) 2005 SPARTA, Inc.  * All rights reserved.  *  * This code was developed in part by Robert N. M. Watson, Senior Principal  * Scientist, SPARTA, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1.  Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  * 2.  Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.  * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of  *     its contributors may be used to endorse or promote products derived  *     from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  * $P4: //depot/projects/trustedbsd/openbsm/libbsm/bsm_audit.c#18 $  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<bsm/audit_internal.h>
end_include

begin_include
include|#
directive|include
file|<bsm/libbsm.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* array of used descriptors */
end_comment

begin_decl_stmt
specifier|static
name|au_record_t
modifier|*
name|open_desc_table
index|[
name|MAX_AUDIT_RECORDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current number of active record descriptors */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bsm_rec_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Records that can be recycled are maintained in the list given below.  The  * maximum number of elements that can be present in this list is bounded by  * MAX_AUDIT_RECORDS.  Memory allocated for these records are never freed.  */
end_comment

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|au_record
argument_list|)
name|bsm_free_q
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|pthread_mutex_t
name|mutex
init|=
name|PTHREAD_MUTEX_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This call frees a token_t and its internal data.  */
end_comment

begin_function
name|void
name|au_free_token
parameter_list|(
name|token_t
modifier|*
name|tok
parameter_list|)
block|{
if|if
condition|(
name|tok
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tok
operator|->
name|t_data
condition|)
name|free
argument_list|(
name|tok
operator|->
name|t_data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tok
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This call reserves memory for the audit record.  Memory must be guaranteed  * before any auditable event can be generated.  The au_record_t structure  * maintains a reference to the memory allocated above and also the list of  * tokens associated with this record.  Descriptors are recyled once the  * records are added to the audit trail following au_close().  */
end_comment

begin_function
name|int
name|au_open
parameter_list|(
name|void
parameter_list|)
block|{
name|au_record_t
modifier|*
name|rec
init|=
name|NULL
decl_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsm_rec_count
operator|==
literal|0
condition|)
name|LIST_INIT
argument_list|(
operator|&
name|bsm_free_q
argument_list|)
expr_stmt|;
comment|/* 	 * Find an unused descriptor, remove it from the free list, mark as 	 * used. 	 */
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|bsm_free_q
argument_list|)
condition|)
block|{
name|rec
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|bsm_free_q
argument_list|)
expr_stmt|;
name|rec
operator|->
name|used
operator|=
literal|1
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|rec
argument_list|,
name|au_rec_q
argument_list|)
expr_stmt|;
block|}
name|pthread_mutex_unlock
argument_list|(
operator|&
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|rec
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Create a new au_record_t if no descriptors are available. 		 */
name|rec
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|au_record_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rec
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|rec
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|MAX_AUDIT_RECORD_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rec
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|rec
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pthread_mutex_lock
argument_list|(
operator|&
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsm_rec_count
operator|==
name|MAX_AUDIT_RECORDS
condition|)
block|{
name|pthread_mutex_unlock
argument_list|(
operator|&
name|mutex
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rec
operator|->
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rec
argument_list|)
expr_stmt|;
comment|/* XXX We need to increase size of MAX_AUDIT_RECORDS */
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|rec
operator|->
name|desc
operator|=
name|bsm_rec_count
expr_stmt|;
name|open_desc_table
index|[
name|bsm_rec_count
index|]
operator|=
name|rec
expr_stmt|;
name|bsm_rec_count
operator|++
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|mutex
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|rec
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|MAX_AUDIT_RECORD_SIZE
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|rec
operator|->
name|token_q
argument_list|)
expr_stmt|;
name|rec
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|rec
operator|->
name|used
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|rec
operator|->
name|desc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Store the token with the record descriptor.  *  * Don't permit writing more to the buffer than would let the trailer be  * appended later.  */
end_comment

begin_function
name|int
name|au_write
parameter_list|(
name|int
name|d
parameter_list|,
name|token_t
modifier|*
name|tok
parameter_list|)
block|{
name|au_record_t
modifier|*
name|rec
decl_stmt|;
if|if
condition|(
name|tok
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Invalid Token */
block|}
comment|/* Write the token to the record descriptor */
name|rec
operator|=
name|open_desc_table
index|[
name|d
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|rec
operator|==
name|NULL
operator|)
operator|||
operator|(
name|rec
operator|->
name|used
operator|==
literal|0
operator|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Invalid descriptor */
block|}
if|if
condition|(
name|rec
operator|->
name|len
operator|+
name|tok
operator|->
name|len
operator|+
name|BSM_TRAILER_SIZE
operator|>
name|MAX_AUDIT_RECORD_SIZE
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Add the token to the tail */
comment|/* 	 * XXX Not locking here -- we should not be writing to 	 * XXX the same descriptor from different threads 	 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|rec
operator|->
name|token_q
argument_list|,
name|tok
argument_list|,
name|tokens
argument_list|)
expr_stmt|;
name|rec
operator|->
name|len
operator|+=
name|tok
operator|->
name|len
expr_stmt|;
comment|/* grow record length by token size bytes */
comment|/* Token should not be available after this call */
name|tok
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Success */
block|}
end_function

begin_comment
comment|/*  * Assemble an audit record out of its tokens, including allocating header and  * trailer tokens.  Does not free the token chain, which must be done by the  * caller if desirable.  *  * XXX: Assumes there is sufficient space for the header and trailer.  */
end_comment

begin_function
specifier|static
name|int
name|au_assemble
parameter_list|(
name|au_record_t
modifier|*
name|rec
parameter_list|,
name|short
name|event
parameter_list|)
block|{
name|token_t
modifier|*
name|header
decl_stmt|,
modifier|*
name|tok
decl_stmt|,
modifier|*
name|trailer
decl_stmt|;
name|size_t
name|tot_rec_size
decl_stmt|;
name|u_char
modifier|*
name|dptr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|tot_rec_size
operator|=
name|rec
operator|->
name|len
operator|+
name|BSM_HEADER_SIZE
operator|+
name|BSM_TRAILER_SIZE
expr_stmt|;
name|header
operator|=
name|au_to_header32
argument_list|(
name|tot_rec_size
argument_list|,
name|event
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|trailer
operator|=
name|au_to_trailer
argument_list|(
name|tot_rec_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|trailer
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|au_free_token
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|errno
operator|=
name|error
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|rec
operator|->
name|token_q
argument_list|,
name|header
argument_list|,
name|tokens
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|rec
operator|->
name|token_q
argument_list|,
name|trailer
argument_list|,
name|tokens
argument_list|)
expr_stmt|;
name|rec
operator|->
name|len
operator|=
name|tot_rec_size
expr_stmt|;
name|dptr
operator|=
name|rec
operator|->
name|data
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tok
argument_list|,
argument|&rec->token_q
argument_list|,
argument|tokens
argument_list|)
block|{
name|memcpy
argument_list|(
name|dptr
argument_list|,
name|tok
operator|->
name|t_data
argument_list|,
name|tok
operator|->
name|len
argument_list|)
expr_stmt|;
name|dptr
operator|+=
name|tok
operator|->
name|len
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a record that is no longer of interest, tear it down and convert to a  * free record.  */
end_comment

begin_function
specifier|static
name|void
name|au_teardown
parameter_list|(
name|au_record_t
modifier|*
name|rec
parameter_list|)
block|{
name|token_t
modifier|*
name|tok
decl_stmt|;
comment|/* Free the token list */
while|while
condition|(
operator|(
name|tok
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|rec
operator|->
name|token_q
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|rec
operator|->
name|token_q
argument_list|,
name|tok
argument_list|,
name|tokens
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tok
operator|->
name|t_data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tok
argument_list|)
expr_stmt|;
block|}
name|rec
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|rec
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|mutex
argument_list|)
expr_stmt|;
comment|/* Add the record to the freelist tail */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|bsm_free_q
argument_list|,
name|rec
argument_list|,
name|au_rec_q
argument_list|)
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add the header token, identify any missing tokens.  Write out the tokens to  * the record memory and finally, call audit.  */
end_comment

begin_function
name|int
name|au_close
parameter_list|(
name|int
name|d
parameter_list|,
name|int
name|keep
parameter_list|,
name|short
name|event
parameter_list|)
block|{
name|au_record_t
modifier|*
name|rec
decl_stmt|;
name|size_t
name|tot_rec_size
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|rec
operator|=
name|open_desc_table
index|[
name|d
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|rec
operator|==
name|NULL
operator|)
operator|||
operator|(
name|rec
operator|->
name|used
operator|==
literal|0
operator|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Invalid descriptor */
block|}
if|if
condition|(
operator|!
name|keep
condition|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|tot_rec_size
operator|=
name|rec
operator|->
name|len
operator|+
name|BSM_HEADER_SIZE
operator|+
name|BSM_TRAILER_SIZE
expr_stmt|;
if|if
condition|(
name|tot_rec_size
operator|>
name|MAX_AUDIT_RECORD_SIZE
condition|)
block|{
comment|/* 		 * XXXRW: Since au_write() is supposed to prevent this, spew 		 * an error here. 		 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"au_close failed"
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|au_assemble
argument_list|(
name|rec
argument_list|,
name|event
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* 		 * XXXRW: This is also not supposed to happen, but might if we 		 * are unable to allocate header and trailer memory. 		 */
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Call the kernel interface to audit */
name|retval
operator|=
name|audit
argument_list|(
name|rec
operator|->
name|data
argument_list|,
name|rec
operator|->
name|len
argument_list|)
expr_stmt|;
name|cleanup
label|:
comment|/* CLEANUP */
name|au_teardown
argument_list|(
name|rec
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * au_close(), except onto an in-memory buffer.  Buffer size as an argument,  * record size returned via same argument on success.  */
end_comment

begin_function
name|int
name|au_close_buffer
parameter_list|(
name|int
name|d
parameter_list|,
name|short
name|event
parameter_list|,
name|u_char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|buflen
parameter_list|)
block|{
name|size_t
name|tot_rec_size
decl_stmt|;
name|au_record_t
modifier|*
name|rec
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|rec
operator|=
name|open_desc_table
index|[
name|d
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|rec
operator|==
name|NULL
operator|)
operator|||
operator|(
name|rec
operator|->
name|used
operator|==
literal|0
operator|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|retval
operator|=
literal|0
expr_stmt|;
name|tot_rec_size
operator|=
name|rec
operator|->
name|len
operator|+
name|BSM_HEADER_SIZE
operator|+
name|BSM_TRAILER_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|tot_rec_size
operator|>
name|MAX_AUDIT_RECORD_SIZE
operator|)
operator|||
operator|(
name|tot_rec_size
operator|>
operator|*
name|buflen
operator|)
condition|)
block|{
comment|/* 		 * XXXRW: See au_close() comment. 		 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"au_close_buffer failed %zd"
argument_list|,
name|tot_rec_size
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|au_assemble
argument_list|(
name|rec
argument_list|,
name|event
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* XXXRW: See au_close() comment. */
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|rec
operator|->
name|data
argument_list|,
name|rec
operator|->
name|len
argument_list|)
expr_stmt|;
operator|*
name|buflen
operator|=
name|rec
operator|->
name|len
expr_stmt|;
name|cleanup
label|:
name|au_teardown
argument_list|(
name|rec
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

end_unit

