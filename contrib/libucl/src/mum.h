begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 2016 Vladimir Makarov<vmakarov@gcc.gnu.org>     Permission is hereby granted, free of charge, to any person    obtaining a copy of this software and associated documentation    files (the "Software"), to deal in the Software without    restriction, including without limitation the rights to use, copy,    modify, merge, publish, distribute, sublicense, and/or sell copies    of the Software, and to permit persons to whom the Software is    furnished to do so, subject to the following conditions:     The above copyright notice and this permission notice shall be    included in all copies or substantial portions of the Software.     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE    SOFTWARE. */
end_comment

begin_comment
comment|/* This file implements MUM (MUltiply and Mix) hashing.  We randomize    input data by 64x64-bit multiplication and mixing hi- and low-parts    of the multiplication result by using an addition and then mix it    into the current state.  We use prime numbers randomly generated    with the equal probability of their bit values for the    multiplication.  When all primes are used once, the state is    randomized and the same prime numbers are used again for data    randomization.     The MUM hashing passes all SMHasher tests.  Pseudo Random Number    Generator based on MUM also passes NIST Statistical Test Suite for    Random and Pseudorandom Number Generators for Cryptographic    Applications (version 2.2.1) with 1000 bitstreams each containing    1M bits.  MUM hashing is also faster Spooky64 and City64 on small    strings (at least upto 512-bit) on Haswell and Power7.  The MUM bulk    speed (speed on very long data) is bigger than Spooky and City on    Power7.  On Haswell the bulk speed is bigger than Spooky one and    close to City speed.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__MUM_HASH__
end_ifndef

begin_define
define|#
directive|define
name|__MUM_HASH__
end_define

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_typedef
typedef|typedef
name|unsigned
name|__int16
name|uint16_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|__int32
name|uint32_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|__int64
name|uint64_t
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Macro saying to use 128-bit integers implemented by GCC for some    targets.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_MUM_USE_INT128
end_ifndef

begin_comment
comment|/* In GCC uint128_t is defined if HOST_BITS_PER_WIDE_INT>= 64.    HOST_WIDE_INT is long if HOST_BITS_PER_LONG> HOST_BITS_PER_INT,    otherwise int. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|UINT_MAX
operator|!=
name|ULONG_MAX
end_if

begin_define
define|#
directive|define
name|_MUM_USE_INT128
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_MUM_USE_INT128
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
operator|(
name|__GNUC__
operator|==
literal|4
operator|)
operator|&&
operator|(
name|__GNUC_MINOR__
operator|>=
literal|9
operator|)
operator|||
operator|(
name|__GNUC__
operator|>
literal|4
operator|)
operator|)
end_if

begin_define
define|#
directive|define
name|_MUM_FRESH_GCC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__llvm__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_MUM_FRESH_GCC
argument_list|)
end_if

begin_define
define|#
directive|define
name|_MUM_ATTRIBUTE_UNUSED
value|__attribute__((unused))
end_define

begin_define
define|#
directive|define
name|_MUM_OPTIMIZE
parameter_list|(
name|opts
parameter_list|)
value|__attribute__((__optimize__ (opts)))
end_define

begin_define
define|#
directive|define
name|_MUM_TARGET
parameter_list|(
name|opts
parameter_list|)
value|__attribute__((__target__ (opts)))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_MUM_ATTRIBUTE_UNUSED
end_define

begin_define
define|#
directive|define
name|_MUM_OPTIMIZE
parameter_list|(
name|opts
parameter_list|)
end_define

begin_define
define|#
directive|define
name|_MUM_TARGET
parameter_list|(
name|opts
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Here are different primes randomly generated with the equal    probability of their bit values.  They are used to randomize input    values.  */
end_comment

begin_decl_stmt
specifier|static
name|uint64_t
name|_mum_hash_step_prime
init|=
literal|0x2e0bb864e9ea7df5ULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|_mum_key_step_prime
init|=
literal|0xcdb32970830fcaa1ULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|_mum_block_start_prime
init|=
literal|0xc42b5e2e6480b23bULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|_mum_unroll_prime
init|=
literal|0x7b51ec3d22f7096fULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|_mum_tail_prime
init|=
literal|0xaf47d47c99b1461bULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|_mum_finish_prime1
init|=
literal|0xa9a7ae7ceff79f3fULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|_mum_finish_prime2
init|=
literal|0xaf47d47c99b1461bULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|_mum_primes
index|[]
init|=
block|{
literal|0X9ebdcae10d981691
block|,
literal|0X32b9b9b97a27ac7d
block|,
literal|0X29b5584d83d35bbd
block|,
literal|0X4b04e0e61401255f
block|,
literal|0X25e8f7b1f1c9d027
block|,
literal|0X80d4c8c000f3e881
block|,
literal|0Xbd1255431904b9dd
block|,
literal|0X8a3bd4485eee6d81
block|,
literal|0X3bc721b2aad05197
block|,
literal|0X71b1a19b907d6e33
block|,
literal|0X525e6c1084a8534b
block|,
literal|0X9e4c2cd340c1299f
block|,
literal|0Xde3add92e94caa37
block|,
literal|0X7e14eadb1f65311d
block|,
literal|0X3f5aa40f89812853
block|,
literal|0X33b15a3b587d15c9
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Multiply 64-bit V and P and return sum of high and low parts of the    result.  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint64_t
name|_mum
parameter_list|(
name|uint64_t
name|v
parameter_list|,
name|uint64_t
name|p
parameter_list|)
block|{
name|uint64_t
name|hi
decl_stmt|,
name|lo
decl_stmt|;
if|#
directive|if
name|_MUM_USE_INT128
if|#
directive|if
name|defined
argument_list|(
name|__aarch64__
argument_list|)
comment|/* AARCH64 needs 2 insns to calculate 128-bit result of the      multiplication.  If we use a generic code we actually call a      function doing 128x128->128 bit multiplication.  The function is      very slow.  */
name|lo
operator|=
name|v
operator|*
name|p
operator|,
name|hi
expr_stmt|;
asm|asm ("umulh %0, %1, %2" : "=r" (hi) : "r" (v), "r" (p));
else|#
directive|else
name|__uint128_t
name|r
init|=
operator|(
name|__uint128_t
operator|)
name|v
operator|*
operator|(
name|__uint128_t
operator|)
name|p
decl_stmt|;
name|hi
operator|=
call|(
name|uint64_t
call|)
argument_list|(
name|r
operator|>>
literal|64
argument_list|)
expr_stmt|;
name|lo
operator|=
operator|(
name|uint64_t
operator|)
name|r
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* Implementation of 64x64->128-bit multiplication by four 32x32->64      bit multiplication.  */
name|uint64_t
name|hv
init|=
name|v
operator|>>
literal|32
decl_stmt|,
name|hp
init|=
name|p
operator|>>
literal|32
decl_stmt|;
name|uint64_t
name|lv
init|=
operator|(
name|uint32_t
operator|)
name|v
decl_stmt|,
name|lp
init|=
operator|(
name|uint32_t
operator|)
name|p
decl_stmt|;
name|uint64_t
name|rh
init|=
name|hv
operator|*
name|hp
decl_stmt|;
name|uint64_t
name|rm_0
init|=
name|hv
operator|*
name|lp
decl_stmt|;
name|uint64_t
name|rm_1
init|=
name|hp
operator|*
name|lv
decl_stmt|;
name|uint64_t
name|rl
init|=
name|lv
operator|*
name|lp
decl_stmt|;
name|uint64_t
name|t
decl_stmt|,
name|carry
init|=
literal|0
decl_stmt|;
comment|/* We could ignore a carry bit here if we did not care about the      same hash for 32-bit and 64-bit targets.  */
name|t
operator|=
name|rl
operator|+
operator|(
name|rm_0
operator|<<
literal|32
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MUM_TARGET_INDEPENDENT_HASH
name|carry
operator|=
name|t
operator|<
name|rl
expr_stmt|;
endif|#
directive|endif
name|lo
operator|=
name|t
operator|+
operator|(
name|rm_1
operator|<<
literal|32
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MUM_TARGET_INDEPENDENT_HASH
name|carry
operator|+=
name|lo
operator|<
name|t
expr_stmt|;
endif|#
directive|endif
name|hi
operator|=
name|rh
operator|+
operator|(
name|rm_0
operator|>>
literal|32
operator|)
operator|+
operator|(
name|rm_1
operator|>>
literal|32
operator|)
operator|+
name|carry
expr_stmt|;
endif|#
directive|endif
comment|/* We could use XOR here too but, for some reasons, on Haswell and      Power7 using an addition improves hashing performance by 10% for      small strings.  */
return|return
name|hi
operator|+
name|lo
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if

begin_define
define|#
directive|define
name|_mum_bswap_32
parameter_list|(
name|x
parameter_list|)
value|_byteswap_uint32_t (x)
end_define

begin_define
define|#
directive|define
name|_mum_bswap_64
parameter_list|(
name|x
parameter_list|)
value|_byteswap_uint64_t (x)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__APPLE__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<libkern/OSByteOrder.h>
end_include

begin_define
define|#
directive|define
name|_mum_bswap_32
parameter_list|(
name|x
parameter_list|)
value|OSSwapInt32 (x)
end_define

begin_define
define|#
directive|define
name|_mum_bswap_64
parameter_list|(
name|x
parameter_list|)
value|OSSwapInt64 (x)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|_mum_bswap32
parameter_list|(
name|x
parameter_list|)
value|__builtin_bswap32 (x)
end_define

begin_define
define|#
directive|define
name|_mum_bswap64
parameter_list|(
name|x
parameter_list|)
value|__builtin_bswap64 (x)
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<byteswap.h>
end_include

begin_define
define|#
directive|define
name|_mum_bswap32
parameter_list|(
name|x
parameter_list|)
value|bswap32 (x)
end_define

begin_define
define|#
directive|define
name|_mum_bswap64
parameter_list|(
name|x
parameter_list|)
value|bswap64 (x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|uint64_t
name|_mum_le
parameter_list|(
name|uint64_t
name|v
parameter_list|)
block|{
if|#
directive|if
name|__BYTE_ORDER__
operator|==
name|__ORDER_LITTLE_ENDIAN__
operator|||
operator|!
name|defined
argument_list|(
name|MUM_TARGET_INDEPENDENT_HASH
argument_list|)
return|return
name|v
return|;
elif|#
directive|elif
name|__BYTE_ORDER__
operator|==
name|__ORDER_BIG_ENDIAN__
return|return
name|_mum_bswap64
argument_list|(
name|v
argument_list|)
return|;
else|#
directive|else
error|#
directive|error
literal|"Unknown endianess"
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|_mum_le32
parameter_list|(
name|uint32_t
name|v
parameter_list|)
block|{
if|#
directive|if
name|__BYTE_ORDER__
operator|==
name|__ORDER_LITTLE_ENDIAN__
operator|||
operator|!
name|defined
argument_list|(
name|MUM_TARGET_INDEPENDENT_HASH
argument_list|)
return|return
name|v
return|;
elif|#
directive|elif
name|__BYTE_ORDER__
operator|==
name|__ORDER_BIG_ENDIAN__
return|return
name|_mum_bswap32
argument_list|(
name|v
argument_list|)
return|;
else|#
directive|else
error|#
directive|error
literal|"Unknown endianess"
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Macro defining how many times the most nested loop in    _mum_hash_aligned will be unrolled by the compiler (although it can    make an own decision:).  Use only a constant here to help a    compiler to unroll a major loop.     The macro value affects the result hash for strings> 128 bit.  The    unroll factor greatly affects the hashing speed.  We prefer the    speed.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_MUM_UNROLL_FACTOR_POWER
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__PPC64__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MUM_TARGET_INDEPENDENT_HASH
argument_list|)
end_if

begin_define
define|#
directive|define
name|_MUM_UNROLL_FACTOR_POWER
value|3
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__aarch64__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MUM_TARGET_INDEPENDENT_HASH
argument_list|)
end_elif

begin_define
define|#
directive|define
name|_MUM_UNROLL_FACTOR_POWER
value|4
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_MUM_UNROLL_FACTOR_POWER
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|_MUM_UNROLL_FACTOR_POWER
operator|<
literal|1
end_if

begin_error
error|#
directive|error
literal|"too small unroll factor"
end_error

begin_elif
elif|#
directive|elif
name|_MUM_UNROLL_FACTOR_POWER
operator|>
literal|4
end_elif

begin_error
error|#
directive|error
literal|"We have not enough primes for such unroll factor"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|_MUM_UNROLL_FACTOR
value|(1<< _MUM_UNROLL_FACTOR_POWER)
end_define

begin_decl_stmt
specifier|static
specifier|inline
name|uint64_t
name|_MUM_OPTIMIZE
argument_list|(
literal|"unroll-loops"
argument_list|)
name|_mum_hash_aligned
argument_list|(
name|uint64_t
name|start
argument_list|,
specifier|const
name|void
operator|*
name|key
argument_list|,
name|size_t
name|len
argument_list|)
block|{
name|uint64_t
name|result
init|=
name|start
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|str
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|key
decl_stmt|;
name|uint64_t
name|u64
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|result
operator|=
name|_mum
argument_list|(
name|result
argument_list|,
name|_mum_block_start_prime
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|>
name|_MUM_UNROLL_FACTOR
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|)
block|{
comment|/* This loop could be vectorized when we have vector insns for        64x64->128-bit multiplication.  AVX2 currently only have a        vector insn for 4 32x32->64-bit multiplication.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_MUM_UNROLL_FACTOR
condition|;
name|i
operator|++
control|)
name|result
operator|^=
name|_mum
argument_list|(
name|_mum_le
argument_list|(
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|str
operator|)
index|[
name|i
index|]
argument_list|)
argument_list|,
name|_mum_primes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|len
operator|-=
name|_MUM_UNROLL_FACTOR
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|str
operator|+=
name|_MUM_UNROLL_FACTOR
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
comment|/* We will use the same prime numbers on the next iterations --        randomize the state.  */
name|result
operator|=
name|_mum
argument_list|(
name|result
argument_list|,
name|_mum_unroll_prime
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|len
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|n
condition|;
name|i
operator|++
control|)
name|result
operator|^=
name|_mum
argument_list|(
name|_mum_le
argument_list|(
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|str
operator|)
index|[
name|i
index|]
argument_list|)
argument_list|,
name|_mum_primes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|len
operator|-=
name|n
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|str
operator|+=
name|n
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|7
case|:
name|u64
operator|=
name|_mum_le32
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|str
argument_list|)
expr_stmt|;
name|u64
operator||=
operator|(
name|uint64_t
operator|)
name|str
index|[
literal|4
index|]
operator|<<
literal|32
expr_stmt|;
name|u64
operator||=
operator|(
name|uint64_t
operator|)
name|str
index|[
literal|5
index|]
operator|<<
literal|40
expr_stmt|;
name|u64
operator||=
operator|(
name|uint64_t
operator|)
name|str
index|[
literal|6
index|]
operator|<<
literal|48
expr_stmt|;
return|return
name|result
operator|^
name|_mum
argument_list|(
name|u64
argument_list|,
name|_mum_tail_prime
argument_list|)
return|;
case|case
literal|6
case|:
name|u64
operator|=
name|_mum_le32
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|str
argument_list|)
expr_stmt|;
name|u64
operator||=
operator|(
name|uint64_t
operator|)
name|str
index|[
literal|4
index|]
operator|<<
literal|32
expr_stmt|;
name|u64
operator||=
operator|(
name|uint64_t
operator|)
name|str
index|[
literal|5
index|]
operator|<<
literal|40
expr_stmt|;
return|return
name|result
operator|^
name|_mum
argument_list|(
name|u64
argument_list|,
name|_mum_tail_prime
argument_list|)
return|;
case|case
literal|5
case|:
name|u64
operator|=
name|_mum_le32
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|str
argument_list|)
expr_stmt|;
name|u64
operator||=
operator|(
name|uint64_t
operator|)
name|str
index|[
literal|4
index|]
operator|<<
literal|32
expr_stmt|;
return|return
name|result
operator|^
name|_mum
argument_list|(
name|u64
argument_list|,
name|_mum_tail_prime
argument_list|)
return|;
case|case
literal|4
case|:
name|u64
operator|=
name|_mum_le32
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|str
argument_list|)
expr_stmt|;
return|return
name|result
operator|^
name|_mum
argument_list|(
name|u64
argument_list|,
name|_mum_tail_prime
argument_list|)
return|;
case|case
literal|3
case|:
name|u64
operator|=
name|str
index|[
literal|0
index|]
expr_stmt|;
name|u64
operator||=
operator|(
name|uint64_t
operator|)
name|str
index|[
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
name|u64
operator||=
operator|(
name|uint64_t
operator|)
name|str
index|[
literal|2
index|]
operator|<<
literal|16
expr_stmt|;
return|return
name|result
operator|^
name|_mum
argument_list|(
name|u64
argument_list|,
name|_mum_tail_prime
argument_list|)
return|;
case|case
literal|2
case|:
name|u64
operator|=
name|str
index|[
literal|0
index|]
expr_stmt|;
name|u64
operator||=
operator|(
name|uint64_t
operator|)
name|str
index|[
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
return|return
name|result
operator|^
name|_mum
argument_list|(
name|u64
argument_list|,
name|_mum_tail_prime
argument_list|)
return|;
case|case
literal|1
case|:
name|u64
operator|=
name|str
index|[
literal|0
index|]
expr_stmt|;
return|return
name|result
operator|^
name|_mum
argument_list|(
name|u64
argument_list|,
name|_mum_tail_prime
argument_list|)
return|;
block|}
return|return
name|result
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Final randomization of H.  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint64_t
name|_mum_final
parameter_list|(
name|uint64_t
name|h
parameter_list|)
block|{
name|h
operator|^=
name|_mum
argument_list|(
name|h
argument_list|,
name|_mum_finish_prime1
argument_list|)
expr_stmt|;
name|h
operator|^=
name|_mum
argument_list|(
name|h
argument_list|,
name|_mum_finish_prime2
argument_list|)
expr_stmt|;
return|return
name|h
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_MUM_FRESH_GCC
argument_list|)
end_if

begin_comment
comment|/* We want to use AVX2 insn MULX instead of generic x86-64 MULQ where    it is possible.  Although on modern Intel processors MULQ takes    3-cycles vs. 4 for MULX, MULX permits more freedom in insn    scheduling as it uses less fixed registers.  */
end_comment

begin_decl_stmt
specifier|static
specifier|inline
name|uint64_t
name|_MUM_TARGET
argument_list|(
literal|"arch=haswell"
argument_list|)
name|_mum_hash_avx2
argument_list|(
specifier|const
name|void
operator|*
name|key
argument_list|,
name|size_t
name|len
argument_list|,
name|uint64_t
name|seed
argument_list|)
block|{
return|return
name|_mum_final
argument_list|(
name|_mum_hash_aligned
argument_list|(
name|seed
operator|+
name|len
argument_list|,
name|key
argument_list|,
name|len
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_MUM_UNALIGNED_ACCESS
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__PPC64__
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|__s390__
argument_list|)
operator|||
name|defined
argument_list|(
name|__m32c__
argument_list|)
operator|||
name|defined
argument_list|(
name|cris
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|__CR16__
argument_list|)
operator|||
name|defined
argument_list|(
name|__vax__
argument_list|)
operator|||
name|defined
argument_list|(
name|__m68k__
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|__aarch64__
argument_list|)
end_if

begin_define
define|#
directive|define
name|_MUM_UNALIGNED_ACCESS
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_MUM_UNALIGNED_ACCESS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* When we need an aligned access to data being hashed we move part of    the unaligned data to an aligned block of given size and then    process it, repeating processing the data by the block.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_MUM_BLOCK_LEN
end_ifndef

begin_define
define|#
directive|define
name|_MUM_BLOCK_LEN
value|1024
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|_MUM_BLOCK_LEN
operator|<
literal|8
end_if

begin_error
error|#
directive|error
literal|"too small block length"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|inline
name|uint64_t
if|#
directive|if
name|defined
argument_list|(
name|__x86_64__
argument_list|)
name|_MUM_TARGET
argument_list|(
literal|"inline-all-stringops"
argument_list|)
endif|#
directive|endif
name|_mum_hash_default
argument_list|(
specifier|const
name|void
operator|*
name|key
argument_list|,
name|size_t
name|len
argument_list|,
name|uint64_t
name|seed
argument_list|)
block|{
name|uint64_t
name|result
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|str
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|key
decl_stmt|;
name|size_t
name|block_len
decl_stmt|;
name|uint64_t
name|buf
index|[
name|_MUM_BLOCK_LEN
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
index|]
decl_stmt|;
name|result
operator|=
name|seed
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|_MUM_UNALIGNED_ACCESS
operator|||
operator|(
operator|(
name|size_t
operator|)
name|str
operator|&
literal|0x7
operator|)
operator|==
literal|0
condition|)
name|result
operator|=
name|_mum_hash_aligned
argument_list|(
name|result
argument_list|,
name|key
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|block_len
operator|=
name|len
operator|<
name|_MUM_BLOCK_LEN
condition|?
name|len
else|:
name|_MUM_BLOCK_LEN
expr_stmt|;
name|memmove
argument_list|(
name|buf
argument_list|,
name|str
argument_list|,
name|block_len
argument_list|)
expr_stmt|;
name|result
operator|=
name|_mum_hash_aligned
argument_list|(
name|result
argument_list|,
name|buf
argument_list|,
name|block_len
argument_list|)
expr_stmt|;
name|len
operator|-=
name|block_len
expr_stmt|;
name|str
operator|+=
name|block_len
expr_stmt|;
block|}
block|}
return|return
name|_mum_final
argument_list|(
name|result
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|uint64_t
name|_mum_next_factor
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|start
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|start
operator|=
operator|(
name|start
operator|<<
literal|8
operator|)
operator||
name|rand
argument_list|()
operator|%
literal|256
expr_stmt|;
return|return
name|start
return|;
block|}
end_function

begin_comment
comment|/* ++++++++++++++++++++++++++ Interface functions: +++++++++++++++++++  */
end_comment

begin_comment
comment|/* Set random multiplicators depending on SEED.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mum_hash_randomize
parameter_list|(
name|uint64_t
name|seed
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|srand
argument_list|(
name|seed
argument_list|)
expr_stmt|;
name|_mum_hash_step_prime
operator|=
name|_mum_next_factor
argument_list|()
expr_stmt|;
name|_mum_key_step_prime
operator|=
name|_mum_next_factor
argument_list|()
expr_stmt|;
name|_mum_finish_prime1
operator|=
name|_mum_next_factor
argument_list|()
expr_stmt|;
name|_mum_finish_prime2
operator|=
name|_mum_next_factor
argument_list|()
expr_stmt|;
name|_mum_block_start_prime
operator|=
name|_mum_next_factor
argument_list|()
expr_stmt|;
name|_mum_unroll_prime
operator|=
name|_mum_next_factor
argument_list|()
expr_stmt|;
name|_mum_tail_prime
operator|=
name|_mum_next_factor
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|_mum_primes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
name|_mum_primes
index|[
name|i
index|]
operator|=
name|_mum_next_factor
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start hashing data with SEED.  Return the state.  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint64_t
name|mum_hash_init
parameter_list|(
name|uint64_t
name|seed
parameter_list|)
block|{
return|return
name|seed
return|;
block|}
end_function

begin_comment
comment|/* Process data KEY with the state H and return the updated state.  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint64_t
name|mum_hash_step
parameter_list|(
name|uint64_t
name|h
parameter_list|,
name|uint64_t
name|key
parameter_list|)
block|{
return|return
name|_mum
argument_list|(
name|h
argument_list|,
name|_mum_hash_step_prime
argument_list|)
operator|^
name|_mum
argument_list|(
name|key
argument_list|,
name|_mum_key_step_prime
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the result of hashing using the current state H.  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint64_t
name|mum_hash_finish
parameter_list|(
name|uint64_t
name|h
parameter_list|)
block|{
return|return
name|_mum_final
argument_list|(
name|h
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fast hashing of KEY with SEED.  The hash is always the same for the    same key on any target. */
end_comment

begin_function
specifier|static
specifier|inline
name|size_t
name|mum_hash64
parameter_list|(
name|uint64_t
name|key
parameter_list|,
name|uint64_t
name|seed
parameter_list|)
block|{
return|return
name|mum_hash_finish
argument_list|(
name|mum_hash_step
argument_list|(
name|mum_hash_init
argument_list|(
name|seed
argument_list|)
argument_list|,
name|key
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Hash data KEY of length LEN and SEED.  The hash depends on the    target endianess and the unroll factor.  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint64_t
name|mum_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|size_t
name|len
parameter_list|,
name|uint64_t
name|seed
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_MUM_FRESH_GCC
argument_list|)
specifier|static
name|int
name|avx2_support
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|avx2_support
operator|>
literal|0
condition|)
return|return
name|_mum_hash_avx2
argument_list|(
name|key
argument_list|,
name|len
argument_list|,
name|seed
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|avx2_support
condition|)
block|{
name|__builtin_cpu_init
argument_list|()
expr_stmt|;
name|avx2_support
operator|=
name|__builtin_cpu_supports
argument_list|(
literal|"avx2"
argument_list|)
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|avx2_support
operator|>
literal|0
condition|)
return|return
name|_mum_hash_avx2
argument_list|(
name|key
argument_list|,
name|len
argument_list|,
name|seed
argument_list|)
return|;
block|}
endif|#
directive|endif
return|return
name|_mum_hash_default
argument_list|(
name|key
argument_list|,
name|len
argument_list|,
name|seed
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

