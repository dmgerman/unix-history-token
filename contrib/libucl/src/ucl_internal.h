begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 2013, Vsevolod Stakhov  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *       * Redistributions of source code must retain the above copyright  *         notice, this list of conditions and the following disclaimer.  *       * Redistributions in binary form must reproduce the above copyright  *         notice, this list of conditions and the following disclaimer in the  *         documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED. IN NO EVENT SHALL AUTHOR BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|UCL_INTERNAL_H_
end_ifndef

begin_define
define|#
directive|define
name|UCL_INTERNAL_H_
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Help embedded builds */
end_comment

begin_define
define|#
directive|define
name|HAVE_SYS_TYPES_H
end_define

begin_define
define|#
directive|define
name|HAVE_SYS_MMAN_H
end_define

begin_define
define|#
directive|define
name|HAVE_SYS_STAT_H
end_define

begin_define
define|#
directive|define
name|HAVE_SYS_PARAM_H
end_define

begin_define
define|#
directive|define
name|HAVE_LIMITS_H
end_define

begin_define
define|#
directive|define
name|HAVE_FCNTL_H
end_define

begin_define
define|#
directive|define
name|HAVE_ERRNO_H
end_define

begin_define
define|#
directive|define
name|HAVE_UNISTD_H
end_define

begin_define
define|#
directive|define
name|HAVE_CTYPE_H
end_define

begin_define
define|#
directive|define
name|HAVE_STDIO_H
end_define

begin_define
define|#
directive|define
name|HAVE_STRING_H
end_define

begin_define
define|#
directive|define
name|HAVE_FLOAT_H
end_define

begin_define
define|#
directive|define
name|HAVE_LIBGEN_H
end_define

begin_define
define|#
directive|define
name|HAVE_MATH_H
end_define

begin_define
define|#
directive|define
name|HAVE_STDBOOL_H
end_define

begin_define
define|#
directive|define
name|HAVE_STDINT_H
end_define

begin_define
define|#
directive|define
name|HAVE_STDARG_H
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|_WIN32
end_ifndef

begin_define
define|#
directive|define
name|HAVE_REGEX_H
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TYPES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_MMAN_H
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|_WIN32
end_ifndef

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_STAT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PARAM_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIMITS_H
end_ifdef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FCNTL_H
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ERRNO_H
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CTYPE_H
end_ifdef

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDIO_H
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRINGS_H
end_ifdef

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"utlist.h"
end_include

begin_include
include|#
directive|include
file|"utstring.h"
end_include

begin_include
include|#
directive|include
file|"uthash.h"
end_include

begin_include
include|#
directive|include
file|"ucl.h"
end_include

begin_include
include|#
directive|include
file|"ucl_hash.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OPENSSL
end_ifdef

begin_include
include|#
directive|include
file|<openssl/evp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__DECONST
end_ifndef

begin_define
define|#
directive|define
name|__DECONST
parameter_list|(
name|type
parameter_list|,
name|var
parameter_list|)
value|((type)(uintptr_t)(const void *)(var))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * @file rcl_internal.h  * Internal structures and functions of UCL library  */
end_comment

begin_define
define|#
directive|define
name|UCL_MAX_RECURSION
value|16
end_define

begin_define
define|#
directive|define
name|UCL_TRASH_KEY
value|0
end_define

begin_define
define|#
directive|define
name|UCL_TRASH_VALUE
value|1
end_define

begin_enum
enum|enum
name|ucl_parser_state
block|{
name|UCL_STATE_INIT
init|=
literal|0
block|,
name|UCL_STATE_OBJECT
block|,
name|UCL_STATE_ARRAY
block|,
name|UCL_STATE_KEY
block|,
name|UCL_STATE_VALUE
block|,
name|UCL_STATE_AFTER_VALUE
block|,
name|UCL_STATE_ARRAY_VALUE
block|,
name|UCL_STATE_SCOMMENT
block|,
name|UCL_STATE_MCOMMENT
block|,
name|UCL_STATE_MACRO_NAME
block|,
name|UCL_STATE_MACRO
block|,
name|UCL_STATE_ERROR
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ucl_character_type
block|{
name|UCL_CHARACTER_DENIED
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
name|UCL_CHARACTER_KEY
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
name|UCL_CHARACTER_KEY_START
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
name|UCL_CHARACTER_WHITESPACE
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|,
name|UCL_CHARACTER_WHITESPACE_UNSAFE
init|=
operator|(
literal|1
operator|<<
literal|4
operator|)
block|,
name|UCL_CHARACTER_VALUE_END
init|=
operator|(
literal|1
operator|<<
literal|5
operator|)
block|,
name|UCL_CHARACTER_VALUE_STR
init|=
operator|(
literal|1
operator|<<
literal|6
operator|)
block|,
name|UCL_CHARACTER_VALUE_DIGIT
init|=
operator|(
literal|1
operator|<<
literal|7
operator|)
block|,
name|UCL_CHARACTER_VALUE_DIGIT_START
init|=
operator|(
literal|1
operator|<<
literal|8
operator|)
block|,
name|UCL_CHARACTER_ESCAPE
init|=
operator|(
literal|1
operator|<<
literal|9
operator|)
block|,
name|UCL_CHARACTER_KEY_SEP
init|=
operator|(
literal|1
operator|<<
literal|10
operator|)
block|,
name|UCL_CHARACTER_JSON_UNSAFE
init|=
operator|(
literal|1
operator|<<
literal|11
operator|)
block|,
name|UCL_CHARACTER_UCL_UNSAFE
init|=
operator|(
literal|1
operator|<<
literal|12
operator|)
block|}
enum|;
end_enum

begin_struct
struct|struct
name|ucl_macro
block|{
name|char
modifier|*
name|name
decl_stmt|;
union|union
block|{
name|ucl_macro_handler
name|handler
decl_stmt|;
name|ucl_context_macro_handler
name|context_handler
decl_stmt|;
block|}
name|h
union|;
name|void
modifier|*
name|ud
decl_stmt|;
name|bool
name|is_context
decl_stmt|;
name|UT_hash_handle
name|hh
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ucl_stack
block|{
name|ucl_object_t
modifier|*
name|obj
decl_stmt|;
name|struct
name|ucl_stack
modifier|*
name|next
decl_stmt|;
name|uint64_t
name|level
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ucl_chunk
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|begin
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|end
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|pos
decl_stmt|;
name|size_t
name|remain
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|unsigned
name|int
name|column
decl_stmt|;
name|unsigned
name|priority
decl_stmt|;
name|enum
name|ucl_duplicate_strategy
name|strategy
decl_stmt|;
name|enum
name|ucl_parse_type
name|parse_type
decl_stmt|;
name|struct
name|ucl_chunk
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OPENSSL
end_ifdef

begin_struct
struct|struct
name|ucl_pubkey
block|{
name|EVP_PKEY
modifier|*
name|key
decl_stmt|;
name|struct
name|ucl_pubkey
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_else
else|#
directive|else
end_else

begin_struct
struct|struct
name|ucl_pubkey
block|{
name|struct
name|ucl_pubkey
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|ucl_variable
block|{
name|char
modifier|*
name|var
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|size_t
name|var_len
decl_stmt|;
name|size_t
name|value_len
decl_stmt|;
name|struct
name|ucl_variable
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ucl_parser
block|{
name|enum
name|ucl_parser_state
name|state
decl_stmt|;
name|enum
name|ucl_parser_state
name|prev_state
decl_stmt|;
name|unsigned
name|int
name|recursion
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|unsigned
name|default_priority
decl_stmt|;
name|int
name|err_code
decl_stmt|;
name|ucl_object_t
modifier|*
name|top_obj
decl_stmt|;
name|ucl_object_t
modifier|*
name|cur_obj
decl_stmt|;
name|ucl_object_t
modifier|*
name|trash_objs
decl_stmt|;
name|ucl_object_t
modifier|*
name|includepaths
decl_stmt|;
name|char
modifier|*
name|cur_file
decl_stmt|;
name|struct
name|ucl_macro
modifier|*
name|macroes
decl_stmt|;
name|struct
name|ucl_stack
modifier|*
name|stack
decl_stmt|;
name|struct
name|ucl_chunk
modifier|*
name|chunks
decl_stmt|;
name|struct
name|ucl_pubkey
modifier|*
name|keys
decl_stmt|;
name|struct
name|ucl_variable
modifier|*
name|variables
decl_stmt|;
name|ucl_variable_handler
name|var_handler
decl_stmt|;
name|void
modifier|*
name|var_data
decl_stmt|;
name|ucl_object_t
modifier|*
name|comments
decl_stmt|;
name|ucl_object_t
modifier|*
name|last_comment
decl_stmt|;
name|UT_string
modifier|*
name|err
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ucl_object_userdata
block|{
name|ucl_object_t
name|obj
decl_stmt|;
name|ucl_userdata_dtor
name|dtor
decl_stmt|;
name|ucl_userdata_emitter
name|emitter
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * Unescape json string inplace  * @param str  */
end_comment

begin_function_decl
name|size_t
name|ucl_unescape_json_string
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Handle include macro  * @param data include data  * @param len length of data  * @param args UCL object representing arguments to the macro  * @param ud user data  * @return  */
end_comment

begin_function_decl
name|bool
name|ucl_include_handler
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|args
parameter_list|,
name|void
modifier|*
name|ud
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Handle tryinclude macro  * @param data include data  * @param len length of data  * @param args UCL object representing arguments to the macro  * @param ud user data  * @return  */
end_comment

begin_function_decl
name|bool
name|ucl_try_include_handler
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|args
parameter_list|,
name|void
modifier|*
name|ud
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Handle includes macro  * @param data include data  * @param len length of data  * @param args UCL object representing arguments to the macro  * @param ud user data  * @return  */
end_comment

begin_function_decl
name|bool
name|ucl_includes_handler
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|args
parameter_list|,
name|void
modifier|*
name|ud
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Handle priority macro  * @param data include data  * @param len length of data  * @param args UCL object representing arguments to the macro  * @param ud user data  * @return  */
end_comment

begin_function_decl
name|bool
name|ucl_priority_handler
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|args
parameter_list|,
name|void
modifier|*
name|ud
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Handle load macro  * @param data include data  * @param len length of data  * @param args UCL object representing arguments to the macro  * @param ud user data  * @return  */
end_comment

begin_function_decl
name|bool
name|ucl_load_handler
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|args
parameter_list|,
name|void
modifier|*
name|ud
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Handle inherit macro  * @param data include data  * @param len length of data  * @param args UCL object representing arguments to the macro  * @param ctx the current context object  * @param ud user data  * @return  */
end_comment

begin_function_decl
name|bool
name|ucl_inherit_handler
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|args
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|ud
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|size_t
name|ucl_strlcpy
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|size_t
name|siz
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|size_t
name|ucl_strlcpy_unsafe
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|size_t
name|siz
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|size_t
name|ucl_strlcpy_tolower
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|size_t
name|siz
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|ucl_strnstr
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|find
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|ucl_strncasestr
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|find
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_function_decl
specifier|static
specifier|inline
name|void
name|ucl_create_err
parameter_list|(
name|UT_string
modifier|*
modifier|*
name|err
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|( format
parameter_list|(
name|printf
parameter_list|,
function_decl|2
operator|,
function_decl|3
end_function_decl

begin_empty_stmt
unit|) ))
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|UCL_FATAL_ERRORS
end_undef

begin_function
specifier|static
specifier|inline
name|void
name|ucl_create_err
parameter_list|(
name|UT_string
modifier|*
modifier|*
name|err
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
if|if
condition|(
operator|*
name|err
operator|==
name|NULL
condition|)
block|{
name|utstring_new
argument_list|(
operator|*
name|err
argument_list|)
expr_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|utstring_printf_va
argument_list|(
operator|*
name|err
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|UCL_FATAL_ERRORS
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/**  * Check whether a given string contains a boolean value  * @param obj object to set  * @param start start of a string  * @param len length of a string  * @return true if a string is a boolean value  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|ucl_maybe_parse_boolean
parameter_list|(
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|start
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|start
decl_stmt|;
name|bool
name|ret
init|=
name|false
decl_stmt|,
name|val
init|=
name|false
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|5
condition|)
block|{
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'f'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'F'
operator|)
operator|&&
name|strncasecmp
argument_list|(
name|p
argument_list|,
literal|"false"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|true
expr_stmt|;
name|val
operator|=
name|false
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|len
operator|==
literal|4
condition|)
block|{
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'t'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'T'
operator|)
operator|&&
name|strncasecmp
argument_list|(
name|p
argument_list|,
literal|"true"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|true
expr_stmt|;
name|val
operator|=
name|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|len
operator|==
literal|3
condition|)
block|{
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'y'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'Y'
operator|)
operator|&&
name|strncasecmp
argument_list|(
name|p
argument_list|,
literal|"yes"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|true
expr_stmt|;
name|val
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'o'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'O'
operator|)
operator|&&
name|strncasecmp
argument_list|(
name|p
argument_list|,
literal|"off"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|true
expr_stmt|;
name|val
operator|=
name|false
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|len
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'n'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'N'
operator|)
operator|&&
name|strncasecmp
argument_list|(
name|p
argument_list|,
literal|"no"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|true
expr_stmt|;
name|val
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'o'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'O'
operator|)
operator|&&
name|strncasecmp
argument_list|(
name|p
argument_list|,
literal|"on"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|true
expr_stmt|;
name|val
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret
operator|&&
name|obj
operator|!=
name|NULL
condition|)
block|{
name|obj
operator|->
name|type
operator|=
name|UCL_BOOLEAN
expr_stmt|;
name|obj
operator|->
name|value
operator|.
name|iv
operator|=
name|val
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Check numeric string  * @param obj object to set if a string is numeric  * @param start start of string  * @param end end of string  * @param pos position where parsing has stopped  * @param allow_double allow parsing of floating point values  * @return 0 if string is numeric and error code (EINVAL or ERANGE) in case of conversion error  */
end_comment

begin_function_decl
name|int
name|ucl_maybe_parse_number
parameter_list|(
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
specifier|const
name|char
modifier|*
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|pos
parameter_list|,
name|bool
name|allow_double
parameter_list|,
name|bool
name|number_bytes
parameter_list|,
name|bool
name|allow_time
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
specifier|const
name|ucl_object_t
modifier|*
name|ucl_hash_search_obj
parameter_list|(
name|ucl_hash_t
modifier|*
name|hashlin
parameter_list|,
name|ucl_object_t
modifier|*
name|obj
parameter_list|)
block|{
return|return
operator|(
specifier|const
name|ucl_object_t
operator|*
operator|)
name|ucl_hash_search
argument_list|(
name|hashlin
argument_list|,
name|obj
operator|->
name|key
argument_list|,
name|obj
operator|->
name|keylen
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|inline
name|ucl_hash_t
modifier|*
name|ucl_hash_insert_object
argument_list|(
name|ucl_hash_t
operator|*
name|hashlin
argument_list|,
specifier|const
name|ucl_object_t
operator|*
name|obj
argument_list|,
name|bool
name|ignore_case
argument_list|)
name|UCL_WARN_UNUSED_RESULT
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|ucl_hash_t
modifier|*
name|ucl_hash_insert_object
parameter_list|(
name|ucl_hash_t
modifier|*
name|hashlin
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|bool
name|ignore_case
parameter_list|)
block|{
if|if
condition|(
name|hashlin
operator|==
name|NULL
condition|)
block|{
name|hashlin
operator|=
name|ucl_hash_create
argument_list|(
name|ignore_case
argument_list|)
expr_stmt|;
block|}
name|ucl_hash_insert
argument_list|(
name|hashlin
argument_list|,
name|obj
argument_list|,
name|obj
operator|->
name|key
argument_list|,
name|obj
operator|->
name|keylen
argument_list|)
expr_stmt|;
return|return
name|hashlin
return|;
block|}
end_function

begin_comment
comment|/**  * Get standard emitter context for a specified emit_type  * @param emit_type type of emitter  * @return context or NULL if input is invalid  */
end_comment

begin_function_decl
specifier|const
name|struct
name|ucl_emitter_context
modifier|*
name|ucl_emit_get_standard_context
parameter_list|(
name|enum
name|ucl_emitter
name|emit_type
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Serialize string as JSON string  * @param str string to emit  * @param buf target buffer  */
end_comment

begin_function_decl
name|void
name|ucl_elt_string_write_json
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|size
parameter_list|,
name|struct
name|ucl_emitter_context
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Write multiline string using `EOD` as string terminator  * @param str  * @param size  * @param ctx  */
end_comment

begin_function_decl
name|void
name|ucl_elt_string_write_multiline
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|size
parameter_list|,
name|struct
name|ucl_emitter_context
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Emit a single object to string  * @param obj  * @return  */
end_comment

begin_function_decl
name|unsigned
name|char
modifier|*
name|ucl_object_emit_single_json
parameter_list|(
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Check whether a specified string is long and should be likely printed in  * multiline mode  * @param obj  * @return  */
end_comment

begin_function_decl
name|bool
name|ucl_maybe_long_string
parameter_list|(
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Print integer to the msgpack output  * @param ctx  * @param val  */
end_comment

begin_function_decl
name|void
name|ucl_emitter_print_int_msgpack
parameter_list|(
name|struct
name|ucl_emitter_context
modifier|*
name|ctx
parameter_list|,
name|int64_t
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Print integer to the msgpack output  * @param ctx  * @param val  */
end_comment

begin_function_decl
name|void
name|ucl_emitter_print_double_msgpack
parameter_list|(
name|struct
name|ucl_emitter_context
modifier|*
name|ctx
parameter_list|,
name|double
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Print double to the msgpack output  * @param ctx  * @param val  */
end_comment

begin_function_decl
name|void
name|ucl_emitter_print_bool_msgpack
parameter_list|(
name|struct
name|ucl_emitter_context
modifier|*
name|ctx
parameter_list|,
name|bool
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Print string to the msgpack output  * @param ctx  * @param s  * @param len  */
end_comment

begin_function_decl
name|void
name|ucl_emitter_print_string_msgpack
parameter_list|(
name|struct
name|ucl_emitter_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Print binary string to the msgpack output  * @param ctx  * @param s  * @param len  */
end_comment

begin_function_decl
name|void
name|ucl_emitter_print_binary_string_msgpack
parameter_list|(
name|struct
name|ucl_emitter_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Print array preamble for msgpack  * @param ctx  * @param len  */
end_comment

begin_function_decl
name|void
name|ucl_emitter_print_array_msgpack
parameter_list|(
name|struct
name|ucl_emitter_context
modifier|*
name|ctx
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Print object preamble for msgpack  * @param ctx  * @param len  */
end_comment

begin_function_decl
name|void
name|ucl_emitter_print_object_msgpack
parameter_list|(
name|struct
name|ucl_emitter_context
modifier|*
name|ctx
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Print NULL to the msgpack output  * @param ctx  */
end_comment

begin_function_decl
name|void
name|ucl_emitter_print_null_msgpack
parameter_list|(
name|struct
name|ucl_emitter_context
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Print object's key if needed to the msgpack output  * @param print_key  * @param ctx  * @param obj  */
end_comment

begin_function_decl
name|void
name|ucl_emitter_print_key_msgpack
parameter_list|(
name|bool
name|print_key
parameter_list|,
name|struct
name|ucl_emitter_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Fetch URL into a buffer  * @param url url to fetch  * @param buf pointer to buffer (must be freed by callee)  * @param buflen pointer to buffer length  * @param err pointer to error argument  * @param must_exist fail if cannot find a url  */
end_comment

begin_function_decl
name|bool
name|ucl_fetch_url
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|url
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|buflen
parameter_list|,
name|UT_string
modifier|*
modifier|*
name|err
parameter_list|,
name|bool
name|must_exist
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Fetch a file and save results to the memory buffer  * @param filename filename to fetch  * @param len length of filename  * @param buf target buffer  * @param buflen target length  * @return  */
end_comment

begin_function_decl
name|bool
name|ucl_fetch_file
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|filename
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|buflen
parameter_list|,
name|UT_string
modifier|*
modifier|*
name|err
parameter_list|,
name|bool
name|must_exist
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Add new element to an object using the current merge strategy and priority  * @param parser  * @param nobj  * @return  */
end_comment

begin_function_decl
name|bool
name|ucl_parser_process_object_element
parameter_list|(
name|struct
name|ucl_parser
modifier|*
name|parser
parameter_list|,
name|ucl_object_t
modifier|*
name|nobj
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Parse msgpack chunk  * @param parser  * @return  */
end_comment

begin_function_decl
name|bool
name|ucl_parse_msgpack
parameter_list|(
name|struct
name|ucl_parser
modifier|*
name|parser
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|ucl_parse_csexp
parameter_list|(
name|struct
name|ucl_parser
modifier|*
name|parser
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UCL_INTERNAL_H_ */
end_comment

end_unit

