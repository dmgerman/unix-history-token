begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 2013, Vsevolod Stakhov  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *       * Redistributions of source code must retain the above copyright  *         notice, this list of conditions and the following disclaimer.  *       * Redistributions in binary form must reproduce the above copyright  *         notice, this list of conditions and the following disclaimer in the  *         documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED. IN NO EVENT SHALL AUTHOR BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ucl.h"
end_include

begin_include
include|#
directive|include
file|"ucl_internal.h"
end_include

begin_include
include|#
directive|include
file|"ucl_chartable.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FLOAT_H
end_ifdef

begin_include
include|#
directive|include
file|<float.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MATH_H
end_ifdef

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * @file ucl_emitter.c  * Serialise UCL object to various of output formats  */
end_comment

begin_function_decl
specifier|static
name|void
name|ucl_emitter_common_elt
parameter_list|(
name|struct
name|ucl_emitter_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|bool
name|first
parameter_list|,
name|bool
name|print_key
parameter_list|,
name|bool
name|compact
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|UCL_EMIT_TYPE_OPS
parameter_list|(
name|type
parameter_list|)
define|\
value|static void ucl_emit_ ## type ## _elt (struct ucl_emitter_context *ctx,	\ 		const ucl_object_t *obj, bool first, bool print_key);	\ 	static void ucl_emit_ ## type ## _start_obj (struct ucl_emitter_context *ctx,	\ 		const ucl_object_t *obj, bool print_key);	\ 	static void ucl_emit_ ## type## _start_array (struct ucl_emitter_context *ctx,	\ 		const ucl_object_t *obj, bool print_key);	\ 	static void ucl_emit_ ##type## _end_object (struct ucl_emitter_context *ctx,	\ 		const ucl_object_t *obj);	\ 	static void ucl_emit_ ##type## _end_array (struct ucl_emitter_context *ctx,	\ 		const ucl_object_t *obj)
end_define

begin_comment
comment|/*  * JSON format operations  */
end_comment

begin_expr_stmt
name|UCL_EMIT_TYPE_OPS
argument_list|(
name|json
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|UCL_EMIT_TYPE_OPS
argument_list|(
name|json_compact
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|UCL_EMIT_TYPE_OPS
argument_list|(
name|config
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|UCL_EMIT_TYPE_OPS
argument_list|(
name|yaml
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|UCL_EMIT_TYPE_OPS
argument_list|(
name|msgpack
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|UCL_EMIT_TYPE_CONTENT
parameter_list|(
name|type
parameter_list|)
value|{	\ 	.ucl_emitter_write_elt = ucl_emit_ ## type ## _elt,	\ 	.ucl_emitter_start_object = ucl_emit_ ## type ##_start_obj,	\ 	.ucl_emitter_start_array = ucl_emit_ ## type ##_start_array,	\ 	.ucl_emitter_end_object = ucl_emit_ ## type ##_end_object,	\ 	.ucl_emitter_end_array = ucl_emit_ ## type ##_end_array	\ }
end_define

begin_decl_stmt
specifier|const
name|struct
name|ucl_emitter_operations
name|ucl_standartd_emitter_ops
index|[]
init|=
block|{
index|[
name|UCL_EMIT_JSON
index|]
operator|=
name|UCL_EMIT_TYPE_CONTENT
argument_list|(
name|json
argument_list|)
block|,
index|[
name|UCL_EMIT_JSON_COMPACT
index|]
operator|=
name|UCL_EMIT_TYPE_CONTENT
argument_list|(
name|json_compact
argument_list|)
block|,
index|[
name|UCL_EMIT_CONFIG
index|]
operator|=
name|UCL_EMIT_TYPE_CONTENT
argument_list|(
name|config
argument_list|)
block|,
index|[
name|UCL_EMIT_YAML
index|]
operator|=
name|UCL_EMIT_TYPE_CONTENT
argument_list|(
name|yaml
argument_list|)
block|,
index|[
name|UCL_EMIT_MSGPACK
index|]
operator|=
name|UCL_EMIT_TYPE_CONTENT
argument_list|(
argument|msgpack
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Utility to check whether we need a top object  */
end_comment

begin_define
define|#
directive|define
name|UCL_EMIT_IDENT_TOP_OBJ
parameter_list|(
name|ctx
parameter_list|,
name|obj
parameter_list|)
value|((ctx)->top != (obj) || \ 		((ctx)->id == UCL_EMIT_JSON_COMPACT || (ctx)->id == UCL_EMIT_JSON))
end_define

begin_comment
comment|/**  * Add tabulation to the output buffer  * @param buf target buffer  * @param tabs number of tabs to add  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ucl_add_tabs
parameter_list|(
specifier|const
name|struct
name|ucl_emitter_functions
modifier|*
name|func
parameter_list|,
name|unsigned
name|int
name|tabs
parameter_list|,
name|bool
name|compact
parameter_list|)
block|{
if|if
condition|(
operator|!
name|compact
operator|&&
name|tabs
operator|>
literal|0
condition|)
block|{
name|func
operator|->
name|ucl_emitter_append_character
argument_list|(
literal|' '
argument_list|,
name|tabs
operator|*
literal|4
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Print key for the element  * @param ctx  * @param obj  */
end_comment

begin_function
specifier|static
name|void
name|ucl_emitter_print_key
parameter_list|(
name|bool
name|print_key
parameter_list|,
name|struct
name|ucl_emitter_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|bool
name|compact
parameter_list|)
block|{
specifier|const
name|struct
name|ucl_emitter_functions
modifier|*
name|func
init|=
name|ctx
operator|->
name|func
decl_stmt|;
if|if
condition|(
operator|!
name|print_key
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|ctx
operator|->
name|id
operator|==
name|UCL_EMIT_CONFIG
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|flags
operator|&
name|UCL_OBJECT_NEED_KEY_ESCAPE
condition|)
block|{
name|ucl_elt_string_write_json
argument_list|(
name|obj
operator|->
name|key
argument_list|,
name|obj
operator|->
name|keylen
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|func
operator|->
name|ucl_emitter_append_len
argument_list|(
name|obj
operator|->
name|key
argument_list|,
name|obj
operator|->
name|keylen
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|obj
operator|->
name|type
operator|!=
name|UCL_OBJECT
operator|&&
name|obj
operator|->
name|type
operator|!=
name|UCL_ARRAY
condition|)
block|{
name|func
operator|->
name|ucl_emitter_append_len
argument_list|(
literal|" = "
argument_list|,
literal|3
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|func
operator|->
name|ucl_emitter_append_character
argument_list|(
literal|' '
argument_list|,
literal|1
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ctx
operator|->
name|id
operator|==
name|UCL_EMIT_YAML
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|keylen
operator|>
literal|0
operator|&&
operator|(
name|obj
operator|->
name|flags
operator|&
name|UCL_OBJECT_NEED_KEY_ESCAPE
operator|)
condition|)
block|{
name|ucl_elt_string_write_json
argument_list|(
name|obj
operator|->
name|key
argument_list|,
name|obj
operator|->
name|keylen
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|->
name|keylen
operator|>
literal|0
condition|)
block|{
name|func
operator|->
name|ucl_emitter_append_len
argument_list|(
name|obj
operator|->
name|key
argument_list|,
name|obj
operator|->
name|keylen
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|func
operator|->
name|ucl_emitter_append_len
argument_list|(
literal|"null"
argument_list|,
literal|4
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
block|}
name|func
operator|->
name|ucl_emitter_append_len
argument_list|(
literal|": "
argument_list|,
literal|2
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|obj
operator|->
name|keylen
operator|>
literal|0
condition|)
block|{
name|ucl_elt_string_write_json
argument_list|(
name|obj
operator|->
name|key
argument_list|,
name|obj
operator|->
name|keylen
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|func
operator|->
name|ucl_emitter_append_len
argument_list|(
literal|"null"
argument_list|,
literal|4
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|compact
condition|)
block|{
name|func
operator|->
name|ucl_emitter_append_character
argument_list|(
literal|':'
argument_list|,
literal|1
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|func
operator|->
name|ucl_emitter_append_len
argument_list|(
literal|": "
argument_list|,
literal|2
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ucl_emitter_finish_object
parameter_list|(
name|struct
name|ucl_emitter_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|bool
name|compact
parameter_list|,
name|bool
name|is_array
parameter_list|)
block|{
specifier|const
name|struct
name|ucl_emitter_functions
modifier|*
name|func
init|=
name|ctx
operator|->
name|func
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|id
operator|==
name|UCL_EMIT_CONFIG
operator|&&
name|obj
operator|!=
name|ctx
operator|->
name|top
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|type
operator|!=
name|UCL_OBJECT
operator|&&
name|obj
operator|->
name|type
operator|!=
name|UCL_ARRAY
condition|)
block|{
if|if
condition|(
operator|!
name|is_array
condition|)
block|{
comment|/* Objects are split by ';' */
name|func
operator|->
name|ucl_emitter_append_len
argument_list|(
literal|";\n"
argument_list|,
literal|2
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Use commas for arrays */
name|func
operator|->
name|ucl_emitter_append_len
argument_list|(
literal|",\n"
argument_list|,
literal|2
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|func
operator|->
name|ucl_emitter_append_character
argument_list|(
literal|'\n'
argument_list|,
literal|1
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * End standard ucl object  * @param ctx emitter context  * @param compact compact flag  */
end_comment

begin_function
specifier|static
name|void
name|ucl_emitter_common_end_object
parameter_list|(
name|struct
name|ucl_emitter_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|bool
name|compact
parameter_list|)
block|{
specifier|const
name|struct
name|ucl_emitter_functions
modifier|*
name|func
init|=
name|ctx
operator|->
name|func
decl_stmt|;
if|if
condition|(
name|UCL_EMIT_IDENT_TOP_OBJ
argument_list|(
name|ctx
argument_list|,
name|obj
argument_list|)
condition|)
block|{
name|ctx
operator|->
name|indent
operator|--
expr_stmt|;
if|if
condition|(
name|compact
condition|)
block|{
name|func
operator|->
name|ucl_emitter_append_character
argument_list|(
literal|'}'
argument_list|,
literal|1
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ctx
operator|->
name|id
operator|!=
name|UCL_EMIT_CONFIG
condition|)
block|{
comment|/* newline is already added for this format */
name|func
operator|->
name|ucl_emitter_append_character
argument_list|(
literal|'\n'
argument_list|,
literal|1
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
block|}
name|ucl_add_tabs
argument_list|(
name|func
argument_list|,
name|ctx
operator|->
name|indent
argument_list|,
name|compact
argument_list|)
expr_stmt|;
name|func
operator|->
name|ucl_emitter_append_character
argument_list|(
literal|'}'
argument_list|,
literal|1
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
block|}
block|}
name|ucl_emitter_finish_object
argument_list|(
name|ctx
argument_list|,
name|obj
argument_list|,
name|compact
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * End standard ucl array  * @param ctx emitter context  * @param compact compact flag  */
end_comment

begin_function
specifier|static
name|void
name|ucl_emitter_common_end_array
parameter_list|(
name|struct
name|ucl_emitter_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|bool
name|compact
parameter_list|)
block|{
specifier|const
name|struct
name|ucl_emitter_functions
modifier|*
name|func
init|=
name|ctx
operator|->
name|func
decl_stmt|;
name|ctx
operator|->
name|indent
operator|--
expr_stmt|;
if|if
condition|(
name|compact
condition|)
block|{
name|func
operator|->
name|ucl_emitter_append_character
argument_list|(
literal|']'
argument_list|,
literal|1
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ctx
operator|->
name|id
operator|!=
name|UCL_EMIT_CONFIG
condition|)
block|{
comment|/* newline is already added for this format */
name|func
operator|->
name|ucl_emitter_append_character
argument_list|(
literal|'\n'
argument_list|,
literal|1
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
block|}
name|ucl_add_tabs
argument_list|(
name|func
argument_list|,
name|ctx
operator|->
name|indent
argument_list|,
name|compact
argument_list|)
expr_stmt|;
name|func
operator|->
name|ucl_emitter_append_character
argument_list|(
literal|']'
argument_list|,
literal|1
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
block|}
name|ucl_emitter_finish_object
argument_list|(
name|ctx
argument_list|,
name|obj
argument_list|,
name|compact
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Start emit standard UCL array  * @param ctx emitter context  * @param obj object to write  * @param compact compact flag  */
end_comment

begin_function
specifier|static
name|void
name|ucl_emitter_common_start_array
parameter_list|(
name|struct
name|ucl_emitter_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|bool
name|print_key
parameter_list|,
name|bool
name|compact
parameter_list|)
block|{
specifier|const
name|ucl_object_t
modifier|*
name|cur
decl_stmt|;
name|ucl_object_iter_t
name|iter
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|ucl_emitter_functions
modifier|*
name|func
init|=
name|ctx
operator|->
name|func
decl_stmt|;
name|bool
name|first
init|=
name|true
decl_stmt|;
name|ucl_emitter_print_key
argument_list|(
name|print_key
argument_list|,
name|ctx
argument_list|,
name|obj
argument_list|,
name|compact
argument_list|)
expr_stmt|;
if|if
condition|(
name|compact
condition|)
block|{
name|func
operator|->
name|ucl_emitter_append_character
argument_list|(
literal|'['
argument_list|,
literal|1
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|func
operator|->
name|ucl_emitter_append_len
argument_list|(
literal|"[\n"
argument_list|,
literal|2
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
block|}
name|ctx
operator|->
name|indent
operator|++
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|type
operator|==
name|UCL_ARRAY
condition|)
block|{
comment|/* explicit array */
while|while
condition|(
operator|(
name|cur
operator|=
name|ucl_iterate_object
argument_list|(
name|obj
argument_list|,
operator|&
name|iter
argument_list|,
name|true
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ucl_emitter_common_elt
argument_list|(
name|ctx
argument_list|,
name|cur
argument_list|,
name|first
argument_list|,
name|false
argument_list|,
name|compact
argument_list|)
expr_stmt|;
name|first
operator|=
name|false
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* implicit array */
name|cur
operator|=
name|obj
expr_stmt|;
while|while
condition|(
name|cur
condition|)
block|{
name|ucl_emitter_common_elt
argument_list|(
name|ctx
argument_list|,
name|cur
argument_list|,
name|first
argument_list|,
name|false
argument_list|,
name|compact
argument_list|)
expr_stmt|;
name|first
operator|=
name|false
expr_stmt|;
name|cur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * Start emit standard UCL object  * @param ctx emitter context  * @param obj object to write  * @param compact compact flag  */
end_comment

begin_function
specifier|static
name|void
name|ucl_emitter_common_start_object
parameter_list|(
name|struct
name|ucl_emitter_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|bool
name|print_key
parameter_list|,
name|bool
name|compact
parameter_list|)
block|{
name|ucl_hash_iter_t
name|it
init|=
name|NULL
decl_stmt|;
specifier|const
name|ucl_object_t
modifier|*
name|cur
decl_stmt|,
modifier|*
name|elt
decl_stmt|;
specifier|const
name|struct
name|ucl_emitter_functions
modifier|*
name|func
init|=
name|ctx
operator|->
name|func
decl_stmt|;
name|bool
name|first
init|=
name|true
decl_stmt|;
name|ucl_emitter_print_key
argument_list|(
name|print_key
argument_list|,
name|ctx
argument_list|,
name|obj
argument_list|,
name|compact
argument_list|)
expr_stmt|;
comment|/* 	 * Print<ident_level>{ 	 *<ident_level + 1><object content> 	 */
if|if
condition|(
name|UCL_EMIT_IDENT_TOP_OBJ
argument_list|(
name|ctx
argument_list|,
name|obj
argument_list|)
condition|)
block|{
if|if
condition|(
name|compact
condition|)
block|{
name|func
operator|->
name|ucl_emitter_append_character
argument_list|(
literal|'{'
argument_list|,
literal|1
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|func
operator|->
name|ucl_emitter_append_len
argument_list|(
literal|"{\n"
argument_list|,
literal|2
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
block|}
name|ctx
operator|->
name|indent
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|cur
operator|=
name|ucl_hash_iterate
argument_list|(
name|obj
operator|->
name|value
operator|.
name|ov
argument_list|,
operator|&
name|it
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|id
operator|==
name|UCL_EMIT_CONFIG
condition|)
block|{
name|LL_FOREACH
argument_list|(
argument|cur
argument_list|,
argument|elt
argument_list|)
block|{
name|ucl_emitter_common_elt
argument_list|(
name|ctx
argument_list|,
name|elt
argument_list|,
name|first
argument_list|,
name|true
argument_list|,
name|compact
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Expand implicit arrays */
if|if
condition|(
name|cur
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
block|{
if|if
condition|(
name|compact
condition|)
block|{
name|func
operator|->
name|ucl_emitter_append_character
argument_list|(
literal|','
argument_list|,
literal|1
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|func
operator|->
name|ucl_emitter_append_len
argument_list|(
literal|",\n"
argument_list|,
literal|2
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
block|}
block|}
name|ucl_add_tabs
argument_list|(
name|func
argument_list|,
name|ctx
operator|->
name|indent
argument_list|,
name|compact
argument_list|)
expr_stmt|;
name|ucl_emitter_common_start_array
argument_list|(
name|ctx
argument_list|,
name|cur
argument_list|,
name|true
argument_list|,
name|compact
argument_list|)
expr_stmt|;
name|ucl_emitter_common_end_array
argument_list|(
name|ctx
argument_list|,
name|cur
argument_list|,
name|compact
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ucl_emitter_common_elt
argument_list|(
name|ctx
argument_list|,
name|cur
argument_list|,
name|first
argument_list|,
name|true
argument_list|,
name|compact
argument_list|)
expr_stmt|;
block|}
block|}
name|first
operator|=
name|false
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Common choice of object emitting  * @param ctx emitter context  * @param obj object to print  * @param first flag to mark the first element  * @param print_key print key of an object  * @param compact compact output  */
end_comment

begin_function
specifier|static
name|void
name|ucl_emitter_common_elt
parameter_list|(
name|struct
name|ucl_emitter_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|bool
name|first
parameter_list|,
name|bool
name|print_key
parameter_list|,
name|bool
name|compact
parameter_list|)
block|{
specifier|const
name|struct
name|ucl_emitter_functions
modifier|*
name|func
init|=
name|ctx
operator|->
name|func
decl_stmt|;
name|bool
name|flag
decl_stmt|;
name|struct
name|ucl_object_userdata
modifier|*
name|ud
decl_stmt|;
specifier|const
name|char
modifier|*
name|ud_out
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|id
operator|!=
name|UCL_EMIT_CONFIG
operator|&&
operator|!
name|first
condition|)
block|{
if|if
condition|(
name|compact
condition|)
block|{
name|func
operator|->
name|ucl_emitter_append_character
argument_list|(
literal|','
argument_list|,
literal|1
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ctx
operator|->
name|id
operator|==
name|UCL_EMIT_YAML
operator|&&
name|ctx
operator|->
name|indent
operator|==
literal|0
condition|)
block|{
name|func
operator|->
name|ucl_emitter_append_len
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|func
operator|->
name|ucl_emitter_append_len
argument_list|(
literal|",\n"
argument_list|,
literal|2
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|ucl_add_tabs
argument_list|(
name|func
argument_list|,
name|ctx
operator|->
name|indent
argument_list|,
name|compact
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|obj
operator|->
name|type
condition|)
block|{
case|case
name|UCL_INT
case|:
name|ucl_emitter_print_key
argument_list|(
name|print_key
argument_list|,
name|ctx
argument_list|,
name|obj
argument_list|,
name|compact
argument_list|)
expr_stmt|;
name|func
operator|->
name|ucl_emitter_append_int
argument_list|(
name|ucl_object_toint
argument_list|(
name|obj
argument_list|)
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
name|ucl_emitter_finish_object
argument_list|(
name|ctx
argument_list|,
name|obj
argument_list|,
name|compact
argument_list|,
operator|!
name|print_key
argument_list|)
expr_stmt|;
break|break;
case|case
name|UCL_FLOAT
case|:
case|case
name|UCL_TIME
case|:
name|ucl_emitter_print_key
argument_list|(
name|print_key
argument_list|,
name|ctx
argument_list|,
name|obj
argument_list|,
name|compact
argument_list|)
expr_stmt|;
name|func
operator|->
name|ucl_emitter_append_double
argument_list|(
name|ucl_object_todouble
argument_list|(
name|obj
argument_list|)
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
name|ucl_emitter_finish_object
argument_list|(
name|ctx
argument_list|,
name|obj
argument_list|,
name|compact
argument_list|,
operator|!
name|print_key
argument_list|)
expr_stmt|;
break|break;
case|case
name|UCL_BOOLEAN
case|:
name|ucl_emitter_print_key
argument_list|(
name|print_key
argument_list|,
name|ctx
argument_list|,
name|obj
argument_list|,
name|compact
argument_list|)
expr_stmt|;
name|flag
operator|=
name|ucl_object_toboolean
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
name|func
operator|->
name|ucl_emitter_append_len
argument_list|(
literal|"true"
argument_list|,
literal|4
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|func
operator|->
name|ucl_emitter_append_len
argument_list|(
literal|"false"
argument_list|,
literal|5
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
block|}
name|ucl_emitter_finish_object
argument_list|(
name|ctx
argument_list|,
name|obj
argument_list|,
name|compact
argument_list|,
operator|!
name|print_key
argument_list|)
expr_stmt|;
break|break;
case|case
name|UCL_STRING
case|:
name|ucl_emitter_print_key
argument_list|(
name|print_key
argument_list|,
name|ctx
argument_list|,
name|obj
argument_list|,
name|compact
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|id
operator|==
name|UCL_EMIT_CONFIG
operator|&&
name|ucl_maybe_long_string
argument_list|(
name|obj
argument_list|)
condition|)
block|{
name|ucl_elt_string_write_multiline
argument_list|(
name|obj
operator|->
name|value
operator|.
name|sv
argument_list|,
name|obj
operator|->
name|len
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ucl_elt_string_write_json
argument_list|(
name|obj
operator|->
name|value
operator|.
name|sv
argument_list|,
name|obj
operator|->
name|len
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
name|ucl_emitter_finish_object
argument_list|(
name|ctx
argument_list|,
name|obj
argument_list|,
name|compact
argument_list|,
operator|!
name|print_key
argument_list|)
expr_stmt|;
break|break;
case|case
name|UCL_NULL
case|:
name|ucl_emitter_print_key
argument_list|(
name|print_key
argument_list|,
name|ctx
argument_list|,
name|obj
argument_list|,
name|compact
argument_list|)
expr_stmt|;
name|func
operator|->
name|ucl_emitter_append_len
argument_list|(
literal|"null"
argument_list|,
literal|4
argument_list|,
name|func
operator|->
name|ud
argument_list|)
expr_stmt|;
name|ucl_emitter_finish_object
argument_list|(
name|ctx
argument_list|,
name|obj
argument_list|,
name|compact
argument_list|,
operator|!
name|print_key
argument_list|)
expr_stmt|;
break|break;
case|case
name|UCL_OBJECT
case|:
name|ucl_emitter_common_start_object
argument_list|(
name|ctx
argument_list|,
name|obj
argument_list|,
name|print_key
argument_list|,
name|compact
argument_list|)
expr_stmt|;
name|ucl_emitter_common_end_object
argument_list|(
name|ctx
argument_list|,
name|obj
argument_list|,
name|compact
argument_list|)
expr_stmt|;
break|break;
case|case
name|UCL_ARRAY
case|:
name|ucl_emitter_common_start_array
argument_list|(
name|ctx
argument_list|,
name|obj
argument_list|,
name|print_key
argument_list|,
name|compact
argument_list|)
expr_stmt|;
name|ucl_emitter_common_end_array
argument_list|(
name|ctx
argument_list|,
name|obj
argument_list|,
name|compact
argument_list|)
expr_stmt|;
break|break;
case|case
name|UCL_USERDATA
case|:
name|ud
operator|=
operator|(
expr|struct
name|ucl_object_userdata
operator|*
operator|)
name|obj
expr_stmt|;
name|ucl_emitter_print_key
argument_list|(
name|print_key
argument_list|,
name|ctx
argument_list|,
name|obj
argument_list|,
name|compact
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud
operator|->
name|emitter
condition|)
block|{
name|ud_out
operator|=
name|ud
operator|->
name|emitter
argument_list|(
name|obj
operator|->
name|value
operator|.
name|ud
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud_out
operator|==
name|NULL
condition|)
block|{
name|ud_out
operator|=
literal|"null"
expr_stmt|;
block|}
block|}
name|ucl_elt_string_write_json
argument_list|(
name|ud_out
argument_list|,
name|strlen
argument_list|(
name|ud_out
argument_list|)
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|ucl_emitter_finish_object
argument_list|(
name|ctx
argument_list|,
name|obj
argument_list|,
name|compact
argument_list|,
operator|!
name|print_key
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Specific standard implementations of the emitter functions  */
end_comment

begin_define
define|#
directive|define
name|UCL_EMIT_TYPE_IMPL
parameter_list|(
name|type
parameter_list|,
name|compact
parameter_list|)
define|\
value|static void ucl_emit_ ## type ## _elt (struct ucl_emitter_context *ctx,	\ 		const ucl_object_t *obj, bool first, bool print_key) {	\ 		ucl_emitter_common_elt (ctx, obj, first, print_key, (compact));	\ 	}	\ 	static void ucl_emit_ ## type ## _start_obj (struct ucl_emitter_context *ctx,	\ 		const ucl_object_t *obj, bool print_key) {	\ 		ucl_emitter_common_start_object (ctx, obj, print_key, (compact));	\ 	}	\ 	static void ucl_emit_ ## type## _start_array (struct ucl_emitter_context *ctx,	\ 		const ucl_object_t *obj, bool print_key) {	\ 		ucl_emitter_common_start_array (ctx, obj, print_key, (compact));	\ 	}	\ 	static void ucl_emit_ ##type## _end_object (struct ucl_emitter_context *ctx,	\ 		const ucl_object_t *obj) {	\ 		ucl_emitter_common_end_object (ctx, obj, (compact));	\ 	}	\ 	static void ucl_emit_ ##type## _end_array (struct ucl_emitter_context *ctx,	\ 		const ucl_object_t *obj) {	\ 		ucl_emitter_common_end_array (ctx, obj, (compact));	\ 	}
end_define

begin_macro
name|UCL_EMIT_TYPE_IMPL
argument_list|(
argument|json
argument_list|,
argument|false
argument_list|)
end_macro

begin_macro
name|UCL_EMIT_TYPE_IMPL
argument_list|(
argument|json_compact
argument_list|,
argument|true
argument_list|)
end_macro

begin_macro
name|UCL_EMIT_TYPE_IMPL
argument_list|(
argument|config
argument_list|,
argument|false
argument_list|)
end_macro

begin_macro
name|UCL_EMIT_TYPE_IMPL
argument_list|(
argument|yaml
argument_list|,
argument|false
argument_list|)
end_macro

begin_function
specifier|static
name|void
name|ucl_emit_msgpack_elt
parameter_list|(
name|struct
name|ucl_emitter_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|bool
name|first
parameter_list|,
name|bool
name|print_key
parameter_list|)
block|{
name|ucl_object_iter_t
name|it
decl_stmt|;
name|struct
name|ucl_object_userdata
modifier|*
name|ud
decl_stmt|;
specifier|const
name|char
modifier|*
name|ud_out
decl_stmt|;
specifier|const
name|ucl_object_t
modifier|*
name|cur
decl_stmt|,
modifier|*
name|celt
decl_stmt|;
switch|switch
condition|(
name|obj
operator|->
name|type
condition|)
block|{
case|case
name|UCL_INT
case|:
name|ucl_emitter_print_key_msgpack
argument_list|(
name|print_key
argument_list|,
name|ctx
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|ucl_emitter_print_int_msgpack
argument_list|(
name|ctx
argument_list|,
name|ucl_object_toint
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|UCL_FLOAT
case|:
case|case
name|UCL_TIME
case|:
name|ucl_emitter_print_key_msgpack
argument_list|(
name|print_key
argument_list|,
name|ctx
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|ucl_emitter_print_double_msgpack
argument_list|(
name|ctx
argument_list|,
name|ucl_object_todouble
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|UCL_BOOLEAN
case|:
name|ucl_emitter_print_key_msgpack
argument_list|(
name|print_key
argument_list|,
name|ctx
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|ucl_emitter_print_bool_msgpack
argument_list|(
name|ctx
argument_list|,
name|ucl_object_toboolean
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|UCL_STRING
case|:
name|ucl_emitter_print_key_msgpack
argument_list|(
name|print_key
argument_list|,
name|ctx
argument_list|,
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|flags
operator|&
name|UCL_OBJECT_BINARY
condition|)
block|{
name|ucl_emitter_print_binary_string_msgpack
argument_list|(
name|ctx
argument_list|,
name|obj
operator|->
name|value
operator|.
name|sv
argument_list|,
name|obj
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ucl_emitter_print_string_msgpack
argument_list|(
name|ctx
argument_list|,
name|obj
operator|->
name|value
operator|.
name|sv
argument_list|,
name|obj
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UCL_NULL
case|:
name|ucl_emitter_print_key_msgpack
argument_list|(
name|print_key
argument_list|,
name|ctx
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|ucl_emitter_print_null_msgpack
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
break|break;
case|case
name|UCL_OBJECT
case|:
name|ucl_emitter_print_key_msgpack
argument_list|(
name|print_key
argument_list|,
name|ctx
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|ucl_emit_msgpack_start_obj
argument_list|(
name|ctx
argument_list|,
name|obj
argument_list|,
name|print_key
argument_list|)
expr_stmt|;
name|it
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|cur
operator|=
name|ucl_iterate_object
argument_list|(
name|obj
argument_list|,
operator|&
name|it
argument_list|,
name|true
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LL_FOREACH
argument_list|(
argument|cur
argument_list|,
argument|celt
argument_list|)
block|{
name|ucl_emit_msgpack_elt
argument_list|(
name|ctx
argument_list|,
name|celt
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* XXX: 				 * in msgpack the length of objects is encoded within a single elt 				 * so in case of multi-value keys we are using merely the first 				 * element ignoring others 				 */
break|break;
block|}
block|}
break|break;
case|case
name|UCL_ARRAY
case|:
name|ucl_emitter_print_key_msgpack
argument_list|(
name|print_key
argument_list|,
name|ctx
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|ucl_emit_msgpack_start_array
argument_list|(
name|ctx
argument_list|,
name|obj
argument_list|,
name|print_key
argument_list|)
expr_stmt|;
name|it
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|cur
operator|=
name|ucl_iterate_object
argument_list|(
name|obj
argument_list|,
operator|&
name|it
argument_list|,
name|true
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ucl_emit_msgpack_elt
argument_list|(
name|ctx
argument_list|,
name|cur
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UCL_USERDATA
case|:
name|ud
operator|=
operator|(
expr|struct
name|ucl_object_userdata
operator|*
operator|)
name|obj
expr_stmt|;
name|ucl_emitter_print_key_msgpack
argument_list|(
name|print_key
argument_list|,
name|ctx
argument_list|,
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud
operator|->
name|emitter
condition|)
block|{
name|ud_out
operator|=
name|ud
operator|->
name|emitter
argument_list|(
name|obj
operator|->
name|value
operator|.
name|ud
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud_out
operator|==
name|NULL
condition|)
block|{
name|ud_out
operator|=
literal|"null"
expr_stmt|;
block|}
block|}
name|ucl_emitter_print_string_msgpack
argument_list|(
name|ctx
argument_list|,
name|obj
operator|->
name|value
operator|.
name|sv
argument_list|,
name|obj
operator|->
name|len
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ucl_emit_msgpack_start_obj
parameter_list|(
name|struct
name|ucl_emitter_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|bool
name|print_key
parameter_list|)
block|{
name|ucl_emitter_print_object_msgpack
argument_list|(
name|ctx
argument_list|,
name|obj
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ucl_emit_msgpack_start_array
parameter_list|(
name|struct
name|ucl_emitter_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|bool
name|print_key
parameter_list|)
block|{
name|ucl_emitter_print_array_msgpack
argument_list|(
name|ctx
argument_list|,
name|obj
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ucl_emit_msgpack_end_object
parameter_list|(
name|struct
name|ucl_emitter_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|)
block|{  }
end_function

begin_function
specifier|static
name|void
name|ucl_emit_msgpack_end_array
parameter_list|(
name|struct
name|ucl_emitter_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|)
block|{  }
end_function

begin_function
name|unsigned
name|char
modifier|*
name|ucl_object_emit
parameter_list|(
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|enum
name|ucl_emitter
name|emit_type
parameter_list|)
block|{
return|return
name|ucl_object_emit_len
argument_list|(
name|obj
argument_list|,
name|emit_type
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|unsigned
name|char
modifier|*
name|ucl_object_emit_len
parameter_list|(
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|enum
name|ucl_emitter
name|emit_type
parameter_list|,
name|size_t
modifier|*
name|outlen
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|struct
name|ucl_emitter_functions
modifier|*
name|func
decl_stmt|;
name|UT_string
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|func
operator|=
name|ucl_object_emit_memory_funcs
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|res
argument_list|)
expr_stmt|;
name|s
operator|=
name|func
operator|->
name|ud
expr_stmt|;
if|if
condition|(
name|func
operator|!=
name|NULL
condition|)
block|{
name|ucl_object_emit_full
argument_list|(
name|obj
argument_list|,
name|emit_type
argument_list|,
name|func
argument_list|)
expr_stmt|;
if|if
condition|(
name|outlen
operator|!=
name|NULL
condition|)
block|{
operator|*
name|outlen
operator|=
name|s
operator|->
name|i
expr_stmt|;
block|}
name|ucl_object_emit_funcs_free
argument_list|(
name|func
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_function
name|bool
name|ucl_object_emit_full
parameter_list|(
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|enum
name|ucl_emitter
name|emit_type
parameter_list|,
name|struct
name|ucl_emitter_functions
modifier|*
name|emitter
parameter_list|)
block|{
specifier|const
name|struct
name|ucl_emitter_context
modifier|*
name|ctx
decl_stmt|;
name|struct
name|ucl_emitter_context
name|my_ctx
decl_stmt|;
name|bool
name|res
init|=
name|false
decl_stmt|;
name|ctx
operator|=
name|ucl_emit_get_standard_context
argument_list|(
name|emit_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|my_ctx
argument_list|,
name|ctx
argument_list|,
sizeof|sizeof
argument_list|(
name|my_ctx
argument_list|)
argument_list|)
expr_stmt|;
name|my_ctx
operator|.
name|func
operator|=
name|emitter
expr_stmt|;
name|my_ctx
operator|.
name|indent
operator|=
literal|0
expr_stmt|;
name|my_ctx
operator|.
name|top
operator|=
name|obj
expr_stmt|;
name|my_ctx
operator|.
name|ops
operator|->
name|ucl_emitter_write_elt
argument_list|(
operator|&
name|my_ctx
argument_list|,
name|obj
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|res
operator|=
name|true
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

end_unit

