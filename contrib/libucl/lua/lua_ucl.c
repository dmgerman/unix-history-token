begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 2014, Vsevolod Stakhov  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *       * Redistributions of source code must retain the above copyright  *         notice, this list of conditions and the following disclaimer.  *       * Redistributions in binary form must reproduce the above copyright  *         notice, this list of conditions and the following disclaimer in the  *         documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED. IN NO EVENT SHALL AUTHOR BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * @file lua ucl bindings  */
end_comment

begin_include
include|#
directive|include
file|"ucl.h"
end_include

begin_include
include|#
directive|include
file|"ucl_internal.h"
end_include

begin_include
include|#
directive|include
file|"lua_ucl.h"
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_comment
comment|/***  * @module ucl  * This lua module allows to parse objects from strings and to store data into  * ucl objects. It uses `libucl` C library to parse and manipulate with ucl objects.  * @example local ucl = require("ucl")  local parser = ucl.parser() local res,err = parser:parse_string('{key=value}')  if not res then 	print('parser error: ' .. err) else 	local obj = parser:get_object() 	local got = ucl.to_format(obj, 'json') endif  local table = {   str = 'value',   num = 100500,   null = ucl.null,   func = function ()     return 'huh'   end }  print(ucl.to_format(table, 'ucl')) -- Output: --[[ num = 100500; str = "value"; null = null; func = "huh"; --]]  */
end_comment

begin_define
define|#
directive|define
name|PARSER_META
value|"ucl.parser.meta"
end_define

begin_define
define|#
directive|define
name|EMITTER_META
value|"ucl.emitter.meta"
end_define

begin_define
define|#
directive|define
name|NULL_META
value|"null.emitter.meta"
end_define

begin_function_decl
specifier|static
name|int
name|ucl_object_lua_push_array
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ucl_object_lua_push_scalar
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|bool
name|allow_array
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ucl_object_t
modifier|*
name|ucl_object_lua_fromtable
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|idx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ucl_object_t
modifier|*
name|ucl_object_lua_fromelt
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|idx
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
modifier|*
name|ucl_null
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Push a single element of an object to lua  * @param L  * @param key  * @param obj  */
end_comment

begin_function
specifier|static
name|void
name|ucl_object_lua_push_element
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|)
block|{
name|lua_pushstring
argument_list|(
name|L
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|ucl_object_push_lua
argument_list|(
name|L
argument_list|,
name|obj
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|lua_settable
argument_list|(
name|L
argument_list|,
operator|-
literal|3
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lua_ucl_userdata_dtor
parameter_list|(
name|void
modifier|*
name|ud
parameter_list|)
block|{
name|struct
name|ucl_lua_funcdata
modifier|*
name|fd
init|=
operator|(
expr|struct
name|ucl_lua_funcdata
operator|*
operator|)
name|ud
decl_stmt|;
name|luaL_unref
argument_list|(
name|fd
operator|->
name|L
argument_list|,
name|LUA_REGISTRYINDEX
argument_list|,
name|fd
operator|->
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|->
name|ret
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|fd
operator|->
name|ret
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|lua_ucl_userdata_emitter
parameter_list|(
name|void
modifier|*
name|ud
parameter_list|)
block|{
name|struct
name|ucl_lua_funcdata
modifier|*
name|fd
init|=
operator|(
expr|struct
name|ucl_lua_funcdata
operator|*
operator|)
name|ud
decl_stmt|;
specifier|const
name|char
modifier|*
name|out
init|=
literal|""
decl_stmt|;
name|lua_rawgeti
argument_list|(
name|fd
operator|->
name|L
argument_list|,
name|LUA_REGISTRYINDEX
argument_list|,
name|fd
operator|->
name|idx
argument_list|)
expr_stmt|;
name|lua_pcall
argument_list|(
name|fd
operator|->
name|L
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
operator|=
name|lua_tostring
argument_list|(
name|fd
operator|->
name|L
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|!=
name|NULL
condition|)
block|{
comment|/* We need to store temporary string in a more appropriate place */
if|if
condition|(
name|fd
operator|->
name|ret
condition|)
block|{
name|free
argument_list|(
name|fd
operator|->
name|ret
argument_list|)
expr_stmt|;
block|}
name|fd
operator|->
name|ret
operator|=
name|strdup
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
name|lua_settop
argument_list|(
name|fd
operator|->
name|L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fd
operator|->
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Push a single object to lua  * @param L  * @param obj  * @return  */
end_comment

begin_function
specifier|static
name|int
name|ucl_object_lua_push_object
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|bool
name|allow_array
parameter_list|)
block|{
specifier|const
name|ucl_object_t
modifier|*
name|cur
decl_stmt|;
name|ucl_object_iter_t
name|it
init|=
name|NULL
decl_stmt|;
name|int
name|nelt
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|allow_array
operator|&&
name|obj
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
comment|/* Actually we need to push this as an array */
return|return
name|ucl_object_lua_push_array
argument_list|(
name|L
argument_list|,
name|obj
argument_list|)
return|;
block|}
comment|/* Optimize allocation by preallocation of table */
while|while
condition|(
name|ucl_iterate_object
argument_list|(
name|obj
argument_list|,
operator|&
name|it
argument_list|,
name|true
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|nelt
operator|++
expr_stmt|;
block|}
name|lua_createtable
argument_list|(
name|L
argument_list|,
literal|0
argument_list|,
name|nelt
argument_list|)
expr_stmt|;
name|it
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|cur
operator|=
name|ucl_iterate_object
argument_list|(
name|obj
argument_list|,
operator|&
name|it
argument_list|,
name|true
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ucl_object_lua_push_element
argument_list|(
name|L
argument_list|,
name|ucl_object_key
argument_list|(
name|cur
argument_list|)
argument_list|,
name|cur
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Push an array to lua as table indexed by integers  * @param L  * @param obj  * @return  */
end_comment

begin_function
specifier|static
name|int
name|ucl_object_lua_push_array
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|)
block|{
specifier|const
name|ucl_object_t
modifier|*
name|cur
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|,
name|nelt
init|=
literal|0
decl_stmt|;
comment|/* Optimize allocation by preallocation of table */
name|LL_FOREACH
argument_list|(
argument|obj
argument_list|,
argument|cur
argument_list|)
block|{
name|nelt
operator|++
expr_stmt|;
block|}
name|lua_createtable
argument_list|(
name|L
argument_list|,
name|nelt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LL_FOREACH
argument_list|(
argument|obj
argument_list|,
argument|cur
argument_list|)
block|{
name|ucl_object_push_lua
argument_list|(
name|L
argument_list|,
name|cur
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|lua_rawseti
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Push a simple object to lua depending on its actual type  */
end_comment

begin_function
specifier|static
name|int
name|ucl_object_lua_push_scalar
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|bool
name|allow_array
parameter_list|)
block|{
name|struct
name|ucl_lua_funcdata
modifier|*
name|fd
decl_stmt|;
if|if
condition|(
name|allow_array
operator|&&
name|obj
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
comment|/* Actually we need to push this as an array */
return|return
name|ucl_object_lua_push_array
argument_list|(
name|L
argument_list|,
name|obj
argument_list|)
return|;
block|}
switch|switch
condition|(
name|obj
operator|->
name|type
condition|)
block|{
case|case
name|UCL_BOOLEAN
case|:
name|lua_pushboolean
argument_list|(
name|L
argument_list|,
name|ucl_obj_toboolean
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|UCL_STRING
case|:
name|lua_pushstring
argument_list|(
name|L
argument_list|,
name|ucl_obj_tostring
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|UCL_INT
case|:
if|#
directive|if
name|LUA_VERSION_NUM
operator|>=
literal|501
name|lua_pushinteger
argument_list|(
name|L
argument_list|,
name|ucl_obj_toint
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|lua_pushnumber
argument_list|(
name|L
argument_list|,
name|ucl_obj_toint
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|UCL_FLOAT
case|:
case|case
name|UCL_TIME
case|:
name|lua_pushnumber
argument_list|(
name|L
argument_list|,
name|ucl_obj_todouble
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|UCL_NULL
case|:
name|lua_getfield
argument_list|(
name|L
argument_list|,
name|LUA_REGISTRYINDEX
argument_list|,
literal|"ucl.null"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UCL_USERDATA
case|:
name|fd
operator|=
operator|(
expr|struct
name|ucl_lua_funcdata
operator|*
operator|)
name|obj
operator|->
name|value
operator|.
name|ud
expr_stmt|;
name|lua_rawgeti
argument_list|(
name|L
argument_list|,
name|LUA_REGISTRYINDEX
argument_list|,
name|fd
operator|->
name|idx
argument_list|)
expr_stmt|;
break|break;
default|default:
name|lua_pushnil
argument_list|(
name|L
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/***  * @function ucl_object_push_lua(L, obj, allow_array)  * This is a `C` function to push `UCL` object as lua variable. This function  * converts `obj` to lua representation using the following conversions:  *  * - *scalar* values are directly presented by lua objects  * - *userdata* values are converted to lua function objects using `LUA_REGISTRYINDEX`,  * this can be used to pass functions from lua to c and vice-versa  * - *arrays* are converted to lua tables with numeric indicies suitable for `ipairs` iterations  * - *objects* are converted to lua tables with string indicies  * @param {lua_State} L lua state pointer  * @param {ucl_object_t} obj object to push  * @param {bool} allow_array expand implicit arrays (should be true for all but partial arrays)  * @return {int} `1` if an object is pushed to lua  */
end_comment

begin_function
name|int
name|ucl_object_push_lua
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|bool
name|allow_array
parameter_list|)
block|{
switch|switch
condition|(
name|obj
operator|->
name|type
condition|)
block|{
case|case
name|UCL_OBJECT
case|:
return|return
name|ucl_object_lua_push_object
argument_list|(
name|L
argument_list|,
name|obj
argument_list|,
name|allow_array
argument_list|)
return|;
case|case
name|UCL_ARRAY
case|:
return|return
name|ucl_object_lua_push_array
argument_list|(
name|L
argument_list|,
name|obj
operator|->
name|value
operator|.
name|av
argument_list|)
return|;
default|default:
return|return
name|ucl_object_lua_push_scalar
argument_list|(
name|L
argument_list|,
name|obj
argument_list|,
name|allow_array
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Parse lua table into object top  * @param L  * @param top  * @param idx  */
end_comment

begin_function
specifier|static
name|ucl_object_t
modifier|*
name|ucl_object_lua_fromtable
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|ucl_object_t
modifier|*
name|obj
decl_stmt|,
modifier|*
name|top
init|=
name|NULL
decl_stmt|;
name|size_t
name|keylen
decl_stmt|;
specifier|const
name|char
modifier|*
name|k
decl_stmt|;
name|bool
name|is_array
init|=
name|true
decl_stmt|;
name|int
name|max
init|=
name|INT_MIN
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
comment|/* For negative indicies we want to invert them */
name|idx
operator|=
name|lua_gettop
argument_list|(
name|L
argument_list|)
operator|+
name|idx
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Check for array */
name|lua_pushnil
argument_list|(
name|L
argument_list|)
expr_stmt|;
while|while
condition|(
name|lua_next
argument_list|(
name|L
argument_list|,
name|idx
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|lua_type
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|)
operator|==
name|LUA_TNUMBER
condition|)
block|{
name|double
name|num
init|=
name|lua_tonumber
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|num
operator|==
operator|(
name|int
operator|)
name|num
condition|)
block|{
if|if
condition|(
name|num
operator|>
name|max
condition|)
block|{
name|max
operator|=
name|num
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Keys are not integer */
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|is_array
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* Keys are not numeric */
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|is_array
operator|=
name|false
expr_stmt|;
break|break;
block|}
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Table iterate */
if|if
condition|(
name|is_array
condition|)
block|{
name|int
name|i
decl_stmt|;
name|top
operator|=
name|ucl_object_typed_new
argument_list|(
name|UCL_ARRAY
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
block|{
name|lua_pushinteger
argument_list|(
name|L
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lua_gettable
argument_list|(
name|L
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|obj
operator|=
name|ucl_object_lua_fromelt
argument_list|(
name|L
argument_list|,
name|lua_gettop
argument_list|(
name|L
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|!=
name|NULL
condition|)
block|{
name|ucl_array_append
argument_list|(
name|top
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|lua_pushnil
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|top
operator|=
name|ucl_object_typed_new
argument_list|(
name|UCL_OBJECT
argument_list|)
expr_stmt|;
while|while
condition|(
name|lua_next
argument_list|(
name|L
argument_list|,
name|idx
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* copy key to avoid modifications */
name|k
operator|=
name|lua_tolstring
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|,
operator|&
name|keylen
argument_list|)
expr_stmt|;
name|obj
operator|=
name|ucl_object_lua_fromelt
argument_list|(
name|L
argument_list|,
name|lua_gettop
argument_list|(
name|L
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|!=
name|NULL
condition|)
block|{
name|ucl_object_insert_key
argument_list|(
name|top
argument_list|,
name|obj
argument_list|,
name|k
argument_list|,
name|keylen
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|top
return|;
block|}
end_function

begin_comment
comment|/**  * Get a single element from lua to object obj  * @param L  * @param obj  * @param idx  */
end_comment

begin_function
specifier|static
name|ucl_object_t
modifier|*
name|ucl_object_lua_fromelt
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|int
name|type
decl_stmt|;
name|double
name|num
decl_stmt|;
name|ucl_object_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
name|struct
name|ucl_lua_funcdata
modifier|*
name|fd
decl_stmt|;
name|type
operator|=
name|lua_type
argument_list|(
name|L
argument_list|,
name|idx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|LUA_TSTRING
case|:
name|obj
operator|=
name|ucl_object_fromstring_common
argument_list|(
name|lua_tostring
argument_list|(
name|L
argument_list|,
name|idx
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|LUA_TNUMBER
case|:
name|num
operator|=
name|lua_tonumber
argument_list|(
name|L
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|==
operator|(
name|int64_t
operator|)
name|num
condition|)
block|{
name|obj
operator|=
name|ucl_object_fromint
argument_list|(
name|num
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|obj
operator|=
name|ucl_object_fromdouble
argument_list|(
name|num
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LUA_TBOOLEAN
case|:
name|obj
operator|=
name|ucl_object_frombool
argument_list|(
name|lua_toboolean
argument_list|(
name|L
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LUA_TUSERDATA
case|:
if|if
condition|(
name|lua_topointer
argument_list|(
name|L
argument_list|,
name|idx
argument_list|)
operator|==
name|ucl_null
condition|)
block|{
name|obj
operator|=
name|ucl_object_typed_new
argument_list|(
name|UCL_NULL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LUA_TTABLE
case|:
case|case
name|LUA_TFUNCTION
case|:
case|case
name|LUA_TTHREAD
case|:
if|if
condition|(
name|luaL_getmetafield
argument_list|(
name|L
argument_list|,
name|idx
argument_list|,
literal|"__gen_ucl"
argument_list|)
condition|)
block|{
if|if
condition|(
name|lua_isfunction
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
name|lua_settop
argument_list|(
name|L
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* gen, obj, func */
name|lua_insert
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* func, gen, obj */
name|lua_insert
argument_list|(
name|L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* func, obj, gen */
name|lua_call
argument_list|(
name|L
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|obj
operator|=
name|ucl_object_lua_fromelt
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|type
operator|==
name|LUA_TTABLE
condition|)
block|{
name|obj
operator|=
name|ucl_object_lua_fromtable
argument_list|(
name|L
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|LUA_TFUNCTION
condition|)
block|{
name|fd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|fd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
name|NULL
condition|)
block|{
name|lua_pushvalue
argument_list|(
name|L
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|fd
operator|->
name|L
operator|=
name|L
expr_stmt|;
name|fd
operator|->
name|ret
operator|=
name|NULL
expr_stmt|;
name|fd
operator|->
name|idx
operator|=
name|luaL_ref
argument_list|(
name|L
argument_list|,
name|LUA_REGISTRYINDEX
argument_list|)
expr_stmt|;
name|obj
operator|=
name|ucl_object_new_userdata
argument_list|(
name|lua_ucl_userdata_dtor
argument_list|,
name|lua_ucl_userdata_emitter
argument_list|)
expr_stmt|;
name|obj
operator|->
name|type
operator|=
name|UCL_USERDATA
expr_stmt|;
name|obj
operator|->
name|value
operator|.
name|ud
operator|=
operator|(
name|void
operator|*
operator|)
name|fd
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
return|return
name|obj
return|;
block|}
end_function

begin_comment
comment|/**  * @function ucl_object_lua_import(L, idx)  * Extracts ucl object from lua variable at `idx` position,  * @see ucl_object_push_lua for conversion definitions  * @param {lua_state} L lua state machine pointer  * @param {int} idx index where the source variable is placed  * @return {ucl_object_t} new ucl object extracted from lua variable. Reference count of this object is 1,  * this object thus needs to be unref'ed after usage.  */
end_comment

begin_function
name|ucl_object_t
modifier|*
name|ucl_object_lua_import
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|ucl_object_t
modifier|*
name|obj
decl_stmt|;
name|int
name|t
decl_stmt|;
name|t
operator|=
name|lua_type
argument_list|(
name|L
argument_list|,
name|idx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|LUA_TTABLE
case|:
name|obj
operator|=
name|ucl_object_lua_fromtable
argument_list|(
name|L
argument_list|,
name|idx
argument_list|)
expr_stmt|;
break|break;
default|default:
name|obj
operator|=
name|ucl_object_lua_fromelt
argument_list|(
name|L
argument_list|,
name|idx
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|obj
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lua_ucl_parser_init
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|struct
name|ucl_parser
modifier|*
name|parser
decl_stmt|,
modifier|*
modifier|*
name|pparser
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lua_gettop
argument_list|(
name|L
argument_list|)
operator|>=
literal|1
condition|)
block|{
name|flags
operator|=
name|lua_tonumber
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|parser
operator|=
name|ucl_parser_new
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|==
name|NULL
condition|)
block|{
name|lua_pushnil
argument_list|(
name|L
argument_list|)
expr_stmt|;
block|}
name|pparser
operator|=
name|lua_newuserdata
argument_list|(
name|L
argument_list|,
sizeof|sizeof
argument_list|(
name|parser
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pparser
operator|=
name|parser
expr_stmt|;
name|luaL_getmetatable
argument_list|(
name|L
argument_list|,
name|PARSER_META
argument_list|)
expr_stmt|;
name|lua_setmetatable
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ucl_parser
modifier|*
name|lua_ucl_parser_get
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|index
parameter_list|)
block|{
return|return
operator|*
operator|(
operator|(
expr|struct
name|ucl_parser
operator|*
operator|*
operator|)
name|luaL_checkudata
argument_list|(
name|L
argument_list|,
name|index
argument_list|,
name|PARSER_META
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/***  * @method parser:parse_file(name)  * Parse UCL object from file.  * @param {string} name filename to parse  * @return {bool[, string]} if res is `true` then file has been parsed successfully, otherwise an error string is also returned @example local parser = ucl.parser() local res,err = parser:parse_file('/some/file.conf')  if not res then 	print('parser error: ' .. err) else 	-- Do something with object end  */
end_comment

begin_function
specifier|static
name|int
name|lua_ucl_parser_parse_file
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|struct
name|ucl_parser
modifier|*
name|parser
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|ret
init|=
literal|2
decl_stmt|;
name|parser
operator|=
name|lua_ucl_parser_get
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|file
operator|=
name|luaL_checkstring
argument_list|(
name|L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|!=
name|NULL
operator|&&
name|file
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ucl_parser_add_file
argument_list|(
name|parser
argument_list|,
name|file
argument_list|)
condition|)
block|{
name|lua_pushboolean
argument_list|(
name|L
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|lua_pushboolean
argument_list|(
name|L
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|lua_pushstring
argument_list|(
name|L
argument_list|,
name|ucl_parser_get_error
argument_list|(
name|parser
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|lua_pushboolean
argument_list|(
name|L
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|lua_pushstring
argument_list|(
name|L
argument_list|,
literal|"invalid arguments"
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/***  * @method parser:parse_string(input)  * Parse UCL object from file.  * @param {string} input string to parse  * @return {bool[, string]} if res is `true` then file has been parsed successfully, otherwise an error string is also returned  */
end_comment

begin_function
specifier|static
name|int
name|lua_ucl_parser_parse_string
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|struct
name|ucl_parser
modifier|*
name|parser
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|size_t
name|llen
decl_stmt|;
name|int
name|ret
init|=
literal|2
decl_stmt|;
name|parser
operator|=
name|lua_ucl_parser_get
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|string
operator|=
name|luaL_checklstring
argument_list|(
name|L
argument_list|,
literal|2
argument_list|,
operator|&
name|llen
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|!=
name|NULL
operator|&&
name|string
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ucl_parser_add_chunk
argument_list|(
name|parser
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|string
argument_list|,
name|llen
argument_list|)
condition|)
block|{
name|lua_pushboolean
argument_list|(
name|L
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|lua_pushboolean
argument_list|(
name|L
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|lua_pushstring
argument_list|(
name|L
argument_list|,
name|ucl_parser_get_error
argument_list|(
name|parser
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|lua_pushboolean
argument_list|(
name|L
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|lua_pushstring
argument_list|(
name|L
argument_list|,
literal|"invalid arguments"
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/***  * @method parser:get_object()  * Get top object from parser and export it to lua representation.  * @return {variant or nil} ucl object as lua native variable  */
end_comment

begin_function
specifier|static
name|int
name|lua_ucl_parser_get_object
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|struct
name|ucl_parser
modifier|*
name|parser
decl_stmt|;
name|ucl_object_t
modifier|*
name|obj
decl_stmt|;
name|int
name|ret
init|=
literal|1
decl_stmt|;
name|parser
operator|=
name|lua_ucl_parser_get
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|obj
operator|=
name|ucl_parser_get_object
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|ucl_object_push_lua
argument_list|(
name|L
argument_list|,
name|obj
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* no need to keep reference */
name|ucl_object_unref
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lua_pushnil
argument_list|(
name|L
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lua_ucl_parser_gc
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|struct
name|ucl_parser
modifier|*
name|parser
decl_stmt|;
name|parser
operator|=
name|lua_ucl_parser_get
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ucl_parser_free
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lua_ucl_parser_mt
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|luaL_newmetatable
argument_list|(
name|L
argument_list|,
name|PARSER_META
argument_list|)
expr_stmt|;
name|lua_pushvalue
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|lua_setfield
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|,
literal|"__index"
argument_list|)
expr_stmt|;
name|lua_pushcfunction
argument_list|(
name|L
argument_list|,
name|lua_ucl_parser_gc
argument_list|)
expr_stmt|;
name|lua_setfield
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|,
literal|"__gc"
argument_list|)
expr_stmt|;
name|lua_pushcfunction
argument_list|(
name|L
argument_list|,
name|lua_ucl_parser_parse_file
argument_list|)
expr_stmt|;
name|lua_setfield
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|,
literal|"parse_file"
argument_list|)
expr_stmt|;
name|lua_pushcfunction
argument_list|(
name|L
argument_list|,
name|lua_ucl_parser_parse_string
argument_list|)
expr_stmt|;
name|lua_setfield
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|,
literal|"parse_string"
argument_list|)
expr_stmt|;
name|lua_pushcfunction
argument_list|(
name|L
argument_list|,
name|lua_ucl_parser_get_object
argument_list|)
expr_stmt|;
name|lua_setfield
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|,
literal|"get_object"
argument_list|)
expr_stmt|;
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lua_ucl_to_string
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|enum
name|ucl_emitter
name|type
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|ucl_object_emit
argument_list|(
name|obj
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|NULL
condition|)
block|{
name|lua_pushstring
argument_list|(
name|L
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|result
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lua_pushnil
argument_list|(
name|L
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lua_ucl_to_json
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|ucl_object_t
modifier|*
name|obj
decl_stmt|;
name|int
name|format
init|=
name|UCL_EMIT_JSON
decl_stmt|;
if|if
condition|(
name|lua_gettop
argument_list|(
name|L
argument_list|)
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|lua_toboolean
argument_list|(
name|L
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|format
operator|=
name|UCL_EMIT_JSON_COMPACT
expr_stmt|;
block|}
block|}
name|obj
operator|=
name|ucl_object_lua_import
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|!=
name|NULL
condition|)
block|{
name|lua_ucl_to_string
argument_list|(
name|L
argument_list|,
name|obj
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|ucl_object_unref
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lua_pushnil
argument_list|(
name|L
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lua_ucl_to_config
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|ucl_object_t
modifier|*
name|obj
decl_stmt|;
name|obj
operator|=
name|ucl_object_lua_import
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|!=
name|NULL
condition|)
block|{
name|lua_ucl_to_string
argument_list|(
name|L
argument_list|,
name|obj
argument_list|,
name|UCL_EMIT_CONFIG
argument_list|)
expr_stmt|;
name|ucl_object_unref
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lua_pushnil
argument_list|(
name|L
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/***  * @function ucl.to_format(var, format)  * Converts lua variable `var` to the specified `format`. Formats supported are:  *  * - `json` - fine printed json  * - `json-compact` - compacted json  * - `config` - fine printed configuration  * - `ucl` - same as `config`  * - `yaml` - embedded yaml  *  * If `var` contains function, they are called during output formatting and if  * they return string value, then this value is used for ouptut.  * @param {variant} var any sort of lua variable (if userdata then metafield `__to_ucl` is searched for output)  * @param {string} format any available format  * @return {string} string representation of `var` in the specific `format`.  * @example local table = {   str = 'value',   num = 100500,   null = ucl.null,   func = function ()     return 'huh'   end }  print(ucl.to_format(table, 'ucl')) -- Output: --[[ num = 100500; str = "value"; null = null; func = "huh"; --]]  */
end_comment

begin_function
specifier|static
name|int
name|lua_ucl_to_format
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|ucl_object_t
modifier|*
name|obj
decl_stmt|;
name|int
name|format
init|=
name|UCL_EMIT_JSON
decl_stmt|;
if|if
condition|(
name|lua_gettop
argument_list|(
name|L
argument_list|)
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|lua_type
argument_list|(
name|L
argument_list|,
literal|2
argument_list|)
operator|==
name|LUA_TNUMBER
condition|)
block|{
name|format
operator|=
name|lua_tonumber
argument_list|(
name|L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|<
literal|0
operator|||
name|format
operator|>=
name|UCL_EMIT_YAML
condition|)
block|{
name|lua_pushnil
argument_list|(
name|L
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|lua_type
argument_list|(
name|L
argument_list|,
literal|2
argument_list|)
operator|==
name|LUA_TSTRING
condition|)
block|{
specifier|const
name|char
modifier|*
name|strtype
init|=
name|lua_tostring
argument_list|(
name|L
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|strtype
argument_list|,
literal|"json"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|format
operator|=
name|UCL_EMIT_JSON
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|strtype
argument_list|,
literal|"json-compact"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|format
operator|=
name|UCL_EMIT_JSON_COMPACT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|strtype
argument_list|,
literal|"yaml"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|format
operator|=
name|UCL_EMIT_YAML
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|strtype
argument_list|,
literal|"config"
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
name|strtype
argument_list|,
literal|"ucl"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|format
operator|=
name|UCL_EMIT_CONFIG
expr_stmt|;
block|}
block|}
block|}
name|obj
operator|=
name|ucl_object_lua_import
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|!=
name|NULL
condition|)
block|{
name|lua_ucl_to_string
argument_list|(
name|L
argument_list|,
name|obj
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|ucl_object_unref
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lua_pushnil
argument_list|(
name|L
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lua_ucl_null_tostring
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|lua_pushstring
argument_list|(
name|L
argument_list|,
literal|"null"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lua_ucl_null_mt
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|luaL_newmetatable
argument_list|(
name|L
argument_list|,
name|NULL_META
argument_list|)
expr_stmt|;
name|lua_pushcfunction
argument_list|(
name|L
argument_list|,
name|lua_ucl_null_tostring
argument_list|)
expr_stmt|;
name|lua_setfield
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|,
literal|"__tostring"
argument_list|)
expr_stmt|;
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|luaopen_ucl
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|lua_ucl_parser_mt
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|lua_ucl_null_mt
argument_list|(
name|L
argument_list|)
expr_stmt|;
comment|/* Create the refs weak table: */
name|lua_createtable
argument_list|(
name|L
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|lua_pushliteral
argument_list|(
name|L
argument_list|,
literal|"v"
argument_list|)
expr_stmt|;
comment|/* tbl, "v" */
name|lua_setfield
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|,
literal|"__mode"
argument_list|)
expr_stmt|;
name|lua_pushvalue
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* tbl, tbl */
name|lua_setmetatable
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* tbl */
name|lua_setfield
argument_list|(
name|L
argument_list|,
name|LUA_REGISTRYINDEX
argument_list|,
literal|"ucl.refs"
argument_list|)
expr_stmt|;
name|lua_newtable
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|lua_pushcfunction
argument_list|(
name|L
argument_list|,
name|lua_ucl_parser_init
argument_list|)
expr_stmt|;
name|lua_setfield
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|,
literal|"parser"
argument_list|)
expr_stmt|;
name|lua_pushcfunction
argument_list|(
name|L
argument_list|,
name|lua_ucl_to_json
argument_list|)
expr_stmt|;
name|lua_setfield
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|,
literal|"to_json"
argument_list|)
expr_stmt|;
name|lua_pushcfunction
argument_list|(
name|L
argument_list|,
name|lua_ucl_to_config
argument_list|)
expr_stmt|;
name|lua_setfield
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|,
literal|"to_config"
argument_list|)
expr_stmt|;
name|lua_pushcfunction
argument_list|(
name|L
argument_list|,
name|lua_ucl_to_format
argument_list|)
expr_stmt|;
name|lua_setfield
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|,
literal|"to_format"
argument_list|)
expr_stmt|;
name|ucl_null
operator|=
name|lua_newuserdata
argument_list|(
name|L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|luaL_getmetatable
argument_list|(
name|L
argument_list|,
name|NULL_META
argument_list|)
expr_stmt|;
name|lua_setmetatable
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
name|lua_pushvalue
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|lua_setfield
argument_list|(
name|L
argument_list|,
name|LUA_REGISTRYINDEX
argument_list|,
literal|"ucl.null"
argument_list|)
expr_stmt|;
name|lua_setfield
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|,
literal|"null"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|struct
name|ucl_lua_funcdata
modifier|*
name|ucl_object_toclosure
parameter_list|(
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|==
name|NULL
operator|||
name|obj
operator|->
name|type
operator|!=
name|UCL_USERDATA
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
operator|(
expr|struct
name|ucl_lua_funcdata
operator|*
operator|)
name|obj
operator|->
name|value
operator|.
name|ud
return|;
block|}
end_function

end_unit

