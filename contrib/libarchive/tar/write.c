begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2007 Tim Kientzle  * Copyright (c) 2012 Michihiro NAKAJIMA  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"bsdtar_platform.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TYPES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_STAT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ATTR_XATTR_H
end_ifdef

begin_include
include|#
directive|include
file|<attr/xattr.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ERRNO_H
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FCNTL_H
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GRP_H
end_ifdef

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_IO_H
end_ifdef

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIBGEN_H
end_ifdef

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIMITS_H
end_ifdef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PATHS_H
end_ifdef

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PWD_H
end_ifdef

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDINT_H
end_ifdef

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"bsdtar.h"
end_include

begin_include
include|#
directive|include
file|"err.h"
end_include

begin_include
include|#
directive|include
file|"line_reader.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|O_BINARY
end_ifndef

begin_define
define|#
directive|define
name|O_BINARY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|archive_dir_entry
block|{
name|struct
name|archive_dir_entry
modifier|*
name|next
decl_stmt|;
name|time_t
name|mtime_sec
decl_stmt|;
name|int
name|mtime_nsec
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|archive_dir
block|{
name|struct
name|archive_dir_entry
modifier|*
name|head
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|append_archive
parameter_list|(
name|struct
name|bsdtar
modifier|*
parameter_list|,
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive
modifier|*
name|ina
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|append_archive_filename
parameter_list|(
name|struct
name|bsdtar
modifier|*
parameter_list|,
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|archive_names_from_file
parameter_list|(
name|struct
name|bsdtar
modifier|*
name|bsdtar
parameter_list|,
name|struct
name|archive
modifier|*
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|copy_file_data_block
parameter_list|(
name|struct
name|bsdtar
modifier|*
parameter_list|,
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|excluded_callback
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|report_write
parameter_list|(
name|struct
name|bsdtar
modifier|*
parameter_list|,
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int64_t
name|progress
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|test_for_append
parameter_list|(
name|struct
name|bsdtar
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|metadata_filter
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_archive
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|bsdtar
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_entry
parameter_list|(
name|struct
name|bsdtar
modifier|*
parameter_list|,
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_file
parameter_list|(
name|struct
name|bsdtar
modifier|*
parameter_list|,
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_hierarchy
parameter_list|(
name|struct
name|bsdtar
modifier|*
parameter_list|,
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_comment
comment|/* Not a full lseek() emulation, but enough for our needs here. */
end_comment

begin_function
specifier|static
name|int
name|seek_file
parameter_list|(
name|int
name|fd
parameter_list|,
name|int64_t
name|offset
parameter_list|,
name|int
name|whence
parameter_list|)
block|{
name|LARGE_INTEGER
name|distance
decl_stmt|;
operator|(
name|void
operator|)
name|whence
expr_stmt|;
comment|/* UNUSED */
name|distance
operator|.
name|QuadPart
operator|=
name|offset
expr_stmt|;
return|return
operator|(
name|SetFilePointerEx
argument_list|(
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|fd
argument_list|)
argument_list|,
name|distance
argument_list|,
name|NULL
argument_list|,
name|FILE_BEGIN
argument_list|)
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|open
value|_open
end_define

begin_define
define|#
directive|define
name|close
value|_close
end_define

begin_define
define|#
directive|define
name|read
value|_read
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|lseek
end_ifdef

begin_undef
undef|#
directive|undef
name|lseek
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|lseek
value|seek_file
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|set_writer_options
parameter_list|(
name|struct
name|bsdtar
modifier|*
name|bsdtar
parameter_list|,
name|struct
name|archive
modifier|*
name|a
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|writer_options
decl_stmt|;
name|int
name|r
decl_stmt|;
name|writer_options
operator|=
name|getenv
argument_list|(
name|ENV_WRITER_OPTIONS
argument_list|)
expr_stmt|;
if|if
condition|(
name|writer_options
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Set default write options. */
name|p
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|IGNORE_WRONG_MODULE_NAME
argument_list|)
operator|+
name|strlen
argument_list|(
name|writer_options
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
comment|/* Prepend magic code to ignore options for 		 * a format or filters which are not added to 		 * the archive write object. */
name|strncpy
argument_list|(
name|p
argument_list|,
name|IGNORE_WRONG_MODULE_NAME
argument_list|,
sizeof|sizeof
argument_list|(
name|IGNORE_WRONG_MODULE_NAME
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
operator|+
sizeof|sizeof
argument_list|(
name|IGNORE_WRONG_MODULE_NAME
argument_list|)
operator|-
literal|1
argument_list|,
name|writer_options
argument_list|)
expr_stmt|;
name|r
operator|=
name|archive_write_set_options
argument_list|(
name|a
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|ARCHIVE_WARN
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|archive_clear_error
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ARCHIVE_OK
operator|!=
name|archive_write_set_options
argument_list|(
name|a
argument_list|,
name|bsdtar
operator|->
name|option_options
argument_list|)
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_reader_options
parameter_list|(
name|struct
name|bsdtar
modifier|*
name|bsdtar
parameter_list|,
name|struct
name|archive
modifier|*
name|a
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|reader_options
decl_stmt|;
name|int
name|r
decl_stmt|;
operator|(
name|void
operator|)
name|bsdtar
expr_stmt|;
comment|/* UNUSED */
name|reader_options
operator|=
name|getenv
argument_list|(
name|ENV_READER_OPTIONS
argument_list|)
expr_stmt|;
if|if
condition|(
name|reader_options
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Set default write options. */
name|p
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|IGNORE_WRONG_MODULE_NAME
argument_list|)
operator|+
name|strlen
argument_list|(
name|reader_options
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
comment|/* Prepend magic code to ignore options for 		 * a format or filters which are not added to 		 * the archive write object. */
name|strncpy
argument_list|(
name|p
argument_list|,
name|IGNORE_WRONG_MODULE_NAME
argument_list|,
sizeof|sizeof
argument_list|(
name|IGNORE_WRONG_MODULE_NAME
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
operator|+
sizeof|sizeof
argument_list|(
name|IGNORE_WRONG_MODULE_NAME
argument_list|)
operator|-
literal|1
argument_list|,
name|reader_options
argument_list|)
expr_stmt|;
name|r
operator|=
name|archive_read_set_options
argument_list|(
name|a
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|ARCHIVE_WARN
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|archive_clear_error
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|tar_mode_c
parameter_list|(
name|struct
name|bsdtar
modifier|*
name|bsdtar
parameter_list|)
block|{
name|struct
name|archive
modifier|*
name|a
decl_stmt|;
specifier|const
name|void
modifier|*
name|filter_name
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|*
name|bsdtar
operator|->
name|argv
operator|==
name|NULL
operator|&&
name|bsdtar
operator|->
name|names_from_file
operator|==
name|NULL
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"no files or directories specified"
argument_list|)
expr_stmt|;
name|a
operator|=
name|archive_write_new
argument_list|()
expr_stmt|;
comment|/* Support any format that the library supports. */
if|if
condition|(
name|cset_get_format
argument_list|(
name|bsdtar
operator|->
name|cset
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|archive_write_set_format_pax_restricted
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|cset_set_format
argument_list|(
name|bsdtar
operator|->
name|cset
argument_list|,
literal|"pax restricted"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|archive_write_set_format_by_name
argument_list|(
name|a
argument_list|,
name|cset_get_format
argument_list|(
name|bsdtar
operator|->
name|cset
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't use format %s: %s\n"
argument_list|,
name|cset_get_format
argument_list|(
name|bsdtar
operator|->
name|cset
argument_list|)
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|archive_write_set_bytes_per_block
argument_list|(
name|a
argument_list|,
name|bsdtar
operator|->
name|bytes_per_block
argument_list|)
expr_stmt|;
name|archive_write_set_bytes_in_last_block
argument_list|(
name|a
argument_list|,
name|bsdtar
operator|->
name|bytes_in_last_block
argument_list|)
expr_stmt|;
name|r
operator|=
name|cset_write_add_filters
argument_list|(
name|bsdtar
operator|->
name|cset
argument_list|,
name|a
argument_list|,
operator|&
name|filter_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|ARCHIVE_WARN
condition|)
block|{
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Unsupported compression option --%s"
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|filter_name
argument_list|)
expr_stmt|;
block|}
name|set_writer_options
argument_list|(
name|bsdtar
argument_list|,
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|ARCHIVE_OK
operator|!=
name|archive_write_open_filename
argument_list|(
name|a
argument_list|,
name|bsdtar
operator|->
name|filename
argument_list|)
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|write_archive
argument_list|(
name|a
argument_list|,
name|bsdtar
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Same as 'c', except we only support tar or empty formats in  * uncompressed files on disk.  */
end_comment

begin_function
name|void
name|tar_mode_r
parameter_list|(
name|struct
name|bsdtar
modifier|*
name|bsdtar
parameter_list|)
block|{
name|int64_t
name|end_offset
decl_stmt|;
name|int
name|format
decl_stmt|;
name|struct
name|archive
modifier|*
name|a
decl_stmt|;
name|struct
name|archive_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* Sanity-test some arguments and the file. */
name|test_for_append
argument_list|(
name|bsdtar
argument_list|)
expr_stmt|;
name|format
operator|=
name|ARCHIVE_FORMAT_TAR_PAX_RESTRICTED
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
name|bsdtar
operator|->
name|fd
operator|=
name|open
argument_list|(
name|bsdtar
operator|->
name|filename
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_BINARY
argument_list|)
expr_stmt|;
else|#
directive|else
name|bsdtar
operator|->
name|fd
operator|=
name|open
argument_list|(
name|bsdtar
operator|->
name|filename
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_BINARY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bsdtar
operator|->
name|fd
operator|<
literal|0
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Cannot open %s"
argument_list|,
name|bsdtar
operator|->
name|filename
argument_list|)
expr_stmt|;
name|a
operator|=
name|archive_read_new
argument_list|()
expr_stmt|;
name|archive_read_support_filter_all
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|archive_read_support_format_empty
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|archive_read_support_format_tar
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|archive_read_support_format_gnutar
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|set_reader_options
argument_list|(
name|bsdtar
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|r
operator|=
name|archive_read_open_fd
argument_list|(
name|a
argument_list|,
name|bsdtar
operator|->
name|fd
argument_list|,
literal|10240
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
name|archive_errno
argument_list|(
name|a
argument_list|)
argument_list|,
literal|"Can't read archive %s: %s"
argument_list|,
name|bsdtar
operator|->
name|filename
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
literal|0
operator|==
name|archive_read_next_header
argument_list|(
name|a
argument_list|,
operator|&
name|entry
argument_list|)
condition|)
block|{
if|if
condition|(
name|archive_filter_code
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
operator|!=
name|ARCHIVE_FILTER_NONE
condition|)
block|{
name|archive_read_free
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|bsdtar
operator|->
name|fd
argument_list|)
expr_stmt|;
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Cannot append to compressed archive."
argument_list|)
expr_stmt|;
block|}
comment|/* Keep going until we hit end-of-archive */
name|format
operator|=
name|archive_format
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
name|end_offset
operator|=
name|archive_read_header_position
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|archive_read_free
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|/* Re-open archive for writing */
name|a
operator|=
name|archive_write_new
argument_list|()
expr_stmt|;
comment|/* 	 * Set the format to be used for writing.  To allow people to 	 * extend empty files, we need to allow them to specify the format, 	 * which opens the possibility that they will specify a format that 	 * doesn't match the existing format.  Hence, the following bit 	 * of arcane ugliness. 	 */
if|if
condition|(
name|cset_get_format
argument_list|(
name|bsdtar
operator|->
name|cset
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* If the user requested a format, use that, but ... */
name|archive_write_set_format_by_name
argument_list|(
name|a
argument_list|,
name|cset_get_format
argument_list|(
name|bsdtar
operator|->
name|cset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ... complain if it's not compatible. */
name|format
operator|&=
name|ARCHIVE_FORMAT_BASE_MASK
expr_stmt|;
if|if
condition|(
name|format
operator|!=
call|(
name|int
call|)
argument_list|(
name|archive_format
argument_list|(
name|a
argument_list|)
operator|&
name|ARCHIVE_FORMAT_BASE_MASK
argument_list|)
operator|&&
name|format
operator|!=
name|ARCHIVE_FORMAT_EMPTY
condition|)
block|{
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Format %s is incompatible with the archive %s."
argument_list|,
name|cset_get_format
argument_list|(
name|bsdtar
operator|->
name|cset
argument_list|)
argument_list|,
name|bsdtar
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Just preserve the current format, with a little care 		 * for formats that libarchive can't write. 		 */
if|if
condition|(
name|format
operator|==
name|ARCHIVE_FORMAT_EMPTY
condition|)
name|format
operator|=
name|ARCHIVE_FORMAT_TAR_PAX_RESTRICTED
expr_stmt|;
name|archive_write_set_format
argument_list|(
name|a
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|bsdtar
operator|->
name|fd
argument_list|,
name|end_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Could not seek to archive end"
argument_list|)
expr_stmt|;
name|set_writer_options
argument_list|(
name|bsdtar
argument_list|,
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|ARCHIVE_OK
operator|!=
name|archive_write_open_fd
argument_list|(
name|a
argument_list|,
name|bsdtar
operator|->
name|fd
argument_list|)
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|write_archive
argument_list|(
name|a
argument_list|,
name|bsdtar
argument_list|)
expr_stmt|;
comment|/* XXX check return val XXX */
name|close
argument_list|(
name|bsdtar
operator|->
name|fd
argument_list|)
expr_stmt|;
name|bsdtar
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tar_mode_u
parameter_list|(
name|struct
name|bsdtar
modifier|*
name|bsdtar
parameter_list|)
block|{
name|int64_t
name|end_offset
decl_stmt|;
name|struct
name|archive
modifier|*
name|a
decl_stmt|;
name|struct
name|archive_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|format
decl_stmt|;
name|struct
name|archive_dir_entry
modifier|*
name|p
decl_stmt|;
name|struct
name|archive_dir
name|archive_dir
decl_stmt|;
name|bsdtar
operator|->
name|archive_dir
operator|=
operator|&
name|archive_dir
expr_stmt|;
name|memset
argument_list|(
operator|&
name|archive_dir
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|archive_dir
argument_list|)
argument_list|)
expr_stmt|;
name|format
operator|=
name|ARCHIVE_FORMAT_TAR_PAX_RESTRICTED
expr_stmt|;
comment|/* Sanity-test some arguments and the file. */
name|test_for_append
argument_list|(
name|bsdtar
argument_list|)
expr_stmt|;
name|bsdtar
operator|->
name|fd
operator|=
name|open
argument_list|(
name|bsdtar
operator|->
name|filename
argument_list|,
name|O_RDWR
operator||
name|O_BINARY
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsdtar
operator|->
name|fd
operator|<
literal|0
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Cannot open %s"
argument_list|,
name|bsdtar
operator|->
name|filename
argument_list|)
expr_stmt|;
name|a
operator|=
name|archive_read_new
argument_list|()
expr_stmt|;
name|archive_read_support_filter_all
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|archive_read_support_format_tar
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|archive_read_support_format_gnutar
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|set_reader_options
argument_list|(
name|bsdtar
argument_list|,
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_read_open_fd
argument_list|(
name|a
argument_list|,
name|bsdtar
operator|->
name|fd
argument_list|,
name|bsdtar
operator|->
name|bytes_per_block
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Can't open %s: %s"
argument_list|,
name|bsdtar
operator|->
name|filename
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Build a list of all entries and their recorded mod times. */
while|while
condition|(
literal|0
operator|==
name|archive_read_next_header
argument_list|(
name|a
argument_list|,
operator|&
name|entry
argument_list|)
condition|)
block|{
if|if
condition|(
name|archive_filter_code
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
operator|!=
name|ARCHIVE_FILTER_NONE
condition|)
block|{
name|archive_read_free
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|bsdtar
operator|->
name|fd
argument_list|)
expr_stmt|;
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Cannot append to compressed archive."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|archive_match_exclude_entry
argument_list|(
name|bsdtar
operator|->
name|matching
argument_list|,
name|ARCHIVE_MATCH_MTIME
operator||
name|ARCHIVE_MATCH_OLDER
operator||
name|ARCHIVE_MATCH_EQUAL
argument_list|,
name|entry
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Error : %s"
argument_list|,
name|archive_error_string
argument_list|(
name|bsdtar
operator|->
name|matching
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Record the last format determination we see */
name|format
operator|=
name|archive_format
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|/* Keep going until we hit end-of-archive */
block|}
name|end_offset
operator|=
name|archive_read_header_position
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|archive_read_free
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|/* Re-open archive for writing. */
name|a
operator|=
name|archive_write_new
argument_list|()
expr_stmt|;
comment|/* 	 * Set format to same one auto-detected above. 	 */
name|archive_write_set_format
argument_list|(
name|a
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|archive_write_set_bytes_per_block
argument_list|(
name|a
argument_list|,
name|bsdtar
operator|->
name|bytes_per_block
argument_list|)
expr_stmt|;
name|archive_write_set_bytes_in_last_block
argument_list|(
name|a
argument_list|,
name|bsdtar
operator|->
name|bytes_in_last_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|bsdtar
operator|->
name|fd
argument_list|,
name|end_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Could not seek to archive end"
argument_list|)
expr_stmt|;
name|set_writer_options
argument_list|(
name|bsdtar
argument_list|,
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|ARCHIVE_OK
operator|!=
name|archive_write_open_fd
argument_list|(
name|a
argument_list|,
name|bsdtar
operator|->
name|fd
argument_list|)
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|write_archive
argument_list|(
name|a
argument_list|,
name|bsdtar
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|bsdtar
operator|->
name|fd
argument_list|)
expr_stmt|;
name|bsdtar
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|bsdtar
operator|->
name|archive_dir
operator|->
name|head
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|bsdtar
operator|->
name|archive_dir
operator|->
name|head
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|bsdtar
operator|->
name|archive_dir
operator|->
name|head
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bsdtar
operator|->
name|archive_dir
operator|->
name|head
argument_list|)
expr_stmt|;
name|bsdtar
operator|->
name|archive_dir
operator|->
name|head
operator|=
name|p
expr_stmt|;
block|}
name|bsdtar
operator|->
name|archive_dir
operator|->
name|tail
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write user-specified files/dirs to opened archive.  */
end_comment

begin_function
specifier|static
name|void
name|write_archive
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|bsdtar
modifier|*
name|bsdtar
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
name|struct
name|archive_entry
modifier|*
name|entry
decl_stmt|,
modifier|*
name|sparse_entry
decl_stmt|;
comment|/* Choose a suitable copy buffer size */
name|bsdtar
operator|->
name|buff_size
operator|=
literal|64
operator|*
literal|1024
expr_stmt|;
while|while
condition|(
name|bsdtar
operator|->
name|buff_size
operator|<
operator|(
name|size_t
operator|)
name|bsdtar
operator|->
name|bytes_per_block
condition|)
name|bsdtar
operator|->
name|buff_size
operator|*=
literal|2
expr_stmt|;
comment|/* Try to compensate for space we'll lose to alignment. */
name|bsdtar
operator|->
name|buff_size
operator|+=
literal|16
operator|*
literal|1024
expr_stmt|;
comment|/* Allocate a buffer for file data. */
if|if
condition|(
operator|(
name|bsdtar
operator|->
name|buff
operator|=
name|malloc
argument_list|(
name|bsdtar
operator|->
name|buff_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot allocate memory"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bsdtar
operator|->
name|resolver
operator|=
name|archive_entry_linkresolver_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot create link resolver"
argument_list|)
expr_stmt|;
name|archive_entry_linkresolver_set_strategy
argument_list|(
name|bsdtar
operator|->
name|resolver
argument_list|,
name|archive_format
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a read_disk object. */
if|if
condition|(
operator|(
name|bsdtar
operator|->
name|diskreader
operator|=
name|archive_read_disk_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Cannot create read_disk object"
argument_list|)
expr_stmt|;
comment|/* Tell the read_disk how handle symlink. */
switch|switch
condition|(
name|bsdtar
operator|->
name|symlink_mode
condition|)
block|{
case|case
literal|'H'
case|:
name|archive_read_disk_set_symlink_hybrid
argument_list|(
name|bsdtar
operator|->
name|diskreader
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|archive_read_disk_set_symlink_logical
argument_list|(
name|bsdtar
operator|->
name|diskreader
argument_list|)
expr_stmt|;
break|break;
default|default:
name|archive_read_disk_set_symlink_physical
argument_list|(
name|bsdtar
operator|->
name|diskreader
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Register entry filters. */
name|archive_read_disk_set_matching
argument_list|(
name|bsdtar
operator|->
name|diskreader
argument_list|,
name|bsdtar
operator|->
name|matching
argument_list|,
name|excluded_callback
argument_list|,
name|bsdtar
argument_list|)
expr_stmt|;
name|archive_read_disk_set_metadata_filter_callback
argument_list|(
name|bsdtar
operator|->
name|diskreader
argument_list|,
name|metadata_filter
argument_list|,
name|bsdtar
argument_list|)
expr_stmt|;
comment|/* Set the behavior of archive_read_disk. */
name|archive_read_disk_set_behavior
argument_list|(
name|bsdtar
operator|->
name|diskreader
argument_list|,
name|bsdtar
operator|->
name|readdisk_flags
argument_list|)
expr_stmt|;
name|archive_read_disk_set_standard_lookup
argument_list|(
name|bsdtar
operator|->
name|diskreader
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsdtar
operator|->
name|names_from_file
operator|!=
name|NULL
condition|)
name|archive_names_from_file
argument_list|(
name|bsdtar
argument_list|,
name|a
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|bsdtar
operator|->
name|argv
condition|)
block|{
name|arg
operator|=
operator|*
name|bsdtar
operator|->
name|argv
expr_stmt|;
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|arg
index|[
literal|1
index|]
operator|==
literal|'C'
condition|)
block|{
name|arg
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|'\0'
condition|)
block|{
name|bsdtar
operator|->
name|argv
operator|++
expr_stmt|;
name|arg
operator|=
operator|*
name|bsdtar
operator|->
name|argv
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
block|{
name|lafe_warnc
argument_list|(
literal|0
argument_list|,
literal|"%s"
argument_list|,
literal|"Missing argument for -C"
argument_list|)
expr_stmt|;
name|bsdtar
operator|->
name|return_value
operator|=
literal|1
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
operator|*
name|arg
operator|==
literal|'\0'
condition|)
block|{
name|lafe_warnc
argument_list|(
literal|0
argument_list|,
literal|"Meaningless argument for -C: ''"
argument_list|)
expr_stmt|;
name|bsdtar
operator|->
name|return_value
operator|=
literal|1
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
name|set_chdir
argument_list|(
name|bsdtar
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|arg
operator|!=
literal|'/'
operator|&&
operator|(
name|arg
index|[
literal|0
index|]
operator|!=
literal|'@'
operator|||
name|arg
index|[
literal|1
index|]
operator|!=
literal|'/'
operator|)
condition|)
name|do_chdir
argument_list|(
name|bsdtar
argument_list|)
expr_stmt|;
comment|/* Handle a deferred -C */
if|if
condition|(
operator|*
name|arg
operator|==
literal|'@'
condition|)
block|{
if|if
condition|(
name|append_archive_filename
argument_list|(
name|bsdtar
argument_list|,
name|a
argument_list|,
name|arg
operator|+
literal|1
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
else|else
name|write_hierarchy
argument_list|(
name|bsdtar
argument_list|,
name|a
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
name|bsdtar
operator|->
name|argv
operator|++
expr_stmt|;
block|}
name|archive_read_disk_set_matching
argument_list|(
name|bsdtar
operator|->
name|diskreader
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|archive_read_disk_set_metadata_filter_callback
argument_list|(
name|bsdtar
operator|->
name|diskreader
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|entry
operator|=
name|NULL
expr_stmt|;
name|archive_entry_linkify
argument_list|(
name|bsdtar
operator|->
name|resolver
argument_list|,
operator|&
name|entry
argument_list|,
operator|&
name|sparse_entry
argument_list|)
expr_stmt|;
while|while
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|int
name|r
decl_stmt|;
name|struct
name|archive_entry
modifier|*
name|entry2
decl_stmt|;
name|struct
name|archive
modifier|*
name|disk
init|=
name|bsdtar
operator|->
name|diskreader
decl_stmt|;
comment|/* 		 * This tricky code here is to correctly read the cotents 		 * of the entry because the disk reader bsdtar->diskreader 		 * is pointing at does not have any information about the 		 * entry by this time and using archive_read_data_block() 		 * with the disk reader consequently must fail. And we 		 * have to re-open the entry to read the contents. 		 */
comment|/* TODO: Work with -C option as well. */
name|r
operator|=
name|archive_read_disk_open
argument_list|(
name|disk
argument_list|,
name|archive_entry_sourcepath
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|lafe_warnc
argument_list|(
name|archive_errno
argument_list|(
name|disk
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
name|bsdtar
operator|->
name|return_value
operator|=
literal|1
expr_stmt|;
name|archive_entry_free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Invoke archive_read_next_header2() to work 		 * archive_read_data_block(), which is called via write_file(), 		 * without failure. 		 */
name|entry2
operator|=
name|archive_entry_new
argument_list|()
expr_stmt|;
name|r
operator|=
name|archive_read_next_header2
argument_list|(
name|disk
argument_list|,
name|entry2
argument_list|)
expr_stmt|;
name|archive_entry_free
argument_list|(
name|entry2
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|lafe_warnc
argument_list|(
name|archive_errno
argument_list|(
name|disk
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_FATAL
condition|)
name|bsdtar
operator|->
name|return_value
operator|=
literal|1
expr_stmt|;
else|else
name|archive_read_close
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|archive_entry_free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|write_file
argument_list|(
name|bsdtar
argument_list|,
name|a
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|archive_entry_free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|archive_read_close
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|entry
operator|=
name|NULL
expr_stmt|;
name|archive_entry_linkify
argument_list|(
name|bsdtar
operator|->
name|resolver
argument_list|,
operator|&
name|entry
argument_list|,
operator|&
name|sparse_entry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|archive_write_close
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|lafe_warnc
argument_list|(
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|bsdtar
operator|->
name|return_value
operator|=
literal|1
expr_stmt|;
block|}
name|cleanup
label|:
comment|/* Free file data buffer. */
name|free
argument_list|(
name|bsdtar
operator|->
name|buff
argument_list|)
expr_stmt|;
name|archive_entry_linkresolver_free
argument_list|(
name|bsdtar
operator|->
name|resolver
argument_list|)
expr_stmt|;
name|bsdtar
operator|->
name|resolver
operator|=
name|NULL
expr_stmt|;
name|archive_read_free
argument_list|(
name|bsdtar
operator|->
name|diskreader
argument_list|)
expr_stmt|;
name|bsdtar
operator|->
name|diskreader
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bsdtar
operator|->
name|option_totals
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Total bytes written: %s\n"
argument_list|,
name|tar_i64toa
argument_list|(
name|archive_filter_bytes
argument_list|(
name|a
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|archive_write_free
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Archive names specified in file.  *  * Unless --null was specified, a line containing exactly "-C" will  * cause the next line to be a directory to pass to chdir().  If  * --null is specified, then a line "-C" is just another filename.  */
end_comment

begin_function
specifier|static
name|void
name|archive_names_from_file
parameter_list|(
name|struct
name|bsdtar
modifier|*
name|bsdtar
parameter_list|,
name|struct
name|archive
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|lafe_line_reader
modifier|*
name|lr
decl_stmt|;
specifier|const
name|char
modifier|*
name|line
decl_stmt|;
name|bsdtar
operator|->
name|next_line_is_dir
operator|=
literal|0
expr_stmt|;
name|lr
operator|=
name|lafe_line_reader
argument_list|(
name|bsdtar
operator|->
name|names_from_file
argument_list|,
name|bsdtar
operator|->
name|option_null
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|lafe_line_reader_next
argument_list|(
name|lr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|bsdtar
operator|->
name|next_line_is_dir
condition|)
block|{
if|if
condition|(
operator|*
name|line
operator|!=
literal|'\0'
condition|)
name|set_chdir
argument_list|(
name|bsdtar
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
block|{
name|lafe_warnc
argument_list|(
literal|0
argument_list|,
literal|"Meaningless argument for -C: ''"
argument_list|)
expr_stmt|;
name|bsdtar
operator|->
name|return_value
operator|=
literal|1
expr_stmt|;
block|}
name|bsdtar
operator|->
name|next_line_is_dir
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|bsdtar
operator|->
name|option_null
operator|&&
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"-C"
argument_list|)
operator|==
literal|0
condition|)
name|bsdtar
operator|->
name|next_line_is_dir
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|line
operator|!=
literal|'/'
condition|)
name|do_chdir
argument_list|(
name|bsdtar
argument_list|)
expr_stmt|;
comment|/* Handle a deferred -C */
name|write_hierarchy
argument_list|(
name|bsdtar
argument_list|,
name|a
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
name|lafe_line_reader_free
argument_list|(
name|lr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsdtar
operator|->
name|next_line_is_dir
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Unexpected end of filename list; "
literal|"directory expected after -C"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Copy from specified archive to current archive.  Returns non-zero  * for write errors (which force us to terminate the entire archiving  * operation).  If there are errors reading the input archive, we set  * bsdtar->return_value but return zero, so the overall archiving  * operation will complete and return non-zero.  */
end_comment

begin_function
specifier|static
name|int
name|append_archive_filename
parameter_list|(
name|struct
name|bsdtar
modifier|*
name|bsdtar
parameter_list|,
name|struct
name|archive
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|raw_filename
parameter_list|)
block|{
name|struct
name|archive
modifier|*
name|ina
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
init|=
name|raw_filename
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|filename
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|filename
operator|=
name|NULL
expr_stmt|;
comment|/* Library uses NULL for stdio. */
name|ina
operator|=
name|archive_read_new
argument_list|()
expr_stmt|;
name|archive_read_support_format_all
argument_list|(
name|ina
argument_list|)
expr_stmt|;
name|archive_read_support_filter_all
argument_list|(
name|ina
argument_list|)
expr_stmt|;
name|set_reader_options
argument_list|(
name|bsdtar
argument_list|,
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_read_open_filename
argument_list|(
name|ina
argument_list|,
name|filename
argument_list|,
name|bsdtar
operator|->
name|bytes_per_block
argument_list|)
condition|)
block|{
name|lafe_warnc
argument_list|(
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|ina
argument_list|)
argument_list|)
expr_stmt|;
name|bsdtar
operator|->
name|return_value
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|rc
operator|=
name|append_archive
argument_list|(
name|bsdtar
argument_list|,
name|a
argument_list|,
name|ina
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|lafe_warnc
argument_list|(
literal|0
argument_list|,
literal|"Error reading archive %s: %s"
argument_list|,
name|raw_filename
argument_list|,
name|archive_error_string
argument_list|(
name|ina
argument_list|)
argument_list|)
expr_stmt|;
name|bsdtar
operator|->
name|return_value
operator|=
literal|1
expr_stmt|;
block|}
name|archive_read_free
argument_list|(
name|ina
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|append_archive
parameter_list|(
name|struct
name|bsdtar
modifier|*
name|bsdtar
parameter_list|,
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive
modifier|*
name|ina
parameter_list|)
block|{
name|struct
name|archive_entry
modifier|*
name|in_entry
decl_stmt|;
name|int
name|e
decl_stmt|;
while|while
condition|(
name|ARCHIVE_OK
operator|==
operator|(
name|e
operator|=
name|archive_read_next_header
argument_list|(
name|ina
argument_list|,
operator|&
name|in_entry
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|archive_match_excluded
argument_list|(
name|bsdtar
operator|->
name|matching
argument_list|,
name|in_entry
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|bsdtar
operator|->
name|option_interactive
operator|&&
operator|!
name|yes
argument_list|(
literal|"copy '%s'"
argument_list|,
name|archive_entry_pathname
argument_list|(
name|in_entry
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|bsdtar
operator|->
name|verbose
condition|)
name|safe_fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a %s"
argument_list|,
name|archive_entry_pathname
argument_list|(
name|in_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_report
argument_list|()
condition|)
name|report_write
argument_list|(
name|bsdtar
argument_list|,
name|a
argument_list|,
name|in_entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|e
operator|=
name|archive_write_header
argument_list|(
name|a
argument_list|,
name|in_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|!=
name|ARCHIVE_OK
condition|)
block|{
if|if
condition|(
operator|!
name|bsdtar
operator|->
name|verbose
condition|)
name|lafe_warnc
argument_list|(
literal|0
argument_list|,
literal|"%s: %s"
argument_list|,
name|archive_entry_pathname
argument_list|(
name|in_entry
argument_list|)
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": %s"
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|==
name|ARCHIVE_FATAL
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|>=
name|ARCHIVE_WARN
condition|)
block|{
if|if
condition|(
name|archive_entry_size
argument_list|(
name|in_entry
argument_list|)
operator|==
literal|0
condition|)
name|archive_read_data_skip
argument_list|(
name|ina
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|copy_file_data_block
argument_list|(
name|bsdtar
argument_list|,
name|a
argument_list|,
name|ina
argument_list|,
name|in_entry
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bsdtar
operator|->
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|e
operator|==
name|ARCHIVE_EOF
condition|?
name|ARCHIVE_OK
else|:
name|e
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Helper function to copy file to archive. */
end_comment

begin_function
specifier|static
name|int
name|copy_file_data_block
parameter_list|(
name|struct
name|bsdtar
modifier|*
name|bsdtar
parameter_list|,
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive
modifier|*
name|in_a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|size_t
name|bytes_read
decl_stmt|;
name|ssize_t
name|bytes_written
decl_stmt|;
name|int64_t
name|offset
decl_stmt|,
name|progress
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|null_buff
init|=
name|NULL
decl_stmt|;
specifier|const
name|void
modifier|*
name|buff
decl_stmt|;
name|int
name|r
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|archive_read_data_block
argument_list|(
name|in_a
argument_list|,
operator|&
name|buff
argument_list|,
operator|&
name|bytes_read
argument_list|,
operator|&
name|offset
argument_list|)
operator|)
operator|==
name|ARCHIVE_OK
condition|)
block|{
if|if
condition|(
name|need_report
argument_list|()
condition|)
name|report_write
argument_list|(
name|bsdtar
argument_list|,
name|a
argument_list|,
name|entry
argument_list|,
name|progress
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|progress
condition|)
block|{
name|int64_t
name|sparse
init|=
name|offset
operator|-
name|progress
decl_stmt|;
name|size_t
name|ns
decl_stmt|;
if|if
condition|(
name|null_buff
operator|==
name|NULL
condition|)
block|{
name|null_buff
operator|=
name|bsdtar
operator|->
name|buff
expr_stmt|;
name|memset
argument_list|(
name|null_buff
argument_list|,
literal|0
argument_list|,
name|bsdtar
operator|->
name|buff_size
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|sparse
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sparse
operator|>
operator|(
name|int64_t
operator|)
name|bsdtar
operator|->
name|buff_size
condition|)
name|ns
operator|=
name|bsdtar
operator|->
name|buff_size
expr_stmt|;
else|else
name|ns
operator|=
operator|(
name|size_t
operator|)
name|sparse
expr_stmt|;
name|bytes_written
operator|=
name|archive_write_data
argument_list|(
name|a
argument_list|,
name|null_buff
argument_list|,
name|ns
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_written
operator|<
literal|0
condition|)
block|{
comment|/* Write failed; this is bad */
name|lafe_warnc
argument_list|(
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|size_t
operator|)
name|bytes_written
operator|<
name|ns
condition|)
block|{
comment|/* Write was truncated; warn but 					 * continue. */
name|lafe_warnc
argument_list|(
literal|0
argument_list|,
literal|"%s: Truncated write; file may "
literal|"have grown while being archived."
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|progress
operator|+=
name|bytes_written
expr_stmt|;
name|sparse
operator|-=
name|bytes_written
expr_stmt|;
block|}
block|}
name|bytes_written
operator|=
name|archive_write_data
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_written
operator|<
literal|0
condition|)
block|{
comment|/* Write failed; this is bad */
name|lafe_warnc
argument_list|(
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|size_t
operator|)
name|bytes_written
operator|<
name|bytes_read
condition|)
block|{
comment|/* Write was truncated; warn but continue. */
name|lafe_warnc
argument_list|(
literal|0
argument_list|,
literal|"%s: Truncated write; file may have grown "
literal|"while being archived."
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|progress
operator|+=
name|bytes_written
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|<
name|ARCHIVE_WARN
condition|)
block|{
name|lafe_warnc
argument_list|(
name|archive_errno
argument_list|(
name|a
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|excluded_callback
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|void
modifier|*
name|_data
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|bsdtar
modifier|*
name|bsdtar
init|=
operator|(
expr|struct
name|bsdtar
operator|*
operator|)
name|_data
decl_stmt|;
if|if
condition|(
name|bsdtar
operator|->
name|option_no_subdirs
condition|)
return|return;
if|if
condition|(
operator|!
name|archive_read_disk_can_descend
argument_list|(
name|a
argument_list|)
condition|)
return|return;
if|if
condition|(
name|bsdtar
operator|->
name|option_interactive
operator|&&
operator|!
name|yes
argument_list|(
literal|"add '%s'"
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
condition|)
return|return;
name|archive_read_disk_descend
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|metadata_filter
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|void
modifier|*
name|_data
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|bsdtar
modifier|*
name|bsdtar
init|=
operator|(
expr|struct
name|bsdtar
operator|*
operator|)
name|_data
decl_stmt|;
comment|/* XXX TODO: check whether this filesystem is 	 * synthetic and/or local.  Add a new 	 * --local-only option to skip non-local 	 * filesystems.  Skip synthetic filesystems 	 * regardless. 	 * 	 * The results should be cached, since 	 * tree.c doesn't usually visit a directory 	 * and the directory contents together.  A simple 	 * move-to-front list should perform quite well. 	 * 	 * Use archive_read_disk_current_filesystem_is_remote(). 	 */
comment|/* 	 * If the user vetoes this file/directory, skip it. 	 * We want this to be fairly late; if some other 	 * check would veto this file, we shouldn't bother 	 * the user with it. 	 */
if|if
condition|(
name|bsdtar
operator|->
name|option_interactive
operator|&&
operator|!
name|yes
argument_list|(
literal|"add '%s'"
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Note: if user vetoes, we won't descend. */
if|if
condition|(
operator|!
name|bsdtar
operator|->
name|option_no_subdirs
operator|&&
name|archive_read_disk_can_descend
argument_list|(
name|a
argument_list|)
condition|)
name|archive_read_disk_descend
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add the file or dir hierarchy named by 'path' to the archive  */
end_comment

begin_function
specifier|static
name|void
name|write_hierarchy
parameter_list|(
name|struct
name|bsdtar
modifier|*
name|bsdtar
parameter_list|,
name|struct
name|archive
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|archive
modifier|*
name|disk
init|=
name|bsdtar
operator|->
name|diskreader
decl_stmt|;
name|struct
name|archive_entry
modifier|*
name|entry
init|=
name|NULL
decl_stmt|,
modifier|*
name|spare_entry
init|=
name|NULL
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|archive_read_disk_open
argument_list|(
name|disk
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|lafe_warnc
argument_list|(
name|archive_errno
argument_list|(
name|disk
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
name|bsdtar
operator|->
name|return_value
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|bsdtar
operator|->
name|first_fs
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|archive_entry_free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|=
name|archive_entry_new
argument_list|()
expr_stmt|;
name|r
operator|=
name|archive_read_next_header2
argument_list|(
name|disk
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_EOF
condition|)
break|break;
elseif|else
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|lafe_warnc
argument_list|(
name|archive_errno
argument_list|(
name|disk
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_FATAL
condition|)
block|{
name|bsdtar
operator|->
name|return_value
operator|=
literal|1
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|r
operator|<
name|ARCHIVE_WARN
condition|)
continue|continue;
block|}
if|if
condition|(
name|bsdtar
operator|->
name|uid
operator|>=
literal|0
condition|)
block|{
name|archive_entry_set_uid
argument_list|(
name|entry
argument_list|,
name|bsdtar
operator|->
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bsdtar
operator|->
name|uname
condition|)
name|archive_entry_set_uname
argument_list|(
name|entry
argument_list|,
name|archive_read_disk_uname
argument_list|(
name|bsdtar
operator|->
name|diskreader
argument_list|,
name|bsdtar
operator|->
name|uid
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bsdtar
operator|->
name|gid
operator|>=
literal|0
condition|)
block|{
name|archive_entry_set_gid
argument_list|(
name|entry
argument_list|,
name|bsdtar
operator|->
name|gid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bsdtar
operator|->
name|gname
condition|)
name|archive_entry_set_gname
argument_list|(
name|entry
argument_list|,
name|archive_read_disk_gname
argument_list|(
name|bsdtar
operator|->
name|diskreader
argument_list|,
name|bsdtar
operator|->
name|gid
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bsdtar
operator|->
name|uname
condition|)
name|archive_entry_set_uname
argument_list|(
name|entry
argument_list|,
name|bsdtar
operator|->
name|uname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsdtar
operator|->
name|gname
condition|)
name|archive_entry_set_gname
argument_list|(
name|entry
argument_list|,
name|bsdtar
operator|->
name|gname
argument_list|)
expr_stmt|;
comment|/* 		 * Rewrite the pathname to be archived.  If rewrite 		 * fails, skip the entry. 		 */
if|if
condition|(
name|edit_pathname
argument_list|(
name|bsdtar
argument_list|,
name|entry
argument_list|)
condition|)
continue|continue;
comment|/* Display entry as we process it. 		 * This format is required by SUSv2. */
if|if
condition|(
name|bsdtar
operator|->
name|verbose
condition|)
name|safe_fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a %s"
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Non-regular files get archived with zero size. */
if|if
condition|(
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
operator|!=
name|AE_IFREG
condition|)
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|archive_entry_linkify
argument_list|(
name|bsdtar
operator|->
name|resolver
argument_list|,
operator|&
name|entry
argument_list|,
operator|&
name|spare_entry
argument_list|)
expr_stmt|;
while|while
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|write_file
argument_list|(
name|bsdtar
argument_list|,
name|a
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|archive_entry_free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|=
name|spare_entry
expr_stmt|;
name|spare_entry
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|bsdtar
operator|->
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|archive_entry_free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|archive_read_close
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write a single file (or directory or other filesystem object) to  * the archive.  */
end_comment

begin_function
specifier|static
name|void
name|write_file
parameter_list|(
name|struct
name|bsdtar
modifier|*
name|bsdtar
parameter_list|,
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|write_entry
argument_list|(
name|bsdtar
argument_list|,
name|a
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write a single entry to the archive.  */
end_comment

begin_function
specifier|static
name|void
name|write_entry
parameter_list|(
name|struct
name|bsdtar
modifier|*
name|bsdtar
parameter_list|,
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|int
name|e
decl_stmt|;
name|e
operator|=
name|archive_write_header
argument_list|(
name|a
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|!=
name|ARCHIVE_OK
condition|)
block|{
if|if
condition|(
operator|!
name|bsdtar
operator|->
name|verbose
condition|)
name|lafe_warnc
argument_list|(
literal|0
argument_list|,
literal|"%s: %s"
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": %s"
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|==
name|ARCHIVE_FATAL
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * If we opened a file earlier, write it out now.  Note that 	 * the format handler might have reset the size field to zero 	 * to inform us that the archive body won't get stored.  In 	 * that case, just skip the write. 	 */
if|if
condition|(
name|e
operator|>=
name|ARCHIVE_WARN
operator|&&
name|archive_entry_size
argument_list|(
name|entry
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|copy_file_data_block
argument_list|(
name|bsdtar
argument_list|,
name|a
argument_list|,
name|bsdtar
operator|->
name|diskreader
argument_list|,
name|entry
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|report_write
parameter_list|(
name|struct
name|bsdtar
modifier|*
name|bsdtar
parameter_list|,
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|int64_t
name|progress
parameter_list|)
block|{
name|uint64_t
name|comp
decl_stmt|,
name|uncomp
decl_stmt|;
name|int
name|compression
decl_stmt|;
if|if
condition|(
name|bsdtar
operator|->
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|comp
operator|=
name|archive_filter_bytes
argument_list|(
name|a
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|uncomp
operator|=
name|archive_filter_bytes
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In: %d files, %s bytes;"
argument_list|,
name|archive_file_count
argument_list|(
name|a
argument_list|)
argument_list|,
name|tar_i64toa
argument_list|(
name|uncomp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp
operator|>
name|uncomp
condition|)
name|compression
operator|=
literal|0
expr_stmt|;
else|else
name|compression
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|uncomp
operator|-
name|comp
operator|)
operator|*
literal|100
operator|/
name|uncomp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" Out: %s bytes, compression %d%%\n"
argument_list|,
name|tar_i64toa
argument_list|(
name|comp
argument_list|)
argument_list|,
name|compression
argument_list|)
expr_stmt|;
comment|/* Can't have two calls to tar_i64toa() pending, so split the output. */
name|safe_fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Current: %s (%s"
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|tar_i64toa
argument_list|(
name|progress
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"/%s bytes)\n"
argument_list|,
name|tar_i64toa
argument_list|(
name|archive_entry_size
argument_list|(
name|entry
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_for_append
parameter_list|(
name|struct
name|bsdtar
modifier|*
name|bsdtar
parameter_list|)
block|{
name|struct
name|stat
name|s
decl_stmt|;
if|if
condition|(
operator|*
name|bsdtar
operator|->
name|argv
operator|==
name|NULL
operator|&&
name|bsdtar
operator|->
name|names_from_file
operator|==
name|NULL
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"no files or directories specified"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsdtar
operator|->
name|filename
operator|==
name|NULL
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Cannot append to stdout."
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|bsdtar
operator|->
name|filename
argument_list|,
operator|&
name|s
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
operator|&&
operator|!
name|S_ISBLK
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Cannot append to %s: not a regular file."
argument_list|,
name|bsdtar
operator|->
name|filename
argument_list|)
expr_stmt|;
comment|/* Is this an appropriate check here on Windows? */
comment|/* 	if (GetFileType(handle) != FILE_TYPE_DISK) 		lafe_errc(1, 0, "Cannot append"); */
block|}
end_function

end_unit

