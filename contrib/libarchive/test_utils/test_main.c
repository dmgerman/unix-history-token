begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2003-2009 Tim Kientzle  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"test.h"
end_include

begin_include
include|#
directive|include
file|"test_utils.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_IOCTL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ICONV_H
end_ifdef

begin_include
include|#
directive|include
file|<iconv.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Some Linux distributions have both linux/ext2_fs.h and ext2fs/ext2_fs.h.  * As the include guards don't agree, the order of include is important.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LINUX_EXT2_FS_H
end_ifdef

begin_include
include|#
directive|include
file|<linux/ext2_fs.h>
end_include

begin_comment
comment|/* for Linux file flags */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_EXT2FS_EXT2_FS_H
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<ext2fs/ext2_fs.h>
end_include

begin_comment
comment|/* Linux file flags, broken on Cygwin */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LINUX_FS_H
end_ifdef

begin_include
include|#
directive|include
file|<linux/fs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SIGNAL_H
end_ifdef

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SIGNAL_H
end_ifdef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ACL_LIBACL_H
end_ifdef

begin_include
include|#
directive|include
file|<acl/libacl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TYPES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_ACL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/acl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_EA_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ea.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_EXTATTR_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/extattr.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_SYS_XATTR_H
end_if

begin_include
include|#
directive|include
file|<sys/xattr.h>
end_include

begin_elif
elif|#
directive|elif
name|HAVE_ATTR_XATTR_H
end_elif

begin_include
include|#
directive|include
file|<attr/xattr.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_RICHACL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/richacl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_MEMBERSHIP_H
end_if

begin_include
include|#
directive|include
file|<membership.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  * Windows support routines  *  * Note: Configuration is a tricky issue.  Using HAVE_* feature macros  * in the test harness is dangerous because they cover up  * configuration errors.  The classic example of this is omitting a  * configure check.  If libarchive and libarchive_test both look for  * the same feature macro, such errors are hard to detect.  Platform  * macros (e.g., _WIN32 or __GNUC__) are a little better, but can  * easily lead to very messy code.  It's best to limit yourself  * to only the most generic programming techniques in the test harness  * and thus avoid conditionals altogether.  Where that's not possible,  * try to minimize conditionals by grouping platform-specific tests in  * one place (e.g., test_acl_freebsd) or by adding new assert()  * functions (e.g., assertMakeHardlink()) to cover up platform  * differences.  Platform-specific coding in libarchive_test is often  * a symptom that some capability is missing from libarchive itself.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_include
include|#
directive|include
file|<direct.h>
end_include

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|F_OK
end_ifndef

begin_define
define|#
directive|define
name|F_OK
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_ISDIR
end_ifndef

begin_define
define|#
directive|define
name|S_ISDIR
parameter_list|(
name|m
parameter_list|)
value|((m)& _S_IFDIR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_ISREG
end_ifndef

begin_define
define|#
directive|define
name|S_ISREG
parameter_list|(
name|m
parameter_list|)
value|((m)& _S_IFREG)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
end_if

begin_define
define|#
directive|define
name|access
value|_access
end_define

begin_undef
undef|#
directive|undef
name|chdir
end_undef

begin_define
define|#
directive|define
name|chdir
value|_chdir
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|fileno
end_ifndef

begin_define
define|#
directive|define
name|fileno
value|_fileno
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*#define fstat _fstat64*/
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
end_if

begin_define
define|#
directive|define
name|getcwd
value|_getcwd
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|lstat
value|stat
end_define

begin_comment
comment|/*#define lstat _stat64*/
end_comment

begin_comment
comment|/*#define stat _stat64*/
end_comment

begin_define
define|#
directive|define
name|rmdir
value|_rmdir
end_define

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
end_if

begin_define
define|#
directive|define
name|strdup
value|_strdup
end_define

begin_define
define|#
directive|define
name|umask
value|_umask
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|int64_t
value|__int64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE__CrtSetReportMode
argument_list|)
end_if

begin_include
include|#
directive|include
file|<crtdbg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|mode_t
name|umasked
parameter_list|(
name|mode_t
name|expected_mode
parameter_list|)
block|{
name|mode_t
name|mode
init|=
name|umask
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|umask
argument_list|(
name|mode
argument_list|)
expr_stmt|;
return|return
name|expected_mode
operator|&
operator|~
name|mode
return|;
block|}
end_function

begin_comment
comment|/* Path to working directory for current test */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|testworkdir
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PROGRAM
end_ifdef

begin_comment
comment|/* Pathname of exe to be tested. */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|testprogfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of exe to use in printf-formatted command strings. */
end_comment

begin_comment
comment|/* On Windows, this includes leading/trailing quotes. */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|testprog
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
modifier|*
name|GetFunctionKernel32
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|my_CreateSymbolicLinkA
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|my_CreateHardLinkA
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|my_GetFileInformationByName
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|BY_HANDLE_FILE_INFORMATION
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
modifier|*
name|GetFunctionKernel32
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|static
name|HINSTANCE
name|lib
decl_stmt|;
specifier|static
name|int
name|set
decl_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
block|{
name|set
operator|=
literal|1
expr_stmt|;
name|lib
operator|=
name|LoadLibrary
argument_list|(
literal|"kernel32.dll"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lib
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't load kernel32.dll?!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|void
operator|*
operator|)
name|GetProcAddress
argument_list|(
name|lib
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|my_CreateSymbolicLinkA
parameter_list|(
specifier|const
name|char
modifier|*
name|linkname
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
specifier|static
name|BOOLEAN
function_decl|(
name|WINAPI
modifier|*
name|f
function_decl|)
parameter_list|(
name|LPCSTR
parameter_list|,
name|LPCSTR
parameter_list|,
name|DWORD
parameter_list|)
function_decl|;
specifier|static
name|int
name|set
decl_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
block|{
name|set
operator|=
literal|1
expr_stmt|;
name|f
operator|=
name|GetFunctionKernel32
argument_list|(
literal|"CreateSymbolicLinkA"
argument_list|)
expr_stmt|;
block|}
return|return
name|f
operator|==
name|NULL
condition|?
literal|0
else|:
call|(
modifier|*
name|f
call|)
argument_list|(
name|linkname
argument_list|,
name|target
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|my_CreateHardLinkA
parameter_list|(
specifier|const
name|char
modifier|*
name|linkname
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|)
block|{
specifier|static
name|BOOLEAN
function_decl|(
name|WINAPI
modifier|*
name|f
function_decl|)
parameter_list|(
name|LPCSTR
parameter_list|,
name|LPCSTR
parameter_list|,
name|LPSECURITY_ATTRIBUTES
parameter_list|)
function_decl|;
specifier|static
name|int
name|set
decl_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
block|{
name|set
operator|=
literal|1
expr_stmt|;
name|f
operator|=
name|GetFunctionKernel32
argument_list|(
literal|"CreateHardLinkA"
argument_list|)
expr_stmt|;
block|}
return|return
name|f
operator|==
name|NULL
condition|?
literal|0
else|:
call|(
modifier|*
name|f
call|)
argument_list|(
name|linkname
argument_list|,
name|target
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|my_GetFileInformationByName
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|BY_HANDLE_FILE_INFORMATION
modifier|*
name|bhfi
parameter_list|)
block|{
name|HANDLE
name|h
decl_stmt|;
name|int
name|r
decl_stmt|;
name|memset
argument_list|(
name|bhfi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bhfi
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|=
name|CreateFile
argument_list|(
name|path
argument_list|,
name|FILE_READ_ATTRIBUTES
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|OPEN_EXISTING
argument_list|,
name|FILE_FLAG_BACKUP_SEMANTICS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|INVALID_HANDLE_VALUE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|r
operator|=
name|GetFileInformationByHandle
argument_list|(
name|h
argument_list|,
name|bhfi
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE__CrtSetReportMode
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__WATCOMC__
argument_list|)
end_if

begin_function
specifier|static
name|void
name|invalid_parameter_handler
parameter_list|(
specifier|const
name|wchar_t
modifier|*
name|expression
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|function
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|,
name|uintptr_t
name|pReserved
parameter_list|)
block|{
comment|/* nop */
comment|// Silence unused-parameter compiler warnings.
operator|(
name|void
operator|)
name|expression
expr_stmt|;
operator|(
name|void
operator|)
name|function
expr_stmt|;
operator|(
name|void
operator|)
name|file
expr_stmt|;
operator|(
name|void
operator|)
name|line
expr_stmt|;
operator|(
name|void
operator|)
name|pReserved
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  * OPTIONS FLAGS  *  */
end_comment

begin_comment
comment|/* Enable core dump on failure. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dump_on_failure
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default is to remove temp dirs and log data for successful tests. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|keep_temp_files
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default is to run the specified tests once and report errors. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|until_failure
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default is to just report pass/fail for each test. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|verbosity
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|VERBOSITY_SUMMARY_ONLY
value|-1
end_define

begin_comment
comment|/* -q */
end_comment

begin_define
define|#
directive|define
name|VERBOSITY_PASSFAIL
value|0
end_define

begin_comment
comment|/* Default */
end_comment

begin_define
define|#
directive|define
name|VERBOSITY_LIGHT_REPORT
value|1
end_define

begin_comment
comment|/* -v */
end_comment

begin_define
define|#
directive|define
name|VERBOSITY_FULL
value|2
end_define

begin_comment
comment|/* -vv */
end_comment

begin_comment
comment|/* A few places generate even more output for verbosity> VERBOSITY_FULL,  * mostly for debugging the test harness itself. */
end_comment

begin_comment
comment|/* Cumulative count of assertion failures. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|failures
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cumulative count of reported skips. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|skips
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cumulative count of assertions checked. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|assertions
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Directory where uuencoded reference files can be found. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|refdir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Report log information selectively to console and/or disk log.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|log_console
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|logfile
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|vlogprintf
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|va_copy
name|va_list
name|lfap
decl_stmt|;
name|va_copy
argument_list|(
name|lfap
argument_list|,
name|ap
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|log_console
condition|)
name|vfprintf
argument_list|(
name|stdout
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|logfile
operator|!=
name|NULL
condition|)
ifdef|#
directive|ifdef
name|va_copy
name|vfprintf
argument_list|(
name|logfile
argument_list|,
name|fmt
argument_list|,
name|lfap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|lfap
argument_list|)
expr_stmt|;
else|#
directive|else
name|vfprintf
argument_list|(
name|logfile
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|logprintf
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vlogprintf
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up a message to display only if next assertion fails. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|msgbuff
index|[
literal|4096
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|msg
decl_stmt|,
modifier|*
name|nextmsg
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|failure
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|fmt
operator|==
name|NULL
condition|)
block|{
name|nextmsg
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|msgbuff
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|nextmsg
operator|=
name|msgbuff
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Copy arguments into file-local variables.  * This was added to permit vararg assert() functions without needing  * variadic wrapper macros.  Turns out that the vararg capability is almost  * never used, so almost all of the vararg assertions can be simplified  * by removing the vararg capability and reworking the wrapper macro to  * pass __FILE__, __LINE__ directly into the function instead of using  * this hook.  I suspect this machinery is used so rarely that we  * would be better off just removing it entirely.  That would simplify  * the code here noticeably.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|skipping_filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|skipping_line
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|skipping_setup
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|skipping_filename
operator|=
name|filename
expr_stmt|;
name|skipping_line
operator|=
name|line
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called at the beginning of each assert() function. */
end_comment

begin_function
specifier|static
name|void
name|assertion_count
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
operator|(
name|void
operator|)
name|file
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|line
expr_stmt|;
comment|/* UNUSED */
operator|++
name|assertions
expr_stmt|;
comment|/* Proper handling of "failure()" message. */
name|msg
operator|=
name|nextmsg
expr_stmt|;
name|nextmsg
operator|=
name|NULL
expr_stmt|;
comment|/* Uncomment to print file:line after every assertion. 	 * Verbose, but occasionally useful in tracking down crashes. */
comment|/* printf("Checked %s:%d\n", file, line); */
block|}
end_function

begin_comment
comment|/*  * For each test source file, we remember how many times each  * assertion was reported.  Cleared before each new test,  * used by test_summarize().  */
end_comment

begin_struct
specifier|static
struct|struct
name|line
block|{
name|int
name|count
decl_stmt|;
name|int
name|skip
decl_stmt|;
block|}
name|failed_lines
index|[
literal|10000
index|]
struct|;
end_struct

begin_decl_stmt
specifier|const
name|char
modifier|*
name|failed_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count this failure, setup up log destination and handle initial report. */
end_comment

begin_function
specifier|static
name|void
name|failure_start
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
comment|/* Record another failure for this line. */
operator|++
name|failures
expr_stmt|;
name|failed_filename
operator|=
name|filename
expr_stmt|;
name|failed_lines
index|[
name|line
index|]
operator|.
name|count
operator|++
expr_stmt|;
comment|/* Determine whether to log header to console. */
switch|switch
condition|(
name|verbosity
condition|)
block|{
case|case
name|VERBOSITY_LIGHT_REPORT
case|:
name|log_console
operator|=
operator|(
name|failed_lines
index|[
name|line
index|]
operator|.
name|count
operator|<
literal|2
operator|)
expr_stmt|;
break|break;
default|default:
name|log_console
operator|=
operator|(
name|verbosity
operator|>=
name|VERBOSITY_FULL
operator|)
expr_stmt|;
block|}
comment|/* Log file:line header for this failure */
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|#
directive|if
name|_MSC_VER
name|logprintf
argument_list|(
literal|"%s(%d): "
argument_list|,
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|#
directive|else
name|logprintf
argument_list|(
literal|"%s:%d: "
argument_list|,
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vlogprintf
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
name|NULL
operator|&&
name|msg
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|logprintf
argument_list|(
literal|"   Description: %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|msg
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Determine whether to log details to console. */
if|if
condition|(
name|verbosity
operator|==
name|VERBOSITY_LIGHT_REPORT
condition|)
name|log_console
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Complete reporting of failed tests. */
end_comment

begin_comment
comment|/*  * The 'extra' hook here is used by libarchive to include libarchive  * error messages with assertion failures.  It could also be used  * to add strerror() output, for example.  Just define the EXTRA_DUMP()  * macro appropriately.  */
end_comment

begin_function
specifier|static
name|void
name|failure_finish
parameter_list|(
name|void
modifier|*
name|extra
parameter_list|)
block|{
operator|(
name|void
operator|)
name|extra
expr_stmt|;
comment|/* UNUSED (maybe) */
ifdef|#
directive|ifdef
name|EXTRA_DUMP
if|if
condition|(
name|extra
operator|!=
name|NULL
condition|)
block|{
name|logprintf
argument_list|(
literal|"    errno: %d\n"
argument_list|,
name|EXTRA_ERRNO
argument_list|(
name|extra
argument_list|)
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"   detail: %s\n"
argument_list|,
name|EXTRA_DUMP
argument_list|(
name|extra
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|dump_on_failure
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" *** forcing core dump so failure can be debugged ***\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Inform user that we're skipping some checks. */
end_comment

begin_function
name|void
name|test_skipping
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|buff
index|[
literal|1024
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|buff
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
comment|/* Use failure() message if set. */
name|msg
operator|=
name|nextmsg
expr_stmt|;
name|nextmsg
operator|=
name|NULL
expr_stmt|;
comment|/* failure_start() isn't quite right, but is awfully convenient. */
name|failure_start
argument_list|(
name|skipping_filename
argument_list|,
name|skipping_line
argument_list|,
literal|"SKIPPING: %s"
argument_list|,
name|buff
argument_list|)
expr_stmt|;
operator|--
name|failures
expr_stmt|;
comment|/* Undo failures++ in failure_start() */
comment|/* Don't failure_finish() here. */
comment|/* Mark as skip, so doesn't count as failed test. */
name|failed_lines
index|[
name|skipping_line
index|]
operator|.
name|skip
operator|=
literal|1
expr_stmt|;
operator|++
name|skips
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  * ASSERTIONS  *  */
end_comment

begin_comment
comment|/* Generic assert() just displays the failed condition. */
end_comment

begin_function
name|int
name|assertion_assert
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|condition
parameter_list|,
name|void
modifier|*
name|extra
parameter_list|)
block|{
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Assertion failed: %s"
argument_list|,
name|condition
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|extra
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/* chdir() and report any errors */
end_comment

begin_function
name|int
name|assertion_chdir
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|)
block|{
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|pathname
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"chdir(\"%s\")"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Verify two integers are equal. */
end_comment

begin_function
name|int
name|assertion_equal_int
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
name|long
name|long
name|v1
parameter_list|,
specifier|const
name|char
modifier|*
name|e1
parameter_list|,
name|long
name|long
name|v2
parameter_list|,
specifier|const
name|char
modifier|*
name|e2
parameter_list|,
name|void
modifier|*
name|extra
parameter_list|)
block|{
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|v1
operator|==
name|v2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"%s != %s"
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"      %s=%lld (0x%llx, 0%llo)\n"
argument_list|,
name|e1
argument_list|,
name|v1
argument_list|,
name|v1
argument_list|,
name|v1
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"      %s=%lld (0x%llx, 0%llo)\n"
argument_list|,
name|e2
argument_list|,
name|v2
argument_list|,
name|v2
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|extra
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Utility to convert a single UTF-8 sequence.  */
end_comment

begin_function
specifier|static
name|int
name|_utf8_to_unicode
parameter_list|(
name|uint32_t
modifier|*
name|pwc
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|utf8_count
index|[
literal|256
index|]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 00 - 0F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 10 - 1F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 20 - 2F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 30 - 3F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 40 - 4F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 50 - 5F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 60 - 6F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 70 - 7F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 80 - 8F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 90 - 9F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* A0 - AF */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* B0 - BF */
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
comment|/* C0 - CF */
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
comment|/* D0 - DF */
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
comment|/* E0 - EF */
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
comment|/* F0 - FF */
block|}
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|uint32_t
name|wc
decl_stmt|;
operator|*
name|pwc
operator|=
literal|0
expr_stmt|;
comment|/* Sanity check. */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Decode 1-4 bytes depending on the value of the first byte. 	 */
name|ch
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Standard:  return 0 for end-of-string. */
name|cnt
operator|=
name|utf8_count
index|[
name|ch
index|]
expr_stmt|;
comment|/* Invalid sequence or there are not plenty bytes. */
if|if
condition|(
name|n
operator|<
operator|(
name|size_t
operator|)
name|cnt
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Make a Unicode code point from a single UTF-8 sequence. */
switch|switch
condition|(
name|cnt
condition|)
block|{
case|case
literal|1
case|:
comment|/* 1 byte sequence. */
operator|*
name|pwc
operator|=
name|ch
operator|&
literal|0x7f
expr_stmt|;
return|return
operator|(
name|cnt
operator|)
return|;
case|case
literal|2
case|:
comment|/* 2 bytes sequence. */
if|if
condition|(
operator|(
name|s
index|[
literal|1
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|pwc
operator|=
operator|(
operator|(
name|ch
operator|&
literal|0x1f
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|s
index|[
literal|1
index|]
operator|&
literal|0x3f
operator|)
expr_stmt|;
return|return
operator|(
name|cnt
operator|)
return|;
case|case
literal|3
case|:
comment|/* 3 bytes sequence. */
if|if
condition|(
operator|(
name|s
index|[
literal|1
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|s
index|[
literal|2
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|wc
operator|=
operator|(
operator|(
name|ch
operator|&
literal|0x0f
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
name|s
index|[
literal|1
index|]
operator|&
literal|0x3f
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|s
index|[
literal|2
index|]
operator|&
literal|0x3f
operator|)
expr_stmt|;
if|if
condition|(
name|wc
operator|<
literal|0x800
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Overlong sequence. */
break|break;
case|case
literal|4
case|:
comment|/* 4 bytes sequence. */
if|if
condition|(
name|n
operator|<
literal|4
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|s
index|[
literal|1
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|s
index|[
literal|2
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|s
index|[
literal|3
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|wc
operator|=
operator|(
operator|(
name|ch
operator|&
literal|0x07
operator|)
operator|<<
literal|18
operator|)
operator||
operator|(
operator|(
name|s
index|[
literal|1
index|]
operator|&
literal|0x3f
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
name|s
index|[
literal|2
index|]
operator|&
literal|0x3f
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|s
index|[
literal|3
index|]
operator|&
literal|0x3f
operator|)
expr_stmt|;
if|if
condition|(
name|wc
operator|<
literal|0x10000
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Overlong sequence. */
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* The code point larger than 0x10FFFF is not legal 	 * Unicode values. */
if|if
condition|(
name|wc
operator|>
literal|0x10FFFF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Correctly gets a Unicode, returns used bytes. */
operator|*
name|pwc
operator|=
name|wc
expr_stmt|;
return|return
operator|(
name|cnt
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|strdump
parameter_list|(
specifier|const
name|char
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|int
name|ewidth
parameter_list|,
name|int
name|utf8
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|q
init|=
name|p
decl_stmt|;
name|logprintf
argument_list|(
literal|"      %*s = "
argument_list|,
name|ewidth
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|logprintf
argument_list|(
literal|"NULL\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|logprintf
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|unsigned
name|int
name|c
init|=
literal|0xff
operator|&
operator|*
name|p
operator|++
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\a'
case|:
name|logprintf
argument_list|(
literal|"\\a"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|logprintf
argument_list|(
literal|"\\b"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|logprintf
argument_list|(
literal|"\\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|logprintf
argument_list|(
literal|"\\r"
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|c
operator|>=
literal|32
operator|&&
name|c
operator|<
literal|127
condition|)
name|logprintf
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|logprintf
argument_list|(
literal|"\\x%02X"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
name|logprintf
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|" (length %d)"
argument_list|,
name|q
operator|==
name|NULL
condition|?
operator|-
literal|1
else|:
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the current string is UTF-8, dump its code points. 	 */
if|if
condition|(
name|utf8
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|uint32_t
name|uc
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|p
operator|=
name|q
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|" ["
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|_utf8_to_unicode
argument_list|(
operator|&
name|uc
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|!=
name|q
condition|)
name|logprintf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"%04X"
argument_list|,
name|uc
argument_list|)
expr_stmt|;
name|p
operator|+=
name|n
expr_stmt|;
name|len
operator|-=
name|n
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
name|logprintf
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|" (count %d"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|logprintf
argument_list|(
literal|",unknown %d bytes"
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|logprintf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|logprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Verify two strings are equal, dump them if not. */
end_comment

begin_function
name|int
name|assertion_equal_string
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|v1
parameter_list|,
specifier|const
name|char
modifier|*
name|e1
parameter_list|,
specifier|const
name|char
modifier|*
name|v2
parameter_list|,
specifier|const
name|char
modifier|*
name|e2
parameter_list|,
name|void
modifier|*
name|extra
parameter_list|,
name|int
name|utf8
parameter_list|)
block|{
name|int
name|l1
decl_stmt|,
name|l2
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|v1
operator|==
name|v2
operator|||
operator|(
name|v1
operator|!=
name|NULL
operator|&&
name|v2
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"%s != %s"
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|)
expr_stmt|;
name|l1
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|l2
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|e2
argument_list|)
expr_stmt|;
if|if
condition|(
name|l1
operator|<
name|l2
condition|)
name|l1
operator|=
name|l2
expr_stmt|;
name|strdump
argument_list|(
name|e1
argument_list|,
name|v1
argument_list|,
name|l1
argument_list|,
name|utf8
argument_list|)
expr_stmt|;
name|strdump
argument_list|(
name|e2
argument_list|,
name|v2
argument_list|,
name|l1
argument_list|,
name|utf8
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|extra
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wcsdump
parameter_list|(
specifier|const
name|char
modifier|*
name|e
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|w
parameter_list|)
block|{
name|logprintf
argument_list|(
literal|"      %s = "
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
condition|)
block|{
name|logprintf
argument_list|(
literal|"(null)"
argument_list|)
expr_stmt|;
return|return;
block|}
name|logprintf
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|w
operator|!=
literal|L'
expr|\0'
condition|)
block|{
name|unsigned
name|int
name|c
init|=
operator|*
name|w
operator|++
decl_stmt|;
if|if
condition|(
name|c
operator|>=
literal|32
operator|&&
name|c
operator|<
literal|127
condition|)
name|logprintf
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
literal|256
condition|)
name|logprintf
argument_list|(
literal|"\\x%02X"
argument_list|,
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
literal|0x10000
condition|)
name|logprintf
argument_list|(
literal|"\\u%04X"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|logprintf
argument_list|(
literal|"\\U%08X"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|logprintf
argument_list|(
literal|"\"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_WCSCMP
end_ifndef

begin_function
specifier|static
name|int
name|wcscmp
parameter_list|(
specifier|const
name|wchar_t
modifier|*
name|s1
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|s2
parameter_list|)
block|{
while|while
condition|(
operator|*
name|s1
operator|==
operator|*
name|s2
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|s1
operator|++
operator|==
literal|L'
expr|\0'
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|*
name|s1
operator|>
operator|*
operator|--
name|s2
condition|)
return|return
literal|1
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Verify that two wide strings are equal, dump them if not. */
end_comment

begin_function
name|int
name|assertion_equal_wstring
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|v1
parameter_list|,
specifier|const
name|char
modifier|*
name|e1
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|v2
parameter_list|,
specifier|const
name|char
modifier|*
name|e2
parameter_list|,
name|void
modifier|*
name|extra
parameter_list|)
block|{
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|v1
operator|==
name|v2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|v1
operator|!=
name|NULL
operator|&&
name|v2
operator|!=
name|NULL
operator|&&
name|wcscmp
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"%s != %s"
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|)
expr_stmt|;
name|wcsdump
argument_list|(
name|e1
argument_list|,
name|v1
argument_list|)
expr_stmt|;
name|wcsdump
argument_list|(
name|e2
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|extra
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pretty standard hexdump routine.  As a bonus, if ref != NULL, then  * any bytes in p that differ from ref will be highlighted with '_'  * before and after the hex value.  */
end_comment

begin_function
specifier|static
name|void
name|hexdump
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|ref
parameter_list|,
name|size_t
name|l
parameter_list|,
name|size_t
name|offset
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
name|sep
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|logprintf
argument_list|(
literal|"(null)\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|+=
literal|16
control|)
block|{
name|logprintf
argument_list|(
literal|"%04x"
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|i
operator|+
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|' '
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
operator|&&
name|i
operator|+
name|j
operator|<
name|l
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|ref
operator|!=
name|NULL
operator|&&
name|p
index|[
name|i
operator|+
name|j
index|]
operator|!=
name|ref
index|[
name|i
operator|+
name|j
index|]
condition|)
name|sep
operator|=
literal|'_'
expr_stmt|;
name|logprintf
argument_list|(
literal|"%c%02x"
argument_list|,
name|sep
argument_list|,
literal|0xff
operator|&
operator|(
name|int
operator|)
name|p
index|[
name|i
operator|+
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref
operator|!=
name|NULL
operator|&&
name|p
index|[
name|i
operator|+
name|j
index|]
operator|==
name|ref
index|[
name|i
operator|+
name|j
index|]
condition|)
name|sep
operator|=
literal|' '
expr_stmt|;
block|}
for|for
control|(
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
block|{
name|logprintf
argument_list|(
literal|"%c  "
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|' '
expr_stmt|;
block|}
name|logprintf
argument_list|(
literal|"%c"
argument_list|,
name|sep
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
operator|&&
name|i
operator|+
name|j
operator|<
name|l
condition|;
name|j
operator|++
control|)
block|{
name|int
name|c
init|=
name|p
index|[
name|i
operator|+
name|j
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|<=
literal|126
condition|)
name|logprintf
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|logprintf
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
name|logprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Verify that two blocks of memory are the same, display the first  * block of differences if they're not. */
end_comment

begin_function
name|int
name|assertion_equal_mem
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|void
modifier|*
name|_v1
parameter_list|,
specifier|const
name|char
modifier|*
name|e1
parameter_list|,
specifier|const
name|void
modifier|*
name|_v2
parameter_list|,
specifier|const
name|char
modifier|*
name|e2
parameter_list|,
name|size_t
name|l
parameter_list|,
specifier|const
name|char
modifier|*
name|ld
parameter_list|,
name|void
modifier|*
name|extra
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|v1
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|_v1
decl_stmt|;
specifier|const
name|char
modifier|*
name|v2
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|_v2
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|v1
operator|==
name|v2
operator|||
operator|(
name|v1
operator|!=
name|NULL
operator|&&
name|v2
operator|!=
name|NULL
operator|&&
name|memcmp
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|,
name|l
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|v1
operator|==
name|NULL
operator|||
name|v2
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"%s != %s"
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"      size %s = %d\n"
argument_list|,
name|ld
argument_list|,
operator|(
name|int
operator|)
name|l
argument_list|)
expr_stmt|;
comment|/* Dump 48 bytes (3 lines) so that the first difference is 	 * in the second line. */
name|offset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|l
operator|>
literal|64
operator|&&
name|memcmp
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|,
literal|32
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Two lines agree, so step forward one line. */
name|v1
operator|+=
literal|16
expr_stmt|;
name|v2
operator|+=
literal|16
expr_stmt|;
name|l
operator|-=
literal|16
expr_stmt|;
name|offset
operator|+=
literal|16
expr_stmt|;
block|}
name|logprintf
argument_list|(
literal|"      Dump of %s\n"
argument_list|,
name|e1
argument_list|)
expr_stmt|;
name|hexdump
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|,
name|l
operator|<
literal|128
condition|?
name|l
else|:
literal|128
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"      Dump of %s\n"
argument_list|,
name|e2
argument_list|)
expr_stmt|;
name|hexdump
argument_list|(
name|v2
argument_list|,
name|v1
argument_list|,
name|l
operator|<
literal|128
condition|?
name|l
else|:
literal|128
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|extra
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Verify that a block of memory is filled with the specified byte. */
end_comment

begin_function
name|int
name|assertion_memory_filled_with
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|void
modifier|*
name|_v1
parameter_list|,
specifier|const
name|char
modifier|*
name|vd
parameter_list|,
name|size_t
name|l
parameter_list|,
specifier|const
name|char
modifier|*
name|ld
parameter_list|,
name|char
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|bd
parameter_list|,
name|void
modifier|*
name|extra
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|v1
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|_v1
decl_stmt|;
name|size_t
name|c
init|=
literal|0
decl_stmt|;
name|size_t
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|ld
expr_stmt|;
comment|/* UNUSED */
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|v1
index|[
name|i
index|]
operator|==
name|b
condition|)
block|{
operator|++
name|c
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|==
name|l
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"%s (size %d) not filled with %s"
argument_list|,
name|vd
argument_list|,
operator|(
name|int
operator|)
name|l
argument_list|,
name|bd
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"   Only %d bytes were correct\n"
argument_list|,
operator|(
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|extra
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Verify that the named file exists and is empty. */
end_comment

begin_function
name|int
name|assertion_empty_file
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|f1
parameter_list|)
block|{
name|char
name|buff
index|[
literal|1024
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|ssize_t
name|s
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|assertion_count
argument_list|(
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|f1
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|filename
argument_list|,
name|line
argument_list|,
literal|"Stat failed: %s"
argument_list|,
name|f1
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|st
operator|.
name|st_size
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|failure_start
argument_list|(
name|filename
argument_list|,
name|line
argument_list|,
literal|"File should be empty: %s"
argument_list|,
name|f1
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"    File size: %d\n"
argument_list|,
operator|(
name|int
operator|)
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"    Contents:\n"
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|f1
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|logprintf
argument_list|(
literal|"    Unable to open %s\n"
argument_list|,
name|f1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
operator|(
operator|(
name|off_t
operator|)
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
operator|<
name|st
operator|.
name|st_size
operator|)
condition|?
operator|(
name|ssize_t
operator|)
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
else|:
operator|(
name|ssize_t
operator|)
name|st
operator|.
name|st_size
expr_stmt|;
name|s
operator|=
name|fread
argument_list|(
name|buff
argument_list|,
literal|1
argument_list|,
name|s
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|hexdump
argument_list|(
name|buff
argument_list|,
name|NULL
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Verify that the named file exists and is not empty. */
end_comment

begin_function
name|int
name|assertion_non_empty_file
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|f1
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|assertion_count
argument_list|(
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|f1
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|filename
argument_list|,
name|line
argument_list|,
literal|"Stat failed: %s"
argument_list|,
name|f1
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|st
operator|.
name|st_size
operator|==
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|filename
argument_list|,
name|line
argument_list|,
literal|"File empty: %s"
argument_list|,
name|f1
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Verify that two files have the same contents. */
end_comment

begin_comment
comment|/* TODO: hexdump the first bytes that actually differ. */
end_comment

begin_function
name|int
name|assertion_equal_file
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|fn1
parameter_list|,
specifier|const
name|char
modifier|*
name|fn2
parameter_list|)
block|{
name|char
name|buff1
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|buff2
index|[
literal|1024
index|]
decl_stmt|;
name|FILE
modifier|*
name|f1
decl_stmt|,
modifier|*
name|f2
decl_stmt|;
name|int
name|n1
decl_stmt|,
name|n2
decl_stmt|;
name|assertion_count
argument_list|(
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|f1
operator|=
name|fopen
argument_list|(
name|fn1
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
name|f2
operator|=
name|fopen
argument_list|(
name|fn2
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f1
operator|==
name|NULL
operator|||
name|f2
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|f1
condition|)
name|fclose
argument_list|(
name|f1
argument_list|)
expr_stmt|;
if|if
condition|(
name|f2
condition|)
name|fclose
argument_list|(
name|f2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|n1
operator|=
operator|(
name|int
operator|)
name|fread
argument_list|(
name|buff1
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buff1
argument_list|)
argument_list|,
name|f1
argument_list|)
expr_stmt|;
name|n2
operator|=
operator|(
name|int
operator|)
name|fread
argument_list|(
name|buff2
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buff2
argument_list|)
argument_list|,
name|f2
argument_list|)
expr_stmt|;
if|if
condition|(
name|n1
operator|!=
name|n2
condition|)
break|break;
if|if
condition|(
name|n1
operator|==
literal|0
operator|&&
name|n2
operator|==
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|f1
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|buff1
argument_list|,
name|buff2
argument_list|,
name|n1
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
name|fclose
argument_list|(
name|f1
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f2
argument_list|)
expr_stmt|;
name|failure_start
argument_list|(
name|filename
argument_list|,
name|line
argument_list|,
literal|"Files not identical"
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"  file1=\"%s\"\n"
argument_list|,
name|fn1
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"  file2=\"%s\"\n"
argument_list|,
name|fn2
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Verify that the named file does exist. */
end_comment

begin_function
name|int
name|assertion_file_exists
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|f
parameter_list|)
block|{
name|assertion_count
argument_list|(
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
if|if
condition|(
operator|!
name|_access
argument_list|(
name|f
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
if|if
condition|(
operator|!
name|access
argument_list|(
name|f
argument_list|,
name|F_OK
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
name|failure_start
argument_list|(
name|filename
argument_list|,
name|line
argument_list|,
literal|"File should exist: %s"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Verify that the named file doesn't exist. */
end_comment

begin_function
name|int
name|assertion_file_not_exists
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|f
parameter_list|)
block|{
name|assertion_count
argument_list|(
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
if|if
condition|(
name|_access
argument_list|(
name|f
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
if|if
condition|(
name|access
argument_list|(
name|f
argument_list|,
name|F_OK
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
name|failure_start
argument_list|(
name|filename
argument_list|,
name|line
argument_list|,
literal|"File should not exist: %s"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Compare the contents of a file to a block of memory. */
end_comment

begin_function
name|int
name|assertion_file_contents
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|int
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
name|char
modifier|*
name|contents
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|n
decl_stmt|;
name|assertion_count
argument_list|(
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|fn
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|failure_start
argument_list|(
name|filename
argument_list|,
name|line
argument_list|,
literal|"File should exist: %s"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|contents
operator|=
name|malloc
argument_list|(
name|s
operator|*
literal|2
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
name|int
operator|)
name|fread
argument_list|(
name|contents
argument_list|,
literal|1
argument_list|,
name|s
operator|*
literal|2
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|s
operator|&&
name|memcmp
argument_list|(
name|buff
argument_list|,
name|contents
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|failure_start
argument_list|(
name|filename
argument_list|,
name|line
argument_list|,
literal|"File contents don't match"
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"  file=\"%s\"\n"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|hexdump
argument_list|(
name|contents
argument_list|,
name|buff
argument_list|,
name|n
operator|>
literal|512
condition|?
literal|512
else|:
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|logprintf
argument_list|(
literal|"  File empty, contents should be:\n"
argument_list|)
expr_stmt|;
name|hexdump
argument_list|(
name|buff
argument_list|,
name|NULL
argument_list|,
name|s
operator|>
literal|512
condition|?
literal|512
else|:
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Check the contents of a text file, being tolerant of line endings. */
end_comment

begin_function
name|int
name|assertion_text_file_contents
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|buff
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
name|char
modifier|*
name|contents
decl_stmt|;
specifier|const
name|char
modifier|*
name|btxt
decl_stmt|,
modifier|*
name|ftxt
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|n
decl_stmt|,
name|s
decl_stmt|;
name|assertion_count
argument_list|(
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|fn
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|failure_start
argument_list|(
name|filename
argument_list|,
name|line
argument_list|,
literal|"File doesn't exist: %s"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|s
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|contents
operator|=
name|malloc
argument_list|(
name|s
operator|*
literal|2
operator|+
literal|128
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
name|int
operator|)
name|fread
argument_list|(
name|contents
argument_list|,
literal|1
argument_list|,
name|s
operator|*
literal|2
operator|+
literal|128
operator|-
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
name|contents
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* Compare texts. */
name|btxt
operator|=
name|buff
expr_stmt|;
name|ftxt
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|contents
expr_stmt|;
while|while
condition|(
operator|*
name|btxt
operator|!=
literal|'\0'
operator|&&
operator|*
name|ftxt
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|btxt
operator|==
operator|*
name|ftxt
condition|)
block|{
operator|++
name|btxt
expr_stmt|;
operator|++
name|ftxt
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|btxt
index|[
literal|0
index|]
operator|==
literal|'\n'
operator|&&
name|ftxt
index|[
literal|0
index|]
operator|==
literal|'\r'
operator|&&
name|ftxt
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
comment|/* Pass over different new line characters. */
operator|++
name|btxt
expr_stmt|;
name|ftxt
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
if|if
condition|(
operator|*
name|btxt
operator|==
literal|'\0'
operator|&&
operator|*
name|ftxt
operator|==
literal|'\0'
condition|)
block|{
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|failure_start
argument_list|(
name|filename
argument_list|,
name|line
argument_list|,
literal|"Contents don't match"
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"  file=\"%s\"\n"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|hexdump
argument_list|(
name|contents
argument_list|,
name|buff
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"  expected\n"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|hexdump
argument_list|(
name|buff
argument_list|,
name|contents
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logprintf
argument_list|(
literal|"  File empty, contents should be:\n"
argument_list|)
expr_stmt|;
name|hexdump
argument_list|(
name|buff
argument_list|,
name|NULL
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Verify that a text file contains the specified lines, regardless of order */
end_comment

begin_comment
comment|/* This could be more efficient if we sorted both sets of lines, etc, but  * since this is used only for testing and only ever deals with a dozen or so  * lines at a time, this relatively crude approach is just fine. */
end_comment

begin_function
name|int
name|assertion_file_contains_lines_any_order
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
specifier|const
name|char
modifier|*
name|lines
index|[]
parameter_list|)
block|{
name|char
modifier|*
name|buff
decl_stmt|;
name|size_t
name|buff_size
decl_stmt|;
name|size_t
name|expected_count
decl_stmt|,
name|actual_count
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
modifier|*
name|expected
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|actual
init|=
name|NULL
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|expected_failure
init|=
literal|0
decl_stmt|,
name|actual_failure
init|=
literal|0
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|buff
operator|=
name|slurpfile
argument_list|(
operator|&
name|buff_size
argument_list|,
literal|"%s"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|buff
operator|==
name|NULL
condition|)
block|{
name|failure_start
argument_list|(
name|pathname
argument_list|,
name|line
argument_list|,
literal|"Can't read file: %s"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Make a copy of the provided lines and count up the expected 	 * file size. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|lines
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{ 	}
name|expected_count
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|expected_count
condition|)
block|{
name|expected
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|expected_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|expected
operator|==
name|NULL
condition|)
block|{
name|failure_start
argument_list|(
name|pathname
argument_list|,
name|line
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|expected
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buff
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|lines
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
name|expected
index|[
name|i
index|]
operator|=
name|strdup
argument_list|(
name|lines
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Break the file into lines */
name|actual_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|'\0'
operator|,
name|p
operator|=
name|buff
init|;
name|p
operator|<
name|buff
operator|+
name|buff_size
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\x0d'
operator|||
operator|*
name|p
operator|==
literal|'\x0a'
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
operator|++
name|actual_count
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
block|}
if|if
condition|(
name|actual_count
condition|)
block|{
name|actual
operator|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|actual_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|actual
operator|==
name|NULL
condition|)
block|{
name|failure_start
argument_list|(
name|pathname
argument_list|,
name|line
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|expected
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buff
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|p
operator|=
name|buff
init|;
name|p
operator|<
name|buff
operator|+
name|buff_size
condition|;
name|p
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|actual
index|[
name|j
index|]
operator|=
name|p
expr_stmt|;
operator|++
name|j
expr_stmt|;
block|}
block|}
block|}
comment|/* Erase matching lines from both lists */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|expected_count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|expected
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|actual_count
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|actual
index|[
name|j
index|]
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|expected
index|[
name|i
index|]
argument_list|,
name|actual
index|[
name|j
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|expected
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|expected
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|actual
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* If there's anything left, it's a failure */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|expected_count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|expected
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
operator|++
name|expected_failure
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|actual_count
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|actual
index|[
name|j
index|]
operator|!=
name|NULL
condition|)
operator|++
name|actual_failure
expr_stmt|;
block|}
if|if
condition|(
name|expected_failure
operator|==
literal|0
operator|&&
name|actual_failure
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|expected
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|actual
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File doesn't match: %s"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|expected_count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|expected
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|logprintf
argument_list|(
literal|"  Expected but not present: %s\n"
argument_list|,
name|expected
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|expected
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|actual_count
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|actual
index|[
name|j
index|]
operator|!=
name|NULL
condition|)
name|logprintf
argument_list|(
literal|"  Present but not expected: %s\n"
argument_list|,
name|actual
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|expected
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|actual
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Verify that a text file does not contains the specified strings */
end_comment

begin_function
name|int
name|assertion_file_contains_no_invalid_strings
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
specifier|const
name|char
modifier|*
name|strings
index|[]
parameter_list|)
block|{
name|char
modifier|*
name|buff
decl_stmt|;
name|int
name|i
decl_stmt|;
name|buff
operator|=
name|slurpfile
argument_list|(
name|NULL
argument_list|,
literal|"%s"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|buff
operator|==
name|NULL
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Can't read file: %s"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|strings
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|strstr
argument_list|(
name|buff
argument_list|,
name|strings
index|[
name|i
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Invalid string in %s: %s"
argument_list|,
name|pathname
argument_list|,
name|strings
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buff
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|free
argument_list|(
name|buff
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Test that two paths point to the same file. */
end_comment

begin_comment
comment|/* As a side-effect, asserts that both files exist. */
end_comment

begin_function
specifier|static
name|int
name|is_hardlink
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|path1
parameter_list|,
specifier|const
name|char
modifier|*
name|path2
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
name|BY_HANDLE_FILE_INFORMATION
name|bhfi1
decl_stmt|,
name|bhfi2
decl_stmt|;
name|int
name|r
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|r
operator|=
name|my_GetFileInformationByName
argument_list|(
name|path1
argument_list|,
operator|&
name|bhfi1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File %s can't be inspected?"
argument_list|,
name|path1
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|r
operator|=
name|my_GetFileInformationByName
argument_list|(
name|path2
argument_list|,
operator|&
name|bhfi2
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File %s can't be inspected?"
argument_list|,
name|path2
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|bhfi1
operator|.
name|dwVolumeSerialNumber
operator|==
name|bhfi2
operator|.
name|dwVolumeSerialNumber
operator|&&
name|bhfi1
operator|.
name|nFileIndexHigh
operator|==
name|bhfi2
operator|.
name|nFileIndexHigh
operator|&&
name|bhfi1
operator|.
name|nFileIndexLow
operator|==
name|bhfi2
operator|.
name|nFileIndexLow
operator|)
return|;
else|#
directive|else
name|struct
name|stat
name|st1
decl_stmt|,
name|st2
decl_stmt|;
name|int
name|r
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|r
operator|=
name|lstat
argument_list|(
name|path1
argument_list|,
operator|&
name|st1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File should exist: %s"
argument_list|,
name|path1
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|r
operator|=
name|lstat
argument_list|(
name|path2
argument_list|,
operator|&
name|st2
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File should exist: %s"
argument_list|,
name|path2
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|st1
operator|.
name|st_ino
operator|==
name|st2
operator|.
name|st_ino
operator|&&
name|st1
operator|.
name|st_dev
operator|==
name|st2
operator|.
name|st_dev
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|assertion_is_hardlink
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|path1
parameter_list|,
specifier|const
name|char
modifier|*
name|path2
parameter_list|)
block|{
if|if
condition|(
name|is_hardlink
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|path1
argument_list|,
name|path2
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Files %s and %s are not hardlinked"
argument_list|,
name|path1
argument_list|,
name|path2
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|assertion_is_not_hardlink
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|path1
parameter_list|,
specifier|const
name|char
modifier|*
name|path2
parameter_list|)
block|{
if|if
condition|(
operator|!
name|is_hardlink
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|path1
argument_list|,
name|path2
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Files %s and %s should not be hardlinked"
argument_list|,
name|path1
argument_list|,
name|path2
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Verify a/b/mtime of 'pathname'. */
end_comment

begin_comment
comment|/* If 'recent', verify that it's within last 10 seconds. */
end_comment

begin_function
specifier|static
name|int
name|assertion_file_time
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|long
name|t
parameter_list|,
name|long
name|nsec
parameter_list|,
name|char
name|type
parameter_list|,
name|int
name|recent
parameter_list|)
block|{
name|long
name|long
name|filet
decl_stmt|,
name|filet_nsec
decl_stmt|;
name|int
name|r
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
define|#
directive|define
name|EPOC_TIME
value|(116444736000000000ULL)
name|FILETIME
name|fxtime
decl_stmt|,
name|fbirthtime
decl_stmt|,
name|fatime
decl_stmt|,
name|fmtime
decl_stmt|;
name|ULARGE_INTEGER
name|wintm
decl_stmt|;
name|HANDLE
name|h
decl_stmt|;
name|fxtime
operator|.
name|dwLowDateTime
operator|=
literal|0
expr_stmt|;
name|fxtime
operator|.
name|dwHighDateTime
operator|=
literal|0
expr_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* Note: FILE_FLAG_BACKUP_SEMANTICS applies to open 	 * a directory file. If not, CreateFile() will fail when 	 * the pathname is a directory. */
name|h
operator|=
name|CreateFile
argument_list|(
name|pathname
argument_list|,
name|FILE_READ_ATTRIBUTES
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|OPEN_EXISTING
argument_list|,
name|FILE_FLAG_BACKUP_SEMANTICS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Can't access %s\n"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|r
operator|=
name|GetFileTime
argument_list|(
name|h
argument_list|,
operator|&
name|fbirthtime
argument_list|,
operator|&
name|fatime
argument_list|,
operator|&
name|fmtime
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'a'
case|:
name|fxtime
operator|=
name|fatime
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|fxtime
operator|=
name|fbirthtime
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|fxtime
operator|=
name|fmtime
expr_stmt|;
break|break;
block|}
name|CloseHandle
argument_list|(
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Can't GetFileTime %s\n"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|wintm
operator|.
name|LowPart
operator|=
name|fxtime
operator|.
name|dwLowDateTime
expr_stmt|;
name|wintm
operator|.
name|HighPart
operator|=
name|fxtime
operator|.
name|dwHighDateTime
expr_stmt|;
name|filet
operator|=
operator|(
name|wintm
operator|.
name|QuadPart
operator|-
name|EPOC_TIME
operator|)
operator|/
literal|10000000
expr_stmt|;
name|filet_nsec
operator|=
operator|(
operator|(
name|wintm
operator|.
name|QuadPart
operator|-
name|EPOC_TIME
operator|)
operator|%
literal|10000000
operator|)
operator|*
literal|100
expr_stmt|;
name|nsec
operator|=
operator|(
name|nsec
operator|/
literal|100
operator|)
operator|*
literal|100
expr_stmt|;
comment|/* Round the request */
else|#
directive|else
name|struct
name|stat
name|st
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|r
operator|=
name|lstat
argument_list|(
name|pathname
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Can't stat %s\n"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'a'
case|:
name|filet
operator|=
name|st
operator|.
name|st_atime
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|filet
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|filet
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"INTERNAL: Bad type %c for file time"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'a'
case|:
name|filet_nsec
operator|=
name|st
operator|.
name|st_atimespec
operator|.
name|tv_nsec
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|filet
operator|=
name|st
operator|.
name|st_birthtime
expr_stmt|;
comment|/* FreeBSD filesystems that don't support birthtime 		 * (e.g., UFS1) always return -1 here. */
if|if
condition|(
name|filet
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|filet_nsec
operator|=
name|st
operator|.
name|st_birthtimespec
operator|.
name|tv_nsec
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|filet_nsec
operator|=
name|st
operator|.
name|st_mtimespec
operator|.
name|tv_nsec
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"INTERNAL: Bad type %c for file time"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* FreeBSD generally only stores to microsecond res, so round. */
name|filet_nsec
operator|=
operator|(
name|filet_nsec
operator|/
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
name|nsec
operator|=
operator|(
name|nsec
operator|/
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
else|#
directive|else
name|filet_nsec
operator|=
name|nsec
operator|=
literal|0
expr_stmt|;
comment|/* Generic POSIX only has whole seconds. */
if|if
condition|(
name|type
operator|==
literal|'b'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Generic POSIX doesn't have birthtime */
if|#
directive|if
name|defined
argument_list|(
name|__HAIKU__
argument_list|)
if|if
condition|(
name|type
operator|==
literal|'a'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Haiku doesn't have atime. */
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|recent
condition|)
block|{
comment|/* Check that requested time is up-to-date. */
name|time_t
name|now
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|filet
operator|<
name|now
operator|-
literal|10
operator|||
name|filet
operator|>
name|now
operator|+
literal|1
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File %s has %ctime %lld, %lld seconds ago\n"
argument_list|,
name|pathname
argument_list|,
name|type
argument_list|,
name|filet
argument_list|,
name|now
operator|-
name|filet
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|filet
operator|!=
name|t
operator|||
name|filet_nsec
operator|!=
name|nsec
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File %s has %ctime %lld.%09lld, expected %lld.%09lld"
argument_list|,
name|pathname
argument_list|,
name|type
argument_list|,
name|filet
argument_list|,
name|filet_nsec
argument_list|,
name|t
argument_list|,
name|nsec
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Verify atime of 'pathname'. */
end_comment

begin_function
name|int
name|assertion_file_atime
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|long
name|t
parameter_list|,
name|long
name|nsec
parameter_list|)
block|{
return|return
name|assertion_file_time
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|pathname
argument_list|,
name|t
argument_list|,
name|nsec
argument_list|,
literal|'a'
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Verify atime of 'pathname' is up-to-date. */
end_comment

begin_function
name|int
name|assertion_file_atime_recent
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|)
block|{
return|return
name|assertion_file_time
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|pathname
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|'a'
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Verify birthtime of 'pathname'. */
end_comment

begin_function
name|int
name|assertion_file_birthtime
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|long
name|t
parameter_list|,
name|long
name|nsec
parameter_list|)
block|{
return|return
name|assertion_file_time
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|pathname
argument_list|,
name|t
argument_list|,
name|nsec
argument_list|,
literal|'b'
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Verify birthtime of 'pathname' is up-to-date. */
end_comment

begin_function
name|int
name|assertion_file_birthtime_recent
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|)
block|{
return|return
name|assertion_file_time
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|pathname
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|'b'
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Verify mode of 'pathname'. */
end_comment

begin_function
name|int
name|assertion_file_mode
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
name|expected_mode
parameter_list|)
block|{
name|int
name|mode
decl_stmt|;
name|int
name|r
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"assertFileMode not yet implemented for Windows"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mode
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|r
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|pathname
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|expected_mode
expr_stmt|;
comment|/* UNUSED */
else|#
directive|else
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|r
operator|=
name|lstat
argument_list|(
name|pathname
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|mode
operator|=
call|(
name|int
call|)
argument_list|(
name|st
operator|.
name|st_mode
operator|&
literal|0777
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
literal|0
operator|&&
name|mode
operator|==
name|expected_mode
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File %s has mode %o, expected %o"
argument_list|,
name|pathname
argument_list|,
name|mode
argument_list|,
name|expected_mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Verify mtime of 'pathname'. */
end_comment

begin_function
name|int
name|assertion_file_mtime
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|long
name|t
parameter_list|,
name|long
name|nsec
parameter_list|)
block|{
return|return
name|assertion_file_time
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|pathname
argument_list|,
name|t
argument_list|,
name|nsec
argument_list|,
literal|'m'
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Verify mtime of 'pathname' is up-to-date. */
end_comment

begin_function
name|int
name|assertion_file_mtime_recent
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|)
block|{
return|return
name|assertion_file_time
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|pathname
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|'m'
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Verify number of links to 'pathname'. */
end_comment

begin_function
name|int
name|assertion_file_nlinks
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
name|nlinks
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
name|BY_HANDLE_FILE_INFORMATION
name|bhfi
decl_stmt|;
name|int
name|r
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|r
operator|=
name|my_GetFileInformationByName
argument_list|(
name|pathname
argument_list|,
operator|&
name|bhfi
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
operator|&&
name|bhfi
operator|.
name|nNumberOfLinks
operator|==
operator|(
name|DWORD
operator|)
name|nlinks
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File %s has %d links, expected %d"
argument_list|,
name|pathname
argument_list|,
name|bhfi
operator|.
name|nNumberOfLinks
argument_list|,
name|nlinks
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|r
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|r
operator|=
name|lstat
argument_list|(
name|pathname
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
operator|&&
operator|(
name|int
operator|)
name|st
operator|.
name|st_nlink
operator|==
name|nlinks
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File %s has %d links, expected %d"
argument_list|,
name|pathname
argument_list|,
name|st
operator|.
name|st_nlink
argument_list|,
name|nlinks
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Verify size of 'pathname'. */
end_comment

begin_function
name|int
name|assertion_file_size
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|long
name|size
parameter_list|)
block|{
name|int64_t
name|filesize
decl_stmt|;
name|int
name|r
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
block|{
name|BY_HANDLE_FILE_INFORMATION
name|bhfi
decl_stmt|;
name|r
operator|=
operator|!
name|my_GetFileInformationByName
argument_list|(
name|pathname
argument_list|,
operator|&
name|bhfi
argument_list|)
expr_stmt|;
name|filesize
operator|=
operator|(
operator|(
name|int64_t
operator|)
name|bhfi
operator|.
name|nFileSizeHigh
operator|<<
literal|32
operator|)
operator|+
name|bhfi
operator|.
name|nFileSizeLow
expr_stmt|;
block|}
else|#
directive|else
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|r
operator|=
name|lstat
argument_list|(
name|pathname
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|filesize
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|r
operator|==
literal|0
operator|&&
name|filesize
operator|==
name|size
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File %s has size %ld, expected %ld"
argument_list|,
name|pathname
argument_list|,
operator|(
name|long
operator|)
name|filesize
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Assert that 'pathname' is a dir.  If mode>= 0, verify that too. */
end_comment

begin_function
name|int
name|assertion_is_dir
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|r
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|(
name|void
operator|)
name|mode
expr_stmt|;
comment|/* UNUSED */
endif|#
directive|endif
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|r
operator|=
name|lstat
argument_list|(
name|pathname
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Dir should exist: %s"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"%s is not a dir"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
comment|/* Windows doesn't handle permissions the same way as POSIX, 	 * so just ignore the mode tests. */
comment|/* TODO: Can we do better here? */
if|if
condition|(
name|mode
operator|>=
literal|0
operator|&&
operator|(
name|mode_t
operator|)
name|mode
operator|!=
operator|(
name|st
operator|.
name|st_mode
operator|&
literal|07777
operator|)
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Dir %s has wrong mode"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"  Expected: 0%3o\n"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"  Found: 0%3o\n"
argument_list|,
name|st
operator|.
name|st_mode
operator|&
literal|07777
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Verify that 'pathname' is a regular file.  If 'mode' is>= 0,  * verify that too. */
end_comment

begin_function
name|int
name|assertion_is_reg
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|r
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|(
name|void
operator|)
name|mode
expr_stmt|;
comment|/* UNUSED */
endif|#
directive|endif
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|r
operator|=
name|lstat
argument_list|(
name|pathname
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
operator|||
operator|!
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File should exist: %s"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
comment|/* Windows doesn't handle permissions the same way as POSIX, 	 * so just ignore the mode tests. */
comment|/* TODO: Can we do better here? */
if|if
condition|(
name|mode
operator|>=
literal|0
operator|&&
operator|(
name|mode_t
operator|)
name|mode
operator|!=
operator|(
name|st
operator|.
name|st_mode
operator|&
literal|07777
operator|)
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File %s has wrong mode"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"  Expected: 0%3o\n"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"  Found: 0%3o\n"
argument_list|,
name|st
operator|.
name|st_mode
operator|&
literal|07777
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Check whether 'pathname' is a symbolic link.  If 'contents' is  * non-NULL, verify that the symlink has those contents. */
end_comment

begin_function
specifier|static
name|int
name|is_symlink
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
specifier|const
name|char
modifier|*
name|contents
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|(
name|void
operator|)
name|pathname
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|contents
expr_stmt|;
comment|/* UNUSED */
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* Windows sort-of has real symlinks, but they're only usable 	 * by privileged users and are crippled even then, so there's 	 * really not much point in bothering with this. */
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
name|char
name|buff
index|[
literal|300
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|ssize_t
name|linklen
decl_stmt|;
name|int
name|r
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|r
operator|=
name|lstat
argument_list|(
name|pathname
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Symlink should exist: %s"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|S_ISLNK
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|linklen
operator|=
name|readlink
argument_list|(
name|pathname
argument_list|,
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|linklen
operator|<
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Can't read symlink %s"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|buff
index|[
name|linklen
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buff
argument_list|,
name|contents
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Assert that path is a symlink that (optionally) contains contents. */
end_comment

begin_function
name|int
name|assertion_is_symlink
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|contents
parameter_list|)
block|{
if|if
condition|(
name|is_symlink
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|path
argument_list|,
name|contents
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|contents
condition|)
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File %s is not a symlink to %s"
argument_list|,
name|path
argument_list|,
name|contents
argument_list|)
expr_stmt|;
else|else
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File %s is not a symlink"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create a directory and report any errors. */
end_comment

begin_function
name|int
name|assertion_make_dir
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|dirname
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|(
name|void
operator|)
name|mode
expr_stmt|;
comment|/* UNUSED */
if|if
condition|(
literal|0
operator|==
name|_mkdir
argument_list|(
name|dirname
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
if|if
condition|(
literal|0
operator|==
name|mkdir
argument_list|(
name|dirname
argument_list|,
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|chmod
argument_list|(
name|dirname
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|assertion_file_mode
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|dirname
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
endif|#
directive|endif
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Could not create directory %s"
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create a file with the specified contents and report any failures. */
end_comment

begin_function
name|int
name|assertion_make_file
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|csize
parameter_list|,
specifier|const
name|void
modifier|*
name|contents
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
comment|/* TODO: Rework this to set file mode as well. */
name|FILE
modifier|*
name|f
decl_stmt|;
operator|(
name|void
operator|)
name|mode
expr_stmt|;
comment|/* UNUSED */
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|path
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Could not create file %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|contents
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|wsize
decl_stmt|;
if|if
condition|(
name|csize
operator|<
literal|0
condition|)
name|wsize
operator|=
name|strlen
argument_list|(
name|contents
argument_list|)
expr_stmt|;
else|else
name|wsize
operator|=
operator|(
name|size_t
operator|)
name|csize
expr_stmt|;
if|if
condition|(
name|wsize
operator|!=
name|fwrite
argument_list|(
name|contents
argument_list|,
literal|1
argument_list|,
name|wsize
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Could not write file %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
name|int
name|fd
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_CREAT
operator||
name|O_WRONLY
argument_list|,
name|mode
operator|>=
literal|0
condition|?
name|mode
else|:
literal|0644
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Could not create %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
literal|0
operator|!=
name|chmod
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Could not chmod %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|contents
operator|!=
name|NULL
condition|)
block|{
name|ssize_t
name|wsize
decl_stmt|;
if|if
condition|(
name|csize
operator|<
literal|0
condition|)
name|wsize
operator|=
operator|(
name|ssize_t
operator|)
name|strlen
argument_list|(
name|contents
argument_list|)
expr_stmt|;
else|else
name|wsize
operator|=
operator|(
name|ssize_t
operator|)
name|csize
expr_stmt|;
if|if
condition|(
name|wsize
operator|!=
name|write
argument_list|(
name|fd
argument_list|,
name|contents
argument_list|,
name|wsize
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Could not write to %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|assertion_file_mode
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Create a hardlink and report any failures. */
end_comment

begin_function
name|int
name|assertion_make_hardlink
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|newpath
parameter_list|,
specifier|const
name|char
modifier|*
name|linkto
parameter_list|)
block|{
name|int
name|succeeded
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
name|succeeded
operator|=
name|my_CreateHardLinkA
argument_list|(
name|newpath
argument_list|,
name|linkto
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|HAVE_LINK
name|succeeded
operator|=
operator|!
name|link
argument_list|(
name|linkto
argument_list|,
name|newpath
argument_list|)
expr_stmt|;
else|#
directive|else
name|succeeded
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|succeeded
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Could not create hardlink"
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"   New link: %s\n"
argument_list|,
name|newpath
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"   Old name: %s\n"
argument_list|,
name|linkto
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create a symlink and report any failures. */
end_comment

begin_function
name|int
name|assertion_make_symlink
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|newpath
parameter_list|,
specifier|const
name|char
modifier|*
name|linkto
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
name|int
name|targetIsDir
init|=
literal|0
decl_stmt|;
comment|/* TODO: Fix this */
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_CreateSymbolicLinkA
argument_list|(
name|newpath
argument_list|,
name|linkto
argument_list|,
name|targetIsDir
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
elif|#
directive|elif
name|HAVE_SYMLINK
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|symlink
argument_list|(
name|linkto
argument_list|,
name|newpath
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Could not create symlink"
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"   New link: %s\n"
argument_list|,
name|newpath
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"   Old name: %s\n"
argument_list|,
name|linkto
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set umask, report failures. */
end_comment

begin_function
name|int
name|assertion_umask
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|file
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|line
expr_stmt|;
comment|/* UNUSED */
name|umask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set times, report failures. */
end_comment

begin_function
name|int
name|assertion_utimes
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|long
name|at
parameter_list|,
name|long
name|at_nsec
parameter_list|,
name|long
name|mt
parameter_list|,
name|long
name|mt_nsec
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
define|#
directive|define
name|WINTIME
parameter_list|(
name|sec
parameter_list|,
name|nsec
parameter_list|)
value|((Int32x32To64(sec, 10000000) + EPOC_TIME)\ 	 + (((nsec)/1000)*10))
name|HANDLE
name|h
decl_stmt|;
name|ULARGE_INTEGER
name|wintm
decl_stmt|;
name|FILETIME
name|fatime
decl_stmt|,
name|fmtime
decl_stmt|;
name|FILETIME
modifier|*
name|pat
decl_stmt|,
modifier|*
name|pmt
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|h
operator|=
name|CreateFileA
argument_list|(
name|pathname
argument_list|,
name|GENERIC_READ
operator||
name|GENERIC_WRITE
argument_list|,
name|FILE_SHARE_READ
operator||
name|FILE_SHARE_WRITE
argument_list|,
name|NULL
argument_list|,
name|OPEN_EXISTING
argument_list|,
name|FILE_FLAG_BACKUP_SEMANTICS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Can't access %s\n"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|at
operator|>
literal|0
operator|||
name|at_nsec
operator|>
literal|0
condition|)
block|{
name|wintm
operator|.
name|QuadPart
operator|=
name|WINTIME
argument_list|(
name|at
argument_list|,
name|at_nsec
argument_list|)
expr_stmt|;
name|fatime
operator|.
name|dwLowDateTime
operator|=
name|wintm
operator|.
name|LowPart
expr_stmt|;
name|fatime
operator|.
name|dwHighDateTime
operator|=
name|wintm
operator|.
name|HighPart
expr_stmt|;
name|pat
operator|=
operator|&
name|fatime
expr_stmt|;
block|}
else|else
name|pat
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mt
operator|>
literal|0
operator|||
name|mt_nsec
operator|>
literal|0
condition|)
block|{
name|wintm
operator|.
name|QuadPart
operator|=
name|WINTIME
argument_list|(
name|mt
argument_list|,
name|mt_nsec
argument_list|)
expr_stmt|;
name|fmtime
operator|.
name|dwLowDateTime
operator|=
name|wintm
operator|.
name|LowPart
expr_stmt|;
name|fmtime
operator|.
name|dwHighDateTime
operator|=
name|wintm
operator|.
name|HighPart
expr_stmt|;
name|pmt
operator|=
operator|&
name|fmtime
expr_stmt|;
block|}
else|else
name|pmt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pat
operator|!=
name|NULL
operator|||
name|pmt
operator|!=
name|NULL
condition|)
name|r
operator|=
name|SetFileTime
argument_list|(
name|h
argument_list|,
name|NULL
argument_list|,
name|pat
argument_list|,
name|pmt
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
literal|1
expr_stmt|;
name|CloseHandle
argument_list|(
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Can't SetFileTime %s\n"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
comment|/* defined(_WIN32)&& !defined(__CYGWIN__) */
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|timeval
name|times
index|[
literal|2
index|]
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mt_nsec
operator|=
name|at_nsec
operator|=
literal|0
expr_stmt|;
comment|/* Generic POSIX only has whole seconds. */
endif|#
directive|endif
if|if
condition|(
name|mt
operator|==
literal|0
operator|&&
name|mt_nsec
operator|==
literal|0
operator|&&
name|at
operator|==
literal|0
operator|&&
name|at_nsec
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|r
operator|=
name|lstat
argument_list|(
name|pathname
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Can't stat %s\n"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|mt
operator|==
literal|0
operator|&&
name|mt_nsec
operator|==
literal|0
condition|)
block|{
name|mt
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mt_nsec
operator|=
name|st
operator|.
name|st_mtimespec
operator|.
name|tv_nsec
expr_stmt|;
comment|/* FreeBSD generally only stores to microsecond res, so round. */
name|mt_nsec
operator|=
operator|(
name|mt_nsec
operator|/
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|at
operator|==
literal|0
operator|&&
name|at_nsec
operator|==
literal|0
condition|)
block|{
name|at
operator|=
name|st
operator|.
name|st_atime
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|at_nsec
operator|=
name|st
operator|.
name|st_atimespec
operator|.
name|tv_nsec
expr_stmt|;
comment|/* FreeBSD generally only stores to microsecond res, so round. */
name|at_nsec
operator|=
operator|(
name|at_nsec
operator|/
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
endif|#
directive|endif
block|}
name|times
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|mt
expr_stmt|;
name|times
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
name|mt_nsec
operator|/
literal|1000
expr_stmt|;
name|times
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|at
expr_stmt|;
name|times
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
name|at_nsec
operator|/
literal|1000
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_LUTIMES
name|r
operator|=
name|lutimes
argument_list|(
name|pathname
argument_list|,
name|times
argument_list|)
expr_stmt|;
else|#
directive|else
name|r
operator|=
name|utimes
argument_list|(
name|pathname
argument_list|,
name|times
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Can't utimes %s\n"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* defined(_WIN32)&& !defined(__CYGWIN__) */
block|}
end_function

begin_comment
comment|/* Compare file flags */
end_comment

begin_function
name|int
name|assertion_compare_fflags
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|patha
parameter_list|,
specifier|const
name|char
modifier|*
name|pathb
parameter_list|,
name|int
name|nomatch
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STRUCT_STAT_ST_FLAGS
argument_list|)
operator|&&
name|defined
argument_list|(
name|UF_NODUMP
argument_list|)
name|struct
name|stat
name|sa
decl_stmt|,
name|sb
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|patha
argument_list|,
operator|&
name|sa
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|stat
argument_list|(
name|pathb
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|nomatch
operator|&&
name|sa
operator|.
name|st_flags
operator|!=
name|sb
operator|.
name|st_flags
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File flags should be identical: "
literal|"%s=%#010x %s=%#010x"
argument_list|,
name|patha
argument_list|,
name|sa
operator|.
name|st_flags
argument_list|,
name|pathb
argument_list|,
name|sb
operator|.
name|st_flags
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|nomatch
operator|&&
name|sa
operator|.
name|st_flags
operator|==
name|sb
operator|.
name|st_flags
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File flags should be different: "
literal|"%s=%#010x %s=%#010x"
argument_list|,
name|patha
argument_list|,
name|sa
operator|.
name|st_flags
argument_list|,
name|pathb
argument_list|,
name|sb
operator|.
name|st_flags
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|FS_IOC_GETFLAGS
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_WORKING_FS_IOC_GETFLAGS
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|FS_NODUMP_FL
argument_list|)
operator|)
operator|||
expr|\
operator|(
name|defined
argument_list|(
name|EXT2_IOC_GETFLAGS
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_WORKING_EXT2_IOC_GETFLAGS
argument_list|)
expr|\
operator|&&
name|defined
argument_list|(
name|EXT2_NODUMP_FL
argument_list|)
operator|)
name|int
name|fd
decl_stmt|,
name|r
decl_stmt|,
name|flagsa
decl_stmt|,
name|flagsb
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|patha
argument_list|,
name|O_RDONLY
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Can't open %s\n"
argument_list|,
name|patha
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|r
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
ifdef|#
directive|ifdef
name|FS_IOC_GETFLAGS
name|FS_IOC_GETFLAGS
argument_list|,
else|#
directive|else
name|EXT2_IOC_GETFLAGS
argument_list|,
endif|#
directive|endif
operator|&
name|flagsa
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Can't get flags %s\n"
argument_list|,
name|patha
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|fd
operator|=
name|open
argument_list|(
name|pathb
argument_list|,
name|O_RDONLY
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Can't open %s\n"
argument_list|,
name|pathb
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|r
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
ifdef|#
directive|ifdef
name|FS_IOC_GETFLAGS
name|FS_IOC_GETFLAGS
argument_list|,
else|#
directive|else
name|EXT2_IOC_GETFLAGS
argument_list|,
endif|#
directive|endif
operator|&
name|flagsb
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Can't get flags %s\n"
argument_list|,
name|pathb
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|nomatch
operator|&&
name|flagsa
operator|!=
name|flagsb
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File flags should be identical: "
literal|"%s=%#010x %s=%#010x"
argument_list|,
name|patha
argument_list|,
name|flagsa
argument_list|,
name|pathb
argument_list|,
name|flagsb
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|nomatch
operator|&&
name|flagsa
operator|==
name|flagsb
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"File flags should be different: "
literal|"%s=%#010x %s=%#010x"
argument_list|,
name|patha
argument_list|,
name|flagsa
argument_list|,
name|pathb
argument_list|,
name|flagsb
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|#
directive|else
operator|(
name|void
operator|)
name|patha
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|pathb
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|nomatch
expr_stmt|;
comment|/* UNUSED */
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set nodump, report failures. */
end_comment

begin_function
name|int
name|assertion_set_nodump
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STRUCT_STAT_ST_FLAGS
argument_list|)
operator|&&
name|defined
argument_list|(
name|UF_NODUMP
argument_list|)
name|int
name|r
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|r
operator|=
name|chflags
argument_list|(
name|pathname
argument_list|,
name|UF_NODUMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Can't set nodump %s\n"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|FS_IOC_GETFLAGS
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_WORKING_FS_IOC_GETFLAGS
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|FS_NODUMP_FL
argument_list|)
operator|)
operator|||
expr|\
operator|(
name|defined
argument_list|(
name|EXT2_IOC_GETFLAGS
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_WORKING_EXT2_IOC_GETFLAGS
argument_list|)
expr|\
operator|&&
name|defined
argument_list|(
name|EXT2_NODUMP_FL
argument_list|)
operator|)
name|int
name|fd
decl_stmt|,
name|r
decl_stmt|,
name|flags
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|pathname
argument_list|,
name|O_RDONLY
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Can't open %s\n"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|r
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
ifdef|#
directive|ifdef
name|FS_IOC_GETFLAGS
name|FS_IOC_GETFLAGS
argument_list|,
else|#
directive|else
name|EXT2_IOC_GETFLAGS
argument_list|,
endif|#
directive|endif
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Can't get flags %s\n"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|FS_NODUMP_FL
name|flags
operator||=
name|FS_NODUMP_FL
expr_stmt|;
else|#
directive|else
name|flags
operator||=
name|EXT2_NODUMP_FL
expr_stmt|;
endif|#
directive|endif
name|r
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
ifdef|#
directive|ifdef
name|FS_IOC_SETFLAGS
name|FS_IOC_SETFLAGS
argument_list|,
else|#
directive|else
name|EXT2_IOC_SETFLAGS
argument_list|,
endif|#
directive|endif
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Can't set nodump %s\n"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|pathname
expr_stmt|;
comment|/* UNUSED */
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PROGRAM
end_ifdef

begin_function
specifier|static
name|void
name|assert_version_id
parameter_list|(
name|char
modifier|*
modifier|*
name|qq
parameter_list|,
name|size_t
modifier|*
name|ss
parameter_list|)
block|{
name|char
modifier|*
name|q
init|=
operator|*
name|qq
decl_stmt|;
name|size_t
name|s
init|=
operator|*
name|ss
decl_stmt|;
comment|/* Version number is a series of digits and periods. */
while|while
condition|(
name|s
operator|>
literal|0
operator|&&
operator|(
operator|*
name|q
operator|==
literal|'.'
operator|||
operator|(
operator|*
name|q
operator|>=
literal|'0'
operator|&&
operator|*
name|q
operator|<=
literal|'9'
operator|)
operator|)
condition|)
block|{
operator|++
name|q
expr_stmt|;
operator|--
name|s
expr_stmt|;
block|}
if|if
condition|(
name|q
index|[
literal|0
index|]
operator|==
literal|'d'
operator|&&
name|q
index|[
literal|1
index|]
operator|==
literal|'e'
operator|&&
name|q
index|[
literal|2
index|]
operator|==
literal|'v'
condition|)
block|{
name|q
operator|+=
literal|3
expr_stmt|;
name|s
operator|-=
literal|3
expr_stmt|;
block|}
comment|/* Skip a single trailing a,b,c, or d. */
if|if
condition|(
operator|*
name|q
operator|==
literal|'a'
operator|||
operator|*
name|q
operator|==
literal|'b'
operator|||
operator|*
name|q
operator|==
literal|'c'
operator|||
operator|*
name|q
operator|==
literal|'d'
condition|)
operator|++
name|q
expr_stmt|;
comment|/* Version number terminated by space. */
name|failure
argument_list|(
literal|"No space after version: ``%s''"
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|s
operator|>
literal|1
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"No space after version: ``%s''"
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|*
name|q
operator|==
literal|' '
argument_list|)
expr_stmt|;
operator|++
name|q
expr_stmt|;
operator|--
name|s
expr_stmt|;
operator|*
name|qq
operator|=
name|q
expr_stmt|;
operator|*
name|ss
operator|=
name|s
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check program version  */
end_comment

begin_function
name|void
name|assertVersion
parameter_list|(
specifier|const
name|char
modifier|*
name|prog
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|size_t
name|s
decl_stmt|;
name|unsigned
name|int
name|prog_len
init|=
name|strlen
argument_list|(
name|base
argument_list|)
decl_stmt|;
name|r
operator|=
name|systemf
argument_list|(
literal|"%s --version>version.stdout 2>version.stderr"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
name|r
operator|=
name|systemf
argument_list|(
literal|"%s -W version>version.stdout 2>version.stderr"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"Unable to run either %s --version or %s -W version"
argument_list|,
name|prog
argument_list|,
name|prog
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|assert
argument_list|(
name|r
operator|==
literal|0
argument_list|)
condition|)
return|return;
comment|/* --version should generate nothing to stdout. */
name|assertEmptyFile
argument_list|(
literal|"version.stderr"
argument_list|)
expr_stmt|;
comment|/* Verify format of version message. */
name|q
operator|=
name|p
operator|=
name|slurpfile
argument_list|(
operator|&
name|s
argument_list|,
literal|"version.stdout"
argument_list|)
expr_stmt|;
comment|/* Version message should start with name of program, then space. */
name|assert
argument_list|(
name|s
operator|>
name|prog_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"Version must start with '%s': ``%s''"
argument_list|,
name|base
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|assertEqualMem
argument_list|(
name|q
argument_list|,
name|base
argument_list|,
name|prog_len
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|q
operator|+=
name|prog_len
expr_stmt|;
name|s
operator|-=
name|prog_len
expr_stmt|;
name|assert
argument_list|(
operator|*
name|q
operator|==
literal|' '
argument_list|)
expr_stmt|;
name|q
operator|++
expr_stmt|;
name|s
operator|--
expr_stmt|;
name|assert_version_id
argument_list|(
operator|&
name|q
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
comment|/* Separator. */
name|failure
argument_list|(
literal|"No `-' between program name and versions: ``%s''"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|assertEqualMem
argument_list|(
name|q
argument_list|,
literal|"- "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|q
operator|+=
literal|2
expr_stmt|;
name|s
operator|-=
literal|2
expr_stmt|;
name|failure
argument_list|(
literal|"Not long enough for libarchive version: ``%s''"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|s
operator|>
literal|11
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"Libarchive version must start with `libarchive': ``%s''"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|assertEqualMem
argument_list|(
name|q
argument_list|,
literal|"libarchive "
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|q
operator|+=
literal|11
expr_stmt|;
name|s
operator|-=
literal|11
expr_stmt|;
name|assert_version_id
argument_list|(
operator|&
name|q
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
comment|/* Skip arbitrary third-party version numbers. */
while|while
condition|(
name|s
operator|>
literal|0
operator|&&
operator|(
operator|*
name|q
operator|==
literal|' '
operator|||
operator|*
name|q
operator|==
literal|'-'
operator|||
operator|*
name|q
operator|==
literal|'/'
operator|||
operator|*
name|q
operator|==
literal|'.'
operator|||
name|isalnum
argument_list|(
operator|*
name|q
argument_list|)
operator|)
condition|)
block|{
operator|++
name|q
expr_stmt|;
operator|--
name|s
expr_stmt|;
block|}
comment|/* All terminated by end-of-line. */
name|assert
argument_list|(
name|s
operator|>=
literal|1
argument_list|)
expr_stmt|;
comment|/* Skip an optional CR character (e.g., Windows) */
name|failure
argument_list|(
literal|"Version output must end with \\n or \\r\\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'\r'
condition|)
block|{
operator|++
name|q
expr_stmt|;
operator|--
name|s
expr_stmt|;
block|}
name|assertEqualMem
argument_list|(
name|q
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PROGRAM */
end_comment

begin_comment
comment|/*  *  *  UTILITIES for use by tests.  *  */
end_comment

begin_comment
comment|/*  * Check whether platform supports symlinks.  This is intended  * for tests to use in deciding whether to bother testing symlink  * support; if the platform doesn't support symlinks, there's no point  * in checking whether the program being tested can create them.  *  * Note that the first time this test is called, we actually go out to  * disk to create and verify a symlink.  This is necessary because  * symlink support is actually a property of a particular filesystem  * and can thus vary between directories on a single system.  After  * the first call, this returns the cached result from memory, so it's  * safe to call it as often as you wish.  */
end_comment

begin_function
name|int
name|canSymlink
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Remember the test result */
specifier|static
name|int
name|value
init|=
literal|0
decl_stmt|,
name|tested
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tested
condition|)
return|return
operator|(
name|value
operator|)
return|;
operator|++
name|tested
expr_stmt|;
name|assertion_make_file
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"canSymlink.0"
argument_list|,
literal|0644
argument_list|,
literal|1
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
comment|/* Note: Cygwin has its own symlink() emulation that does not 	 * use the Win32 CreateSymbolicLink() function. */
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
name|value
operator|=
name|my_CreateSymbolicLinkA
argument_list|(
literal|"canSymlink.1"
argument_list|,
literal|"canSymlink.0"
argument_list|,
literal|0
argument_list|)
operator|&&
name|is_symlink
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"canSymlink.1"
argument_list|,
literal|"canSymlink.0"
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|HAVE_SYMLINK
name|value
operator|=
operator|(
literal|0
operator|==
name|symlink
argument_list|(
literal|"canSymlink.0"
argument_list|,
literal|"canSymlink.1"
argument_list|)
operator|)
operator|&&
name|is_symlink
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"canSymlink.1"
argument_list|,
literal|"canSymlink.0"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Platform-dependent options for hiding the output of a subcommand. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|redirectArgs
init|=
literal|">NUL 2>NUL"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Win32 cmd.exe */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|redirectArgs
init|=
literal|">/dev/null 2>/dev/null"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* POSIX 'sh' */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Can this platform run the bzip2 program?  */
end_comment

begin_function
name|int
name|canBzip2
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|tested
init|=
literal|0
decl_stmt|,
name|value
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|tested
condition|)
block|{
name|tested
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|systemf
argument_list|(
literal|"bzip2 -d -V %s"
argument_list|,
name|redirectArgs
argument_list|)
operator|==
literal|0
condition|)
name|value
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Can this platform run the grzip program?  */
end_comment

begin_function
name|int
name|canGrzip
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|tested
init|=
literal|0
decl_stmt|,
name|value
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|tested
condition|)
block|{
name|tested
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|systemf
argument_list|(
literal|"grzip -V %s"
argument_list|,
name|redirectArgs
argument_list|)
operator|==
literal|0
condition|)
name|value
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Can this platform run the gzip program?  */
end_comment

begin_function
name|int
name|canGzip
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|tested
init|=
literal|0
decl_stmt|,
name|value
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|tested
condition|)
block|{
name|tested
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|systemf
argument_list|(
literal|"gzip -V %s"
argument_list|,
name|redirectArgs
argument_list|)
operator|==
literal|0
condition|)
name|value
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Can this platform run the lrzip program?  */
end_comment

begin_function
name|int
name|canRunCommand
parameter_list|(
specifier|const
name|char
modifier|*
name|cmd
parameter_list|)
block|{
specifier|static
name|int
name|tested
init|=
literal|0
decl_stmt|,
name|value
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|tested
condition|)
block|{
name|tested
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|systemf
argument_list|(
literal|"%s %s"
argument_list|,
name|cmd
argument_list|,
name|redirectArgs
argument_list|)
operator|==
literal|0
condition|)
name|value
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_function
name|int
name|canLrzip
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|tested
init|=
literal|0
decl_stmt|,
name|value
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|tested
condition|)
block|{
name|tested
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|systemf
argument_list|(
literal|"lrzip -V %s"
argument_list|,
name|redirectArgs
argument_list|)
operator|==
literal|0
condition|)
name|value
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Can this platform run the lz4 program?  */
end_comment

begin_function
name|int
name|canLz4
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|tested
init|=
literal|0
decl_stmt|,
name|value
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|tested
condition|)
block|{
name|tested
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|systemf
argument_list|(
literal|"lz4 -V %s"
argument_list|,
name|redirectArgs
argument_list|)
operator|==
literal|0
condition|)
name|value
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Can this platform run the lzip program?  */
end_comment

begin_function
name|int
name|canLzip
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|tested
init|=
literal|0
decl_stmt|,
name|value
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|tested
condition|)
block|{
name|tested
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|systemf
argument_list|(
literal|"lzip -V %s"
argument_list|,
name|redirectArgs
argument_list|)
operator|==
literal|0
condition|)
name|value
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Can this platform run the lzma program?  */
end_comment

begin_function
name|int
name|canLzma
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|tested
init|=
literal|0
decl_stmt|,
name|value
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|tested
condition|)
block|{
name|tested
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|systemf
argument_list|(
literal|"lzma -V %s"
argument_list|,
name|redirectArgs
argument_list|)
operator|==
literal|0
condition|)
name|value
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Can this platform run the lzop program?  */
end_comment

begin_function
name|int
name|canLzop
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|tested
init|=
literal|0
decl_stmt|,
name|value
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|tested
condition|)
block|{
name|tested
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|systemf
argument_list|(
literal|"lzop -V %s"
argument_list|,
name|redirectArgs
argument_list|)
operator|==
literal|0
condition|)
name|value
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Can this platform run the xz program?  */
end_comment

begin_function
name|int
name|canXz
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|tested
init|=
literal|0
decl_stmt|,
name|value
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|tested
condition|)
block|{
name|tested
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|systemf
argument_list|(
literal|"xz -V %s"
argument_list|,
name|redirectArgs
argument_list|)
operator|==
literal|0
condition|)
name|value
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Can this filesystem handle nodump flags.  */
end_comment

begin_function
name|int
name|canNodump
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STRUCT_STAT_ST_FLAGS
argument_list|)
operator|&&
name|defined
argument_list|(
name|UF_NODUMP
argument_list|)
specifier|const
name|char
modifier|*
name|path
init|=
literal|"cannodumptest"
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|assertion_make_file
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|path
argument_list|,
literal|0644
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|chflags
argument_list|(
name|path
argument_list|,
name|UF_NODUMP
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sb
operator|.
name|st_flags
operator|&
name|UF_NODUMP
condition|)
return|return
operator|(
literal|1
operator|)
return|;
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|FS_IOC_GETFLAGS
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_WORKING_FS_IOC_GETFLAGS
argument_list|)
expr|\
operator|&&
name|defined
argument_list|(
name|FS_NODUMP_FL
argument_list|)
operator|)
operator|||
expr|\
operator|(
name|defined
argument_list|(
name|EXT2_IOC_GETFLAGS
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_WORKING_EXT2_IOC_GETFLAGS
argument_list|)
expr|\
operator|&&
name|defined
argument_list|(
name|EXT2_NODUMP_FL
argument_list|)
operator|)
specifier|const
name|char
modifier|*
name|path
init|=
literal|"cannodumptest"
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|r
decl_stmt|,
name|flags
decl_stmt|;
name|assertion_make_file
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|path
argument_list|,
literal|0644
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDONLY
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|r
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
ifdef|#
directive|ifdef
name|FS_IOC_GETFLAGS
name|FS_IOC_GETFLAGS
argument_list|,
else|#
directive|else
name|EXT2_IOC_GETFLAGS
argument_list|,
endif|#
directive|endif
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|FS_NODUMP_FL
name|flags
operator||=
name|FS_NODUMP_FL
expr_stmt|;
else|#
directive|else
name|flags
operator||=
name|EXT2_NODUMP_FL
expr_stmt|;
endif|#
directive|endif
name|r
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
ifdef|#
directive|ifdef
name|FS_IOC_SETFLAGS
name|FS_IOC_SETFLAGS
argument_list|,
else|#
directive|else
name|EXT2_IOC_SETFLAGS
argument_list|,
endif|#
directive|endif
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDONLY
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|r
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
ifdef|#
directive|ifdef
name|FS_IOC_GETFLAGS
name|FS_IOC_GETFLAGS
argument_list|,
else|#
directive|else
name|EXT2_IOC_GETFLAGS
argument_list|,
endif|#
directive|endif
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FS_NODUMP_FL
if|if
condition|(
name|flags
operator|&
name|FS_NODUMP_FL
condition|)
else|#
directive|else
if|if
condition|(
name|flags
operator|&
name|EXT2_NODUMP_FL
condition|)
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get extended attribute from a path */
end_comment

begin_function
specifier|const
name|void
modifier|*
name|getXattr
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|void
modifier|*
name|value
init|=
name|NULL
decl_stmt|;
if|#
directive|if
name|ARCHIVE_XATTR_SUPPORT
name|ssize_t
name|size
decl_stmt|;
if|#
directive|if
name|ARCHIVE_XATTR_LINUX
name|size
operator|=
name|lgetxattr
argument_list|(
name|path
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|ARCHIVE_XATTR_DARWIN
name|size
operator|=
name|getxattr
argument_list|(
name|path
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|XATTR_NOFOLLOW
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|ARCHIVE_XATTR_AIX
name|size
operator|=
name|lgetea
argument_list|(
name|path
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|ARCHIVE_XATTR_FREEBSD
name|size
operator|=
name|extattr_get_link
argument_list|(
name|path
argument_list|,
name|EXTATTR_NAMESPACE_USER
argument_list|,
name|name
operator|+
literal|5
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|size
operator|>=
literal|0
condition|)
block|{
name|value
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|#
directive|if
name|ARCHIVE_XATTR_LINUX
name|size
operator|=
name|lgetxattr
argument_list|(
name|path
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|size
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|ARCHIVE_XATTR_DARWIN
name|size
operator|=
name|getxattr
argument_list|(
name|path
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
name|XATTR_NOFOLLOW
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|ARCHIVE_XATTR_AIX
name|size
operator|=
name|lgetea
argument_list|(
name|path
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|size
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|ARCHIVE_XATTR_FREEBSD
name|size
operator|=
name|extattr_get_link
argument_list|(
name|path
argument_list|,
name|EXTATTR_NAMESPACE_USER
argument_list|,
name|name
operator|+
literal|5
argument_list|,
name|value
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|size
operator|<
literal|0
condition|)
operator|*
name|sizep
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|sizep
operator|=
operator|(
name|size_t
operator|)
name|size
expr_stmt|;
else|#
directive|else
comment|/* !ARCHIVE_XATTR_SUPPORT */
operator|(
name|void
operator|)
name|path
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|name
expr_stmt|;
comment|/* UNUSED */
operator|*
name|sizep
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* !ARCHIVE_XATTR_SUPPORT */
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set extended attribute on a path  * Returns 0 on error, 1 on success  */
end_comment

begin_function
name|int
name|setXattr
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|void
modifier|*
name|value
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
if|#
directive|if
name|ARCHIVE_XATTR_SUPPORT
if|#
directive|if
name|ARCHIVE_XATTR_LINUX
if|if
condition|(
name|lsetxattr
argument_list|(
name|path
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
elif|#
directive|elif
name|ARCHIVE_XATTR_DARWIN
if|if
condition|(
name|setxattr
argument_list|(
name|path
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
name|XATTR_NOFOLLOW
argument_list|)
operator|==
literal|0
condition|)
elif|#
directive|elif
name|ARCHIVE_XATTR_AIX
if|if
condition|(
name|lsetea
argument_list|(
name|path
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
elif|#
directive|elif
name|ARCHIVE_XATTR_FREEBSD
if|if
condition|(
name|extattr_set_link
argument_list|(
name|path
argument_list|,
name|EXTATTR_NAMESPACE_USER
argument_list|,
name|name
operator|+
literal|5
argument_list|,
name|value
argument_list|,
name|size
argument_list|)
operator|>
operator|-
literal|1
condition|)
else|#
directive|else
if|if
condition|(
literal|0
condition|)
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
comment|/* !ARCHIVE_XATTR_SUPPORT */
operator|(
name|void
operator|)
name|path
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|name
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|value
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|size
expr_stmt|;
comment|/* UNUSED */
endif|#
directive|endif
comment|/* !ARCHIVE_XATTR_SUPPORT */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|ARCHIVE_ACL_SUNOS
end_if

begin_comment
comment|/* Fetch ACLs on Solaris using acl() or facl() */
end_comment

begin_function
name|void
modifier|*
name|sunacl_get
parameter_list|(
name|int
name|cmd
parameter_list|,
name|int
modifier|*
name|aclcnt
parameter_list|,
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|cnt
decl_stmt|,
name|cntcmd
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|void
modifier|*
name|aclp
decl_stmt|;
if|if
condition|(
name|cmd
operator|==
name|GETACL
condition|)
block|{
name|cntcmd
operator|=
name|GETACLCNT
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|aclent_t
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|ARCHIVE_ACL_SUNOS_NFS4
elseif|else
if|if
condition|(
name|cmd
operator|==
name|ACE_GETACL
condition|)
block|{
name|cntcmd
operator|=
name|ACE_GETACLCNT
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|ace_t
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
else|else
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
operator|*
name|aclcnt
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|aclp
operator|=
name|NULL
expr_stmt|;
name|cnt
operator|=
operator|-
literal|2
expr_stmt|;
while|while
condition|(
name|cnt
operator|==
operator|-
literal|2
operator|||
operator|(
name|cnt
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|ENOSPC
operator|)
condition|)
block|{
if|if
condition|(
name|path
operator|!=
name|NULL
condition|)
name|cnt
operator|=
name|acl
argument_list|(
name|path
argument_list|,
name|cntcmd
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|cnt
operator|=
name|facl
argument_list|(
name|fd
argument_list|,
name|cntcmd
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|aclp
operator|==
name|NULL
condition|)
name|aclp
operator|=
name|malloc
argument_list|(
name|cnt
operator|*
name|size
argument_list|)
expr_stmt|;
else|else
name|aclp
operator|=
name|realloc
argument_list|(
name|NULL
argument_list|,
name|cnt
operator|*
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|aclp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|path
operator|!=
name|NULL
condition|)
name|cnt
operator|=
name|acl
argument_list|(
name|path
argument_list|,
name|cmd
argument_list|,
name|cnt
argument_list|,
name|aclp
argument_list|)
expr_stmt|;
else|else
name|cnt
operator|=
name|facl
argument_list|(
name|fd
argument_list|,
name|cmd
argument_list|,
name|cnt
argument_list|,
name|aclp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|aclp
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
name|aclp
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
block|}
block|}
operator|*
name|aclcnt
operator|=
name|cnt
expr_stmt|;
return|return
operator|(
name|aclp
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARCHIVE_ACL_SUNOS */
end_comment

begin_comment
comment|/*  * Set test ACLs on a path  * Return values:  * 0: error setting ACLs  * ARCHIVE_TEST_ACL_TYPE_POSIX1E: POSIX.1E ACLs have been set  * ARCHIVE_TEST_ACL_TYPE_NFS4: NFSv4 or extended ACLs have been set  */
end_comment

begin_function
name|int
name|setTestAcl
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
if|#
directive|if
name|ARCHIVE_ACL_SUPPORT
name|int
name|r
init|=
literal|1
decl_stmt|;
if|#
directive|if
name|ARCHIVE_ACL_LIBACL
operator|||
name|ARCHIVE_ACL_FREEBSD
operator|||
name|ARCHIVE_ACL_DARWIN
name|acl_t
name|acl
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|ARCHIVE_ACL_LIBRICHACL
name|struct
name|richacl
modifier|*
name|richacl
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|ARCHIVE_ACL_LIBACL
operator|||
name|ARCHIVE_ACL_FREEBSD
specifier|const
name|char
modifier|*
name|acltext_posix1e
init|=
literal|"user:1:rw-,"
literal|"group:15:r-x,"
literal|"user::rwx,"
literal|"group::rwx,"
literal|"other::r-x,"
literal|"mask::rwx"
decl_stmt|;
elif|#
directive|elif
name|ARCHIVE_ACL_SUNOS
comment|/* Solaris POSIX.1e */
name|aclent_t
name|aclp_posix1e
index|[]
init|=
block|{
block|{
name|USER_OBJ
block|,
operator|-
literal|1
block|,
literal|4
operator||
literal|2
operator||
literal|1
block|}
block|,
block|{
name|USER
block|,
literal|1
block|,
literal|4
operator||
literal|2
block|}
block|,
block|{
name|GROUP_OBJ
block|,
operator|-
literal|1
block|,
literal|4
operator||
literal|2
operator||
literal|1
block|}
block|,
block|{
name|GROUP
block|,
literal|15
block|,
literal|4
operator||
literal|1
block|}
block|,
block|{
name|CLASS_OBJ
block|,
operator|-
literal|1
block|,
literal|4
operator||
literal|2
operator||
literal|1
block|}
block|,
block|{
name|OTHER_OBJ
block|,
operator|-
literal|1
block|,
literal|4
operator||
literal|2
operator||
literal|1
block|}
block|}
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|ARCHIVE_ACL_FREEBSD
comment|/* FreeBSD NFS4 */
specifier|const
name|char
modifier|*
name|acltext_nfs4
init|=
literal|"user:1:rwpaRcs::allow:1,"
literal|"group:15:rxaRcs::allow:15,"
literal|"owner@:rwpxaARWcCos::allow,"
literal|"group@:rwpxaRcs::allow,"
literal|"everyone@:rxaRcs::allow"
decl_stmt|;
elif|#
directive|elif
name|ARCHIVE_ACL_LIBRICHACL
specifier|const
name|char
modifier|*
name|acltext_nfs4
init|=
literal|"owner:rwpxaARWcCoS::mask,"
literal|"group:rwpxaRcS::mask,"
literal|"other:rxaRcS::mask,"
literal|"user:1:rwpaRcS::allow,"
literal|"group:15:rxaRcS::allow,"
literal|"owner@:rwpxaARWcCoS::allow,"
literal|"group@:rwpxaRcS::allow,"
literal|"everyone@:rxaRcS::allow"
decl_stmt|;
elif|#
directive|elif
name|ARCHIVE_ACL_SUNOS_NFS4
comment|/* Solaris NFS4 */
name|ace_t
name|aclp_nfs4
index|[]
init|=
block|{
block|{
literal|1
block|,
name|ACE_READ_DATA
operator||
name|ACE_WRITE_DATA
operator||
name|ACE_APPEND_DATA
operator||
name|ACE_READ_ATTRIBUTES
operator||
name|ACE_READ_NAMED_ATTRS
operator||
name|ACE_READ_ACL
operator||
name|ACE_SYNCHRONIZE
block|,
literal|0
block|,
name|ACE_ACCESS_ALLOWED_ACE_TYPE
block|}
block|,
block|{
literal|15
block|,
name|ACE_READ_DATA
operator||
name|ACE_EXECUTE
operator||
name|ACE_READ_ATTRIBUTES
operator||
name|ACE_READ_NAMED_ATTRS
operator||
name|ACE_READ_ACL
operator||
name|ACE_SYNCHRONIZE
block|,
name|ACE_IDENTIFIER_GROUP
block|,
name|ACE_ACCESS_ALLOWED_ACE_TYPE
block|}
block|,
block|{
operator|-
literal|1
block|,
name|ACE_READ_DATA
operator||
name|ACE_WRITE_DATA
operator||
name|ACE_APPEND_DATA
operator||
name|ACE_EXECUTE
operator||
name|ACE_READ_ATTRIBUTES
operator||
name|ACE_WRITE_ATTRIBUTES
operator||
name|ACE_READ_NAMED_ATTRS
operator||
name|ACE_WRITE_NAMED_ATTRS
operator||
name|ACE_READ_ACL
operator||
name|ACE_WRITE_ACL
operator||
name|ACE_WRITE_OWNER
operator||
name|ACE_SYNCHRONIZE
block|,
name|ACE_OWNER
block|,
name|ACE_ACCESS_ALLOWED_ACE_TYPE
block|}
block|,
block|{
operator|-
literal|1
block|,
name|ACE_READ_DATA
operator||
name|ACE_WRITE_DATA
operator||
name|ACE_APPEND_DATA
operator||
name|ACE_EXECUTE
operator||
name|ACE_READ_ATTRIBUTES
operator||
name|ACE_READ_NAMED_ATTRS
operator||
name|ACE_READ_ACL
operator||
name|ACE_SYNCHRONIZE
block|,
name|ACE_GROUP
operator||
name|ACE_IDENTIFIER_GROUP
block|,
name|ACE_ACCESS_ALLOWED_ACE_TYPE
block|}
block|,
block|{
operator|-
literal|1
block|,
name|ACE_READ_DATA
operator||
name|ACE_EXECUTE
operator||
name|ACE_READ_ATTRIBUTES
operator||
name|ACE_READ_NAMED_ATTRS
operator||
name|ACE_READ_ACL
operator||
name|ACE_SYNCHRONIZE
block|,
name|ACE_EVERYONE
block|,
name|ACE_ACCESS_ALLOWED_ACE_TYPE
block|}
block|}
decl_stmt|;
elif|#
directive|elif
name|ARCHIVE_ACL_DARWIN
comment|/* Mac OS X */
name|acl_entry_t
name|aclent
decl_stmt|;
name|acl_permset_t
name|permset
decl_stmt|;
specifier|const
name|uid_t
name|uid
init|=
literal|1
decl_stmt|;
name|uuid_t
name|uuid
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|acl_perm_t
name|acl_perms
index|[]
init|=
block|{
name|ACL_READ_DATA
block|,
name|ACL_WRITE_DATA
block|,
name|ACL_APPEND_DATA
block|,
name|ACL_EXECUTE
block|,
name|ACL_READ_ATTRIBUTES
block|,
name|ACL_READ_EXTATTRIBUTES
block|,
name|ACL_READ_SECURITY
block|,
if|#
directive|if
name|HAVE_DECL_ACL_SYNCHRONIZE
name|ACL_SYNCHRONIZE
endif|#
directive|endif
block|}
decl_stmt|;
endif|#
directive|endif
comment|/* ARCHIVE_ACL_DARWIN */
if|#
directive|if
name|ARCHIVE_ACL_FREEBSD
name|acl
operator|=
name|acl_from_text
argument_list|(
name|acltext_nfs4
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"acl_from_text() error: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|assert
argument_list|(
name|acl
operator|!=
name|NULL
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
elif|#
directive|elif
name|ARCHIVE_ACL_LIBRICHACL
name|richacl
operator|=
name|richacl_from_text
argument_list|(
name|acltext_nfs4
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"richacl_from_text() error: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|assert
argument_list|(
name|richacl
operator|!=
name|NULL
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
elif|#
directive|elif
name|ARCHIVE_ACL_DARWIN
name|acl
operator|=
name|acl_init
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"acl_init() error: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|assert
argument_list|(
name|acl
operator|!=
name|NULL
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|r
operator|=
name|acl_create_entry
argument_list|(
operator|&
name|acl
argument_list|,
operator|&
name|aclent
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"acl_create_entry() error: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|assertEqualInt
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|testacl_free
goto|;
name|r
operator|=
name|acl_set_tag_type
argument_list|(
name|aclent
argument_list|,
name|ACL_EXTENDED_ALLOW
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"acl_set_tag_type() error: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|assertEqualInt
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|testacl_free
goto|;
name|r
operator|=
name|acl_get_permset
argument_list|(
name|aclent
argument_list|,
operator|&
name|permset
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"acl_get_permset() error: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|assertEqualInt
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|testacl_free
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|acl_perms
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|acl_perms
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|=
name|acl_add_perm
argument_list|(
name|permset
argument_list|,
name|acl_perms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"acl_add_perm() error: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|assertEqualInt
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|testacl_free
goto|;
block|}
name|r
operator|=
name|acl_set_permset
argument_list|(
name|aclent
argument_list|,
name|permset
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"acl_set_permset() error: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|assertEqualInt
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|testacl_free
goto|;
name|r
operator|=
name|mbr_uid_to_uuid
argument_list|(
name|uid
argument_list|,
name|uuid
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"mbr_uid_to_uuid() error: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|assertEqualInt
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|testacl_free
goto|;
name|r
operator|=
name|acl_set_qualifier
argument_list|(
name|aclent
argument_list|,
name|uuid
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"acl_set_qualifier() error: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|assertEqualInt
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|testacl_free
goto|;
endif|#
directive|endif
comment|/* ARCHIVE_ACL_DARWIN */
if|#
directive|if
name|ARCHIVE_ACL_NFS4
if|#
directive|if
name|ARCHIVE_ACL_FREEBSD
name|r
operator|=
name|acl_set_file
argument_list|(
name|path
argument_list|,
name|ACL_TYPE_NFS4
argument_list|,
name|acl
argument_list|)
expr_stmt|;
name|acl_free
argument_list|(
name|acl
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|ARCHIVE_ACL_LIBRICHACL
name|r
operator|=
name|richacl_set_file
argument_list|(
name|path
argument_list|,
name|richacl
argument_list|)
expr_stmt|;
name|richacl_free
argument_list|(
name|richacl
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|ARCHIVE_ACL_SUNOS_NFS4
name|r
operator|=
name|acl
argument_list|(
name|path
argument_list|,
name|ACE_SETACL
argument_list|,
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|aclp_nfs4
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|aclp_nfs4
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|,
name|aclp_nfs4
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|ARCHIVE_ACL_DARWIN
name|r
operator|=
name|acl_set_file
argument_list|(
name|path
argument_list|,
name|ACL_TYPE_EXTENDED
argument_list|,
name|acl
argument_list|)
expr_stmt|;
name|acl_free
argument_list|(
name|acl
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|r
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_TEST_ACL_TYPE_NFS4
operator|)
return|;
endif|#
directive|endif
comment|/* ARCHIVE_ACL_NFS4 */
if|#
directive|if
name|ARCHIVE_ACL_POSIX1E
if|#
directive|if
name|ARCHIVE_ACL_FREEBSD
operator|||
name|ARCHIVE_ACL_LIBACL
name|acl
operator|=
name|acl_from_text
argument_list|(
name|acltext_posix1e
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"acl_from_text() error: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|assert
argument_list|(
name|acl
operator|!=
name|NULL
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|r
operator|=
name|acl_set_file
argument_list|(
name|path
argument_list|,
name|ACL_TYPE_ACCESS
argument_list|,
name|acl
argument_list|)
expr_stmt|;
name|acl_free
argument_list|(
name|acl
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|ARCHIVE_ACL_SUNOS
name|r
operator|=
name|acl
argument_list|(
name|path
argument_list|,
name|SETACL
argument_list|,
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|aclp_posix1e
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|aclp_posix1e
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|,
name|aclp_posix1e
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|r
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_TEST_ACL_TYPE_POSIX1E
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* ARCHIVE_ACL_POSIX1E */
if|#
directive|if
name|ARCHIVE_ACL_DARWIN
name|testacl_free
label|:
name|acl_free
argument_list|(
name|acl
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* ARCHIVE_ACL_SUPPORT */
operator|(
name|void
operator|)
name|path
expr_stmt|;
comment|/* UNUSED */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sleep as needed; useful for verifying disk timestamp changes by  * ensuring that the wall-clock time has actually changed before we  * go back to re-read something from disk.  */
end_comment

begin_function
name|void
name|sleepUntilAfter
parameter_list|(
name|time_t
name|t
parameter_list|)
block|{
while|while
condition|(
name|t
operator|>=
name|time
argument_list|(
name|NULL
argument_list|)
condition|)
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
name|Sleep
argument_list|(
literal|500
argument_list|)
expr_stmt|;
else|#
directive|else
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Call standard system() call, but build up the command line using  * sprintf() conventions.  */
end_comment

begin_function
name|int
name|systemf
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|buff
index|[
literal|8192
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|int
name|r
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|buff
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>
name|VERBOSITY_FULL
condition|)
name|logprintf
argument_list|(
literal|"Cmd: %s\n"
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|r
operator|=
name|system
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Slurp a file into memory for ease of comparison and testing.  * Returns size of file in 'sizep' if non-NULL, null-terminates  * data in memory for ease of use.  */
end_comment

begin_function
name|char
modifier|*
name|slurpfile
parameter_list|(
name|size_t
modifier|*
name|sizep
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|filename
index|[
literal|8192
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|ssize_t
name|bytes_read
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|r
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|filename
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
comment|/* Note: No error; non-existent file is okay here. */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|r
operator|=
name|fstat
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|logprintf
argument_list|(
literal|"Can't stat file %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|p
operator|=
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|st
operator|.
name|st_size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|logprintf
argument_list|(
literal|"Can't allocate %ld bytes of memory to read file %s\n"
argument_list|,
operator|(
name|long
name|int
operator|)
name|st
operator|.
name|st_size
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bytes_read
operator|=
name|fread
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
operator|(
name|size_t
operator|)
name|st
operator|.
name|st_size
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|<
name|st
operator|.
name|st_size
condition|)
block|{
name|logprintf
argument_list|(
literal|"Can't read file %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|p
index|[
name|st
operator|.
name|st_size
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|sizep
operator|!=
name|NULL
condition|)
operator|*
name|sizep
operator|=
operator|(
name|size_t
operator|)
name|st
operator|.
name|st_size
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Slurp a file into memory for ease of comparison and testing.  * Returns size of file in 'sizep' if non-NULL, null-terminates  * data in memory for ease of use.  */
end_comment

begin_function
name|void
name|dumpfile
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|ssize_t
name|bytes_written
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|logprintf
argument_list|(
literal|"Can't open file %s for writing\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
name|bytes_written
operator|=
name|fwrite
argument_list|(
name|data
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_written
operator|<
operator|(
name|ssize_t
operator|)
name|len
condition|)
name|logprintf
argument_list|(
literal|"Can't write file %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a uuencoded file from the reference directory, decode, and  * write the result into the current directory. */
end_comment

begin_define
define|#
directive|define
name|VALID_UUDECODE
parameter_list|(
name|c
parameter_list|)
value|(c>= 32&& c<= 96)
end_define

begin_define
define|#
directive|define
name|UUDECODE
parameter_list|(
name|c
parameter_list|)
value|(((c) - 0x20)& 0x3f)
end_define

begin_function
name|void
name|extract_reference_file
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
name|buff
index|[
literal|1024
index|]
decl_stmt|;
name|FILE
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s/%s.uu"
argument_list|,
name|refdir
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|in
operator|=
name|fopen
argument_list|(
name|buff
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"Couldn't open reference file %s"
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|in
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
condition|)
return|return;
comment|/* Read up to and including the 'begin' line. */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|in
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* TODO: This is a failure. */
return|return;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|buff
argument_list|,
literal|"begin "
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* Now, decode the rest and write it. */
name|out
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|in
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|buff
decl_stmt|;
name|int
name|bytes
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|buff
argument_list|,
literal|"end"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|bytes
operator|=
name|UUDECODE
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
while|while
condition|(
name|bytes
operator|>
literal|0
condition|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
comment|/* Write out 1-3 bytes from that. */
if|if
condition|(
name|bytes
operator|>
literal|0
condition|)
block|{
name|assert
argument_list|(
name|VALID_UUDECODE
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|VALID_UUDECODE
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|UUDECODE
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|<<
literal|18
expr_stmt|;
name|n
operator||=
name|UUDECODE
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|<<
literal|12
expr_stmt|;
name|fputc
argument_list|(
name|n
operator|>>
literal|16
argument_list|,
name|out
argument_list|)
expr_stmt|;
operator|--
name|bytes
expr_stmt|;
block|}
if|if
condition|(
name|bytes
operator|>
literal|0
condition|)
block|{
name|assert
argument_list|(
name|VALID_UUDECODE
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator||=
name|UUDECODE
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|<<
literal|6
expr_stmt|;
name|fputc
argument_list|(
operator|(
name|n
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|,
name|out
argument_list|)
expr_stmt|;
operator|--
name|bytes
expr_stmt|;
block|}
if|if
condition|(
name|bytes
operator|>
literal|0
condition|)
block|{
name|assert
argument_list|(
name|VALID_UUDECODE
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator||=
name|UUDECODE
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|n
operator|&
literal|0xFF
argument_list|,
name|out
argument_list|)
expr_stmt|;
operator|--
name|bytes
expr_stmt|;
block|}
block|}
block|}
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|copy_reference_file
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
name|buff
index|[
literal|1024
index|]
decl_stmt|;
name|FILE
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|;
name|size_t
name|rbytes
decl_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s/%s"
argument_list|,
name|refdir
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|in
operator|=
name|fopen
argument_list|(
name|buff
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"Couldn't open reference file %s"
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|in
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
condition|)
return|return;
comment|/* Now, decode the rest and write it. */
comment|/* Not a lot of error checking here; the input better be right. */
name|out
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|rbytes
operator|=
name|fread
argument_list|(
name|buff
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|in
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|buff
argument_list|,
literal|1
argument_list|,
name|rbytes
argument_list|,
name|out
argument_list|)
operator|!=
name|rbytes
condition|)
block|{
name|logprintf
argument_list|(
literal|"Error: fwrite\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|is_LargeInode
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
name|BY_HANDLE_FILE_INFORMATION
name|bhfi
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|my_GetFileInformationByName
argument_list|(
name|file
argument_list|,
operator|&
name|bhfi
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|bhfi
operator|.
name|nFileIndexHigh
operator|&
literal|0x0000FFFFUL
operator|)
return|;
else|#
directive|else
name|struct
name|stat
name|st
decl_stmt|;
name|int64_t
name|ino
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ino
operator|=
operator|(
name|int64_t
operator|)
name|st
operator|.
name|st_ino
expr_stmt|;
return|return
operator|(
name|ino
operator|>
literal|0xffffffff
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|extract_reference_files
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|names
parameter_list|)
block|{
while|while
condition|(
name|names
operator|&&
operator|*
name|names
condition|)
name|extract_reference_file
argument_list|(
operator|*
name|names
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|PROGRAM
end_ifndef

begin_comment
comment|/* Set ACLs */
end_comment

begin_function
name|int
name|assertion_entry_set_acls
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|ae
parameter_list|,
name|struct
name|archive_test_acl_t
modifier|*
name|acls
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|r
decl_stmt|,
name|ret
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|archive_entry_acl_clear
argument_list|(
name|ae
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|=
name|archive_entry_acl_add_entry
argument_list|(
name|ae
argument_list|,
name|acls
index|[
name|i
index|]
operator|.
name|type
argument_list|,
name|acls
index|[
name|i
index|]
operator|.
name|permset
argument_list|,
name|acls
index|[
name|i
index|]
operator|.
name|tag
argument_list|,
name|acls
index|[
name|i
index|]
operator|.
name|qual
argument_list|,
name|acls
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"type=%#010x, "
argument_list|,
literal|"permset=%#010x, tag=%d, qual=%d name=%s"
argument_list|,
name|acls
index|[
name|i
index|]
operator|.
name|type
argument_list|,
name|acls
index|[
name|i
index|]
operator|.
name|permset
argument_list|,
name|acls
index|[
name|i
index|]
operator|.
name|tag
argument_list|,
name|acls
index|[
name|i
index|]
operator|.
name|qual
argument_list|,
name|acls
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_test_acl_match
parameter_list|(
name|struct
name|archive_test_acl_t
modifier|*
name|acl
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|permset
parameter_list|,
name|int
name|tag
parameter_list|,
name|int
name|qual
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|type
operator|!=
name|acl
operator|->
name|type
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|permset
operator|!=
name|acl
operator|->
name|permset
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|tag
operator|!=
name|acl
operator|->
name|tag
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|tag
operator|==
name|ARCHIVE_ENTRY_ACL_USER_OBJ
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|tag
operator|==
name|ARCHIVE_ENTRY_ACL_GROUP_OBJ
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|tag
operator|==
name|ARCHIVE_ENTRY_ACL_EVERYONE
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|tag
operator|==
name|ARCHIVE_ENTRY_ACL_OTHER
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|qual
operator|!=
name|acl
operator|->
name|qual
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|acl
operator|->
name|name
operator|==
name|NULL
operator|||
name|acl
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|acl
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|==
name|strcmp
argument_list|(
name|name
argument_list|,
name|acl
operator|->
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Compare ACLs */
end_comment

begin_function
name|int
name|assertion_entry_compare_acls
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|ae
parameter_list|,
name|struct
name|archive_test_acl_t
modifier|*
name|acls
parameter_list|,
name|int
name|cnt
parameter_list|,
name|int
name|want_type
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
modifier|*
name|marker
decl_stmt|;
name|int
name|i
decl_stmt|,
name|r
decl_stmt|,
name|n
decl_stmt|,
name|ret
decl_stmt|;
name|int
name|type
decl_stmt|,
name|permset
decl_stmt|,
name|tag
decl_stmt|,
name|qual
decl_stmt|;
name|int
name|matched
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|assertion_count
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|marker
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|marker
index|[
literal|0
index|]
argument_list|)
operator|*
name|cnt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|acls
index|[
name|i
index|]
operator|.
name|type
operator|&
name|want_type
operator|)
operator|!=
literal|0
condition|)
block|{
name|marker
index|[
name|n
index|]
operator|=
name|i
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"No ACL's to compare, type mask: %d"
argument_list|,
name|want_type
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
while|while
condition|(
literal|0
operator|==
operator|(
name|r
operator|=
name|archive_entry_acl_next
argument_list|(
name|ae
argument_list|,
name|want_type
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|permset
argument_list|,
operator|&
name|tag
argument_list|,
operator|&
name|qual
argument_list|,
operator|&
name|name
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|matched
operator|=
literal|0
init|;
name|i
operator|<
name|n
operator|&&
operator|!
name|matched
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|archive_test_acl_match
argument_list|(
operator|&
name|acls
index|[
name|marker
index|[
name|i
index|]
index|]
argument_list|,
name|type
argument_list|,
name|permset
argument_list|,
name|tag
argument_list|,
name|qual
argument_list|,
name|name
argument_list|)
condition|)
block|{
comment|/* We found a match; remove it. */
name|marker
index|[
name|i
index|]
operator|=
name|marker
index|[
name|n
operator|-
literal|1
index|]
expr_stmt|;
name|n
operator|--
expr_stmt|;
name|matched
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|type
operator|==
name|ARCHIVE_ENTRY_ACL_TYPE_ACCESS
operator|&&
name|tag
operator|==
name|ARCHIVE_ENTRY_ACL_USER_OBJ
condition|)
block|{
if|if
condition|(
operator|!
name|matched
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"No match for "
literal|"user_obj perm"
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|permset
operator|<<
literal|6
operator|)
operator|!=
operator|(
name|mode
operator|&
literal|0700
operator|)
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"USER_OBJ permset "
literal|"(%02o) != user mode (%02o)"
argument_list|,
name|permset
argument_list|,
literal|07
operator|&
operator|(
name|mode
operator|>>
literal|6
operator|)
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|ARCHIVE_ENTRY_ACL_TYPE_ACCESS
operator|&&
name|tag
operator|==
name|ARCHIVE_ENTRY_ACL_GROUP_OBJ
condition|)
block|{
if|if
condition|(
operator|!
name|matched
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"No match for "
literal|"group_obj perm"
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|permset
operator|<<
literal|3
operator|)
operator|!=
operator|(
name|mode
operator|&
literal|0070
operator|)
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"GROUP_OBJ permset "
literal|"(%02o) != group mode (%02o)"
argument_list|,
name|permset
argument_list|,
literal|07
operator|&
operator|(
name|mode
operator|>>
literal|3
operator|)
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|ARCHIVE_ENTRY_ACL_TYPE_ACCESS
operator|&&
name|tag
operator|==
name|ARCHIVE_ENTRY_ACL_OTHER
condition|)
block|{
if|if
condition|(
operator|!
name|matched
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"No match for "
literal|"other perm"
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|permset
operator|<<
literal|0
operator|)
operator|!=
operator|(
name|mode
operator|&
literal|0007
operator|)
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"OTHER permset "
literal|"(%02o) != other mode (%02o)"
argument_list|,
name|permset
argument_list|,
name|mode
operator|&
literal|07
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|matched
operator|!=
literal|1
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Could not find match for "
literal|"ACL (type=%#010x,permset=%#010x,tag=%d,qual=%d,"
literal|"name=``%s'')"
argument_list|,
name|type
argument_list|,
name|permset
argument_list|,
name|tag
argument_list|,
name|qual
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_EOF
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Should not exit before EOF"
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|want_type
operator|&
name|ARCHIVE_ENTRY_ACL_TYPE_ACCESS
operator|)
operator|!=
literal|0
operator|&&
call|(
name|mode_t
call|)
argument_list|(
name|mode
operator|&
literal|0777
argument_list|)
operator|!=
operator|(
name|archive_entry_mode
argument_list|(
name|ae
argument_list|)
operator|&
literal|0777
operator|)
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Mode (%02o) and entry mode (%02o) "
literal|"mismatch"
argument_list|,
name|mode
argument_list|,
name|archive_entry_mode
argument_list|(
name|ae
argument_list|)
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
name|failure_start
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"Could not find match for ACL "
literal|"(type=%#010x,permset=%#010x,tag=%d,qual=%d,name=``%s'')"
argument_list|,
name|acls
index|[
name|marker
index|[
literal|0
index|]
index|]
operator|.
name|type
argument_list|,
name|acls
index|[
name|marker
index|[
literal|0
index|]
index|]
operator|.
name|permset
argument_list|,
name|acls
index|[
name|marker
index|[
literal|0
index|]
index|]
operator|.
name|tag
argument_list|,
name|acls
index|[
name|marker
index|[
literal|0
index|]
index|]
operator|.
name|qual
argument_list|,
name|acls
index|[
name|marker
index|[
literal|0
index|]
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|failure_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
comment|/* Number of ACLs not matched should == 0 */
block|}
name|free
argument_list|(
name|marker
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(PROGRAM) */
end_comment

begin_comment
comment|/*  *  * TEST management  *  */
end_comment

begin_comment
comment|/*  * "list.h" is simply created by "grep DEFINE_TEST test_*.c"; it has  * a line like  *      DEFINE_TEST(test_function)  * for each test.  */
end_comment

begin_comment
comment|/* Use "list.h" to declare all of the test functions. */
end_comment

begin_undef
undef|#
directive|undef
name|DEFINE_TEST
end_undef

begin_define
define|#
directive|define
name|DEFINE_TEST
parameter_list|(
name|name
parameter_list|)
value|void name(void);
end_define

begin_include
include|#
directive|include
file|"list.h"
end_include

begin_comment
comment|/* Use "list.h" to create a list of all tests (functions and names). */
end_comment

begin_undef
undef|#
directive|undef
name|DEFINE_TEST
end_undef

begin_define
define|#
directive|define
name|DEFINE_TEST
parameter_list|(
name|n
parameter_list|)
value|{ n, #n, 0 },
end_define

begin_decl_stmt
name|struct
name|test_list_t
name|tests
index|[]
init|=
block|{
include|#
directive|include
file|"list.h"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Summarize repeated failures in the just-completed test.  */
end_comment

begin_function
specifier|static
name|void
name|test_summarize
parameter_list|(
name|int
name|failed
parameter_list|,
name|int
name|skips_num
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|verbosity
condition|)
block|{
case|case
name|VERBOSITY_SUMMARY_ONLY
case|:
name|printf
argument_list|(
name|failed
condition|?
literal|"E"
else|:
literal|"."
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|VERBOSITY_PASSFAIL
case|:
name|printf
argument_list|(
name|failed
condition|?
literal|"FAIL\n"
else|:
name|skips_num
condition|?
literal|"ok (S)\n"
else|:
literal|"ok\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|log_console
operator|=
operator|(
name|verbosity
operator|==
name|VERBOSITY_LIGHT_REPORT
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|failed_lines
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|failed_lines
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|failed_lines
index|[
name|i
index|]
operator|.
name|count
operator|>
literal|1
operator|&&
operator|!
name|failed_lines
index|[
name|i
index|]
operator|.
name|skip
condition|)
name|logprintf
argument_list|(
literal|"%s:%d: Summary: Failed %d times\n"
argument_list|,
name|failed_filename
argument_list|,
name|i
argument_list|,
name|failed_lines
index|[
name|i
index|]
operator|.
name|count
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the failure history for the next file. */
name|failed_filename
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
name|failed_lines
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|failed_lines
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Actually run a single test, with appropriate setup and cleanup.  */
end_comment

begin_function
specifier|static
name|int
name|test_run
parameter_list|(
name|int
name|i
parameter_list|,
specifier|const
name|char
modifier|*
name|tmpdir
parameter_list|)
block|{
name|char
name|workdir
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|logfilename
index|[
literal|64
index|]
decl_stmt|;
name|int
name|failures_before
init|=
name|failures
decl_stmt|;
name|int
name|skips_before
init|=
name|skips
decl_stmt|;
name|int
name|oldumask
decl_stmt|;
switch|switch
condition|(
name|verbosity
condition|)
block|{
case|case
name|VERBOSITY_SUMMARY_ONLY
case|:
comment|/* No per-test reports at all */
break|break;
case|case
name|VERBOSITY_PASSFAIL
case|:
comment|/* rest of line will include ok/FAIL marker */
name|printf
argument_list|(
literal|"%3d: %-64s"
argument_list|,
name|i
argument_list|,
name|tests
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Title of test, details will follow */
name|printf
argument_list|(
literal|"%3d: %s\n"
argument_list|,
name|i
argument_list|,
name|tests
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Chdir to the top-level work directory. */
if|if
condition|(
operator|!
name|assertChdir
argument_list|(
name|tmpdir
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: Can't chdir to top work dir %s\n"
argument_list|,
name|tmpdir
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Create a log file for this test. */
name|sprintf
argument_list|(
name|logfilename
argument_list|,
literal|"%s.log"
argument_list|,
name|tests
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|logfile
operator|=
name|fopen
argument_list|(
name|logfilename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|logfile
argument_list|,
literal|"%s\n\n"
argument_list|,
name|tests
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* Chdir() to a work dir for this specific test. */
name|snprintf
argument_list|(
name|workdir
argument_list|,
sizeof|sizeof
argument_list|(
name|workdir
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|tmpdir
argument_list|,
name|tests
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|testworkdir
operator|=
name|workdir
expr_stmt|;
if|if
condition|(
operator|!
name|assertMakeDir
argument_list|(
name|testworkdir
argument_list|,
literal|0755
argument_list|)
operator|||
operator|!
name|assertChdir
argument_list|(
name|testworkdir
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: Can't chdir to work dir %s\n"
argument_list|,
name|testworkdir
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Explicitly reset the locale before each test. */
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|"C"
argument_list|)
expr_stmt|;
comment|/* Record the umask before we run the test. */
name|umask
argument_list|(
name|oldumask
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Run the actual test. 	 */
operator|(
operator|*
name|tests
index|[
name|i
index|]
operator|.
name|func
operator|)
operator|(
operator|)
expr_stmt|;
comment|/* 	 * Clean up and report afterwards. 	 */
name|testworkdir
operator|=
name|NULL
expr_stmt|;
comment|/* Restore umask */
name|umask
argument_list|(
name|oldumask
argument_list|)
expr_stmt|;
comment|/* Reset locale. */
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|"C"
argument_list|)
expr_stmt|;
comment|/* Reset directory. */
if|if
condition|(
operator|!
name|assertChdir
argument_list|(
name|tmpdir
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: Couldn't chdir to temp dir %s\n"
argument_list|,
name|tmpdir
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Report per-test summaries. */
name|tests
index|[
name|i
index|]
operator|.
name|failures
operator|=
name|failures
operator|-
name|failures_before
expr_stmt|;
name|test_summarize
argument_list|(
name|tests
index|[
name|i
index|]
operator|.
name|failures
argument_list|,
name|skips
operator|-
name|skips_before
argument_list|)
expr_stmt|;
comment|/* Close the per-test log file. */
name|fclose
argument_list|(
name|logfile
argument_list|)
expr_stmt|;
name|logfile
operator|=
name|NULL
expr_stmt|;
comment|/* If there were no failures, we can remove the work dir and logfile. */
if|if
condition|(
name|tests
index|[
name|i
index|]
operator|.
name|failures
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|keep_temp_files
operator|&&
name|assertChdir
argument_list|(
name|tmpdir
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
comment|/* Make sure not to leave empty directories. 			 * Sometimes a processing of closing files used by tests 			 * is not done, then rmdir will be failed and it will 			 * leave a empty test directory. So we should wait a few 			 * seconds and retry rmdir. */
name|int
name|r
decl_stmt|,
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
literal|10
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
name|t
operator|>
literal|0
condition|)
name|Sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|r
operator|=
name|systemf
argument_list|(
literal|"rmdir /S /Q %s"
argument_list|,
name|tests
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
break|break;
block|}
name|systemf
argument_list|(
literal|"del %s"
argument_list|,
name|logfilename
argument_list|)
expr_stmt|;
else|#
directive|else
name|systemf
argument_list|(
literal|"rm -rf %s"
argument_list|,
name|tests
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|systemf
argument_list|(
literal|"rm %s"
argument_list|,
name|logfilename
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* Return appropriate status. */
return|return
operator|(
name|tests
index|[
name|i
index|]
operator|.
name|failures
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  *  * MAIN and support routines.  *  *  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
specifier|const
name|char
modifier|*
name|program
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|limit
init|=
sizeof|sizeof
argument_list|(
name|tests
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tests
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"Usage: %s [options]<test><test> ...\n"
argument_list|,
name|program
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Default is to run all tests.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Otherwise, specify the numbers of the tests you wish to run.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Options:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -d  Dump core after any failure, for debugging.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -k  Keep all temp files.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      Default: temp files for successful tests deleted.\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROGRAM
name|printf
argument_list|(
literal|"  -p<path>  Path to executable to be tested.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      Default: path taken from "
name|ENVBASE
literal|" environment variable.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"  -q  Quiet.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -r<dir>   Path to dir containing reference files.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      Default: Current directory.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -u  Keep running specifies tests until one fails.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -v  Verbose.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Available tests:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"  %d: %s\n"
argument_list|,
name|i
argument_list|,
name|tests
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_refdir
parameter_list|(
specifier|const
name|char
modifier|*
name|d
parameter_list|)
block|{
name|size_t
name|tried_size
decl_stmt|,
name|buff_size
decl_stmt|;
name|char
modifier|*
name|buff
decl_stmt|,
modifier|*
name|tried
decl_stmt|,
modifier|*
name|pwd
init|=
name|NULL
decl_stmt|,
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|PATH_MAX
name|buff_size
operator|=
name|PATH_MAX
expr_stmt|;
else|#
directive|else
name|buff_size
operator|=
literal|8192
expr_stmt|;
endif|#
directive|endif
name|buff
operator|=
name|calloc
argument_list|(
name|buff_size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|buff
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to allocate memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate a buffer to hold the various directories we checked. */
name|tried_size
operator|=
name|buff_size
operator|*
literal|2
expr_stmt|;
name|tried
operator|=
name|calloc
argument_list|(
name|tried_size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tried
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to allocate memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If a dir was specified, try that */
if|if
condition|(
name|d
operator|!=
name|NULL
condition|)
block|{
name|pwd
operator|=
name|NULL
expr_stmt|;
name|snprintf
argument_list|(
name|buff
argument_list|,
name|buff_size
argument_list|,
literal|"%s"
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|p
operator|=
name|slurpfile
argument_list|(
name|NULL
argument_list|,
literal|"%s/%s"
argument_list|,
name|buff
argument_list|,
name|KNOWNREF
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
goto|goto
name|success
goto|;
name|strncat
argument_list|(
name|tried
argument_list|,
name|buff
argument_list|,
name|tried_size
operator|-
name|strlen
argument_list|(
name|tried
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|tried
argument_list|,
literal|"\n"
argument_list|,
name|tried_size
operator|-
name|strlen
argument_list|(
name|tried
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
comment|/* Get the current dir. */
ifdef|#
directive|ifdef
name|PATH_MAX
name|pwd
operator|=
name|getcwd
argument_list|(
name|NULL
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
comment|/* Solaris getcwd needs the size. */
else|#
directive|else
name|pwd
operator|=
name|getcwd
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|pwd
index|[
name|strlen
argument_list|(
name|pwd
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|pwd
index|[
name|strlen
argument_list|(
name|pwd
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Look for a known file. */
name|snprintf
argument_list|(
name|buff
argument_list|,
name|buff_size
argument_list|,
literal|"%s"
argument_list|,
name|pwd
argument_list|)
expr_stmt|;
name|p
operator|=
name|slurpfile
argument_list|(
name|NULL
argument_list|,
literal|"%s/%s"
argument_list|,
name|buff
argument_list|,
name|KNOWNREF
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
goto|goto
name|success
goto|;
name|strncat
argument_list|(
name|tried
argument_list|,
name|buff
argument_list|,
name|tried_size
operator|-
name|strlen
argument_list|(
name|tried
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|tried
argument_list|,
literal|"\n"
argument_list|,
name|tried_size
operator|-
name|strlen
argument_list|(
name|tried
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buff
argument_list|,
name|buff_size
argument_list|,
literal|"%s/test"
argument_list|,
name|pwd
argument_list|)
expr_stmt|;
name|p
operator|=
name|slurpfile
argument_list|(
name|NULL
argument_list|,
literal|"%s/%s"
argument_list|,
name|buff
argument_list|,
name|KNOWNREF
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
goto|goto
name|success
goto|;
name|strncat
argument_list|(
name|tried
argument_list|,
name|buff
argument_list|,
name|tried_size
operator|-
name|strlen
argument_list|(
name|tried
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|tried
argument_list|,
literal|"\n"
argument_list|,
name|tried_size
operator|-
name|strlen
argument_list|(
name|tried
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LIBRARY
argument_list|)
name|snprintf
argument_list|(
name|buff
argument_list|,
name|buff_size
argument_list|,
literal|"%s/%s/test"
argument_list|,
name|pwd
argument_list|,
name|LIBRARY
argument_list|)
expr_stmt|;
else|#
directive|else
name|snprintf
argument_list|(
name|buff
argument_list|,
name|buff_size
argument_list|,
literal|"%s/%s/test"
argument_list|,
name|pwd
argument_list|,
name|PROGRAM
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
name|slurpfile
argument_list|(
name|NULL
argument_list|,
literal|"%s/%s"
argument_list|,
name|buff
argument_list|,
name|KNOWNREF
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
goto|goto
name|success
goto|;
name|strncat
argument_list|(
name|tried
argument_list|,
name|buff
argument_list|,
name|tried_size
operator|-
name|strlen
argument_list|(
name|tried
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|tried
argument_list|,
literal|"\n"
argument_list|,
name|tried_size
operator|-
name|strlen
argument_list|(
name|tried
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PROGRAM_ALIAS
argument_list|)
name|snprintf
argument_list|(
name|buff
argument_list|,
name|buff_size
argument_list|,
literal|"%s/%s/test"
argument_list|,
name|pwd
argument_list|,
name|PROGRAM_ALIAS
argument_list|)
expr_stmt|;
name|p
operator|=
name|slurpfile
argument_list|(
name|NULL
argument_list|,
literal|"%s/%s"
argument_list|,
name|buff
argument_list|,
name|KNOWNREF
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
goto|goto
name|success
goto|;
name|strncat
argument_list|(
name|tried
argument_list|,
name|buff
argument_list|,
name|tried_size
operator|-
name|strlen
argument_list|(
name|tried
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|tried
argument_list|,
literal|"\n"
argument_list|,
name|tried_size
operator|-
name|strlen
argument_list|(
name|tried
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|memcmp
argument_list|(
name|pwd
argument_list|,
literal|"/usr/obj"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|buff
argument_list|,
name|buff_size
argument_list|,
literal|"%s"
argument_list|,
name|pwd
operator|+
literal|8
argument_list|)
expr_stmt|;
name|p
operator|=
name|slurpfile
argument_list|(
name|NULL
argument_list|,
literal|"%s/%s"
argument_list|,
name|buff
argument_list|,
name|KNOWNREF
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
goto|goto
name|success
goto|;
name|strncat
argument_list|(
name|tried
argument_list|,
name|buff
argument_list|,
name|tried_size
operator|-
name|strlen
argument_list|(
name|tried
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|tried
argument_list|,
literal|"\n"
argument_list|,
name|tried_size
operator|-
name|strlen
argument_list|(
name|tried
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buff
argument_list|,
name|buff_size
argument_list|,
literal|"%s/test"
argument_list|,
name|pwd
operator|+
literal|8
argument_list|)
expr_stmt|;
name|p
operator|=
name|slurpfile
argument_list|(
name|NULL
argument_list|,
literal|"%s/%s"
argument_list|,
name|buff
argument_list|,
name|KNOWNREF
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
goto|goto
name|success
goto|;
name|strncat
argument_list|(
name|tried
argument_list|,
name|buff
argument_list|,
name|tried_size
operator|-
name|strlen
argument_list|(
name|tried
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|tried
argument_list|,
literal|"\n"
argument_list|,
name|tried_size
operator|-
name|strlen
argument_list|(
name|tried
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|failure
label|:
name|printf
argument_list|(
literal|"Unable to locate known reference file %s\n"
argument_list|,
name|KNOWNREF
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Checked following directories:\n%s\n"
argument_list|,
name|tried
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Use -r option to specify full path to reference directory\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_DEBUG
argument_list|)
name|DebugBreak
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|success
label|:
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pwd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tried
argument_list|)
expr_stmt|;
comment|/* Copy result into a fresh buffer to reduce memory usage. */
name|p
operator|=
name|strdup
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buff
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|limit
init|=
sizeof|sizeof
argument_list|(
name|tests
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tests
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|test_set
index|[
sizeof|sizeof
argument_list|(
name|tests
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tests
index|[
literal|0
index|]
argument_list|)
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|,
name|tests_run
init|=
literal|0
decl_stmt|,
name|tests_failed
init|=
literal|0
decl_stmt|,
name|option
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|char
modifier|*
name|refdir_alloc
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|progname
decl_stmt|;
name|char
modifier|*
modifier|*
name|saved_argv
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|option_arg
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
name|tmpdir
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|pwd
decl_stmt|,
modifier|*
name|testprogdir
decl_stmt|,
modifier|*
name|tmp2
init|=
name|NULL
decl_stmt|,
modifier|*
name|vlevel
init|=
name|NULL
decl_stmt|;
name|char
name|tmpdir_timestamp
index|[
literal|256
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|argc
expr_stmt|;
comment|/* UNUSED */
comment|/* Get the current dir. */
ifdef|#
directive|ifdef
name|PATH_MAX
name|pwd
operator|=
name|getcwd
argument_list|(
name|NULL
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
comment|/* Solaris getcwd needs the size. */
else|#
directive|else
name|pwd
operator|=
name|getcwd
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|pwd
index|[
name|strlen
argument_list|(
name|pwd
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|pwd
index|[
name|strlen
argument_list|(
name|pwd
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE__CrtSetReportMode
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__WATCOMC__
argument_list|)
comment|/* To stop to run the default invalid parameter handler. */
name|_set_invalid_parameter_handler
argument_list|(
name|invalid_parameter_handler
argument_list|)
expr_stmt|;
comment|/* Disable annoying assertion message box. */
name|_CrtSetReportMode
argument_list|(
name|_CRT_ASSERT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Name of this program, used to build root of our temp directory 	 * tree. 	 */
name|progname
operator|=
name|p
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|testprogdir
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|progname
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: Out of memory."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|testprogdir
argument_list|,
name|progname
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Support \ or / dir separators for Windows compat. */
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
operator|||
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
name|progname
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|i
operator|=
name|j
expr_stmt|;
block|}
operator|++
name|p
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|testprogdir
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
if|if
condition|(
name|testprogdir
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|&&
name|testprogdir
index|[
literal|0
index|]
operator|!=
literal|'\\'
operator|&&
operator|!
operator|(
operator|(
operator|(
name|testprogdir
index|[
literal|0
index|]
operator|>=
literal|'a'
operator|&&
name|testprogdir
index|[
literal|0
index|]
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|testprogdir
index|[
literal|0
index|]
operator|>=
literal|'A'
operator|&&
name|testprogdir
index|[
literal|0
index|]
operator|<=
literal|'Z'
operator|)
operator|)
operator|&&
name|testprogdir
index|[
literal|1
index|]
operator|==
literal|':'
operator|&&
operator|(
name|testprogdir
index|[
literal|2
index|]
operator|==
literal|'/'
operator|||
name|testprogdir
index|[
literal|2
index|]
operator|==
literal|'\\'
operator|)
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|testprogdir
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
endif|#
directive|endif
block|{
comment|/* Fixup path for relative directories. */
if|if
condition|(
operator|(
name|testprogdir
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|testprogdir
argument_list|,
name|strlen
argument_list|(
name|pwd
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|testprogdir
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: Out of memory."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|memmove
argument_list|(
name|testprogdir
operator|+
name|strlen
argument_list|(
name|pwd
argument_list|)
operator|+
literal|1
argument_list|,
name|testprogdir
argument_list|,
name|strlen
argument_list|(
name|testprogdir
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|testprogdir
argument_list|,
name|pwd
argument_list|,
name|strlen
argument_list|(
name|pwd
argument_list|)
argument_list|)
expr_stmt|;
name|testprogdir
index|[
name|strlen
argument_list|(
name|pwd
argument_list|)
index|]
operator|=
literal|'/'
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PROGRAM
comment|/* Get the target program from environment, if available. */
name|testprogfile
operator|=
name|getenv
argument_list|(
name|ENVBASE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|getenv
argument_list|(
literal|"TMPDIR"
argument_list|)
operator|!=
name|NULL
condition|)
name|tmp
operator|=
name|getenv
argument_list|(
literal|"TMPDIR"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|getenv
argument_list|(
literal|"TMP"
argument_list|)
operator|!=
name|NULL
condition|)
name|tmp
operator|=
name|getenv
argument_list|(
literal|"TMP"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|getenv
argument_list|(
literal|"TEMP"
argument_list|)
operator|!=
name|NULL
condition|)
name|tmp
operator|=
name|getenv
argument_list|(
literal|"TEMP"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|getenv
argument_list|(
literal|"TEMPDIR"
argument_list|)
operator|!=
name|NULL
condition|)
name|tmp
operator|=
name|getenv
argument_list|(
literal|"TEMPDIR"
argument_list|)
expr_stmt|;
else|else
name|tmp
operator|=
literal|"/tmp"
expr_stmt|;
comment|/* Allow -d to be controlled through the environment. */
if|if
condition|(
name|getenv
argument_list|(
name|ENVBASE
literal|"_DEBUG"
argument_list|)
operator|!=
name|NULL
condition|)
name|dump_on_failure
operator|=
literal|1
expr_stmt|;
comment|/* Allow -v to be controlled through the environment. */
if|if
condition|(
name|getenv
argument_list|(
literal|"_VERBOSITY_LEVEL"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|vlevel
operator|=
name|getenv
argument_list|(
literal|"_VERBOSITY_LEVEL"
argument_list|)
expr_stmt|;
name|verbosity
operator|=
name|atoi
argument_list|(
name|vlevel
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|<
name|VERBOSITY_SUMMARY_ONLY
operator|||
name|verbosity
operator|>
name|VERBOSITY_FULL
condition|)
block|{
comment|/* Unsupported verbosity levels are silently ignored */
name|vlevel
operator|=
name|NULL
expr_stmt|;
name|verbosity
operator|=
name|VERBOSITY_PASSFAIL
expr_stmt|;
block|}
block|}
comment|/* Get the directory holding test files from environment. */
name|refdir
operator|=
name|getenv
argument_list|(
name|ENVBASE
literal|"_TEST_FILES"
argument_list|)
expr_stmt|;
comment|/* 	 * Parse options, without using getopt(), which isn't available 	 * on all platforms. 	 */
operator|++
name|argv
expr_stmt|;
comment|/* Skip program name */
while|while
condition|(
operator|*
name|argv
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|argv
operator|!=
literal|'-'
condition|)
break|break;
name|p
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
operator|++
name|p
expr_stmt|;
comment|/* Skip '-' */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|option
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|option_arg
operator|=
name|NULL
expr_stmt|;
comment|/* If 'opt' takes an argument, parse that. */
if|if
condition|(
name|option
operator|==
literal|'p'
operator|||
name|option
operator|==
literal|'r'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|option_arg
operator|=
name|p
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|argv
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Option -%c requires argument.\n"
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|progname
argument_list|)
expr_stmt|;
block|}
else|else
name|option_arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
name|p
operator|=
literal|""
expr_stmt|;
comment|/* End of this option word. */
block|}
comment|/* Now, handle the option. */
switch|switch
condition|(
name|option
condition|)
block|{
case|case
literal|'d'
case|:
name|dump_on_failure
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|keep_temp_files
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
ifdef|#
directive|ifdef
name|PROGRAM
name|testprogfile
operator|=
name|option_arg
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-p option not permitted\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|progname
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'q'
case|:
if|if
condition|(
operator|!
name|vlevel
condition|)
name|verbosity
operator|--
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|refdir
operator|=
name|option_arg
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|until_failure
operator|++
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
if|if
condition|(
operator|!
name|vlevel
condition|)
name|verbosity
operator|++
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unrecognized option '%c'\n"
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|progname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Sanity-check that our options make sense. 	 */
ifdef|#
directive|ifdef
name|PROGRAM
if|if
condition|(
name|testprogfile
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|tmp2
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|testprogdir
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|PROGRAM
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: Out of memory."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|tmp2
argument_list|,
name|testprogdir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp2
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp2
argument_list|,
name|PROGRAM
argument_list|)
expr_stmt|;
name|testprogfile
operator|=
name|tmp2
expr_stmt|;
block|}
block|{
name|char
modifier|*
name|testprg
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
comment|/* Command.com sometimes rejects '/' separators. */
name|testprg
operator|=
name|strdup
argument_list|(
name|testprogfile
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|testprg
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|testprg
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
name|testprg
index|[
name|i
index|]
operator|=
literal|'\\'
expr_stmt|;
block|}
name|testprogfile
operator|=
name|testprg
expr_stmt|;
endif|#
directive|endif
comment|/* Quote the name that gets put into shell command lines. */
name|testprg
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|testprogfile
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|testprg
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|testprg
argument_list|,
name|testprogfile
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|testprg
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|testprog
operator|=
name|testprg
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGPIPE
argument_list|)
block|{
comment|/* Ignore SIGPIPE signals */
name|struct
name|sigaction
name|sa
decl_stmt|;
name|sa
operator|.
name|sa_handler
operator|=
name|SIG_IGN
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sa
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigaction
argument_list|(
name|SIGPIPE
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Create a temp directory for the following tests. 	 * Include the time the tests started as part of the name, 	 * to make it easier to track the results of multiple tests. 	 */
name|now
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|strftime
argument_list|(
name|tmpdir_timestamp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpdir_timestamp
argument_list|)
argument_list|,
literal|"%Y-%m-%dT%H.%M.%S"
argument_list|,
name|localtime
argument_list|(
operator|&
name|now
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmpdir
argument_list|,
literal|"%s/%s.%s-%03d"
argument_list|,
name|tmp
argument_list|,
name|progname
argument_list|,
name|tmpdir_timestamp
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|assertMakeDir
argument_list|(
name|tmpdir
argument_list|,
literal|0755
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
literal|999
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: Unable to create temp directory %s\n"
argument_list|,
name|tmpdir
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If the user didn't specify a directory for locating 	 * reference files, try to find the reference files in 	 * the "usual places." 	 */
name|refdir
operator|=
name|refdir_alloc
operator|=
name|get_refdir
argument_list|(
name|refdir
argument_list|)
expr_stmt|;
comment|/* 	 * Banner with basic information. 	 */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"If tests fail or crash, details will be in:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   %s\n"
argument_list|,
name|tmpdir
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>
name|VERBOSITY_SUMMARY_ONLY
condition|)
block|{
name|printf
argument_list|(
literal|"Reference files will be read from: %s\n"
argument_list|,
name|refdir
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROGRAM
name|printf
argument_list|(
literal|"Running tests on: %s\n"
argument_list|,
name|testprog
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"Exercising: "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|EXTRA_VERSION
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Running "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Run some or all of the individual tests. 	 */
name|saved_argv
operator|=
name|argv
expr_stmt|;
do|do
block|{
name|argv
operator|=
name|saved_argv
expr_stmt|;
do|do
block|{
name|int
name|test_num
decl_stmt|;
name|test_num
operator|=
name|get_test_set
argument_list|(
name|test_set
argument_list|,
name|limit
argument_list|,
operator|*
name|argv
argument_list|,
name|tests
argument_list|)
expr_stmt|;
if|if
condition|(
name|test_num
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"*** INVALID Test %s\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|refdir_alloc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|testprogdir
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|progname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|test_num
condition|;
name|i
operator|++
control|)
block|{
name|tests_run
operator|++
expr_stmt|;
if|if
condition|(
name|test_run
argument_list|(
name|test_set
index|[
name|i
index|]
argument_list|,
name|tmpdir
argument_list|)
condition|)
block|{
name|tests_failed
operator|++
expr_stmt|;
if|if
condition|(
name|until_failure
condition|)
goto|goto
name|finish
goto|;
block|}
block|}
if|if
condition|(
operator|*
name|argv
operator|!=
name|NULL
condition|)
name|argv
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|argv
operator|!=
name|NULL
condition|)
do|;
block|}
do|while
condition|(
name|until_failure
condition|)
do|;
name|finish
label|:
comment|/* Must be freed after all tests run */
name|free
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|testprogdir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pwd
argument_list|)
expr_stmt|;
comment|/* 	 * Report summary statistics. 	 */
if|if
condition|(
name|verbosity
operator|>
name|VERBOSITY_SUMMARY_ONLY
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Totals:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Tests run:         %8d\n"
argument_list|,
name|tests_run
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Tests failed:      %8d\n"
argument_list|,
name|tests_failed
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Assertions checked:%8d\n"
argument_list|,
name|assertions
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Assertions failed: %8d\n"
argument_list|,
name|failures
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Skips reported:    %8d\n"
argument_list|,
name|skips
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|failures
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Failing tests:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|tests
index|[
name|i
index|]
operator|.
name|failures
condition|)
name|printf
argument_list|(
literal|"  %d: %s (%d failures)\n"
argument_list|,
name|i
argument_list|,
name|tests
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|tests
index|[
name|i
index|]
operator|.
name|failures
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Details for failing tests: %s\n"
argument_list|,
name|tmpdir
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbosity
operator|==
name|VERBOSITY_SUMMARY_ONLY
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d tests passed, no failures\n"
argument_list|,
name|tests_run
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|refdir_alloc
argument_list|)
expr_stmt|;
comment|/* If the final tmpdir is empty, we can remove it. */
comment|/* This should be the usual case when all tests succeed. */
name|assertChdir
argument_list|(
literal|".."
argument_list|)
expr_stmt|;
name|rmdir
argument_list|(
name|tmpdir
argument_list|)
expr_stmt|;
return|return
operator|(
name|tests_failed
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

end_unit

