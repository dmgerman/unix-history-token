begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009 Michihiro NAKAJIMA  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"archive_platform.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ERRNO_H
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_LIBXML_XMLREADER_H
end_if

begin_include
include|#
directive|include
file|<libxml/xmlreader.h>
end_include

begin_elif
elif|#
directive|elif
name|HAVE_BSDXML_H
end_elif

begin_include
include|#
directive|include
file|<bsdxml.h>
end_include

begin_elif
elif|#
directive|elif
name|HAVE_EXPAT_H
end_elif

begin_include
include|#
directive|include
file|<expat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_BZLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<bzlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_LZMA_H
end_if

begin_include
include|#
directive|include
file|<lzma.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"archive.h"
end_include

begin_include
include|#
directive|include
file|"archive_digest_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_endian.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry_locale.h"
end_include

begin_include
include|#
directive|include
file|"archive_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_read_private.h"
end_include

begin_if
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|HAVE_LIBXML_XMLREADER_H
argument_list|)
operator|&&
expr|\
operator|!
name|defined
argument_list|(
name|HAVE_BSDXML_H
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_EXPAT_H
argument_list|)
operator|)
operator|||
expr|\
operator|!
name|defined
argument_list|(
name|HAVE_ZLIB_H
argument_list|)
operator|||
expr|\
operator|!
name|defined
argument_list|(
name|ARCHIVE_HAS_MD5
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|ARCHIVE_HAS_SHA1
argument_list|)
end_if

begin_comment
comment|/*  * xar needs several external libraries.  *   o libxml2 or expat --- XML parser  *   o openssl or MD5/SHA1 hash function  *   o zlib  *   o bzlib2 (option)  *   o liblzma (option)  */
end_comment

begin_function
name|int
name|archive_read_support_format_xar
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_READ_MAGIC
argument_list|,
name|ARCHIVE_STATE_NEW
argument_list|,
literal|"archive_read_support_format_xar"
argument_list|)
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Xar not supported on this platform"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Support xar format */
end_comment

begin_comment
comment|/* #define DEBUG 1 */
end_comment

begin_comment
comment|/* #define DEBUG_PRINT_TOC 1 */
end_comment

begin_if
if|#
directive|if
name|DEBUG_PRINT_TOC
end_if

begin_define
define|#
directive|define
name|PRINT_TOC
parameter_list|(
name|d
parameter_list|,
name|outbytes
parameter_list|)
value|do {				\ 	unsigned char *x = (unsigned char *)(uintptr_t)d;	\ 	unsigned char c = x[outbytes-1];			\ 	x[outbytes - 1] = 0;					\ 	fprintf(stderr, "%s", x);				\ 	fprintf(stderr, "%c", c);				\ 	x[outbytes - 1] = c;					\ } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PRINT_TOC
parameter_list|(
name|d
parameter_list|,
name|outbytes
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|HEADER_MAGIC
value|0x78617221
end_define

begin_define
define|#
directive|define
name|HEADER_SIZE
value|28
end_define

begin_define
define|#
directive|define
name|HEADER_VERSION
value|1
end_define

begin_define
define|#
directive|define
name|CKSUM_NONE
value|0
end_define

begin_define
define|#
directive|define
name|CKSUM_SHA1
value|1
end_define

begin_define
define|#
directive|define
name|CKSUM_MD5
value|2
end_define

begin_define
define|#
directive|define
name|MD5_SIZE
value|16
end_define

begin_define
define|#
directive|define
name|SHA1_SIZE
value|20
end_define

begin_define
define|#
directive|define
name|MAX_SUM_SIZE
value|20
end_define

begin_enum
enum|enum
name|enctype
block|{
name|NONE
block|,
name|GZIP
block|,
name|BZIP2
block|,
name|LZMA
block|,
name|XZ
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|chksumval
block|{
name|int
name|alg
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|unsigned
name|char
name|val
index|[
name|MAX_SUM_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|chksumwork
block|{
name|int
name|alg
decl_stmt|;
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_MD5
name|archive_md5_ctx
name|md5ctx
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA1
name|archive_sha1_ctx
name|sha1ctx
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_struct
struct|struct
name|xattr
block|{
name|struct
name|xattr
modifier|*
name|next
decl_stmt|;
name|struct
name|archive_string
name|name
decl_stmt|;
name|uint64_t
name|id
decl_stmt|;
name|uint64_t
name|length
decl_stmt|;
name|uint64_t
name|offset
decl_stmt|;
name|uint64_t
name|size
decl_stmt|;
name|enum
name|enctype
name|encoding
decl_stmt|;
name|struct
name|chksumval
name|a_sum
decl_stmt|;
name|struct
name|chksumval
name|e_sum
decl_stmt|;
name|struct
name|archive_string
name|fstype
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|xar_file
block|{
name|struct
name|xar_file
modifier|*
name|next
decl_stmt|;
name|struct
name|xar_file
modifier|*
name|hdnext
decl_stmt|;
name|struct
name|xar_file
modifier|*
name|parent
decl_stmt|;
name|int
name|subdirs
decl_stmt|;
name|unsigned
name|int
name|has
decl_stmt|;
define|#
directive|define
name|HAS_DATA
value|0x00001
define|#
directive|define
name|HAS_PATHNAME
value|0x00002
define|#
directive|define
name|HAS_SYMLINK
value|0x00004
define|#
directive|define
name|HAS_TIME
value|0x00008
define|#
directive|define
name|HAS_UID
value|0x00010
define|#
directive|define
name|HAS_GID
value|0x00020
define|#
directive|define
name|HAS_MODE
value|0x00040
define|#
directive|define
name|HAS_TYPE
value|0x00080
define|#
directive|define
name|HAS_DEV
value|0x00100
define|#
directive|define
name|HAS_DEVMAJOR
value|0x00200
define|#
directive|define
name|HAS_DEVMINOR
value|0x00400
define|#
directive|define
name|HAS_INO
value|0x00800
define|#
directive|define
name|HAS_FFLAGS
value|0x01000
define|#
directive|define
name|HAS_XATTR
value|0x02000
define|#
directive|define
name|HAS_ACL
value|0x04000
name|uint64_t
name|id
decl_stmt|;
name|uint64_t
name|length
decl_stmt|;
name|uint64_t
name|offset
decl_stmt|;
name|uint64_t
name|size
decl_stmt|;
name|enum
name|enctype
name|encoding
decl_stmt|;
name|struct
name|chksumval
name|a_sum
decl_stmt|;
name|struct
name|chksumval
name|e_sum
decl_stmt|;
name|struct
name|archive_string
name|pathname
decl_stmt|;
name|struct
name|archive_string
name|symlink
decl_stmt|;
name|time_t
name|ctime
decl_stmt|;
name|time_t
name|mtime
decl_stmt|;
name|time_t
name|atime
decl_stmt|;
name|struct
name|archive_string
name|uname
decl_stmt|;
name|int64_t
name|uid
decl_stmt|;
name|struct
name|archive_string
name|gname
decl_stmt|;
name|int64_t
name|gid
decl_stmt|;
name|mode_t
name|mode
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
name|dev_t
name|devmajor
decl_stmt|;
name|dev_t
name|devminor
decl_stmt|;
name|int64_t
name|ino64
decl_stmt|;
name|struct
name|archive_string
name|fflags_text
decl_stmt|;
name|unsigned
name|int
name|link
decl_stmt|;
name|unsigned
name|int
name|nlink
decl_stmt|;
name|struct
name|archive_string
name|hardlink
decl_stmt|;
name|struct
name|xattr
modifier|*
name|xattr_list
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|hdlink
block|{
name|struct
name|hdlink
modifier|*
name|next
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|struct
name|xar_file
modifier|*
name|files
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|heap_queue
block|{
name|struct
name|xar_file
modifier|*
modifier|*
name|files
decl_stmt|;
name|int
name|allocated
decl_stmt|;
name|int
name|used
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|xmlstatus
block|{
name|INIT
block|,
name|XAR
block|,
name|TOC
block|,
name|TOC_CREATION_TIME
block|,
name|TOC_CHECKSUM
block|,
name|TOC_CHECKSUM_OFFSET
block|,
name|TOC_CHECKSUM_SIZE
block|,
name|TOC_FILE
block|,
name|FILE_DATA
block|,
name|FILE_DATA_LENGTH
block|,
name|FILE_DATA_OFFSET
block|,
name|FILE_DATA_SIZE
block|,
name|FILE_DATA_ENCODING
block|,
name|FILE_DATA_A_CHECKSUM
block|,
name|FILE_DATA_E_CHECKSUM
block|,
name|FILE_DATA_CONTENT
block|,
name|FILE_EA
block|,
name|FILE_EA_LENGTH
block|,
name|FILE_EA_OFFSET
block|,
name|FILE_EA_SIZE
block|,
name|FILE_EA_ENCODING
block|,
name|FILE_EA_A_CHECKSUM
block|,
name|FILE_EA_E_CHECKSUM
block|,
name|FILE_EA_NAME
block|,
name|FILE_EA_FSTYPE
block|,
name|FILE_CTIME
block|,
name|FILE_MTIME
block|,
name|FILE_ATIME
block|,
name|FILE_GROUP
block|,
name|FILE_GID
block|,
name|FILE_USER
block|,
name|FILE_UID
block|,
name|FILE_MODE
block|,
name|FILE_DEVICE
block|,
name|FILE_DEVICE_MAJOR
block|,
name|FILE_DEVICE_MINOR
block|,
name|FILE_DEVICENO
block|,
name|FILE_INODE
block|,
name|FILE_LINK
block|,
name|FILE_TYPE
block|,
name|FILE_NAME
block|,
name|FILE_ACL
block|,
name|FILE_ACL_DEFAULT
block|,
name|FILE_ACL_ACCESS
block|,
name|FILE_ACL_APPLEEXTENDED
block|,
comment|/* BSD file flags. */
name|FILE_FLAGS
block|,
name|FILE_FLAGS_USER_NODUMP
block|,
name|FILE_FLAGS_USER_IMMUTABLE
block|,
name|FILE_FLAGS_USER_APPEND
block|,
name|FILE_FLAGS_USER_OPAQUE
block|,
name|FILE_FLAGS_USER_NOUNLINK
block|,
name|FILE_FLAGS_SYS_ARCHIVED
block|,
name|FILE_FLAGS_SYS_IMMUTABLE
block|,
name|FILE_FLAGS_SYS_APPEND
block|,
name|FILE_FLAGS_SYS_NOUNLINK
block|,
name|FILE_FLAGS_SYS_SNAPSHOT
block|,
comment|/* Linux file flags. */
name|FILE_EXT2
block|,
name|FILE_EXT2_SecureDeletion
block|,
name|FILE_EXT2_Undelete
block|,
name|FILE_EXT2_Compress
block|,
name|FILE_EXT2_Synchronous
block|,
name|FILE_EXT2_Immutable
block|,
name|FILE_EXT2_AppendOnly
block|,
name|FILE_EXT2_NoDump
block|,
name|FILE_EXT2_NoAtime
block|,
name|FILE_EXT2_CompDirty
block|,
name|FILE_EXT2_CompBlock
block|,
name|FILE_EXT2_NoCompBlock
block|,
name|FILE_EXT2_CompError
block|,
name|FILE_EXT2_BTree
block|,
name|FILE_EXT2_HashIndexed
block|,
name|FILE_EXT2_iMagic
block|,
name|FILE_EXT2_Journaled
block|,
name|FILE_EXT2_NoTail
block|,
name|FILE_EXT2_DirSync
block|,
name|FILE_EXT2_TopDir
block|,
name|FILE_EXT2_Reserved
block|,
name|UNKNOWN
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|unknown_tag
block|{
name|struct
name|unknown_tag
modifier|*
name|next
decl_stmt|;
name|struct
name|archive_string
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|xar
block|{
name|uint64_t
name|offset
decl_stmt|;
comment|/* Current position in the file. */
name|int64_t
name|total
decl_stmt|;
name|uint64_t
name|h_base
decl_stmt|;
name|int
name|end_of_file
decl_stmt|;
define|#
directive|define
name|OUTBUFF_SIZE
value|(1024 * 64)
name|unsigned
name|char
modifier|*
name|outbuff
decl_stmt|;
name|enum
name|xmlstatus
name|xmlsts
decl_stmt|;
name|enum
name|xmlstatus
name|xmlsts_unknown
decl_stmt|;
name|struct
name|unknown_tag
modifier|*
name|unknowntags
decl_stmt|;
name|int
name|base64text
decl_stmt|;
comment|/* 	 * TOC 	 */
name|uint64_t
name|toc_remaining
decl_stmt|;
name|uint64_t
name|toc_total
decl_stmt|;
name|uint64_t
name|toc_chksum_offset
decl_stmt|;
name|uint64_t
name|toc_chksum_size
decl_stmt|;
comment|/* 	 * For Decoding data. 	 */
name|enum
name|enctype
name|rd_encoding
decl_stmt|;
name|z_stream
name|stream
decl_stmt|;
name|int
name|stream_valid
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_BZLIB_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|BZ_CONFIG_ERROR
argument_list|)
name|bz_stream
name|bzstream
decl_stmt|;
name|int
name|bzstream_valid
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_LZMA_H
operator|&&
name|HAVE_LIBLZMA
name|lzma_stream
name|lzstream
decl_stmt|;
name|int
name|lzstream_valid
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * For Checksum data. 	 */
name|struct
name|chksumwork
name|a_sumwrk
decl_stmt|;
name|struct
name|chksumwork
name|e_sumwrk
decl_stmt|;
name|struct
name|xar_file
modifier|*
name|file
decl_stmt|;
comment|/* current reading file. */
name|struct
name|xattr
modifier|*
name|xattr
decl_stmt|;
comment|/* current reading extended attribute. */
name|struct
name|heap_queue
name|file_queue
decl_stmt|;
name|struct
name|xar_file
modifier|*
name|hdlink_orgs
decl_stmt|;
name|struct
name|hdlink
modifier|*
name|hdlink_list
decl_stmt|;
name|int
name|entry_init
decl_stmt|;
name|uint64_t
name|entry_total
decl_stmt|;
name|uint64_t
name|entry_remaining
decl_stmt|;
name|size_t
name|entry_unconsumed
decl_stmt|;
name|uint64_t
name|entry_size
decl_stmt|;
name|enum
name|enctype
name|entry_encoding
decl_stmt|;
name|struct
name|chksumval
name|entry_a_sum
decl_stmt|;
name|struct
name|chksumval
name|entry_e_sum
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|sconv
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|xmlattr
block|{
name|struct
name|xmlattr
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|xmlattr_list
block|{
name|struct
name|xmlattr
modifier|*
name|first
decl_stmt|;
name|struct
name|xmlattr
modifier|*
modifier|*
name|last
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|xar_bid
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xar_read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xar_read_data
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|int64_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xar_read_data_skip
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xar_cleanup
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|move_reading_point
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|uint64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rd_contents_init
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|enum
name|enctype
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rd_contents
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|uint64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|atol10
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|atol8
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|atohex
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|time_t
name|parse_time
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|heap_add_entry
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|heap_queue
modifier|*
parameter_list|,
name|struct
name|xar_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|xar_file
modifier|*
name|heap_get_entry
parameter_list|(
name|struct
name|heap_queue
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_link
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|xar
modifier|*
parameter_list|,
name|struct
name|xar_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|checksum_init
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|checksum_update
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|checksum_final
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|checksum_cleanup
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|decompression_init
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|enum
name|enctype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|decompress
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|decompression_cleanup
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xmlattr_cleanup
parameter_list|(
name|struct
name|xmlattr_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|file_new
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|xar
modifier|*
parameter_list|,
name|struct
name|xmlattr_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|file_free
parameter_list|(
name|struct
name|xar_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xattr_new
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|xar
modifier|*
parameter_list|,
name|struct
name|xmlattr_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xattr_free
parameter_list|(
name|struct
name|xattr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getencoding
parameter_list|(
name|struct
name|xmlattr_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getsumalgorithm
parameter_list|(
name|struct
name|xmlattr_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|unknowntag_start
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|xar
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unknowntag_end
parameter_list|(
name|struct
name|xar
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xml_start
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|xmlattr_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xml_end
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xml_data
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xml_parse_file_flags
parameter_list|(
name|struct
name|xar
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xml_parse_file_ext2
parameter_list|(
name|struct
name|xar
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LIBXML_XMLREADER_H
argument_list|)
end_if

begin_function_decl
specifier|static
name|int
name|xml2_xmlattr_setup
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|xmlattr_list
modifier|*
parameter_list|,
name|xmlTextReaderPtr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xml2_read_cb
parameter_list|(
name|void
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xml2_close_cb
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xml2_error_hdr
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|xmlParserSeverities
parameter_list|,
name|xmlTextReaderLocatorPtr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xml2_read_toc
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_BSDXML_H
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_EXPAT_H
argument_list|)
end_elif

begin_struct
struct|struct
name|expat_userData
block|{
name|int
name|state
decl_stmt|;
name|struct
name|archive_read
modifier|*
name|archive
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|expat_xmlattr_setup
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|xmlattr_list
modifier|*
parameter_list|,
specifier|const
name|XML_Char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expat_start_cb
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|XML_Char
modifier|*
parameter_list|,
specifier|const
name|XML_Char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expat_end_cb
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|XML_Char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expat_data_cb
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|XML_Char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|expat_read_toc
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|archive_read_support_format_xar
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|int
name|r
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_READ_MAGIC
argument_list|,
name|ARCHIVE_STATE_NEW
argument_list|,
literal|"archive_read_support_format_xar"
argument_list|)
expr_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|xar
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xar
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate xar data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|r
operator|=
name|__archive_read_register_format
argument_list|(
name|a
argument_list|,
name|xar
argument_list|,
literal|"xar"
argument_list|,
name|xar_bid
argument_list|,
name|NULL
argument_list|,
name|xar_read_header
argument_list|,
name|xar_read_data
argument_list|,
name|xar_read_data_skip
argument_list|,
name|NULL
argument_list|,
name|xar_cleanup
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|free
argument_list|(
name|xar
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xar_bid
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|int
name|best_bid
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|b
decl_stmt|;
name|int
name|bid
decl_stmt|;
operator|(
name|void
operator|)
name|best_bid
expr_stmt|;
comment|/* UNUSED */
name|b
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|HEADER_SIZE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bid
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Verify magic code 	 */
if|if
condition|(
name|archive_be32dec
argument_list|(
name|b
argument_list|)
operator|!=
name|HEADER_MAGIC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bid
operator|+=
literal|32
expr_stmt|;
comment|/* 	 * Verify header size 	 */
if|if
condition|(
name|archive_be16dec
argument_list|(
name|b
operator|+
literal|4
argument_list|)
operator|!=
name|HEADER_SIZE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bid
operator|+=
literal|16
expr_stmt|;
comment|/* 	 * Verify header version 	 */
if|if
condition|(
name|archive_be16dec
argument_list|(
name|b
operator|+
literal|6
argument_list|)
operator|!=
name|HEADER_VERSION
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bid
operator|+=
literal|16
expr_stmt|;
comment|/* 	 * Verify type of checksum 	 */
switch|switch
condition|(
name|archive_be32dec
argument_list|(
name|b
operator|+
literal|24
argument_list|)
condition|)
block|{
case|case
name|CKSUM_NONE
case|:
case|case
name|CKSUM_SHA1
case|:
case|case
name|CKSUM_MD5
case|:
name|bid
operator|+=
literal|32
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|bid
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_toc
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
name|struct
name|xar_file
modifier|*
name|file
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|b
decl_stmt|;
name|uint64_t
name|toc_compressed_size
decl_stmt|;
name|uint64_t
name|toc_uncompressed_size
decl_stmt|;
name|uint32_t
name|toc_chksum_alg
decl_stmt|;
name|ssize_t
name|bytes
decl_stmt|;
name|int
name|r
decl_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
comment|/* 	 * Read xar header. 	 */
name|b
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|HEADER_SIZE
argument_list|,
operator|&
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|<
literal|0
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|bytes
operator|)
return|;
if|if
condition|(
name|bytes
operator|<
name|HEADER_SIZE
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated archive header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|archive_be32dec
argument_list|(
name|b
argument_list|)
operator|!=
name|HEADER_MAGIC
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid header magic"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|archive_be16dec
argument_list|(
name|b
operator|+
literal|6
argument_list|)
operator|!=
name|HEADER_VERSION
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Unsupported header version(%d)"
argument_list|,
name|archive_be16dec
argument_list|(
name|b
operator|+
literal|6
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|toc_compressed_size
operator|=
name|archive_be64dec
argument_list|(
name|b
operator|+
literal|8
argument_list|)
expr_stmt|;
name|xar
operator|->
name|toc_remaining
operator|=
name|toc_compressed_size
expr_stmt|;
name|toc_uncompressed_size
operator|=
name|archive_be64dec
argument_list|(
name|b
operator|+
literal|16
argument_list|)
expr_stmt|;
name|toc_chksum_alg
operator|=
name|archive_be32dec
argument_list|(
name|b
operator|+
literal|24
argument_list|)
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|HEADER_SIZE
argument_list|)
expr_stmt|;
name|xar
operator|->
name|offset
operator|+=
name|HEADER_SIZE
expr_stmt|;
name|xar
operator|->
name|toc_total
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Read TOC(Table of Contents). 	 */
comment|/* Initialize reading contents. */
name|r
operator|=
name|move_reading_point
argument_list|(
name|a
argument_list|,
name|HEADER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|r
operator|=
name|rd_contents_init
argument_list|(
name|a
argument_list|,
name|GZIP
argument_list|,
name|toc_chksum_alg
argument_list|,
name|CKSUM_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
ifdef|#
directive|ifdef
name|HAVE_LIBXML_XMLREADER_H
name|r
operator|=
name|xml2_read_toc
argument_list|(
name|a
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_BSDXML_H
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_EXPAT_H
argument_list|)
name|r
operator|=
name|expat_read_toc
argument_list|(
name|a
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
comment|/* Set 'The HEAP' base. */
name|xar
operator|->
name|h_base
operator|=
name|xar
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|xar
operator|->
name|toc_total
operator|!=
name|toc_uncompressed_size
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"TOC uncompressed size error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* 	 * Checksum TOC 	 */
if|if
condition|(
name|toc_chksum_alg
operator|!=
name|CKSUM_NONE
condition|)
block|{
name|r
operator|=
name|move_reading_point
argument_list|(
name|a
argument_list|,
name|xar
operator|->
name|toc_chksum_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|b
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
operator|(
name|size_t
operator|)
name|xar
operator|->
name|toc_chksum_size
argument_list|,
operator|&
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|<
literal|0
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|bytes
operator|)
return|;
if|if
condition|(
operator|(
name|uint64_t
operator|)
name|bytes
operator|<
name|xar
operator|->
name|toc_chksum_size
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated archive file"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|r
operator|=
name|checksum_final
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
operator|(
name|size_t
operator|)
name|xar
operator|->
name|toc_chksum_size
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|xar
operator|->
name|toc_chksum_size
argument_list|)
expr_stmt|;
name|xar
operator|->
name|offset
operator|+=
name|xar
operator|->
name|toc_chksum_size
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* 	 * Connect hardlinked files. 	 */
for|for
control|(
name|file
operator|=
name|xar
operator|->
name|hdlink_orgs
init|;
name|file
operator|!=
name|NULL
condition|;
name|file
operator|=
name|file
operator|->
name|hdnext
control|)
block|{
name|struct
name|hdlink
modifier|*
modifier|*
name|hdlink
decl_stmt|;
for|for
control|(
name|hdlink
operator|=
operator|&
operator|(
name|xar
operator|->
name|hdlink_list
operator|)
init|;
operator|*
name|hdlink
operator|!=
name|NULL
condition|;
name|hdlink
operator|=
operator|&
operator|(
operator|(
operator|*
name|hdlink
operator|)
operator|->
name|next
operator|)
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|hdlink
operator|)
operator|->
name|id
operator|==
name|file
operator|->
name|id
condition|)
block|{
name|struct
name|hdlink
modifier|*
name|hltmp
decl_stmt|;
name|struct
name|xar_file
modifier|*
name|f2
decl_stmt|;
name|int
name|nlink
init|=
operator|(
operator|*
name|hdlink
operator|)
operator|->
name|cnt
operator|+
literal|1
decl_stmt|;
name|file
operator|->
name|nlink
operator|=
name|nlink
expr_stmt|;
for|for
control|(
name|f2
operator|=
operator|(
operator|*
name|hdlink
operator|)
operator|->
name|files
init|;
name|f2
operator|!=
name|NULL
condition|;
name|f2
operator|=
name|f2
operator|->
name|hdnext
control|)
block|{
name|f2
operator|->
name|nlink
operator|=
name|nlink
expr_stmt|;
name|archive_string_copy
argument_list|(
operator|&
operator|(
name|f2
operator|->
name|hardlink
operator|)
argument_list|,
operator|&
operator|(
name|file
operator|->
name|pathname
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Remove resolved files from hdlist_list. */
name|hltmp
operator|=
operator|*
name|hdlink
expr_stmt|;
operator|*
name|hdlink
operator|=
name|hltmp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|hltmp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_XAR
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"xar"
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xar_read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
name|struct
name|xar_file
modifier|*
name|file
decl_stmt|;
name|struct
name|xattr
modifier|*
name|xattr
decl_stmt|;
name|int
name|r
decl_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
name|r
operator|=
name|ARCHIVE_OK
expr_stmt|;
if|if
condition|(
name|xar
operator|->
name|offset
operator|==
literal|0
condition|)
block|{
comment|/* Create a character conversion object. */
if|if
condition|(
name|xar
operator|->
name|sconv
operator|==
name|NULL
condition|)
block|{
name|xar
operator|->
name|sconv
operator|=
name|archive_string_conversion_from_charset
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
literal|"UTF-8"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xar
operator|->
name|sconv
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Read TOC. */
name|r
operator|=
name|read_toc
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|file
operator|=
name|xar
operator|->
name|file
operator|=
name|heap_get_entry
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|file_queue
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|xar
operator|->
name|end_of_file
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|file
operator|->
name|mode
operator|&
name|AE_IFMT
operator|)
operator|!=
name|AE_IFDIR
condition|)
break|break;
if|if
condition|(
name|file
operator|->
name|has
operator|!=
operator|(
name|HAS_PATHNAME
operator||
name|HAS_TYPE
operator|)
condition|)
break|break;
comment|/* 		 * If a file type is a directory and it does not have 		 * any metadata, do not export. 		 */
name|file_free
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
name|archive_entry_set_atime
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|atime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|archive_entry_set_ctime
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|ctime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|archive_entry_set_mtime
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|mtime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|archive_entry_set_gid
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|gname
operator|.
name|length
operator|>
literal|0
operator|&&
name|archive_entry_copy_gname_l
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|gname
operator|.
name|s
argument_list|,
name|archive_strlen
argument_list|(
operator|&
operator|(
name|file
operator|->
name|gname
operator|)
argument_list|)
argument_list|,
name|xar
operator|->
name|sconv
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for Gname"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Gname cannot be converted from %s to current locale."
argument_list|,
name|archive_string_conversion_charset_name
argument_list|(
name|xar
operator|->
name|sconv
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
name|archive_entry_set_uid
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|uname
operator|.
name|length
operator|>
literal|0
operator|&&
name|archive_entry_copy_uname_l
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|uname
operator|.
name|s
argument_list|,
name|archive_strlen
argument_list|(
operator|&
operator|(
name|file
operator|->
name|uname
operator|)
argument_list|)
argument_list|,
name|xar
operator|->
name|sconv
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for Uname"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Uname cannot be converted from %s to current locale."
argument_list|,
name|archive_string_conversion_charset_name
argument_list|(
name|xar
operator|->
name|sconv
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
name|archive_entry_set_mode
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_entry_copy_pathname_l
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|pathname
operator|.
name|s
argument_list|,
name|archive_strlen
argument_list|(
operator|&
operator|(
name|file
operator|->
name|pathname
operator|)
argument_list|)
argument_list|,
name|xar
operator|->
name|sconv
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for Pathname"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Pathname cannot be converted from %s to current locale."
argument_list|,
name|archive_string_conversion_charset_name
argument_list|(
name|xar
operator|->
name|sconv
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
if|if
condition|(
name|file
operator|->
name|symlink
operator|.
name|length
operator|>
literal|0
operator|&&
name|archive_entry_copy_symlink_l
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|symlink
operator|.
name|s
argument_list|,
name|archive_strlen
argument_list|(
operator|&
operator|(
name|file
operator|->
name|symlink
operator|)
argument_list|)
argument_list|,
name|xar
operator|->
name|sconv
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for Linkname"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Linkname cannot be converted from %s to current locale."
argument_list|,
name|archive_string_conversion_charset_name
argument_list|(
name|xar
operator|->
name|sconv
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
comment|/* Set proper nlink. */
if|if
condition|(
operator|(
name|file
operator|->
name|mode
operator|&
name|AE_IFMT
operator|)
operator|==
name|AE_IFDIR
condition|)
name|archive_entry_set_nlink
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|subdirs
operator|+
literal|2
argument_list|)
expr_stmt|;
else|else
name|archive_entry_set_nlink
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|nlink
argument_list|)
expr_stmt|;
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
operator|(
name|file
operator|->
name|hardlink
operator|)
argument_list|)
operator|>
literal|0
condition|)
name|archive_entry_set_hardlink
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|hardlink
operator|.
name|s
argument_list|)
expr_stmt|;
name|archive_entry_set_ino64
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|ino64
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|has
operator|&
name|HAS_DEV
condition|)
name|archive_entry_set_dev
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|has
operator|&
name|HAS_DEVMAJOR
condition|)
name|archive_entry_set_devmajor
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|devmajor
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|has
operator|&
name|HAS_DEVMINOR
condition|)
name|archive_entry_set_devminor
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|devminor
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
operator|(
name|file
operator|->
name|fflags_text
operator|)
argument_list|)
operator|>
literal|0
condition|)
name|archive_entry_copy_fflags_text
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|fflags_text
operator|.
name|s
argument_list|)
expr_stmt|;
name|xar
operator|->
name|entry_init
operator|=
literal|1
expr_stmt|;
name|xar
operator|->
name|entry_total
operator|=
literal|0
expr_stmt|;
name|xar
operator|->
name|entry_remaining
operator|=
name|file
operator|->
name|length
expr_stmt|;
name|xar
operator|->
name|entry_size
operator|=
name|file
operator|->
name|size
expr_stmt|;
name|xar
operator|->
name|entry_encoding
operator|=
name|file
operator|->
name|encoding
expr_stmt|;
name|xar
operator|->
name|entry_a_sum
operator|=
name|file
operator|->
name|a_sum
expr_stmt|;
name|xar
operator|->
name|entry_e_sum
operator|=
name|file
operator|->
name|e_sum
expr_stmt|;
comment|/* 	 * Read extended attributes. 	 */
name|xattr
operator|=
name|file
operator|->
name|xattr_list
expr_stmt|;
while|while
condition|(
name|xattr
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|void
modifier|*
name|d
decl_stmt|;
name|size_t
name|outbytes
decl_stmt|,
name|used
decl_stmt|;
name|r
operator|=
name|move_reading_point
argument_list|(
name|a
argument_list|,
name|xattr
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
break|break;
name|r
operator|=
name|rd_contents_init
argument_list|(
name|a
argument_list|,
name|xattr
operator|->
name|encoding
argument_list|,
name|xattr
operator|->
name|a_sum
operator|.
name|alg
argument_list|,
name|xattr
operator|->
name|e_sum
operator|.
name|alg
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
break|break;
name|d
operator|=
name|NULL
expr_stmt|;
name|r
operator|=
name|rd_contents
argument_list|(
name|a
argument_list|,
operator|&
name|d
argument_list|,
operator|&
name|outbytes
argument_list|,
operator|&
name|used
argument_list|,
name|xattr
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
break|break;
if|if
condition|(
name|outbytes
operator|!=
name|xattr
operator|->
name|size
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Decompressed size error"
argument_list|)
expr_stmt|;
name|r
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
break|break;
block|}
name|r
operator|=
name|checksum_final
argument_list|(
name|a
argument_list|,
name|xattr
operator|->
name|a_sum
operator|.
name|val
argument_list|,
name|xattr
operator|->
name|a_sum
operator|.
name|len
argument_list|,
name|xattr
operator|->
name|e_sum
operator|.
name|val
argument_list|,
name|xattr
operator|->
name|e_sum
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
break|break;
name|archive_entry_xattr_add_entry
argument_list|(
name|entry
argument_list|,
name|xattr
operator|->
name|name
operator|.
name|s
argument_list|,
name|d
argument_list|,
name|outbytes
argument_list|)
expr_stmt|;
name|xattr
operator|=
name|xattr
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|file_free
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
if|if
condition|(
name|xar
operator|->
name|entry_remaining
operator|>
literal|0
condition|)
comment|/* Move reading point to the beginning of current 		 * file contents. */
name|r
operator|=
name|move_reading_point
argument_list|(
name|a
argument_list|,
name|file
operator|->
name|offset
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|ARCHIVE_OK
expr_stmt|;
name|file_free
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xar_read_data
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|int64_t
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
name|size_t
name|used
decl_stmt|;
name|int
name|r
decl_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|xar
operator|->
name|entry_unconsumed
condition|)
block|{
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|xar
operator|->
name|entry_unconsumed
argument_list|)
expr_stmt|;
name|xar
operator|->
name|entry_unconsumed
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|xar
operator|->
name|end_of_file
operator|||
name|xar
operator|->
name|entry_remaining
operator|<=
literal|0
condition|)
block|{
name|r
operator|=
name|ARCHIVE_EOF
expr_stmt|;
goto|goto
name|abort_read_data
goto|;
block|}
if|if
condition|(
name|xar
operator|->
name|entry_init
condition|)
block|{
name|r
operator|=
name|rd_contents_init
argument_list|(
name|a
argument_list|,
name|xar
operator|->
name|entry_encoding
argument_list|,
name|xar
operator|->
name|entry_a_sum
operator|.
name|alg
argument_list|,
name|xar
operator|->
name|entry_e_sum
operator|.
name|alg
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|xar
operator|->
name|entry_remaining
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
name|xar
operator|->
name|entry_init
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|buff
operator|=
name|NULL
expr_stmt|;
name|r
operator|=
name|rd_contents
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|size
argument_list|,
operator|&
name|used
argument_list|,
name|xar
operator|->
name|entry_remaining
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
goto|goto
name|abort_read_data
goto|;
operator|*
name|offset
operator|=
name|xar
operator|->
name|entry_total
expr_stmt|;
name|xar
operator|->
name|entry_total
operator|+=
operator|*
name|size
expr_stmt|;
name|xar
operator|->
name|total
operator|+=
operator|*
name|size
expr_stmt|;
name|xar
operator|->
name|offset
operator|+=
name|used
expr_stmt|;
name|xar
operator|->
name|entry_remaining
operator|-=
name|used
expr_stmt|;
name|xar
operator|->
name|entry_unconsumed
operator|=
name|used
expr_stmt|;
if|if
condition|(
name|xar
operator|->
name|entry_remaining
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|xar
operator|->
name|entry_total
operator|!=
name|xar
operator|->
name|entry_size
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Decompressed size error"
argument_list|)
expr_stmt|;
name|r
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
goto|goto
name|abort_read_data
goto|;
block|}
name|r
operator|=
name|checksum_final
argument_list|(
name|a
argument_list|,
name|xar
operator|->
name|entry_a_sum
operator|.
name|val
argument_list|,
name|xar
operator|->
name|entry_a_sum
operator|.
name|len
argument_list|,
name|xar
operator|->
name|entry_e_sum
operator|.
name|val
argument_list|,
name|xar
operator|->
name|entry_e_sum
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
goto|goto
name|abort_read_data
goto|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
name|abort_read_data
label|:
operator|*
name|buff
operator|=
name|NULL
expr_stmt|;
operator|*
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|offset
operator|=
name|xar
operator|->
name|total
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xar_read_data_skip
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
name|int64_t
name|bytes_skipped
decl_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|xar
operator|->
name|end_of_file
condition|)
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
name|bytes_skipped
operator|=
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|xar
operator|->
name|entry_remaining
operator|+
name|xar
operator|->
name|entry_unconsumed
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_skipped
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|xar
operator|->
name|offset
operator|+=
name|bytes_skipped
expr_stmt|;
name|xar
operator|->
name|entry_unconsumed
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xar_cleanup
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
name|struct
name|hdlink
modifier|*
name|hdlink
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|r
decl_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
name|checksum_cleanup
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|r
operator|=
name|decompression_cleanup
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|hdlink
operator|=
name|xar
operator|->
name|hdlink_list
expr_stmt|;
while|while
condition|(
name|hdlink
operator|!=
name|NULL
condition|)
block|{
name|struct
name|hdlink
modifier|*
name|next
init|=
name|hdlink
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|hdlink
argument_list|)
expr_stmt|;
name|hdlink
operator|=
name|next
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xar
operator|->
name|file_queue
operator|.
name|used
condition|;
name|i
operator|++
control|)
name|file_free
argument_list|(
name|xar
operator|->
name|file_queue
operator|.
name|files
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xar
operator|->
name|file_queue
operator|.
name|files
argument_list|)
expr_stmt|;
while|while
condition|(
name|xar
operator|->
name|unknowntags
operator|!=
name|NULL
condition|)
block|{
name|struct
name|unknown_tag
modifier|*
name|tag
decl_stmt|;
name|tag
operator|=
name|xar
operator|->
name|unknowntags
expr_stmt|;
name|xar
operator|->
name|unknowntags
operator|=
name|tag
operator|->
name|next
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|tag
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tag
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|xar
operator|->
name|outbuff
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xar
argument_list|)
expr_stmt|;
name|a
operator|->
name|format
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|move_reading_point
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|uint64_t
name|offset
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|xar
operator|->
name|offset
operator|-
name|xar
operator|->
name|h_base
operator|!=
name|offset
condition|)
block|{
comment|/* Seek forward to the start of file contents. */
name|int64_t
name|step
decl_stmt|;
name|step
operator|=
name|offset
operator|-
operator|(
name|xar
operator|->
name|offset
operator|-
name|xar
operator|->
name|h_base
operator|)
expr_stmt|;
if|if
condition|(
name|step
operator|>
literal|0
condition|)
block|{
name|step
operator|=
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|step
argument_list|)
expr_stmt|;
if|if
condition|(
name|step
operator|<
literal|0
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|step
operator|)
return|;
name|xar
operator|->
name|offset
operator|+=
name|step
expr_stmt|;
block|}
else|else
block|{
name|int64_t
name|pos
init|=
name|__archive_read_seek
argument_list|(
name|a
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|==
name|ARCHIVE_FAILED
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Cannot seek."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|xar
operator|->
name|offset
operator|=
name|pos
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rd_contents_init
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|enum
name|enctype
name|encoding
parameter_list|,
name|int
name|a_sum_alg
parameter_list|,
name|int
name|e_sum_alg
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
comment|/* Init decompress library. */
if|if
condition|(
operator|(
name|r
operator|=
name|decompression_init
argument_list|(
name|a
argument_list|,
name|encoding
argument_list|)
operator|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
comment|/* Init checksum library. */
name|checksum_init
argument_list|(
name|a
argument_list|,
name|a_sum_alg
argument_list|,
name|e_sum_alg
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rd_contents
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|size_t
modifier|*
name|used
parameter_list|,
name|uint64_t
name|remaining
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|b
decl_stmt|;
name|ssize_t
name|bytes
decl_stmt|;
comment|/* Get whatever bytes are immediately available. */
name|b
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
operator|&
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|<
literal|0
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|bytes
operator|)
return|;
if|if
condition|(
name|bytes
operator|==
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Truncated archive file"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|uint64_t
operator|)
name|bytes
operator|>
name|remaining
condition|)
name|bytes
operator|=
operator|(
name|ssize_t
operator|)
name|remaining
expr_stmt|;
comment|/* 	 * Decompress contents of file. 	 */
operator|*
name|used
operator|=
name|bytes
expr_stmt|;
if|if
condition|(
name|decompress
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|size
argument_list|,
name|b
argument_list|,
name|used
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
comment|/* 	 * Update checksum of a compressed data and a extracted data. 	 */
name|checksum_update
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
operator|*
name|used
argument_list|,
operator|*
name|buff
argument_list|,
operator|*
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Note that this implementation does not (and should not!) obey  * locale settings; you cannot simply substitute strtol here, since  * it does obey locale.  */
end_comment

begin_function
specifier|static
name|uint64_t
name|atol10
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|char_cnt
parameter_list|)
block|{
name|uint64_t
name|l
decl_stmt|;
name|int
name|digit
decl_stmt|;
if|if
condition|(
name|char_cnt
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|l
operator|=
literal|0
expr_stmt|;
name|digit
operator|=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
while|while
condition|(
name|digit
operator|>=
literal|0
operator|&&
name|digit
operator|<
literal|10
operator|&&
name|char_cnt
operator|--
operator|>
literal|0
condition|)
block|{
name|l
operator|=
operator|(
name|l
operator|*
literal|10
operator|)
operator|+
name|digit
expr_stmt|;
name|digit
operator|=
operator|*
operator|++
name|p
operator|-
literal|'0'
expr_stmt|;
block|}
return|return
operator|(
name|l
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int64_t
name|atol8
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|char_cnt
parameter_list|)
block|{
name|int64_t
name|l
decl_stmt|;
name|int
name|digit
decl_stmt|;
if|if
condition|(
name|char_cnt
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|l
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|char_cnt
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'7'
condition|)
name|digit
operator|=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
else|else
break|break;
name|p
operator|++
expr_stmt|;
name|l
operator|<<=
literal|3
expr_stmt|;
name|l
operator||=
name|digit
expr_stmt|;
block|}
return|return
operator|(
name|l
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|atohex
parameter_list|(
name|unsigned
name|char
modifier|*
name|b
parameter_list|,
name|size_t
name|bsize
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|psize
parameter_list|)
block|{
name|size_t
name|fbsize
init|=
name|bsize
decl_stmt|;
while|while
condition|(
name|bsize
operator|&&
name|psize
operator|>
literal|1
condition|)
block|{
name|unsigned
name|char
name|x
decl_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|>=
literal|'a'
operator|&&
name|p
index|[
literal|0
index|]
operator|<=
literal|'z'
condition|)
name|x
operator|=
operator|(
name|p
index|[
literal|0
index|]
operator|-
literal|'a'
operator|+
literal|0x0a
operator|)
operator|<<
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|>=
literal|'A'
operator|&&
name|p
index|[
literal|0
index|]
operator|<=
literal|'Z'
condition|)
name|x
operator|=
operator|(
name|p
index|[
literal|0
index|]
operator|-
literal|'A'
operator|+
literal|0x0a
operator|)
operator|<<
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|>=
literal|'0'
operator|&&
name|p
index|[
literal|0
index|]
operator|<=
literal|'9'
condition|)
name|x
operator|=
operator|(
name|p
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
operator|<<
literal|4
expr_stmt|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|>=
literal|'a'
operator|&&
name|p
index|[
literal|1
index|]
operator|<=
literal|'z'
condition|)
name|x
operator||=
name|p
index|[
literal|1
index|]
operator|-
literal|'a'
operator|+
literal|0x0a
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|>=
literal|'A'
operator|&&
name|p
index|[
literal|1
index|]
operator|<=
literal|'Z'
condition|)
name|x
operator||=
name|p
index|[
literal|1
index|]
operator|-
literal|'A'
operator|+
literal|0x0a
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|p
index|[
literal|1
index|]
operator|<=
literal|'9'
condition|)
name|x
operator||=
name|p
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|b
operator|++
operator|=
name|x
expr_stmt|;
name|bsize
operator|--
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
name|psize
operator|-=
literal|2
expr_stmt|;
block|}
return|return
operator|(
name|fbsize
operator|-
name|bsize
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|time_t
name|time_from_tm
parameter_list|(
name|struct
name|tm
modifier|*
name|t
parameter_list|)
block|{
if|#
directive|if
name|HAVE_TIMEGM
comment|/* Use platform timegm() if available. */
return|return
operator|(
name|timegm
argument_list|(
name|t
argument_list|)
operator|)
return|;
elif|#
directive|elif
name|HAVE__MKGMTIME64
return|return
operator|(
name|_mkgmtime64
argument_list|(
name|t
argument_list|)
operator|)
return|;
else|#
directive|else
comment|/* Else use direct calculation using POSIX assumptions. */
comment|/* First, fix up tm_yday based on the year/month/day. */
name|mktime
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Then we can compute timegm() from first principles. */
return|return
operator|(
name|t
operator|->
name|tm_sec
operator|+
name|t
operator|->
name|tm_min
operator|*
literal|60
operator|+
name|t
operator|->
name|tm_hour
operator|*
literal|3600
operator|+
name|t
operator|->
name|tm_yday
operator|*
literal|86400
operator|+
operator|(
name|t
operator|->
name|tm_year
operator|-
literal|70
operator|)
operator|*
literal|31536000
operator|+
operator|(
operator|(
name|t
operator|->
name|tm_year
operator|-
literal|69
operator|)
operator|/
literal|4
operator|)
operator|*
literal|86400
operator|-
operator|(
operator|(
name|t
operator|->
name|tm_year
operator|-
literal|1
operator|)
operator|/
literal|100
operator|)
operator|*
literal|86400
operator|+
operator|(
operator|(
name|t
operator|->
name|tm_year
operator|+
literal|299
operator|)
operator|/
literal|400
operator|)
operator|*
literal|86400
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|time_t
name|parse_time
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|struct
name|tm
name|tm
decl_stmt|;
name|time_t
name|t
init|=
literal|0
decl_stmt|;
name|int64_t
name|data
decl_stmt|;
name|memset
argument_list|(
operator|&
name|tm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|20
condition|)
return|return
operator|(
name|t
operator|)
return|;
name|data
operator|=
name|atol10
argument_list|(
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|<
literal|1900
condition|)
return|return
operator|(
name|t
operator|)
return|;
name|tm
operator|.
name|tm_year
operator|=
operator|(
name|int
operator|)
name|data
operator|-
literal|1900
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'-'
condition|)
return|return
operator|(
name|t
operator|)
return|;
name|data
operator|=
name|atol10
argument_list|(
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|<
literal|1
operator|||
name|data
operator|>
literal|12
condition|)
return|return
operator|(
name|t
operator|)
return|;
name|tm
operator|.
name|tm_mon
operator|=
operator|(
name|int
operator|)
name|data
operator|-
literal|1
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'-'
condition|)
return|return
operator|(
name|t
operator|)
return|;
name|data
operator|=
name|atol10
argument_list|(
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|<
literal|1
operator|||
name|data
operator|>
literal|31
condition|)
return|return
operator|(
name|t
operator|)
return|;
name|tm
operator|.
name|tm_mday
operator|=
operator|(
name|int
operator|)
name|data
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'T'
condition|)
return|return
operator|(
name|t
operator|)
return|;
name|data
operator|=
name|atol10
argument_list|(
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|<
literal|0
operator|||
name|data
operator|>
literal|23
condition|)
return|return
operator|(
name|t
operator|)
return|;
name|tm
operator|.
name|tm_hour
operator|=
operator|(
name|int
operator|)
name|data
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|':'
condition|)
return|return
operator|(
name|t
operator|)
return|;
name|data
operator|=
name|atol10
argument_list|(
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|<
literal|0
operator|||
name|data
operator|>
literal|59
condition|)
return|return
operator|(
name|t
operator|)
return|;
name|tm
operator|.
name|tm_min
operator|=
operator|(
name|int
operator|)
name|data
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|':'
condition|)
return|return
operator|(
name|t
operator|)
return|;
name|data
operator|=
name|atol10
argument_list|(
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|<
literal|0
operator|||
name|data
operator|>
literal|60
condition|)
return|return
operator|(
name|t
operator|)
return|;
name|tm
operator|.
name|tm_sec
operator|=
operator|(
name|int
operator|)
name|data
expr_stmt|;
if|#
directive|if
literal|0
block|p += 2; 	if (*p != 'Z') 		return (t);
endif|#
directive|endif
name|t
operator|=
name|time_from_tm
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|heap_add_entry
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|heap_queue
modifier|*
name|heap
parameter_list|,
name|struct
name|xar_file
modifier|*
name|file
parameter_list|)
block|{
name|uint64_t
name|file_id
decl_stmt|,
name|parent_id
decl_stmt|;
name|int
name|hole
decl_stmt|,
name|parent
decl_stmt|;
comment|/* Expand our pending files list as necessary. */
if|if
condition|(
name|heap
operator|->
name|used
operator|>=
name|heap
operator|->
name|allocated
condition|)
block|{
name|struct
name|xar_file
modifier|*
modifier|*
name|new_pending_files
decl_stmt|;
name|int
name|new_size
init|=
name|heap
operator|->
name|allocated
operator|*
literal|2
decl_stmt|;
if|if
condition|(
name|heap
operator|->
name|allocated
operator|<
literal|1024
condition|)
name|new_size
operator|=
literal|1024
expr_stmt|;
comment|/* Overflow might keep us from growing the list. */
if|if
condition|(
name|new_size
operator|<=
name|heap
operator|->
name|allocated
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|new_pending_files
operator|=
operator|(
expr|struct
name|xar_file
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|new_size
operator|*
sizeof|sizeof
argument_list|(
name|new_pending_files
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_pending_files
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|new_pending_files
argument_list|,
name|heap
operator|->
name|files
argument_list|,
name|heap
operator|->
name|allocated
operator|*
sizeof|sizeof
argument_list|(
name|new_pending_files
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|heap
operator|->
name|files
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|heap
operator|->
name|files
argument_list|)
expr_stmt|;
name|heap
operator|->
name|files
operator|=
name|new_pending_files
expr_stmt|;
name|heap
operator|->
name|allocated
operator|=
name|new_size
expr_stmt|;
block|}
name|file_id
operator|=
name|file
operator|->
name|id
expr_stmt|;
comment|/* 	 * Start with hole at end, walk it up tree to find insertion point. 	 */
name|hole
operator|=
name|heap
operator|->
name|used
operator|++
expr_stmt|;
while|while
condition|(
name|hole
operator|>
literal|0
condition|)
block|{
name|parent
operator|=
operator|(
name|hole
operator|-
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|parent_id
operator|=
name|heap
operator|->
name|files
index|[
name|parent
index|]
operator|->
name|id
expr_stmt|;
if|if
condition|(
name|file_id
operator|>=
name|parent_id
condition|)
block|{
name|heap
operator|->
name|files
index|[
name|hole
index|]
operator|=
name|file
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
comment|/* Move parent into hole<==> move hole up tree. */
name|heap
operator|->
name|files
index|[
name|hole
index|]
operator|=
name|heap
operator|->
name|files
index|[
name|parent
index|]
expr_stmt|;
name|hole
operator|=
name|parent
expr_stmt|;
block|}
name|heap
operator|->
name|files
index|[
literal|0
index|]
operator|=
name|file
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|xar_file
modifier|*
name|heap_get_entry
parameter_list|(
name|struct
name|heap_queue
modifier|*
name|heap
parameter_list|)
block|{
name|uint64_t
name|a_id
decl_stmt|,
name|b_id
decl_stmt|,
name|c_id
decl_stmt|;
name|int
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|;
name|struct
name|xar_file
modifier|*
name|r
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|heap
operator|->
name|used
operator|<
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * The first file in the list is the earliest; we'll return this. 	 */
name|r
operator|=
name|heap
operator|->
name|files
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * Move the last item in the heap to the root of the tree 	 */
name|heap
operator|->
name|files
index|[
literal|0
index|]
operator|=
name|heap
operator|->
name|files
index|[
operator|--
operator|(
name|heap
operator|->
name|used
operator|)
index|]
expr_stmt|;
comment|/* 	 * Rebalance the heap. 	 */
name|a
operator|=
literal|0
expr_stmt|;
comment|/* Starting element and its heap key */
name|a_id
operator|=
name|heap
operator|->
name|files
index|[
name|a
index|]
operator|->
name|id
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|b
operator|=
name|a
operator|+
name|a
operator|+
literal|1
expr_stmt|;
comment|/* First child */
if|if
condition|(
name|b
operator|>=
name|heap
operator|->
name|used
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|b_id
operator|=
name|heap
operator|->
name|files
index|[
name|b
index|]
operator|->
name|id
expr_stmt|;
name|c
operator|=
name|b
operator|+
literal|1
expr_stmt|;
comment|/* Use second child if it is smaller. */
if|if
condition|(
name|c
operator|<
name|heap
operator|->
name|used
condition|)
block|{
name|c_id
operator|=
name|heap
operator|->
name|files
index|[
name|c
index|]
operator|->
name|id
expr_stmt|;
if|if
condition|(
name|c_id
operator|<
name|b_id
condition|)
block|{
name|b
operator|=
name|c
expr_stmt|;
name|b_id
operator|=
name|c_id
expr_stmt|;
block|}
block|}
if|if
condition|(
name|a_id
operator|<=
name|b_id
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|tmp
operator|=
name|heap
operator|->
name|files
index|[
name|a
index|]
expr_stmt|;
name|heap
operator|->
name|files
index|[
name|a
index|]
operator|=
name|heap
operator|->
name|files
index|[
name|b
index|]
expr_stmt|;
name|heap
operator|->
name|files
index|[
name|b
index|]
operator|=
name|tmp
expr_stmt|;
name|a
operator|=
name|b
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|add_link
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|xar
modifier|*
name|xar
parameter_list|,
name|struct
name|xar_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|hdlink
modifier|*
name|hdlink
decl_stmt|;
for|for
control|(
name|hdlink
operator|=
name|xar
operator|->
name|hdlink_list
init|;
name|hdlink
operator|!=
name|NULL
condition|;
name|hdlink
operator|=
name|hdlink
operator|->
name|next
control|)
block|{
if|if
condition|(
name|hdlink
operator|->
name|id
operator|==
name|file
operator|->
name|link
condition|)
block|{
name|file
operator|->
name|hdnext
operator|=
name|hdlink
operator|->
name|files
expr_stmt|;
name|hdlink
operator|->
name|cnt
operator|++
expr_stmt|;
name|hdlink
operator|->
name|files
operator|=
name|file
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
block|}
name|hdlink
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hdlink
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdlink
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|file
operator|->
name|hdnext
operator|=
name|NULL
expr_stmt|;
name|hdlink
operator|->
name|id
operator|=
name|file
operator|->
name|link
expr_stmt|;
name|hdlink
operator|->
name|cnt
operator|=
literal|1
expr_stmt|;
name|hdlink
operator|->
name|files
operator|=
name|file
expr_stmt|;
name|hdlink
operator|->
name|next
operator|=
name|xar
operator|->
name|hdlink_list
expr_stmt|;
name|xar
operator|->
name|hdlink_list
operator|=
name|hdlink
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_checksum_init
parameter_list|(
name|struct
name|chksumwork
modifier|*
name|sumwrk
parameter_list|,
name|int
name|sum_alg
parameter_list|)
block|{
name|sumwrk
operator|->
name|alg
operator|=
name|sum_alg
expr_stmt|;
switch|switch
condition|(
name|sum_alg
condition|)
block|{
case|case
name|CKSUM_NONE
case|:
break|break;
case|case
name|CKSUM_SHA1
case|:
name|archive_sha1_init
argument_list|(
operator|&
operator|(
name|sumwrk
operator|->
name|sha1ctx
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CKSUM_MD5
case|:
name|archive_md5_init
argument_list|(
operator|&
operator|(
name|sumwrk
operator|->
name|md5ctx
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|_checksum_update
parameter_list|(
name|struct
name|chksumwork
modifier|*
name|sumwrk
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
switch|switch
condition|(
name|sumwrk
operator|->
name|alg
condition|)
block|{
case|case
name|CKSUM_NONE
case|:
break|break;
case|case
name|CKSUM_SHA1
case|:
name|archive_sha1_update
argument_list|(
operator|&
operator|(
name|sumwrk
operator|->
name|sha1ctx
operator|)
argument_list|,
name|buff
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|CKSUM_MD5
case|:
name|archive_md5_update
argument_list|(
operator|&
operator|(
name|sumwrk
operator|->
name|md5ctx
operator|)
argument_list|,
name|buff
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|_checksum_final
parameter_list|(
name|struct
name|chksumwork
modifier|*
name|sumwrk
parameter_list|,
specifier|const
name|void
modifier|*
name|val
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|unsigned
name|char
name|sum
index|[
name|MAX_SUM_SIZE
index|]
decl_stmt|;
name|int
name|r
init|=
name|ARCHIVE_OK
decl_stmt|;
switch|switch
condition|(
name|sumwrk
operator|->
name|alg
condition|)
block|{
case|case
name|CKSUM_NONE
case|:
break|break;
case|case
name|CKSUM_SHA1
case|:
name|archive_sha1_final
argument_list|(
operator|&
operator|(
name|sumwrk
operator|->
name|sha1ctx
operator|)
argument_list|,
name|sum
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|SHA1_SIZE
operator|||
name|memcmp
argument_list|(
name|val
argument_list|,
name|sum
argument_list|,
name|SHA1_SIZE
argument_list|)
operator|!=
literal|0
condition|)
name|r
operator|=
name|ARCHIVE_FAILED
expr_stmt|;
break|break;
case|case
name|CKSUM_MD5
case|:
name|archive_md5_final
argument_list|(
operator|&
operator|(
name|sumwrk
operator|->
name|md5ctx
operator|)
argument_list|,
name|sum
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|MD5_SIZE
operator|||
name|memcmp
argument_list|(
name|val
argument_list|,
name|sum
argument_list|,
name|MD5_SIZE
argument_list|)
operator|!=
literal|0
condition|)
name|r
operator|=
name|ARCHIVE_FAILED
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|checksum_init
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|int
name|a_sum_alg
parameter_list|,
name|int
name|e_sum_alg
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
name|_checksum_init
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|a_sumwrk
operator|)
argument_list|,
name|a_sum_alg
argument_list|)
expr_stmt|;
name|_checksum_init
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|e_sumwrk
operator|)
argument_list|,
name|e_sum_alg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|checksum_update
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|abuff
parameter_list|,
name|size_t
name|asize
parameter_list|,
specifier|const
name|void
modifier|*
name|ebuff
parameter_list|,
name|size_t
name|esize
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
name|_checksum_update
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|a_sumwrk
operator|)
argument_list|,
name|abuff
argument_list|,
name|asize
argument_list|)
expr_stmt|;
name|_checksum_update
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|e_sumwrk
operator|)
argument_list|,
name|ebuff
argument_list|,
name|esize
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|checksum_final
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|a_sum_val
parameter_list|,
name|size_t
name|a_sum_len
parameter_list|,
specifier|const
name|void
modifier|*
name|e_sum_val
parameter_list|,
name|size_t
name|e_sum_len
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
name|int
name|r
decl_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
name|r
operator|=
name|_checksum_final
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|a_sumwrk
operator|)
argument_list|,
name|a_sum_val
argument_list|,
name|a_sum_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_OK
condition|)
name|r
operator|=
name|_checksum_final
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|e_sumwrk
operator|)
argument_list|,
name|e_sum_val
argument_list|,
name|e_sum_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Sumcheck error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|decompression_init
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|enum
name|enctype
name|encoding
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
specifier|const
name|char
modifier|*
name|detail
decl_stmt|;
name|int
name|r
decl_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
name|xar
operator|->
name|rd_encoding
operator|=
name|encoding
expr_stmt|;
switch|switch
condition|(
name|encoding
condition|)
block|{
case|case
name|NONE
case|:
break|break;
case|case
name|GZIP
case|:
if|if
condition|(
name|xar
operator|->
name|stream_valid
condition|)
name|r
operator|=
name|inflateReset
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|stream
operator|)
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|inflateInit
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|stream
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|Z_OK
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Couldn't initialize zlib stream."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|xar
operator|->
name|stream_valid
operator|=
literal|1
expr_stmt|;
name|xar
operator|->
name|stream
operator|.
name|total_in
operator|=
literal|0
expr_stmt|;
name|xar
operator|->
name|stream
operator|.
name|total_out
operator|=
literal|0
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_BZLIB_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|BZ_CONFIG_ERROR
argument_list|)
case|case
name|BZIP2
case|:
if|if
condition|(
name|xar
operator|->
name|bzstream_valid
condition|)
block|{
name|BZ2_bzDecompressEnd
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|bzstream
operator|)
argument_list|)
expr_stmt|;
name|xar
operator|->
name|bzstream_valid
operator|=
literal|0
expr_stmt|;
block|}
name|r
operator|=
name|BZ2_bzDecompressInit
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|bzstream
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|BZ_MEM_ERROR
condition|)
name|r
operator|=
name|BZ2_bzDecompressInit
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|bzstream
operator|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|BZ_OK
condition|)
block|{
name|int
name|err
init|=
name|ARCHIVE_ERRNO_MISC
decl_stmt|;
name|detail
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|BZ_PARAM_ERROR
case|:
name|detail
operator|=
literal|"invalid setup parameter"
expr_stmt|;
break|break;
case|case
name|BZ_MEM_ERROR
case|:
name|err
operator|=
name|ENOMEM
expr_stmt|;
name|detail
operator|=
literal|"out of memory"
expr_stmt|;
break|break;
case|case
name|BZ_CONFIG_ERROR
case|:
name|detail
operator|=
literal|"mis-compiled library"
expr_stmt|;
break|break;
block|}
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|err
argument_list|,
literal|"Internal error initializing decompressor: %s"
argument_list|,
name|detail
operator|==
name|NULL
condition|?
literal|"??"
else|:
name|detail
argument_list|)
expr_stmt|;
name|xar
operator|->
name|bzstream_valid
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|xar
operator|->
name|bzstream_valid
operator|=
literal|1
expr_stmt|;
name|xar
operator|->
name|bzstream
operator|.
name|total_in_lo32
operator|=
literal|0
expr_stmt|;
name|xar
operator|->
name|bzstream
operator|.
name|total_in_hi32
operator|=
literal|0
expr_stmt|;
name|xar
operator|->
name|bzstream
operator|.
name|total_out_lo32
operator|=
literal|0
expr_stmt|;
name|xar
operator|->
name|bzstream
operator|.
name|total_out_hi32
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LZMA_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LIBLZMA
argument_list|)
if|#
directive|if
name|LZMA_VERSION_MAJOR
operator|>=
literal|5
comment|/* Effectively disable the limiter. */
define|#
directive|define
name|LZMA_MEMLIMIT
value|UINT64_MAX
else|#
directive|else
comment|/* NOTE: This needs to check memory size which running system has. */
define|#
directive|define
name|LZMA_MEMLIMIT
value|(1U<< 30)
endif|#
directive|endif
case|case
name|XZ
case|:
case|case
name|LZMA
case|:
if|if
condition|(
name|xar
operator|->
name|lzstream_valid
condition|)
block|{
name|lzma_end
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|lzstream
operator|)
argument_list|)
expr_stmt|;
name|xar
operator|->
name|lzstream_valid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|xar
operator|->
name|entry_encoding
operator|==
name|XZ
condition|)
name|r
operator|=
name|lzma_stream_decoder
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|lzstream
operator|)
argument_list|,
name|LZMA_MEMLIMIT
argument_list|,
comment|/* memlimit */
name|LZMA_CONCATENATED
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|lzma_alone_decoder
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|lzstream
operator|)
argument_list|,
name|LZMA_MEMLIMIT
argument_list|)
expr_stmt|;
comment|/* memlimit */
if|if
condition|(
name|r
operator|!=
name|LZMA_OK
condition|)
block|{
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|LZMA_MEM_ERROR
case|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Internal error initializing "
literal|"compression library: "
literal|"Cannot allocate memory"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LZMA_OPTIONS_ERROR
case|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Internal error initializing "
literal|"compression library: "
literal|"Invalid or unsupported options"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Internal error initializing "
literal|"lzma library"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|xar
operator|->
name|lzstream_valid
operator|=
literal|1
expr_stmt|;
name|xar
operator|->
name|lzstream
operator|.
name|total_in
operator|=
literal|0
expr_stmt|;
name|xar
operator|->
name|lzstream
operator|.
name|total_out
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* 	 * Unsupported compression. 	 */
default|default:
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_BZLIB_H
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|BZ_CONFIG_ERROR
argument_list|)
case|case
name|BZIP2
case|:
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_LZMA_H
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAVE_LIBLZMA
argument_list|)
case|case
name|LZMA
case|:
case|case
name|XZ
case|:
endif|#
directive|endif
switch|switch
condition|(
name|xar
operator|->
name|entry_encoding
condition|)
block|{
case|case
name|BZIP2
case|:
name|detail
operator|=
literal|"bzip2"
expr_stmt|;
break|break;
case|case
name|LZMA
case|:
name|detail
operator|=
literal|"lzma"
expr_stmt|;
break|break;
case|case
name|XZ
case|:
name|detail
operator|=
literal|"xz"
expr_stmt|;
break|break;
default|default:
name|detail
operator|=
literal|"??"
expr_stmt|;
break|break;
block|}
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"%s compression not supported on this platform"
argument_list|,
name|detail
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|decompress
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|outbytes
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|,
name|size_t
modifier|*
name|used
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
name|void
modifier|*
name|outbuff
decl_stmt|;
name|size_t
name|avail_in
decl_stmt|,
name|avail_out
decl_stmt|;
name|int
name|r
decl_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
name|avail_in
operator|=
operator|*
name|used
expr_stmt|;
name|outbuff
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|*
name|buff
expr_stmt|;
if|if
condition|(
name|outbuff
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|xar
operator|->
name|outbuff
operator|==
name|NULL
condition|)
block|{
name|xar
operator|->
name|outbuff
operator|=
name|malloc
argument_list|(
name|OUTBUFF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|xar
operator|->
name|outbuff
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Couldn't allocate memory for out buffer"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
name|outbuff
operator|=
name|xar
operator|->
name|outbuff
expr_stmt|;
operator|*
name|buff
operator|=
name|outbuff
expr_stmt|;
name|avail_out
operator|=
name|OUTBUFF_SIZE
expr_stmt|;
block|}
else|else
name|avail_out
operator|=
operator|*
name|outbytes
expr_stmt|;
switch|switch
condition|(
name|xar
operator|->
name|rd_encoding
condition|)
block|{
case|case
name|GZIP
case|:
name|xar
operator|->
name|stream
operator|.
name|next_in
operator|=
operator|(
name|Bytef
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|b
expr_stmt|;
name|xar
operator|->
name|stream
operator|.
name|avail_in
operator|=
name|avail_in
expr_stmt|;
name|xar
operator|->
name|stream
operator|.
name|next_out
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|outbuff
expr_stmt|;
name|xar
operator|->
name|stream
operator|.
name|avail_out
operator|=
name|avail_out
expr_stmt|;
name|r
operator|=
name|inflate
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|stream
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|Z_OK
case|:
comment|/* Decompressor made some progress.*/
case|case
name|Z_STREAM_END
case|:
comment|/* Found end of stream. */
break|break;
default|default:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"File decompression failed (%d)"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
operator|*
name|used
operator|=
name|avail_in
operator|-
name|xar
operator|->
name|stream
operator|.
name|avail_in
expr_stmt|;
operator|*
name|outbytes
operator|=
name|avail_out
operator|-
name|xar
operator|->
name|stream
operator|.
name|avail_out
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_BZLIB_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|BZ_CONFIG_ERROR
argument_list|)
case|case
name|BZIP2
case|:
name|xar
operator|->
name|bzstream
operator|.
name|next_in
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|b
expr_stmt|;
name|xar
operator|->
name|bzstream
operator|.
name|avail_in
operator|=
name|avail_in
expr_stmt|;
name|xar
operator|->
name|bzstream
operator|.
name|next_out
operator|=
operator|(
name|char
operator|*
operator|)
name|outbuff
expr_stmt|;
name|xar
operator|->
name|bzstream
operator|.
name|avail_out
operator|=
name|avail_out
expr_stmt|;
name|r
operator|=
name|BZ2_bzDecompress
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|bzstream
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|BZ_STREAM_END
case|:
comment|/* Found end of stream. */
switch|switch
condition|(
name|BZ2_bzDecompressEnd
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|bzstream
operator|)
argument_list|)
condition|)
block|{
case|case
name|BZ_OK
case|:
break|break;
default|default:
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Failed to clean up decompressor"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|xar
operator|->
name|bzstream_valid
operator|=
literal|0
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|BZ_OK
case|:
comment|/* Decompressor made some progress. */
break|break;
default|default:
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"bzip decompression failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
operator|*
name|used
operator|=
name|avail_in
operator|-
name|xar
operator|->
name|bzstream
operator|.
name|avail_in
expr_stmt|;
operator|*
name|outbytes
operator|=
name|avail_out
operator|-
name|xar
operator|->
name|bzstream
operator|.
name|avail_out
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LZMA_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LIBLZMA
argument_list|)
case|case
name|LZMA
case|:
case|case
name|XZ
case|:
name|xar
operator|->
name|lzstream
operator|.
name|next_in
operator|=
name|b
expr_stmt|;
name|xar
operator|->
name|lzstream
operator|.
name|avail_in
operator|=
name|avail_in
expr_stmt|;
name|xar
operator|->
name|lzstream
operator|.
name|next_out
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|outbuff
expr_stmt|;
name|xar
operator|->
name|lzstream
operator|.
name|avail_out
operator|=
name|avail_out
expr_stmt|;
name|r
operator|=
name|lzma_code
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|lzstream
operator|)
argument_list|,
name|LZMA_RUN
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|LZMA_STREAM_END
case|:
comment|/* Found end of stream. */
name|lzma_end
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|lzstream
operator|)
argument_list|)
expr_stmt|;
name|xar
operator|->
name|lzstream_valid
operator|=
literal|0
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|LZMA_OK
case|:
comment|/* Decompressor made some progress. */
break|break;
default|default:
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"%s decompression failed(%d)"
argument_list|,
operator|(
name|xar
operator|->
name|entry_encoding
operator|==
name|XZ
operator|)
condition|?
literal|"xz"
else|:
literal|"lzma"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
operator|*
name|used
operator|=
name|avail_in
operator|-
name|xar
operator|->
name|lzstream
operator|.
name|avail_in
expr_stmt|;
operator|*
name|outbytes
operator|=
name|avail_out
operator|-
name|xar
operator|->
name|lzstream
operator|.
name|avail_out
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_BZLIB_H
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|BZ_CONFIG_ERROR
argument_list|)
case|case
name|BZIP2
case|:
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_LZMA_H
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAVE_LIBLZMA
argument_list|)
case|case
name|LZMA
case|:
case|case
name|XZ
case|:
endif|#
directive|endif
case|case
name|NONE
case|:
default|default:
if|if
condition|(
name|outbuff
operator|==
name|xar
operator|->
name|outbuff
condition|)
block|{
operator|*
name|buff
operator|=
name|b
expr_stmt|;
operator|*
name|used
operator|=
name|avail_in
expr_stmt|;
operator|*
name|outbytes
operator|=
name|avail_in
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|avail_out
operator|>
name|avail_in
condition|)
name|avail_out
operator|=
name|avail_in
expr_stmt|;
name|memcpy
argument_list|(
name|outbuff
argument_list|,
name|b
argument_list|,
name|avail_out
argument_list|)
expr_stmt|;
operator|*
name|used
operator|=
name|avail_out
expr_stmt|;
operator|*
name|outbytes
operator|=
name|avail_out
expr_stmt|;
block|}
break|break;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|decompression_cleanup
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
name|int
name|r
decl_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
name|r
operator|=
name|ARCHIVE_OK
expr_stmt|;
if|if
condition|(
name|xar
operator|->
name|stream_valid
condition|)
block|{
if|if
condition|(
name|inflateEnd
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|stream
operator|)
argument_list|)
operator|!=
name|Z_OK
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Failed to clean up zlib decompressor"
argument_list|)
expr_stmt|;
name|r
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_BZLIB_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|BZ_CONFIG_ERROR
argument_list|)
if|if
condition|(
name|xar
operator|->
name|bzstream_valid
condition|)
block|{
if|if
condition|(
name|BZ2_bzDecompressEnd
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|bzstream
operator|)
argument_list|)
operator|!=
name|BZ_OK
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Failed to clean up bzip2 decompressor"
argument_list|)
expr_stmt|;
name|r
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LZMA_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LIBLZMA
argument_list|)
if|if
condition|(
name|xar
operator|->
name|lzstream_valid
condition|)
name|lzma_end
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|lzstream
operator|)
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_LZMA_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LIBLZMA
argument_list|)
if|if
condition|(
name|xar
operator|->
name|lzstream_valid
condition|)
block|{
if|if
condition|(
name|lzmadec_end
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|lzstream
operator|)
argument_list|)
operator|!=
name|LZMADEC_OK
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Failed to clean up lzmadec decompressor"
argument_list|)
expr_stmt|;
name|r
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|checksum_cleanup
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
name|_checksum_final
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|a_sumwrk
operator|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_checksum_final
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|e_sumwrk
operator|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xmlattr_cleanup
parameter_list|(
name|struct
name|xmlattr_list
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|xmlattr
modifier|*
name|attr
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|attr
operator|=
name|list
operator|->
name|first
expr_stmt|;
while|while
condition|(
name|attr
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|attr
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|attr
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|attr
operator|->
name|value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|attr
operator|=
name|next
expr_stmt|;
block|}
name|list
operator|->
name|first
operator|=
name|NULL
expr_stmt|;
name|list
operator|->
name|last
operator|=
operator|&
operator|(
name|list
operator|->
name|first
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|file_new
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|xar
modifier|*
name|xar
parameter_list|,
name|struct
name|xmlattr_list
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|xar_file
modifier|*
name|file
decl_stmt|;
name|struct
name|xmlattr
modifier|*
name|attr
decl_stmt|;
name|file
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|file
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|file
operator|->
name|parent
operator|=
name|xar
operator|->
name|file
expr_stmt|;
name|file
operator|->
name|mode
operator|=
literal|0777
operator||
name|AE_IFREG
expr_stmt|;
name|file
operator|->
name|atime
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|file
operator|->
name|mtime
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|xar
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|xar
operator|->
name|xattr
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|attr
operator|=
name|list
operator|->
name|first
init|;
name|attr
operator|!=
name|NULL
condition|;
name|attr
operator|=
name|attr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|attr
operator|->
name|name
argument_list|,
literal|"id"
argument_list|)
operator|==
literal|0
condition|)
name|file
operator|->
name|id
operator|=
name|atol10
argument_list|(
name|attr
operator|->
name|value
argument_list|,
name|strlen
argument_list|(
name|attr
operator|->
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|file
operator|->
name|nlink
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|heap_add_entry
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|xar
operator|->
name|file_queue
operator|)
argument_list|,
name|file
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|file_free
parameter_list|(
name|struct
name|xar_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|xattr
modifier|*
name|xattr
decl_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|file
operator|->
name|pathname
operator|)
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|file
operator|->
name|symlink
operator|)
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|file
operator|->
name|uname
operator|)
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|file
operator|->
name|gname
operator|)
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|file
operator|->
name|hardlink
operator|)
argument_list|)
expr_stmt|;
name|xattr
operator|=
name|file
operator|->
name|xattr_list
expr_stmt|;
while|while
condition|(
name|xattr
operator|!=
name|NULL
condition|)
block|{
name|struct
name|xattr
modifier|*
name|next
decl_stmt|;
name|next
operator|=
name|xattr
operator|->
name|next
expr_stmt|;
name|xattr_free
argument_list|(
name|xattr
argument_list|)
expr_stmt|;
name|xattr
operator|=
name|next
expr_stmt|;
block|}
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xattr_new
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|xar
modifier|*
name|xar
parameter_list|,
name|struct
name|xmlattr_list
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|xattr
modifier|*
name|xattr
decl_stmt|,
modifier|*
modifier|*
name|nx
decl_stmt|;
name|struct
name|xmlattr
modifier|*
name|attr
decl_stmt|;
name|xattr
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|xattr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xattr
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|xar
operator|->
name|xattr
operator|=
name|xattr
expr_stmt|;
for|for
control|(
name|attr
operator|=
name|list
operator|->
name|first
init|;
name|attr
operator|!=
name|NULL
condition|;
name|attr
operator|=
name|attr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|attr
operator|->
name|name
argument_list|,
literal|"id"
argument_list|)
operator|==
literal|0
condition|)
name|xattr
operator|->
name|id
operator|=
name|atol10
argument_list|(
name|attr
operator|->
name|value
argument_list|,
name|strlen
argument_list|(
name|attr
operator|->
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Chain to xattr list. */
for|for
control|(
name|nx
operator|=
operator|&
operator|(
name|xar
operator|->
name|file
operator|->
name|xattr_list
operator|)
init|;
operator|*
name|nx
operator|!=
name|NULL
condition|;
name|nx
operator|=
operator|&
operator|(
operator|(
operator|*
name|nx
operator|)
operator|->
name|next
operator|)
control|)
block|{
if|if
condition|(
name|xattr
operator|->
name|id
operator|<
operator|(
operator|*
name|nx
operator|)
operator|->
name|id
condition|)
break|break;
block|}
name|xattr
operator|->
name|next
operator|=
operator|*
name|nx
expr_stmt|;
operator|*
name|nx
operator|=
name|xattr
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xattr_free
parameter_list|(
name|struct
name|xattr
modifier|*
name|xattr
parameter_list|)
block|{
name|archive_string_free
argument_list|(
operator|&
operator|(
name|xattr
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xattr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|getencoding
parameter_list|(
name|struct
name|xmlattr_list
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|xmlattr
modifier|*
name|attr
decl_stmt|;
name|enum
name|enctype
name|encoding
init|=
name|NONE
decl_stmt|;
for|for
control|(
name|attr
operator|=
name|list
operator|->
name|first
init|;
name|attr
operator|!=
name|NULL
condition|;
name|attr
operator|=
name|attr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|attr
operator|->
name|name
argument_list|,
literal|"style"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|attr
operator|->
name|value
argument_list|,
literal|"application/octet-stream"
argument_list|)
operator|==
literal|0
condition|)
name|encoding
operator|=
name|NONE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|attr
operator|->
name|value
argument_list|,
literal|"application/x-gzip"
argument_list|)
operator|==
literal|0
condition|)
name|encoding
operator|=
name|GZIP
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|attr
operator|->
name|value
argument_list|,
literal|"application/x-bzip2"
argument_list|)
operator|==
literal|0
condition|)
name|encoding
operator|=
name|BZIP2
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|attr
operator|->
name|value
argument_list|,
literal|"application/x-lzma"
argument_list|)
operator|==
literal|0
condition|)
name|encoding
operator|=
name|LZMA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|attr
operator|->
name|value
argument_list|,
literal|"application/x-xz"
argument_list|)
operator|==
literal|0
condition|)
name|encoding
operator|=
name|XZ
expr_stmt|;
block|}
block|}
return|return
operator|(
name|encoding
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getsumalgorithm
parameter_list|(
name|struct
name|xmlattr_list
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|xmlattr
modifier|*
name|attr
decl_stmt|;
name|int
name|alg
init|=
name|CKSUM_NONE
decl_stmt|;
for|for
control|(
name|attr
operator|=
name|list
operator|->
name|first
init|;
name|attr
operator|!=
name|NULL
condition|;
name|attr
operator|=
name|attr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|attr
operator|->
name|name
argument_list|,
literal|"style"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|v
init|=
name|attr
operator|->
name|value
decl_stmt|;
if|if
condition|(
operator|(
name|v
index|[
literal|0
index|]
operator|==
literal|'S'
operator|||
name|v
index|[
literal|0
index|]
operator|==
literal|'s'
operator|)
operator|&&
operator|(
name|v
index|[
literal|1
index|]
operator|==
literal|'H'
operator|||
name|v
index|[
literal|1
index|]
operator|==
literal|'h'
operator|)
operator|&&
operator|(
name|v
index|[
literal|2
index|]
operator|==
literal|'A'
operator|||
name|v
index|[
literal|2
index|]
operator|==
literal|'a'
operator|)
operator|&&
name|v
index|[
literal|3
index|]
operator|==
literal|'1'
operator|&&
name|v
index|[
literal|4
index|]
operator|==
literal|'\0'
condition|)
name|alg
operator|=
name|CKSUM_SHA1
expr_stmt|;
if|if
condition|(
operator|(
name|v
index|[
literal|0
index|]
operator|==
literal|'M'
operator|||
name|v
index|[
literal|0
index|]
operator|==
literal|'m'
operator|)
operator|&&
operator|(
name|v
index|[
literal|1
index|]
operator|==
literal|'D'
operator|||
name|v
index|[
literal|1
index|]
operator|==
literal|'d'
operator|)
operator|&&
name|v
index|[
literal|2
index|]
operator|==
literal|'5'
operator|&&
name|v
index|[
literal|3
index|]
operator|==
literal|'\0'
condition|)
name|alg
operator|=
name|CKSUM_MD5
expr_stmt|;
block|}
block|}
return|return
operator|(
name|alg
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unknowntag_start
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|xar
modifier|*
name|xar
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|unknown_tag
modifier|*
name|tag
decl_stmt|;
name|tag
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tag
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|tag
operator|->
name|next
operator|=
name|xar
operator|->
name|unknowntags
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
operator|(
name|tag
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|archive_strcpy
argument_list|(
operator|&
operator|(
name|tag
operator|->
name|name
operator|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|xar
operator|->
name|unknowntags
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"UNKNOWNTAG_START:%s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xar
operator|->
name|xmlsts_unknown
operator|=
name|xar
operator|->
name|xmlsts
expr_stmt|;
name|xar
operator|->
name|xmlsts
operator|=
name|UNKNOWN
expr_stmt|;
block|}
name|xar
operator|->
name|unknowntags
operator|=
name|tag
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unknowntag_end
parameter_list|(
name|struct
name|xar
modifier|*
name|xar
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|unknown_tag
modifier|*
name|tag
decl_stmt|;
name|tag
operator|=
name|xar
operator|->
name|unknowntags
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|NULL
operator|||
name|name
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|strcmp
argument_list|(
name|tag
operator|->
name|name
operator|.
name|s
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|unknowntags
operator|=
name|tag
operator|->
name|next
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|tag
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|xar
operator|->
name|unknowntags
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"UNKNOWNTAG_END:%s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xar
operator|->
name|xmlsts
operator|=
name|xar
operator|->
name|xmlsts_unknown
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|xml_start
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|xmlattr_list
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
name|struct
name|xmlattr
modifier|*
name|attr
decl_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
if|#
directive|if
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"xml_sta:[%s]\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|attr
operator|=
name|list
operator|->
name|first
init|;
name|attr
operator|!=
name|NULL
condition|;
name|attr
operator|=
name|attr
operator|->
name|next
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    attr:\"%s\"=\"%s\"\n"
argument_list|,
name|attr
operator|->
name|name
argument_list|,
name|attr
operator|->
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xar
operator|->
name|base64text
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|xar
operator|->
name|xmlsts
condition|)
block|{
case|case
name|INIT
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"xar"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|XAR
expr_stmt|;
elseif|else
if|if
condition|(
name|unknowntag_start
argument_list|(
name|a
argument_list|,
name|xar
argument_list|,
name|name
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
break|break;
case|case
name|XAR
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"toc"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|TOC
expr_stmt|;
elseif|else
if|if
condition|(
name|unknowntag_start
argument_list|(
name|a
argument_list|,
name|xar
argument_list|,
name|name
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
break|break;
case|case
name|TOC
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"creation-time"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|TOC_CREATION_TIME
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"checksum"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|TOC_CHECKSUM
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"file"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|file_new
argument_list|(
name|a
argument_list|,
name|xar
argument_list|,
name|list
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|xar
operator|->
name|xmlsts
operator|=
name|TOC_FILE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unknowntag_start
argument_list|(
name|a
argument_list|,
name|xar
argument_list|,
name|name
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
break|break;
case|case
name|TOC_CHECKSUM
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"offset"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|TOC_CHECKSUM_OFFSET
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"size"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|TOC_CHECKSUM_SIZE
expr_stmt|;
elseif|else
if|if
condition|(
name|unknowntag_start
argument_list|(
name|a
argument_list|,
name|xar
argument_list|,
name|name
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
break|break;
case|case
name|TOC_FILE
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"file"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|file_new
argument_list|(
name|a
argument_list|,
name|xar
argument_list|,
name|list
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"data"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_DATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"ea"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|xattr_new
argument_list|(
name|a
argument_list|,
name|xar
argument_list|,
name|list
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"ctime"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_CTIME
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"mtime"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_MTIME
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"atime"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_ATIME
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"group"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_GROUP
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"gid"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_GID
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"user"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_USER
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"uid"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_UID
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"mode"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_MODE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"device"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_DEVICE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"deviceno"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_DEVICENO
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"inode"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_INODE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"link"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_LINK
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"type"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_TYPE
expr_stmt|;
for|for
control|(
name|attr
operator|=
name|list
operator|->
name|first
init|;
name|attr
operator|!=
name|NULL
condition|;
name|attr
operator|=
name|attr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|attr
operator|->
name|name
argument_list|,
literal|"link"
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|attr
operator|->
name|value
argument_list|,
literal|"original"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|file
operator|->
name|hdnext
operator|=
name|xar
operator|->
name|hdlink_orgs
expr_stmt|;
name|xar
operator|->
name|hdlink_orgs
operator|=
name|xar
operator|->
name|file
expr_stmt|;
block|}
else|else
block|{
name|xar
operator|->
name|file
operator|->
name|link
operator|=
operator|(
name|unsigned
operator|)
name|atol10
argument_list|(
name|attr
operator|->
name|value
argument_list|,
name|strlen
argument_list|(
name|attr
operator|->
name|value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xar
operator|->
name|file
operator|->
name|link
operator|>
literal|0
condition|)
if|if
condition|(
name|add_link
argument_list|(
name|a
argument_list|,
name|xar
argument_list|,
name|xar
operator|->
name|file
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
block|{
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
empty_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"name"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_NAME
expr_stmt|;
for|for
control|(
name|attr
operator|=
name|list
operator|->
name|first
init|;
name|attr
operator|!=
name|NULL
condition|;
name|attr
operator|=
name|attr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|attr
operator|->
name|name
argument_list|,
literal|"enctype"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|attr
operator|->
name|value
argument_list|,
literal|"base64"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|base64text
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"acl"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_ACL
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"flags"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_FLAGS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"ext2"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2
expr_stmt|;
elseif|else
if|if
condition|(
name|unknowntag_start
argument_list|(
name|a
argument_list|,
name|xar
argument_list|,
name|name
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
break|break;
case|case
name|FILE_DATA
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"length"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_DATA_LENGTH
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"offset"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_DATA_OFFSET
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"size"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_DATA_SIZE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"encoding"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_DATA_ENCODING
expr_stmt|;
name|xar
operator|->
name|file
operator|->
name|encoding
operator|=
name|getencoding
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"archived-checksum"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_DATA_A_CHECKSUM
expr_stmt|;
name|xar
operator|->
name|file
operator|->
name|a_sum
operator|.
name|alg
operator|=
name|getsumalgorithm
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"extracted-checksum"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_DATA_E_CHECKSUM
expr_stmt|;
name|xar
operator|->
name|file
operator|->
name|e_sum
operator|.
name|alg
operator|=
name|getsumalgorithm
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"content"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_DATA_CONTENT
expr_stmt|;
elseif|else
if|if
condition|(
name|unknowntag_start
argument_list|(
name|a
argument_list|,
name|xar
argument_list|,
name|name
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
break|break;
case|case
name|FILE_DEVICE
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"major"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_DEVICE_MAJOR
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"minor"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_DEVICE_MINOR
expr_stmt|;
elseif|else
if|if
condition|(
name|unknowntag_start
argument_list|(
name|a
argument_list|,
name|xar
argument_list|,
name|name
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
break|break;
case|case
name|FILE_DATA_CONTENT
case|:
if|if
condition|(
name|unknowntag_start
argument_list|(
name|a
argument_list|,
name|xar
argument_list|,
name|name
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
break|break;
case|case
name|FILE_EA
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"length"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EA_LENGTH
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"offset"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EA_OFFSET
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"size"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EA_SIZE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"encoding"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EA_ENCODING
expr_stmt|;
name|xar
operator|->
name|xattr
operator|->
name|encoding
operator|=
name|getencoding
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"archived-checksum"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EA_A_CHECKSUM
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"extracted-checksum"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EA_E_CHECKSUM
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"name"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EA_NAME
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"fstype"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EA_FSTYPE
expr_stmt|;
elseif|else
if|if
condition|(
name|unknowntag_start
argument_list|(
name|a
argument_list|,
name|xar
argument_list|,
name|name
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
break|break;
case|case
name|FILE_ACL
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"appleextended"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_ACL_APPLEEXTENDED
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"default"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_ACL_DEFAULT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"access"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_ACL_ACCESS
expr_stmt|;
elseif|else
if|if
condition|(
name|unknowntag_start
argument_list|(
name|a
argument_list|,
name|xar
argument_list|,
name|name
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
break|break;
case|case
name|FILE_FLAGS
case|:
if|if
condition|(
operator|!
name|xml_parse_file_flags
argument_list|(
name|xar
argument_list|,
name|name
argument_list|)
condition|)
if|if
condition|(
name|unknowntag_start
argument_list|(
name|a
argument_list|,
name|xar
argument_list|,
name|name
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
break|break;
case|case
name|FILE_EXT2
case|:
if|if
condition|(
operator|!
name|xml_parse_file_ext2
argument_list|(
name|xar
argument_list|,
name|name
argument_list|)
condition|)
if|if
condition|(
name|unknowntag_start
argument_list|(
name|a
argument_list|,
name|xar
argument_list|,
name|name
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
break|break;
case|case
name|TOC_CREATION_TIME
case|:
case|case
name|TOC_CHECKSUM_OFFSET
case|:
case|case
name|TOC_CHECKSUM_SIZE
case|:
case|case
name|FILE_DATA_LENGTH
case|:
case|case
name|FILE_DATA_OFFSET
case|:
case|case
name|FILE_DATA_SIZE
case|:
case|case
name|FILE_DATA_ENCODING
case|:
case|case
name|FILE_DATA_A_CHECKSUM
case|:
case|case
name|FILE_DATA_E_CHECKSUM
case|:
case|case
name|FILE_EA_LENGTH
case|:
case|case
name|FILE_EA_OFFSET
case|:
case|case
name|FILE_EA_SIZE
case|:
case|case
name|FILE_EA_ENCODING
case|:
case|case
name|FILE_EA_A_CHECKSUM
case|:
case|case
name|FILE_EA_E_CHECKSUM
case|:
case|case
name|FILE_EA_NAME
case|:
case|case
name|FILE_EA_FSTYPE
case|:
case|case
name|FILE_CTIME
case|:
case|case
name|FILE_MTIME
case|:
case|case
name|FILE_ATIME
case|:
case|case
name|FILE_GROUP
case|:
case|case
name|FILE_GID
case|:
case|case
name|FILE_USER
case|:
case|case
name|FILE_UID
case|:
case|case
name|FILE_INODE
case|:
case|case
name|FILE_DEVICE_MAJOR
case|:
case|case
name|FILE_DEVICE_MINOR
case|:
case|case
name|FILE_DEVICENO
case|:
case|case
name|FILE_MODE
case|:
case|case
name|FILE_TYPE
case|:
case|case
name|FILE_LINK
case|:
case|case
name|FILE_NAME
case|:
case|case
name|FILE_ACL_DEFAULT
case|:
case|case
name|FILE_ACL_ACCESS
case|:
case|case
name|FILE_ACL_APPLEEXTENDED
case|:
case|case
name|FILE_FLAGS_USER_NODUMP
case|:
case|case
name|FILE_FLAGS_USER_IMMUTABLE
case|:
case|case
name|FILE_FLAGS_USER_APPEND
case|:
case|case
name|FILE_FLAGS_USER_OPAQUE
case|:
case|case
name|FILE_FLAGS_USER_NOUNLINK
case|:
case|case
name|FILE_FLAGS_SYS_ARCHIVED
case|:
case|case
name|FILE_FLAGS_SYS_IMMUTABLE
case|:
case|case
name|FILE_FLAGS_SYS_APPEND
case|:
case|case
name|FILE_FLAGS_SYS_NOUNLINK
case|:
case|case
name|FILE_FLAGS_SYS_SNAPSHOT
case|:
case|case
name|FILE_EXT2_SecureDeletion
case|:
case|case
name|FILE_EXT2_Undelete
case|:
case|case
name|FILE_EXT2_Compress
case|:
case|case
name|FILE_EXT2_Synchronous
case|:
case|case
name|FILE_EXT2_Immutable
case|:
case|case
name|FILE_EXT2_AppendOnly
case|:
case|case
name|FILE_EXT2_NoDump
case|:
case|case
name|FILE_EXT2_NoAtime
case|:
case|case
name|FILE_EXT2_CompDirty
case|:
case|case
name|FILE_EXT2_CompBlock
case|:
case|case
name|FILE_EXT2_NoCompBlock
case|:
case|case
name|FILE_EXT2_CompError
case|:
case|case
name|FILE_EXT2_BTree
case|:
case|case
name|FILE_EXT2_HashIndexed
case|:
case|case
name|FILE_EXT2_iMagic
case|:
case|case
name|FILE_EXT2_Journaled
case|:
case|case
name|FILE_EXT2_NoTail
case|:
case|case
name|FILE_EXT2_DirSync
case|:
case|case
name|FILE_EXT2_TopDir
case|:
case|case
name|FILE_EXT2_Reserved
case|:
case|case
name|UNKNOWN
case|:
if|if
condition|(
name|unknowntag_start
argument_list|(
name|a
argument_list|,
name|xar
argument_list|,
name|name
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
break|break;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xml_end
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
decl_stmt|;
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
name|a
operator|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|userData
expr_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
if|#
directive|if
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"xml_end:[%s]\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|xar
operator|->
name|xmlsts
condition|)
block|{
case|case
name|INIT
case|:
break|break;
case|case
name|XAR
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"xar"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|INIT
expr_stmt|;
break|break;
case|case
name|TOC
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"toc"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|XAR
expr_stmt|;
break|break;
case|case
name|TOC_CREATION_TIME
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"creation-time"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|TOC
expr_stmt|;
break|break;
case|case
name|TOC_CHECKSUM
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"checksum"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|TOC
expr_stmt|;
break|break;
case|case
name|TOC_CHECKSUM_OFFSET
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"offset"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|TOC_CHECKSUM
expr_stmt|;
break|break;
case|case
name|TOC_CHECKSUM_SIZE
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"size"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|TOC_CHECKSUM
expr_stmt|;
break|break;
case|case
name|TOC_FILE
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"file"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|xar
operator|->
name|file
operator|->
name|parent
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|xar
operator|->
name|file
operator|->
name|mode
operator|&
name|AE_IFMT
operator|)
operator|==
name|AE_IFDIR
operator|)
condition|)
name|xar
operator|->
name|file
operator|->
name|parent
operator|->
name|subdirs
operator|++
expr_stmt|;
name|xar
operator|->
name|file
operator|=
name|xar
operator|->
name|file
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|xar
operator|->
name|file
operator|==
name|NULL
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|TOC
expr_stmt|;
block|}
break|break;
case|case
name|FILE_DATA
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"data"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|TOC_FILE
expr_stmt|;
break|break;
case|case
name|FILE_DATA_LENGTH
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"length"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_DATA
expr_stmt|;
break|break;
case|case
name|FILE_DATA_OFFSET
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"offset"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_DATA
expr_stmt|;
break|break;
case|case
name|FILE_DATA_SIZE
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"size"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_DATA
expr_stmt|;
break|break;
case|case
name|FILE_DATA_ENCODING
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"encoding"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_DATA
expr_stmt|;
break|break;
case|case
name|FILE_DATA_A_CHECKSUM
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"archived-checksum"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_DATA
expr_stmt|;
break|break;
case|case
name|FILE_DATA_E_CHECKSUM
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"extracted-checksum"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_DATA
expr_stmt|;
break|break;
case|case
name|FILE_DATA_CONTENT
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"content"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_DATA
expr_stmt|;
break|break;
case|case
name|FILE_EA
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"ea"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|TOC_FILE
expr_stmt|;
name|xar
operator|->
name|xattr
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|FILE_EA_LENGTH
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"length"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EA
expr_stmt|;
break|break;
case|case
name|FILE_EA_OFFSET
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"offset"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EA
expr_stmt|;
break|break;
case|case
name|FILE_EA_SIZE
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"size"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EA
expr_stmt|;
break|break;
case|case
name|FILE_EA_ENCODING
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"encoding"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EA
expr_stmt|;
break|break;
case|case
name|FILE_EA_A_CHECKSUM
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"archived-checksum"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EA
expr_stmt|;
break|break;
case|case
name|FILE_EA_E_CHECKSUM
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"extracted-checksum"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EA
expr_stmt|;
break|break;
case|case
name|FILE_EA_NAME
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"name"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EA
expr_stmt|;
break|break;
case|case
name|FILE_EA_FSTYPE
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"fstype"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EA
expr_stmt|;
break|break;
case|case
name|FILE_CTIME
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"ctime"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|TOC_FILE
expr_stmt|;
break|break;
case|case
name|FILE_MTIME
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"mtime"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|TOC_FILE
expr_stmt|;
break|break;
case|case
name|FILE_ATIME
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"atime"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|TOC_FILE
expr_stmt|;
break|break;
case|case
name|FILE_GROUP
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"group"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|TOC_FILE
expr_stmt|;
break|break;
case|case
name|FILE_GID
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"gid"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|TOC_FILE
expr_stmt|;
break|break;
case|case
name|FILE_USER
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"user"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|TOC_FILE
expr_stmt|;
break|break;
case|case
name|FILE_UID
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"uid"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|TOC_FILE
expr_stmt|;
break|break;
case|case
name|FILE_MODE
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"mode"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|TOC_FILE
expr_stmt|;
break|break;
case|case
name|FILE_DEVICE
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"device"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|TOC_FILE
expr_stmt|;
break|break;
case|case
name|FILE_DEVICE_MAJOR
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"major"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_DEVICE
expr_stmt|;
break|break;
case|case
name|FILE_DEVICE_MINOR
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"minor"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_DEVICE
expr_stmt|;
break|break;
case|case
name|FILE_DEVICENO
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"deviceno"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|TOC_FILE
expr_stmt|;
break|break;
case|case
name|FILE_INODE
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"inode"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|TOC_FILE
expr_stmt|;
break|break;
case|case
name|FILE_LINK
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"link"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|TOC_FILE
expr_stmt|;
break|break;
case|case
name|FILE_TYPE
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"type"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|TOC_FILE
expr_stmt|;
break|break;
case|case
name|FILE_NAME
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"name"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|TOC_FILE
expr_stmt|;
break|break;
case|case
name|FILE_ACL
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"acl"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|TOC_FILE
expr_stmt|;
break|break;
case|case
name|FILE_ACL_DEFAULT
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"default"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_ACL
expr_stmt|;
break|break;
case|case
name|FILE_ACL_ACCESS
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"access"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_ACL
expr_stmt|;
break|break;
case|case
name|FILE_ACL_APPLEEXTENDED
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"appleextended"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_ACL
expr_stmt|;
break|break;
case|case
name|FILE_FLAGS
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"flags"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|TOC_FILE
expr_stmt|;
break|break;
case|case
name|FILE_FLAGS_USER_NODUMP
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"UserNoDump"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_FLAGS
expr_stmt|;
break|break;
case|case
name|FILE_FLAGS_USER_IMMUTABLE
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"UserImmutable"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_FLAGS
expr_stmt|;
break|break;
case|case
name|FILE_FLAGS_USER_APPEND
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"UserAppend"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_FLAGS
expr_stmt|;
break|break;
case|case
name|FILE_FLAGS_USER_OPAQUE
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"UserOpaque"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_FLAGS
expr_stmt|;
break|break;
case|case
name|FILE_FLAGS_USER_NOUNLINK
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"UserNoUnlink"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_FLAGS
expr_stmt|;
break|break;
case|case
name|FILE_FLAGS_SYS_ARCHIVED
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"SystemArchived"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_FLAGS
expr_stmt|;
break|break;
case|case
name|FILE_FLAGS_SYS_IMMUTABLE
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"SystemImmutable"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_FLAGS
expr_stmt|;
break|break;
case|case
name|FILE_FLAGS_SYS_APPEND
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"SystemAppend"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_FLAGS
expr_stmt|;
break|break;
case|case
name|FILE_FLAGS_SYS_NOUNLINK
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"SystemNoUnlink"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_FLAGS
expr_stmt|;
break|break;
case|case
name|FILE_FLAGS_SYS_SNAPSHOT
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"SystemSnapshot"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_FLAGS
expr_stmt|;
break|break;
case|case
name|FILE_EXT2
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"ext2"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|TOC_FILE
expr_stmt|;
break|break;
case|case
name|FILE_EXT2_SecureDeletion
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"SecureDeletion"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2
expr_stmt|;
break|break;
case|case
name|FILE_EXT2_Undelete
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"Undelete"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2
expr_stmt|;
break|break;
case|case
name|FILE_EXT2_Compress
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"Compress"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2
expr_stmt|;
break|break;
case|case
name|FILE_EXT2_Synchronous
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"Synchronous"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2
expr_stmt|;
break|break;
case|case
name|FILE_EXT2_Immutable
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"Immutable"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2
expr_stmt|;
break|break;
case|case
name|FILE_EXT2_AppendOnly
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"AppendOnly"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2
expr_stmt|;
break|break;
case|case
name|FILE_EXT2_NoDump
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"NoDump"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2
expr_stmt|;
break|break;
case|case
name|FILE_EXT2_NoAtime
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"NoAtime"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2
expr_stmt|;
break|break;
case|case
name|FILE_EXT2_CompDirty
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"CompDirty"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2
expr_stmt|;
break|break;
case|case
name|FILE_EXT2_CompBlock
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"CompBlock"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2
expr_stmt|;
break|break;
case|case
name|FILE_EXT2_NoCompBlock
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"NoCompBlock"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2
expr_stmt|;
break|break;
case|case
name|FILE_EXT2_CompError
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"CompError"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2
expr_stmt|;
break|break;
case|case
name|FILE_EXT2_BTree
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"BTree"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2
expr_stmt|;
break|break;
case|case
name|FILE_EXT2_HashIndexed
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"HashIndexed"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2
expr_stmt|;
break|break;
case|case
name|FILE_EXT2_iMagic
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"iMagic"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2
expr_stmt|;
break|break;
case|case
name|FILE_EXT2_Journaled
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"Journaled"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2
expr_stmt|;
break|break;
case|case
name|FILE_EXT2_NoTail
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"NoTail"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2
expr_stmt|;
break|break;
case|case
name|FILE_EXT2_DirSync
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"DirSync"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2
expr_stmt|;
break|break;
case|case
name|FILE_EXT2_TopDir
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"TopDir"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2
expr_stmt|;
break|break;
case|case
name|FILE_EXT2_Reserved
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"Reserved"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2
expr_stmt|;
break|break;
case|case
name|UNKNOWN
case|:
name|unknowntag_end
argument_list|(
name|xar
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|int
name|base64
index|[
literal|256
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 00 - 0F */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 10 - 1F */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|62
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|63
block|,
comment|/* 20 - 2F */
literal|52
block|,
literal|53
block|,
literal|54
block|,
literal|55
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|59
block|,
literal|60
block|,
literal|61
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 30 - 3F */
operator|-
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
comment|/* 40 - 4F */
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 50 - 5F */
operator|-
literal|1
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
comment|/* 60 - 6F */
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|49
block|,
literal|50
block|,
literal|51
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 70 - 7F */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 80 - 8F */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 90 - 9F */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* A0 - AF */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* B0 - BF */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* C0 - CF */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* D0 - DF */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* E0 - EF */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* F0 - FF */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|strappend_base64
parameter_list|(
name|struct
name|xar
modifier|*
name|xar
parameter_list|,
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|l
parameter_list|)
block|{
name|unsigned
name|char
name|buff
index|[
literal|256
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|out
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|b
decl_stmt|;
name|size_t
name|len
decl_stmt|;
operator|(
name|void
operator|)
name|xar
expr_stmt|;
comment|/* UNUSED */
name|len
operator|=
literal|0
expr_stmt|;
name|out
operator|=
name|buff
expr_stmt|;
name|b
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|s
expr_stmt|;
while|while
condition|(
name|l
operator|>
literal|0
condition|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|l
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|base64
index|[
name|b
index|[
literal|0
index|]
index|]
operator|<
literal|0
operator|||
name|base64
index|[
name|b
index|[
literal|1
index|]
index|]
operator|<
literal|0
condition|)
break|break;
name|n
operator|=
name|base64
index|[
operator|*
name|b
operator|++
index|]
operator|<<
literal|18
expr_stmt|;
name|n
operator||=
name|base64
index|[
operator|*
name|b
operator|++
index|]
operator|<<
literal|12
expr_stmt|;
operator|*
name|out
operator|++
operator|=
name|n
operator|>>
literal|16
expr_stmt|;
name|len
operator|++
expr_stmt|;
name|l
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|base64
index|[
operator|*
name|b
index|]
operator|<
literal|0
condition|)
break|break;
name|n
operator||=
name|base64
index|[
operator|*
name|b
operator|++
index|]
operator|<<
literal|6
expr_stmt|;
operator|*
name|out
operator|++
operator|=
operator|(
name|n
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|len
operator|++
expr_stmt|;
operator|--
name|l
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|base64
index|[
operator|*
name|b
index|]
operator|<
literal|0
condition|)
break|break;
name|n
operator||=
name|base64
index|[
operator|*
name|b
operator|++
index|]
expr_stmt|;
operator|*
name|out
operator|++
operator|=
name|n
operator|&
literal|0xFF
expr_stmt|;
name|len
operator|++
expr_stmt|;
operator|--
name|l
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|+
literal|3
operator|>=
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
condition|)
block|{
name|archive_strncat
argument_list|(
name|as
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|buff
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|out
operator|=
name|buff
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|archive_strncat
argument_list|(
name|as
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|buff
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_string
parameter_list|(
specifier|const
name|char
modifier|*
name|known
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|known
argument_list|)
operator|!=
name|len
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|memcmp
argument_list|(
name|data
argument_list|,
name|known
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xml_data
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
decl_stmt|;
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
name|a
operator|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|userData
expr_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
if|#
directive|if
name|DEBUG
block|{
name|char
name|buff
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
name|len
operator|>
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
name|len
operator|=
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|buff
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buff
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tlen=%d:\"%s\"\n"
argument_list|,
name|len
argument_list|,
name|buff
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|xar
operator|->
name|xmlsts
condition|)
block|{
case|case
name|TOC_CHECKSUM_OFFSET
case|:
name|xar
operator|->
name|toc_chksum_offset
operator|=
name|atol10
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOC_CHECKSUM_SIZE
case|:
name|xar
operator|->
name|toc_chksum_size
operator|=
name|atol10
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|xar
operator|->
name|file
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|xar
operator|->
name|xmlsts
condition|)
block|{
case|case
name|FILE_NAME
case|:
if|if
condition|(
name|xar
operator|->
name|file
operator|->
name|parent
operator|!=
name|NULL
condition|)
block|{
name|archive_string_concat
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|file
operator|->
name|pathname
operator|)
argument_list|,
operator|&
operator|(
name|xar
operator|->
name|file
operator|->
name|parent
operator|->
name|pathname
operator|)
argument_list|)
expr_stmt|;
name|archive_strappend_char
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|file
operator|->
name|pathname
operator|)
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
block|}
name|xar
operator|->
name|file
operator|->
name|has
operator||=
name|HAS_PATHNAME
expr_stmt|;
if|if
condition|(
name|xar
operator|->
name|base64text
condition|)
block|{
name|strappend_base64
argument_list|(
name|xar
argument_list|,
operator|&
operator|(
name|xar
operator|->
name|file
operator|->
name|pathname
operator|)
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
name|archive_strncat
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|file
operator|->
name|pathname
operator|)
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_LINK
case|:
name|xar
operator|->
name|file
operator|->
name|has
operator||=
name|HAS_SYMLINK
expr_stmt|;
name|archive_strncpy
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|file
operator|->
name|symlink
operator|)
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_TYPE
case|:
if|if
condition|(
name|is_string
argument_list|(
literal|"file"
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|||
name|is_string
argument_list|(
literal|"hardlink"
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|file
operator|->
name|mode
operator|=
operator|(
name|xar
operator|->
name|file
operator|->
name|mode
operator|&
operator|~
name|AE_IFMT
operator|)
operator||
name|AE_IFREG
expr_stmt|;
if|if
condition|(
name|is_string
argument_list|(
literal|"directory"
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|file
operator|->
name|mode
operator|=
operator|(
name|xar
operator|->
name|file
operator|->
name|mode
operator|&
operator|~
name|AE_IFMT
operator|)
operator||
name|AE_IFDIR
expr_stmt|;
if|if
condition|(
name|is_string
argument_list|(
literal|"symlink"
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|file
operator|->
name|mode
operator|=
operator|(
name|xar
operator|->
name|file
operator|->
name|mode
operator|&
operator|~
name|AE_IFMT
operator|)
operator||
name|AE_IFLNK
expr_stmt|;
if|if
condition|(
name|is_string
argument_list|(
literal|"character special"
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|file
operator|->
name|mode
operator|=
operator|(
name|xar
operator|->
name|file
operator|->
name|mode
operator|&
operator|~
name|AE_IFMT
operator|)
operator||
name|AE_IFCHR
expr_stmt|;
if|if
condition|(
name|is_string
argument_list|(
literal|"block special"
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|file
operator|->
name|mode
operator|=
operator|(
name|xar
operator|->
name|file
operator|->
name|mode
operator|&
operator|~
name|AE_IFMT
operator|)
operator||
name|AE_IFBLK
expr_stmt|;
if|if
condition|(
name|is_string
argument_list|(
literal|"socket"
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|file
operator|->
name|mode
operator|=
operator|(
name|xar
operator|->
name|file
operator|->
name|mode
operator|&
operator|~
name|AE_IFMT
operator|)
operator||
name|AE_IFSOCK
expr_stmt|;
if|if
condition|(
name|is_string
argument_list|(
literal|"fifo"
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|file
operator|->
name|mode
operator|=
operator|(
name|xar
operator|->
name|file
operator|->
name|mode
operator|&
operator|~
name|AE_IFMT
operator|)
operator||
name|AE_IFIFO
expr_stmt|;
name|xar
operator|->
name|file
operator|->
name|has
operator||=
name|HAS_TYPE
expr_stmt|;
break|break;
case|case
name|FILE_INODE
case|:
name|xar
operator|->
name|file
operator|->
name|has
operator||=
name|HAS_INO
expr_stmt|;
name|xar
operator|->
name|file
operator|->
name|ino64
operator|=
name|atol10
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_DEVICE_MAJOR
case|:
name|xar
operator|->
name|file
operator|->
name|has
operator||=
name|HAS_DEVMAJOR
expr_stmt|;
name|xar
operator|->
name|file
operator|->
name|devmajor
operator|=
operator|(
name|dev_t
operator|)
name|atol10
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_DEVICE_MINOR
case|:
name|xar
operator|->
name|file
operator|->
name|has
operator||=
name|HAS_DEVMINOR
expr_stmt|;
name|xar
operator|->
name|file
operator|->
name|devminor
operator|=
operator|(
name|dev_t
operator|)
name|atol10
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_DEVICENO
case|:
name|xar
operator|->
name|file
operator|->
name|has
operator||=
name|HAS_DEV
expr_stmt|;
name|xar
operator|->
name|file
operator|->
name|dev
operator|=
operator|(
name|dev_t
operator|)
name|atol10
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_MODE
case|:
name|xar
operator|->
name|file
operator|->
name|has
operator||=
name|HAS_MODE
expr_stmt|;
name|xar
operator|->
name|file
operator|->
name|mode
operator|=
operator|(
name|xar
operator|->
name|file
operator|->
name|mode
operator|&
name|AE_IFMT
operator|)
operator||
operator|(
call|(
name|mode_t
call|)
argument_list|(
name|atol8
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
argument_list|)
operator|&
operator|~
name|AE_IFMT
operator|)
expr_stmt|;
break|break;
case|case
name|FILE_GROUP
case|:
name|xar
operator|->
name|file
operator|->
name|has
operator||=
name|HAS_GID
expr_stmt|;
name|archive_strncpy
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|file
operator|->
name|gname
operator|)
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_GID
case|:
name|xar
operator|->
name|file
operator|->
name|has
operator||=
name|HAS_GID
expr_stmt|;
name|xar
operator|->
name|file
operator|->
name|gid
operator|=
name|atol10
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_USER
case|:
name|xar
operator|->
name|file
operator|->
name|has
operator||=
name|HAS_UID
expr_stmt|;
name|archive_strncpy
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|file
operator|->
name|uname
operator|)
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_UID
case|:
name|xar
operator|->
name|file
operator|->
name|has
operator||=
name|HAS_UID
expr_stmt|;
name|xar
operator|->
name|file
operator|->
name|uid
operator|=
name|atol10
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_CTIME
case|:
name|xar
operator|->
name|file
operator|->
name|has
operator||=
name|HAS_TIME
expr_stmt|;
name|xar
operator|->
name|file
operator|->
name|ctime
operator|=
name|parse_time
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_MTIME
case|:
name|xar
operator|->
name|file
operator|->
name|has
operator||=
name|HAS_TIME
expr_stmt|;
name|xar
operator|->
name|file
operator|->
name|mtime
operator|=
name|parse_time
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_ATIME
case|:
name|xar
operator|->
name|file
operator|->
name|has
operator||=
name|HAS_TIME
expr_stmt|;
name|xar
operator|->
name|file
operator|->
name|atime
operator|=
name|parse_time
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_DATA_LENGTH
case|:
name|xar
operator|->
name|file
operator|->
name|has
operator||=
name|HAS_DATA
expr_stmt|;
name|xar
operator|->
name|file
operator|->
name|length
operator|=
name|atol10
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_DATA_OFFSET
case|:
name|xar
operator|->
name|file
operator|->
name|has
operator||=
name|HAS_DATA
expr_stmt|;
name|xar
operator|->
name|file
operator|->
name|offset
operator|=
name|atol10
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_DATA_SIZE
case|:
name|xar
operator|->
name|file
operator|->
name|has
operator||=
name|HAS_DATA
expr_stmt|;
name|xar
operator|->
name|file
operator|->
name|size
operator|=
name|atol10
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_DATA_A_CHECKSUM
case|:
name|xar
operator|->
name|file
operator|->
name|a_sum
operator|.
name|len
operator|=
name|atohex
argument_list|(
name|xar
operator|->
name|file
operator|->
name|a_sum
operator|.
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|xar
operator|->
name|file
operator|->
name|a_sum
operator|.
name|val
argument_list|)
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_DATA_E_CHECKSUM
case|:
name|xar
operator|->
name|file
operator|->
name|e_sum
operator|.
name|len
operator|=
name|atohex
argument_list|(
name|xar
operator|->
name|file
operator|->
name|e_sum
operator|.
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|xar
operator|->
name|file
operator|->
name|e_sum
operator|.
name|val
argument_list|)
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_EA_LENGTH
case|:
name|xar
operator|->
name|file
operator|->
name|has
operator||=
name|HAS_XATTR
expr_stmt|;
name|xar
operator|->
name|xattr
operator|->
name|length
operator|=
name|atol10
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_EA_OFFSET
case|:
name|xar
operator|->
name|file
operator|->
name|has
operator||=
name|HAS_XATTR
expr_stmt|;
name|xar
operator|->
name|xattr
operator|->
name|offset
operator|=
name|atol10
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_EA_SIZE
case|:
name|xar
operator|->
name|file
operator|->
name|has
operator||=
name|HAS_XATTR
expr_stmt|;
name|xar
operator|->
name|xattr
operator|->
name|size
operator|=
name|atol10
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_EA_A_CHECKSUM
case|:
name|xar
operator|->
name|file
operator|->
name|has
operator||=
name|HAS_XATTR
expr_stmt|;
name|xar
operator|->
name|xattr
operator|->
name|a_sum
operator|.
name|len
operator|=
name|atohex
argument_list|(
name|xar
operator|->
name|xattr
operator|->
name|a_sum
operator|.
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|xar
operator|->
name|xattr
operator|->
name|a_sum
operator|.
name|val
argument_list|)
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_EA_E_CHECKSUM
case|:
name|xar
operator|->
name|file
operator|->
name|has
operator||=
name|HAS_XATTR
expr_stmt|;
name|xar
operator|->
name|xattr
operator|->
name|e_sum
operator|.
name|len
operator|=
name|atohex
argument_list|(
name|xar
operator|->
name|xattr
operator|->
name|e_sum
operator|.
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|xar
operator|->
name|xattr
operator|->
name|e_sum
operator|.
name|val
argument_list|)
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_EA_NAME
case|:
name|xar
operator|->
name|file
operator|->
name|has
operator||=
name|HAS_XATTR
expr_stmt|;
name|archive_strncpy
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|xattr
operator|->
name|name
operator|)
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_EA_FSTYPE
case|:
name|xar
operator|->
name|file
operator|->
name|has
operator||=
name|HAS_XATTR
expr_stmt|;
name|archive_strncpy
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|xattr
operator|->
name|fstype
operator|)
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
break|break;
case|case
name|FILE_ACL_DEFAULT
case|:
case|case
name|FILE_ACL_ACCESS
case|:
case|case
name|FILE_ACL_APPLEEXTENDED
case|:
name|xar
operator|->
name|file
operator|->
name|has
operator||=
name|HAS_ACL
expr_stmt|;
comment|/* TODO */
break|break;
case|case
name|INIT
case|:
case|case
name|XAR
case|:
case|case
name|TOC
case|:
case|case
name|TOC_CREATION_TIME
case|:
case|case
name|TOC_CHECKSUM
case|:
case|case
name|TOC_CHECKSUM_OFFSET
case|:
case|case
name|TOC_CHECKSUM_SIZE
case|:
case|case
name|TOC_FILE
case|:
case|case
name|FILE_DATA
case|:
case|case
name|FILE_DATA_ENCODING
case|:
case|case
name|FILE_DATA_CONTENT
case|:
case|case
name|FILE_DEVICE
case|:
case|case
name|FILE_EA
case|:
case|case
name|FILE_EA_ENCODING
case|:
case|case
name|FILE_ACL
case|:
case|case
name|FILE_FLAGS
case|:
case|case
name|FILE_FLAGS_USER_NODUMP
case|:
case|case
name|FILE_FLAGS_USER_IMMUTABLE
case|:
case|case
name|FILE_FLAGS_USER_APPEND
case|:
case|case
name|FILE_FLAGS_USER_OPAQUE
case|:
case|case
name|FILE_FLAGS_USER_NOUNLINK
case|:
case|case
name|FILE_FLAGS_SYS_ARCHIVED
case|:
case|case
name|FILE_FLAGS_SYS_IMMUTABLE
case|:
case|case
name|FILE_FLAGS_SYS_APPEND
case|:
case|case
name|FILE_FLAGS_SYS_NOUNLINK
case|:
case|case
name|FILE_FLAGS_SYS_SNAPSHOT
case|:
case|case
name|FILE_EXT2
case|:
case|case
name|FILE_EXT2_SecureDeletion
case|:
case|case
name|FILE_EXT2_Undelete
case|:
case|case
name|FILE_EXT2_Compress
case|:
case|case
name|FILE_EXT2_Synchronous
case|:
case|case
name|FILE_EXT2_Immutable
case|:
case|case
name|FILE_EXT2_AppendOnly
case|:
case|case
name|FILE_EXT2_NoDump
case|:
case|case
name|FILE_EXT2_NoAtime
case|:
case|case
name|FILE_EXT2_CompDirty
case|:
case|case
name|FILE_EXT2_CompBlock
case|:
case|case
name|FILE_EXT2_NoCompBlock
case|:
case|case
name|FILE_EXT2_CompError
case|:
case|case
name|FILE_EXT2_BTree
case|:
case|case
name|FILE_EXT2_HashIndexed
case|:
case|case
name|FILE_EXT2_iMagic
case|:
case|case
name|FILE_EXT2_Journaled
case|:
case|case
name|FILE_EXT2_NoTail
case|:
case|case
name|FILE_EXT2_DirSync
case|:
case|case
name|FILE_EXT2_TopDir
case|:
case|case
name|FILE_EXT2_Reserved
case|:
case|case
name|UNKNOWN
case|:
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * BSD file flags.  */
end_comment

begin_function
specifier|static
name|int
name|xml_parse_file_flags
parameter_list|(
name|struct
name|xar
modifier|*
name|xar
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|flag
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"UserNoDump"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_FLAGS_USER_NODUMP
expr_stmt|;
name|flag
operator|=
literal|"nodump"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"UserImmutable"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_FLAGS_USER_IMMUTABLE
expr_stmt|;
name|flag
operator|=
literal|"uimmutable"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"UserAppend"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_FLAGS_USER_APPEND
expr_stmt|;
name|flag
operator|=
literal|"uappend"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"UserOpaque"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_FLAGS_USER_OPAQUE
expr_stmt|;
name|flag
operator|=
literal|"opaque"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"UserNoUnlink"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_FLAGS_USER_NOUNLINK
expr_stmt|;
name|flag
operator|=
literal|"nouunlink"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"SystemArchived"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_FLAGS_SYS_ARCHIVED
expr_stmt|;
name|flag
operator|=
literal|"archived"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"SystemImmutable"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_FLAGS_SYS_IMMUTABLE
expr_stmt|;
name|flag
operator|=
literal|"simmutable"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"SystemAppend"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_FLAGS_SYS_APPEND
expr_stmt|;
name|flag
operator|=
literal|"sappend"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"SystemNoUnlink"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_FLAGS_SYS_NOUNLINK
expr_stmt|;
name|flag
operator|=
literal|"nosunlink"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"SystemSnapshot"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_FLAGS_SYS_SNAPSHOT
expr_stmt|;
name|flag
operator|=
literal|"snapshot"
expr_stmt|;
block|}
if|if
condition|(
name|flag
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|xar
operator|->
name|file
operator|->
name|has
operator||=
name|HAS_FFLAGS
expr_stmt|;
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|file
operator|->
name|fflags_text
operator|)
argument_list|)
operator|>
literal|0
condition|)
name|archive_strappend_char
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|file
operator|->
name|fflags_text
operator|)
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|archive_strcat
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|file
operator|->
name|fflags_text
operator|)
argument_list|,
name|flag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Linux file flags.  */
end_comment

begin_function
specifier|static
name|int
name|xml_parse_file_ext2
parameter_list|(
name|struct
name|xar
modifier|*
name|xar
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|flag
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"SecureDeletion"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2_SecureDeletion
expr_stmt|;
name|flag
operator|=
literal|"securedeletion"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"Undelete"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2_Undelete
expr_stmt|;
name|flag
operator|=
literal|"nouunlink"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"Compress"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2_Compress
expr_stmt|;
name|flag
operator|=
literal|"compress"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"Synchronous"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2_Synchronous
expr_stmt|;
name|flag
operator|=
literal|"sync"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"Immutable"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2_Immutable
expr_stmt|;
name|flag
operator|=
literal|"simmutable"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"AppendOnly"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2_AppendOnly
expr_stmt|;
name|flag
operator|=
literal|"sappend"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"NoDump"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2_NoDump
expr_stmt|;
name|flag
operator|=
literal|"nodump"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"NoAtime"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2_NoAtime
expr_stmt|;
name|flag
operator|=
literal|"noatime"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"CompDirty"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2_CompDirty
expr_stmt|;
name|flag
operator|=
literal|"compdirty"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"CompBlock"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2_CompBlock
expr_stmt|;
name|flag
operator|=
literal|"comprblk"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"NoCompBlock"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2_NoCompBlock
expr_stmt|;
name|flag
operator|=
literal|"nocomprblk"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"CompError"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2_CompError
expr_stmt|;
name|flag
operator|=
literal|"comperr"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"BTree"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2_BTree
expr_stmt|;
name|flag
operator|=
literal|"btree"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"HashIndexed"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2_HashIndexed
expr_stmt|;
name|flag
operator|=
literal|"hashidx"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"iMagic"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2_iMagic
expr_stmt|;
name|flag
operator|=
literal|"imagic"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"Journaled"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2_Journaled
expr_stmt|;
name|flag
operator|=
literal|"journal"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"NoTail"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2_NoTail
expr_stmt|;
name|flag
operator|=
literal|"notail"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"DirSync"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2_DirSync
expr_stmt|;
name|flag
operator|=
literal|"dirsync"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"TopDir"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2_TopDir
expr_stmt|;
name|flag
operator|=
literal|"topdir"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"Reserved"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xar
operator|->
name|xmlsts
operator|=
name|FILE_EXT2_Reserved
expr_stmt|;
name|flag
operator|=
literal|"reserved"
expr_stmt|;
block|}
if|if
condition|(
name|flag
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|file
operator|->
name|fflags_text
operator|)
argument_list|)
operator|>
literal|0
condition|)
name|archive_strappend_char
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|file
operator|->
name|fflags_text
operator|)
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|archive_strcat
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|file
operator|->
name|fflags_text
operator|)
argument_list|,
name|flag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIBXML_XMLREADER_H
end_ifdef

begin_function
specifier|static
name|int
name|xml2_xmlattr_setup
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|xmlattr_list
modifier|*
name|list
parameter_list|,
name|xmlTextReaderPtr
name|reader
parameter_list|)
block|{
name|struct
name|xmlattr
modifier|*
name|attr
decl_stmt|;
name|int
name|r
decl_stmt|;
name|list
operator|->
name|first
operator|=
name|NULL
expr_stmt|;
name|list
operator|->
name|last
operator|=
operator|&
operator|(
name|list
operator|->
name|first
operator|)
expr_stmt|;
name|r
operator|=
name|xmlTextReaderMoveToFirstAttribute
argument_list|(
name|reader
argument_list|)
expr_stmt|;
while|while
condition|(
name|r
operator|==
literal|1
condition|)
block|{
name|attr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
operator|(
name|attr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|attr
operator|->
name|name
operator|=
name|strdup
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|xmlTextReaderConstLocalName
argument_list|(
name|reader
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|attr
operator|->
name|value
operator|=
name|strdup
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|xmlTextReaderConstValue
argument_list|(
name|reader
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|->
name|value
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|attr
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|attr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|list
operator|->
name|last
operator|=
name|attr
expr_stmt|;
name|list
operator|->
name|last
operator|=
operator|&
operator|(
name|attr
operator|->
name|next
operator|)
expr_stmt|;
name|r
operator|=
name|xmlTextReaderMoveToNextAttribute
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xml2_read_cb
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
decl_stmt|;
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
specifier|const
name|void
modifier|*
name|d
decl_stmt|;
name|size_t
name|outbytes
decl_stmt|;
name|size_t
name|used
init|=
literal|0
decl_stmt|;
name|int
name|r
decl_stmt|;
name|a
operator|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|context
expr_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|xar
operator|->
name|toc_remaining
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|d
operator|=
name|buffer
expr_stmt|;
name|outbytes
operator|=
name|len
expr_stmt|;
name|r
operator|=
name|rd_contents
argument_list|(
name|a
argument_list|,
operator|&
name|d
argument_list|,
operator|&
name|outbytes
argument_list|,
operator|&
name|used
argument_list|,
name|xar
operator|->
name|toc_remaining
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|xar
operator|->
name|toc_remaining
operator|-=
name|used
expr_stmt|;
name|xar
operator|->
name|offset
operator|+=
name|used
expr_stmt|;
name|xar
operator|->
name|toc_total
operator|+=
name|outbytes
expr_stmt|;
name|PRINT_TOC
argument_list|(
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|outbytes
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xml2_close_cb
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
operator|(
name|void
operator|)
name|context
expr_stmt|;
comment|/* UNUSED */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xml2_error_hdr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|xmlParserSeverities
name|severity
parameter_list|,
name|xmlTextReaderLocatorPtr
name|locator
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
decl_stmt|;
operator|(
name|void
operator|)
name|locator
expr_stmt|;
comment|/* UNUSED */
name|a
operator|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|arg
expr_stmt|;
switch|switch
condition|(
name|severity
condition|)
block|{
case|case
name|XML_PARSER_SEVERITY_VALIDITY_WARNING
case|:
case|case
name|XML_PARSER_SEVERITY_WARNING
case|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"XML Parsing error: %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|XML_PARSER_SEVERITY_VALIDITY_ERROR
case|:
case|case
name|XML_PARSER_SEVERITY_ERROR
case|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"XML Parsing error: %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|xml2_read_toc
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|xmlTextReaderPtr
name|reader
decl_stmt|;
name|struct
name|xmlattr_list
name|list
decl_stmt|;
name|int
name|r
decl_stmt|;
name|reader
operator|=
name|xmlReaderForIO
argument_list|(
name|xml2_read_cb
argument_list|,
name|xml2_close_cb
argument_list|,
name|a
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|reader
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Couldn't allocate memory for xml parser"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|xmlTextReaderSetErrorHandler
argument_list|(
name|reader
argument_list|,
name|xml2_error_hdr
argument_list|,
name|a
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|xmlTextReaderRead
argument_list|(
name|reader
argument_list|)
operator|)
operator|==
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|int
name|type
decl_stmt|,
name|empty
decl_stmt|;
name|type
operator|=
name|xmlTextReaderNodeType
argument_list|(
name|reader
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|xmlTextReaderConstLocalName
argument_list|(
name|reader
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|XML_READER_TYPE_ELEMENT
case|:
name|empty
operator|=
name|xmlTextReaderIsEmptyElement
argument_list|(
name|reader
argument_list|)
expr_stmt|;
name|r
operator|=
name|xml2_xmlattr_setup
argument_list|(
name|a
argument_list|,
operator|&
name|list
argument_list|,
name|reader
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_OK
condition|)
name|r
operator|=
name|xml_start
argument_list|(
name|a
argument_list|,
name|name
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|xmlattr_cleanup
argument_list|(
operator|&
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
if|if
condition|(
name|empty
condition|)
name|xml_end
argument_list|(
name|a
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|XML_READER_TYPE_END_ELEMENT
case|:
name|xml_end
argument_list|(
name|a
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|XML_READER_TYPE_TEXT
case|:
name|value
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|xmlTextReaderConstValue
argument_list|(
name|reader
argument_list|)
expr_stmt|;
name|xml_data
argument_list|(
name|a
argument_list|,
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|XML_READER_TYPE_SIGNIFICANT_WHITESPACE
case|:
default|default:
break|break;
block|}
if|if
condition|(
name|r
operator|<
literal|0
condition|)
break|break;
block|}
name|xmlFreeTextReader
argument_list|(
name|reader
argument_list|)
expr_stmt|;
name|xmlCleanupParser
argument_list|()
expr_stmt|;
return|return
operator|(
operator|(
name|r
operator|==
literal|0
operator|)
condition|?
name|ARCHIVE_OK
else|:
name|ARCHIVE_FATAL
operator|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_BSDXML_H
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_EXPAT_H
argument_list|)
end_elif

begin_function
specifier|static
name|int
name|expat_xmlattr_setup
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|xmlattr_list
modifier|*
name|list
parameter_list|,
specifier|const
name|XML_Char
modifier|*
modifier|*
name|atts
parameter_list|)
block|{
name|struct
name|xmlattr
modifier|*
name|attr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|list
operator|->
name|first
operator|=
name|NULL
expr_stmt|;
name|list
operator|->
name|last
operator|=
operator|&
operator|(
name|list
operator|->
name|first
operator|)
expr_stmt|;
if|if
condition|(
name|atts
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
while|while
condition|(
name|atts
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
name|atts
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
name|attr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
operator|(
name|attr
operator|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|strdup
argument_list|(
name|atts
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|value
operator|=
name|strdup
argument_list|(
name|atts
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|==
name|NULL
operator|||
name|name
operator|==
name|NULL
operator|||
name|value
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|attr
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|attr
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|attr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|list
operator|->
name|last
operator|=
name|attr
expr_stmt|;
name|list
operator|->
name|last
operator|=
operator|&
operator|(
name|attr
operator|->
name|next
operator|)
expr_stmt|;
name|atts
operator|+=
literal|2
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|expat_start_cb
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|name
parameter_list|,
specifier|const
name|XML_Char
modifier|*
modifier|*
name|atts
parameter_list|)
block|{
name|struct
name|expat_userData
modifier|*
name|ud
init|=
operator|(
expr|struct
name|expat_userData
operator|*
operator|)
name|userData
decl_stmt|;
name|struct
name|archive_read
modifier|*
name|a
init|=
name|ud
operator|->
name|archive
decl_stmt|;
name|struct
name|xmlattr_list
name|list
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|expat_xmlattr_setup
argument_list|(
name|a
argument_list|,
operator|&
name|list
argument_list|,
name|atts
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_OK
condition|)
name|r
operator|=
name|xml_start
argument_list|(
name|a
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|name
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|xmlattr_cleanup
argument_list|(
operator|&
name|list
argument_list|)
expr_stmt|;
name|ud
operator|->
name|state
operator|=
name|r
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|expat_end_cb
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|expat_userData
modifier|*
name|ud
init|=
operator|(
expr|struct
name|expat_userData
operator|*
operator|)
name|userData
decl_stmt|;
name|xml_end
argument_list|(
name|ud
operator|->
name|archive
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|expat_data_cb
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|expat_userData
modifier|*
name|ud
init|=
operator|(
expr|struct
name|expat_userData
operator|*
operator|)
name|userData
decl_stmt|;
name|xml_data
argument_list|(
name|ud
operator|->
name|archive
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|expat_read_toc
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
name|XML_Parser
name|parser
decl_stmt|;
name|struct
name|expat_userData
name|ud
decl_stmt|;
name|ud
operator|.
name|state
operator|=
name|ARCHIVE_OK
expr_stmt|;
name|ud
operator|.
name|archive
operator|=
name|a
expr_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
comment|/* Initialize XML Parser library. */
name|parser
operator|=
name|XML_ParserCreate
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Couldn't allocate memory for xml parser"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|XML_SetUserData
argument_list|(
name|parser
argument_list|,
operator|&
name|ud
argument_list|)
expr_stmt|;
name|XML_SetElementHandler
argument_list|(
name|parser
argument_list|,
name|expat_start_cb
argument_list|,
name|expat_end_cb
argument_list|)
expr_stmt|;
name|XML_SetCharacterDataHandler
argument_list|(
name|parser
argument_list|,
name|expat_data_cb
argument_list|)
expr_stmt|;
name|xar
operator|->
name|xmlsts
operator|=
name|INIT
expr_stmt|;
while|while
condition|(
name|xar
operator|->
name|toc_remaining
operator|&&
name|ud
operator|.
name|state
operator|==
name|ARCHIVE_OK
condition|)
block|{
name|enum
name|XML_Status
name|xr
decl_stmt|;
specifier|const
name|void
modifier|*
name|d
decl_stmt|;
name|size_t
name|outbytes
decl_stmt|;
name|size_t
name|used
decl_stmt|;
name|int
name|r
decl_stmt|;
name|d
operator|=
name|NULL
expr_stmt|;
name|r
operator|=
name|rd_contents
argument_list|(
name|a
argument_list|,
operator|&
name|d
argument_list|,
operator|&
name|outbytes
argument_list|,
operator|&
name|used
argument_list|,
name|xar
operator|->
name|toc_remaining
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|xar
operator|->
name|toc_remaining
operator|-=
name|used
expr_stmt|;
name|xar
operator|->
name|offset
operator|+=
name|used
expr_stmt|;
name|xar
operator|->
name|toc_total
operator|+=
name|outbytes
expr_stmt|;
name|PRINT_TOC
argument_list|(
name|d
argument_list|,
name|outbytes
argument_list|)
expr_stmt|;
name|xr
operator|=
name|XML_Parse
argument_list|(
name|parser
argument_list|,
name|d
argument_list|,
name|outbytes
argument_list|,
name|xar
operator|->
name|toc_remaining
operator|==
literal|0
argument_list|)
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|used
argument_list|)
expr_stmt|;
if|if
condition|(
name|xr
operator|==
name|XML_STATUS_ERROR
condition|)
block|{
name|XML_ParserFree
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"XML Parsing failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
name|XML_ParserFree
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
operator|(
name|ud
operator|.
name|state
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(HAVE_BSDXML_H) || defined(HAVE_EXPAT_H) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Support xar format */
end_comment

end_unit

