begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004 Tim Kientzle  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"archive_platform.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ERRNO_H
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"archive.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry.h"
end_include

begin_include
include|#
directive|include
file|"archive_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_read_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_endian.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_ZLIB_H
end_ifndef

begin_include
include|#
directive|include
file|"archive_crc32.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|zip
block|{
comment|/* entry_bytes_remaining is the number of bytes we expect. */
name|int64_t
name|entry_bytes_remaining
decl_stmt|;
name|int64_t
name|entry_offset
decl_stmt|;
comment|/* These count the number of bytes actually read for the entry. */
name|int64_t
name|entry_compressed_bytes_read
decl_stmt|;
name|int64_t
name|entry_uncompressed_bytes_read
decl_stmt|;
comment|/* Running CRC32 of the decompressed data */
name|unsigned
name|long
name|entry_crc32
decl_stmt|;
name|unsigned
name|version
decl_stmt|;
name|unsigned
name|system
decl_stmt|;
name|unsigned
name|flags
decl_stmt|;
name|unsigned
name|compression
decl_stmt|;
specifier|const
name|char
modifier|*
name|compression_name
decl_stmt|;
name|time_t
name|mtime
decl_stmt|;
name|time_t
name|ctime
decl_stmt|;
name|time_t
name|atime
decl_stmt|;
name|mode_t
name|mode
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
comment|/* Flags to mark progress of decompression. */
name|char
name|decompress_init
decl_stmt|;
name|char
name|end_of_entry
decl_stmt|;
name|unsigned
name|long
name|crc32
decl_stmt|;
name|ssize_t
name|filename_length
decl_stmt|;
name|ssize_t
name|extra_length
decl_stmt|;
name|int64_t
name|uncompressed_size
decl_stmt|;
name|int64_t
name|compressed_size
decl_stmt|;
name|unsigned
name|char
modifier|*
name|uncompressed_buffer
decl_stmt|;
name|size_t
name|uncompressed_buffer_size
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
name|z_stream
name|stream
decl_stmt|;
name|char
name|stream_valid
decl_stmt|;
endif|#
directive|endif
name|struct
name|archive_string
name|pathname
decl_stmt|;
name|struct
name|archive_string
name|extra
decl_stmt|;
name|char
name|format_name
index|[
literal|64
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ZIP_LENGTH_AT_END
value|8
end_define

begin_struct
struct|struct
name|zip_file_header
block|{
name|char
name|signature
index|[
literal|4
index|]
decl_stmt|;
name|char
name|version
index|[
literal|2
index|]
decl_stmt|;
name|char
name|flags
index|[
literal|2
index|]
decl_stmt|;
name|char
name|compression
index|[
literal|2
index|]
decl_stmt|;
name|char
name|timedate
index|[
literal|4
index|]
decl_stmt|;
name|char
name|crc32
index|[
literal|4
index|]
decl_stmt|;
name|char
name|compressed_size
index|[
literal|4
index|]
decl_stmt|;
name|char
name|uncompressed_size
index|[
literal|4
index|]
decl_stmt|;
name|char
name|filename_length
index|[
literal|2
index|]
decl_stmt|;
name|char
name|extra_length
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|compression_names
index|[]
init|=
block|{
literal|"uncompressed"
block|,
literal|"shrinking"
block|,
literal|"reduced-1"
block|,
literal|"reduced-2"
block|,
literal|"reduced-3"
block|,
literal|"reduced-4"
block|,
literal|"imploded"
block|,
literal|"reserved"
block|,
literal|"deflation"
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|archive_read_format_zip_bid
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_zip_cleanup
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_zip_read_data
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|off_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_zip_read_data_skip
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_zip_read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zip_read_data_deflate
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|off_t
modifier|*
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zip_read_data_none
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|off_t
modifier|*
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zip_read_file_header
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|zip
modifier|*
name|zip
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|time_t
name|zip_time
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_extra
parameter_list|(
specifier|const
name|void
modifier|*
name|extra
parameter_list|,
name|struct
name|zip
modifier|*
name|zip
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|archive_read_support_format_zip
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|struct
name|zip
modifier|*
name|zip
decl_stmt|;
name|int
name|r
decl_stmt|;
name|zip
operator|=
operator|(
expr|struct
name|zip
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|zip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate zip data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|memset
argument_list|(
name|zip
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zip
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|__archive_read_register_format
argument_list|(
name|a
argument_list|,
name|zip
argument_list|,
literal|"zip"
argument_list|,
name|archive_read_format_zip_bid
argument_list|,
name|NULL
argument_list|,
name|archive_read_format_zip_read_header
argument_list|,
name|archive_read_format_zip_read_data
argument_list|,
name|archive_read_format_zip_read_data_skip
argument_list|,
name|archive_read_format_zip_cleanup
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|free
argument_list|(
name|zip
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_zip_bid
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|void
modifier|*
name|buff
decl_stmt|;
name|ssize_t
name|bytes_avail
decl_stmt|,
name|offset
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|4
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Bid of 30 here is: 16 bits for "PK", 	 * next 16-bit field has four options (-2 bits). 	 * 16 + 16-2 = 30. 	 */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'P'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'K'
condition|)
block|{
if|if
condition|(
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|'\001'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'\002'
operator|)
operator|||
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|'\003'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'\004'
operator|)
operator|||
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|'\005'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'\006'
operator|)
operator|||
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|'\007'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'\010'
operator|)
operator|||
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|'0'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'0'
operator|)
condition|)
return|return
operator|(
literal|30
operator|)
return|;
block|}
comment|/* 	 * Attempt to handle self-extracting archives 	 * by noting a PE header and searching forward 	 * up to 128k for a 'PK\003\004' marker. 	 */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'M'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'Z'
condition|)
block|{
comment|/* 		 * TODO: Optimize by initializing 'offset' to an 		 * estimate of the likely start of the archive data 		 * based on values in the PE header.  Note that we 		 * don't need to be exact, but we mustn't skip too 		 * far.  The search below will compensate if we 		 * undershoot. 		 */
name|offset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|offset
operator|<
literal|124000
condition|)
block|{
comment|/* Get 4k of data beyond where we stopped. */
name|buff
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|offset
operator|+
literal|4096
argument_list|,
operator|&
name|bytes_avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|buff
operator|==
name|NULL
condition|)
break|break;
name|p
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|buff
operator|+
name|offset
expr_stmt|;
while|while
condition|(
name|p
operator|+
literal|9
operator|<
operator|(
specifier|const
name|char
operator|*
operator|)
name|buff
operator|+
name|bytes_avail
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'P'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'K'
comment|/* signature */
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|3
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|4
comment|/* File entry */
operator|&&
name|p
index|[
literal|8
index|]
operator|==
literal|8
comment|/* compression == deflate */
operator|&&
name|p
index|[
literal|9
index|]
operator|==
literal|0
comment|/* High byte of compression */
condition|)
block|{
return|return
operator|(
literal|30
operator|)
return|;
block|}
operator|++
name|p
expr_stmt|;
block|}
name|offset
operator|=
name|p
operator|-
operator|(
specifier|const
name|char
operator|*
operator|)
name|buff
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Search forward for a "PK\003\004" file header.  This handles the  * case of self-extracting archives, where there is an executable  * prepended to the ZIP archive.  */
end_comment

begin_function
specifier|static
name|int
name|skip_sfx
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|h
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|size_t
name|skip
decl_stmt|;
name|ssize_t
name|bytes
decl_stmt|;
comment|/* 	 * TODO: We should be able to skip forward by a bunch 	 * by lifting some values from the PE header.  We don't 	 * need to be exact (we're still going to search forward 	 * to find the header), but it will speed things up and 	 * reduce the chance of a false positive. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|h
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|4
argument_list|,
operator|&
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|<
literal|4
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|p
operator|=
name|h
expr_stmt|;
name|q
operator|=
name|p
operator|+
name|bytes
expr_stmt|;
comment|/* 		 * Scan ahead until we find something that looks 		 * like the zip header. 		 */
while|while
condition|(
name|p
operator|+
literal|4
operator|<
name|q
condition|)
block|{
switch|switch
condition|(
name|p
index|[
literal|3
index|]
condition|)
block|{
case|case
literal|'\004'
case|:
comment|/* TODO: Additional verification here. */
if|if
condition|(
name|memcmp
argument_list|(
literal|"PK\003\004"
argument_list|,
name|p
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|skip
operator|=
name|p
operator|-
operator|(
specifier|const
name|char
operator|*
operator|)
name|h
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|skip
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
name|p
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
literal|'\003'
case|:
name|p
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|p
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|p
operator|+=
literal|3
expr_stmt|;
break|break;
default|default:
name|p
operator|+=
literal|4
expr_stmt|;
break|break;
block|}
block|}
name|skip
operator|=
name|p
operator|-
operator|(
specifier|const
name|char
operator|*
operator|)
name|h
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|skip
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_zip_read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|h
decl_stmt|;
specifier|const
name|char
modifier|*
name|signature
decl_stmt|;
name|struct
name|zip
modifier|*
name|zip
decl_stmt|;
name|int
name|r
init|=
name|ARCHIVE_OK
decl_stmt|,
name|r1
decl_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_ZIP
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|==
name|NULL
condition|)
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"ZIP"
expr_stmt|;
name|zip
operator|=
operator|(
expr|struct
name|zip
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
name|zip
operator|->
name|decompress_init
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|end_of_entry
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|entry_uncompressed_bytes_read
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|entry_compressed_bytes_read
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|entry_crc32
operator|=
name|crc32
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|4
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|signature
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|signature
index|[
literal|0
index|]
operator|==
literal|'M'
operator|&&
name|signature
index|[
literal|1
index|]
operator|==
literal|'Z'
condition|)
block|{
comment|/* This is an executable?  Must be self-extracting... */
name|r
operator|=
name|skip_sfx
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|ARCHIVE_WARN
condition|)
return|return
operator|(
name|r
operator|)
return|;
if|if
condition|(
operator|(
name|h
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|4
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|signature
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|h
expr_stmt|;
block|}
if|if
condition|(
name|signature
index|[
literal|0
index|]
operator|!=
literal|'P'
operator|||
name|signature
index|[
literal|1
index|]
operator|!=
literal|'K'
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Bad ZIP file"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* 	 * "PK00" signature is used for "split" archives that 	 * only have a single segment.  This means we can just 	 * skip the PK00; the first real file header should follow. 	 */
if|if
condition|(
name|signature
index|[
literal|2
index|]
operator|==
literal|'0'
operator|&&
name|signature
index|[
literal|3
index|]
operator|==
literal|'0'
condition|)
block|{
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|4
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|signature
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|signature
index|[
literal|0
index|]
operator|!=
literal|'P'
operator|||
name|signature
index|[
literal|1
index|]
operator|!=
literal|'K'
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Bad ZIP file"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|signature
index|[
literal|2
index|]
operator|==
literal|'\001'
operator|&&
name|signature
index|[
literal|3
index|]
operator|==
literal|'\002'
condition|)
block|{
comment|/* Beginning of central directory. */
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
block|}
if|if
condition|(
name|signature
index|[
literal|2
index|]
operator|==
literal|'\003'
operator|&&
name|signature
index|[
literal|3
index|]
operator|==
literal|'\004'
condition|)
block|{
comment|/* Regular file entry. */
name|r1
operator|=
name|zip_read_file_header
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|zip
argument_list|)
expr_stmt|;
if|if
condition|(
name|r1
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r1
operator|)
return|;
return|return
operator|(
name|r
operator|)
return|;
block|}
if|if
condition|(
name|signature
index|[
literal|2
index|]
operator|==
literal|'\005'
operator|&&
name|signature
index|[
literal|3
index|]
operator|==
literal|'\006'
condition|)
block|{
comment|/* End-of-archive record. */
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
block|}
if|if
condition|(
name|signature
index|[
literal|2
index|]
operator|==
literal|'\007'
operator|&&
name|signature
index|[
literal|3
index|]
operator|==
literal|'\010'
condition|)
block|{
comment|/* 		 * We should never encounter this record here; 		 * see ZIP_LENGTH_AT_END handling below for details. 		 */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Bad ZIP file: Unexpected end-of-entry record"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Damaged ZIP file or unsupported format variant (%d,%d)"
argument_list|,
name|signature
index|[
literal|2
index|]
argument_list|,
name|signature
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zip_read_file_header
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|zip
modifier|*
name|zip
parameter_list|)
block|{
specifier|const
name|struct
name|zip_file_header
modifier|*
name|p
decl_stmt|;
specifier|const
name|void
modifier|*
name|h
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
sizeof|sizeof
expr|*
name|p
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated ZIP file header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|zip
operator|->
name|version
operator|=
name|p
operator|->
name|version
index|[
literal|0
index|]
expr_stmt|;
name|zip
operator|->
name|system
operator|=
name|p
operator|->
name|version
index|[
literal|1
index|]
expr_stmt|;
name|zip
operator|->
name|flags
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|->
name|flags
argument_list|)
expr_stmt|;
name|zip
operator|->
name|compression
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|->
name|compression
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|compression
operator|<
sizeof|sizeof
argument_list|(
name|compression_names
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|compression_names
index|[
literal|0
index|]
argument_list|)
condition|)
name|zip
operator|->
name|compression_name
operator|=
name|compression_names
index|[
name|zip
operator|->
name|compression
index|]
expr_stmt|;
else|else
name|zip
operator|->
name|compression_name
operator|=
literal|"??"
expr_stmt|;
name|zip
operator|->
name|mtime
operator|=
name|zip_time
argument_list|(
name|p
operator|->
name|timedate
argument_list|)
expr_stmt|;
name|zip
operator|->
name|ctime
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|atime
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|mode
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|uid
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|gid
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|crc32
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|->
name|crc32
argument_list|)
expr_stmt|;
name|zip
operator|->
name|filename_length
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|->
name|filename_length
argument_list|)
expr_stmt|;
name|zip
operator|->
name|extra_length
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|->
name|extra_length
argument_list|)
expr_stmt|;
name|zip
operator|->
name|uncompressed_size
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|->
name|uncompressed_size
argument_list|)
expr_stmt|;
name|zip
operator|->
name|compressed_size
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|->
name|compressed_size
argument_list|)
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|zip_file_header
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the filename. */
if|if
condition|(
operator|(
name|h
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|zip
operator|->
name|filename_length
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated ZIP file header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|archive_string_ensure
argument_list|(
operator|&
name|zip
operator|->
name|pathname
argument_list|,
name|zip
operator|->
name|filename_length
argument_list|)
operator|==
name|NULL
condition|)
name|__archive_errx
argument_list|(
literal|1
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
name|archive_strncpy
argument_list|(
operator|&
name|zip
operator|->
name|pathname
argument_list|,
name|h
argument_list|,
name|zip
operator|->
name|filename_length
argument_list|)
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|zip
operator|->
name|filename_length
argument_list|)
expr_stmt|;
name|archive_entry_set_pathname
argument_list|(
name|entry
argument_list|,
name|zip
operator|->
name|pathname
operator|.
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|pathname
operator|.
name|s
index|[
name|archive_strlen
argument_list|(
operator|&
name|zip
operator|->
name|pathname
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|zip
operator|->
name|mode
operator|=
name|AE_IFDIR
operator||
literal|0777
expr_stmt|;
else|else
name|zip
operator|->
name|mode
operator|=
name|AE_IFREG
operator||
literal|0777
expr_stmt|;
comment|/* Read the extra data. */
if|if
condition|(
operator|(
name|h
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|zip
operator|->
name|extra_length
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated ZIP file header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|process_extra
argument_list|(
name|h
argument_list|,
name|zip
argument_list|)
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|zip
operator|->
name|extra_length
argument_list|)
expr_stmt|;
comment|/* Populate some additional entry fields: */
name|archive_entry_set_mode
argument_list|(
name|entry
argument_list|,
name|zip
operator|->
name|mode
argument_list|)
expr_stmt|;
name|archive_entry_set_uid
argument_list|(
name|entry
argument_list|,
name|zip
operator|->
name|uid
argument_list|)
expr_stmt|;
name|archive_entry_set_gid
argument_list|(
name|entry
argument_list|,
name|zip
operator|->
name|gid
argument_list|)
expr_stmt|;
name|archive_entry_set_mtime
argument_list|(
name|entry
argument_list|,
name|zip
operator|->
name|mtime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|archive_entry_set_ctime
argument_list|(
name|entry
argument_list|,
name|zip
operator|->
name|ctime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|archive_entry_set_atime
argument_list|(
name|entry
argument_list|,
name|zip
operator|->
name|atime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set the size only if it's meaningful. */
if|if
condition|(
literal|0
operator|==
operator|(
name|zip
operator|->
name|flags
operator|&
name|ZIP_LENGTH_AT_END
operator|)
condition|)
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
name|zip
operator|->
name|uncompressed_size
argument_list|)
expr_stmt|;
name|zip
operator|->
name|entry_bytes_remaining
operator|=
name|zip
operator|->
name|compressed_size
expr_stmt|;
name|zip
operator|->
name|entry_offset
operator|=
literal|0
expr_stmt|;
comment|/* If there's no body, force read_data() to return EOF immediately. */
if|if
condition|(
literal|0
operator|==
operator|(
name|zip
operator|->
name|flags
operator|&
name|ZIP_LENGTH_AT_END
operator|)
operator|&&
name|zip
operator|->
name|entry_bytes_remaining
operator|<
literal|1
condition|)
name|zip
operator|->
name|end_of_entry
operator|=
literal|1
expr_stmt|;
comment|/* Set up a more descriptive format name. */
name|sprintf
argument_list|(
name|zip
operator|->
name|format_name
argument_list|,
literal|"ZIP %d.%d (%s)"
argument_list|,
name|zip
operator|->
name|version
operator|/
literal|10
argument_list|,
name|zip
operator|->
name|version
operator|%
literal|10
argument_list|,
name|zip
operator|->
name|compression_name
argument_list|)
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
name|zip
operator|->
name|format_name
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert an MSDOS-style date/time into Unix-style time. */
end_comment

begin_function
specifier|static
name|time_t
name|zip_time
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
name|int
name|msTime
decl_stmt|,
name|msDate
decl_stmt|;
name|struct
name|tm
name|ts
decl_stmt|;
name|msTime
operator|=
operator|(
literal|0xff
operator|&
operator|(
name|unsigned
operator|)
name|p
index|[
literal|0
index|]
operator|)
operator|+
literal|256
operator|*
operator|(
literal|0xff
operator|&
operator|(
name|unsigned
operator|)
name|p
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|msDate
operator|=
operator|(
literal|0xff
operator|&
operator|(
name|unsigned
operator|)
name|p
index|[
literal|2
index|]
operator|)
operator|+
literal|256
operator|*
operator|(
literal|0xff
operator|&
operator|(
name|unsigned
operator|)
name|p
index|[
literal|3
index|]
operator|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
name|ts
operator|.
name|tm_year
operator|=
operator|(
operator|(
name|msDate
operator|>>
literal|9
operator|)
operator|&
literal|0x7f
operator|)
operator|+
literal|80
expr_stmt|;
comment|/* Years since 1900. */
name|ts
operator|.
name|tm_mon
operator|=
operator|(
operator|(
name|msDate
operator|>>
literal|5
operator|)
operator|&
literal|0x0f
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* Month number. */
name|ts
operator|.
name|tm_mday
operator|=
name|msDate
operator|&
literal|0x1f
expr_stmt|;
comment|/* Day of month. */
name|ts
operator|.
name|tm_hour
operator|=
operator|(
name|msTime
operator|>>
literal|11
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|ts
operator|.
name|tm_min
operator|=
operator|(
name|msTime
operator|>>
literal|5
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|ts
operator|.
name|tm_sec
operator|=
operator|(
name|msTime
operator|<<
literal|1
operator|)
operator|&
literal|0x3e
expr_stmt|;
name|ts
operator|.
name|tm_isdst
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|mktime
argument_list|(
operator|&
name|ts
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_zip_read_data
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|off_t
modifier|*
name|offset
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|struct
name|zip
modifier|*
name|zip
decl_stmt|;
name|zip
operator|=
operator|(
expr|struct
name|zip
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
comment|/* 	 * If we hit end-of-entry last time, clean up and return 	 * ARCHIVE_EOF this time. 	 */
if|if
condition|(
name|zip
operator|->
name|end_of_entry
condition|)
block|{
operator|*
name|offset
operator|=
name|zip
operator|->
name|entry_uncompressed_bytes_read
expr_stmt|;
operator|*
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|buff
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
block|}
switch|switch
condition|(
name|zip
operator|->
name|compression
condition|)
block|{
case|case
literal|0
case|:
comment|/* No compression. */
name|r
operator|=
name|zip_read_data_none
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|size
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/* Deflate compression. */
name|r
operator|=
name|zip_read_data_deflate
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|size
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Unsupported compression. */
operator|*
name|buff
operator|=
name|NULL
expr_stmt|;
operator|*
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* Return a warning. */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Unsupported ZIP compression method (%s)"
argument_list|,
name|zip
operator|->
name|compression_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|flags
operator|&
name|ZIP_LENGTH_AT_END
condition|)
block|{
comment|/* 			 * ZIP_LENGTH_AT_END requires us to 			 * decompress the entry in order to 			 * skip it, but we don't know this 			 * compression method, so we give up. 			 */
name|r
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
block|}
else|else
block|{
comment|/* We can't decompress this entry, but we will 			 * be able to skip() it and try the next entry. */
name|r
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
comment|/* Update checksum */
if|if
condition|(
operator|*
name|size
condition|)
name|zip
operator|->
name|entry_crc32
operator|=
name|crc32
argument_list|(
name|zip
operator|->
name|entry_crc32
argument_list|,
operator|*
name|buff
argument_list|,
operator|*
name|size
argument_list|)
expr_stmt|;
comment|/* If we hit the end, swallow any end-of-data marker. */
if|if
condition|(
name|zip
operator|->
name|end_of_entry
condition|)
block|{
if|if
condition|(
name|zip
operator|->
name|flags
operator|&
name|ZIP_LENGTH_AT_END
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|16
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated ZIP end-of-file record"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|zip
operator|->
name|crc32
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|4
argument_list|)
expr_stmt|;
name|zip
operator|->
name|compressed_size
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|8
argument_list|)
expr_stmt|;
name|zip
operator|->
name|uncompressed_size
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|12
argument_list|)
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
comment|/* Check file size, CRC against these values. */
if|if
condition|(
name|zip
operator|->
name|compressed_size
operator|!=
name|zip
operator|->
name|entry_compressed_bytes_read
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"ZIP compressed data is wrong size"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* Size field only stores the lower 32 bits of the actual size. */
if|if
condition|(
operator|(
name|zip
operator|->
name|uncompressed_size
operator|&
name|UINT32_MAX
operator|)
operator|!=
operator|(
name|zip
operator|->
name|entry_uncompressed_bytes_read
operator|&
name|UINT32_MAX
operator|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"ZIP uncompressed data is wrong size"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* Check computed CRC against header */
if|if
condition|(
name|zip
operator|->
name|crc32
operator|!=
name|zip
operator|->
name|entry_crc32
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"ZIP bad CRC: 0x%lx should be 0x%lx"
argument_list|,
name|zip
operator|->
name|entry_crc32
argument_list|,
name|zip
operator|->
name|crc32
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
block|}
comment|/* Return EOF immediately if this is a non-regular file. */
if|if
condition|(
name|AE_IFREG
operator|!=
operator|(
name|zip
operator|->
name|mode
operator|&
name|AE_IFMT
operator|)
condition|)
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read "uncompressed" data.  According to the current specification,  * if ZIP_LENGTH_AT_END is specified, then the size fields in the  * initial file header are supposed to be set to zero.  This would, of  * course, make it impossible for us to read the archive, since we  * couldn't determine the end of the file data.  Info-ZIP seems to  * include the real size fields both before and after the data in this  * case (the CRC only appears afterwards), so this works as you would  * expect.  *  * Returns ARCHIVE_OK if successful, ARCHIVE_FATAL otherwise, sets  * zip->end_of_entry if it consumes all of the data.  */
end_comment

begin_function
specifier|static
name|int
name|zip_read_data_none
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|off_t
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
decl_stmt|;
name|ssize_t
name|bytes_avail
decl_stmt|;
name|zip
operator|=
operator|(
expr|struct
name|zip
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|entry_bytes_remaining
operator|==
literal|0
condition|)
block|{
operator|*
name|buff
operator|=
name|NULL
expr_stmt|;
operator|*
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|offset
operator|=
name|zip
operator|->
name|entry_offset
expr_stmt|;
name|zip
operator|->
name|end_of_entry
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
comment|/* 	 * Note: '1' here is a performance optimization. 	 * Recall that the decompression layer returns a count of 	 * available bytes; asking for more than that forces the 	 * decompressor to combine reads by copying data. 	 */
operator|*
name|buff
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
operator|&
name|bytes_avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_avail
operator|<=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated ZIP file data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|bytes_avail
operator|>
name|zip
operator|->
name|entry_bytes_remaining
condition|)
name|bytes_avail
operator|=
name|zip
operator|->
name|entry_bytes_remaining
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|bytes_avail
argument_list|)
expr_stmt|;
operator|*
name|size
operator|=
name|bytes_avail
expr_stmt|;
operator|*
name|offset
operator|=
name|zip
operator|->
name|entry_offset
expr_stmt|;
name|zip
operator|->
name|entry_offset
operator|+=
operator|*
name|size
expr_stmt|;
name|zip
operator|->
name|entry_bytes_remaining
operator|-=
operator|*
name|size
expr_stmt|;
name|zip
operator|->
name|entry_uncompressed_bytes_read
operator|+=
operator|*
name|size
expr_stmt|;
name|zip
operator|->
name|entry_compressed_bytes_read
operator|+=
operator|*
name|size
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
end_ifdef

begin_function
specifier|static
name|int
name|zip_read_data_deflate
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|off_t
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
decl_stmt|;
name|ssize_t
name|bytes_avail
decl_stmt|;
specifier|const
name|void
modifier|*
name|compressed_buff
decl_stmt|;
name|int
name|r
decl_stmt|;
name|zip
operator|=
operator|(
expr|struct
name|zip
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
comment|/* If the buffer hasn't been allocated, allocate it now. */
if|if
condition|(
name|zip
operator|->
name|uncompressed_buffer
operator|==
name|NULL
condition|)
block|{
name|zip
operator|->
name|uncompressed_buffer_size
operator|=
literal|32
operator|*
literal|1024
expr_stmt|;
name|zip
operator|->
name|uncompressed_buffer
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|zip
operator|->
name|uncompressed_buffer_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|uncompressed_buffer
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"No memory for ZIP decompression"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
comment|/* If we haven't yet read any data, initialize the decompressor. */
if|if
condition|(
operator|!
name|zip
operator|->
name|decompress_init
condition|)
block|{
if|if
condition|(
name|zip
operator|->
name|stream_valid
condition|)
name|r
operator|=
name|inflateReset
argument_list|(
operator|&
name|zip
operator|->
name|stream
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|inflateInit2
argument_list|(
operator|&
name|zip
operator|->
name|stream
argument_list|,
operator|-
literal|15
comment|/* Don't check for zlib header */
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|Z_OK
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Can't initialize ZIP decompression."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Stream structure has been set up. */
name|zip
operator|->
name|stream_valid
operator|=
literal|1
expr_stmt|;
comment|/* We've initialized decompression for this stream. */
name|zip
operator|->
name|decompress_init
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Note: '1' here is a performance optimization. 	 * Recall that the decompression layer returns a count of 	 * available bytes; asking for more than that forces the 	 * decompressor to combine reads by copying data. 	 */
name|compressed_buff
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
operator|&
name|bytes_avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_avail
operator|<=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated ZIP file body"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* 	 * A bug in zlib.h: stream.next_in should be marked 'const' 	 * but isn't (the library never alters data through the 	 * next_in pointer, only reads it).  The result: this ugly 	 * cast to remove 'const'. 	 */
name|zip
operator|->
name|stream
operator|.
name|next_in
operator|=
operator|(
name|Bytef
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|(
specifier|const
name|void
operator|*
operator|)
name|compressed_buff
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|avail_in
operator|=
name|bytes_avail
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|total_in
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|next_out
operator|=
name|zip
operator|->
name|uncompressed_buffer
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|avail_out
operator|=
name|zip
operator|->
name|uncompressed_buffer_size
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|total_out
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|inflate
argument_list|(
operator|&
name|zip
operator|->
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|Z_OK
case|:
break|break;
case|case
name|Z_STREAM_END
case|:
name|zip
operator|->
name|end_of_entry
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|Z_MEM_ERROR
case|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Out of memory for ZIP decompression"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
default|default:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"ZIP decompression failed (%d)"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Consume as much as the compressor actually used. */
name|bytes_avail
operator|=
name|zip
operator|->
name|stream
operator|.
name|total_in
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|bytes_avail
argument_list|)
expr_stmt|;
name|zip
operator|->
name|entry_bytes_remaining
operator|-=
name|bytes_avail
expr_stmt|;
name|zip
operator|->
name|entry_compressed_bytes_read
operator|+=
name|bytes_avail
expr_stmt|;
operator|*
name|offset
operator|=
name|zip
operator|->
name|entry_offset
expr_stmt|;
operator|*
name|size
operator|=
name|zip
operator|->
name|stream
operator|.
name|total_out
expr_stmt|;
name|zip
operator|->
name|entry_uncompressed_bytes_read
operator|+=
operator|*
name|size
expr_stmt|;
operator|*
name|buff
operator|=
name|zip
operator|->
name|uncompressed_buffer
expr_stmt|;
name|zip
operator|->
name|entry_offset
operator|+=
operator|*
name|size
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|zip_read_data_deflate
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|off_t
modifier|*
name|offset
parameter_list|)
block|{
operator|*
name|buff
operator|=
name|NULL
expr_stmt|;
operator|*
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|offset
operator|=
literal|0
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"libarchive compiled without deflate support (no libz)"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|archive_read_format_zip_read_data_skip
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
decl_stmt|;
specifier|const
name|void
modifier|*
name|buff
init|=
name|NULL
decl_stmt|;
name|off_t
name|bytes_skipped
decl_stmt|;
name|zip
operator|=
operator|(
expr|struct
name|zip
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
comment|/* If we've already read to end of data, we're done. */
if|if
condition|(
name|zip
operator|->
name|end_of_entry
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
comment|/* 	 * If the length is at the end, we have no choice but 	 * to decompress all the data to find the end marker. 	 */
if|if
condition|(
name|zip
operator|->
name|flags
operator|&
name|ZIP_LENGTH_AT_END
condition|)
block|{
name|size_t
name|size
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|int
name|r
decl_stmt|;
do|do
block|{
name|r
operator|=
name|archive_read_format_zip_read_data
argument_list|(
name|a
argument_list|,
operator|&
name|buff
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|r
operator|==
name|ARCHIVE_OK
condition|)
do|;
return|return
operator|(
name|r
operator|)
return|;
block|}
comment|/* 	 * If the length is at the beginning, we can skip the 	 * compressed data much more quickly. 	 */
name|bytes_skipped
operator|=
name|__archive_read_skip
argument_list|(
name|a
argument_list|,
name|zip
operator|->
name|entry_bytes_remaining
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_skipped
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
comment|/* This entry is finished and done. */
name|zip
operator|->
name|end_of_entry
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_zip_cleanup
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
decl_stmt|;
name|zip
operator|=
operator|(
expr|struct
name|zip
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
if|if
condition|(
name|zip
operator|->
name|stream_valid
condition|)
name|inflateEnd
argument_list|(
operator|&
name|zip
operator|->
name|stream
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|zip
operator|->
name|uncompressed_buffer
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|zip
operator|->
name|pathname
operator|)
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|zip
operator|->
name|extra
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zip
argument_list|)
expr_stmt|;
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The extra data is stored as a list of  *	id1+size1+data1 + id2+size2+data2 ...  *  triplets.  id and size are 2 bytes each.  */
end_comment

begin_function
specifier|static
name|void
name|process_extra
parameter_list|(
specifier|const
name|void
modifier|*
name|extra
parameter_list|,
name|struct
name|zip
modifier|*
name|zip
parameter_list|)
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|extra
decl_stmt|;
while|while
condition|(
name|offset
operator|<
name|zip
operator|->
name|extra_length
operator|-
literal|4
condition|)
block|{
name|unsigned
name|short
name|headerid
init|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
decl_stmt|;
name|unsigned
name|short
name|datasize
init|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
operator|+
literal|2
argument_list|)
decl_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|offset
operator|+
name|datasize
operator|>
name|zip
operator|->
name|extra_length
condition|)
break|break;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Header id 0x%04x, length %d\n"
argument_list|,
name|headerid
argument_list|,
name|datasize
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|headerid
condition|)
block|{
case|case
literal|0x0001
case|:
comment|/* Zip64 extended information extra field. */
if|if
condition|(
name|datasize
operator|>=
literal|8
condition|)
name|zip
operator|->
name|uncompressed_size
operator|=
name|archive_le64dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|datasize
operator|>=
literal|16
condition|)
name|zip
operator|->
name|compressed_size
operator|=
name|archive_le64dec
argument_list|(
name|p
operator|+
name|offset
operator|+
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x5455
case|:
block|{
comment|/* Extended time field "UT". */
name|int
name|flags
init|=
name|p
index|[
name|offset
index|]
decl_stmt|;
name|offset
operator|++
expr_stmt|;
name|datasize
operator|--
expr_stmt|;
comment|/* Flag bits indicate which dates are present. */
if|if
condition|(
name|flags
operator|&
literal|0x01
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mtime: %lld -> %d\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|zip
operator|->
name|mtime
argument_list|,
name|archive_le32dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|datasize
operator|<
literal|4
condition|)
break|break;
name|zip
operator|->
name|mtime
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|datasize
operator|-=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
literal|0x02
condition|)
block|{
if|if
condition|(
name|datasize
operator|<
literal|4
condition|)
break|break;
name|zip
operator|->
name|atime
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|datasize
operator|-=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
literal|0x04
condition|)
block|{
if|if
condition|(
name|datasize
operator|<
literal|4
condition|)
break|break;
name|zip
operator|->
name|ctime
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|datasize
operator|-=
literal|4
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|0x7855
case|:
comment|/* Info-ZIP Unix Extra Field (type 2) "Ux". */
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"uid %d gid %d\n"
argument_list|,
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
argument_list|,
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|datasize
operator|>=
literal|2
condition|)
name|zip
operator|->
name|uid
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|datasize
operator|>=
literal|4
condition|)
name|zip
operator|->
name|gid
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|offset
operator|+=
name|datasize
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|offset
operator|!=
name|zip
operator|->
name|extra_length
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Extra data field contents do not match reported size!"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

end_unit

