begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2011 Tim Kientzle  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * This file contains the "essential" portions of the read API, that  * is, stuff that will probably always be used by any client that  * actually needs to read an archive.  Optional pieces have been, as  * far as possible, separated out into separate files to avoid  * needlessly bloating statically-linked clients.  */
end_comment

begin_include
include|#
directive|include
file|"archive_platform.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ERRNO_H
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"archive.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry.h"
end_include

begin_include
include|#
directive|include
file|"archive_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_read_private.h"
end_include

begin_define
define|#
directive|define
name|minimum
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(a< b ? a : b)
end_define

begin_function_decl
specifier|static
name|int
name|choose_filters
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|choose_format
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|archive_vtable
modifier|*
name|archive_read_vtable
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|_archive_filter_bytes
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_archive_filter_code
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|_archive_filter_name
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_archive_filter_count
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_archive_read_close
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_archive_read_data_block
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|int64_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_archive_read_free
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_archive_read_next_header
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_archive_read_next_header2
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|advance_file_pointer
parameter_list|(
name|struct
name|archive_read_filter
modifier|*
parameter_list|,
name|int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|struct
name|archive_vtable
modifier|*
name|archive_read_vtable
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|struct
name|archive_vtable
name|av
decl_stmt|;
specifier|static
name|int
name|inited
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|inited
condition|)
block|{
name|av
operator|.
name|archive_filter_bytes
operator|=
name|_archive_filter_bytes
expr_stmt|;
name|av
operator|.
name|archive_filter_code
operator|=
name|_archive_filter_code
expr_stmt|;
name|av
operator|.
name|archive_filter_name
operator|=
name|_archive_filter_name
expr_stmt|;
name|av
operator|.
name|archive_filter_count
operator|=
name|_archive_filter_count
expr_stmt|;
name|av
operator|.
name|archive_read_data_block
operator|=
name|_archive_read_data_block
expr_stmt|;
name|av
operator|.
name|archive_read_next_header
operator|=
name|_archive_read_next_header
expr_stmt|;
name|av
operator|.
name|archive_read_next_header2
operator|=
name|_archive_read_next_header2
expr_stmt|;
name|av
operator|.
name|archive_free
operator|=
name|_archive_read_free
expr_stmt|;
name|av
operator|.
name|archive_close
operator|=
name|_archive_read_close
expr_stmt|;
name|inited
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|av
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate, initialize and return a struct archive object.  */
end_comment

begin_function
name|struct
name|archive
modifier|*
name|archive_read_new
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
decl_stmt|;
name|a
operator|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|a
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|a
operator|->
name|archive
operator|.
name|magic
operator|=
name|ARCHIVE_READ_MAGIC
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|state
operator|=
name|ARCHIVE_STATE_NEW
expr_stmt|;
name|a
operator|->
name|entry
operator|=
name|archive_entry_new2
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|)
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|vtable
operator|=
name|archive_read_vtable
argument_list|()
expr_stmt|;
name|a
operator|->
name|passphrases
operator|.
name|last
operator|=
operator|&
name|a
operator|->
name|passphrases
operator|.
name|first
expr_stmt|;
return|return
operator|(
operator|&
name|a
operator|->
name|archive
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Record the do-not-extract-to file. This belongs in archive_read_extract.c.  */
end_comment

begin_function
name|void
name|archive_read_extract_set_skip_file
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
name|int64_t
name|d
parameter_list|,
name|int64_t
name|i
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
if|if
condition|(
name|ARCHIVE_OK
operator|!=
name|__archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_READ_MAGIC
argument_list|,
name|ARCHIVE_STATE_ANY
argument_list|,
literal|"archive_read_extract_set_skip_file"
argument_list|)
condition|)
return|return;
name|a
operator|->
name|skip_file_set
operator|=
literal|1
expr_stmt|;
name|a
operator|->
name|skip_file_dev
operator|=
name|d
expr_stmt|;
name|a
operator|->
name|skip_file_ino
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Open the archive  */
end_comment

begin_function
name|int
name|archive_read_open
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|void
modifier|*
name|client_data
parameter_list|,
name|archive_open_callback
modifier|*
name|client_opener
parameter_list|,
name|archive_read_callback
modifier|*
name|client_reader
parameter_list|,
name|archive_close_callback
modifier|*
name|client_closer
parameter_list|)
block|{
comment|/* Old archive_read_open() is just a thin shell around 	 * archive_read_open1. */
name|archive_read_set_open_callback
argument_list|(
name|a
argument_list|,
name|client_opener
argument_list|)
expr_stmt|;
name|archive_read_set_read_callback
argument_list|(
name|a
argument_list|,
name|client_reader
argument_list|)
expr_stmt|;
name|archive_read_set_close_callback
argument_list|(
name|a
argument_list|,
name|client_closer
argument_list|)
expr_stmt|;
name|archive_read_set_callback_data
argument_list|(
name|a
argument_list|,
name|client_data
argument_list|)
expr_stmt|;
return|return
name|archive_read_open1
argument_list|(
name|a
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|archive_read_open2
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|void
modifier|*
name|client_data
parameter_list|,
name|archive_open_callback
modifier|*
name|client_opener
parameter_list|,
name|archive_read_callback
modifier|*
name|client_reader
parameter_list|,
name|archive_skip_callback
modifier|*
name|client_skipper
parameter_list|,
name|archive_close_callback
modifier|*
name|client_closer
parameter_list|)
block|{
comment|/* Old archive_read_open2() is just a thin shell around 	 * archive_read_open1. */
name|archive_read_set_callback_data
argument_list|(
name|a
argument_list|,
name|client_data
argument_list|)
expr_stmt|;
name|archive_read_set_open_callback
argument_list|(
name|a
argument_list|,
name|client_opener
argument_list|)
expr_stmt|;
name|archive_read_set_read_callback
argument_list|(
name|a
argument_list|,
name|client_reader
argument_list|)
expr_stmt|;
name|archive_read_set_skip_callback
argument_list|(
name|a
argument_list|,
name|client_skipper
argument_list|)
expr_stmt|;
name|archive_read_set_close_callback
argument_list|(
name|a
argument_list|,
name|client_closer
argument_list|)
expr_stmt|;
return|return
name|archive_read_open1
argument_list|(
name|a
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|client_read_proxy
parameter_list|(
name|struct
name|archive_read_filter
modifier|*
name|self
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|)
block|{
name|ssize_t
name|r
decl_stmt|;
name|r
operator|=
call|(
name|self
operator|->
name|archive
operator|->
name|client
operator|.
name|reader
call|)
argument_list|(
operator|&
name|self
operator|->
name|archive
operator|->
name|archive
argument_list|,
name|self
operator|->
name|data
argument_list|,
name|buff
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int64_t
name|client_skip_proxy
parameter_list|(
name|struct
name|archive_read_filter
modifier|*
name|self
parameter_list|,
name|int64_t
name|request
parameter_list|)
block|{
if|if
condition|(
name|request
operator|<
literal|0
condition|)
name|__archive_errx
argument_list|(
literal|1
argument_list|,
literal|"Negative skip requested."
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|self
operator|->
name|archive
operator|->
name|client
operator|.
name|skipper
operator|!=
name|NULL
condition|)
block|{
comment|/* Seek requests over 1GiB are broken down into 		 * multiple seeks.  This avoids overflows when the 		 * requests get passed through 32-bit arguments. */
name|int64_t
name|skip_limit
init|=
operator|(
name|int64_t
operator|)
literal|1
operator|<<
literal|30
decl_stmt|;
name|int64_t
name|total
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int64_t
name|get
decl_stmt|,
name|ask
init|=
name|request
decl_stmt|;
if|if
condition|(
name|ask
operator|>
name|skip_limit
condition|)
name|ask
operator|=
name|skip_limit
expr_stmt|;
name|get
operator|=
call|(
name|self
operator|->
name|archive
operator|->
name|client
operator|.
name|skipper
call|)
argument_list|(
operator|&
name|self
operator|->
name|archive
operator|->
name|archive
argument_list|,
name|self
operator|->
name|data
argument_list|,
name|ask
argument_list|)
expr_stmt|;
name|total
operator|+=
name|get
expr_stmt|;
if|if
condition|(
name|get
operator|==
literal|0
operator|||
name|get
operator|==
name|request
condition|)
return|return
operator|(
name|total
operator|)
return|;
if|if
condition|(
name|get
operator|>
name|request
condition|)
return|return
name|ARCHIVE_FATAL
return|;
name|request
operator|-=
name|get
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|self
operator|->
name|archive
operator|->
name|client
operator|.
name|seeker
operator|!=
name|NULL
operator|&&
name|request
operator|>
literal|64
operator|*
literal|1024
condition|)
block|{
comment|/* If the client provided a seeker but not a skipper, 		 * we can use the seeker to skip forward. 		 * 		 * Note: This isn't always a good idea.  The client 		 * skipper is allowed to skip by less than requested 		 * if it needs to maintain block alignment.  The 		 * seeker is not allowed to play such games, so using 		 * the seeker here may be a performance loss compared 		 * to just reading and discarding.  That's why we 		 * only do this for skips of over 64k. 		 */
name|int64_t
name|before
init|=
name|self
operator|->
name|position
decl_stmt|;
name|int64_t
name|after
init|=
call|(
name|self
operator|->
name|archive
operator|->
name|client
operator|.
name|seeker
call|)
argument_list|(
operator|&
name|self
operator|->
name|archive
operator|->
name|archive
argument_list|,
name|self
operator|->
name|data
argument_list|,
name|request
argument_list|,
name|SEEK_CUR
argument_list|)
decl_stmt|;
if|if
condition|(
name|after
operator|!=
name|before
operator|+
name|request
condition|)
return|return
name|ARCHIVE_FATAL
return|;
return|return
name|after
operator|-
name|before
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int64_t
name|client_seek_proxy
parameter_list|(
name|struct
name|archive_read_filter
modifier|*
name|self
parameter_list|,
name|int64_t
name|offset
parameter_list|,
name|int
name|whence
parameter_list|)
block|{
comment|/* DO NOT use the skipper here!  If we transparently handled 	 * forward seek here by using the skipper, that will break 	 * other libarchive code that assumes a successful forward 	 * seek means it can also seek backwards. 	 */
if|if
condition|(
name|self
operator|->
name|archive
operator|->
name|client
operator|.
name|seeker
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|self
operator|->
name|archive
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Current client reader does not support seeking a device"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
return|return
call|(
name|self
operator|->
name|archive
operator|->
name|client
operator|.
name|seeker
call|)
argument_list|(
operator|&
name|self
operator|->
name|archive
operator|->
name|archive
argument_list|,
name|self
operator|->
name|data
argument_list|,
name|offset
argument_list|,
name|whence
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|client_close_proxy
parameter_list|(
name|struct
name|archive_read_filter
modifier|*
name|self
parameter_list|)
block|{
name|int
name|r
init|=
name|ARCHIVE_OK
decl_stmt|,
name|r2
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|self
operator|->
name|archive
operator|->
name|client
operator|.
name|closer
operator|==
name|NULL
condition|)
return|return
operator|(
name|r
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|self
operator|->
name|archive
operator|->
name|client
operator|.
name|nodes
condition|;
name|i
operator|++
control|)
block|{
name|r2
operator|=
call|(
name|self
operator|->
name|archive
operator|->
name|client
operator|.
name|closer
call|)
argument_list|(
operator|(
expr|struct
name|archive
operator|*
operator|)
name|self
operator|->
name|archive
argument_list|,
name|self
operator|->
name|archive
operator|->
name|client
operator|.
name|dataset
index|[
name|i
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>
name|r2
condition|)
name|r
operator|=
name|r2
expr_stmt|;
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|client_open_proxy
parameter_list|(
name|struct
name|archive_read_filter
modifier|*
name|self
parameter_list|)
block|{
name|int
name|r
init|=
name|ARCHIVE_OK
decl_stmt|;
if|if
condition|(
name|self
operator|->
name|archive
operator|->
name|client
operator|.
name|opener
operator|!=
name|NULL
condition|)
name|r
operator|=
call|(
name|self
operator|->
name|archive
operator|->
name|client
operator|.
name|opener
call|)
argument_list|(
operator|(
expr|struct
name|archive
operator|*
operator|)
name|self
operator|->
name|archive
argument_list|,
name|self
operator|->
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|client_switch_proxy
parameter_list|(
name|struct
name|archive_read_filter
modifier|*
name|self
parameter_list|,
name|unsigned
name|int
name|iindex
parameter_list|)
block|{
name|int
name|r1
init|=
name|ARCHIVE_OK
decl_stmt|,
name|r2
init|=
name|ARCHIVE_OK
decl_stmt|;
name|void
modifier|*
name|data2
init|=
name|NULL
decl_stmt|;
comment|/* Don't do anything if already in the specified data node */
if|if
condition|(
name|self
operator|->
name|archive
operator|->
name|client
operator|.
name|cursor
operator|==
name|iindex
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
name|self
operator|->
name|archive
operator|->
name|client
operator|.
name|cursor
operator|=
name|iindex
expr_stmt|;
name|data2
operator|=
name|self
operator|->
name|archive
operator|->
name|client
operator|.
name|dataset
index|[
name|self
operator|->
name|archive
operator|->
name|client
operator|.
name|cursor
index|]
operator|.
name|data
expr_stmt|;
if|if
condition|(
name|self
operator|->
name|archive
operator|->
name|client
operator|.
name|switcher
operator|!=
name|NULL
condition|)
block|{
name|r1
operator|=
name|r2
operator|=
call|(
name|self
operator|->
name|archive
operator|->
name|client
operator|.
name|switcher
call|)
argument_list|(
operator|(
expr|struct
name|archive
operator|*
operator|)
name|self
operator|->
name|archive
argument_list|,
name|self
operator|->
name|data
argument_list|,
name|data2
argument_list|)
expr_stmt|;
name|self
operator|->
name|data
operator|=
name|data2
expr_stmt|;
block|}
else|else
block|{
comment|/* Attempt to call close and open instead */
if|if
condition|(
name|self
operator|->
name|archive
operator|->
name|client
operator|.
name|closer
operator|!=
name|NULL
condition|)
name|r1
operator|=
call|(
name|self
operator|->
name|archive
operator|->
name|client
operator|.
name|closer
call|)
argument_list|(
operator|(
expr|struct
name|archive
operator|*
operator|)
name|self
operator|->
name|archive
argument_list|,
name|self
operator|->
name|data
argument_list|)
expr_stmt|;
name|self
operator|->
name|data
operator|=
name|data2
expr_stmt|;
if|if
condition|(
name|self
operator|->
name|archive
operator|->
name|client
operator|.
name|opener
operator|!=
name|NULL
condition|)
name|r2
operator|=
call|(
name|self
operator|->
name|archive
operator|->
name|client
operator|.
name|opener
call|)
argument_list|(
operator|(
expr|struct
name|archive
operator|*
operator|)
name|self
operator|->
name|archive
argument_list|,
name|self
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|r1
operator|<
name|r2
operator|)
condition|?
name|r1
else|:
name|r2
return|;
block|}
end_function

begin_function
name|int
name|archive_read_set_open_callback
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
name|archive_open_callback
modifier|*
name|client_opener
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_READ_MAGIC
argument_list|,
name|ARCHIVE_STATE_NEW
argument_list|,
literal|"archive_read_set_open_callback"
argument_list|)
expr_stmt|;
name|a
operator|->
name|client
operator|.
name|opener
operator|=
name|client_opener
expr_stmt|;
return|return
name|ARCHIVE_OK
return|;
block|}
end_function

begin_function
name|int
name|archive_read_set_read_callback
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
name|archive_read_callback
modifier|*
name|client_reader
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_READ_MAGIC
argument_list|,
name|ARCHIVE_STATE_NEW
argument_list|,
literal|"archive_read_set_read_callback"
argument_list|)
expr_stmt|;
name|a
operator|->
name|client
operator|.
name|reader
operator|=
name|client_reader
expr_stmt|;
return|return
name|ARCHIVE_OK
return|;
block|}
end_function

begin_function
name|int
name|archive_read_set_skip_callback
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
name|archive_skip_callback
modifier|*
name|client_skipper
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_READ_MAGIC
argument_list|,
name|ARCHIVE_STATE_NEW
argument_list|,
literal|"archive_read_set_skip_callback"
argument_list|)
expr_stmt|;
name|a
operator|->
name|client
operator|.
name|skipper
operator|=
name|client_skipper
expr_stmt|;
return|return
name|ARCHIVE_OK
return|;
block|}
end_function

begin_function
name|int
name|archive_read_set_seek_callback
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
name|archive_seek_callback
modifier|*
name|client_seeker
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_READ_MAGIC
argument_list|,
name|ARCHIVE_STATE_NEW
argument_list|,
literal|"archive_read_set_seek_callback"
argument_list|)
expr_stmt|;
name|a
operator|->
name|client
operator|.
name|seeker
operator|=
name|client_seeker
expr_stmt|;
return|return
name|ARCHIVE_OK
return|;
block|}
end_function

begin_function
name|int
name|archive_read_set_close_callback
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
name|archive_close_callback
modifier|*
name|client_closer
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_READ_MAGIC
argument_list|,
name|ARCHIVE_STATE_NEW
argument_list|,
literal|"archive_read_set_close_callback"
argument_list|)
expr_stmt|;
name|a
operator|->
name|client
operator|.
name|closer
operator|=
name|client_closer
expr_stmt|;
return|return
name|ARCHIVE_OK
return|;
block|}
end_function

begin_function
name|int
name|archive_read_set_switch_callback
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
name|archive_switch_callback
modifier|*
name|client_switcher
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_READ_MAGIC
argument_list|,
name|ARCHIVE_STATE_NEW
argument_list|,
literal|"archive_read_set_switch_callback"
argument_list|)
expr_stmt|;
name|a
operator|->
name|client
operator|.
name|switcher
operator|=
name|client_switcher
expr_stmt|;
return|return
name|ARCHIVE_OK
return|;
block|}
end_function

begin_function
name|int
name|archive_read_set_callback_data
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
name|void
modifier|*
name|client_data
parameter_list|)
block|{
return|return
name|archive_read_set_callback_data2
argument_list|(
name|_a
argument_list|,
name|client_data
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|archive_read_set_callback_data2
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
name|void
modifier|*
name|client_data
parameter_list|,
name|unsigned
name|int
name|iindex
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_READ_MAGIC
argument_list|,
name|ARCHIVE_STATE_NEW
argument_list|,
literal|"archive_read_set_callback_data2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|client
operator|.
name|nodes
operator|==
literal|0
condition|)
block|{
name|a
operator|->
name|client
operator|.
name|dataset
operator|=
operator|(
expr|struct
name|archive_read_data_node
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|a
operator|->
name|client
operator|.
name|dataset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|client
operator|.
name|dataset
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"No memory."
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_FATAL
return|;
block|}
name|a
operator|->
name|client
operator|.
name|nodes
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|iindex
operator|>
name|a
operator|->
name|client
operator|.
name|nodes
operator|-
literal|1
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|EINVAL
argument_list|,
literal|"Invalid index specified."
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_FATAL
return|;
block|}
name|a
operator|->
name|client
operator|.
name|dataset
index|[
name|iindex
index|]
operator|.
name|data
operator|=
name|client_data
expr_stmt|;
name|a
operator|->
name|client
operator|.
name|dataset
index|[
name|iindex
index|]
operator|.
name|begin_position
operator|=
operator|-
literal|1
expr_stmt|;
name|a
operator|->
name|client
operator|.
name|dataset
index|[
name|iindex
index|]
operator|.
name|total_size
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|ARCHIVE_OK
return|;
block|}
end_function

begin_function
name|int
name|archive_read_add_callback_data
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
name|void
modifier|*
name|client_data
parameter_list|,
name|unsigned
name|int
name|iindex
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_READ_MAGIC
argument_list|,
name|ARCHIVE_STATE_NEW
argument_list|,
literal|"archive_read_add_callback_data"
argument_list|)
expr_stmt|;
if|if
condition|(
name|iindex
operator|>
name|a
operator|->
name|client
operator|.
name|nodes
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|EINVAL
argument_list|,
literal|"Invalid index specified."
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_FATAL
return|;
block|}
name|p
operator|=
name|realloc
argument_list|(
name|a
operator|->
name|client
operator|.
name|dataset
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|a
operator|->
name|client
operator|.
name|dataset
argument_list|)
operator|*
operator|(
operator|++
operator|(
name|a
operator|->
name|client
operator|.
name|nodes
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"No memory."
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_FATAL
return|;
block|}
name|a
operator|->
name|client
operator|.
name|dataset
operator|=
operator|(
expr|struct
name|archive_read_data_node
operator|*
operator|)
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
name|a
operator|->
name|client
operator|.
name|nodes
operator|-
literal|1
init|;
name|i
operator|>
name|iindex
operator|&&
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|a
operator|->
name|client
operator|.
name|dataset
index|[
name|i
index|]
operator|.
name|data
operator|=
name|a
operator|->
name|client
operator|.
name|dataset
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|data
expr_stmt|;
name|a
operator|->
name|client
operator|.
name|dataset
index|[
name|i
index|]
operator|.
name|begin_position
operator|=
operator|-
literal|1
expr_stmt|;
name|a
operator|->
name|client
operator|.
name|dataset
index|[
name|i
index|]
operator|.
name|total_size
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|a
operator|->
name|client
operator|.
name|dataset
index|[
name|iindex
index|]
operator|.
name|data
operator|=
name|client_data
expr_stmt|;
name|a
operator|->
name|client
operator|.
name|dataset
index|[
name|iindex
index|]
operator|.
name|begin_position
operator|=
operator|-
literal|1
expr_stmt|;
name|a
operator|->
name|client
operator|.
name|dataset
index|[
name|iindex
index|]
operator|.
name|total_size
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|ARCHIVE_OK
return|;
block|}
end_function

begin_function
name|int
name|archive_read_append_callback_data
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
name|void
modifier|*
name|client_data
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
return|return
name|archive_read_add_callback_data
argument_list|(
name|_a
argument_list|,
name|client_data
argument_list|,
name|a
operator|->
name|client
operator|.
name|nodes
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|archive_read_prepend_callback_data
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
name|void
modifier|*
name|client_data
parameter_list|)
block|{
return|return
name|archive_read_add_callback_data
argument_list|(
name|_a
argument_list|,
name|client_data
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|archive_read_open1
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|struct
name|archive_read_filter
modifier|*
name|filter
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|int
name|slot
decl_stmt|,
name|e
init|=
name|ARCHIVE_OK
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_READ_MAGIC
argument_list|,
name|ARCHIVE_STATE_NEW
argument_list|,
literal|"archive_read_open"
argument_list|)
expr_stmt|;
name|archive_clear_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|client
operator|.
name|reader
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|EINVAL
argument_list|,
literal|"No reader function provided to archive_read_open"
argument_list|)
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|state
operator|=
name|ARCHIVE_STATE_FATAL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Open data source. */
if|if
condition|(
name|a
operator|->
name|client
operator|.
name|opener
operator|!=
name|NULL
condition|)
block|{
name|e
operator|=
call|(
name|a
operator|->
name|client
operator|.
name|opener
call|)
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|a
operator|->
name|client
operator|.
name|dataset
index|[
literal|0
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|!=
literal|0
condition|)
block|{
comment|/* If the open failed, call the closer to clean up. */
if|if
condition|(
name|a
operator|->
name|client
operator|.
name|closer
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|a
operator|->
name|client
operator|.
name|nodes
condition|;
name|i
operator|++
control|)
call|(
name|a
operator|->
name|client
operator|.
name|closer
call|)
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|a
operator|->
name|client
operator|.
name|dataset
index|[
name|i
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|e
operator|)
return|;
block|}
block|}
name|filter
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|filter
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|filter
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|filter
operator|->
name|bidder
operator|=
name|NULL
expr_stmt|;
name|filter
operator|->
name|upstream
operator|=
name|NULL
expr_stmt|;
name|filter
operator|->
name|archive
operator|=
name|a
expr_stmt|;
name|filter
operator|->
name|data
operator|=
name|a
operator|->
name|client
operator|.
name|dataset
index|[
literal|0
index|]
operator|.
name|data
expr_stmt|;
name|filter
operator|->
name|open
operator|=
name|client_open_proxy
expr_stmt|;
name|filter
operator|->
name|read
operator|=
name|client_read_proxy
expr_stmt|;
name|filter
operator|->
name|skip
operator|=
name|client_skip_proxy
expr_stmt|;
name|filter
operator|->
name|seek
operator|=
name|client_seek_proxy
expr_stmt|;
name|filter
operator|->
name|close
operator|=
name|client_close_proxy
expr_stmt|;
name|filter
operator|->
name|sswitch
operator|=
name|client_switch_proxy
expr_stmt|;
name|filter
operator|->
name|name
operator|=
literal|"none"
expr_stmt|;
name|filter
operator|->
name|code
operator|=
name|ARCHIVE_FILTER_NONE
expr_stmt|;
name|a
operator|->
name|client
operator|.
name|dataset
index|[
literal|0
index|]
operator|.
name|begin_position
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|a
operator|->
name|filter
operator|||
operator|!
name|a
operator|->
name|bypass_filter_bidding
condition|)
block|{
name|a
operator|->
name|filter
operator|=
name|filter
expr_stmt|;
comment|/* Build out the input pipeline. */
name|e
operator|=
name|choose_filters
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|<
name|ARCHIVE_WARN
condition|)
block|{
name|a
operator|->
name|archive
operator|.
name|state
operator|=
name|ARCHIVE_STATE_FATAL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* Need to add "NONE" type filter at the end of the filter chain */
name|tmp
operator|=
name|a
operator|->
name|filter
expr_stmt|;
while|while
condition|(
name|tmp
operator|->
name|upstream
condition|)
name|tmp
operator|=
name|tmp
operator|->
name|upstream
expr_stmt|;
name|tmp
operator|->
name|upstream
operator|=
name|filter
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|a
operator|->
name|format
condition|)
block|{
name|slot
operator|=
name|choose_format
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|<
literal|0
condition|)
block|{
name|__archive_read_close_filters
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|state
operator|=
name|ARCHIVE_STATE_FATAL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|a
operator|->
name|format
operator|=
operator|&
operator|(
name|a
operator|->
name|formats
index|[
name|slot
index|]
operator|)
expr_stmt|;
block|}
name|a
operator|->
name|archive
operator|.
name|state
operator|=
name|ARCHIVE_STATE_HEADER
expr_stmt|;
comment|/* Ensure libarchive starts from the first node in a multivolume set */
name|client_switch_proxy
argument_list|(
name|a
operator|->
name|filter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allow each registered stream transform to bid on whether  * it wants to handle this stream.  Repeat until we've finished  * building the pipeline.  */
end_comment

begin_comment
comment|/* We won't build a filter pipeline with more stages than this. */
end_comment

begin_define
define|#
directive|define
name|MAX_NUMBER_FILTERS
value|25
end_define

begin_function
specifier|static
name|int
name|choose_filters
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|int
name|number_bidders
decl_stmt|,
name|i
decl_stmt|,
name|bid
decl_stmt|,
name|best_bid
decl_stmt|,
name|number_filters
decl_stmt|;
name|struct
name|archive_read_filter_bidder
modifier|*
name|bidder
decl_stmt|,
modifier|*
name|best_bidder
decl_stmt|;
name|struct
name|archive_read_filter
modifier|*
name|filter
decl_stmt|;
name|ssize_t
name|avail
decl_stmt|;
name|int
name|r
decl_stmt|;
for|for
control|(
name|number_filters
operator|=
literal|0
init|;
name|number_filters
operator|<
name|MAX_NUMBER_FILTERS
condition|;
operator|++
name|number_filters
control|)
block|{
name|number_bidders
operator|=
sizeof|sizeof
argument_list|(
name|a
operator|->
name|bidders
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|a
operator|->
name|bidders
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|best_bid
operator|=
literal|0
expr_stmt|;
name|best_bidder
operator|=
name|NULL
expr_stmt|;
name|bidder
operator|=
name|a
operator|->
name|bidders
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_bidders
condition|;
name|i
operator|++
operator|,
name|bidder
operator|++
control|)
block|{
if|if
condition|(
name|bidder
operator|->
name|bid
operator|!=
name|NULL
condition|)
block|{
name|bid
operator|=
call|(
name|bidder
operator|->
name|bid
call|)
argument_list|(
name|bidder
argument_list|,
name|a
operator|->
name|filter
argument_list|)
expr_stmt|;
if|if
condition|(
name|bid
operator|>
name|best_bid
condition|)
block|{
name|best_bid
operator|=
name|bid
expr_stmt|;
name|best_bidder
operator|=
name|bidder
expr_stmt|;
block|}
block|}
block|}
comment|/* If no bidder, we're done. */
if|if
condition|(
name|best_bidder
operator|==
name|NULL
condition|)
block|{
comment|/* Verify the filter by asking it for some data. */
name|__archive_read_filter_ahead
argument_list|(
name|a
operator|->
name|filter
argument_list|,
literal|1
argument_list|,
operator|&
name|avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|avail
operator|<
literal|0
condition|)
block|{
name|__archive_read_close_filters
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|__archive_read_free_filters
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|a
operator|->
name|archive
operator|.
name|compression_name
operator|=
name|a
operator|->
name|filter
operator|->
name|name
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|compression_code
operator|=
name|a
operator|->
name|filter
operator|->
name|code
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
name|filter
operator|=
operator|(
expr|struct
name|archive_read_filter
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|filter
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|filter
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|filter
operator|->
name|bidder
operator|=
name|best_bidder
expr_stmt|;
name|filter
operator|->
name|archive
operator|=
name|a
expr_stmt|;
name|filter
operator|->
name|upstream
operator|=
name|a
operator|->
name|filter
expr_stmt|;
name|a
operator|->
name|filter
operator|=
name|filter
expr_stmt|;
name|r
operator|=
call|(
name|best_bidder
operator|->
name|init
call|)
argument_list|(
name|a
operator|->
name|filter
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|__archive_read_close_filters
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|__archive_read_free_filters
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Input requires too many filters for decoding"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read header of next entry.  */
end_comment

begin_function
specifier|static
name|int
name|_archive_read_next_header2
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|int
name|r1
init|=
name|ARCHIVE_OK
decl_stmt|,
name|r2
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_READ_MAGIC
argument_list|,
name|ARCHIVE_STATE_HEADER
operator||
name|ARCHIVE_STATE_DATA
argument_list|,
literal|"archive_read_next_header"
argument_list|)
expr_stmt|;
name|archive_entry_clear
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|archive_clear_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|)
expr_stmt|;
comment|/* 	 * If client didn't consume entire data, skip any remainder 	 * (This is especially important for GNU incremental directories.) 	 */
if|if
condition|(
name|a
operator|->
name|archive
operator|.
name|state
operator|==
name|ARCHIVE_STATE_DATA
condition|)
block|{
name|r1
operator|=
name|archive_read_data_skip
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|)
expr_stmt|;
if|if
condition|(
name|r1
operator|==
name|ARCHIVE_EOF
condition|)
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|EIO
argument_list|,
literal|"Premature end-of-file."
argument_list|)
expr_stmt|;
if|if
condition|(
name|r1
operator|==
name|ARCHIVE_EOF
operator|||
name|r1
operator|==
name|ARCHIVE_FATAL
condition|)
block|{
name|a
operator|->
name|archive
operator|.
name|state
operator|=
name|ARCHIVE_STATE_FATAL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
comment|/* Record start-of-header offset in uncompressed stream. */
name|a
operator|->
name|header_position
operator|=
name|a
operator|->
name|filter
operator|->
name|position
expr_stmt|;
operator|++
name|_a
operator|->
name|file_count
expr_stmt|;
name|r2
operator|=
call|(
name|a
operator|->
name|format
operator|->
name|read_header
call|)
argument_list|(
name|a
argument_list|,
name|entry
argument_list|)
expr_stmt|;
comment|/* 	 * EOF and FATAL are persistent at this layer.  By 	 * modifying the state, we guarantee that future calls to 	 * read a header or read data will fail. 	 */
switch|switch
condition|(
name|r2
condition|)
block|{
case|case
name|ARCHIVE_EOF
case|:
name|a
operator|->
name|archive
operator|.
name|state
operator|=
name|ARCHIVE_STATE_EOF
expr_stmt|;
operator|--
name|_a
operator|->
name|file_count
expr_stmt|;
comment|/* Revert a file counter. */
break|break;
case|case
name|ARCHIVE_OK
case|:
name|a
operator|->
name|archive
operator|.
name|state
operator|=
name|ARCHIVE_STATE_DATA
expr_stmt|;
break|break;
case|case
name|ARCHIVE_WARN
case|:
name|a
operator|->
name|archive
operator|.
name|state
operator|=
name|ARCHIVE_STATE_DATA
expr_stmt|;
break|break;
case|case
name|ARCHIVE_RETRY
case|:
break|break;
case|case
name|ARCHIVE_FATAL
case|:
name|a
operator|->
name|archive
operator|.
name|state
operator|=
name|ARCHIVE_STATE_FATAL
expr_stmt|;
break|break;
block|}
name|__archive_reset_read_data
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|)
expr_stmt|;
name|a
operator|->
name|data_start_node
operator|=
name|a
operator|->
name|client
operator|.
name|cursor
expr_stmt|;
comment|/* EOF always wins; otherwise return the worst error. */
return|return
operator|(
name|r2
operator|<
name|r1
operator|||
name|r2
operator|==
name|ARCHIVE_EOF
operator|)
condition|?
name|r2
else|:
name|r1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_archive_read_next_header
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
name|struct
name|archive_entry
modifier|*
modifier|*
name|entryp
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
operator|*
name|entryp
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|_archive_read_next_header2
argument_list|(
name|_a
argument_list|,
name|a
operator|->
name|entry
argument_list|)
expr_stmt|;
operator|*
name|entryp
operator|=
name|a
operator|->
name|entry
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Allow each registered format to bid on whether it wants to handle  * the next entry.  Return index of winning bidder.  */
end_comment

begin_function
specifier|static
name|int
name|choose_format
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|int
name|slots
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|bid
decl_stmt|,
name|best_bid
decl_stmt|;
name|int
name|best_bid_slot
decl_stmt|;
name|slots
operator|=
sizeof|sizeof
argument_list|(
name|a
operator|->
name|formats
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|a
operator|->
name|formats
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|best_bid
operator|=
operator|-
literal|1
expr_stmt|;
name|best_bid_slot
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Set up a->format for convenience of bidders. */
name|a
operator|->
name|format
operator|=
operator|&
operator|(
name|a
operator|->
name|formats
index|[
literal|0
index|]
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|slots
condition|;
name|i
operator|++
operator|,
name|a
operator|->
name|format
operator|++
control|)
block|{
if|if
condition|(
name|a
operator|->
name|format
operator|->
name|bid
condition|)
block|{
name|bid
operator|=
call|(
name|a
operator|->
name|format
operator|->
name|bid
call|)
argument_list|(
name|a
argument_list|,
name|best_bid
argument_list|)
expr_stmt|;
if|if
condition|(
name|bid
operator|==
name|ARCHIVE_FATAL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|filter
operator|->
name|position
operator|!=
literal|0
condition|)
name|__archive_read_seek
argument_list|(
name|a
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bid
operator|>
name|best_bid
operator|)
operator|||
operator|(
name|best_bid_slot
operator|<
literal|0
operator|)
condition|)
block|{
name|best_bid
operator|=
name|bid
expr_stmt|;
name|best_bid_slot
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * There were no bidders; this is a serious programmer error 	 * and demands a quick and definitive abort. 	 */
if|if
condition|(
name|best_bid_slot
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"No formats registered"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* 	 * There were bidders, but no non-zero bids; this means we 	 * can't support this stream. 	 */
if|if
condition|(
name|best_bid
operator|<
literal|1
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Unrecognized archive format"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
return|return
operator|(
name|best_bid_slot
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the file offset (within the uncompressed data stream) where  * the last header started.  */
end_comment

begin_function
name|int64_t
name|archive_read_header_position
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_READ_MAGIC
argument_list|,
name|ARCHIVE_STATE_ANY
argument_list|,
literal|"archive_read_header_position"
argument_list|)
expr_stmt|;
return|return
operator|(
name|a
operator|->
name|header_position
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns 1 if the archive contains at least one encrypted entry.  * If the archive format not support encryption at all  * ARCHIVE_READ_FORMAT_ENCRYPTION_UNSUPPORTED is returned.  * If for any other reason (e.g. not enough data read so far)  * we cannot say whether there are encrypted entries, then  * ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW is returned.  * In general, this function will return values below zero when the  * reader is uncertain or totally uncapable of encryption support.  * When this function returns 0 you can be sure that the reader  * supports encryption detection but no encrypted entries have  * been found yet.  *  * NOTE: If the metadata/header of an archive is also encrypted, you  * cannot rely on the number of encrypted entries. That is why this  * function does not return the number of encrypted entries but#  * just shows that there are some.  */
end_comment

begin_function
name|int
name|archive_read_has_encrypted_entries
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|int
name|format_supports_encryption
init|=
name|archive_read_format_capabilities
argument_list|(
name|_a
argument_list|)
operator|&
operator|(
name|ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_DATA
operator||
name|ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_METADATA
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|_a
operator|||
operator|!
name|format_supports_encryption
condition|)
block|{
comment|/* Format in general doesn't support encryption */
return|return
name|ARCHIVE_READ_FORMAT_ENCRYPTION_UNSUPPORTED
return|;
block|}
comment|/* A reader potentially has read enough data now. */
if|if
condition|(
name|a
operator|->
name|format
operator|&&
name|a
operator|->
name|format
operator|->
name|has_encrypted_entries
condition|)
block|{
return|return
call|(
name|a
operator|->
name|format
operator|->
name|has_encrypted_entries
call|)
argument_list|(
name|a
argument_list|)
return|;
block|}
comment|/* For any other reason we cannot say how many entries are there. */
return|return
name|ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW
return|;
block|}
end_function

begin_comment
comment|/*  * Returns a bitmask of capabilities that are supported by the archive format reader.  * If the reader has no special capabilities, ARCHIVE_READ_FORMAT_CAPS_NONE is returned.  */
end_comment

begin_function
name|int
name|archive_read_format_capabilities
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
if|if
condition|(
name|a
operator|&&
name|a
operator|->
name|format
operator|&&
name|a
operator|->
name|format
operator|->
name|format_capabilties
condition|)
block|{
return|return
call|(
name|a
operator|->
name|format
operator|->
name|format_capabilties
call|)
argument_list|(
name|a
argument_list|)
return|;
block|}
return|return
name|ARCHIVE_READ_FORMAT_CAPS_NONE
return|;
block|}
end_function

begin_comment
comment|/*  * Read data from an archive entry, using a read(2)-style interface.  * This is a convenience routine that just calls  * archive_read_data_block and copies the results into the client  * buffer, filling any gaps with zero bytes.  Clients using this  * API can be completely ignorant of sparse-file issues; sparse files  * will simply be padded with nulls.  *  * DO NOT intermingle calls to this function and archive_read_data_block  * to read a single entry body.  */
end_comment

begin_function
name|ssize_t
name|archive_read_data
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
name|struct
name|archive
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive
operator|*
operator|)
name|_a
decl_stmt|;
name|char
modifier|*
name|dest
decl_stmt|;
specifier|const
name|void
modifier|*
name|read_buf
decl_stmt|;
name|size_t
name|bytes_read
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|r
decl_stmt|;
name|bytes_read
operator|=
literal|0
expr_stmt|;
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
name|buff
expr_stmt|;
while|while
condition|(
name|s
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|read_data_remaining
operator|==
literal|0
condition|)
block|{
name|read_buf
operator|=
name|a
operator|->
name|read_data_block
expr_stmt|;
name|a
operator|->
name|read_data_is_posix_read
operator|=
literal|1
expr_stmt|;
name|a
operator|->
name|read_data_requested
operator|=
name|s
expr_stmt|;
name|r
operator|=
name|archive_read_data_block
argument_list|(
name|a
argument_list|,
operator|&
name|read_buf
argument_list|,
operator|&
name|a
operator|->
name|read_data_remaining
argument_list|,
operator|&
name|a
operator|->
name|read_data_offset
argument_list|)
expr_stmt|;
name|a
operator|->
name|read_data_block
operator|=
name|read_buf
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_EOF
condition|)
return|return
operator|(
name|bytes_read
operator|)
return|;
comment|/* 			 * Error codes are all negative, so the status 			 * return here cannot be confused with a valid 			 * byte count.  (ARCHIVE_OK is zero.) 			 */
if|if
condition|(
name|r
operator|<
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
if|if
condition|(
name|a
operator|->
name|read_data_offset
operator|<
name|a
operator|->
name|read_data_output_offset
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Encountered out-of-order sparse blocks"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_RETRY
operator|)
return|;
block|}
comment|/* Compute the amount of zero padding needed. */
if|if
condition|(
name|a
operator|->
name|read_data_output_offset
operator|+
operator|(
name|int64_t
operator|)
name|s
operator|<
name|a
operator|->
name|read_data_offset
condition|)
block|{
name|len
operator|=
name|s
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|->
name|read_data_output_offset
operator|<
name|a
operator|->
name|read_data_offset
condition|)
block|{
name|len
operator|=
call|(
name|size_t
call|)
argument_list|(
name|a
operator|->
name|read_data_offset
operator|-
name|a
operator|->
name|read_data_output_offset
argument_list|)
expr_stmt|;
block|}
else|else
name|len
operator|=
literal|0
expr_stmt|;
comment|/* Add zeroes. */
name|memset
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
operator|-=
name|len
expr_stmt|;
name|a
operator|->
name|read_data_output_offset
operator|+=
name|len
expr_stmt|;
name|dest
operator|+=
name|len
expr_stmt|;
name|bytes_read
operator|+=
name|len
expr_stmt|;
comment|/* Copy data if there is any space left. */
if|if
condition|(
name|s
operator|>
literal|0
condition|)
block|{
name|len
operator|=
name|a
operator|->
name|read_data_remaining
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|s
condition|)
name|len
operator|=
name|s
expr_stmt|;
name|memcpy
argument_list|(
name|dest
argument_list|,
name|a
operator|->
name|read_data_block
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
operator|-=
name|len
expr_stmt|;
name|a
operator|->
name|read_data_block
operator|+=
name|len
expr_stmt|;
name|a
operator|->
name|read_data_remaining
operator|-=
name|len
expr_stmt|;
name|a
operator|->
name|read_data_output_offset
operator|+=
name|len
expr_stmt|;
name|a
operator|->
name|read_data_offset
operator|+=
name|len
expr_stmt|;
name|dest
operator|+=
name|len
expr_stmt|;
name|bytes_read
operator|+=
name|len
expr_stmt|;
block|}
block|}
name|a
operator|->
name|read_data_is_posix_read
operator|=
literal|0
expr_stmt|;
name|a
operator|->
name|read_data_requested
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|bytes_read
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reset the read_data_* variables, used for starting a new entry.  */
end_comment

begin_function
name|void
name|__archive_reset_read_data
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|)
block|{
name|a
operator|->
name|read_data_output_offset
operator|=
literal|0
expr_stmt|;
name|a
operator|->
name|read_data_remaining
operator|=
literal|0
expr_stmt|;
name|a
operator|->
name|read_data_is_posix_read
operator|=
literal|0
expr_stmt|;
name|a
operator|->
name|read_data_requested
operator|=
literal|0
expr_stmt|;
comment|/* extra resets, from rar.c */
name|a
operator|->
name|read_data_block
operator|=
name|NULL
expr_stmt|;
name|a
operator|->
name|read_data_offset
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Skip over all remaining data in this entry.  */
end_comment

begin_function
name|int
name|archive_read_data_skip
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|int
name|r
decl_stmt|;
specifier|const
name|void
modifier|*
name|buff
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int64_t
name|offset
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_READ_MAGIC
argument_list|,
name|ARCHIVE_STATE_DATA
argument_list|,
literal|"archive_read_data_skip"
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|format
operator|->
name|read_data_skip
operator|!=
name|NULL
condition|)
name|r
operator|=
call|(
name|a
operator|->
name|format
operator|->
name|read_data_skip
call|)
argument_list|(
name|a
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
operator|(
name|r
operator|=
name|archive_read_data_block
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
operator|&
name|buff
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|offset
argument_list|)
operator|)
operator|==
name|ARCHIVE_OK
condition|)
empty_stmt|;
block|}
if|if
condition|(
name|r
operator|==
name|ARCHIVE_EOF
condition|)
name|r
operator|=
name|ARCHIVE_OK
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|state
operator|=
name|ARCHIVE_STATE_HEADER
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
name|int64_t
name|archive_seek_data
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
name|int64_t
name|offset
parameter_list|,
name|int
name|whence
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_READ_MAGIC
argument_list|,
name|ARCHIVE_STATE_DATA
argument_list|,
literal|"archive_seek_data_block"
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|format
operator|->
name|seek_data
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_PROGRAMMER
argument_list|,
literal|"Internal error: "
literal|"No format_seek_data_block function registered"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
return|return
call|(
name|a
operator|->
name|format
operator|->
name|seek_data
call|)
argument_list|(
name|a
argument_list|,
name|offset
argument_list|,
name|whence
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read the next block of entry data from the archive.  * This is a zero-copy interface; the client receives a pointer,  * size, and file offset of the next available block of data.  *  * Returns ARCHIVE_OK if the operation is successful, ARCHIVE_EOF if  * the end of entry is encountered.  */
end_comment

begin_function
specifier|static
name|int
name|_archive_read_data_block
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|int64_t
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_READ_MAGIC
argument_list|,
name|ARCHIVE_STATE_DATA
argument_list|,
literal|"archive_read_data_block"
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|format
operator|->
name|read_data
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_PROGRAMMER
argument_list|,
literal|"Internal error: "
literal|"No format->read_data function registered"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
return|return
call|(
name|a
operator|->
name|format
operator|->
name|read_data
call|)
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|size
argument_list|,
name|offset
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|__archive_read_close_filters
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|archive_read_filter
modifier|*
name|f
init|=
name|a
operator|->
name|filter
decl_stmt|;
name|int
name|r
init|=
name|ARCHIVE_OK
decl_stmt|;
comment|/* Close each filter in the pipeline. */
while|while
condition|(
name|f
operator|!=
name|NULL
condition|)
block|{
name|struct
name|archive_read_filter
modifier|*
name|t
init|=
name|f
operator|->
name|upstream
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|->
name|closed
operator|&&
name|f
operator|->
name|close
operator|!=
name|NULL
condition|)
block|{
name|int
name|r1
init|=
call|(
name|f
operator|->
name|close
call|)
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|f
operator|->
name|closed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|r1
operator|<
name|r
condition|)
name|r
operator|=
name|r1
expr_stmt|;
block|}
name|free
argument_list|(
name|f
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|f
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
name|f
operator|=
name|t
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
name|void
name|__archive_read_free_filters
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
while|while
condition|(
name|a
operator|->
name|filter
operator|!=
name|NULL
condition|)
block|{
name|struct
name|archive_read_filter
modifier|*
name|t
init|=
name|a
operator|->
name|filter
operator|->
name|upstream
decl_stmt|;
name|free
argument_list|(
name|a
operator|->
name|filter
argument_list|)
expr_stmt|;
name|a
operator|->
name|filter
operator|=
name|t
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * return the count of # of filters in use  */
end_comment

begin_function
specifier|static
name|int
name|_archive_filter_count
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|struct
name|archive_read_filter
modifier|*
name|p
init|=
name|a
operator|->
name|filter
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|upstream
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/*  * Close the file and all I/O.  */
end_comment

begin_function
specifier|static
name|int
name|_archive_read_close
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|int
name|r
init|=
name|ARCHIVE_OK
decl_stmt|,
name|r1
init|=
name|ARCHIVE_OK
decl_stmt|;
name|archive_check_magic
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_READ_MAGIC
argument_list|,
name|ARCHIVE_STATE_ANY
operator||
name|ARCHIVE_STATE_FATAL
argument_list|,
literal|"archive_read_close"
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|archive
operator|.
name|state
operator|==
name|ARCHIVE_STATE_CLOSED
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
name|archive_clear_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|)
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|state
operator|=
name|ARCHIVE_STATE_CLOSED
expr_stmt|;
comment|/* TODO: Clean up the formatters. */
comment|/* Release the filter objects. */
name|r1
operator|=
name|__archive_read_close_filters
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|r1
operator|<
name|r
condition|)
name|r
operator|=
name|r1
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release memory and other resources.  */
end_comment

begin_function
specifier|static
name|int
name|_archive_read_free
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|struct
name|archive_read_passphrase
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|int
name|slots
decl_stmt|;
name|int
name|r
init|=
name|ARCHIVE_OK
decl_stmt|;
if|if
condition|(
name|_a
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_READ_MAGIC
argument_list|,
name|ARCHIVE_STATE_ANY
operator||
name|ARCHIVE_STATE_FATAL
argument_list|,
literal|"archive_read_free"
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|archive
operator|.
name|state
operator|!=
name|ARCHIVE_STATE_CLOSED
operator|&&
name|a
operator|->
name|archive
operator|.
name|state
operator|!=
name|ARCHIVE_STATE_FATAL
condition|)
name|r
operator|=
name|archive_read_close
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|)
expr_stmt|;
comment|/* Call cleanup functions registered by optional components. */
if|if
condition|(
name|a
operator|->
name|cleanup_archive_extract
operator|!=
name|NULL
condition|)
name|r
operator|=
call|(
name|a
operator|->
name|cleanup_archive_extract
call|)
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|/* Cleanup format-specific data. */
name|slots
operator|=
sizeof|sizeof
argument_list|(
name|a
operator|->
name|formats
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|a
operator|->
name|formats
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|slots
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|->
name|format
operator|=
operator|&
operator|(
name|a
operator|->
name|formats
index|[
name|i
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|formats
index|[
name|i
index|]
operator|.
name|cleanup
condition|)
operator|(
name|a
operator|->
name|formats
index|[
name|i
index|]
operator|.
name|cleanup
operator|)
operator|(
name|a
operator|)
expr_stmt|;
block|}
comment|/* Free the filters */
name|__archive_read_free_filters
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|/* Release the bidder objects. */
name|n
operator|=
sizeof|sizeof
argument_list|(
name|a
operator|->
name|bidders
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|a
operator|->
name|bidders
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|a
operator|->
name|bidders
index|[
name|i
index|]
operator|.
name|free
operator|!=
name|NULL
condition|)
block|{
name|int
name|r1
init|=
operator|(
name|a
operator|->
name|bidders
index|[
name|i
index|]
operator|.
name|free
operator|)
operator|(
operator|&
name|a
operator|->
name|bidders
index|[
name|i
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|r1
operator|<
name|r
condition|)
name|r
operator|=
name|r1
expr_stmt|;
block|}
block|}
comment|/* Release passphrase list. */
name|p
operator|=
name|a
operator|->
name|passphrases
operator|.
name|first
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|struct
name|archive_read_passphrase
modifier|*
name|np
init|=
name|p
operator|->
name|next
decl_stmt|;
comment|/* A passphrase should be cleaned. */
name|memset
argument_list|(
name|p
operator|->
name|passphrase
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|p
operator|->
name|passphrase
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|passphrase
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|np
expr_stmt|;
block|}
name|archive_string_free
argument_list|(
operator|&
name|a
operator|->
name|archive
operator|.
name|error_string
argument_list|)
expr_stmt|;
name|archive_entry_free
argument_list|(
name|a
operator|->
name|entry
argument_list|)
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|magic
operator|=
literal|0
expr_stmt|;
name|__archive_clean
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|a
operator|->
name|client
operator|.
name|dataset
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|archive_read_filter
modifier|*
name|get_filter
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|struct
name|archive_read_filter
modifier|*
name|f
init|=
name|a
operator|->
name|filter
decl_stmt|;
comment|/* We use n == -1 for 'the last filter', which is always the 	 * client proxy. */
if|if
condition|(
name|n
operator|==
operator|-
literal|1
operator|&&
name|f
operator|!=
name|NULL
condition|)
block|{
name|struct
name|archive_read_filter
modifier|*
name|last
init|=
name|f
decl_stmt|;
name|f
operator|=
name|f
operator|->
name|upstream
expr_stmt|;
while|while
condition|(
name|f
operator|!=
name|NULL
condition|)
block|{
name|last
operator|=
name|f
expr_stmt|;
name|f
operator|=
name|f
operator|->
name|upstream
expr_stmt|;
block|}
return|return
operator|(
name|last
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
while|while
condition|(
name|n
operator|>
literal|0
operator|&&
name|f
operator|!=
name|NULL
condition|)
block|{
name|f
operator|=
name|f
operator|->
name|upstream
expr_stmt|;
operator|--
name|n
expr_stmt|;
block|}
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_archive_filter_code
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|struct
name|archive_read_filter
modifier|*
name|f
init|=
name|get_filter
argument_list|(
name|_a
argument_list|,
name|n
argument_list|)
decl_stmt|;
return|return
name|f
operator|==
name|NULL
condition|?
operator|-
literal|1
else|:
name|f
operator|->
name|code
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|_archive_filter_name
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|struct
name|archive_read_filter
modifier|*
name|f
init|=
name|get_filter
argument_list|(
name|_a
argument_list|,
name|n
argument_list|)
decl_stmt|;
return|return
name|f
operator|!=
name|NULL
condition|?
name|f
operator|->
name|name
else|:
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int64_t
name|_archive_filter_bytes
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|struct
name|archive_read_filter
modifier|*
name|f
init|=
name|get_filter
argument_list|(
name|_a
argument_list|,
name|n
argument_list|)
decl_stmt|;
return|return
name|f
operator|==
name|NULL
condition|?
operator|-
literal|1
else|:
name|f
operator|->
name|position
return|;
block|}
end_function

begin_comment
comment|/*  * Used internally by read format handlers to register their bid and  * initialization functions.  */
end_comment

begin_function
name|int
name|__archive_read_register_format
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|void
modifier|*
name|format_data
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
function_decl|(
modifier|*
name|bid
function_decl|)
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|,
name|int
function_decl|(
modifier|*
name|options
function_decl|)
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
parameter_list|,
name|int
function_decl|(
modifier|*
name|read_header
function_decl|)
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
parameter_list|,
name|int
function_decl|(
modifier|*
name|read_data
function_decl|)
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|int64_t
modifier|*
parameter_list|)
parameter_list|,
name|int
function_decl|(
modifier|*
name|read_data_skip
function_decl|)
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
parameter_list|,
name|int64_t
function_decl|(
modifier|*
name|seek_data
function_decl|)
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|int64_t
parameter_list|,
name|int
parameter_list|)
parameter_list|,
name|int
function_decl|(
modifier|*
name|cleanup
function_decl|)
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
parameter_list|,
name|int
function_decl|(
modifier|*
name|format_capabilities
function_decl|)
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
parameter_list|,
name|int
function_decl|(
modifier|*
name|has_encrypted_entries
function_decl|)
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|number_slots
decl_stmt|;
name|archive_check_magic
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_READ_MAGIC
argument_list|,
name|ARCHIVE_STATE_NEW
argument_list|,
literal|"__archive_read_register_format"
argument_list|)
expr_stmt|;
name|number_slots
operator|=
sizeof|sizeof
argument_list|(
name|a
operator|->
name|formats
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|a
operator|->
name|formats
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_slots
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|a
operator|->
name|formats
index|[
name|i
index|]
operator|.
name|bid
operator|==
name|bid
condition|)
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
comment|/* We've already installed */
if|if
condition|(
name|a
operator|->
name|formats
index|[
name|i
index|]
operator|.
name|bid
operator|==
name|NULL
condition|)
block|{
name|a
operator|->
name|formats
index|[
name|i
index|]
operator|.
name|bid
operator|=
name|bid
expr_stmt|;
name|a
operator|->
name|formats
index|[
name|i
index|]
operator|.
name|options
operator|=
name|options
expr_stmt|;
name|a
operator|->
name|formats
index|[
name|i
index|]
operator|.
name|read_header
operator|=
name|read_header
expr_stmt|;
name|a
operator|->
name|formats
index|[
name|i
index|]
operator|.
name|read_data
operator|=
name|read_data
expr_stmt|;
name|a
operator|->
name|formats
index|[
name|i
index|]
operator|.
name|read_data_skip
operator|=
name|read_data_skip
expr_stmt|;
name|a
operator|->
name|formats
index|[
name|i
index|]
operator|.
name|seek_data
operator|=
name|seek_data
expr_stmt|;
name|a
operator|->
name|formats
index|[
name|i
index|]
operator|.
name|cleanup
operator|=
name|cleanup
expr_stmt|;
name|a
operator|->
name|formats
index|[
name|i
index|]
operator|.
name|data
operator|=
name|format_data
expr_stmt|;
name|a
operator|->
name|formats
index|[
name|i
index|]
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|a
operator|->
name|formats
index|[
name|i
index|]
operator|.
name|format_capabilties
operator|=
name|format_capabilities
expr_stmt|;
name|a
operator|->
name|formats
index|[
name|i
index|]
operator|.
name|has_encrypted_entries
operator|=
name|has_encrypted_entries
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
block|}
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Not enough slots for format registration"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Used internally by decompression routines to register their bid and  * initialization functions.  */
end_comment

begin_function
name|int
name|__archive_read_get_bidder
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|archive_read_filter_bidder
modifier|*
modifier|*
name|bidder
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|number_slots
decl_stmt|;
name|number_slots
operator|=
sizeof|sizeof
argument_list|(
name|a
operator|->
name|bidders
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|a
operator|->
name|bidders
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_slots
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|a
operator|->
name|bidders
index|[
name|i
index|]
operator|.
name|bid
operator|==
name|NULL
condition|)
block|{
name|memset
argument_list|(
name|a
operator|->
name|bidders
operator|+
name|i
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|a
operator|->
name|bidders
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|bidder
operator|=
operator|(
name|a
operator|->
name|bidders
operator|+
name|i
operator|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
block|}
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Not enough slots for filter registration"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The next section implements the peek/consume internal I/O  * system used by archive readers.  This system allows simple  * read-ahead for consumers while preserving zero-copy operation  * most of the time.  *  * The two key operations:  *  * The read-ahead function returns a pointer to a block of data  *    that satisfies a minimum request.  *  * The consume function advances the file pointer.  *  * In the ideal case, filters generate blocks of data  * and __archive_read_ahead() just returns pointers directly into  * those blocks.  Then __archive_read_consume() just bumps those  * pointers.  Only if your request would span blocks does the I/O  * layer use a copy buffer to provide you with a contiguous block of  * data.  *  * A couple of useful idioms:  *  * "I just want some data."  Ask for 1 byte and pay attention to  *    the "number of bytes available" from __archive_read_ahead().  *    Consume whatever you actually use.  *  * "I want to output a large block of data."  As above, ask for 1 byte,  *    emit all that's available (up to whatever limit you have), consume  *    it all, then repeat until you're done.  This effectively means that  *    you're passing along the blocks that came from your provider.  *  * "I want to peek ahead by a large amount."  Ask for 4k or so, then  *    double and repeat until you get an error or have enough.  Note  *    that the I/O layer will likely end up expanding its copy buffer  *    to fit your request, so use this technique cautiously.  This  *    technique is used, for example, by some of the format tasting  *    code that has uncertain look-ahead needs.  */
end_comment

begin_comment
comment|/*  * Looks ahead in the input stream:  *  * If 'avail' pointer is provided, that returns number of bytes available  *    in the current buffer, which may be much larger than requested.  *  * If end-of-file, *avail gets set to zero.  *  * If error, *avail gets error code.  *  * If request can be met, returns pointer to data.  *  * If minimum request cannot be met, returns NULL.  *  * Note: If you just want "some data", ask for 1 byte and pay attention  * to *avail, which will have the actual amount available.  If you  * know exactly how many bytes you need, just ask for that and treat  * a NULL return as an error.  *  * Important:  This does NOT move the file pointer.  See  * __archive_read_consume() below.  */
end_comment

begin_function
specifier|const
name|void
modifier|*
name|__archive_read_ahead
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|size_t
name|min
parameter_list|,
name|ssize_t
modifier|*
name|avail
parameter_list|)
block|{
return|return
operator|(
name|__archive_read_filter_ahead
argument_list|(
name|a
operator|->
name|filter
argument_list|,
name|min
argument_list|,
name|avail
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|void
modifier|*
name|__archive_read_filter_ahead
parameter_list|(
name|struct
name|archive_read_filter
modifier|*
name|filter
parameter_list|,
name|size_t
name|min
parameter_list|,
name|ssize_t
modifier|*
name|avail
parameter_list|)
block|{
name|ssize_t
name|bytes_read
decl_stmt|;
name|size_t
name|tocopy
decl_stmt|;
if|if
condition|(
name|filter
operator|->
name|fatal
condition|)
block|{
if|if
condition|(
name|avail
condition|)
operator|*
name|avail
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Keep pulling more data until we can satisfy the request. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * If we can satisfy from the copy buffer (and the 		 * copy buffer isn't empty), we're done.  In particular, 		 * note that min == 0 is a perfectly well-defined 		 * request. 		 */
if|if
condition|(
name|filter
operator|->
name|avail
operator|>=
name|min
operator|&&
name|filter
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|avail
operator|!=
name|NULL
condition|)
operator|*
name|avail
operator|=
name|filter
operator|->
name|avail
expr_stmt|;
return|return
operator|(
name|filter
operator|->
name|next
operator|)
return|;
block|}
comment|/* 		 * We can satisfy directly from client buffer if everything 		 * currently in the copy buffer is still in the client buffer. 		 */
if|if
condition|(
name|filter
operator|->
name|client_total
operator|>=
name|filter
operator|->
name|client_avail
operator|+
name|filter
operator|->
name|avail
operator|&&
name|filter
operator|->
name|client_avail
operator|+
name|filter
operator|->
name|avail
operator|>=
name|min
condition|)
block|{
comment|/* "Roll back" to client buffer. */
name|filter
operator|->
name|client_avail
operator|+=
name|filter
operator|->
name|avail
expr_stmt|;
name|filter
operator|->
name|client_next
operator|-=
name|filter
operator|->
name|avail
expr_stmt|;
comment|/* Copy buffer is now empty. */
name|filter
operator|->
name|avail
operator|=
literal|0
expr_stmt|;
name|filter
operator|->
name|next
operator|=
name|filter
operator|->
name|buffer
expr_stmt|;
comment|/* Return data from client buffer. */
if|if
condition|(
name|avail
operator|!=
name|NULL
condition|)
operator|*
name|avail
operator|=
name|filter
operator|->
name|client_avail
expr_stmt|;
return|return
operator|(
name|filter
operator|->
name|client_next
operator|)
return|;
block|}
comment|/* Move data forward in copy buffer if necessary. */
if|if
condition|(
name|filter
operator|->
name|next
operator|>
name|filter
operator|->
name|buffer
operator|&&
name|filter
operator|->
name|next
operator|+
name|min
operator|>
name|filter
operator|->
name|buffer
operator|+
name|filter
operator|->
name|buffer_size
condition|)
block|{
if|if
condition|(
name|filter
operator|->
name|avail
operator|>
literal|0
condition|)
name|memmove
argument_list|(
name|filter
operator|->
name|buffer
argument_list|,
name|filter
operator|->
name|next
argument_list|,
name|filter
operator|->
name|avail
argument_list|)
expr_stmt|;
name|filter
operator|->
name|next
operator|=
name|filter
operator|->
name|buffer
expr_stmt|;
block|}
comment|/* If we've used up the client data, get more. */
if|if
condition|(
name|filter
operator|->
name|client_avail
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|filter
operator|->
name|end_of_file
condition|)
block|{
if|if
condition|(
name|avail
operator|!=
name|NULL
condition|)
operator|*
name|avail
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bytes_read
operator|=
call|(
name|filter
operator|->
name|read
call|)
argument_list|(
name|filter
argument_list|,
operator|&
name|filter
operator|->
name|client_buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|<
literal|0
condition|)
block|{
comment|/* Read error. */
name|filter
operator|->
name|client_total
operator|=
name|filter
operator|->
name|client_avail
operator|=
literal|0
expr_stmt|;
name|filter
operator|->
name|client_next
operator|=
name|filter
operator|->
name|client_buff
operator|=
name|NULL
expr_stmt|;
name|filter
operator|->
name|fatal
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|avail
operator|!=
name|NULL
condition|)
operator|*
name|avail
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|bytes_read
operator|==
literal|0
condition|)
block|{
comment|/* Check for another client object first */
if|if
condition|(
name|filter
operator|->
name|archive
operator|->
name|client
operator|.
name|cursor
operator|!=
name|filter
operator|->
name|archive
operator|->
name|client
operator|.
name|nodes
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|client_switch_proxy
argument_list|(
name|filter
argument_list|,
name|filter
operator|->
name|archive
operator|->
name|client
operator|.
name|cursor
operator|+
literal|1
argument_list|)
operator|==
name|ARCHIVE_OK
condition|)
continue|continue;
block|}
comment|/* Premature end-of-file. */
name|filter
operator|->
name|client_total
operator|=
name|filter
operator|->
name|client_avail
operator|=
literal|0
expr_stmt|;
name|filter
operator|->
name|client_next
operator|=
name|filter
operator|->
name|client_buff
operator|=
name|NULL
expr_stmt|;
name|filter
operator|->
name|end_of_file
operator|=
literal|1
expr_stmt|;
comment|/* Return whatever we do have. */
if|if
condition|(
name|avail
operator|!=
name|NULL
condition|)
operator|*
name|avail
operator|=
name|filter
operator|->
name|avail
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|filter
operator|->
name|client_total
operator|=
name|bytes_read
expr_stmt|;
name|filter
operator|->
name|client_avail
operator|=
name|filter
operator|->
name|client_total
expr_stmt|;
name|filter
operator|->
name|client_next
operator|=
name|filter
operator|->
name|client_buff
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * We can't satisfy the request from the copy 			 * buffer or the existing client data, so we 			 * need to copy more client data over to the 			 * copy buffer. 			 */
comment|/* Ensure the buffer is big enough. */
if|if
condition|(
name|min
operator|>
name|filter
operator|->
name|buffer_size
condition|)
block|{
name|size_t
name|s
decl_stmt|,
name|t
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Double the buffer; watch for overflow. */
name|s
operator|=
name|t
operator|=
name|filter
operator|->
name|buffer_size
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
name|s
operator|=
name|min
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|min
condition|)
block|{
name|t
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|t
operator|<=
name|s
condition|)
block|{
comment|/* Integer overflow! */
name|archive_set_error
argument_list|(
operator|&
name|filter
operator|->
name|archive
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Unable to allocate copy"
literal|" buffer"
argument_list|)
expr_stmt|;
name|filter
operator|->
name|fatal
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|avail
operator|!=
name|NULL
condition|)
operator|*
name|avail
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|s
operator|=
name|t
expr_stmt|;
block|}
comment|/* Now s>= min, so allocate a new buffer. */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|filter
operator|->
name|archive
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Unable to allocate copy buffer"
argument_list|)
expr_stmt|;
name|filter
operator|->
name|fatal
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|avail
operator|!=
name|NULL
condition|)
operator|*
name|avail
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Move data into newly-enlarged buffer. */
if|if
condition|(
name|filter
operator|->
name|avail
operator|>
literal|0
condition|)
name|memmove
argument_list|(
name|p
argument_list|,
name|filter
operator|->
name|next
argument_list|,
name|filter
operator|->
name|avail
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filter
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|filter
operator|->
name|next
operator|=
name|filter
operator|->
name|buffer
operator|=
name|p
expr_stmt|;
name|filter
operator|->
name|buffer_size
operator|=
name|s
expr_stmt|;
block|}
comment|/* We can add client data to copy buffer. */
comment|/* First estimate: copy to fill rest of buffer. */
name|tocopy
operator|=
operator|(
name|filter
operator|->
name|buffer
operator|+
name|filter
operator|->
name|buffer_size
operator|)
operator|-
operator|(
name|filter
operator|->
name|next
operator|+
name|filter
operator|->
name|avail
operator|)
expr_stmt|;
comment|/* Don't waste time buffering more than we need to. */
if|if
condition|(
name|tocopy
operator|+
name|filter
operator|->
name|avail
operator|>
name|min
condition|)
name|tocopy
operator|=
name|min
operator|-
name|filter
operator|->
name|avail
expr_stmt|;
comment|/* Don't copy more than is available. */
if|if
condition|(
name|tocopy
operator|>
name|filter
operator|->
name|client_avail
condition|)
name|tocopy
operator|=
name|filter
operator|->
name|client_avail
expr_stmt|;
name|memcpy
argument_list|(
name|filter
operator|->
name|next
operator|+
name|filter
operator|->
name|avail
argument_list|,
name|filter
operator|->
name|client_next
argument_list|,
name|tocopy
argument_list|)
expr_stmt|;
comment|/* Remove this data from client buffer. */
name|filter
operator|->
name|client_next
operator|+=
name|tocopy
expr_stmt|;
name|filter
operator|->
name|client_avail
operator|-=
name|tocopy
expr_stmt|;
comment|/* add it to copy buffer. */
name|filter
operator|->
name|avail
operator|+=
name|tocopy
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Move the file pointer forward.  */
end_comment

begin_function
name|int64_t
name|__archive_read_consume
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|int64_t
name|request
parameter_list|)
block|{
return|return
operator|(
name|__archive_read_filter_consume
argument_list|(
name|a
operator|->
name|filter
argument_list|,
name|request
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int64_t
name|__archive_read_filter_consume
parameter_list|(
name|struct
name|archive_read_filter
modifier|*
name|filter
parameter_list|,
name|int64_t
name|request
parameter_list|)
block|{
name|int64_t
name|skipped
decl_stmt|;
if|if
condition|(
name|request
operator|<
literal|0
condition|)
return|return
name|ARCHIVE_FATAL
return|;
if|if
condition|(
name|request
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|skipped
operator|=
name|advance_file_pointer
argument_list|(
name|filter
argument_list|,
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|skipped
operator|==
name|request
condition|)
return|return
operator|(
name|skipped
operator|)
return|;
comment|/* We hit EOF before we satisfied the skip request. */
if|if
condition|(
name|skipped
operator|<
literal|0
condition|)
comment|/* Map error code to 0 for error message below. */
name|skipped
operator|=
literal|0
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|filter
operator|->
name|archive
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Truncated input file (needed %jd bytes, only %jd available)"
argument_list|,
operator|(
name|intmax_t
operator|)
name|request
argument_list|,
operator|(
name|intmax_t
operator|)
name|skipped
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Advance the file pointer by the amount requested.  * Returns the amount actually advanced, which may be less than the  * request if EOF is encountered first.  * Returns a negative value if there's an I/O error.  */
end_comment

begin_function
specifier|static
name|int64_t
name|advance_file_pointer
parameter_list|(
name|struct
name|archive_read_filter
modifier|*
name|filter
parameter_list|,
name|int64_t
name|request
parameter_list|)
block|{
name|int64_t
name|bytes_skipped
decl_stmt|,
name|total_bytes_skipped
init|=
literal|0
decl_stmt|;
name|ssize_t
name|bytes_read
decl_stmt|;
name|size_t
name|min
decl_stmt|;
if|if
condition|(
name|filter
operator|->
name|fatal
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Use up the copy buffer first. */
if|if
condition|(
name|filter
operator|->
name|avail
operator|>
literal|0
condition|)
block|{
name|min
operator|=
operator|(
name|size_t
operator|)
name|minimum
argument_list|(
name|request
argument_list|,
operator|(
name|int64_t
operator|)
name|filter
operator|->
name|avail
argument_list|)
expr_stmt|;
name|filter
operator|->
name|next
operator|+=
name|min
expr_stmt|;
name|filter
operator|->
name|avail
operator|-=
name|min
expr_stmt|;
name|request
operator|-=
name|min
expr_stmt|;
name|filter
operator|->
name|position
operator|+=
name|min
expr_stmt|;
name|total_bytes_skipped
operator|+=
name|min
expr_stmt|;
block|}
comment|/* Then use up the client buffer. */
if|if
condition|(
name|filter
operator|->
name|client_avail
operator|>
literal|0
condition|)
block|{
name|min
operator|=
operator|(
name|size_t
operator|)
name|minimum
argument_list|(
name|request
argument_list|,
operator|(
name|int64_t
operator|)
name|filter
operator|->
name|client_avail
argument_list|)
expr_stmt|;
name|filter
operator|->
name|client_next
operator|+=
name|min
expr_stmt|;
name|filter
operator|->
name|client_avail
operator|-=
name|min
expr_stmt|;
name|request
operator|-=
name|min
expr_stmt|;
name|filter
operator|->
name|position
operator|+=
name|min
expr_stmt|;
name|total_bytes_skipped
operator|+=
name|min
expr_stmt|;
block|}
if|if
condition|(
name|request
operator|==
literal|0
condition|)
return|return
operator|(
name|total_bytes_skipped
operator|)
return|;
comment|/* If there's an optimized skip function, use it. */
if|if
condition|(
name|filter
operator|->
name|skip
operator|!=
name|NULL
condition|)
block|{
name|bytes_skipped
operator|=
call|(
name|filter
operator|->
name|skip
call|)
argument_list|(
name|filter
argument_list|,
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_skipped
operator|<
literal|0
condition|)
block|{
comment|/* error */
name|filter
operator|->
name|fatal
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|bytes_skipped
operator|)
return|;
block|}
name|filter
operator|->
name|position
operator|+=
name|bytes_skipped
expr_stmt|;
name|total_bytes_skipped
operator|+=
name|bytes_skipped
expr_stmt|;
name|request
operator|-=
name|bytes_skipped
expr_stmt|;
if|if
condition|(
name|request
operator|==
literal|0
condition|)
return|return
operator|(
name|total_bytes_skipped
operator|)
return|;
block|}
comment|/* Use ordinary reads as necessary to complete the request. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|bytes_read
operator|=
call|(
name|filter
operator|->
name|read
call|)
argument_list|(
name|filter
argument_list|,
operator|&
name|filter
operator|->
name|client_buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|<
literal|0
condition|)
block|{
name|filter
operator|->
name|client_buff
operator|=
name|NULL
expr_stmt|;
name|filter
operator|->
name|fatal
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|bytes_read
operator|)
return|;
block|}
if|if
condition|(
name|bytes_read
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|filter
operator|->
name|archive
operator|->
name|client
operator|.
name|cursor
operator|!=
name|filter
operator|->
name|archive
operator|->
name|client
operator|.
name|nodes
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|client_switch_proxy
argument_list|(
name|filter
argument_list|,
name|filter
operator|->
name|archive
operator|->
name|client
operator|.
name|cursor
operator|+
literal|1
argument_list|)
operator|==
name|ARCHIVE_OK
condition|)
continue|continue;
block|}
name|filter
operator|->
name|client_buff
operator|=
name|NULL
expr_stmt|;
name|filter
operator|->
name|end_of_file
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|total_bytes_skipped
operator|)
return|;
block|}
if|if
condition|(
name|bytes_read
operator|>=
name|request
condition|)
block|{
name|filter
operator|->
name|client_next
operator|=
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|filter
operator|->
name|client_buff
operator|)
operator|+
name|request
expr_stmt|;
name|filter
operator|->
name|client_avail
operator|=
call|(
name|size_t
call|)
argument_list|(
name|bytes_read
operator|-
name|request
argument_list|)
expr_stmt|;
name|filter
operator|->
name|client_total
operator|=
name|bytes_read
expr_stmt|;
name|total_bytes_skipped
operator|+=
name|request
expr_stmt|;
name|filter
operator|->
name|position
operator|+=
name|request
expr_stmt|;
return|return
operator|(
name|total_bytes_skipped
operator|)
return|;
block|}
name|filter
operator|->
name|position
operator|+=
name|bytes_read
expr_stmt|;
name|total_bytes_skipped
operator|+=
name|bytes_read
expr_stmt|;
name|request
operator|-=
name|bytes_read
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Returns ARCHIVE_FAILED if seeking isn't supported.  */
end_comment

begin_function
name|int64_t
name|__archive_read_seek
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|int64_t
name|offset
parameter_list|,
name|int
name|whence
parameter_list|)
block|{
return|return
name|__archive_read_filter_seek
argument_list|(
name|a
operator|->
name|filter
argument_list|,
name|offset
argument_list|,
name|whence
argument_list|)
return|;
block|}
end_function

begin_function
name|int64_t
name|__archive_read_filter_seek
parameter_list|(
name|struct
name|archive_read_filter
modifier|*
name|filter
parameter_list|,
name|int64_t
name|offset
parameter_list|,
name|int
name|whence
parameter_list|)
block|{
name|struct
name|archive_read_client
modifier|*
name|client
decl_stmt|;
name|int64_t
name|r
decl_stmt|;
name|unsigned
name|int
name|cursor
decl_stmt|;
if|if
condition|(
name|filter
operator|->
name|closed
operator|||
name|filter
operator|->
name|fatal
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
if|if
condition|(
name|filter
operator|->
name|seek
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
name|client
operator|=
operator|&
operator|(
name|filter
operator|->
name|archive
operator|->
name|client
operator|)
expr_stmt|;
switch|switch
condition|(
name|whence
condition|)
block|{
case|case
name|SEEK_CUR
case|:
comment|/* Adjust the offset and use SEEK_SET instead */
name|offset
operator|+=
name|filter
operator|->
name|position
expr_stmt|;
case|case
name|SEEK_SET
case|:
name|cursor
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|client
operator|->
name|dataset
index|[
name|cursor
index|]
operator|.
name|begin_position
operator|<
literal|0
operator|||
name|client
operator|->
name|dataset
index|[
name|cursor
index|]
operator|.
name|total_size
operator|<
literal|0
operator|||
name|client
operator|->
name|dataset
index|[
name|cursor
index|]
operator|.
name|begin_position
operator|+
name|client
operator|->
name|dataset
index|[
name|cursor
index|]
operator|.
name|total_size
operator|-
literal|1
operator|>
name|offset
operator|||
name|cursor
operator|+
literal|1
operator|>=
name|client
operator|->
name|nodes
condition|)
break|break;
name|r
operator|=
name|client
operator|->
name|dataset
index|[
name|cursor
index|]
operator|.
name|begin_position
operator|+
name|client
operator|->
name|dataset
index|[
name|cursor
index|]
operator|.
name|total_size
expr_stmt|;
name|client
operator|->
name|dataset
index|[
operator|++
name|cursor
index|]
operator|.
name|begin_position
operator|=
name|r
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|r
operator|=
name|client_switch_proxy
argument_list|(
name|filter
argument_list|,
name|cursor
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
name|r
return|;
if|if
condition|(
operator|(
name|r
operator|=
name|client_seek_proxy
argument_list|(
name|filter
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|r
return|;
name|client
operator|->
name|dataset
index|[
name|cursor
index|]
operator|.
name|total_size
operator|=
name|r
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|dataset
index|[
name|cursor
index|]
operator|.
name|begin_position
operator|+
name|client
operator|->
name|dataset
index|[
name|cursor
index|]
operator|.
name|total_size
operator|-
literal|1
operator|>
name|offset
operator|||
name|cursor
operator|+
literal|1
operator|>=
name|client
operator|->
name|nodes
condition|)
break|break;
name|r
operator|=
name|client
operator|->
name|dataset
index|[
name|cursor
index|]
operator|.
name|begin_position
operator|+
name|client
operator|->
name|dataset
index|[
name|cursor
index|]
operator|.
name|total_size
expr_stmt|;
name|client
operator|->
name|dataset
index|[
operator|++
name|cursor
index|]
operator|.
name|begin_position
operator|=
name|r
expr_stmt|;
block|}
name|offset
operator|-=
name|client
operator|->
name|dataset
index|[
name|cursor
index|]
operator|.
name|begin_position
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
name|offset
operator|>
name|client
operator|->
name|dataset
index|[
name|cursor
index|]
operator|.
name|total_size
condition|)
return|return
name|ARCHIVE_FATAL
return|;
if|if
condition|(
operator|(
name|r
operator|=
name|client_seek_proxy
argument_list|(
name|filter
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|r
return|;
break|break;
case|case
name|SEEK_END
case|:
name|cursor
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|client
operator|->
name|dataset
index|[
name|cursor
index|]
operator|.
name|begin_position
operator|<
literal|0
operator|||
name|client
operator|->
name|dataset
index|[
name|cursor
index|]
operator|.
name|total_size
operator|<
literal|0
operator|||
name|cursor
operator|+
literal|1
operator|>=
name|client
operator|->
name|nodes
condition|)
break|break;
name|r
operator|=
name|client
operator|->
name|dataset
index|[
name|cursor
index|]
operator|.
name|begin_position
operator|+
name|client
operator|->
name|dataset
index|[
name|cursor
index|]
operator|.
name|total_size
expr_stmt|;
name|client
operator|->
name|dataset
index|[
operator|++
name|cursor
index|]
operator|.
name|begin_position
operator|=
name|r
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|r
operator|=
name|client_switch_proxy
argument_list|(
name|filter
argument_list|,
name|cursor
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
name|r
return|;
if|if
condition|(
operator|(
name|r
operator|=
name|client_seek_proxy
argument_list|(
name|filter
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|r
return|;
name|client
operator|->
name|dataset
index|[
name|cursor
index|]
operator|.
name|total_size
operator|=
name|r
expr_stmt|;
name|r
operator|=
name|client
operator|->
name|dataset
index|[
name|cursor
index|]
operator|.
name|begin_position
operator|+
name|client
operator|->
name|dataset
index|[
name|cursor
index|]
operator|.
name|total_size
expr_stmt|;
if|if
condition|(
name|cursor
operator|+
literal|1
operator|>=
name|client
operator|->
name|nodes
condition|)
break|break;
name|client
operator|->
name|dataset
index|[
operator|++
name|cursor
index|]
operator|.
name|begin_position
operator|=
name|r
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|r
operator|+
name|offset
operator|>=
name|client
operator|->
name|dataset
index|[
name|cursor
index|]
operator|.
name|begin_position
condition|)
break|break;
name|offset
operator|+=
name|client
operator|->
name|dataset
index|[
name|cursor
index|]
operator|.
name|total_size
expr_stmt|;
if|if
condition|(
name|cursor
operator|==
literal|0
condition|)
break|break;
name|cursor
operator|--
expr_stmt|;
name|r
operator|=
name|client
operator|->
name|dataset
index|[
name|cursor
index|]
operator|.
name|begin_position
operator|+
name|client
operator|->
name|dataset
index|[
name|cursor
index|]
operator|.
name|total_size
expr_stmt|;
block|}
name|offset
operator|=
operator|(
name|r
operator|+
name|offset
operator|)
operator|-
name|client
operator|->
name|dataset
index|[
name|cursor
index|]
operator|.
name|begin_position
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|client_switch_proxy
argument_list|(
name|filter
argument_list|,
name|cursor
argument_list|)
operator|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
name|r
return|;
name|r
operator|=
name|client_seek_proxy
argument_list|(
name|filter
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|ARCHIVE_OK
condition|)
return|return
name|r
return|;
break|break;
default|default:
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|r
operator|+=
name|client
operator|->
name|dataset
index|[
name|cursor
index|]
operator|.
name|begin_position
expr_stmt|;
if|if
condition|(
name|r
operator|>=
literal|0
condition|)
block|{
comment|/* 		 * Ouch.  Clearing the buffer like this hurts, especially 		 * at bid time.  A lot of our efficiency at bid time comes 		 * from having bidders reuse the data we've already read. 		 * 		 * TODO: If the seek request is in data we already 		 * have, then don't call the seek callback. 		 * 		 * TODO: Zip seeks to end-of-file at bid time.  If 		 * other formats also start doing this, we may need to 		 * find a way for clients to fudge the seek offset to 		 * a block boundary. 		 * 		 * Hmmm... If whence was SEEK_END, we know the file 		 * size is (r - offset).  Can we use that to simplify 		 * the TODO items above? 		 */
name|filter
operator|->
name|avail
operator|=
name|filter
operator|->
name|client_avail
operator|=
literal|0
expr_stmt|;
name|filter
operator|->
name|next
operator|=
name|filter
operator|->
name|buffer
expr_stmt|;
name|filter
operator|->
name|position
operator|=
name|r
expr_stmt|;
name|filter
operator|->
name|end_of_file
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

end_unit

