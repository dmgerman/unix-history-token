begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Matt Thomas<matt@3am-software.com>.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  * Based on: NetBSD: rb.c,v 1.6 2010/04/30 13:58:09 joerg Exp  */
end_comment

begin_include
include|#
directive|include
file|"archive_platform.h"
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|"archive_rb.h"
end_include

begin_comment
comment|/* Keep in sync with archive_rb.h */
end_comment

begin_define
define|#
directive|define
name|RB_DIR_LEFT
value|0
end_define

begin_define
define|#
directive|define
name|RB_DIR_RIGHT
value|1
end_define

begin_define
define|#
directive|define
name|RB_DIR_OTHER
value|1
end_define

begin_define
define|#
directive|define
name|rb_left
value|rb_nodes[RB_DIR_LEFT]
end_define

begin_define
define|#
directive|define
name|rb_right
value|rb_nodes[RB_DIR_RIGHT]
end_define

begin_define
define|#
directive|define
name|RB_FLAG_POSITION
value|0x2
end_define

begin_define
define|#
directive|define
name|RB_FLAG_RED
value|0x1
end_define

begin_define
define|#
directive|define
name|RB_FLAG_MASK
value|(RB_FLAG_POSITION|RB_FLAG_RED)
end_define

begin_define
define|#
directive|define
name|RB_FATHER
parameter_list|(
name|rb
parameter_list|)
define|\
value|((struct archive_rb_node *)((rb)->rb_info& ~RB_FLAG_MASK))
end_define

begin_define
define|#
directive|define
name|RB_SET_FATHER
parameter_list|(
name|rb
parameter_list|,
name|father
parameter_list|)
define|\
value|((void)((rb)->rb_info = (uintptr_t)(father)|((rb)->rb_info& RB_FLAG_MASK)))
end_define

begin_define
define|#
directive|define
name|RB_SENTINEL_P
parameter_list|(
name|rb
parameter_list|)
value|((rb) == NULL)
end_define

begin_define
define|#
directive|define
name|RB_LEFT_SENTINEL_P
parameter_list|(
name|rb
parameter_list|)
value|RB_SENTINEL_P((rb)->rb_left)
end_define

begin_define
define|#
directive|define
name|RB_RIGHT_SENTINEL_P
parameter_list|(
name|rb
parameter_list|)
value|RB_SENTINEL_P((rb)->rb_right)
end_define

begin_define
define|#
directive|define
name|RB_FATHER_SENTINEL_P
parameter_list|(
name|rb
parameter_list|)
value|RB_SENTINEL_P(RB_FATHER((rb)))
end_define

begin_define
define|#
directive|define
name|RB_CHILDLESS_P
parameter_list|(
name|rb
parameter_list|)
define|\
value|(RB_SENTINEL_P(rb) || (RB_LEFT_SENTINEL_P(rb)&& RB_RIGHT_SENTINEL_P(rb)))
end_define

begin_define
define|#
directive|define
name|RB_TWOCHILDREN_P
parameter_list|(
name|rb
parameter_list|)
define|\
value|(!RB_SENTINEL_P(rb)&& !RB_LEFT_SENTINEL_P(rb)&& !RB_RIGHT_SENTINEL_P(rb))
end_define

begin_define
define|#
directive|define
name|RB_POSITION
parameter_list|(
name|rb
parameter_list|)
define|\
value|(((rb)->rb_info& RB_FLAG_POSITION) ? RB_DIR_RIGHT : RB_DIR_LEFT)
end_define

begin_define
define|#
directive|define
name|RB_RIGHT_P
parameter_list|(
name|rb
parameter_list|)
value|(RB_POSITION(rb) == RB_DIR_RIGHT)
end_define

begin_define
define|#
directive|define
name|RB_LEFT_P
parameter_list|(
name|rb
parameter_list|)
value|(RB_POSITION(rb) == RB_DIR_LEFT)
end_define

begin_define
define|#
directive|define
name|RB_RED_P
parameter_list|(
name|rb
parameter_list|)
value|(!RB_SENTINEL_P(rb)&& ((rb)->rb_info& RB_FLAG_RED) != 0)
end_define

begin_define
define|#
directive|define
name|RB_BLACK_P
parameter_list|(
name|rb
parameter_list|)
value|(RB_SENTINEL_P(rb) || ((rb)->rb_info& RB_FLAG_RED) == 0)
end_define

begin_define
define|#
directive|define
name|RB_MARK_RED
parameter_list|(
name|rb
parameter_list|)
value|((void)((rb)->rb_info |= RB_FLAG_RED))
end_define

begin_define
define|#
directive|define
name|RB_MARK_BLACK
parameter_list|(
name|rb
parameter_list|)
value|((void)((rb)->rb_info&= ~RB_FLAG_RED))
end_define

begin_define
define|#
directive|define
name|RB_INVERT_COLOR
parameter_list|(
name|rb
parameter_list|)
value|((void)((rb)->rb_info ^= RB_FLAG_RED))
end_define

begin_define
define|#
directive|define
name|RB_ROOT_P
parameter_list|(
name|rbt
parameter_list|,
name|rb
parameter_list|)
value|((rbt)->rbt_root == (rb))
end_define

begin_define
define|#
directive|define
name|RB_SET_POSITION
parameter_list|(
name|rb
parameter_list|,
name|position
parameter_list|)
define|\
value|((void)((position) ? ((rb)->rb_info |= RB_FLAG_POSITION) : \     ((rb)->rb_info&= ~RB_FLAG_POSITION)))
end_define

begin_define
define|#
directive|define
name|RB_ZERO_PROPERTIES
parameter_list|(
name|rb
parameter_list|)
value|((void)((rb)->rb_info&= ~RB_FLAG_MASK))
end_define

begin_define
define|#
directive|define
name|RB_COPY_PROPERTIES
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
define|\
value|((void)((dst)->rb_info ^= ((dst)->rb_info ^ (src)->rb_info)& RB_FLAG_MASK))
end_define

begin_define
define|#
directive|define
name|RB_SWAP_PROPERTIES
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|do { \     uintptr_t xorinfo = ((a)->rb_info ^ (b)->rb_info)& RB_FLAG_MASK; \     (a)->rb_info ^= xorinfo; \     (b)->rb_info ^= xorinfo; \   } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_function_decl
specifier|static
name|void
name|__archive_rb_tree_insert_rebalance
parameter_list|(
name|struct
name|archive_rb_tree
modifier|*
parameter_list|,
name|struct
name|archive_rb_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__archive_rb_tree_removal_rebalance
parameter_list|(
name|struct
name|archive_rb_tree
modifier|*
parameter_list|,
name|struct
name|archive_rb_node
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|RB_SENTINEL_NODE
value|NULL
end_define

begin_define
define|#
directive|define
name|T
value|1
end_define

begin_define
define|#
directive|define
name|F
value|0
end_define

begin_function
name|void
name|__archive_rb_tree_init
parameter_list|(
name|struct
name|archive_rb_tree
modifier|*
name|rbt
parameter_list|,
specifier|const
name|struct
name|archive_rb_tree_ops
modifier|*
name|ops
parameter_list|)
block|{
name|rbt
operator|->
name|rbt_ops
operator|=
name|ops
expr_stmt|;
operator|*
operator|(
operator|(
expr|struct
name|archive_rb_node
operator|*
operator|*
operator|)
operator|&
name|rbt
operator|->
name|rbt_root
operator|)
operator|=
name|RB_SENTINEL_NODE
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|archive_rb_node
modifier|*
name|__archive_rb_tree_find_node
parameter_list|(
name|struct
name|archive_rb_tree
modifier|*
name|rbt
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|)
block|{
name|archive_rbto_compare_key_fn
name|compare_key
init|=
name|rbt
operator|->
name|rbt_ops
operator|->
name|rbto_compare_key
decl_stmt|;
name|struct
name|archive_rb_node
modifier|*
name|parent
init|=
name|rbt
operator|->
name|rbt_root
decl_stmt|;
while|while
condition|(
operator|!
name|RB_SENTINEL_P
argument_list|(
name|parent
argument_list|)
condition|)
block|{
specifier|const
name|signed
name|int
name|diff
init|=
call|(
modifier|*
name|compare_key
call|)
argument_list|(
name|parent
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
return|return
name|parent
return|;
name|parent
operator|=
name|parent
operator|->
name|rb_nodes
index|[
name|diff
operator|>
literal|0
index|]
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|struct
name|archive_rb_node
modifier|*
name|__archive_rb_tree_find_node_geq
parameter_list|(
name|struct
name|archive_rb_tree
modifier|*
name|rbt
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|)
block|{
name|archive_rbto_compare_key_fn
name|compare_key
init|=
name|rbt
operator|->
name|rbt_ops
operator|->
name|rbto_compare_key
decl_stmt|;
name|struct
name|archive_rb_node
modifier|*
name|parent
init|=
name|rbt
operator|->
name|rbt_root
decl_stmt|;
name|struct
name|archive_rb_node
modifier|*
name|last
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|!
name|RB_SENTINEL_P
argument_list|(
name|parent
argument_list|)
condition|)
block|{
specifier|const
name|signed
name|int
name|diff
init|=
call|(
modifier|*
name|compare_key
call|)
argument_list|(
name|parent
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
return|return
name|parent
return|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
name|last
operator|=
name|parent
expr_stmt|;
name|parent
operator|=
name|parent
operator|->
name|rb_nodes
index|[
name|diff
operator|>
literal|0
index|]
expr_stmt|;
block|}
return|return
name|last
return|;
block|}
end_function

begin_function
name|struct
name|archive_rb_node
modifier|*
name|__archive_rb_tree_find_node_leq
parameter_list|(
name|struct
name|archive_rb_tree
modifier|*
name|rbt
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|)
block|{
name|archive_rbto_compare_key_fn
name|compare_key
init|=
name|rbt
operator|->
name|rbt_ops
operator|->
name|rbto_compare_key
decl_stmt|;
name|struct
name|archive_rb_node
modifier|*
name|parent
init|=
name|rbt
operator|->
name|rbt_root
decl_stmt|;
name|struct
name|archive_rb_node
modifier|*
name|last
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|!
name|RB_SENTINEL_P
argument_list|(
name|parent
argument_list|)
condition|)
block|{
specifier|const
name|signed
name|int
name|diff
init|=
call|(
modifier|*
name|compare_key
call|)
argument_list|(
name|parent
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
return|return
name|parent
return|;
if|if
condition|(
name|diff
operator|>
literal|0
condition|)
name|last
operator|=
name|parent
expr_stmt|;
name|parent
operator|=
name|parent
operator|->
name|rb_nodes
index|[
name|diff
operator|>
literal|0
index|]
expr_stmt|;
block|}
return|return
name|last
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|__archive_rb_tree_insert_node
parameter_list|(
name|struct
name|archive_rb_tree
modifier|*
name|rbt
parameter_list|,
name|struct
name|archive_rb_node
modifier|*
name|self
parameter_list|)
block|{
name|archive_rbto_compare_nodes_fn
name|compare_nodes
init|=
name|rbt
operator|->
name|rbt_ops
operator|->
name|rbto_compare_nodes
decl_stmt|;
name|struct
name|archive_rb_node
modifier|*
name|parent
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|unsigned
name|int
name|position
decl_stmt|;
name|int
name|rebalance
decl_stmt|;
name|tmp
operator|=
name|rbt
operator|->
name|rbt_root
expr_stmt|;
comment|/* 	 * This is a hack.  Because rbt->rbt_root is just a 	 * struct archive_rb_node *, just like rb_node->rb_nodes[RB_DIR_LEFT], 	 * we can use this fact to avoid a lot of tests for root and know 	 * that even at root, updating 	 * RB_FATHER(rb_node)->rb_nodes[RB_POSITION(rb_node)] will 	 * update rbt->rbt_root. 	 */
name|parent
operator|=
operator|(
expr|struct
name|archive_rb_node
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
name|rbt
operator|->
name|rbt_root
expr_stmt|;
name|position
operator|=
name|RB_DIR_LEFT
expr_stmt|;
comment|/* 	 * Find out where to place this new leaf. 	 */
while|while
condition|(
operator|!
name|RB_SENTINEL_P
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
specifier|const
name|signed
name|int
name|diff
init|=
call|(
modifier|*
name|compare_nodes
call|)
argument_list|(
name|tmp
argument_list|,
name|self
argument_list|)
decl_stmt|;
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Node already exists; don't insert. 			 */
return|return
name|F
return|;
block|}
name|parent
operator|=
name|tmp
expr_stmt|;
name|position
operator|=
operator|(
name|diff
operator|>
literal|0
operator|)
expr_stmt|;
name|tmp
operator|=
name|parent
operator|->
name|rb_nodes
index|[
name|position
index|]
expr_stmt|;
block|}
comment|/* 	 * Initialize the node and insert as a leaf into the tree. 	 */
name|RB_SET_FATHER
argument_list|(
name|self
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|RB_SET_POSITION
argument_list|(
name|self
argument_list|,
name|position
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|==
operator|(
expr|struct
name|archive_rb_node
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
name|rbt
operator|->
name|rbt_root
condition|)
block|{
name|RB_MARK_BLACK
argument_list|(
name|self
argument_list|)
expr_stmt|;
comment|/* root is always black */
name|rebalance
operator|=
name|F
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * All new nodes are colored red.  We only need to rebalance 		 * if our parent is also red. 		 */
name|RB_MARK_RED
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|rebalance
operator|=
name|RB_RED_P
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
name|self
operator|->
name|rb_left
operator|=
name|parent
operator|->
name|rb_nodes
index|[
name|position
index|]
expr_stmt|;
name|self
operator|->
name|rb_right
operator|=
name|parent
operator|->
name|rb_nodes
index|[
name|position
index|]
expr_stmt|;
name|parent
operator|->
name|rb_nodes
index|[
name|position
index|]
operator|=
name|self
expr_stmt|;
comment|/* 	 * Rebalance tree after insertion 	 */
if|if
condition|(
name|rebalance
condition|)
name|__archive_rb_tree_insert_rebalance
argument_list|(
name|rbt
argument_list|,
name|self
argument_list|)
expr_stmt|;
return|return
name|T
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Swap the location and colors of 'self' and its child @ which.  The child  * can not be a sentinel node.  This is our rotation function.  However,  * since it preserves coloring, it great simplifies both insertion and  * removal since rotation almost always involves the exchanging of colors  * as a separate step.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|__archive_rb_tree_reparent_nodes
parameter_list|(
name|struct
name|archive_rb_node
modifier|*
name|old_father
parameter_list|,
specifier|const
name|unsigned
name|int
name|which
parameter_list|)
block|{
specifier|const
name|unsigned
name|int
name|other
init|=
name|which
operator|^
name|RB_DIR_OTHER
decl_stmt|;
name|struct
name|archive_rb_node
modifier|*
specifier|const
name|grandpa
init|=
name|RB_FATHER
argument_list|(
name|old_father
argument_list|)
decl_stmt|;
name|struct
name|archive_rb_node
modifier|*
specifier|const
name|old_child
init|=
name|old_father
operator|->
name|rb_nodes
index|[
name|which
index|]
decl_stmt|;
name|struct
name|archive_rb_node
modifier|*
specifier|const
name|new_father
init|=
name|old_child
decl_stmt|;
name|struct
name|archive_rb_node
modifier|*
specifier|const
name|new_child
init|=
name|old_father
decl_stmt|;
comment|/* 	 * Exchange descendant linkages. 	 */
name|grandpa
operator|->
name|rb_nodes
index|[
name|RB_POSITION
argument_list|(
name|old_father
argument_list|)
index|]
operator|=
name|new_father
expr_stmt|;
name|new_child
operator|->
name|rb_nodes
index|[
name|which
index|]
operator|=
name|old_child
operator|->
name|rb_nodes
index|[
name|other
index|]
expr_stmt|;
name|new_father
operator|->
name|rb_nodes
index|[
name|other
index|]
operator|=
name|new_child
expr_stmt|;
comment|/* 	 * Update ancestor linkages 	 */
name|RB_SET_FATHER
argument_list|(
name|new_father
argument_list|,
name|grandpa
argument_list|)
expr_stmt|;
name|RB_SET_FATHER
argument_list|(
name|new_child
argument_list|,
name|new_father
argument_list|)
expr_stmt|;
comment|/* 	 * Exchange properties between new_father and new_child.  The only 	 * change is that new_child's position is now on the other side. 	 */
name|RB_SWAP_PROPERTIES
argument_list|(
name|new_father
argument_list|,
name|new_child
argument_list|)
expr_stmt|;
name|RB_SET_POSITION
argument_list|(
name|new_child
argument_list|,
name|other
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure to reparent the new child to ourself. 	 */
if|if
condition|(
operator|!
name|RB_SENTINEL_P
argument_list|(
name|new_child
operator|->
name|rb_nodes
index|[
name|which
index|]
argument_list|)
condition|)
block|{
name|RB_SET_FATHER
argument_list|(
name|new_child
operator|->
name|rb_nodes
index|[
name|which
index|]
argument_list|,
name|new_child
argument_list|)
expr_stmt|;
name|RB_SET_POSITION
argument_list|(
name|new_child
operator|->
name|rb_nodes
index|[
name|which
index|]
argument_list|,
name|which
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|__archive_rb_tree_insert_rebalance
parameter_list|(
name|struct
name|archive_rb_tree
modifier|*
name|rbt
parameter_list|,
name|struct
name|archive_rb_node
modifier|*
name|self
parameter_list|)
block|{
name|struct
name|archive_rb_node
modifier|*
name|father
init|=
name|RB_FATHER
argument_list|(
name|self
argument_list|)
decl_stmt|;
name|struct
name|archive_rb_node
modifier|*
name|grandpa
decl_stmt|;
name|struct
name|archive_rb_node
modifier|*
name|uncle
decl_stmt|;
name|unsigned
name|int
name|which
decl_stmt|;
name|unsigned
name|int
name|other
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * We are red and our parent is red, therefore we must have a 		 * grandfather and he must be black. 		 */
name|grandpa
operator|=
name|RB_FATHER
argument_list|(
name|father
argument_list|)
expr_stmt|;
name|which
operator|=
operator|(
name|father
operator|==
name|grandpa
operator|->
name|rb_right
operator|)
expr_stmt|;
name|other
operator|=
name|which
operator|^
name|RB_DIR_OTHER
expr_stmt|;
name|uncle
operator|=
name|grandpa
operator|->
name|rb_nodes
index|[
name|other
index|]
expr_stmt|;
if|if
condition|(
name|RB_BLACK_P
argument_list|(
name|uncle
argument_list|)
condition|)
break|break;
comment|/* 		 * Case 1: our uncle is red 		 *   Simply invert the colors of our parent and 		 *   uncle and make our grandparent red.  And 		 *   then solve the problem up at his level. 		 */
name|RB_MARK_BLACK
argument_list|(
name|uncle
argument_list|)
expr_stmt|;
name|RB_MARK_BLACK
argument_list|(
name|father
argument_list|)
expr_stmt|;
if|if
condition|(
name|RB_ROOT_P
argument_list|(
name|rbt
argument_list|,
name|grandpa
argument_list|)
condition|)
block|{
comment|/* 			 * If our grandpa is root, don't bother 			 * setting him to red, just return. 			 */
return|return;
block|}
name|RB_MARK_RED
argument_list|(
name|grandpa
argument_list|)
expr_stmt|;
name|self
operator|=
name|grandpa
expr_stmt|;
name|father
operator|=
name|RB_FATHER
argument_list|(
name|self
argument_list|)
expr_stmt|;
if|if
condition|(
name|RB_BLACK_P
argument_list|(
name|father
argument_list|)
condition|)
block|{
comment|/* 			 * If our greatgrandpa is black, we're done. 			 */
return|return;
block|}
block|}
comment|/* 	 * Case 2&3: our uncle is black. 	 */
if|if
condition|(
name|self
operator|==
name|father
operator|->
name|rb_nodes
index|[
name|other
index|]
condition|)
block|{
comment|/* 		 * Case 2: we are on the same side as our uncle 		 *   Swap ourselves with our parent so this case 		 *   becomes case 3.  Basically our parent becomes our 		 *   child. 		 */
name|__archive_rb_tree_reparent_nodes
argument_list|(
name|father
argument_list|,
name|other
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Case 3: we are opposite a child of a black uncle. 	 *   Swap our parent and grandparent.  Since our grandfather 	 *   is black, our father will become black and our new sibling 	 *   (former grandparent) will become red. 	 */
name|__archive_rb_tree_reparent_nodes
argument_list|(
name|grandpa
argument_list|,
name|which
argument_list|)
expr_stmt|;
comment|/* 	 * Final step: Set the root to black. 	 */
name|RB_MARK_BLACK
argument_list|(
name|rbt
operator|->
name|rbt_root
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|__archive_rb_tree_prune_node
parameter_list|(
name|struct
name|archive_rb_tree
modifier|*
name|rbt
parameter_list|,
name|struct
name|archive_rb_node
modifier|*
name|self
parameter_list|,
name|int
name|rebalance
parameter_list|)
block|{
specifier|const
name|unsigned
name|int
name|which
init|=
name|RB_POSITION
argument_list|(
name|self
argument_list|)
decl_stmt|;
name|struct
name|archive_rb_node
modifier|*
name|father
init|=
name|RB_FATHER
argument_list|(
name|self
argument_list|)
decl_stmt|;
comment|/* 	 * Since we are childless, we know that self->rb_left is pointing 	 * to the sentinel node. 	 */
name|father
operator|->
name|rb_nodes
index|[
name|which
index|]
operator|=
name|self
operator|->
name|rb_left
expr_stmt|;
comment|/* 	 * Rebalance if requested. 	 */
if|if
condition|(
name|rebalance
condition|)
name|__archive_rb_tree_removal_rebalance
argument_list|(
name|rbt
argument_list|,
name|father
argument_list|,
name|which
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * When deleting an interior node  */
end_comment

begin_function
specifier|static
name|void
name|__archive_rb_tree_swap_prune_and_rebalance
parameter_list|(
name|struct
name|archive_rb_tree
modifier|*
name|rbt
parameter_list|,
name|struct
name|archive_rb_node
modifier|*
name|self
parameter_list|,
name|struct
name|archive_rb_node
modifier|*
name|standin
parameter_list|)
block|{
specifier|const
name|unsigned
name|int
name|standin_which
init|=
name|RB_POSITION
argument_list|(
name|standin
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|standin_other
init|=
name|standin_which
operator|^
name|RB_DIR_OTHER
decl_stmt|;
name|struct
name|archive_rb_node
modifier|*
name|standin_son
decl_stmt|;
name|struct
name|archive_rb_node
modifier|*
name|standin_father
init|=
name|RB_FATHER
argument_list|(
name|standin
argument_list|)
decl_stmt|;
name|int
name|rebalance
init|=
name|RB_BLACK_P
argument_list|(
name|standin
argument_list|)
decl_stmt|;
if|if
condition|(
name|standin_father
operator|==
name|self
condition|)
block|{
comment|/* 		 * As a child of self, any children would be opposite of 		 * our parent. 		 */
name|standin_son
operator|=
name|standin
operator|->
name|rb_nodes
index|[
name|standin_which
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Since we aren't a child of self, any children would be 		 * on the same side as our parent. 		 */
name|standin_son
operator|=
name|standin
operator|->
name|rb_nodes
index|[
name|standin_other
index|]
expr_stmt|;
block|}
if|if
condition|(
name|RB_RED_P
argument_list|(
name|standin_son
argument_list|)
condition|)
block|{
comment|/* 		 * We know we have a red child so if we flip it to black 		 * we don't have to rebalance. 		 */
name|RB_MARK_BLACK
argument_list|(
name|standin_son
argument_list|)
expr_stmt|;
name|rebalance
operator|=
name|F
expr_stmt|;
if|if
condition|(
name|standin_father
operator|!=
name|self
condition|)
block|{
comment|/* 			 * Change the son's parentage to point to his grandpa. 			 */
name|RB_SET_FATHER
argument_list|(
name|standin_son
argument_list|,
name|standin_father
argument_list|)
expr_stmt|;
name|RB_SET_POSITION
argument_list|(
name|standin_son
argument_list|,
name|standin_which
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|standin_father
operator|==
name|self
condition|)
block|{
comment|/* 		 * If we are about to delete the standin's father, then when 		 * we call rebalance, we need to use ourselves as our father. 		 * Otherwise remember our original father.  Also, since we are 		 * our standin's father we only need to reparent the standin's 		 * brother. 		 * 		 * |    R      -->     S    | 		 * |  Q   S    -->   Q   T  | 		 * |        t  -->          | 		 * 		 * Have our son/standin adopt his brother as his new son. 		 */
name|standin_father
operator|=
name|standin
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * |    R          -->    S       .  | 		 * |   / \  |   T  -->   / \  |  /   | 		 * |  ..... | S    -->  ..... | T    | 		 * 		 * Sever standin's connection to his father. 		 */
name|standin_father
operator|->
name|rb_nodes
index|[
name|standin_which
index|]
operator|=
name|standin_son
expr_stmt|;
comment|/* 		 * Adopt the far son. 		 */
name|standin
operator|->
name|rb_nodes
index|[
name|standin_other
index|]
operator|=
name|self
operator|->
name|rb_nodes
index|[
name|standin_other
index|]
expr_stmt|;
name|RB_SET_FATHER
argument_list|(
name|standin
operator|->
name|rb_nodes
index|[
name|standin_other
index|]
argument_list|,
name|standin
argument_list|)
expr_stmt|;
comment|/* 		 * Use standin_other because we need to preserve standin_which 		 * for the removal_rebalance. 		 */
name|standin_other
operator|=
name|standin_which
expr_stmt|;
block|}
comment|/* 	 * Move the only remaining son to our standin.  If our standin is our 	 * son, this will be the only son needed to be moved. 	 */
name|standin
operator|->
name|rb_nodes
index|[
name|standin_other
index|]
operator|=
name|self
operator|->
name|rb_nodes
index|[
name|standin_other
index|]
expr_stmt|;
name|RB_SET_FATHER
argument_list|(
name|standin
operator|->
name|rb_nodes
index|[
name|standin_other
index|]
argument_list|,
name|standin
argument_list|)
expr_stmt|;
comment|/* 	 * Now copy the result of self to standin and then replace 	 * self with standin in the tree. 	 */
name|RB_COPY_PROPERTIES
argument_list|(
name|standin
argument_list|,
name|self
argument_list|)
expr_stmt|;
name|RB_SET_FATHER
argument_list|(
name|standin
argument_list|,
name|RB_FATHER
argument_list|(
name|self
argument_list|)
argument_list|)
expr_stmt|;
name|RB_FATHER
argument_list|(
name|standin
argument_list|)
operator|->
name|rb_nodes
index|[
name|RB_POSITION
argument_list|(
name|standin
argument_list|)
index|]
operator|=
name|standin
expr_stmt|;
if|if
condition|(
name|rebalance
condition|)
name|__archive_rb_tree_removal_rebalance
argument_list|(
name|rbt
argument_list|,
name|standin_father
argument_list|,
name|standin_which
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We could do this by doing  *	__archive_rb_tree_node_swap(rbt, self, which);  *	__archive_rb_tree_prune_node(rbt, self, F);  *  * But it's more efficient to just evaluate and recolor the child.  */
end_comment

begin_function
specifier|static
name|void
name|__archive_rb_tree_prune_blackred_branch
parameter_list|(
name|struct
name|archive_rb_node
modifier|*
name|self
parameter_list|,
name|unsigned
name|int
name|which
parameter_list|)
block|{
name|struct
name|archive_rb_node
modifier|*
name|father
init|=
name|RB_FATHER
argument_list|(
name|self
argument_list|)
decl_stmt|;
name|struct
name|archive_rb_node
modifier|*
name|son
init|=
name|self
operator|->
name|rb_nodes
index|[
name|which
index|]
decl_stmt|;
comment|/* 	 * Remove ourselves from the tree and give our former child our 	 * properties (position, color, root). 	 */
name|RB_COPY_PROPERTIES
argument_list|(
name|son
argument_list|,
name|self
argument_list|)
expr_stmt|;
name|father
operator|->
name|rb_nodes
index|[
name|RB_POSITION
argument_list|(
name|son
argument_list|)
index|]
operator|=
name|son
expr_stmt|;
name|RB_SET_FATHER
argument_list|(
name|son
argument_list|,
name|father
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
name|void
name|__archive_rb_tree_remove_node
parameter_list|(
name|struct
name|archive_rb_tree
modifier|*
name|rbt
parameter_list|,
name|struct
name|archive_rb_node
modifier|*
name|self
parameter_list|)
block|{
name|struct
name|archive_rb_node
modifier|*
name|standin
decl_stmt|;
name|unsigned
name|int
name|which
decl_stmt|;
comment|/* 	 * In the following diagrams, we (the node to be removed) are S.  Red 	 * nodes are lowercase.  T could be either red or black. 	 * 	 * Remember the major axiom of the red-black tree: the number of 	 * black nodes from the root to each leaf is constant across all 	 * leaves, only the number of red nodes varies. 	 * 	 * Thus removing a red leaf doesn't require any other changes to a 	 * red-black tree.  So if we must remove a node, attempt to rearrange 	 * the tree so we can remove a red node. 	 * 	 * The simplest case is a childless red node or a childless root node: 	 * 	 * |    T  -->    T  |    or    |  R  -->  *  | 	 * |  s    -->  *    | 	 */
if|if
condition|(
name|RB_CHILDLESS_P
argument_list|(
name|self
argument_list|)
condition|)
block|{
specifier|const
name|int
name|rebalance
init|=
name|RB_BLACK_P
argument_list|(
name|self
argument_list|)
operator|&&
operator|!
name|RB_ROOT_P
argument_list|(
name|rbt
argument_list|,
name|self
argument_list|)
decl_stmt|;
name|__archive_rb_tree_prune_node
argument_list|(
name|rbt
argument_list|,
name|self
argument_list|,
name|rebalance
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|RB_TWOCHILDREN_P
argument_list|(
name|self
argument_list|)
condition|)
block|{
comment|/* 		 * The next simplest case is the node we are deleting is 		 * black and has one red child. 		 * 		 * |      T  -->      T  -->      T  | 		 * |    S    -->  R      -->  R      | 		 * |  r      -->    s    -->    *    | 		 */
name|which
operator|=
name|RB_LEFT_SENTINEL_P
argument_list|(
name|self
argument_list|)
condition|?
name|RB_DIR_RIGHT
else|:
name|RB_DIR_LEFT
expr_stmt|;
name|__archive_rb_tree_prune_blackred_branch
argument_list|(
name|self
argument_list|,
name|which
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * We invert these because we prefer to remove from the inside of 	 * the tree. 	 */
name|which
operator|=
name|RB_POSITION
argument_list|(
name|self
argument_list|)
operator|^
name|RB_DIR_OTHER
expr_stmt|;
comment|/* 	 * Let's find the node closes to us opposite of our parent 	 * Now swap it with ourself, "prune" it, and rebalance, if needed. 	 */
name|standin
operator|=
name|__archive_rb_tree_iterate
argument_list|(
name|rbt
argument_list|,
name|self
argument_list|,
name|which
argument_list|)
expr_stmt|;
name|__archive_rb_tree_swap_prune_and_rebalance
argument_list|(
name|rbt
argument_list|,
name|self
argument_list|,
name|standin
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__archive_rb_tree_removal_rebalance
parameter_list|(
name|struct
name|archive_rb_tree
modifier|*
name|rbt
parameter_list|,
name|struct
name|archive_rb_node
modifier|*
name|parent
parameter_list|,
name|unsigned
name|int
name|which
parameter_list|)
block|{
while|while
condition|(
name|RB_BLACK_P
argument_list|(
name|parent
operator|->
name|rb_nodes
index|[
name|which
index|]
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|other
init|=
name|which
operator|^
name|RB_DIR_OTHER
decl_stmt|;
name|struct
name|archive_rb_node
modifier|*
name|brother
init|=
name|parent
operator|->
name|rb_nodes
index|[
name|other
index|]
decl_stmt|;
comment|/* 		 * For cases 1, 2a, and 2b, our brother's children must 		 * be black and our father must be black 		 */
if|if
condition|(
name|RB_BLACK_P
argument_list|(
name|parent
argument_list|)
operator|&&
name|RB_BLACK_P
argument_list|(
name|brother
operator|->
name|rb_left
argument_list|)
operator|&&
name|RB_BLACK_P
argument_list|(
name|brother
operator|->
name|rb_right
argument_list|)
condition|)
block|{
if|if
condition|(
name|RB_RED_P
argument_list|(
name|brother
argument_list|)
condition|)
block|{
comment|/* 				 * Case 1: Our brother is red, swap its 				 * position (and colors) with our parent.  				 * This should now be case 2b (unless C or E 				 * has a red child which is case 3; thus no 				 * explicit branch to case 2b). 				 * 				 *    B         ->        D 				 *  A     d     ->    b     E 				 *      C   E   ->  A   C 				 */
name|__archive_rb_tree_reparent_nodes
argument_list|(
name|parent
argument_list|,
name|other
argument_list|)
expr_stmt|;
name|brother
operator|=
name|parent
operator|->
name|rb_nodes
index|[
name|other
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Both our parent and brother are black. 				 * Change our brother to red, advance up rank 				 * and go through the loop again. 				 * 				 *    B         ->   *B 				 * *A     D     ->  A     d 				 *      C   E   ->      C   E 				 */
name|RB_MARK_RED
argument_list|(
name|brother
argument_list|)
expr_stmt|;
if|if
condition|(
name|RB_ROOT_P
argument_list|(
name|rbt
argument_list|,
name|parent
argument_list|)
condition|)
return|return;
comment|/* root == parent == black */
name|which
operator|=
name|RB_POSITION
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|parent
operator|=
name|RB_FATHER
argument_list|(
name|parent
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 		 * Avoid an else here so that case 2a above can hit either 		 * case 2b, 3, or 4. 		 */
if|if
condition|(
name|RB_RED_P
argument_list|(
name|parent
argument_list|)
operator|&&
name|RB_BLACK_P
argument_list|(
name|brother
argument_list|)
operator|&&
name|RB_BLACK_P
argument_list|(
name|brother
operator|->
name|rb_left
argument_list|)
operator|&&
name|RB_BLACK_P
argument_list|(
name|brother
operator|->
name|rb_right
argument_list|)
condition|)
block|{
comment|/* 			 * We are black, our father is red, our brother and 			 * both nephews are black.  Simply invert/exchange the 			 * colors of our father and brother (to black and red 			 * respectively). 			 * 			 *	|    f        -->    F        | 			 *	|  *     B    -->  *     b    | 			 *	|      N   N  -->      N   N  | 			 */
name|RB_MARK_BLACK
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|RB_MARK_RED
argument_list|(
name|brother
argument_list|)
expr_stmt|;
break|break;
comment|/* We're done! */
block|}
else|else
block|{
comment|/* 			 * Our brother must be black and have at least one 			 * red child (it may have two). 			 */
if|if
condition|(
name|RB_BLACK_P
argument_list|(
name|brother
operator|->
name|rb_nodes
index|[
name|other
index|]
argument_list|)
condition|)
block|{
comment|/* 				 * Case 3: our brother is black, our near 				 * nephew is red, and our far nephew is black. 				 * Swap our brother with our near nephew.   				 * This result in a tree that matches case 4. 				 * (Our father could be red or black). 				 * 				 *	|    F      -->    F      | 				 *	|  x     B  -->  x   B    | 				 *	|      n    -->        n  | 				 */
name|__archive_rb_tree_reparent_nodes
argument_list|(
name|brother
argument_list|,
name|which
argument_list|)
expr_stmt|;
name|brother
operator|=
name|parent
operator|->
name|rb_nodes
index|[
name|other
index|]
expr_stmt|;
block|}
comment|/* 			 * Case 4: our brother is black and our far nephew 			 * is red.  Swap our father and brother locations and 			 * change our far nephew to black.  (these can be 			 * done in either order so we change the color first). 			 * The result is a valid red-black tree and is a 			 * terminal case.  (again we don't care about the 			 * father's color) 			 * 			 * If the father is red, we will get a red-black-black 			 * tree: 			 *	|  f      ->  f      -->    b    | 			 *	|    B    ->    B    -->  F   N  | 			 *	|      n  ->      N  -->         | 			 * 			 * If the father is black, we will get an all black 			 * tree: 			 *	|  F      ->  F      -->    B    | 			 *	|    B    ->    B    -->  F   N  | 			 *	|      n  ->      N  -->         | 			 * 			 * If we had two red nephews, then after the swap, 			 * our former father would have a red grandson.  			 */
name|RB_MARK_BLACK
argument_list|(
name|brother
operator|->
name|rb_nodes
index|[
name|other
index|]
argument_list|)
expr_stmt|;
name|__archive_rb_tree_reparent_nodes
argument_list|(
name|parent
argument_list|,
name|other
argument_list|)
expr_stmt|;
break|break;
comment|/* We're done! */
block|}
block|}
block|}
end_function

begin_function
name|struct
name|archive_rb_node
modifier|*
name|__archive_rb_tree_iterate
parameter_list|(
name|struct
name|archive_rb_tree
modifier|*
name|rbt
parameter_list|,
name|struct
name|archive_rb_node
modifier|*
name|self
parameter_list|,
specifier|const
name|unsigned
name|int
name|direction
parameter_list|)
block|{
specifier|const
name|unsigned
name|int
name|other
init|=
name|direction
operator|^
name|RB_DIR_OTHER
decl_stmt|;
if|if
condition|(
name|self
operator|==
name|NULL
condition|)
block|{
name|self
operator|=
name|rbt
operator|->
name|rbt_root
expr_stmt|;
if|if
condition|(
name|RB_SENTINEL_P
argument_list|(
name|self
argument_list|)
condition|)
return|return
name|NULL
return|;
while|while
condition|(
operator|!
name|RB_SENTINEL_P
argument_list|(
name|self
operator|->
name|rb_nodes
index|[
name|direction
index|]
argument_list|)
condition|)
name|self
operator|=
name|self
operator|->
name|rb_nodes
index|[
name|direction
index|]
expr_stmt|;
return|return
name|self
return|;
block|}
comment|/* 	 * We can't go any further in this direction.  We proceed up in the 	 * opposite direction until our parent is in direction we want to go. 	 */
if|if
condition|(
name|RB_SENTINEL_P
argument_list|(
name|self
operator|->
name|rb_nodes
index|[
name|direction
index|]
argument_list|)
condition|)
block|{
while|while
condition|(
operator|!
name|RB_ROOT_P
argument_list|(
name|rbt
argument_list|,
name|self
argument_list|)
condition|)
block|{
if|if
condition|(
name|other
operator|==
operator|(
name|unsigned
name|int
operator|)
name|RB_POSITION
argument_list|(
name|self
argument_list|)
condition|)
return|return
name|RB_FATHER
argument_list|(
name|self
argument_list|)
return|;
name|self
operator|=
name|RB_FATHER
argument_list|(
name|self
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
comment|/* 	 * Advance down one in current direction and go down as far as possible 	 * in the opposite direction. 	 */
name|self
operator|=
name|self
operator|->
name|rb_nodes
index|[
name|direction
index|]
expr_stmt|;
while|while
condition|(
operator|!
name|RB_SENTINEL_P
argument_list|(
name|self
operator|->
name|rb_nodes
index|[
name|other
index|]
argument_list|)
condition|)
name|self
operator|=
name|self
operator|->
name|rb_nodes
index|[
name|other
index|]
expr_stmt|;
return|return
name|self
return|;
block|}
end_function

end_unit

