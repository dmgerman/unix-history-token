begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 Michihiro NAKAJIMA  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"archive_platform.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ERRNO_H
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_BZLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<bzlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LZMA_H
end_ifdef

begin_include
include|#
directive|include
file|<lzma.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"archive.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry_locale.h"
end_include

begin_include
include|#
directive|include
file|"archive_ppmd7_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_read_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_endian.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_ZLIB_H
end_ifndef

begin_include
include|#
directive|include
file|"archive_crc32.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|_7ZIP_SIGNATURE
value|"7z\xBC\xAF\x27\x1C"
end_define

begin_define
define|#
directive|define
name|SFX_MIN_ADDR
value|0x27000
end_define

begin_define
define|#
directive|define
name|SFX_MAX_ADDR
value|0x60000
end_define

begin_comment
comment|/*  * Codec ID  */
end_comment

begin_define
define|#
directive|define
name|_7Z_COPY
value|0
end_define

begin_define
define|#
directive|define
name|_7Z_LZMA
value|0x030101
end_define

begin_define
define|#
directive|define
name|_7Z_LZMA2
value|0x21
end_define

begin_define
define|#
directive|define
name|_7Z_DEFLATE
value|0x040108
end_define

begin_define
define|#
directive|define
name|_7Z_BZ2
value|0x040202
end_define

begin_define
define|#
directive|define
name|_7Z_PPMD
value|0x030401
end_define

begin_define
define|#
directive|define
name|_7Z_DELTA
value|0x03
end_define

begin_define
define|#
directive|define
name|_7Z_CRYPTO
value|0x06F10701
end_define

begin_define
define|#
directive|define
name|_7Z_X86
value|0x03030103
end_define

begin_define
define|#
directive|define
name|_7Z_X86_BCJ2
value|0x0303011B
end_define

begin_define
define|#
directive|define
name|_7Z_POWERPC
value|0x03030205
end_define

begin_define
define|#
directive|define
name|_7Z_IA64
value|0x03030401
end_define

begin_define
define|#
directive|define
name|_7Z_ARM
value|0x03030501
end_define

begin_define
define|#
directive|define
name|_7Z_ARMTHUMB
value|0x03030701
end_define

begin_define
define|#
directive|define
name|_7Z_SPARC
value|0x03030805
end_define

begin_comment
comment|/*  * 7-Zip header property IDs.  */
end_comment

begin_define
define|#
directive|define
name|kEnd
value|0x00
end_define

begin_define
define|#
directive|define
name|kHeader
value|0x01
end_define

begin_define
define|#
directive|define
name|kArchiveProperties
value|0x02
end_define

begin_define
define|#
directive|define
name|kAdditionalStreamsInfo
value|0x03
end_define

begin_define
define|#
directive|define
name|kMainStreamsInfo
value|0x04
end_define

begin_define
define|#
directive|define
name|kFilesInfo
value|0x05
end_define

begin_define
define|#
directive|define
name|kPackInfo
value|0x06
end_define

begin_define
define|#
directive|define
name|kUnPackInfo
value|0x07
end_define

begin_define
define|#
directive|define
name|kSubStreamsInfo
value|0x08
end_define

begin_define
define|#
directive|define
name|kSize
value|0x09
end_define

begin_define
define|#
directive|define
name|kCRC
value|0x0A
end_define

begin_define
define|#
directive|define
name|kFolder
value|0x0B
end_define

begin_define
define|#
directive|define
name|kCodersUnPackSize
value|0x0C
end_define

begin_define
define|#
directive|define
name|kNumUnPackStream
value|0x0D
end_define

begin_define
define|#
directive|define
name|kEmptyStream
value|0x0E
end_define

begin_define
define|#
directive|define
name|kEmptyFile
value|0x0F
end_define

begin_define
define|#
directive|define
name|kAnti
value|0x10
end_define

begin_define
define|#
directive|define
name|kName
value|0x11
end_define

begin_define
define|#
directive|define
name|kCTime
value|0x12
end_define

begin_define
define|#
directive|define
name|kATime
value|0x13
end_define

begin_define
define|#
directive|define
name|kMTime
value|0x14
end_define

begin_define
define|#
directive|define
name|kAttributes
value|0x15
end_define

begin_define
define|#
directive|define
name|kEncodedHeader
value|0x17
end_define

begin_struct
struct|struct
name|_7z_digests
block|{
name|unsigned
name|char
modifier|*
name|defineds
decl_stmt|;
name|uint32_t
modifier|*
name|digests
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|_7z_folder
block|{
name|uint64_t
name|numCoders
decl_stmt|;
struct|struct
name|_7z_coder
block|{
name|unsigned
name|long
name|codec
decl_stmt|;
name|uint64_t
name|numInStreams
decl_stmt|;
name|uint64_t
name|numOutStreams
decl_stmt|;
name|uint64_t
name|propertiesSize
decl_stmt|;
name|unsigned
name|char
modifier|*
name|properties
decl_stmt|;
block|}
modifier|*
name|coders
struct|;
name|uint64_t
name|numBindPairs
decl_stmt|;
struct|struct
block|{
name|uint64_t
name|inIndex
decl_stmt|;
name|uint64_t
name|outIndex
decl_stmt|;
block|}
modifier|*
name|bindPairs
struct|;
name|uint64_t
name|numPackedStreams
decl_stmt|;
name|uint64_t
modifier|*
name|packedStreams
decl_stmt|;
name|uint64_t
name|numInStreams
decl_stmt|;
name|uint64_t
name|numOutStreams
decl_stmt|;
name|uint64_t
modifier|*
name|unPackSize
decl_stmt|;
name|unsigned
name|char
name|digest_defined
decl_stmt|;
name|uint32_t
name|digest
decl_stmt|;
name|uint64_t
name|numUnpackStreams
decl_stmt|;
name|uint32_t
name|packIndex
decl_stmt|;
comment|/* Unoperated bytes. */
name|uint64_t
name|skipped_bytes
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|_7z_coders_info
block|{
name|uint64_t
name|numFolders
decl_stmt|;
name|struct
name|_7z_folder
modifier|*
name|folders
decl_stmt|;
name|uint64_t
name|dataStreamIndex
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|_7z_pack_info
block|{
name|uint64_t
name|pos
decl_stmt|;
name|uint64_t
name|numPackStreams
decl_stmt|;
name|uint64_t
modifier|*
name|sizes
decl_stmt|;
name|struct
name|_7z_digests
name|digest
decl_stmt|;
comment|/* Calculated from pos and numPackStreams. */
name|uint64_t
modifier|*
name|positions
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|_7z_substream_info
block|{
name|size_t
name|unpack_streams
decl_stmt|;
name|uint64_t
modifier|*
name|unpackSizes
decl_stmt|;
name|unsigned
name|char
modifier|*
name|digestsDefined
decl_stmt|;
name|uint32_t
modifier|*
name|digests
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|_7z_stream_info
block|{
name|struct
name|_7z_pack_info
name|pi
decl_stmt|;
name|struct
name|_7z_coders_info
name|ci
decl_stmt|;
name|struct
name|_7z_substream_info
name|ss
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|_7z_header_info
block|{
name|uint64_t
name|dataIndex
decl_stmt|;
name|unsigned
name|char
modifier|*
name|emptyStreamBools
decl_stmt|;
name|unsigned
name|char
modifier|*
name|emptyFileBools
decl_stmt|;
name|unsigned
name|char
modifier|*
name|antiBools
decl_stmt|;
name|unsigned
name|char
modifier|*
name|attrBools
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|_7zip_entry
block|{
name|size_t
name|name_len
decl_stmt|;
name|unsigned
name|char
modifier|*
name|utf16name
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_DEBUG
argument_list|)
specifier|const
name|wchar_t
modifier|*
name|wname
decl_stmt|;
endif|#
directive|endif
name|uint32_t
name|folderIndex
decl_stmt|;
name|uint32_t
name|ssIndex
decl_stmt|;
name|unsigned
name|flg
decl_stmt|;
define|#
directive|define
name|MTIME_IS_SET
value|(1<<0)
define|#
directive|define
name|ATIME_IS_SET
value|(1<<1)
define|#
directive|define
name|CTIME_IS_SET
value|(1<<2)
define|#
directive|define
name|CRC32_IS_SET
value|(1<<3)
define|#
directive|define
name|HAS_STREAM
value|(1<<4)
name|time_t
name|mtime
decl_stmt|;
name|time_t
name|atime
decl_stmt|;
name|time_t
name|ctime
decl_stmt|;
name|long
name|mtime_ns
decl_stmt|;
name|long
name|atime_ns
decl_stmt|;
name|long
name|ctime_ns
decl_stmt|;
name|uint32_t
name|mode
decl_stmt|;
name|uint32_t
name|attr
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|_7zip
block|{
comment|/* Structural information about the archive. */
name|struct
name|_7z_stream_info
name|si
decl_stmt|;
name|int
name|header_is_being_read
decl_stmt|;
name|int
name|header_is_encoded
decl_stmt|;
name|uint64_t
name|header_bytes_remaining
decl_stmt|;
name|unsigned
name|long
name|header_crc32
decl_stmt|;
comment|/* Header offset to check that reading pointes of the file contens 	 * will not exceed the header. */
name|uint64_t
name|header_offset
decl_stmt|;
comment|/* Base offset of the archive file for a seek in case reading SFX. */
name|uint64_t
name|seek_base
decl_stmt|;
comment|/* List of entries */
name|size_t
name|entries_remaining
decl_stmt|;
name|uint64_t
name|numFiles
decl_stmt|;
name|struct
name|_7zip_entry
modifier|*
name|entries
decl_stmt|;
name|struct
name|_7zip_entry
modifier|*
name|entry
decl_stmt|;
name|unsigned
name|char
modifier|*
name|entry_names
decl_stmt|;
comment|/* entry_bytes_remaining is the number of bytes we expect. */
name|int64_t
name|entry_offset
decl_stmt|;
name|uint64_t
name|entry_bytes_remaining
decl_stmt|;
comment|/* Running CRC32 of the decompressed data */
name|unsigned
name|long
name|entry_crc32
decl_stmt|;
comment|/* Flags to mark progress of decompression. */
name|char
name|end_of_entry
decl_stmt|;
comment|/* Uncompressed buffer control.  */
define|#
directive|define
name|UBUFF_SIZE
value|(64 * 1024)
name|unsigned
name|char
modifier|*
name|uncompressed_buffer
decl_stmt|;
name|unsigned
name|char
modifier|*
name|uncompressed_buffer_pointer
decl_stmt|;
name|size_t
name|uncompressed_buffer_size
decl_stmt|;
name|size_t
name|uncompressed_buffer_bytes_remaining
decl_stmt|;
comment|/* Offset of the compressed data. */
name|int64_t
name|stream_offset
decl_stmt|;
comment|/* 	 * Decompressing control data. 	 */
name|unsigned
name|folder_index
decl_stmt|;
name|uint64_t
name|folder_outbytes_remaining
decl_stmt|;
name|unsigned
name|pack_stream_index
decl_stmt|;
name|unsigned
name|pack_stream_remaining
decl_stmt|;
name|uint64_t
name|pack_stream_inbytes_remaining
decl_stmt|;
name|size_t
name|pack_stream_bytes_unconsumed
decl_stmt|;
comment|/* The codec information of a folder. */
name|unsigned
name|long
name|codec
decl_stmt|;
name|unsigned
name|long
name|codec2
decl_stmt|;
comment|/* 	 * Decompressor controllers. 	 */
comment|/* Decording LZMA1 and LZMA2 data. */
ifdef|#
directive|ifdef
name|HAVE_LZMA_H
name|lzma_stream
name|lzstream
decl_stmt|;
name|int
name|lzstream_valid
decl_stmt|;
endif|#
directive|endif
comment|/* Decording bzip2 data. */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_BZLIB_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|BZ_CONFIG_ERROR
argument_list|)
name|bz_stream
name|bzstream
decl_stmt|;
name|int
name|bzstream_valid
decl_stmt|;
endif|#
directive|endif
comment|/* Decording deflate data. */
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
name|z_stream
name|stream
decl_stmt|;
name|int
name|stream_valid
decl_stmt|;
endif|#
directive|endif
comment|/* Decording PPMd data. */
name|int
name|ppmd7_stat
decl_stmt|;
name|CPpmd7
name|ppmd7_context
decl_stmt|;
name|CPpmd7z_RangeDec
name|range_dec
decl_stmt|;
name|IByteIn
name|bytein
decl_stmt|;
struct|struct
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|next_in
decl_stmt|;
name|int64_t
name|avail_in
decl_stmt|;
name|int64_t
name|total_in
decl_stmt|;
name|unsigned
name|char
modifier|*
name|next_out
decl_stmt|;
name|int64_t
name|avail_out
decl_stmt|;
name|int64_t
name|total_out
decl_stmt|;
name|int
name|overconsumed
decl_stmt|;
block|}
name|ppstream
struct|;
name|int
name|ppmd7_valid
decl_stmt|;
comment|/* Decoding BCJ and BCJ2 data. */
name|uint32_t
name|bcj_state
decl_stmt|;
name|size_t
name|odd_bcj_size
decl_stmt|;
name|unsigned
name|char
name|odd_bcj
index|[
literal|4
index|]
decl_stmt|;
comment|/* Decoding BCJ data. */
name|size_t
name|bcj_prevPosT
decl_stmt|;
name|uint32_t
name|bcj_prevMask
decl_stmt|;
name|uint32_t
name|bcj_ip
decl_stmt|;
comment|/* Decoding BCJ2 data. */
name|size_t
name|main_stream_bytes_remaining
decl_stmt|;
name|unsigned
name|char
modifier|*
name|sub_stream_buff
index|[
literal|3
index|]
decl_stmt|;
name|size_t
name|sub_stream_size
index|[
literal|3
index|]
decl_stmt|;
name|size_t
name|sub_stream_bytes_remaining
index|[
literal|3
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|tmp_stream_buff
decl_stmt|;
name|size_t
name|tmp_stream_buff_size
decl_stmt|;
name|size_t
name|tmp_stream_bytes_avail
decl_stmt|;
name|size_t
name|tmp_stream_bytes_remaining
decl_stmt|;
ifdef|#
directive|ifdef
name|_LZMA_PROB32
define|#
directive|define
name|CProb
value|uint32_t
else|#
directive|else
define|#
directive|define
name|CProb
value|uint16_t
endif|#
directive|endif
name|CProb
name|bcj2_p
index|[
literal|256
operator|+
literal|2
index|]
decl_stmt|;
name|uint8_t
name|bcj2_prevByte
decl_stmt|;
name|uint32_t
name|bcj2_range
decl_stmt|;
name|uint32_t
name|bcj2_code
decl_stmt|;
name|uint64_t
name|bcj2_outPos
decl_stmt|;
comment|/* Filename character-set conversion data. */
name|struct
name|archive_string_conv
modifier|*
name|sconv
decl_stmt|;
name|char
name|format_name
index|[
literal|64
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|archive_read_format_7zip_bid
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_7zip_cleanup
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_7zip_read_data
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|int64_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_7zip_read_data_skip
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_7zip_read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_7zip_header_in_sfx
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|decode_codec_id
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|decode_encoded_header_info
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|_7z_stream_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|decompress
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|_7zip
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssize_t
name|extract_pack_stream
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fileTimeToUtc
parameter_list|(
name|uint64_t
parameter_list|,
name|time_t
modifier|*
parameter_list|,
name|long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|folder_uncompressed_size
parameter_list|(
name|struct
name|_7z_folder
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_CodersInfo
parameter_list|(
name|struct
name|_7z_coders_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_Digest
parameter_list|(
name|struct
name|_7z_digests
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_Folder
parameter_list|(
name|struct
name|_7z_folder
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_Header
parameter_list|(
name|struct
name|_7z_header_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_PackInfo
parameter_list|(
name|struct
name|_7z_pack_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_StreamsInfo
parameter_list|(
name|struct
name|_7z_stream_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_SubStreamsInfo
parameter_list|(
name|struct
name|_7z_substream_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|free_decompression
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|_7zip
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssize_t
name|get_uncompressed_data
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|header_bytes
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|init_decompression
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|_7zip
modifier|*
parameter_list|,
specifier|const
name|struct
name|_7z_coder
modifier|*
parameter_list|,
specifier|const
name|struct
name|_7z_coder
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_7zip_uint64
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|uint64_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_Bools
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_CodersInfo
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|_7z_coders_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_Digests
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|_7z_digests
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_Folder
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|_7z_folder
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_Header
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|_7z_header_info
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_PackInfo
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|_7z_pack_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_StreamsInfo
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|_7z_stream_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_SubStreamsInfo
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|_7z_substream_info
modifier|*
parameter_list|,
name|struct
name|_7z_folder
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_Times
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|_7z_header_info
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_consume
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssize_t
name|read_stream
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|seek_pack
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|skip_stream
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|skip_sfx
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|ssize_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|slurp_central_directory
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|_7zip
modifier|*
parameter_list|,
name|struct
name|_7z_header_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|setup_decode_folder
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|_7z_folder
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|x86_Init
parameter_list|(
name|struct
name|_7zip
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|x86_Convert
parameter_list|(
name|struct
name|_7zip
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssize_t
name|Bcj2_Decode
parameter_list|(
name|struct
name|_7zip
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|archive_read_support_format_7zip
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|struct
name|_7zip
modifier|*
name|zip
decl_stmt|;
name|int
name|r
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_READ_MAGIC
argument_list|,
name|ARCHIVE_STATE_NEW
argument_list|,
literal|"archive_read_support_format_7zip"
argument_list|)
expr_stmt|;
name|zip
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate 7zip data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|r
operator|=
name|__archive_read_register_format
argument_list|(
name|a
argument_list|,
name|zip
argument_list|,
literal|"7zip"
argument_list|,
name|archive_read_format_7zip_bid
argument_list|,
name|NULL
argument_list|,
name|archive_read_format_7zip_read_header
argument_list|,
name|archive_read_format_7zip_read_data
argument_list|,
name|archive_read_format_7zip_read_data_skip
argument_list|,
name|archive_read_format_7zip_cleanup
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|free
argument_list|(
name|zip
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_7zip_bid
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|int
name|best_bid
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
comment|/* If someone has already bid more than 32, then avoid 	   trashing the look-ahead buffers with a seek. */
if|if
condition|(
name|best_bid
operator|>
literal|32
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|6
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* If first six bytes are the 7-Zip signature, 	 * return the bid right now. */
if|if
condition|(
name|memcmp
argument_list|(
name|p
argument_list|,
name|_7ZIP_SIGNATURE
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|48
operator|)
return|;
comment|/* 	 * It may a 7-Zip SFX archive file. If first two bytes are 	 * 'M' and 'Z' available on Windows or first four bytes are 	 * "\x7F\x45LF" available on posix like system, seek the 7-Zip 	 * signature. Although we will perform a seek when reading 	 * a header, what we do not use __archive_read_seek() here is 	 * due to a bidding performance. 	 */
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'M'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'Z'
operator|)
operator|||
name|memcmp
argument_list|(
name|p
argument_list|,
literal|"\x7F\x45LF"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ssize_t
name|offset
init|=
name|SFX_MIN_ADDR
decl_stmt|;
name|ssize_t
name|window
init|=
literal|4096
decl_stmt|;
name|ssize_t
name|bytes_avail
decl_stmt|;
while|while
condition|(
name|offset
operator|+
name|window
operator|<=
operator|(
name|SFX_MAX_ADDR
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|buff
init|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|offset
operator|+
name|window
argument_list|,
operator|&
name|bytes_avail
argument_list|)
decl_stmt|;
if|if
condition|(
name|buff
operator|==
name|NULL
condition|)
block|{
comment|/* Remaining bytes are less than window. */
name|window
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|window
operator|<
literal|0x40
condition|)
return|return
operator|(
literal|0
operator|)
return|;
continue|continue;
block|}
name|p
operator|=
name|buff
operator|+
name|offset
expr_stmt|;
while|while
condition|(
name|p
operator|+
literal|32
operator|<
name|buff
operator|+
name|bytes_avail
condition|)
block|{
name|int
name|step
init|=
name|check_7zip_header_in_sfx
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|step
operator|==
literal|0
condition|)
return|return
operator|(
literal|48
operator|)
return|;
name|p
operator|+=
name|step
expr_stmt|;
block|}
name|offset
operator|=
name|p
operator|-
name|buff
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_7zip_header_in_sfx
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
switch|switch
condition|(
operator|(
name|unsigned
name|char
operator|)
name|p
index|[
literal|5
index|]
condition|)
block|{
case|case
literal|0x1C
case|:
if|if
condition|(
name|memcmp
argument_list|(
name|p
argument_list|,
name|_7ZIP_SIGNATURE
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|6
operator|)
return|;
comment|/* 		 * Test the CRC because its extraction code has 7-Zip 		 * Magic Code, so we should do this in order not to 		 * make a mis-detection. 		 */
if|if
condition|(
name|crc32
argument_list|(
literal|0
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|p
operator|+
literal|12
argument_list|,
literal|20
argument_list|)
operator|!=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|8
argument_list|)
condition|)
return|return
operator|(
literal|6
operator|)
return|;
comment|/* Hit the header! */
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x37
case|:
return|return
operator|(
literal|5
operator|)
return|;
case|case
literal|0x7A
case|:
return|return
operator|(
literal|4
operator|)
return|;
case|case
literal|0xBC
case|:
return|return
operator|(
literal|3
operator|)
return|;
case|case
literal|0xAF
case|:
return|return
operator|(
literal|2
operator|)
return|;
case|case
literal|0x27
case|:
return|return
operator|(
literal|1
operator|)
return|;
default|default:
return|return
operator|(
literal|6
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|skip_sfx
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|ssize_t
name|bytes_avail
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|h
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|size_t
name|skip
decl_stmt|,
name|offset
decl_stmt|;
name|ssize_t
name|bytes
decl_stmt|,
name|window
decl_stmt|;
comment|/* 	 * If bytes_avail> SFX_MIN_ADDR we do not have to call 	 * __archive_read_seek() at this time since we have 	 * alredy had enough data. 	 */
if|if
condition|(
name|bytes_avail
operator|>
name|SFX_MIN_ADDR
condition|)
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|SFX_MIN_ADDR
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|__archive_read_seek
argument_list|(
name|a
argument_list|,
name|SFX_MIN_ADDR
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|offset
operator|=
literal|0
expr_stmt|;
name|window
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|offset
operator|+
name|window
operator|<=
name|SFX_MAX_ADDR
operator|-
name|SFX_MIN_ADDR
condition|)
block|{
name|h
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|window
argument_list|,
operator|&
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
comment|/* Remaining bytes are less than window. */
name|window
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|window
operator|<
literal|0x40
condition|)
goto|goto
name|fatal
goto|;
continue|continue;
block|}
if|if
condition|(
name|bytes
operator|<
literal|6
condition|)
block|{
comment|/* This case might happen when window == 1. */
name|window
operator|=
literal|4096
expr_stmt|;
continue|continue;
block|}
name|p
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|h
expr_stmt|;
name|q
operator|=
name|p
operator|+
name|bytes
expr_stmt|;
comment|/* 		 * Scan ahead until we find something that looks 		 * like the 7-Zip header. 		 */
while|while
condition|(
name|p
operator|+
literal|32
operator|<
name|q
condition|)
block|{
name|int
name|step
init|=
name|check_7zip_header_in_sfx
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|step
operator|==
literal|0
condition|)
block|{
name|struct
name|_7zip
modifier|*
name|zip
init|=
operator|(
expr|struct
name|_7zip
operator|*
operator|)
name|a
operator|->
name|format
operator|->
name|data
decl_stmt|;
name|skip
operator|=
name|p
operator|-
operator|(
specifier|const
name|char
operator|*
operator|)
name|h
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|skip
argument_list|)
expr_stmt|;
name|zip
operator|->
name|seek_base
operator|=
name|SFX_MIN_ADDR
operator|+
name|offset
operator|+
name|skip
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
name|p
operator|+=
name|step
expr_stmt|;
block|}
name|skip
operator|=
name|p
operator|-
operator|(
specifier|const
name|char
operator|*
operator|)
name|h
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|skip
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|skip
expr_stmt|;
if|if
condition|(
name|window
operator|==
literal|1
condition|)
name|window
operator|=
literal|4096
expr_stmt|;
block|}
name|fatal
label|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Couldn't find out 7-Zip header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_7zip_read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|_7zip
modifier|*
name|zip
init|=
operator|(
expr|struct
name|_7zip
operator|*
operator|)
name|a
operator|->
name|format
operator|->
name|data
decl_stmt|;
name|struct
name|_7zip_entry
modifier|*
name|zip_entry
decl_stmt|;
name|int
name|r
decl_stmt|,
name|ret
init|=
name|ARCHIVE_OK
decl_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_7ZIP
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|==
name|NULL
condition|)
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"7-Zip"
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|entries
operator|==
name|NULL
condition|)
block|{
name|struct
name|_7z_header_info
name|header
decl_stmt|;
name|memset
argument_list|(
operator|&
name|header
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|header
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|slurp_central_directory
argument_list|(
name|a
argument_list|,
name|zip
argument_list|,
operator|&
name|header
argument_list|)
expr_stmt|;
name|free_Header
argument_list|(
operator|&
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|zip
operator|->
name|entries_remaining
operator|=
operator|(
name|size_t
operator|)
name|zip
operator|->
name|numFiles
expr_stmt|;
name|zip
operator|->
name|entry
operator|=
name|zip
operator|->
name|entries
expr_stmt|;
block|}
else|else
block|{
operator|++
name|zip
operator|->
name|entry
expr_stmt|;
block|}
name|zip_entry
operator|=
name|zip
operator|->
name|entry
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|entries_remaining
operator|<=
literal|0
condition|)
return|return
name|ARCHIVE_EOF
return|;
operator|--
name|zip
operator|->
name|entries_remaining
expr_stmt|;
name|zip
operator|->
name|entry_offset
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|end_of_entry
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|entry_crc32
operator|=
name|crc32
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup a string conversion for a filename. */
if|if
condition|(
name|zip
operator|->
name|sconv
operator|==
name|NULL
condition|)
block|{
name|zip
operator|->
name|sconv
operator|=
name|archive_string_conversion_from_charset
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
literal|"UTF-16LE"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|sconv
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|archive_entry_copy_pathname_l
argument_list|(
name|entry
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|zip_entry
operator|->
name|utf16name
argument_list|,
name|zip_entry
operator|->
name|name_len
argument_list|,
name|zip
operator|->
name|sconv
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for Pathname"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Pathname cannot be converted "
literal|"from %s to current locale."
argument_list|,
name|archive_string_conversion_charset_name
argument_list|(
name|zip
operator|->
name|sconv
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
comment|/* Populate some additional entry fields: */
name|archive_entry_set_mode
argument_list|(
name|entry
argument_list|,
name|zip_entry
operator|->
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip_entry
operator|->
name|flg
operator|&
name|MTIME_IS_SET
condition|)
name|archive_entry_set_mtime
argument_list|(
name|entry
argument_list|,
name|zip_entry
operator|->
name|mtime
argument_list|,
name|zip_entry
operator|->
name|mtime_ns
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip_entry
operator|->
name|flg
operator|&
name|CTIME_IS_SET
condition|)
name|archive_entry_set_ctime
argument_list|(
name|entry
argument_list|,
name|zip_entry
operator|->
name|ctime
argument_list|,
name|zip_entry
operator|->
name|ctime_ns
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip_entry
operator|->
name|flg
operator|&
name|ATIME_IS_SET
condition|)
name|archive_entry_set_atime
argument_list|(
name|entry
argument_list|,
name|zip_entry
operator|->
name|atime
argument_list|,
name|zip_entry
operator|->
name|atime_ns
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip_entry
operator|->
name|ssIndex
operator|!=
operator|(
name|uint32_t
operator|)
operator|-
literal|1
condition|)
block|{
name|zip
operator|->
name|entry_bytes_remaining
operator|=
name|zip
operator|->
name|si
operator|.
name|ss
operator|.
name|unpackSizes
index|[
name|zip_entry
operator|->
name|ssIndex
index|]
expr_stmt|;
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
name|zip
operator|->
name|entry_bytes_remaining
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zip
operator|->
name|entry_bytes_remaining
operator|=
literal|0
expr_stmt|;
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If there's no body, force read_data() to return EOF immediately. */
if|if
condition|(
name|zip
operator|->
name|entry_bytes_remaining
operator|<
literal|1
condition|)
name|zip
operator|->
name|end_of_entry
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|zip_entry
operator|->
name|mode
operator|&
name|AE_IFMT
operator|)
operator|==
name|AE_IFLNK
condition|)
block|{
name|unsigned
name|char
modifier|*
name|symname
init|=
name|NULL
decl_stmt|;
name|size_t
name|symsize
init|=
literal|0
decl_stmt|;
comment|/* 		 * Symbolic-name is recorded as its contents. We have to 		 * read the contents at this time. 		 */
while|while
condition|(
name|zip
operator|->
name|entry_bytes_remaining
operator|>
literal|0
condition|)
block|{
specifier|const
name|void
modifier|*
name|buff
decl_stmt|;
name|unsigned
name|char
modifier|*
name|mem
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int64_t
name|offset
decl_stmt|;
name|r
operator|=
name|archive_read_format_7zip_read_data
argument_list|(
name|a
argument_list|,
operator|&
name|buff
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|ARCHIVE_WARN
condition|)
block|{
name|free
argument_list|(
name|symname
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
name|mem
operator|=
name|realloc
argument_list|(
name|symname
argument_list|,
name|symsize
operator|+
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|symname
argument_list|)
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for Symname"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|symname
operator|=
name|mem
expr_stmt|;
name|memcpy
argument_list|(
name|symname
operator|+
name|symsize
argument_list|,
name|buff
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|symsize
operator|+=
name|size
expr_stmt|;
block|}
if|if
condition|(
name|symsize
operator|==
literal|0
condition|)
block|{
comment|/* If there is no synname, handle it as a regular 			 * file. */
name|zip_entry
operator|->
name|mode
operator|&=
operator|~
name|AE_IFMT
expr_stmt|;
name|zip_entry
operator|->
name|mode
operator||=
name|AE_IFREG
expr_stmt|;
name|archive_entry_set_mode
argument_list|(
name|entry
argument_list|,
name|zip_entry
operator|->
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|symname
index|[
name|symsize
index|]
operator|=
literal|'\0'
expr_stmt|;
name|archive_entry_copy_symlink
argument_list|(
name|entry
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|symname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|symname
argument_list|)
expr_stmt|;
block|}
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Set up a more descriptive format name. */
name|sprintf
argument_list|(
name|zip
operator|->
name|format_name
argument_list|,
literal|"7-Zip"
argument_list|)
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
name|zip
operator|->
name|format_name
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_7zip_read_data
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|int64_t
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|_7zip
modifier|*
name|zip
decl_stmt|;
name|ssize_t
name|bytes
decl_stmt|;
name|int
name|ret
init|=
name|ARCHIVE_OK
decl_stmt|;
name|zip
operator|=
operator|(
expr|struct
name|_7zip
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|pack_stream_bytes_unconsumed
condition|)
name|read_consume
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|/* 	 * If we hit end-of-entry last time, clean up and return 	 * ARCHIVE_EOF this time. 	 */
if|if
condition|(
name|zip
operator|->
name|end_of_entry
condition|)
block|{
operator|*
name|offset
operator|=
name|zip
operator|->
name|entry_offset
expr_stmt|;
operator|*
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|buff
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
block|}
name|bytes
operator|=
name|read_stream
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
operator|(
name|size_t
operator|)
name|zip
operator|->
name|entry_bytes_remaining
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|<
literal|0
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|bytes
operator|)
return|;
if|if
condition|(
name|bytes
operator|==
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated 7-Zip file body"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|zip
operator|->
name|entry_bytes_remaining
operator|-=
name|bytes
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|entry_bytes_remaining
operator|==
literal|0
condition|)
name|zip
operator|->
name|end_of_entry
operator|=
literal|1
expr_stmt|;
comment|/* Update checksum */
if|if
condition|(
operator|(
name|zip
operator|->
name|entry
operator|->
name|flg
operator|&
name|CRC32_IS_SET
operator|)
operator|&&
name|bytes
condition|)
name|zip
operator|->
name|entry_crc32
operator|=
name|crc32
argument_list|(
name|zip
operator|->
name|entry_crc32
argument_list|,
operator|*
name|buff
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
comment|/* If we hit the end, swallow any end-of-data marker. */
if|if
condition|(
name|zip
operator|->
name|end_of_entry
condition|)
block|{
comment|/* Check computed CRC against file contents. */
if|if
condition|(
operator|(
name|zip
operator|->
name|entry
operator|->
name|flg
operator|&
name|CRC32_IS_SET
operator|)
operator|&&
name|zip
operator|->
name|si
operator|.
name|ss
operator|.
name|digests
index|[
name|zip
operator|->
name|entry
operator|->
name|ssIndex
index|]
operator|!=
name|zip
operator|->
name|entry_crc32
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"7-Zip bad CRC: 0x%lx should be 0x%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|zip
operator|->
name|entry_crc32
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|zip
operator|->
name|si
operator|.
name|ss
operator|.
name|digests
index|[
name|zip
operator|->
name|entry
operator|->
name|ssIndex
index|]
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
block|}
operator|*
name|size
operator|=
name|bytes
expr_stmt|;
operator|*
name|offset
operator|=
name|zip
operator|->
name|entry_offset
expr_stmt|;
name|zip
operator|->
name|entry_offset
operator|+=
name|bytes
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_7zip_read_data_skip
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|_7zip
modifier|*
name|zip
decl_stmt|;
name|int64_t
name|bytes_skipped
decl_stmt|;
name|zip
operator|=
operator|(
expr|struct
name|_7zip
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|pack_stream_bytes_unconsumed
condition|)
name|read_consume
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|/* If we've already read to end of data, we're done. */
if|if
condition|(
name|zip
operator|->
name|end_of_entry
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
comment|/* 	 * If the length is at the beginning, we can skip the 	 * compressed data much more quickly. 	 */
name|bytes_skipped
operator|=
name|skip_stream
argument_list|(
name|a
argument_list|,
operator|(
name|size_t
operator|)
name|zip
operator|->
name|entry_bytes_remaining
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_skipped
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|zip
operator|->
name|entry_bytes_remaining
operator|=
literal|0
expr_stmt|;
comment|/* This entry is finished and done. */
name|zip
operator|->
name|end_of_entry
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_7zip_cleanup
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|_7zip
modifier|*
name|zip
decl_stmt|;
name|zip
operator|=
operator|(
expr|struct
name|_7zip
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
name|free_StreamsInfo
argument_list|(
operator|&
operator|(
name|zip
operator|->
name|si
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zip
operator|->
name|entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zip
operator|->
name|entry_names
argument_list|)
expr_stmt|;
name|free_decompression
argument_list|(
name|a
argument_list|,
name|zip
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zip
operator|->
name|uncompressed_buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zip
operator|->
name|sub_stream_buff
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zip
operator|->
name|sub_stream_buff
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zip
operator|->
name|sub_stream_buff
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zip
operator|->
name|tmp_stream_buff
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zip
argument_list|)
expr_stmt|;
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_consume
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|_7zip
modifier|*
name|zip
init|=
operator|(
expr|struct
name|_7zip
operator|*
operator|)
name|a
operator|->
name|format
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|zip
operator|->
name|pack_stream_bytes_unconsumed
condition|)
block|{
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|zip
operator|->
name|pack_stream_bytes_unconsumed
argument_list|)
expr_stmt|;
name|zip
operator|->
name|stream_offset
operator|+=
name|zip
operator|->
name|pack_stream_bytes_unconsumed
expr_stmt|;
name|zip
operator|->
name|pack_stream_bytes_unconsumed
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LZMA_H
end_ifdef

begin_comment
comment|/*  * Set an error code and choose an error message for liblzma.  */
end_comment

begin_function
specifier|static
name|void
name|set_error
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|int
name|ret
parameter_list|)
block|{
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|LZMA_STREAM_END
case|:
comment|/* Found end of stream. */
case|case
name|LZMA_OK
case|:
comment|/* Decompressor made some progress. */
break|break;
case|case
name|LZMA_MEM_ERROR
case|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Lzma library error: Cannot allocate memory"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LZMA_MEMLIMIT_ERROR
case|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Lzma library error: Out of memory"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LZMA_FORMAT_ERROR
case|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Lzma library error: format not recognized"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LZMA_OPTIONS_ERROR
case|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Lzma library error: Invalid options"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LZMA_DATA_ERROR
case|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Lzma library error: Corrupted input data"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LZMA_BUF_ERROR
case|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Lzma library error:  No progress is possible"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Return an error. */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Lzma decompression failed:  Unknown error"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|unsigned
name|long
name|decode_codec_id
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|codecId
parameter_list|,
name|size_t
name|id_size
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|unsigned
name|long
name|id
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|id_size
condition|;
name|i
operator|++
control|)
block|{
name|id
operator|<<=
literal|8
expr_stmt|;
name|id
operator|+=
name|codecId
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
operator|(
name|id
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|ppmd_alloc
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
operator|(
name|void
operator|)
name|p
expr_stmt|;
return|return
name|malloc
argument_list|(
name|size
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppmd_free
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|address
parameter_list|)
block|{
operator|(
name|void
operator|)
name|p
expr_stmt|;
name|free
argument_list|(
name|address
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|Byte
name|ppmd_read
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
operator|(
name|IByteIn
operator|*
operator|)
name|p
operator|)
operator|->
name|a
decl_stmt|;
name|struct
name|_7zip
modifier|*
name|zip
init|=
operator|(
expr|struct
name|_7zip
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
name|Byte
name|b
decl_stmt|;
if|if
condition|(
name|zip
operator|->
name|ppstream
operator|.
name|avail_in
operator|==
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated RAR file data"
argument_list|)
expr_stmt|;
name|zip
operator|->
name|ppstream
operator|.
name|overconsumed
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|b
operator|=
operator|*
name|zip
operator|->
name|ppstream
operator|.
name|next_in
operator|++
expr_stmt|;
name|zip
operator|->
name|ppstream
operator|.
name|avail_in
operator|--
expr_stmt|;
name|zip
operator|->
name|ppstream
operator|.
name|total_in
operator|++
expr_stmt|;
return|return
operator|(
name|b
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|ISzAlloc
name|g_szalloc
init|=
block|{
name|ppmd_alloc
block|,
name|ppmd_free
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|init_decompression
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|_7zip
modifier|*
name|zip
parameter_list|,
specifier|const
name|struct
name|_7z_coder
modifier|*
name|coder1
parameter_list|,
specifier|const
name|struct
name|_7z_coder
modifier|*
name|coder2
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|zip
operator|->
name|codec
operator|=
name|coder1
operator|->
name|codec
expr_stmt|;
name|zip
operator|->
name|codec2
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|zip
operator|->
name|codec
condition|)
block|{
case|case
name|_7Z_COPY
case|:
case|case
name|_7Z_BZ2
case|:
case|case
name|_7Z_DEFLATE
case|:
case|case
name|_7Z_PPMD
case|:
if|if
condition|(
name|coder2
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|coder2
operator|->
name|codec
operator|!=
name|_7Z_X86
operator|&&
name|coder2
operator|->
name|codec
operator|!=
name|_7Z_X86_BCJ2
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Unsupported filter %lx for %lx"
argument_list|,
name|coder2
operator|->
name|codec
argument_list|,
name|coder1
operator|->
name|codec
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|zip
operator|->
name|codec2
operator|=
name|coder2
operator|->
name|codec
expr_stmt|;
name|zip
operator|->
name|bcj_state
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|coder2
operator|->
name|codec
operator|==
name|_7Z_X86
condition|)
name|x86_Init
argument_list|(
name|zip
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|zip
operator|->
name|codec
condition|)
block|{
case|case
name|_7Z_COPY
case|:
break|break;
case|case
name|_7Z_LZMA
case|:
case|case
name|_7Z_LZMA2
case|:
ifdef|#
directive|ifdef
name|HAVE_LZMA_H
if|#
directive|if
name|LZMA_VERSION_MAJOR
operator|>=
literal|5
comment|/* Effectively disable the limiter. */
define|#
directive|define
name|LZMA_MEMLIMIT
value|UINT64_MAX
else|#
directive|else
comment|/* NOTE: This needs to check memory size which running system has. */
define|#
directive|define
name|LZMA_MEMLIMIT
value|(1U<< 30)
endif|#
directive|endif
block|{
name|lzma_options_delta
name|delta_opt
decl_stmt|;
name|lzma_filter
name|filters
index|[
name|LZMA_FILTERS_MAX
index|]
decl_stmt|;
if|#
directive|if
name|LZMA_VERSION
operator|<
literal|50000030
name|lzma_filter
modifier|*
name|ff
decl_stmt|;
endif|#
directive|endif
name|int
name|fi
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|zip
operator|->
name|lzstream_valid
condition|)
block|{
name|lzma_end
argument_list|(
operator|&
operator|(
name|zip
operator|->
name|lzstream
operator|)
argument_list|)
expr_stmt|;
name|zip
operator|->
name|lzstream_valid
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * NOTE: liblzma incompletely handle the BCJ+LZMA compressed 		 * data made by 7-Zip because 7-Zip does not add End-Of- 		 * Payload Marker(EOPM) at the end of LZMA compressed data, 		 * and so liblzma cannot know the end of the compressed data 		 * without EOPM. So consequently liblzma will not return last 		 * three or four bytes of uncompressed data because 		 * LZMA_FILTER_X86 filter does not handle input data if its 		 * data size is less than five bytes. If liblzma detect EOPM 		 * or know the uncompressed data size, liblzma will flush out 		 * the remaining that three or four bytes of uncompressed 		 * data. That is why we have to use our converting program 		 * for BCJ+LZMA. If we were able to tell the uncompressed 		 * size to liblzma when using lzma_raw_decoder() liblzma 		 * could correctly deal with BCJ+LZMA. But unfortunately 		 * there is no way to do that.  		 * Discussion about this can be found at XZ Utils forum. 		 */
if|if
condition|(
name|coder2
operator|!=
name|NULL
condition|)
block|{
name|zip
operator|->
name|codec2
operator|=
name|coder2
operator|->
name|codec
expr_stmt|;
name|filters
index|[
name|fi
index|]
operator|.
name|options
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|zip
operator|->
name|codec2
condition|)
block|{
case|case
name|_7Z_X86
case|:
if|if
condition|(
name|zip
operator|->
name|codec
operator|==
name|_7Z_LZMA2
condition|)
block|{
name|filters
index|[
name|fi
index|]
operator|.
name|id
operator|=
name|LZMA_FILTER_X86
expr_stmt|;
name|fi
operator|++
expr_stmt|;
block|}
else|else
comment|/* Use our filter. */
name|x86_Init
argument_list|(
name|zip
argument_list|)
expr_stmt|;
break|break;
case|case
name|_7Z_X86_BCJ2
case|:
comment|/* Use our filter. */
name|zip
operator|->
name|bcj_state
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|_7Z_DELTA
case|:
name|filters
index|[
name|fi
index|]
operator|.
name|id
operator|=
name|LZMA_FILTER_DELTA
expr_stmt|;
name|memset
argument_list|(
operator|&
name|delta_opt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|delta_opt
argument_list|)
argument_list|)
expr_stmt|;
name|delta_opt
operator|.
name|type
operator|=
name|LZMA_DELTA_TYPE_BYTE
expr_stmt|;
name|delta_opt
operator|.
name|dist
operator|=
literal|1
expr_stmt|;
name|filters
index|[
name|fi
index|]
operator|.
name|options
operator|=
operator|&
name|delta_opt
expr_stmt|;
name|fi
operator|++
expr_stmt|;
break|break;
comment|/* Following filters have not been tested yet. */
case|case
name|_7Z_POWERPC
case|:
name|filters
index|[
name|fi
index|]
operator|.
name|id
operator|=
name|LZMA_FILTER_POWERPC
expr_stmt|;
name|fi
operator|++
expr_stmt|;
break|break;
case|case
name|_7Z_IA64
case|:
name|filters
index|[
name|fi
index|]
operator|.
name|id
operator|=
name|LZMA_FILTER_IA64
expr_stmt|;
name|fi
operator|++
expr_stmt|;
break|break;
case|case
name|_7Z_ARM
case|:
name|filters
index|[
name|fi
index|]
operator|.
name|id
operator|=
name|LZMA_FILTER_ARM
expr_stmt|;
name|fi
operator|++
expr_stmt|;
break|break;
case|case
name|_7Z_ARMTHUMB
case|:
name|filters
index|[
name|fi
index|]
operator|.
name|id
operator|=
name|LZMA_FILTER_ARMTHUMB
expr_stmt|;
name|fi
operator|++
expr_stmt|;
break|break;
case|case
name|_7Z_SPARC
case|:
name|filters
index|[
name|fi
index|]
operator|.
name|id
operator|=
name|LZMA_FILTER_SPARC
expr_stmt|;
name|fi
operator|++
expr_stmt|;
break|break;
default|default:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Unexpected codec ID: %lX"
argument_list|,
name|zip
operator|->
name|codec2
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
block|}
if|if
condition|(
name|zip
operator|->
name|codec
operator|==
name|_7Z_LZMA2
condition|)
name|filters
index|[
name|fi
index|]
operator|.
name|id
operator|=
name|LZMA_FILTER_LZMA2
expr_stmt|;
else|else
name|filters
index|[
name|fi
index|]
operator|.
name|id
operator|=
name|LZMA_FILTER_LZMA1
expr_stmt|;
name|filters
index|[
name|fi
index|]
operator|.
name|options
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|LZMA_VERSION
operator|<
literal|50000030
name|ff
operator|=
operator|&
name|filters
index|[
name|fi
index|]
expr_stmt|;
endif|#
directive|endif
name|r
operator|=
name|lzma_properties_decode
argument_list|(
operator|&
name|filters
index|[
name|fi
index|]
argument_list|,
name|NULL
argument_list|,
name|coder1
operator|->
name|properties
argument_list|,
operator|(
name|size_t
operator|)
name|coder1
operator|->
name|propertiesSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|LZMA_OK
condition|)
block|{
name|set_error
argument_list|(
name|a
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|fi
operator|++
expr_stmt|;
name|filters
index|[
name|fi
index|]
operator|.
name|id
operator|=
name|LZMA_VLI_UNKNOWN
expr_stmt|;
name|filters
index|[
name|fi
index|]
operator|.
name|options
operator|=
name|NULL
expr_stmt|;
name|r
operator|=
name|lzma_raw_decoder
argument_list|(
operator|&
operator|(
name|zip
operator|->
name|lzstream
operator|)
argument_list|,
name|filters
argument_list|)
expr_stmt|;
if|#
directive|if
name|LZMA_VERSION
operator|<
literal|50000030
name|free
argument_list|(
name|ff
operator|->
name|options
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|r
operator|!=
name|LZMA_OK
condition|)
block|{
name|set_error
argument_list|(
name|a
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|zip
operator|->
name|lzstream_valid
operator|=
literal|1
expr_stmt|;
name|zip
operator|->
name|lzstream
operator|.
name|total_in
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|lzstream
operator|.
name|total_out
operator|=
literal|0
expr_stmt|;
break|break;
block|}
else|#
directive|else
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"LZMA codec is unsupported"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
endif|#
directive|endif
case|case
name|_7Z_BZ2
case|:
if|#
directive|if
name|defined
argument_list|(
name|HAVE_BZLIB_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|BZ_CONFIG_ERROR
argument_list|)
if|if
condition|(
name|zip
operator|->
name|bzstream_valid
condition|)
block|{
name|BZ2_bzDecompressEnd
argument_list|(
operator|&
operator|(
name|zip
operator|->
name|bzstream
operator|)
argument_list|)
expr_stmt|;
name|zip
operator|->
name|bzstream_valid
operator|=
literal|0
expr_stmt|;
block|}
name|r
operator|=
name|BZ2_bzDecompressInit
argument_list|(
operator|&
operator|(
name|zip
operator|->
name|bzstream
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|BZ_MEM_ERROR
condition|)
name|r
operator|=
name|BZ2_bzDecompressInit
argument_list|(
operator|&
operator|(
name|zip
operator|->
name|bzstream
operator|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|BZ_OK
condition|)
block|{
name|int
name|err
init|=
name|ARCHIVE_ERRNO_MISC
decl_stmt|;
specifier|const
name|char
modifier|*
name|detail
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|BZ_PARAM_ERROR
case|:
name|detail
operator|=
literal|"invalid setup parameter"
expr_stmt|;
break|break;
case|case
name|BZ_MEM_ERROR
case|:
name|err
operator|=
name|ENOMEM
expr_stmt|;
name|detail
operator|=
literal|"out of memory"
expr_stmt|;
break|break;
case|case
name|BZ_CONFIG_ERROR
case|:
name|detail
operator|=
literal|"mis-compiled library"
expr_stmt|;
break|break;
block|}
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|err
argument_list|,
literal|"Internal error initializing decompressor: %s"
argument_list|,
name|detail
operator|==
name|NULL
condition|?
literal|"??"
else|:
name|detail
argument_list|)
expr_stmt|;
name|zip
operator|->
name|bzstream_valid
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|zip
operator|->
name|bzstream_valid
operator|=
literal|1
expr_stmt|;
name|zip
operator|->
name|bzstream
operator|.
name|total_in_lo32
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|bzstream
operator|.
name|total_in_hi32
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|bzstream
operator|.
name|total_out_lo32
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|bzstream
operator|.
name|total_out_hi32
operator|=
literal|0
expr_stmt|;
break|break;
else|#
directive|else
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"BZ2 codec is unsupported"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
endif|#
directive|endif
case|case
name|_7Z_DEFLATE
case|:
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
if|if
condition|(
name|zip
operator|->
name|stream_valid
condition|)
name|r
operator|=
name|inflateReset
argument_list|(
operator|&
operator|(
name|zip
operator|->
name|stream
operator|)
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|inflateInit2
argument_list|(
operator|&
operator|(
name|zip
operator|->
name|stream
operator|)
argument_list|,
operator|-
literal|15
comment|/* Don't check for zlib header */
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|Z_OK
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Couldn't initialize zlib stream."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|zip
operator|->
name|stream_valid
operator|=
literal|1
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|total_in
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|total_out
operator|=
literal|0
expr_stmt|;
break|break;
else|#
directive|else
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"DEFLATE codec is unsupported"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
endif|#
directive|endif
case|case
name|_7Z_PPMD
case|:
block|{
name|unsigned
name|order
decl_stmt|;
name|uint32_t
name|msize
decl_stmt|;
if|if
condition|(
name|zip
operator|->
name|ppmd7_valid
condition|)
block|{
name|__archive_ppmd7_functions
operator|.
name|Ppmd7_Free
argument_list|(
operator|&
name|zip
operator|->
name|ppmd7_context
argument_list|,
operator|&
name|g_szalloc
argument_list|)
expr_stmt|;
name|zip
operator|->
name|ppmd7_valid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|coder1
operator|->
name|propertiesSize
operator|<
literal|5
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Malformed PPMd parameter"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|order
operator|=
name|coder1
operator|->
name|properties
index|[
literal|0
index|]
expr_stmt|;
name|msize
operator|=
name|archive_le32dec
argument_list|(
operator|&
operator|(
name|coder1
operator|->
name|properties
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|order
operator|<
name|PPMD7_MIN_ORDER
operator|||
name|order
operator|>
name|PPMD7_MAX_ORDER
operator|||
name|msize
operator|<
name|PPMD7_MIN_MEM_SIZE
operator|||
name|msize
operator|>
name|PPMD7_MAX_MEM_SIZE
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Malformed PPMd parameter"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|__archive_ppmd7_functions
operator|.
name|Ppmd7_Construct
argument_list|(
operator|&
name|zip
operator|->
name|ppmd7_context
argument_list|)
expr_stmt|;
name|r
operator|=
name|__archive_ppmd7_functions
operator|.
name|Ppmd7_Alloc
argument_list|(
operator|&
name|zip
operator|->
name|ppmd7_context
argument_list|,
name|msize
argument_list|,
operator|&
name|g_szalloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Coludn't allocate memory for PPMd"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|__archive_ppmd7_functions
operator|.
name|Ppmd7_Init
argument_list|(
operator|&
name|zip
operator|->
name|ppmd7_context
argument_list|,
name|order
argument_list|)
expr_stmt|;
name|__archive_ppmd7_functions
operator|.
name|Ppmd7z_RangeDec_CreateVTable
argument_list|(
operator|&
name|zip
operator|->
name|range_dec
argument_list|)
expr_stmt|;
name|zip
operator|->
name|ppmd7_valid
operator|=
literal|1
expr_stmt|;
name|zip
operator|->
name|ppmd7_stat
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|ppstream
operator|.
name|overconsumed
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|ppstream
operator|.
name|total_in
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|ppstream
operator|.
name|total_out
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|_7Z_X86
case|:
case|case
name|_7Z_X86_BCJ2
case|:
case|case
name|_7Z_POWERPC
case|:
case|case
name|_7Z_IA64
case|:
case|case
name|_7Z_ARM
case|:
case|case
name|_7Z_ARMTHUMB
case|:
case|case
name|_7Z_SPARC
case|:
case|case
name|_7Z_DELTA
case|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Unexpected codec ID: %lX"
argument_list|,
name|zip
operator|->
name|codec
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
default|default:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Unknown codec ID: %lX"
argument_list|,
name|zip
operator|->
name|codec
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|decompress
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|_7zip
modifier|*
name|zip
parameter_list|,
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|outbytes
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|,
name|size_t
modifier|*
name|used
parameter_list|)
block|{
specifier|const
name|uint8_t
modifier|*
name|t_next_in
decl_stmt|;
name|uint8_t
modifier|*
name|t_next_out
decl_stmt|;
name|size_t
name|o_avail_in
decl_stmt|,
name|o_avail_out
decl_stmt|;
name|size_t
name|t_avail_in
decl_stmt|,
name|t_avail_out
decl_stmt|;
name|uint8_t
modifier|*
name|bcj2_next_out
decl_stmt|;
name|size_t
name|bcj2_avail_out
decl_stmt|;
name|int
name|r
decl_stmt|,
name|ret
init|=
name|ARCHIVE_OK
decl_stmt|;
name|t_avail_in
operator|=
name|o_avail_in
operator|=
operator|*
name|used
expr_stmt|;
name|t_avail_out
operator|=
name|o_avail_out
operator|=
operator|*
name|outbytes
expr_stmt|;
name|t_next_in
operator|=
name|b
expr_stmt|;
name|t_next_out
operator|=
name|buff
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|codec
operator|!=
name|_7Z_LZMA2
operator|&&
name|zip
operator|->
name|codec2
operator|==
name|_7Z_X86
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Do not copy out the BCJ remaining bytes when the output 		 * buffer size is less than five bytes. */
if|if
condition|(
name|o_avail_in
operator|!=
literal|0
operator|&&
name|t_avail_out
operator|<
literal|5
operator|&&
name|zip
operator|->
name|odd_bcj_size
condition|)
block|{
operator|*
name|used
operator|=
literal|0
expr_stmt|;
operator|*
name|outbytes
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|zip
operator|->
name|odd_bcj_size
operator|>
literal|0
operator|&&
name|t_avail_out
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|t_next_out
operator|++
operator|=
name|zip
operator|->
name|odd_bcj
index|[
name|i
index|]
expr_stmt|;
name|t_avail_out
operator|--
expr_stmt|;
name|zip
operator|->
name|odd_bcj_size
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|o_avail_in
operator|==
literal|0
operator|||
name|t_avail_out
operator|==
literal|0
condition|)
block|{
operator|*
name|used
operator|=
name|o_avail_in
operator|-
name|t_avail_in
expr_stmt|;
operator|*
name|outbytes
operator|=
name|o_avail_out
operator|-
name|t_avail_out
expr_stmt|;
if|if
condition|(
name|o_avail_in
operator|==
literal|0
condition|)
name|ret
operator|=
name|ARCHIVE_EOF
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
name|bcj2_next_out
operator|=
name|t_next_out
expr_stmt|;
name|bcj2_avail_out
operator|=
name|t_avail_out
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|codec2
operator|==
name|_7Z_X86_BCJ2
condition|)
block|{
comment|/* 		 * Decord a remaining decompressed main stream for BCJ2. 		 */
if|if
condition|(
name|zip
operator|->
name|tmp_stream_bytes_remaining
condition|)
block|{
name|ssize_t
name|bytes
decl_stmt|;
name|size_t
name|remaining
init|=
name|zip
operator|->
name|tmp_stream_bytes_remaining
decl_stmt|;
name|bytes
operator|=
name|Bcj2_Decode
argument_list|(
name|zip
argument_list|,
name|t_next_out
argument_list|,
name|t_avail_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"BCJ2 conversion Failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|zip
operator|->
name|main_stream_bytes_remaining
operator|-=
name|remaining
operator|-
name|zip
operator|->
name|tmp_stream_bytes_remaining
expr_stmt|;
name|t_avail_out
operator|-=
name|bytes
expr_stmt|;
if|if
condition|(
name|o_avail_in
operator|==
literal|0
operator|||
name|t_avail_out
operator|==
literal|0
condition|)
block|{
operator|*
name|used
operator|=
literal|0
expr_stmt|;
operator|*
name|outbytes
operator|=
name|o_avail_out
operator|-
name|t_avail_out
expr_stmt|;
if|if
condition|(
name|o_avail_in
operator|==
literal|0
operator|&&
name|zip
operator|->
name|tmp_stream_bytes_remaining
condition|)
name|ret
operator|=
name|ARCHIVE_EOF
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|t_next_out
operator|+=
name|bytes
expr_stmt|;
name|bcj2_next_out
operator|=
name|t_next_out
expr_stmt|;
name|bcj2_avail_out
operator|=
name|t_avail_out
expr_stmt|;
block|}
name|t_next_out
operator|=
name|zip
operator|->
name|tmp_stream_buff
expr_stmt|;
name|t_avail_out
operator|=
name|zip
operator|->
name|tmp_stream_buff_size
expr_stmt|;
block|}
switch|switch
condition|(
name|zip
operator|->
name|codec
condition|)
block|{
case|case
name|_7Z_COPY
case|:
block|{
name|size_t
name|bytes
init|=
operator|(
name|t_avail_in
operator|>
name|t_avail_out
operator|)
condition|?
name|t_avail_out
else|:
name|t_avail_in
decl_stmt|;
name|memcpy
argument_list|(
name|t_next_out
argument_list|,
name|t_next_in
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|t_avail_in
operator|-=
name|bytes
expr_stmt|;
name|t_avail_out
operator|-=
name|bytes
expr_stmt|;
if|if
condition|(
name|o_avail_in
operator|==
literal|0
condition|)
name|ret
operator|=
name|ARCHIVE_EOF
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|HAVE_LZMA_H
case|case
name|_7Z_LZMA
case|:
case|case
name|_7Z_LZMA2
case|:
name|zip
operator|->
name|lzstream
operator|.
name|next_in
operator|=
name|t_next_in
expr_stmt|;
name|zip
operator|->
name|lzstream
operator|.
name|avail_in
operator|=
name|t_avail_in
expr_stmt|;
name|zip
operator|->
name|lzstream
operator|.
name|next_out
operator|=
name|t_next_out
expr_stmt|;
name|zip
operator|->
name|lzstream
operator|.
name|avail_out
operator|=
name|t_avail_out
expr_stmt|;
name|r
operator|=
name|lzma_code
argument_list|(
operator|&
operator|(
name|zip
operator|->
name|lzstream
operator|)
argument_list|,
name|LZMA_RUN
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|LZMA_STREAM_END
case|:
comment|/* Found end of stream. */
name|lzma_end
argument_list|(
operator|&
operator|(
name|zip
operator|->
name|lzstream
operator|)
argument_list|)
expr_stmt|;
name|zip
operator|->
name|lzstream_valid
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_EOF
expr_stmt|;
break|break;
case|case
name|LZMA_OK
case|:
comment|/* Decompressor made some progress. */
break|break;
default|default:
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Decompression failed(%d)"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|t_avail_in
operator|=
name|zip
operator|->
name|lzstream
operator|.
name|avail_in
expr_stmt|;
name|t_avail_out
operator|=
name|zip
operator|->
name|lzstream
operator|.
name|avail_out
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_BZLIB_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|BZ_CONFIG_ERROR
argument_list|)
case|case
name|_7Z_BZ2
case|:
name|zip
operator|->
name|bzstream
operator|.
name|next_in
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|t_next_in
expr_stmt|;
name|zip
operator|->
name|bzstream
operator|.
name|avail_in
operator|=
name|t_avail_in
expr_stmt|;
name|zip
operator|->
name|bzstream
operator|.
name|next_out
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|t_next_out
expr_stmt|;
name|zip
operator|->
name|bzstream
operator|.
name|avail_out
operator|=
name|t_avail_out
expr_stmt|;
name|r
operator|=
name|BZ2_bzDecompress
argument_list|(
operator|&
operator|(
name|zip
operator|->
name|bzstream
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|BZ_STREAM_END
case|:
comment|/* Found end of stream. */
switch|switch
condition|(
name|BZ2_bzDecompressEnd
argument_list|(
operator|&
operator|(
name|zip
operator|->
name|bzstream
operator|)
argument_list|)
condition|)
block|{
case|case
name|BZ_OK
case|:
break|break;
default|default:
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Failed to clean up decompressor"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|zip
operator|->
name|bzstream_valid
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_EOF
expr_stmt|;
break|break;
case|case
name|BZ_OK
case|:
comment|/* Decompressor made some progress. */
break|break;
default|default:
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"bzip decompression failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|t_avail_in
operator|=
name|zip
operator|->
name|bzstream
operator|.
name|avail_in
expr_stmt|;
name|t_avail_out
operator|=
name|zip
operator|->
name|bzstream
operator|.
name|avail_out
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
case|case
name|_7Z_DEFLATE
case|:
name|zip
operator|->
name|stream
operator|.
name|next_in
operator|=
operator|(
name|Bytef
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|t_next_in
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|avail_in
operator|=
name|t_avail_in
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|next_out
operator|=
name|t_next_out
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|avail_out
operator|=
name|t_avail_out
expr_stmt|;
name|r
operator|=
name|inflate
argument_list|(
operator|&
operator|(
name|zip
operator|->
name|stream
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|Z_STREAM_END
case|:
comment|/* Found end of stream. */
name|ret
operator|=
name|ARCHIVE_EOF
expr_stmt|;
break|break;
case|case
name|Z_OK
case|:
comment|/* Decompressor made some progress.*/
break|break;
default|default:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"File decompression failed (%d)"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|t_avail_in
operator|=
name|zip
operator|->
name|stream
operator|.
name|avail_in
expr_stmt|;
name|t_avail_out
operator|=
name|zip
operator|->
name|stream
operator|.
name|avail_out
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|_7Z_PPMD
case|:
block|{
name|uint64_t
name|flush_bytes
decl_stmt|;
if|if
condition|(
operator|!
name|zip
operator|->
name|ppmd7_valid
operator|||
name|zip
operator|->
name|ppmd7_stat
operator|<
literal|0
operator|||
name|t_avail_out
operator|<=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Decompression internal error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|zip
operator|->
name|ppstream
operator|.
name|next_in
operator|=
name|t_next_in
expr_stmt|;
name|zip
operator|->
name|ppstream
operator|.
name|avail_in
operator|=
name|t_avail_in
expr_stmt|;
name|zip
operator|->
name|ppstream
operator|.
name|next_out
operator|=
name|t_next_out
expr_stmt|;
name|zip
operator|->
name|ppstream
operator|.
name|avail_out
operator|=
name|t_avail_out
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|ppmd7_stat
operator|==
literal|0
condition|)
block|{
name|zip
operator|->
name|bytein
operator|.
name|a
operator|=
name|a
expr_stmt|;
name|zip
operator|->
name|bytein
operator|.
name|Read
operator|=
operator|&
name|ppmd_read
expr_stmt|;
name|zip
operator|->
name|range_dec
operator|.
name|Stream
operator|=
operator|&
name|zip
operator|->
name|bytein
expr_stmt|;
name|r
operator|=
name|__archive_ppmd7_functions
operator|.
name|Ppmd7z_RangeDec_Init
argument_list|(
operator|&
operator|(
name|zip
operator|->
name|range_dec
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|zip
operator|->
name|ppmd7_stat
operator|=
operator|-
literal|1
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Failed to initialize PPMd range decorder"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
if|if
condition|(
name|zip
operator|->
name|ppstream
operator|.
name|overconsumed
condition|)
block|{
name|zip
operator|->
name|ppmd7_stat
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|zip
operator|->
name|ppmd7_stat
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|t_avail_in
operator|==
literal|0
condition|)
comment|/* XXX Flush out remaining decoded data XXX */
name|flush_bytes
operator|=
name|zip
operator|->
name|folder_outbytes_remaining
expr_stmt|;
else|else
name|flush_bytes
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|int
name|sym
decl_stmt|;
name|sym
operator|=
name|__archive_ppmd7_functions
operator|.
name|Ppmd7_DecodeSymbol
argument_list|(
operator|&
operator|(
name|zip
operator|->
name|ppmd7_context
operator|)
argument_list|,
operator|&
operator|(
name|zip
operator|->
name|range_dec
operator|.
name|p
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|<
literal|0
condition|)
block|{
name|zip
operator|->
name|ppmd7_stat
operator|=
operator|-
literal|1
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Failed to decode PPMd"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
if|if
condition|(
name|zip
operator|->
name|ppstream
operator|.
name|overconsumed
condition|)
block|{
name|zip
operator|->
name|ppmd7_stat
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
operator|*
name|zip
operator|->
name|ppstream
operator|.
name|next_out
operator|++
operator|=
operator|(
name|unsigned
name|char
operator|)
name|sym
expr_stmt|;
name|zip
operator|->
name|ppstream
operator|.
name|avail_out
operator|--
expr_stmt|;
name|zip
operator|->
name|ppstream
operator|.
name|total_out
operator|++
expr_stmt|;
if|if
condition|(
name|flush_bytes
condition|)
name|flush_bytes
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|zip
operator|->
name|ppstream
operator|.
name|avail_out
operator|&&
operator|(
name|zip
operator|->
name|ppstream
operator|.
name|avail_in
operator|||
name|flush_bytes
operator|)
condition|)
do|;
name|t_avail_in
operator|=
operator|(
name|size_t
operator|)
name|zip
operator|->
name|ppstream
operator|.
name|avail_in
expr_stmt|;
name|t_avail_out
operator|=
operator|(
name|size_t
operator|)
name|zip
operator|->
name|ppstream
operator|.
name|avail_out
expr_stmt|;
break|break;
block|}
default|default:
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Decompression internal error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
operator|&&
name|ret
operator|!=
name|ARCHIVE_EOF
condition|)
return|return
operator|(
name|ret
operator|)
return|;
operator|*
name|used
operator|=
name|o_avail_in
operator|-
name|t_avail_in
expr_stmt|;
operator|*
name|outbytes
operator|=
name|o_avail_out
operator|-
name|t_avail_out
expr_stmt|;
comment|/* 	 * Decord BCJ. 	 */
if|if
condition|(
name|zip
operator|->
name|codec
operator|!=
name|_7Z_LZMA2
operator|&&
name|zip
operator|->
name|codec2
operator|==
name|_7Z_X86
condition|)
block|{
name|size_t
name|l
init|=
name|x86_Convert
argument_list|(
name|zip
argument_list|,
name|buff
argument_list|,
operator|*
name|outbytes
argument_list|)
decl_stmt|;
name|zip
operator|->
name|odd_bcj_size
operator|=
operator|*
name|outbytes
operator|-
name|l
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|odd_bcj_size
operator|>
literal|0
operator|&&
name|zip
operator|->
name|odd_bcj_size
operator|<=
literal|4
operator|&&
name|o_avail_in
operator|&&
name|ret
operator|!=
name|ARCHIVE_EOF
condition|)
block|{
name|memcpy
argument_list|(
name|zip
operator|->
name|odd_bcj
argument_list|,
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buff
operator|)
operator|+
name|l
argument_list|,
name|zip
operator|->
name|odd_bcj_size
argument_list|)
expr_stmt|;
operator|*
name|outbytes
operator|=
name|l
expr_stmt|;
block|}
else|else
name|zip
operator|->
name|odd_bcj_size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Decord BCJ2 with a decompressed main stream. 	 */
if|if
condition|(
name|zip
operator|->
name|codec2
operator|==
name|_7Z_X86_BCJ2
condition|)
block|{
name|ssize_t
name|bytes
decl_stmt|;
name|zip
operator|->
name|tmp_stream_bytes_avail
operator|=
name|zip
operator|->
name|tmp_stream_buff_size
operator|-
name|t_avail_out
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|tmp_stream_bytes_avail
operator|>
name|zip
operator|->
name|main_stream_bytes_remaining
condition|)
name|zip
operator|->
name|tmp_stream_bytes_avail
operator|=
name|zip
operator|->
name|main_stream_bytes_remaining
expr_stmt|;
name|zip
operator|->
name|tmp_stream_bytes_remaining
operator|=
name|zip
operator|->
name|tmp_stream_bytes_avail
expr_stmt|;
name|bytes
operator|=
name|Bcj2_Decode
argument_list|(
name|zip
argument_list|,
name|bcj2_next_out
argument_list|,
name|bcj2_avail_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"BCJ2 conversion Failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|zip
operator|->
name|main_stream_bytes_remaining
operator|-=
name|zip
operator|->
name|tmp_stream_bytes_avail
operator|-
name|zip
operator|->
name|tmp_stream_bytes_remaining
expr_stmt|;
name|bcj2_avail_out
operator|-=
name|bytes
expr_stmt|;
operator|*
name|outbytes
operator|=
name|o_avail_out
operator|-
name|bcj2_avail_out
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|free_decompression
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|_7zip
modifier|*
name|zip
parameter_list|)
block|{
name|int
name|r
init|=
name|ARCHIVE_OK
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_ZLIB_H
argument_list|)
operator|&&
expr|\
operator|!
operator|(
name|defined
argument_list|(
name|HAVE_BZLIB_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|BZ_CONFIG_ERROR
argument_list|)
operator|)
operator|(
name|void
operator|)
name|a
expr_stmt|;
comment|/* UNUSED */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_LZMA_H
if|if
condition|(
name|zip
operator|->
name|lzstream_valid
condition|)
name|lzma_end
argument_list|(
operator|&
operator|(
name|zip
operator|->
name|lzstream
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_BZLIB_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|BZ_CONFIG_ERROR
argument_list|)
if|if
condition|(
name|zip
operator|->
name|bzstream_valid
condition|)
block|{
if|if
condition|(
name|BZ2_bzDecompressEnd
argument_list|(
operator|&
operator|(
name|zip
operator|->
name|bzstream
operator|)
argument_list|)
operator|!=
name|BZ_OK
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Failed to clean up bzip2 decompressor"
argument_list|)
expr_stmt|;
name|r
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
block|}
name|zip
operator|->
name|bzstream_valid
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
if|if
condition|(
name|zip
operator|->
name|stream_valid
condition|)
block|{
if|if
condition|(
name|inflateEnd
argument_list|(
operator|&
operator|(
name|zip
operator|->
name|stream
operator|)
argument_list|)
operator|!=
name|Z_OK
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Failed to clean up zlib decompressor"
argument_list|)
expr_stmt|;
name|r
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
block|}
name|zip
operator|->
name|stream_valid
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|zip
operator|->
name|ppmd7_valid
condition|)
block|{
name|__archive_ppmd7_functions
operator|.
name|Ppmd7_Free
argument_list|(
operator|&
name|zip
operator|->
name|ppmd7_context
argument_list|,
operator|&
name|g_szalloc
argument_list|)
expr_stmt|;
name|zip
operator|->
name|ppmd7_valid
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_7zip_uint64
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|uint64_t
modifier|*
name|val
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
name|avail
decl_stmt|,
name|mask
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|avail
operator|=
operator|*
name|p
expr_stmt|;
name|mask
operator|=
literal|0x80
expr_stmt|;
operator|*
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|avail
operator|&
name|mask
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|val
operator||=
operator|(
operator|(
name|uint64_t
operator|)
operator|*
name|p
operator|)
operator|<<
operator|(
literal|8
operator|*
name|i
operator|)
expr_stmt|;
name|mask
operator|>>=
literal|1
expr_stmt|;
continue|continue;
block|}
operator|*
name|val
operator|+=
operator|(
name|avail
operator|&
operator|(
name|mask
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
literal|8
operator|*
name|i
operator|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_Bools
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|size_t
name|num
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|mask
init|=
literal|0
decl_stmt|,
name|avail
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|avail
operator|=
operator|*
name|p
expr_stmt|;
name|mask
operator|=
literal|0x80
expr_stmt|;
block|}
name|data
index|[
name|i
index|]
operator|=
operator|(
name|avail
operator|&
name|mask
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|mask
operator|>>=
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_Digest
parameter_list|(
name|struct
name|_7z_digests
modifier|*
name|d
parameter_list|)
block|{
name|free
argument_list|(
name|d
operator|->
name|defineds
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|d
operator|->
name|digests
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_Digests
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|_7z_digests
modifier|*
name|d
parameter_list|,
name|size_t
name|num
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|memset
argument_list|(
name|d
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|defineds
operator|=
name|malloc
argument_list|(
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|defineds
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Read Bools. 	 */
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|read_Bools
argument_list|(
name|a
argument_list|,
name|d
operator|->
name|defineds
argument_list|,
name|num
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
comment|/* All are defined */
name|memset
argument_list|(
name|d
operator|->
name|defineds
argument_list|,
literal|1
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|d
operator|->
name|digests
operator|=
name|calloc
argument_list|(
name|num
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|d
operator|->
name|digests
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|digests
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|d
operator|->
name|defineds
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|4
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|d
operator|->
name|digests
index|[
name|i
index|]
operator|=
name|archive_le32dec
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_PackInfo
parameter_list|(
name|struct
name|_7z_pack_info
modifier|*
name|pi
parameter_list|)
block|{
name|free
argument_list|(
name|pi
operator|->
name|sizes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pi
operator|->
name|positions
argument_list|)
expr_stmt|;
name|free_Digest
argument_list|(
operator|&
operator|(
name|pi
operator|->
name|digest
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_PackInfo
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|_7z_pack_info
modifier|*
name|pi
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|memset
argument_list|(
name|pi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pi
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Read PackPos. 	 */
if|if
condition|(
name|parse_7zip_uint64
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|pi
operator|->
name|pos
operator|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Read NumPackStreams. 	 */
if|if
condition|(
name|parse_7zip_uint64
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|pi
operator|->
name|numPackStreams
operator|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|pi
operator|->
name|numPackStreams
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
literal|1000000
operator|<
name|pi
operator|->
name|numPackStreams
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Read PackSizes[num] 	 */
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|p
operator|==
name|kEnd
condition|)
comment|/* PackSizes[num] are not present. */
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|*
name|p
operator|!=
name|kSize
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|pi
operator|->
name|sizes
operator|=
name|calloc
argument_list|(
operator|(
name|size_t
operator|)
name|pi
operator|->
name|numPackStreams
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|pi
operator|->
name|positions
operator|=
name|calloc
argument_list|(
operator|(
name|size_t
operator|)
name|pi
operator|->
name|numPackStreams
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|sizes
operator|==
name|NULL
operator|||
name|pi
operator|->
name|positions
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pi
operator|->
name|numPackStreams
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|parse_7zip_uint64
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|pi
operator|->
name|sizes
index|[
name|i
index|]
operator|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Read PackStreamDigests[num] 	 */
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|p
operator|==
name|kEnd
condition|)
block|{
comment|/* PackStreamDigests[num] are not present. */
name|pi
operator|->
name|digest
operator|.
name|defineds
operator|=
name|calloc
argument_list|(
operator|(
name|size_t
operator|)
name|pi
operator|->
name|numPackStreams
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pi
operator|->
name|digest
operator|.
name|defineds
argument_list|)
argument_list|)
expr_stmt|;
name|pi
operator|->
name|digest
operator|.
name|digests
operator|=
name|calloc
argument_list|(
operator|(
name|size_t
operator|)
name|pi
operator|->
name|numPackStreams
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pi
operator|->
name|digest
operator|.
name|digests
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|digest
operator|.
name|defineds
operator|==
name|NULL
operator|||
name|pi
operator|->
name|digest
operator|.
name|digests
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|p
operator|!=
name|kSize
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|read_Digests
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|pi
operator|->
name|digest
operator|)
argument_list|,
operator|(
name|size_t
operator|)
name|pi
operator|->
name|numPackStreams
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 *  Must be marked by kEnd. 	 */
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|p
operator|!=
name|kEnd
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_Folder
parameter_list|(
name|struct
name|_7z_folder
modifier|*
name|f
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
if|if
condition|(
name|f
operator|->
name|coders
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|f
operator|->
name|numCoders
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|f
operator|->
name|coders
index|[
name|i
index|]
operator|.
name|properties
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|f
operator|->
name|coders
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|f
operator|->
name|bindPairs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|f
operator|->
name|packedStreams
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|f
operator|->
name|unPackSize
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_Folder
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|_7z_folder
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|_7zip
modifier|*
name|zip
init|=
operator|(
expr|struct
name|_7zip
operator|*
operator|)
name|a
operator|->
name|format
operator|->
name|data
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|uint64_t
name|numInStreamsTotal
init|=
literal|0
decl_stmt|;
name|uint64_t
name|numOutStreamsTotal
init|=
literal|0
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|memset
argument_list|(
name|f
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|f
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Read NumCoders. 	 */
if|if
condition|(
name|parse_7zip_uint64
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|f
operator|->
name|numCoders
operator|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|f
operator|->
name|numCoders
operator|>
literal|4
condition|)
comment|/* Too many coders. */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|f
operator|->
name|coders
operator|=
name|calloc
argument_list|(
operator|(
name|size_t
operator|)
name|f
operator|->
name|numCoders
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|f
operator|->
name|coders
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|coders
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|f
operator|->
name|numCoders
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|codec_size
decl_stmt|;
name|int
name|simple
decl_stmt|,
name|attr
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 		 * 0:3 CodecIdSize 		 * 4:  0 - IsSimple 		 *     1 - Is not Simple 		 * 5:  0 - No Attributes 		 *     1 - There are Attributes; 		 * 7:  Must be zero. 		 */
name|codec_size
operator|=
operator|*
name|p
operator|&
literal|0xf
expr_stmt|;
name|simple
operator|=
operator|(
operator|*
name|p
operator|&
literal|0x10
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|attr
operator|=
operator|*
name|p
operator|&
literal|0x20
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|&
literal|0x80
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Not supported. */
comment|/* 		 * Read Decompression Method IDs. 		 */
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
name|codec_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|f
operator|->
name|coders
index|[
name|i
index|]
operator|.
name|codec
operator|=
name|decode_codec_id
argument_list|(
name|p
argument_list|,
name|codec_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|simple
condition|)
block|{
name|f
operator|->
name|coders
index|[
name|i
index|]
operator|.
name|numInStreams
operator|=
literal|1
expr_stmt|;
name|f
operator|->
name|coders
index|[
name|i
index|]
operator|.
name|numOutStreams
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|parse_7zip_uint64
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|f
operator|->
name|coders
index|[
name|i
index|]
operator|.
name|numInStreams
operator|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
literal|1000000
operator|<
name|f
operator|->
name|coders
index|[
name|i
index|]
operator|.
name|numInStreams
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|parse_7zip_uint64
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|f
operator|->
name|coders
index|[
name|i
index|]
operator|.
name|numOutStreams
operator|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
literal|1000000
operator|<
name|f
operator|->
name|coders
index|[
name|i
index|]
operator|.
name|numOutStreams
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|attr
condition|)
block|{
if|if
condition|(
name|parse_7zip_uint64
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|f
operator|->
name|coders
index|[
name|i
index|]
operator|.
name|propertiesSize
operator|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
operator|(
name|size_t
operator|)
name|f
operator|->
name|coders
index|[
name|i
index|]
operator|.
name|propertiesSize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|f
operator|->
name|coders
index|[
name|i
index|]
operator|.
name|properties
operator|=
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|f
operator|->
name|coders
index|[
name|i
index|]
operator|.
name|propertiesSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|coders
index|[
name|i
index|]
operator|.
name|properties
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|memcpy
argument_list|(
name|f
operator|->
name|coders
index|[
name|i
index|]
operator|.
name|properties
argument_list|,
name|p
argument_list|,
operator|(
name|size_t
operator|)
name|f
operator|->
name|coders
index|[
name|i
index|]
operator|.
name|propertiesSize
argument_list|)
expr_stmt|;
block|}
name|numInStreamsTotal
operator|+=
name|f
operator|->
name|coders
index|[
name|i
index|]
operator|.
name|numInStreams
expr_stmt|;
name|numOutStreamsTotal
operator|+=
name|f
operator|->
name|coders
index|[
name|i
index|]
operator|.
name|numOutStreams
expr_stmt|;
block|}
if|if
condition|(
name|numOutStreamsTotal
operator|==
literal|0
operator|||
name|numInStreamsTotal
operator|<
name|numOutStreamsTotal
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|f
operator|->
name|numBindPairs
operator|=
name|numOutStreamsTotal
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|header_bytes_remaining
operator|<
name|f
operator|->
name|numBindPairs
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|f
operator|->
name|numBindPairs
operator|>
literal|0
condition|)
block|{
name|f
operator|->
name|bindPairs
operator|=
name|calloc
argument_list|(
operator|(
name|size_t
operator|)
name|f
operator|->
name|numBindPairs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|f
operator|->
name|bindPairs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|bindPairs
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
name|f
operator|->
name|bindPairs
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|f
operator|->
name|numBindPairs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|parse_7zip_uint64
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|f
operator|->
name|bindPairs
index|[
name|i
index|]
operator|.
name|inIndex
operator|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
literal|1000000
operator|<
name|f
operator|->
name|bindPairs
index|[
name|i
index|]
operator|.
name|inIndex
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|parse_7zip_uint64
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|f
operator|->
name|bindPairs
index|[
name|i
index|]
operator|.
name|outIndex
operator|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
literal|1000000
operator|<
name|f
operator|->
name|bindPairs
index|[
name|i
index|]
operator|.
name|outIndex
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|f
operator|->
name|numPackedStreams
operator|=
name|numInStreamsTotal
operator|-
name|f
operator|->
name|numBindPairs
expr_stmt|;
name|f
operator|->
name|packedStreams
operator|=
name|calloc
argument_list|(
operator|(
name|size_t
operator|)
name|f
operator|->
name|numPackedStreams
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|f
operator|->
name|packedStreams
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|packedStreams
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|f
operator|->
name|numPackedStreams
operator|==
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numInStreamsTotal
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|f
operator|->
name|numBindPairs
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|f
operator|->
name|bindPairs
index|[
name|j
index|]
operator|.
name|inIndex
operator|==
name|i
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|f
operator|->
name|numBindPairs
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|numInStreamsTotal
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|f
operator|->
name|packedStreams
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|f
operator|->
name|numPackedStreams
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|parse_7zip_uint64
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|f
operator|->
name|packedStreams
index|[
name|i
index|]
operator|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
literal|1000000
operator|<
name|f
operator|->
name|packedStreams
index|[
name|i
index|]
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|f
operator|->
name|numInStreams
operator|=
name|numInStreamsTotal
expr_stmt|;
name|f
operator|->
name|numOutStreams
operator|=
name|numOutStreamsTotal
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_CodersInfo
parameter_list|(
name|struct
name|_7z_coders_info
modifier|*
name|ci
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
if|if
condition|(
name|ci
operator|->
name|folders
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ci
operator|->
name|numFolders
condition|;
name|i
operator|++
control|)
name|free_Folder
argument_list|(
operator|&
operator|(
name|ci
operator|->
name|folders
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ci
operator|->
name|folders
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|read_CodersInfo
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|_7z_coders_info
modifier|*
name|ci
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|_7z_digests
name|digest
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|memset
argument_list|(
name|ci
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ci
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|digest
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|digest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
operator|*
name|p
operator|!=
name|kFolder
condition|)
goto|goto
name|failed
goto|;
comment|/* 	 * Read NumFolders. 	 */
if|if
condition|(
name|parse_7zip_uint64
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|ci
operator|->
name|numFolders
operator|)
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
literal|1000000
operator|<
name|ci
operator|->
name|numFolders
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Read External. 	 */
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|0
case|:
name|ci
operator|->
name|folders
operator|=
name|calloc
argument_list|(
operator|(
name|size_t
operator|)
name|ci
operator|->
name|numFolders
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ci
operator|->
name|folders
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|folders
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ci
operator|->
name|numFolders
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|read_Folder
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|ci
operator|->
name|folders
index|[
name|i
index|]
operator|)
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|failed
goto|;
block|}
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|parse_7zip_uint64
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|ci
operator|->
name|dataStreamIndex
operator|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
literal|1000000
operator|<
name|ci
operator|->
name|dataStreamIndex
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
operator|*
name|p
operator|!=
name|kCodersUnPackSize
condition|)
goto|goto
name|failed
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ci
operator|->
name|numFolders
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|_7z_folder
modifier|*
name|folder
init|=
operator|&
operator|(
name|ci
operator|->
name|folders
index|[
name|i
index|]
operator|)
decl_stmt|;
name|unsigned
name|j
decl_stmt|;
name|folder
operator|->
name|unPackSize
operator|=
name|calloc
argument_list|(
operator|(
name|size_t
operator|)
name|folder
operator|->
name|numOutStreams
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|folder
operator|->
name|unPackSize
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|folder
operator|->
name|unPackSize
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|folder
operator|->
name|numOutStreams
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|parse_7zip_uint64
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|folder
operator|->
name|unPackSize
index|[
name|j
index|]
operator|)
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|failed
goto|;
block|}
block|}
comment|/* 	 * Read CRCs. 	 */
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
operator|*
name|p
operator|==
name|kEnd
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|*
name|p
operator|!=
name|kCRC
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
name|read_Digests
argument_list|(
name|a
argument_list|,
operator|&
name|digest
argument_list|,
operator|(
name|size_t
operator|)
name|ci
operator|->
name|numFolders
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|failed
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ci
operator|->
name|numFolders
condition|;
name|i
operator|++
control|)
block|{
name|ci
operator|->
name|folders
index|[
name|i
index|]
operator|.
name|digest_defined
operator|=
name|digest
operator|.
name|defineds
index|[
name|i
index|]
expr_stmt|;
name|ci
operator|->
name|folders
index|[
name|i
index|]
operator|.
name|digest
operator|=
name|digest
operator|.
name|digests
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* 	 *  Must be kEnd. 	 */
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
operator|*
name|p
operator|!=
name|kEnd
condition|)
goto|goto
name|failed
goto|;
name|free_Digest
argument_list|(
operator|&
name|digest
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|failed
label|:
name|free_Digest
argument_list|(
operator|&
name|digest
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|folder_uncompressed_size
parameter_list|(
name|struct
name|_7z_folder
modifier|*
name|f
parameter_list|)
block|{
name|int
name|n
init|=
operator|(
name|int
operator|)
name|f
operator|->
name|numOutStreams
decl_stmt|;
name|unsigned
name|pairs
init|=
operator|(
name|unsigned
operator|)
name|f
operator|->
name|numBindPairs
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pairs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|f
operator|->
name|bindPairs
index|[
name|i
index|]
operator|.
name|outIndex
operator|==
operator|(
name|uint64_t
operator|)
name|n
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|pairs
condition|)
return|return
operator|(
name|f
operator|->
name|unPackSize
index|[
name|n
index|]
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_SubStreamsInfo
parameter_list|(
name|struct
name|_7z_substream_info
modifier|*
name|ss
parameter_list|)
block|{
name|free
argument_list|(
name|ss
operator|->
name|unpackSizes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ss
operator|->
name|digestsDefined
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ss
operator|->
name|digests
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_SubStreamsInfo
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|_7z_substream_info
modifier|*
name|ss
parameter_list|,
name|struct
name|_7z_folder
modifier|*
name|f
parameter_list|,
name|size_t
name|numFolders
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|uint64_t
modifier|*
name|usizes
decl_stmt|;
name|size_t
name|unpack_streams
decl_stmt|;
name|int
name|type
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|uint32_t
name|numDigests
decl_stmt|;
name|memset
argument_list|(
name|ss
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ss
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numFolders
condition|;
name|i
operator|++
control|)
name|f
index|[
name|i
index|]
operator|.
name|numUnpackStreams
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|type
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|kNumUnPackStream
condition|)
block|{
name|unpack_streams
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numFolders
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|parse_7zip_uint64
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|f
index|[
name|i
index|]
operator|.
name|numUnpackStreams
operator|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
literal|1000000
operator|<
name|f
index|[
name|i
index|]
operator|.
name|numUnpackStreams
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|unpack_streams
operator|+=
operator|(
name|size_t
operator|)
name|f
index|[
name|i
index|]
operator|.
name|numUnpackStreams
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|type
operator|=
operator|*
name|p
expr_stmt|;
block|}
else|else
name|unpack_streams
operator|=
name|numFolders
expr_stmt|;
name|ss
operator|->
name|unpack_streams
operator|=
name|unpack_streams
expr_stmt|;
if|if
condition|(
name|unpack_streams
condition|)
block|{
name|ss
operator|->
name|unpackSizes
operator|=
name|calloc
argument_list|(
name|unpack_streams
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ss
operator|->
name|unpackSizes
argument_list|)
argument_list|)
expr_stmt|;
name|ss
operator|->
name|digestsDefined
operator|=
name|calloc
argument_list|(
name|unpack_streams
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ss
operator|->
name|digestsDefined
argument_list|)
argument_list|)
expr_stmt|;
name|ss
operator|->
name|digests
operator|=
name|calloc
argument_list|(
name|unpack_streams
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ss
operator|->
name|digests
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|unpackSizes
operator|==
name|NULL
operator|||
name|ss
operator|->
name|digestsDefined
operator|==
name|NULL
operator|||
name|ss
operator|->
name|digests
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|usizes
operator|=
name|ss
operator|->
name|unpackSizes
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numFolders
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|pack
decl_stmt|;
name|uint64_t
name|sum
decl_stmt|;
if|if
condition|(
name|f
index|[
name|i
index|]
operator|.
name|numUnpackStreams
operator|==
literal|0
condition|)
continue|continue;
name|sum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|kSize
condition|)
block|{
for|for
control|(
name|pack
operator|=
literal|1
init|;
name|pack
operator|<
name|f
index|[
name|i
index|]
operator|.
name|numUnpackStreams
condition|;
name|pack
operator|++
control|)
block|{
if|if
condition|(
name|parse_7zip_uint64
argument_list|(
name|a
argument_list|,
name|usizes
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|sum
operator|+=
operator|*
name|usizes
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|usizes
operator|++
operator|=
name|folder_uncompressed_size
argument_list|(
operator|&
name|f
index|[
name|i
index|]
argument_list|)
operator|-
name|sum
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|kSize
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|type
operator|=
operator|*
name|p
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|unpack_streams
condition|;
name|i
operator|++
control|)
block|{
name|ss
operator|->
name|digestsDefined
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|ss
operator|->
name|digests
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|numDigests
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numFolders
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|f
index|[
name|i
index|]
operator|.
name|numUnpackStreams
operator|!=
literal|1
operator|||
operator|!
name|f
index|[
name|i
index|]
operator|.
name|digest_defined
condition|)
name|numDigests
operator|+=
operator|(
name|uint32_t
operator|)
name|f
index|[
name|i
index|]
operator|.
name|numUnpackStreams
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|kCRC
condition|)
block|{
name|struct
name|_7z_digests
name|tmpDigests
decl_stmt|;
name|unsigned
name|char
modifier|*
name|digestsDefined
init|=
name|ss
operator|->
name|digestsDefined
decl_stmt|;
name|uint32_t
modifier|*
name|digests
init|=
name|ss
operator|->
name|digests
decl_stmt|;
name|int
name|di
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
operator|&
name|tmpDigests
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpDigests
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_Digests
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|tmpDigests
operator|)
argument_list|,
name|numDigests
argument_list|)
operator|<
literal|0
condition|)
block|{
name|free_Digest
argument_list|(
operator|&
name|tmpDigests
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numFolders
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|f
index|[
name|i
index|]
operator|.
name|numUnpackStreams
operator|==
literal|1
operator|&&
name|f
index|[
name|i
index|]
operator|.
name|digest_defined
condition|)
block|{
operator|*
name|digestsDefined
operator|++
operator|=
literal|1
expr_stmt|;
operator|*
name|digests
operator|++
operator|=
name|f
index|[
name|i
index|]
operator|.
name|digest
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|f
index|[
name|i
index|]
operator|.
name|numUnpackStreams
condition|;
name|j
operator|++
operator|,
name|di
operator|++
control|)
block|{
operator|*
name|digestsDefined
operator|++
operator|=
name|tmpDigests
operator|.
name|defineds
index|[
name|di
index|]
expr_stmt|;
operator|*
name|digests
operator|++
operator|=
name|tmpDigests
operator|.
name|digests
index|[
name|di
index|]
expr_stmt|;
block|}
block|}
block|}
name|free_Digest
argument_list|(
operator|&
name|tmpDigests
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|type
operator|=
operator|*
name|p
expr_stmt|;
block|}
comment|/* 	 *  Must be kEnd. 	 */
if|if
condition|(
name|type
operator|!=
name|kEnd
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_StreamsInfo
parameter_list|(
name|struct
name|_7z_stream_info
modifier|*
name|si
parameter_list|)
block|{
name|free_PackInfo
argument_list|(
operator|&
operator|(
name|si
operator|->
name|pi
operator|)
argument_list|)
expr_stmt|;
name|free_CodersInfo
argument_list|(
operator|&
operator|(
name|si
operator|->
name|ci
operator|)
argument_list|)
expr_stmt|;
name|free_SubStreamsInfo
argument_list|(
operator|&
operator|(
name|si
operator|->
name|ss
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_StreamsInfo
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|_7z_stream_info
modifier|*
name|si
parameter_list|)
block|{
name|struct
name|_7zip
modifier|*
name|zip
init|=
operator|(
expr|struct
name|_7zip
operator|*
operator|)
name|a
operator|->
name|format
operator|->
name|data
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|memset
argument_list|(
name|si
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|p
operator|==
name|kPackInfo
condition|)
block|{
name|uint64_t
name|packPos
decl_stmt|;
if|if
condition|(
name|read_PackInfo
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|si
operator|->
name|pi
operator|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|si
operator|->
name|pi
operator|.
name|positions
operator|==
name|NULL
operator|||
name|si
operator|->
name|pi
operator|.
name|sizes
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 		 * Calculate packed stream positions. 		 */
name|packPos
operator|=
name|si
operator|->
name|pi
operator|.
name|pos
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|si
operator|->
name|pi
operator|.
name|numPackStreams
condition|;
name|i
operator|++
control|)
block|{
name|si
operator|->
name|pi
operator|.
name|positions
index|[
name|i
index|]
operator|=
name|packPos
expr_stmt|;
name|packPos
operator|+=
name|si
operator|->
name|pi
operator|.
name|sizes
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|packPos
operator|>
name|zip
operator|->
name|header_offset
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
name|kUnPackInfo
condition|)
block|{
name|uint32_t
name|packIndex
decl_stmt|;
name|struct
name|_7z_folder
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|read_CodersInfo
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|si
operator|->
name|ci
operator|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 		 * Calculate packed stream indexes. 		 */
name|packIndex
operator|=
literal|0
expr_stmt|;
name|f
operator|=
name|si
operator|->
name|ci
operator|.
name|folders
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|si
operator|->
name|ci
operator|.
name|numFolders
condition|;
name|i
operator|++
control|)
block|{
name|f
index|[
name|i
index|]
operator|.
name|packIndex
operator|=
name|packIndex
expr_stmt|;
name|packIndex
operator|+=
operator|(
name|uint32_t
operator|)
name|f
index|[
name|i
index|]
operator|.
name|numPackedStreams
expr_stmt|;
if|if
condition|(
name|packIndex
operator|>
name|si
operator|->
name|pi
operator|.
name|numPackStreams
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
name|kSubStreamsInfo
condition|)
block|{
if|if
condition|(
name|read_SubStreamsInfo
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|si
operator|->
name|ss
operator|)
argument_list|,
name|si
operator|->
name|ci
operator|.
name|folders
argument_list|,
operator|(
name|size_t
operator|)
name|si
operator|->
name|ci
operator|.
name|numFolders
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 *  Must be kEnd. 	 */
if|if
condition|(
operator|*
name|p
operator|!=
name|kEnd
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_Header
parameter_list|(
name|struct
name|_7z_header_info
modifier|*
name|h
parameter_list|)
block|{
name|free
argument_list|(
name|h
operator|->
name|emptyStreamBools
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|h
operator|->
name|emptyFileBools
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|h
operator|->
name|antiBools
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|h
operator|->
name|attrBools
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_Header
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|_7z_header_info
modifier|*
name|h
parameter_list|,
name|int
name|check_header_id
parameter_list|)
block|{
name|struct
name|_7zip
modifier|*
name|zip
init|=
operator|(
expr|struct
name|_7zip
operator|*
operator|)
name|a
operator|->
name|format
operator|->
name|data
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|_7z_folder
modifier|*
name|folders
decl_stmt|;
name|struct
name|_7z_stream_info
modifier|*
name|si
init|=
operator|&
operator|(
name|zip
operator|->
name|si
operator|)
decl_stmt|;
name|struct
name|_7zip_entry
modifier|*
name|entries
decl_stmt|;
name|uint32_t
name|folderIndex
decl_stmt|,
name|indexInFolder
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|int
name|eindex
decl_stmt|,
name|empty_streams
decl_stmt|,
name|sindex
decl_stmt|;
if|if
condition|(
name|check_header_id
condition|)
block|{
comment|/* 		 * Read Header. 		 */
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|p
operator|!=
name|kHeader
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Read ArchiveProperties. 	 */
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|p
operator|==
name|kArchiveProperties
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|uint64_t
name|size
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|parse_7zip_uint64
argument_list|(
name|a
argument_list|,
operator|&
name|size
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Read MainStreamsInfo. 	 */
if|if
condition|(
operator|*
name|p
operator|==
name|kMainStreamsInfo
condition|)
block|{
if|if
condition|(
name|read_StreamsInfo
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|zip
operator|->
name|si
operator|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
name|kEnd
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Read FilesInfo. 	 */
if|if
condition|(
operator|*
name|p
operator|!=
name|kFilesInfo
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|parse_7zip_uint64
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|zip
operator|->
name|numFiles
operator|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
literal|1000000
operator|<
name|zip
operator|->
name|numFiles
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|zip
operator|->
name|entries
operator|=
name|calloc
argument_list|(
operator|(
name|size_t
operator|)
name|zip
operator|->
name|numFiles
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zip
operator|->
name|entries
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|entries
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|entries
operator|=
name|zip
operator|->
name|entries
expr_stmt|;
name|empty_streams
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|type
decl_stmt|;
name|uint64_t
name|size
decl_stmt|;
name|size_t
name|ll
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|type
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|kEnd
condition|)
break|break;
if|if
condition|(
name|parse_7zip_uint64
argument_list|(
name|a
argument_list|,
operator|&
name|size
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|zip
operator|->
name|header_bytes_remaining
operator|<
name|size
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ll
operator|=
operator|(
name|size_t
operator|)
name|size
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|kEmptyStream
case|:
name|h
operator|->
name|emptyStreamBools
operator|=
name|calloc
argument_list|(
operator|(
name|size_t
operator|)
name|zip
operator|->
name|numFiles
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|h
operator|->
name|emptyStreamBools
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|emptyStreamBools
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|read_Bools
argument_list|(
name|a
argument_list|,
name|h
operator|->
name|emptyStreamBools
argument_list|,
operator|(
name|size_t
operator|)
name|zip
operator|->
name|numFiles
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|empty_streams
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zip
operator|->
name|numFiles
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|h
operator|->
name|emptyStreamBools
index|[
name|i
index|]
condition|)
name|empty_streams
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|kEmptyFile
case|:
if|if
condition|(
name|empty_streams
operator|<=
literal|0
condition|)
block|{
comment|/* Unexcepted sequence. Skip this. */
if|if
condition|(
name|header_bytes
argument_list|(
name|a
argument_list|,
name|ll
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
block|}
name|h
operator|->
name|emptyFileBools
operator|=
name|calloc
argument_list|(
name|empty_streams
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|h
operator|->
name|emptyFileBools
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|emptyFileBools
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|read_Bools
argument_list|(
name|a
argument_list|,
name|h
operator|->
name|emptyFileBools
argument_list|,
name|empty_streams
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
case|case
name|kAnti
case|:
if|if
condition|(
name|empty_streams
operator|<=
literal|0
condition|)
block|{
comment|/* Unexcepted sequence. Skip this. */
if|if
condition|(
name|header_bytes
argument_list|(
name|a
argument_list|,
name|ll
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
block|}
name|h
operator|->
name|antiBools
operator|=
name|calloc
argument_list|(
name|empty_streams
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|h
operator|->
name|antiBools
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|antiBools
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|read_Bools
argument_list|(
name|a
argument_list|,
name|h
operator|->
name|antiBools
argument_list|,
name|empty_streams
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
case|case
name|kCTime
case|:
case|case
name|kATime
case|:
case|case
name|kMTime
case|:
if|if
condition|(
name|read_Times
argument_list|(
name|a
argument_list|,
name|h
argument_list|,
name|type
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
case|case
name|kName
case|:
block|{
name|unsigned
name|char
modifier|*
name|np
decl_stmt|;
name|size_t
name|nl
decl_stmt|,
name|nb
decl_stmt|;
comment|/* Skip one byte. */
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ll
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|ll
operator|&
literal|1
operator|)
operator|||
name|ll
operator|<
name|zip
operator|->
name|numFiles
operator|*
literal|4
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|zip
operator|->
name|entry_names
operator|=
name|malloc
argument_list|(
name|ll
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|entry_names
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|np
operator|=
name|zip
operator|->
name|entry_names
expr_stmt|;
name|nb
operator|=
name|ll
expr_stmt|;
comment|/* 			 * Copy whole file names. 			 * NOTE: This loop prevents from expanding 			 * the uncompressed buffer in order not to 			 * use extra memory resource. 			 */
while|while
condition|(
name|nb
condition|)
block|{
name|size_t
name|b
decl_stmt|;
if|if
condition|(
name|nb
operator|>
name|UBUFF_SIZE
condition|)
name|b
operator|=
name|UBUFF_SIZE
expr_stmt|;
else|else
name|b
operator|=
name|nb
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|memcpy
argument_list|(
name|np
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|np
operator|+=
name|b
expr_stmt|;
name|nb
operator|-=
name|b
expr_stmt|;
block|}
name|np
operator|=
name|zip
operator|->
name|entry_names
expr_stmt|;
name|nl
operator|=
name|ll
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zip
operator|->
name|numFiles
condition|;
name|i
operator|++
control|)
block|{
name|entries
index|[
name|i
index|]
operator|.
name|utf16name
operator|=
name|np
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_DEBUG
argument_list|)
name|entries
index|[
name|i
index|]
operator|.
name|wname
operator|=
operator|(
name|wchar_t
operator|*
operator|)
name|np
expr_stmt|;
endif|#
directive|endif
comment|/* Find a terminator. */
while|while
condition|(
name|nl
operator|>=
literal|2
operator|&&
operator|(
name|np
index|[
literal|0
index|]
operator|||
name|np
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|np
operator|+=
literal|2
expr_stmt|;
name|nl
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|nl
operator|<
literal|2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Terminator not found */
name|entries
index|[
name|i
index|]
operator|.
name|name_len
operator|=
name|np
operator|-
name|entries
index|[
name|i
index|]
operator|.
name|utf16name
expr_stmt|;
name|np
operator|+=
literal|2
expr_stmt|;
name|nl
operator|-=
literal|2
expr_stmt|;
block|}
break|break;
block|}
case|case
name|kAttributes
case|:
block|{
name|int
name|allAreDefined
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|2
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|allAreDefined
operator|=
operator|*
name|p
expr_stmt|;
name|h
operator|->
name|attrBools
operator|=
name|calloc
argument_list|(
operator|(
name|size_t
operator|)
name|zip
operator|->
name|numFiles
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|h
operator|->
name|attrBools
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|attrBools
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|allAreDefined
condition|)
name|memset
argument_list|(
name|h
operator|->
name|attrBools
argument_list|,
literal|1
argument_list|,
operator|(
name|size_t
operator|)
name|zip
operator|->
name|numFiles
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|read_Bools
argument_list|(
name|a
argument_list|,
name|h
operator|->
name|attrBools
argument_list|,
operator|(
name|size_t
operator|)
name|zip
operator|->
name|numFiles
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zip
operator|->
name|numFiles
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|h
operator|->
name|attrBools
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|4
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|entries
index|[
name|i
index|]
operator|.
name|attr
operator|=
name|archive_le32dec
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
default|default:
if|if
condition|(
name|header_bytes
argument_list|(
name|a
argument_list|,
name|ll
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
block|}
block|}
comment|/* 	 * Set up entry's attributes. 	 */
name|folders
operator|=
name|si
operator|->
name|ci
operator|.
name|folders
expr_stmt|;
name|eindex
operator|=
name|sindex
operator|=
literal|0
expr_stmt|;
name|folderIndex
operator|=
name|indexInFolder
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zip
operator|->
name|numFiles
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|h
operator|->
name|emptyStreamBools
operator|==
name|NULL
operator|||
name|h
operator|->
name|emptyStreamBools
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|entries
index|[
name|i
index|]
operator|.
name|flg
operator||=
name|HAS_STREAM
expr_stmt|;
comment|/* The high 16 bits of attributes is a posix file mode. */
name|entries
index|[
name|i
index|]
operator|.
name|mode
operator|=
name|entries
index|[
name|i
index|]
operator|.
name|attr
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|entries
index|[
name|i
index|]
operator|.
name|flg
operator|&
name|HAS_STREAM
condition|)
block|{
if|if
condition|(
operator|(
name|size_t
operator|)
name|sindex
operator|>=
name|si
operator|->
name|ss
operator|.
name|unpack_streams
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|entries
index|[
name|i
index|]
operator|.
name|mode
operator|==
literal|0
condition|)
name|entries
index|[
name|i
index|]
operator|.
name|mode
operator|=
name|AE_IFREG
operator||
literal|0666
expr_stmt|;
if|if
condition|(
name|si
operator|->
name|ss
operator|.
name|digestsDefined
index|[
name|sindex
index|]
condition|)
name|entries
index|[
name|i
index|]
operator|.
name|flg
operator||=
name|CRC32_IS_SET
expr_stmt|;
name|entries
index|[
name|i
index|]
operator|.
name|ssIndex
operator|=
name|sindex
expr_stmt|;
name|sindex
operator|++
expr_stmt|;
block|}
else|else
block|{
name|int
name|dir
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|emptyFileBools
operator|==
name|NULL
condition|)
name|dir
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|h
operator|->
name|emptyFileBools
index|[
name|eindex
index|]
condition|)
name|dir
operator|=
literal|0
expr_stmt|;
else|else
name|dir
operator|=
literal|1
expr_stmt|;
name|eindex
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|entries
index|[
name|i
index|]
operator|.
name|mode
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dir
condition|)
name|entries
index|[
name|i
index|]
operator|.
name|mode
operator|=
name|AE_IFDIR
operator||
literal|0777
expr_stmt|;
else|else
name|entries
index|[
name|i
index|]
operator|.
name|mode
operator|=
name|AE_IFREG
operator||
literal|0666
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dir
operator|&&
operator|(
name|entries
index|[
name|i
index|]
operator|.
name|mode
operator|&
name|AE_IFMT
operator|)
operator|!=
name|AE_IFDIR
condition|)
block|{
name|entries
index|[
name|i
index|]
operator|.
name|mode
operator|&=
operator|~
name|AE_IFMT
expr_stmt|;
name|entries
index|[
name|i
index|]
operator|.
name|mode
operator||=
name|AE_IFDIR
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|entries
index|[
name|i
index|]
operator|.
name|mode
operator|&
name|AE_IFMT
operator|)
operator|==
name|AE_IFDIR
operator|&&
name|entries
index|[
name|i
index|]
operator|.
name|name_len
operator|>=
literal|2
operator|&&
operator|(
name|entries
index|[
name|i
index|]
operator|.
name|utf16name
index|[
name|entries
index|[
name|i
index|]
operator|.
name|name_len
operator|-
literal|2
index|]
operator|!=
literal|'/'
operator|||
name|entries
index|[
name|i
index|]
operator|.
name|utf16name
index|[
name|entries
index|[
name|i
index|]
operator|.
name|name_len
operator|-
literal|1
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
name|entries
index|[
name|i
index|]
operator|.
name|utf16name
index|[
name|entries
index|[
name|i
index|]
operator|.
name|name_len
index|]
operator|=
literal|'/'
expr_stmt|;
name|entries
index|[
name|i
index|]
operator|.
name|utf16name
index|[
name|entries
index|[
name|i
index|]
operator|.
name|name_len
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|entries
index|[
name|i
index|]
operator|.
name|name_len
operator|+=
literal|2
expr_stmt|;
block|}
name|entries
index|[
name|i
index|]
operator|.
name|ssIndex
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|entries
index|[
name|i
index|]
operator|.
name|attr
operator|&
literal|0x01
condition|)
name|entries
index|[
name|i
index|]
operator|.
name|mode
operator|&=
operator|~
literal|0222
expr_stmt|;
comment|/* Read only. */
if|if
condition|(
operator|(
name|entries
index|[
name|i
index|]
operator|.
name|flg
operator|&
name|HAS_STREAM
operator|)
operator|==
literal|0
operator|&&
name|indexInFolder
operator|==
literal|0
condition|)
block|{
comment|/* 			 * The entry is an empty file or a directory file, 			 * those both have no contents. 			 */
name|entries
index|[
name|i
index|]
operator|.
name|folderIndex
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|indexInFolder
operator|==
literal|0
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|folderIndex
operator|>=
name|si
operator|->
name|ci
operator|.
name|numFolders
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|folders
index|[
name|folderIndex
index|]
operator|.
name|numUnpackStreams
condition|)
break|break;
name|folderIndex
operator|++
expr_stmt|;
block|}
block|}
name|entries
index|[
name|i
index|]
operator|.
name|folderIndex
operator|=
name|folderIndex
expr_stmt|;
if|if
condition|(
operator|(
name|entries
index|[
name|i
index|]
operator|.
name|flg
operator|&
name|HAS_STREAM
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|indexInFolder
operator|++
expr_stmt|;
if|if
condition|(
name|indexInFolder
operator|>=
name|folders
index|[
name|folderIndex
index|]
operator|.
name|numUnpackStreams
condition|)
block|{
name|folderIndex
operator|++
expr_stmt|;
name|indexInFolder
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|EPOC_TIME
value|ARCHIVE_LITERAL_ULL(116444736000000000)
end_define

begin_function
specifier|static
name|void
name|fileTimeToUtc
parameter_list|(
name|uint64_t
name|fileTime
parameter_list|,
name|time_t
modifier|*
name|timep
parameter_list|,
name|long
modifier|*
name|ns
parameter_list|)
block|{
if|if
condition|(
name|fileTime
operator|>=
name|EPOC_TIME
condition|)
block|{
name|fileTime
operator|-=
name|EPOC_TIME
expr_stmt|;
comment|/* milli seconds base */
operator|*
name|timep
operator|=
call|(
name|time_t
call|)
argument_list|(
name|fileTime
operator|/
literal|10000000
argument_list|)
expr_stmt|;
comment|/* nano seconds base */
operator|*
name|ns
operator|=
call|(
name|long
call|)
argument_list|(
name|fileTime
operator|%
literal|10000000
argument_list|)
operator|*
literal|100
expr_stmt|;
block|}
else|else
block|{
operator|*
name|timep
operator|=
literal|0
expr_stmt|;
operator|*
name|ns
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|read_Times
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|_7z_header_info
modifier|*
name|h
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|_7zip
modifier|*
name|zip
init|=
operator|(
expr|struct
name|_7zip
operator|*
operator|)
name|a
operator|->
name|format
operator|->
name|data
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|_7zip_entry
modifier|*
name|entries
init|=
name|zip
operator|->
name|entries
decl_stmt|;
name|unsigned
name|char
modifier|*
name|timeBools
decl_stmt|;
name|int
name|allAreDefined
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|timeBools
operator|=
name|calloc
argument_list|(
operator|(
name|size_t
operator|)
name|zip
operator|->
name|numFiles
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|timeBools
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeBools
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Read allAreDefined. */
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
name|allAreDefined
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|allAreDefined
condition|)
name|memset
argument_list|(
name|timeBools
argument_list|,
literal|1
argument_list|,
operator|(
name|size_t
operator|)
name|zip
operator|->
name|numFiles
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|read_Bools
argument_list|(
name|a
argument_list|,
name|timeBools
argument_list|,
operator|(
name|size_t
operator|)
name|zip
operator|->
name|numFiles
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|failed
goto|;
block|}
comment|/* Read external. */
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
name|parse_7zip_uint64
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|h
operator|->
name|dataIndex
operator|)
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
literal|1000000
operator|<
name|h
operator|->
name|dataIndex
condition|)
goto|goto
name|failed
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zip
operator|->
name|numFiles
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|timeBools
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|8
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|kCTime
case|:
name|fileTimeToUtc
argument_list|(
name|archive_le64dec
argument_list|(
name|p
argument_list|)
argument_list|,
operator|&
operator|(
name|entries
index|[
name|i
index|]
operator|.
name|ctime
operator|)
argument_list|,
operator|&
operator|(
name|entries
index|[
name|i
index|]
operator|.
name|ctime_ns
operator|)
argument_list|)
expr_stmt|;
name|entries
index|[
name|i
index|]
operator|.
name|flg
operator||=
name|CTIME_IS_SET
expr_stmt|;
break|break;
case|case
name|kATime
case|:
name|fileTimeToUtc
argument_list|(
name|archive_le64dec
argument_list|(
name|p
argument_list|)
argument_list|,
operator|&
operator|(
name|entries
index|[
name|i
index|]
operator|.
name|atime
operator|)
argument_list|,
operator|&
operator|(
name|entries
index|[
name|i
index|]
operator|.
name|atime_ns
operator|)
argument_list|)
expr_stmt|;
name|entries
index|[
name|i
index|]
operator|.
name|flg
operator||=
name|ATIME_IS_SET
expr_stmt|;
break|break;
case|case
name|kMTime
case|:
name|fileTimeToUtc
argument_list|(
name|archive_le64dec
argument_list|(
name|p
argument_list|)
argument_list|,
operator|&
operator|(
name|entries
index|[
name|i
index|]
operator|.
name|mtime
operator|)
argument_list|,
operator|&
operator|(
name|entries
index|[
name|i
index|]
operator|.
name|mtime_ns
operator|)
argument_list|)
expr_stmt|;
name|entries
index|[
name|i
index|]
operator|.
name|flg
operator||=
name|MTIME_IS_SET
expr_stmt|;
break|break;
block|}
block|}
name|free
argument_list|(
name|timeBools
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|failed
label|:
name|free
argument_list|(
name|timeBools
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|decode_encoded_header_info
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|_7z_stream_info
modifier|*
name|si
parameter_list|)
block|{
name|struct
name|_7zip
modifier|*
name|zip
init|=
operator|(
expr|struct
name|_7zip
operator|*
operator|)
name|a
operator|->
name|format
operator|->
name|data
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|read_StreamsInfo
argument_list|(
name|a
argument_list|,
name|si
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
operator|-
literal|1
argument_list|,
literal|"Couldn't allocate memory"
argument_list|)
expr_stmt|;
else|else
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
operator|-
literal|1
argument_list|,
literal|"Malformed 7-Zip archive"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|si
operator|->
name|pi
operator|.
name|numPackStreams
operator|==
literal|0
operator|||
name|si
operator|->
name|ci
operator|.
name|numFolders
operator|==
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
operator|-
literal|1
argument_list|,
literal|"Malformed 7-Zip archive"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|zip
operator|->
name|header_offset
operator|<
name|si
operator|->
name|pi
operator|.
name|pos
operator|+
name|si
operator|->
name|pi
operator|.
name|sizes
index|[
literal|0
index|]
operator|||
call|(
name|int64_t
call|)
argument_list|(
name|si
operator|->
name|pi
operator|.
name|pos
operator|+
name|si
operator|->
name|pi
operator|.
name|sizes
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
operator|||
name|si
operator|->
name|pi
operator|.
name|sizes
index|[
literal|0
index|]
operator|==
literal|0
operator|||
operator|(
name|int64_t
operator|)
name|si
operator|->
name|pi
operator|.
name|pos
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
operator|-
literal|1
argument_list|,
literal|"Malformed Header offset"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|header_bytes
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|size_t
name|rbytes
parameter_list|)
block|{
name|struct
name|_7zip
modifier|*
name|zip
init|=
operator|(
expr|struct
name|_7zip
operator|*
operator|)
name|a
operator|->
name|format
operator|->
name|data
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|zip
operator|->
name|header_bytes_remaining
operator|<
name|rbytes
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|zip
operator|->
name|pack_stream_bytes_unconsumed
condition|)
name|read_consume
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|header_is_encoded
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|rbytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|zip
operator|->
name|header_bytes_remaining
operator|-=
name|rbytes
expr_stmt|;
name|zip
operator|->
name|pack_stream_bytes_unconsumed
operator|=
name|rbytes
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|void
modifier|*
name|buff
decl_stmt|;
name|ssize_t
name|bytes
decl_stmt|;
name|bytes
operator|=
name|read_stream
argument_list|(
name|a
argument_list|,
operator|&
name|buff
argument_list|,
name|rbytes
argument_list|,
name|rbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|<=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|zip
operator|->
name|header_bytes_remaining
operator|-=
name|bytes
expr_stmt|;
name|p
operator|=
name|buff
expr_stmt|;
block|}
comment|/* Update checksum */
name|zip
operator|->
name|header_crc32
operator|=
name|crc32
argument_list|(
name|zip
operator|->
name|header_crc32
argument_list|,
name|p
argument_list|,
name|rbytes
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|slurp_central_directory
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|_7zip
modifier|*
name|zip
parameter_list|,
name|struct
name|_7z_header_info
modifier|*
name|header
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|uint64_t
name|next_header_offset
decl_stmt|;
name|uint64_t
name|next_header_size
decl_stmt|;
name|uint32_t
name|next_header_crc
decl_stmt|;
name|ssize_t
name|bytes_avail
decl_stmt|;
name|int
name|check_header_crc
decl_stmt|,
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|32
argument_list|,
operator|&
name|bytes_avail
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'M'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'Z'
operator|)
operator|||
name|memcmp
argument_list|(
name|p
argument_list|,
literal|"\x7F\x45LF"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This is an executable ? Must be self-extracting... */
name|r
operator|=
name|skip_sfx
argument_list|(
name|a
argument_list|,
name|bytes_avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|ARCHIVE_WARN
condition|)
return|return
operator|(
name|r
operator|)
return|;
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|32
argument_list|,
operator|&
name|bytes_avail
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|zip
operator|->
name|seek_base
operator|+=
literal|32
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|p
argument_list|,
name|_7ZIP_SIGNATURE
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
operator|-
literal|1
argument_list|,
literal|"Not 7-Zip archive file"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* CRC check. */
if|if
condition|(
name|crc32
argument_list|(
literal|0
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|p
operator|+
literal|12
argument_list|,
literal|20
argument_list|)
operator|!=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|8
argument_list|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
operator|-
literal|1
argument_list|,
literal|"Header CRC error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|next_header_offset
operator|=
name|archive_le64dec
argument_list|(
name|p
operator|+
literal|12
argument_list|)
expr_stmt|;
name|next_header_size
operator|=
name|archive_le64dec
argument_list|(
name|p
operator|+
literal|20
argument_list|)
expr_stmt|;
name|next_header_crc
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|28
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_header_size
operator|==
literal|0
condition|)
comment|/* There is no entry in an archive file. */
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
if|if
condition|(
operator|(
operator|(
name|int64_t
operator|)
name|next_header_offset
operator|)
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
operator|-
literal|1
argument_list|,
literal|"Malformed 7-Zip archive"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_header_offset
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bytes_avail
operator|>=
operator|(
name|ssize_t
operator|)
name|next_header_offset
condition|)
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|next_header_offset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|__archive_read_seek
argument_list|(
name|a
argument_list|,
name|next_header_offset
operator|+
name|zip
operator|->
name|seek_base
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|zip
operator|->
name|stream_offset
operator|=
name|next_header_offset
expr_stmt|;
name|zip
operator|->
name|header_offset
operator|=
name|next_header_offset
expr_stmt|;
name|zip
operator|->
name|header_bytes_remaining
operator|=
name|next_header_size
expr_stmt|;
name|zip
operator|->
name|header_crc32
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|header_is_encoded
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|header_is_being_read
operator|=
literal|1
expr_stmt|;
name|check_header_crc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated 7-Zip file body"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Parse ArchiveProperties. */
switch|switch
condition|(
name|p
index|[
literal|0
index|]
condition|)
block|{
case|case
name|kEncodedHeader
case|:
comment|/* 		 * The archive has an encoded header and we have to decode it 		 * in order to parse the header correctly. 		 */
name|r
operator|=
name|decode_encoded_header_info
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|zip
operator|->
name|si
operator|)
argument_list|)
expr_stmt|;
comment|/* Check the EncodedHeader CRC.*/
if|if
condition|(
name|r
operator|==
literal|0
operator|&&
name|zip
operator|->
name|header_crc32
operator|!=
name|next_header_crc
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
operator|-
literal|1
argument_list|,
literal|"Damaged 7-Zip archive"
argument_list|)
expr_stmt|;
name|r
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|zip
operator|->
name|si
operator|.
name|ci
operator|.
name|folders
index|[
literal|0
index|]
operator|.
name|digest_defined
condition|)
name|next_header_crc
operator|=
name|zip
operator|->
name|si
operator|.
name|ci
operator|.
name|folders
index|[
literal|0
index|]
operator|.
name|digest
expr_stmt|;
else|else
name|check_header_crc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|pack_stream_bytes_unconsumed
condition|)
name|read_consume
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|r
operator|=
name|setup_decode_folder
argument_list|(
name|a
argument_list|,
name|zip
operator|->
name|si
operator|.
name|ci
operator|.
name|folders
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|zip
operator|->
name|header_bytes_remaining
operator|=
name|zip
operator|->
name|folder_outbytes_remaining
expr_stmt|;
name|r
operator|=
name|seek_pack
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Clean up StreamsInfo. */
name|free_StreamsInfo
argument_list|(
operator|&
operator|(
name|zip
operator|->
name|si
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
operator|(
name|zip
operator|->
name|si
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|zip
operator|->
name|si
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|zip
operator|->
name|header_is_encoded
operator|=
literal|1
expr_stmt|;
name|zip
operator|->
name|header_crc32
operator|=
literal|0
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|kHeader
case|:
comment|/* 		 * Parse the header. 		 */
name|errno
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|read_Header
argument_list|(
name|a
argument_list|,
name|header
argument_list|,
name|zip
operator|->
name|header_is_encoded
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
operator|-
literal|1
argument_list|,
literal|"Couldn't allocate memory"
argument_list|)
expr_stmt|;
else|else
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
operator|-
literal|1
argument_list|,
literal|"Damaged 7-Zip archive"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* 		 *  Must be kEnd. 		 */
if|if
condition|(
operator|(
name|p
operator|=
name|header_bytes
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|*
name|p
operator|!=
name|kEnd
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
operator|-
literal|1
argument_list|,
literal|"Malformed 7-Zip archive"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Check the Header CRC.*/
if|if
condition|(
name|check_header_crc
operator|&&
name|zip
operator|->
name|header_crc32
operator|!=
name|next_header_crc
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
operator|-
literal|1
argument_list|,
literal|"Malformed 7-Zip archive"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
break|break;
default|default:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
operator|-
literal|1
argument_list|,
literal|"Unexpected Property ID = %X"
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Clean up variables be used for decoding the archive header */
name|zip
operator|->
name|pack_stream_remaining
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|pack_stream_index
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|folder_outbytes_remaining
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|uncompressed_buffer_bytes_remaining
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|pack_stream_bytes_unconsumed
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|header_is_being_read
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|get_uncompressed_data
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|minimum
parameter_list|)
block|{
name|struct
name|_7zip
modifier|*
name|zip
init|=
operator|(
expr|struct
name|_7zip
operator|*
operator|)
name|a
operator|->
name|format
operator|->
name|data
decl_stmt|;
name|ssize_t
name|bytes_avail
decl_stmt|;
if|if
condition|(
name|zip
operator|->
name|codec
operator|==
name|_7Z_COPY
operator|&&
name|zip
operator|->
name|codec2
operator|==
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* Copy mode. */
comment|/* 		 * Note: '1' here is a performance optimization. 		 * Recall that the decompression layer returns a count of 		 * available bytes; asking for more than that forces the 		 * decompressor to combine reads by copying data. 		 */
operator|*
name|buff
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
operator|&
name|bytes_avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_avail
operator|<=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated 7-Zip file data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|size_t
operator|)
name|bytes_avail
operator|>
name|zip
operator|->
name|uncompressed_buffer_bytes_remaining
condition|)
name|bytes_avail
operator|=
operator|(
name|ssize_t
operator|)
name|zip
operator|->
name|uncompressed_buffer_bytes_remaining
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|bytes_avail
operator|>
name|size
condition|)
name|bytes_avail
operator|=
operator|(
name|ssize_t
operator|)
name|size
expr_stmt|;
name|zip
operator|->
name|pack_stream_bytes_unconsumed
operator|=
name|bytes_avail
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zip
operator|->
name|uncompressed_buffer_pointer
operator|==
name|NULL
condition|)
block|{
comment|/* Decompression has failed. */
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Damaged 7-Zip archive"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
else|else
block|{
comment|/* Packed mode. */
if|if
condition|(
name|minimum
operator|>
name|zip
operator|->
name|uncompressed_buffer_bytes_remaining
condition|)
block|{
comment|/* 			 * If remaining uncompressed data size is less than 			 * the minimum size, fill the buffer up to the 			 * minimum size. 			 */
if|if
condition|(
name|extract_pack_stream
argument_list|(
name|a
argument_list|,
name|minimum
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|size
operator|>
name|zip
operator|->
name|uncompressed_buffer_bytes_remaining
condition|)
name|bytes_avail
operator|=
operator|(
name|ssize_t
operator|)
name|zip
operator|->
name|uncompressed_buffer_bytes_remaining
expr_stmt|;
else|else
name|bytes_avail
operator|=
operator|(
name|ssize_t
operator|)
name|size
expr_stmt|;
operator|*
name|buff
operator|=
name|zip
operator|->
name|uncompressed_buffer_pointer
expr_stmt|;
name|zip
operator|->
name|uncompressed_buffer_pointer
operator|+=
name|bytes_avail
expr_stmt|;
block|}
name|zip
operator|->
name|uncompressed_buffer_bytes_remaining
operator|-=
name|bytes_avail
expr_stmt|;
return|return
operator|(
name|bytes_avail
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|extract_pack_stream
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|size_t
name|minimum
parameter_list|)
block|{
name|struct
name|_7zip
modifier|*
name|zip
init|=
operator|(
expr|struct
name|_7zip
operator|*
operator|)
name|a
operator|->
name|format
operator|->
name|data
decl_stmt|;
name|ssize_t
name|bytes_avail
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|zip
operator|->
name|codec
operator|==
name|_7Z_COPY
operator|&&
name|zip
operator|->
name|codec2
operator|==
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|minimum
operator|==
literal|0
condition|)
name|minimum
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|minimum
argument_list|,
operator|&
name|bytes_avail
argument_list|)
operator|==
name|NULL
operator|||
name|bytes_avail
operator|<=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated 7-Zip file body"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|bytes_avail
operator|>
operator|(
name|ssize_t
operator|)
name|zip
operator|->
name|pack_stream_inbytes_remaining
condition|)
name|bytes_avail
operator|=
operator|(
name|ssize_t
operator|)
name|zip
operator|->
name|pack_stream_inbytes_remaining
expr_stmt|;
name|zip
operator|->
name|pack_stream_inbytes_remaining
operator|-=
name|bytes_avail
expr_stmt|;
if|if
condition|(
name|bytes_avail
operator|>
operator|(
name|ssize_t
operator|)
name|zip
operator|->
name|folder_outbytes_remaining
condition|)
name|bytes_avail
operator|=
operator|(
name|ssize_t
operator|)
name|zip
operator|->
name|folder_outbytes_remaining
expr_stmt|;
name|zip
operator|->
name|folder_outbytes_remaining
operator|-=
name|bytes_avail
expr_stmt|;
name|zip
operator|->
name|uncompressed_buffer_bytes_remaining
operator|=
name|bytes_avail
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
comment|/* If the buffer hasn't been allocated, allocate it now. */
if|if
condition|(
name|zip
operator|->
name|uncompressed_buffer
operator|==
name|NULL
condition|)
block|{
name|zip
operator|->
name|uncompressed_buffer_size
operator|=
name|UBUFF_SIZE
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|uncompressed_buffer_size
operator|<
name|minimum
condition|)
block|{
name|zip
operator|->
name|uncompressed_buffer_size
operator|=
name|minimum
operator|+
literal|1023
expr_stmt|;
name|zip
operator|->
name|uncompressed_buffer_size
operator|&=
operator|~
literal|0x3ff
expr_stmt|;
block|}
name|zip
operator|->
name|uncompressed_buffer
operator|=
name|malloc
argument_list|(
name|zip
operator|->
name|uncompressed_buffer_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|uncompressed_buffer
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"No memory for 7-Zip decompression"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|zip
operator|->
name|uncompressed_buffer_bytes_remaining
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zip
operator|->
name|uncompressed_buffer_size
operator|<
name|minimum
operator|||
name|zip
operator|->
name|uncompressed_buffer_bytes_remaining
operator|<
name|minimum
condition|)
block|{
comment|/* 		 * Make sure the uncompressed buffer can have bytes 		 * at least `minimum' bytes. 		 * NOTE: This case happen when reading the header. 		 */
name|size_t
name|used
decl_stmt|;
if|if
condition|(
name|zip
operator|->
name|uncompressed_buffer_pointer
operator|!=
literal|0
condition|)
name|used
operator|=
name|zip
operator|->
name|uncompressed_buffer_pointer
operator|-
name|zip
operator|->
name|uncompressed_buffer
expr_stmt|;
else|else
name|used
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|uncompressed_buffer_size
operator|<
name|minimum
condition|)
block|{
comment|/* 			 * Expand the uncompressed buffer up to 			 * the minimum size. 			 */
name|zip
operator|->
name|uncompressed_buffer_size
operator|=
name|minimum
operator|+
literal|1023
expr_stmt|;
name|zip
operator|->
name|uncompressed_buffer_size
operator|&=
operator|~
literal|0x3ff
expr_stmt|;
name|zip
operator|->
name|uncompressed_buffer
operator|=
name|realloc
argument_list|(
name|zip
operator|->
name|uncompressed_buffer
argument_list|,
name|zip
operator|->
name|uncompressed_buffer_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|uncompressed_buffer
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"No memory for 7-Zip decompression"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
comment|/* 		 * Move unconsumed bytes to the head. 		 */
if|if
condition|(
name|used
condition|)
block|{
name|memmove
argument_list|(
name|zip
operator|->
name|uncompressed_buffer
argument_list|,
name|zip
operator|->
name|uncompressed_buffer
operator|+
name|used
argument_list|,
name|zip
operator|->
name|uncompressed_buffer_bytes_remaining
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|zip
operator|->
name|uncompressed_buffer_bytes_remaining
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|uncompressed_buffer_pointer
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|size_t
name|bytes_in
decl_stmt|,
name|bytes_out
decl_stmt|;
specifier|const
name|void
modifier|*
name|buff_in
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buff_out
decl_stmt|;
name|int
name|end_of_data
decl_stmt|;
comment|/* 		 * Note: '1' here is a performance optimization. 		 * Recall that the decompression layer returns a count of 		 * available bytes; asking for more than that forces the 		 * decompressor to combine reads by copying data. 		 */
name|buff_in
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
operator|&
name|bytes_avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_avail
operator|<=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated 7-Zip file body"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|buff_out
operator|=
name|zip
operator|->
name|uncompressed_buffer
operator|+
name|zip
operator|->
name|uncompressed_buffer_bytes_remaining
expr_stmt|;
name|bytes_out
operator|=
name|zip
operator|->
name|uncompressed_buffer_size
operator|-
name|zip
operator|->
name|uncompressed_buffer_bytes_remaining
expr_stmt|;
name|bytes_in
operator|=
name|bytes_avail
expr_stmt|;
if|if
condition|(
name|bytes_in
operator|>
name|zip
operator|->
name|pack_stream_inbytes_remaining
condition|)
name|bytes_in
operator|=
operator|(
name|size_t
operator|)
name|zip
operator|->
name|pack_stream_inbytes_remaining
expr_stmt|;
comment|/* Drive decompression. */
name|r
operator|=
name|decompress
argument_list|(
name|a
argument_list|,
name|zip
argument_list|,
name|buff_out
argument_list|,
operator|&
name|bytes_out
argument_list|,
name|buff_in
argument_list|,
operator|&
name|bytes_in
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|ARCHIVE_OK
case|:
name|end_of_data
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ARCHIVE_EOF
case|:
name|end_of_data
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|zip
operator|->
name|pack_stream_inbytes_remaining
operator|-=
name|bytes_in
expr_stmt|;
if|if
condition|(
name|bytes_out
operator|>
name|zip
operator|->
name|folder_outbytes_remaining
condition|)
name|bytes_out
operator|=
operator|(
name|size_t
operator|)
name|zip
operator|->
name|folder_outbytes_remaining
expr_stmt|;
name|zip
operator|->
name|folder_outbytes_remaining
operator|-=
name|bytes_out
expr_stmt|;
name|zip
operator|->
name|uncompressed_buffer_bytes_remaining
operator|+=
name|bytes_out
expr_stmt|;
name|zip
operator|->
name|pack_stream_bytes_unconsumed
operator|=
name|bytes_in
expr_stmt|;
comment|/* 		 * Continue decompression until uncompressed_buffer is full. 		 */
if|if
condition|(
name|zip
operator|->
name|uncompressed_buffer_bytes_remaining
operator|==
name|zip
operator|->
name|uncompressed_buffer_size
condition|)
break|break;
if|if
condition|(
name|zip
operator|->
name|codec2
operator|==
name|_7Z_X86
operator|&&
name|zip
operator|->
name|odd_bcj_size
operator|&&
name|zip
operator|->
name|uncompressed_buffer_bytes_remaining
operator|+
literal|5
operator|>
name|zip
operator|->
name|uncompressed_buffer_size
condition|)
break|break;
if|if
condition|(
name|zip
operator|->
name|pack_stream_inbytes_remaining
operator|==
literal|0
operator|&&
name|zip
operator|->
name|folder_outbytes_remaining
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|end_of_data
operator|||
operator|(
name|bytes_in
operator|==
literal|0
operator|&&
name|bytes_out
operator|==
literal|0
operator|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Damaged 7-Zip archive"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|read_consume
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zip
operator|->
name|uncompressed_buffer_bytes_remaining
operator|<
name|minimum
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Damaged 7-Zip archive"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|zip
operator|->
name|uncompressed_buffer_pointer
operator|=
name|zip
operator|->
name|uncompressed_buffer
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|seek_pack
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|_7zip
modifier|*
name|zip
init|=
operator|(
expr|struct
name|_7zip
operator|*
operator|)
name|a
operator|->
name|format
operator|->
name|data
decl_stmt|;
name|int64_t
name|pack_offset
decl_stmt|;
if|if
condition|(
name|zip
operator|->
name|pack_stream_remaining
operator|<=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Damaged 7-Zip archive"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|zip
operator|->
name|pack_stream_inbytes_remaining
operator|=
name|zip
operator|->
name|si
operator|.
name|pi
operator|.
name|sizes
index|[
name|zip
operator|->
name|pack_stream_index
index|]
expr_stmt|;
name|pack_offset
operator|=
name|zip
operator|->
name|si
operator|.
name|pi
operator|.
name|positions
index|[
name|zip
operator|->
name|pack_stream_index
index|]
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|stream_offset
operator|!=
name|pack_offset
condition|)
block|{
if|if
condition|(
literal|0
operator|>
name|__archive_read_seek
argument_list|(
name|a
argument_list|,
name|pack_offset
operator|+
name|zip
operator|->
name|seek_base
argument_list|,
name|SEEK_SET
argument_list|)
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|zip
operator|->
name|stream_offset
operator|=
name|pack_offset
expr_stmt|;
block|}
name|zip
operator|->
name|pack_stream_index
operator|++
expr_stmt|;
name|zip
operator|->
name|pack_stream_remaining
operator|--
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|read_stream
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|minimum
parameter_list|)
block|{
name|struct
name|_7zip
modifier|*
name|zip
init|=
operator|(
expr|struct
name|_7zip
operator|*
operator|)
name|a
operator|->
name|format
operator|->
name|data
decl_stmt|;
name|uint64_t
name|skip_bytes
init|=
literal|0
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|zip
operator|->
name|uncompressed_buffer_bytes_remaining
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|zip
operator|->
name|pack_stream_inbytes_remaining
operator|>
literal|0
condition|)
block|{
name|r
operator|=
name|extract_pack_stream
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
return|return
operator|(
name|get_uncompressed_data
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|size
argument_list|,
name|minimum
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|zip
operator|->
name|folder_outbytes_remaining
operator|>
literal|0
condition|)
block|{
comment|/* Extract a remaining pack stream. */
name|r
operator|=
name|extract_pack_stream
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
return|return
operator|(
name|get_uncompressed_data
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|size
argument_list|,
name|minimum
argument_list|)
operator|)
return|;
block|}
block|}
else|else
return|return
operator|(
name|get_uncompressed_data
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|size
argument_list|,
name|minimum
argument_list|)
operator|)
return|;
comment|/* 	 * Current pack stream has been consumed. 	 */
if|if
condition|(
name|zip
operator|->
name|pack_stream_remaining
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|zip
operator|->
name|header_is_being_read
condition|)
block|{
comment|/* Invalid sequence. This might happen when 			 * reading a malformed archive. */
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Malformed 7-Zip archive"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* 		 * All current folder's pack streams have been 		 * consumed. Switch to next folder. 		 */
if|if
condition|(
name|zip
operator|->
name|folder_index
operator|==
literal|0
operator|&&
operator|(
name|zip
operator|->
name|si
operator|.
name|ci
operator|.
name|folders
index|[
name|zip
operator|->
name|entry
operator|->
name|folderIndex
index|]
operator|.
name|skipped_bytes
operator|||
name|zip
operator|->
name|folder_index
operator|!=
name|zip
operator|->
name|entry
operator|->
name|folderIndex
operator|)
condition|)
block|{
name|zip
operator|->
name|folder_index
operator|=
name|zip
operator|->
name|entry
operator|->
name|folderIndex
expr_stmt|;
name|skip_bytes
operator|=
name|zip
operator|->
name|si
operator|.
name|ci
operator|.
name|folders
index|[
name|zip
operator|->
name|folder_index
index|]
operator|.
name|skipped_bytes
expr_stmt|;
block|}
if|if
condition|(
name|zip
operator|->
name|folder_index
operator|>=
name|zip
operator|->
name|si
operator|.
name|ci
operator|.
name|numFolders
condition|)
block|{
comment|/* 			 * We have consumed all folders and its pack streams. 			 */
operator|*
name|buff
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|r
operator|=
name|setup_decode_folder
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|zip
operator|->
name|si
operator|.
name|ci
operator|.
name|folders
index|[
name|zip
operator|->
name|folder_index
index|]
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|zip
operator|->
name|folder_index
operator|++
expr_stmt|;
block|}
comment|/* 	 * Switch to next pack stream. 	 */
name|r
operator|=
name|seek_pack
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
comment|/* Extract a new pack stream. */
name|r
operator|=
name|extract_pack_stream
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
comment|/* 	 * Skip the bytes we alrady has skipped in skip_stream().  	 */
while|while
condition|(
name|skip_bytes
condition|)
block|{
name|ssize_t
name|skipped
decl_stmt|;
if|if
condition|(
name|zip
operator|->
name|uncompressed_buffer_bytes_remaining
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|zip
operator|->
name|pack_stream_inbytes_remaining
operator|>
literal|0
condition|)
block|{
name|r
operator|=
name|extract_pack_stream
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|zip
operator|->
name|folder_outbytes_remaining
operator|>
literal|0
condition|)
block|{
comment|/* Extract a remaining pack stream. */
name|r
operator|=
name|extract_pack_stream
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
else|else
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated 7-Zip file body"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
name|skipped
operator|=
name|get_uncompressed_data
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
operator|(
name|size_t
operator|)
name|skip_bytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|skipped
operator|<
literal|0
condition|)
return|return
operator|(
name|skipped
operator|)
return|;
name|skip_bytes
operator|-=
name|skipped
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|pack_stream_bytes_unconsumed
condition|)
name|read_consume
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|get_uncompressed_data
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|size
argument_list|,
name|minimum
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setup_decode_folder
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|_7z_folder
modifier|*
name|folder
parameter_list|,
name|int
name|header
parameter_list|)
block|{
name|struct
name|_7zip
modifier|*
name|zip
init|=
operator|(
expr|struct
name|_7zip
operator|*
operator|)
name|a
operator|->
name|format
operator|->
name|data
decl_stmt|;
specifier|const
name|struct
name|_7z_coder
modifier|*
name|coder1
decl_stmt|,
modifier|*
name|coder2
decl_stmt|;
specifier|const
name|char
modifier|*
name|cname
init|=
operator|(
name|header
operator|)
condition|?
literal|"archive header"
else|:
literal|"file content"
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|int
name|r
decl_stmt|,
name|found_bcj2
init|=
literal|0
decl_stmt|;
comment|/* 	 * Release the memory which the previous folder used for BCJ2. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|zip
operator|->
name|sub_stream_buff
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|zip
operator|->
name|sub_stream_buff
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|zip
operator|->
name|sub_stream_buff
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Initialize a stream reader. 	 */
name|zip
operator|->
name|pack_stream_remaining
operator|=
operator|(
name|unsigned
operator|)
name|folder
operator|->
name|numPackedStreams
expr_stmt|;
name|zip
operator|->
name|pack_stream_index
operator|=
operator|(
name|unsigned
operator|)
name|folder
operator|->
name|packIndex
expr_stmt|;
name|zip
operator|->
name|folder_outbytes_remaining
operator|=
name|folder_uncompressed_size
argument_list|(
name|folder
argument_list|)
expr_stmt|;
name|zip
operator|->
name|uncompressed_buffer_bytes_remaining
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Check coder types. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|folder
operator|->
name|numCoders
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|folder
operator|->
name|coders
index|[
name|i
index|]
operator|.
name|codec
operator|==
name|_7Z_CRYPTO
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"The %s is encrypted, "
literal|"but currently not supported"
argument_list|,
name|cname
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|folder
operator|->
name|coders
index|[
name|i
index|]
operator|.
name|codec
operator|==
name|_7Z_X86_BCJ2
condition|)
name|found_bcj2
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|folder
operator|->
name|numCoders
operator|>
literal|2
operator|&&
operator|!
name|found_bcj2
operator|)
operator|||
name|found_bcj2
operator|>
literal|1
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"The %s is encoded with many filters, "
literal|"but currently not supported"
argument_list|,
name|cname
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|coder1
operator|=
operator|&
operator|(
name|folder
operator|->
name|coders
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|folder
operator|->
name|numCoders
operator|==
literal|2
condition|)
name|coder2
operator|=
operator|&
operator|(
name|folder
operator|->
name|coders
index|[
literal|1
index|]
operator|)
expr_stmt|;
else|else
name|coder2
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|found_bcj2
condition|)
block|{
comment|/* 		 * Preparation to decode BCJ2. 		 * Decoding BCJ2 requires four sources. Those are at least, 		 * as far as I know, two types of the storage form. 		 */
specifier|const
name|struct
name|_7z_coder
modifier|*
name|fc
init|=
name|folder
operator|->
name|coders
decl_stmt|;
specifier|static
specifier|const
name|struct
name|_7z_coder
name|coder_copy
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|NULL
block|}
decl_stmt|;
specifier|const
name|struct
name|_7z_coder
modifier|*
name|scoder
index|[
literal|3
index|]
init|=
block|{
operator|&
name|coder_copy
block|,
operator|&
name|coder_copy
block|,
operator|&
name|coder_copy
block|}
decl_stmt|;
specifier|const
name|void
modifier|*
name|buff
decl_stmt|;
name|ssize_t
name|bytes
decl_stmt|;
name|unsigned
name|char
modifier|*
name|b
index|[
literal|3
index|]
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
name|uint64_t
name|sunpack
index|[
literal|3
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
name|size_t
name|s
index|[
literal|3
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|int
name|idx
index|[
literal|3
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|}
decl_stmt|;
if|if
condition|(
name|folder
operator|->
name|numCoders
operator|==
literal|4
operator|&&
name|fc
index|[
literal|3
index|]
operator|.
name|codec
operator|==
name|_7Z_X86_BCJ2
operator|&&
name|folder
operator|->
name|numInStreams
operator|==
literal|7
operator|&&
name|folder
operator|->
name|numOutStreams
operator|==
literal|4
operator|&&
name|zip
operator|->
name|pack_stream_remaining
operator|==
literal|4
condition|)
block|{
comment|/* Source type 1 made by 7zr or 7z with -m options. */
if|if
condition|(
name|folder
operator|->
name|bindPairs
index|[
literal|0
index|]
operator|.
name|inIndex
operator|==
literal|5
condition|)
block|{
comment|/* The form made by 7zr */
name|idx
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|idx
index|[
literal|1
index|]
operator|=
literal|2
expr_stmt|;
name|idx
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|scoder
index|[
literal|1
index|]
operator|=
operator|&
operator|(
name|fc
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|scoder
index|[
literal|2
index|]
operator|=
operator|&
operator|(
name|fc
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|sunpack
index|[
literal|1
index|]
operator|=
name|folder
operator|->
name|unPackSize
index|[
literal|1
index|]
expr_stmt|;
name|sunpack
index|[
literal|2
index|]
operator|=
name|folder
operator|->
name|unPackSize
index|[
literal|0
index|]
expr_stmt|;
name|coder1
operator|=
operator|&
operator|(
name|fc
index|[
literal|2
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * NOTE: Some patterns do not work. 				 * work: 				 *  7z a -m0=BCJ2 -m1=COPY -m2=COPY 				 *       -m3=(any) 				 *  7z a -m0=BCJ2 -m1=COPY -m2=(any) 				 *       -m3=COPY 				 *  7z a -m0=BCJ2 -m1=(any) -m2=COPY 				 *       -m3=COPY 				 * not work: 				 *  other patterns. 				 * 				 * We have to handle this like `pipe' or 				 * our libarchive7s filter frame work, 				 * decoding the BCJ2 main stream sequentially, 				 * m3 -> m2 -> m1 -> BCJ2. 				 * 				 */
if|if
condition|(
name|fc
index|[
literal|0
index|]
operator|.
name|codec
operator|==
name|_7Z_COPY
operator|&&
name|fc
index|[
literal|1
index|]
operator|.
name|codec
operator|==
name|_7Z_COPY
condition|)
name|coder1
operator|=
operator|&
operator|(
name|folder
operator|->
name|coders
index|[
literal|2
index|]
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fc
index|[
literal|0
index|]
operator|.
name|codec
operator|==
name|_7Z_COPY
operator|&&
name|fc
index|[
literal|2
index|]
operator|.
name|codec
operator|==
name|_7Z_COPY
condition|)
name|coder1
operator|=
operator|&
operator|(
name|folder
operator|->
name|coders
index|[
literal|1
index|]
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fc
index|[
literal|1
index|]
operator|.
name|codec
operator|==
name|_7Z_COPY
operator|&&
name|fc
index|[
literal|2
index|]
operator|.
name|codec
operator|==
name|_7Z_COPY
condition|)
name|coder1
operator|=
operator|&
operator|(
name|folder
operator|->
name|coders
index|[
literal|0
index|]
operator|)
expr_stmt|;
else|else
block|{
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Unsupported form of "
literal|"BCJ2 streams"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
name|coder2
operator|=
operator|&
operator|(
name|fc
index|[
literal|3
index|]
operator|)
expr_stmt|;
name|zip
operator|->
name|main_stream_bytes_remaining
operator|=
operator|(
name|size_t
operator|)
name|folder
operator|->
name|unPackSize
index|[
literal|2
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|coder2
operator|!=
name|NULL
operator|&&
name|coder2
operator|->
name|codec
operator|==
name|_7Z_X86_BCJ2
operator|&&
name|zip
operator|->
name|pack_stream_remaining
operator|==
literal|4
operator|&&
name|folder
operator|->
name|numInStreams
operator|==
literal|5
operator|&&
name|folder
operator|->
name|numOutStreams
operator|==
literal|2
condition|)
block|{
comment|/* Source type 0 made by 7z */
name|zip
operator|->
name|main_stream_bytes_remaining
operator|=
operator|(
name|size_t
operator|)
name|folder
operator|->
name|unPackSize
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* We got an unexpected form. */
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Unsupported form of BCJ2 streams"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Skip the main stream at this time. */
if|if
condition|(
operator|(
name|r
operator|=
name|seek_pack
argument_list|(
name|a
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|zip
operator|->
name|pack_stream_bytes_unconsumed
operator|=
operator|(
name|size_t
operator|)
name|zip
operator|->
name|pack_stream_inbytes_remaining
expr_stmt|;
name|read_consume
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|/* Read following three sub streams. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|_7z_coder
modifier|*
name|coder
init|=
name|scoder
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|seek_pack
argument_list|(
name|a
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
if|if
condition|(
name|sunpack
index|[
name|i
index|]
operator|==
operator|(
name|uint64_t
operator|)
operator|-
literal|1
condition|)
name|zip
operator|->
name|folder_outbytes_remaining
operator|=
name|zip
operator|->
name|pack_stream_inbytes_remaining
expr_stmt|;
else|else
name|zip
operator|->
name|folder_outbytes_remaining
operator|=
name|sunpack
index|[
name|i
index|]
expr_stmt|;
name|r
operator|=
name|init_decompression
argument_list|(
name|a
argument_list|,
name|zip
argument_list|,
name|coder
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
comment|/* Allocate memory for the decorded data of a sub 			 * stream. */
name|b
index|[
name|i
index|]
operator|=
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|zip
operator|->
name|folder_outbytes_remaining
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"No memory for 7-Zip decompression"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Extract a sub stream. */
while|while
condition|(
name|zip
operator|->
name|pack_stream_inbytes_remaining
operator|>
literal|0
condition|)
block|{
name|r
operator|=
name|extract_pack_stream
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|bytes
operator|=
name|get_uncompressed_data
argument_list|(
name|a
argument_list|,
operator|&
name|buff
argument_list|,
name|zip
operator|->
name|uncompressed_buffer_bytes_remaining
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|<
literal|0
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|bytes
operator|)
return|;
name|memcpy
argument_list|(
name|b
index|[
name|i
index|]
operator|+
name|s
index|[
name|i
index|]
argument_list|,
name|buff
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|s
index|[
name|i
index|]
operator|+=
name|bytes
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|pack_stream_bytes_unconsumed
condition|)
name|read_consume
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Set the sub streams to the right place. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|zip
operator|->
name|sub_stream_buff
index|[
name|i
index|]
operator|=
name|b
index|[
name|idx
index|[
name|i
index|]
index|]
expr_stmt|;
name|zip
operator|->
name|sub_stream_size
index|[
name|i
index|]
operator|=
name|s
index|[
name|idx
index|[
name|i
index|]
index|]
expr_stmt|;
name|zip
operator|->
name|sub_stream_bytes_remaining
index|[
name|i
index|]
operator|=
name|s
index|[
name|idx
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
comment|/* Allocate memory used for decoded main stream bytes. */
if|if
condition|(
name|zip
operator|->
name|tmp_stream_buff
operator|==
name|NULL
condition|)
block|{
name|zip
operator|->
name|tmp_stream_buff_size
operator|=
literal|32
operator|*
literal|1024
expr_stmt|;
name|zip
operator|->
name|tmp_stream_buff
operator|=
name|malloc
argument_list|(
name|zip
operator|->
name|tmp_stream_buff_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|tmp_stream_buff
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"No memory for 7-Zip decompression"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
name|zip
operator|->
name|tmp_stream_bytes_avail
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|tmp_stream_bytes_remaining
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|odd_bcj_size
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|bcj2_outPos
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Reset a stream reader in order to read the main stream 		 * of BCJ2. 		 */
name|zip
operator|->
name|pack_stream_remaining
operator|=
literal|1
expr_stmt|;
name|zip
operator|->
name|pack_stream_index
operator|=
operator|(
name|unsigned
operator|)
name|folder
operator|->
name|packIndex
expr_stmt|;
name|zip
operator|->
name|folder_outbytes_remaining
operator|=
name|folder_uncompressed_size
argument_list|(
name|folder
argument_list|)
expr_stmt|;
name|zip
operator|->
name|uncompressed_buffer_bytes_remaining
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Initialize the decompressor for the new folder's pack streams. 	 */
name|r
operator|=
name|init_decompression
argument_list|(
name|a
argument_list|,
name|zip
argument_list|,
name|coder1
argument_list|,
name|coder2
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int64_t
name|skip_stream
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|size_t
name|skip_bytes
parameter_list|)
block|{
name|struct
name|_7zip
modifier|*
name|zip
init|=
operator|(
expr|struct
name|_7zip
operator|*
operator|)
name|a
operator|->
name|format
operator|->
name|data
decl_stmt|;
specifier|const
name|void
modifier|*
name|p
decl_stmt|;
name|int64_t
name|skipped_bytes
decl_stmt|;
name|size_t
name|bytes
init|=
name|skip_bytes
decl_stmt|;
if|if
condition|(
name|zip
operator|->
name|folder_index
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Optimization for a list mode. 		 * Avoid unncecessary decoding operations. 		 */
name|zip
operator|->
name|si
operator|.
name|ci
operator|.
name|folders
index|[
name|zip
operator|->
name|entry
operator|->
name|folderIndex
index|]
operator|.
name|skipped_bytes
operator|+=
name|skip_bytes
expr_stmt|;
return|return
operator|(
name|skip_bytes
operator|)
return|;
block|}
while|while
condition|(
name|bytes
condition|)
block|{
name|skipped_bytes
operator|=
name|read_stream
argument_list|(
name|a
argument_list|,
operator|&
name|p
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|skipped_bytes
operator|<
literal|0
condition|)
return|return
operator|(
name|skipped_bytes
operator|)
return|;
if|if
condition|(
name|skipped_bytes
operator|==
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated 7-Zip file body"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|bytes
operator|-=
operator|(
name|size_t
operator|)
name|skipped_bytes
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|pack_stream_bytes_unconsumed
condition|)
name|read_consume
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|skip_bytes
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Brought from LZMA SDK.  *  * Bra86.c -- Converter for x86 code (BCJ)  * 2008-10-04 : Igor Pavlov : Public domain  *  */
end_comment

begin_define
define|#
directive|define
name|Test86MSByte
parameter_list|(
name|b
parameter_list|)
value|((b) == 0 || (b) == 0xFF)
end_define

begin_function
specifier|static
name|void
name|x86_Init
parameter_list|(
name|struct
name|_7zip
modifier|*
name|zip
parameter_list|)
block|{
name|zip
operator|->
name|bcj_state
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|bcj_prevPosT
operator|=
operator|(
name|size_t
operator|)
literal|0
operator|-
literal|1
expr_stmt|;
name|zip
operator|->
name|bcj_prevMask
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|bcj_ip
operator|=
literal|5
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|x86_Convert
parameter_list|(
name|struct
name|_7zip
modifier|*
name|zip
parameter_list|,
name|uint8_t
modifier|*
name|data
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
specifier|static
specifier|const
name|uint8_t
name|kMaskToAllowedStatus
index|[
literal|8
index|]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
specifier|static
specifier|const
name|uint8_t
name|kMaskToBitNumber
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|}
decl_stmt|;
name|size_t
name|bufferPos
decl_stmt|,
name|prevPosT
decl_stmt|;
name|uint32_t
name|ip
decl_stmt|,
name|prevMask
decl_stmt|;
if|if
condition|(
name|size
operator|<
literal|5
condition|)
return|return
literal|0
return|;
name|bufferPos
operator|=
literal|0
expr_stmt|;
name|prevPosT
operator|=
name|zip
operator|->
name|bcj_prevPosT
expr_stmt|;
name|prevMask
operator|=
name|zip
operator|->
name|bcj_prevMask
expr_stmt|;
name|ip
operator|=
name|zip
operator|->
name|bcj_ip
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|uint8_t
modifier|*
name|p
init|=
name|data
operator|+
name|bufferPos
decl_stmt|;
name|uint8_t
modifier|*
name|limit
init|=
name|data
operator|+
name|size
operator|-
literal|4
decl_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|limit
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|p
operator|&
literal|0xFE
operator|)
operator|==
literal|0xE8
condition|)
break|break;
name|bufferPos
operator|=
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|limit
condition|)
break|break;
name|prevPosT
operator|=
name|bufferPos
operator|-
name|prevPosT
expr_stmt|;
if|if
condition|(
name|prevPosT
operator|>
literal|3
condition|)
name|prevMask
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|prevMask
operator|=
operator|(
name|prevMask
operator|<<
operator|(
operator|(
name|int
operator|)
name|prevPosT
operator|-
literal|1
operator|)
operator|)
operator|&
literal|0x7
expr_stmt|;
if|if
condition|(
name|prevMask
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|char
name|b
init|=
name|p
index|[
literal|4
operator|-
name|kMaskToBitNumber
index|[
name|prevMask
index|]
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|kMaskToAllowedStatus
index|[
name|prevMask
index|]
operator|||
name|Test86MSByte
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|prevPosT
operator|=
name|bufferPos
expr_stmt|;
name|prevMask
operator|=
operator|(
operator|(
name|prevMask
operator|<<
literal|1
operator|)
operator|&
literal|0x7
operator|)
operator||
literal|1
expr_stmt|;
name|bufferPos
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
block|}
name|prevPosT
operator|=
name|bufferPos
expr_stmt|;
if|if
condition|(
name|Test86MSByte
argument_list|(
name|p
index|[
literal|4
index|]
argument_list|)
condition|)
block|{
name|uint32_t
name|src
init|=
operator|(
operator|(
name|uint32_t
operator|)
name|p
index|[
literal|4
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|p
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|p
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|p
index|[
literal|1
index|]
operator|)
decl_stmt|;
name|uint32_t
name|dest
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|uint8_t
name|b
decl_stmt|;
name|int
name|b_index
decl_stmt|;
name|dest
operator|=
name|src
operator|-
operator|(
name|ip
operator|+
operator|(
name|uint32_t
operator|)
name|bufferPos
operator|)
expr_stmt|;
if|if
condition|(
name|prevMask
operator|==
literal|0
condition|)
break|break;
name|b_index
operator|=
name|kMaskToBitNumber
index|[
name|prevMask
index|]
operator|*
literal|8
expr_stmt|;
name|b
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|dest
operator|>>
operator|(
literal|24
operator|-
name|b_index
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Test86MSByte
argument_list|(
name|b
argument_list|)
condition|)
break|break;
name|src
operator|=
name|dest
operator|^
operator|(
operator|(
literal|1
operator|<<
operator|(
literal|32
operator|-
name|b_index
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|p
index|[
literal|4
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|~
operator|(
operator|(
operator|(
name|dest
operator|>>
literal|24
operator|)
operator|&
literal|1
operator|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|dest
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|dest
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
operator|(
name|uint8_t
operator|)
name|dest
expr_stmt|;
name|bufferPos
operator|+=
literal|5
expr_stmt|;
block|}
else|else
block|{
name|prevMask
operator|=
operator|(
operator|(
name|prevMask
operator|<<
literal|1
operator|)
operator|&
literal|0x7
operator|)
operator||
literal|1
expr_stmt|;
name|bufferPos
operator|++
expr_stmt|;
block|}
block|}
name|zip
operator|->
name|bcj_prevPosT
operator|=
name|prevPosT
expr_stmt|;
name|zip
operator|->
name|bcj_prevMask
operator|=
name|prevMask
expr_stmt|;
name|zip
operator|->
name|bcj_ip
operator|+=
name|bufferPos
expr_stmt|;
return|return
operator|(
name|bufferPos
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Brought from LZMA SDK.  *  * Bcj2.c -- Converter for x86 code (BCJ2)  * 2008-10-04 : Igor Pavlov : Public domain  *  */
end_comment

begin_define
define|#
directive|define
name|SZ_ERROR_DATA
value|ARCHIVE_FAILED
end_define

begin_define
define|#
directive|define
name|IsJcc
parameter_list|(
name|b0
parameter_list|,
name|b1
parameter_list|)
value|((b0) == 0x0F&& ((b1)& 0xF0) == 0x80)
end_define

begin_define
define|#
directive|define
name|IsJ
parameter_list|(
name|b0
parameter_list|,
name|b1
parameter_list|)
value|((b1& 0xFE) == 0xE8 || IsJcc(b0, b1))
end_define

begin_define
define|#
directive|define
name|kNumTopBits
value|24
end_define

begin_define
define|#
directive|define
name|kTopValue
value|((uint32_t)1<< kNumTopBits)
end_define

begin_define
define|#
directive|define
name|kNumBitModelTotalBits
value|11
end_define

begin_define
define|#
directive|define
name|kBitModelTotal
value|(1<< kNumBitModelTotalBits)
end_define

begin_define
define|#
directive|define
name|kNumMoveBits
value|5
end_define

begin_define
define|#
directive|define
name|RC_READ_BYTE
value|(*buffer++)
end_define

begin_define
define|#
directive|define
name|RC_TEST
value|{ if (buffer == bufferLim) return SZ_ERROR_DATA; }
end_define

begin_define
define|#
directive|define
name|RC_INIT2
value|zip->bcj2_code = 0; zip->bcj2_range = 0xFFFFFFFF; \   { int ii; for (ii = 0; ii< 5; ii++) { RC_TEST; zip->bcj2_code = (zip->bcj2_code<< 8) | RC_READ_BYTE; }}
end_define

begin_define
define|#
directive|define
name|NORMALIZE
value|if (zip->bcj2_range< kTopValue) { RC_TEST; zip->bcj2_range<<= 8; zip->bcj2_code = (zip->bcj2_code<< 8) | RC_READ_BYTE; }
end_define

begin_define
define|#
directive|define
name|IF_BIT_0
parameter_list|(
name|p
parameter_list|)
value|ttt = *(p); bound = (zip->bcj2_range>> kNumBitModelTotalBits) * ttt; if (zip->bcj2_code< bound)
end_define

begin_define
define|#
directive|define
name|UPDATE_0
parameter_list|(
name|p
parameter_list|)
value|zip->bcj2_range = bound; *(p) = (CProb)(ttt + ((kBitModelTotal - ttt)>> kNumMoveBits)); NORMALIZE;
end_define

begin_define
define|#
directive|define
name|UPDATE_1
parameter_list|(
name|p
parameter_list|)
value|zip->bcj2_range -= bound; zip->bcj2_code -= bound; *(p) = (CProb)(ttt - (ttt>> kNumMoveBits)); NORMALIZE;
end_define

begin_function
specifier|static
name|ssize_t
name|Bcj2_Decode
parameter_list|(
name|struct
name|_7zip
modifier|*
name|zip
parameter_list|,
name|uint8_t
modifier|*
name|outBuf
parameter_list|,
name|size_t
name|outSize
parameter_list|)
block|{
name|size_t
name|inPos
init|=
literal|0
decl_stmt|,
name|outPos
init|=
literal|0
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|buf0
decl_stmt|,
modifier|*
name|buf1
decl_stmt|,
modifier|*
name|buf2
decl_stmt|,
modifier|*
name|buf3
decl_stmt|;
name|size_t
name|size0
decl_stmt|,
name|size1
decl_stmt|,
name|size2
decl_stmt|,
name|size3
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|buffer
decl_stmt|,
modifier|*
name|bufferLim
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|size0
operator|=
name|zip
operator|->
name|tmp_stream_bytes_remaining
expr_stmt|;
name|buf0
operator|=
name|zip
operator|->
name|tmp_stream_buff
operator|+
name|zip
operator|->
name|tmp_stream_bytes_avail
operator|-
name|size0
expr_stmt|;
name|size1
operator|=
name|zip
operator|->
name|sub_stream_bytes_remaining
index|[
literal|0
index|]
expr_stmt|;
name|buf1
operator|=
name|zip
operator|->
name|sub_stream_buff
index|[
literal|0
index|]
operator|+
name|zip
operator|->
name|sub_stream_size
index|[
literal|0
index|]
operator|-
name|size1
expr_stmt|;
name|size2
operator|=
name|zip
operator|->
name|sub_stream_bytes_remaining
index|[
literal|1
index|]
expr_stmt|;
name|buf2
operator|=
name|zip
operator|->
name|sub_stream_buff
index|[
literal|1
index|]
operator|+
name|zip
operator|->
name|sub_stream_size
index|[
literal|1
index|]
operator|-
name|size2
expr_stmt|;
name|size3
operator|=
name|zip
operator|->
name|sub_stream_bytes_remaining
index|[
literal|2
index|]
expr_stmt|;
name|buf3
operator|=
name|zip
operator|->
name|sub_stream_buff
index|[
literal|2
index|]
operator|+
name|zip
operator|->
name|sub_stream_size
index|[
literal|2
index|]
operator|-
name|size3
expr_stmt|;
name|buffer
operator|=
name|buf3
expr_stmt|;
name|bufferLim
operator|=
name|buffer
operator|+
name|size3
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|bcj_state
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Initialize. 		 */
name|zip
operator|->
name|bcj2_prevByte
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|zip
operator|->
name|bcj2_p
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|zip
operator|->
name|bcj2_p
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
name|zip
operator|->
name|bcj2_p
index|[
name|i
index|]
operator|=
name|kBitModelTotal
operator|>>
literal|1
expr_stmt|;
name|RC_INIT2
expr_stmt|;
name|zip
operator|->
name|bcj_state
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Gather the odd bytes of a previous call. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|zip
operator|->
name|odd_bcj_size
operator|>
literal|0
operator|&&
name|outPos
operator|<
name|outSize
condition|;
name|i
operator|++
control|)
block|{
name|outBuf
index|[
name|outPos
operator|++
index|]
operator|=
name|zip
operator|->
name|odd_bcj
index|[
name|i
index|]
expr_stmt|;
name|zip
operator|->
name|odd_bcj_size
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|outSize
operator|==
literal|0
condition|)
block|{
name|zip
operator|->
name|bcj2_outPos
operator|+=
name|outPos
expr_stmt|;
return|return
operator|(
name|outPos
operator|)
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|uint8_t
name|b
decl_stmt|;
name|CProb
modifier|*
name|prob
decl_stmt|;
name|uint32_t
name|bound
decl_stmt|;
name|uint32_t
name|ttt
decl_stmt|;
name|size_t
name|limit
init|=
name|size0
operator|-
name|inPos
decl_stmt|;
if|if
condition|(
name|outSize
operator|-
name|outPos
operator|<
name|limit
condition|)
name|limit
operator|=
name|outSize
operator|-
name|outPos
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|bcj_state
operator|==
literal|1
condition|)
block|{
while|while
condition|(
name|limit
operator|!=
literal|0
condition|)
block|{
name|uint8_t
name|bb
init|=
name|buf0
index|[
name|inPos
index|]
decl_stmt|;
name|outBuf
index|[
name|outPos
operator|++
index|]
operator|=
name|bb
expr_stmt|;
if|if
condition|(
name|IsJ
argument_list|(
name|zip
operator|->
name|bcj2_prevByte
argument_list|,
name|bb
argument_list|)
condition|)
block|{
name|zip
operator|->
name|bcj_state
operator|=
literal|2
expr_stmt|;
break|break;
block|}
name|inPos
operator|++
expr_stmt|;
name|zip
operator|->
name|bcj2_prevByte
operator|=
name|bb
expr_stmt|;
name|limit
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|limit
operator|==
literal|0
operator|||
name|outPos
operator|==
name|outSize
condition|)
break|break;
name|zip
operator|->
name|bcj_state
operator|=
literal|1
expr_stmt|;
name|b
operator|=
name|buf0
index|[
name|inPos
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|0xE8
condition|)
name|prob
operator|=
name|zip
operator|->
name|bcj2_p
operator|+
name|zip
operator|->
name|bcj2_prevByte
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|==
literal|0xE9
condition|)
name|prob
operator|=
name|zip
operator|->
name|bcj2_p
operator|+
literal|256
expr_stmt|;
else|else
name|prob
operator|=
name|zip
operator|->
name|bcj2_p
operator|+
literal|257
expr_stmt|;
name|IF_BIT_0
argument_list|(
argument|prob
argument_list|)
block|{
name|UPDATE_0
argument_list|(
argument|prob
argument_list|)
name|zip
operator|->
name|bcj2_prevByte
operator|=
name|b
expr_stmt|;
block|}
else|else
block|{
name|uint32_t
name|dest
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|v
decl_stmt|;
name|uint8_t
name|out
index|[
literal|4
index|]
decl_stmt|;
name|UPDATE_1
argument_list|(
argument|prob
argument_list|)
if|if
condition|(
name|b
operator|==
literal|0xE8
condition|)
block|{
name|v
operator|=
name|buf1
expr_stmt|;
if|if
condition|(
name|size1
operator|<
literal|4
condition|)
return|return
name|SZ_ERROR_DATA
return|;
name|buf1
operator|+=
literal|4
expr_stmt|;
name|size1
operator|-=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|buf2
expr_stmt|;
if|if
condition|(
name|size2
operator|<
literal|4
condition|)
return|return
name|SZ_ERROR_DATA
return|;
name|buf2
operator|+=
literal|4
expr_stmt|;
name|size2
operator|-=
literal|4
expr_stmt|;
block|}
name|dest
operator|=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|v
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|v
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|v
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|v
index|[
literal|3
index|]
operator|)
operator|)
operator|-
operator|(
operator|(
name|uint32_t
operator|)
name|zip
operator|->
name|bcj2_outPos
operator|+
name|outPos
operator|+
literal|4
operator|)
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|=
operator|(
name|uint8_t
operator|)
name|dest
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|dest
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|dest
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
name|zip
operator|->
name|bcj2_prevByte
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|dest
operator|>>
literal|24
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
operator|&&
name|outPos
operator|<
name|outSize
condition|;
name|i
operator|++
control|)
name|outBuf
index|[
name|outPos
operator|++
index|]
operator|=
name|out
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|4
condition|)
block|{
comment|/* 				 * Save odd bytes which we could not add into 				 * the output buffer because of out of space. 				 */
name|zip
operator|->
name|odd_bcj_size
operator|=
literal|4
operator|-
name|i
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
name|i
operator|-
literal|4
operator|+
name|zip
operator|->
name|odd_bcj_size
expr_stmt|;
name|zip
operator|->
name|odd_bcj
index|[
name|j
index|]
operator|=
name|out
index|[
name|i
index|]
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
name|zip
operator|->
name|tmp_stream_bytes_remaining
operator|-=
name|inPos
expr_stmt|;
name|zip
operator|->
name|sub_stream_bytes_remaining
index|[
literal|0
index|]
operator|=
name|size1
expr_stmt|;
name|zip
operator|->
name|sub_stream_bytes_remaining
index|[
literal|1
index|]
operator|=
name|size2
expr_stmt|;
name|zip
operator|->
name|sub_stream_bytes_remaining
index|[
literal|2
index|]
operator|=
name|bufferLim
operator|-
name|buffer
expr_stmt|;
name|zip
operator|->
name|bcj2_outPos
operator|+=
name|outPos
expr_stmt|;
return|return
operator|(
operator|(
name|ssize_t
operator|)
name|outPos
operator|)
return|;
block|}
end_function

end_unit

