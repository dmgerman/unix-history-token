begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010-2012 Michihiro NAKAJIMA  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"archive_platform.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ERRNO_H
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIMITS_H
end_ifdef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_if
if|#
directive|if
name|HAVE_LIBXML_XMLWRITER_H
end_if

begin_include
include|#
directive|include
file|<libxml/xmlwriter.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_BZLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<bzlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_LZMA_H
end_if

begin_include
include|#
directive|include
file|<lzma.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"archive.h"
end_include

begin_include
include|#
directive|include
file|"archive_crypto_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_endian.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry_locale.h"
end_include

begin_include
include|#
directive|include
file|"archive_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_rb.h"
end_include

begin_include
include|#
directive|include
file|"archive_string.h"
end_include

begin_include
include|#
directive|include
file|"archive_write_private.h"
end_include

begin_comment
comment|/*  * Differences to xar utility.  * - Subdocument is not supported yet.  * - ACL is not supported yet.  * - When writing an XML element<link type="<file-type>">,<file-type>  *   which is a file type a symbolic link is referencing is always marked  *   as "broken". Xar utility uses stat(2) to get the file type, but, in  *   libarcive format writer, we should not use it; if it is needed, we  *   should get about it at archive_read_disk.c.  * - It is possible to appear both<flags> and<ext2> elements.  *   Xar utility generates<flags> on BSD platform and<ext2> on Linux  *   platform.  *  */
end_comment

begin_if
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|HAVE_LIBXML_XMLWRITER_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|LIBXML_VERSION
argument_list|)
operator|&&
expr|\
name|LIBXML_VERSION
operator|>=
literal|20703
operator|)
operator|||
expr|\
operator|!
name|defined
argument_list|(
name|HAVE_ZLIB_H
argument_list|)
operator|||
expr|\
operator|!
name|defined
argument_list|(
name|ARCHIVE_HAS_MD5
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|ARCHIVE_HAS_SHA1
argument_list|)
end_if

begin_comment
comment|/*  * xar needs several external libraries.  *   o libxml2  *   o openssl or MD5/SHA1 hash function  *   o zlib  *   o bzlib2 (option)  *   o liblzma (option)  */
end_comment

begin_function
name|int
name|archive_write_set_format_xar
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_write
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_write
operator|*
operator|)
name|_a
decl_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Xar not supported on this platform"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Support xar format */
end_comment

begin_comment
comment|/*#define DEBUG_PRINT_TOC		1 */
end_comment

begin_define
define|#
directive|define
name|BAD_CAST_CONST
value|(const xmlChar *)
end_define

begin_define
define|#
directive|define
name|HEADER_MAGIC
value|0x78617221
end_define

begin_define
define|#
directive|define
name|HEADER_SIZE
value|28
end_define

begin_define
define|#
directive|define
name|HEADER_VERSION
value|1
end_define

begin_enum
enum|enum
name|sumalg
block|{
name|CKSUM_NONE
init|=
literal|0
block|,
name|CKSUM_SHA1
init|=
literal|1
block|,
name|CKSUM_MD5
init|=
literal|2
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|MD5_SIZE
value|16
end_define

begin_define
define|#
directive|define
name|SHA1_SIZE
value|20
end_define

begin_define
define|#
directive|define
name|MAX_SUM_SIZE
value|20
end_define

begin_define
define|#
directive|define
name|MD5_NAME
value|"md5"
end_define

begin_define
define|#
directive|define
name|SHA1_NAME
value|"sha1"
end_define

begin_enum
enum|enum
name|enctype
block|{
name|NONE
block|,
name|GZIP
block|,
name|BZIP2
block|,
name|LZMA
block|,
name|XZ
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|chksumwork
block|{
name|enum
name|sumalg
name|alg
decl_stmt|;
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_MD5
name|archive_md5_ctx
name|md5ctx
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA1
name|archive_sha1_ctx
name|sha1ctx
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_enum
enum|enum
name|la_zaction
block|{
name|ARCHIVE_Z_FINISH
block|,
name|ARCHIVE_Z_RUN
block|}
enum|;
end_enum

begin_comment
comment|/*  * Universal zstream.  */
end_comment

begin_struct
struct|struct
name|la_zstream
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|next_in
decl_stmt|;
name|size_t
name|avail_in
decl_stmt|;
name|uint64_t
name|total_in
decl_stmt|;
name|unsigned
name|char
modifier|*
name|next_out
decl_stmt|;
name|size_t
name|avail_out
decl_stmt|;
name|uint64_t
name|total_out
decl_stmt|;
name|int
name|valid
decl_stmt|;
name|void
modifier|*
name|real_stream
decl_stmt|;
name|int
function_decl|(
modifier|*
name|code
function_decl|)
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|la_zstream
modifier|*
name|lastrm
parameter_list|,
name|enum
name|la_zaction
name|action
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|end
function_decl|)
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|la_zstream
modifier|*
name|lastrm
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|chksumval
block|{
name|enum
name|sumalg
name|alg
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|unsigned
name|char
name|val
index|[
name|MAX_SUM_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|heap_data
block|{
name|int
name|id
decl_stmt|;
name|struct
name|heap_data
modifier|*
name|next
decl_stmt|;
name|uint64_t
name|temp_offset
decl_stmt|;
name|uint64_t
name|length
decl_stmt|;
comment|/* archived size.	*/
name|uint64_t
name|size
decl_stmt|;
comment|/* extracted size.	*/
name|enum
name|enctype
name|compression
decl_stmt|;
name|struct
name|chksumval
name|a_sum
decl_stmt|;
comment|/* archived checksum.	*/
name|struct
name|chksumval
name|e_sum
decl_stmt|;
comment|/* extracted checksum.	*/
block|}
struct|;
end_struct

begin_struct
struct|struct
name|file
block|{
name|struct
name|archive_rb_node
name|rbnode
decl_stmt|;
name|int
name|id
decl_stmt|;
name|struct
name|archive_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|archive_rb_tree
name|rbtree
decl_stmt|;
name|struct
name|file
modifier|*
name|next
decl_stmt|;
name|struct
name|file
modifier|*
name|chnext
decl_stmt|;
name|struct
name|file
modifier|*
name|hlnext
decl_stmt|;
comment|/* For hardlinked files. 	 * Use only when archive_entry_nlink()> 1 */
name|struct
name|file
modifier|*
name|hardlink_target
decl_stmt|;
name|struct
name|file
modifier|*
name|parent
decl_stmt|;
comment|/* parent directory entry */
comment|/* 	 * To manage sub directory files. 	 * We use 'chnext' a menber of struct file to chain. 	 */
struct|struct
block|{
name|struct
name|file
modifier|*
name|first
decl_stmt|;
name|struct
name|file
modifier|*
modifier|*
name|last
decl_stmt|;
block|}
name|children
struct|;
comment|/* For making a directory tree. */
name|struct
name|archive_string
name|parentdir
decl_stmt|;
name|struct
name|archive_string
name|basename
decl_stmt|;
name|struct
name|archive_string
name|symlink
decl_stmt|;
name|int
name|ea_idx
decl_stmt|;
struct|struct
block|{
name|struct
name|heap_data
modifier|*
name|first
decl_stmt|;
name|struct
name|heap_data
modifier|*
modifier|*
name|last
decl_stmt|;
block|}
name|xattr
struct|;
name|struct
name|heap_data
name|data
decl_stmt|;
name|struct
name|archive_string
name|script
decl_stmt|;
name|int
name|virtual
range|:
literal|1
decl_stmt|;
name|int
name|dir
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|hardlink
block|{
name|struct
name|archive_rb_node
name|rbnode
decl_stmt|;
name|int
name|nlink
decl_stmt|;
struct|struct
block|{
name|struct
name|file
modifier|*
name|first
decl_stmt|;
name|struct
name|file
modifier|*
modifier|*
name|last
decl_stmt|;
block|}
name|file_list
struct|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|xar
block|{
name|int
name|temp_fd
decl_stmt|;
name|uint64_t
name|temp_offset
decl_stmt|;
name|int
name|file_idx
decl_stmt|;
name|struct
name|file
modifier|*
name|root
decl_stmt|;
name|struct
name|file
modifier|*
name|cur_dirent
decl_stmt|;
name|struct
name|archive_string
name|cur_dirstr
decl_stmt|;
name|struct
name|file
modifier|*
name|cur_file
decl_stmt|;
name|uint64_t
name|bytes_remaining
decl_stmt|;
name|struct
name|archive_string
name|tstr
decl_stmt|;
name|struct
name|archive_string
name|vstr
decl_stmt|;
name|enum
name|sumalg
name|opt_toc_sumalg
decl_stmt|;
name|enum
name|sumalg
name|opt_sumalg
decl_stmt|;
name|enum
name|enctype
name|opt_compression
decl_stmt|;
name|int
name|opt_compression_level
decl_stmt|;
name|struct
name|chksumwork
name|a_sumwrk
decl_stmt|;
comment|/* archived checksum.	*/
name|struct
name|chksumwork
name|e_sumwrk
decl_stmt|;
comment|/* extracted checksum.	*/
name|struct
name|la_zstream
name|stream
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|sconv
decl_stmt|;
comment|/* 	 * Compressed data buffer. 	 */
name|unsigned
name|char
name|wbuff
index|[
literal|1024
operator|*
literal|64
index|]
decl_stmt|;
name|size_t
name|wbuff_remaining
decl_stmt|;
name|struct
name|heap_data
name|toc
decl_stmt|;
comment|/* 	 * The list of all file entries is used to manage struct file 	 * objects. 	 * We use 'next' a menber of struct file to chain. 	 */
struct|struct
block|{
name|struct
name|file
modifier|*
name|first
decl_stmt|;
name|struct
name|file
modifier|*
modifier|*
name|last
decl_stmt|;
block|}
name|file_list
struct|;
comment|/* 	 * The list of hard-linked file entries. 	 * We use 'hlnext' a menber of struct file to chain. 	 */
name|struct
name|archive_rb_tree
name|hardlink_rbtree
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|xar_options
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xar_write_header
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssize_t
name|xar_write_data
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xar_finish_entry
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xar_close
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xar_free
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|file
modifier|*
name|file_new
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|file_free
parameter_list|(
name|struct
name|file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|file
modifier|*
name|file_create_virtual_dir
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|xar
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|file_add_child_tail
parameter_list|(
name|struct
name|file
modifier|*
parameter_list|,
name|struct
name|file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|file
modifier|*
name|file_find_child
parameter_list|(
name|struct
name|file
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|file_gen_utility_names
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_path_component
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|file_tree
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|file
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|file_register
parameter_list|(
name|struct
name|xar
modifier|*
parameter_list|,
name|struct
name|file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|file_init_register
parameter_list|(
name|struct
name|xar
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|file_free_register
parameter_list|(
name|struct
name|xar
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|file_register_hardlink
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|file_connect_hardlink_files
parameter_list|(
name|struct
name|xar
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|file_init_hardlinks
parameter_list|(
name|struct
name|xar
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|file_free_hardlinks
parameter_list|(
name|struct
name|xar
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|checksum_init
parameter_list|(
name|struct
name|chksumwork
modifier|*
parameter_list|,
name|enum
name|sumalg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|checksum_update
parameter_list|(
name|struct
name|chksumwork
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|checksum_final
parameter_list|(
name|struct
name|chksumwork
modifier|*
parameter_list|,
name|struct
name|chksumval
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compression_init_encoder_gzip
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|la_zstream
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compression_code_gzip
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|la_zstream
modifier|*
parameter_list|,
name|enum
name|la_zaction
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compression_end_gzip
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|la_zstream
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compression_init_encoder_bzip2
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|la_zstream
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_BZLIB_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|BZ_CONFIG_ERROR
argument_list|)
end_if

begin_function_decl
specifier|static
name|int
name|compression_code_bzip2
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|la_zstream
modifier|*
parameter_list|,
name|enum
name|la_zaction
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compression_end_bzip2
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|la_zstream
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|compression_init_encoder_lzma
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|la_zstream
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compression_init_encoder_xz
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|la_zstream
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LZMA_H
argument_list|)
end_if

begin_function_decl
specifier|static
name|int
name|compression_code_lzma
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|la_zstream
modifier|*
parameter_list|,
name|enum
name|la_zaction
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compression_end_lzma
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|la_zstream
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|xar_compression_init_encoder
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compression_code
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|la_zstream
modifier|*
parameter_list|,
name|enum
name|la_zaction
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compression_end
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|la_zstream
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|save_xattrs
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getalgsize
parameter_list|(
name|enum
name|sumalg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|getalgname
parameter_list|(
name|enum
name|sumalg
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|archive_write_set_format_xar
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_write
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_write
operator|*
operator|)
name|_a
decl_stmt|;
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_WRITE_MAGIC
argument_list|,
name|ARCHIVE_STATE_NEW
argument_list|,
literal|"archive_write_set_format_xar"
argument_list|)
expr_stmt|;
comment|/* If another format was already registered, unregister it. */
if|if
condition|(
name|a
operator|->
name|format_free
operator|!=
name|NULL
condition|)
call|(
name|a
operator|->
name|format_free
call|)
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|xar
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|xar
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xar
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate xar data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|xar
operator|->
name|temp_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|file_init_register
argument_list|(
name|xar
argument_list|)
expr_stmt|;
name|file_init_hardlinks
argument_list|(
name|xar
argument_list|)
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|tstr
operator|)
argument_list|)
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|vstr
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Create the root directory. 	 */
name|xar
operator|->
name|root
operator|=
name|file_create_virtual_dir
argument_list|(
name|a
argument_list|,
name|xar
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|xar
operator|->
name|root
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|xar
argument_list|)
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate xar data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|xar
operator|->
name|root
operator|->
name|parent
operator|=
name|xar
operator|->
name|root
expr_stmt|;
name|file_register
argument_list|(
name|xar
argument_list|,
name|xar
operator|->
name|root
argument_list|)
expr_stmt|;
name|xar
operator|->
name|cur_dirent
operator|=
name|xar
operator|->
name|root
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|cur_dirstr
operator|)
argument_list|)
expr_stmt|;
name|archive_string_ensure
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|cur_dirstr
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xar
operator|->
name|cur_dirstr
operator|.
name|s
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Initialize option. 	 */
comment|/* Set default checksum type. */
name|xar
operator|->
name|opt_toc_sumalg
operator|=
name|CKSUM_SHA1
expr_stmt|;
name|xar
operator|->
name|opt_sumalg
operator|=
name|CKSUM_SHA1
expr_stmt|;
comment|/* Set default compression type and level. */
name|xar
operator|->
name|opt_compression
operator|=
name|GZIP
expr_stmt|;
name|xar
operator|->
name|opt_compression_level
operator|=
literal|6
expr_stmt|;
name|a
operator|->
name|format_data
operator|=
name|xar
expr_stmt|;
name|a
operator|->
name|format_name
operator|=
literal|"xar"
expr_stmt|;
name|a
operator|->
name|format_options
operator|=
name|xar_options
expr_stmt|;
name|a
operator|->
name|format_write_header
operator|=
name|xar_write_header
expr_stmt|;
name|a
operator|->
name|format_write_data
operator|=
name|xar_write_data
expr_stmt|;
name|a
operator|->
name|format_finish_entry
operator|=
name|xar_finish_entry
expr_stmt|;
name|a
operator|->
name|format_close
operator|=
name|xar_close
expr_stmt|;
name|a
operator|->
name|format_free
operator|=
name|xar_free
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_XAR
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"xar"
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xar_options
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
name|a
operator|->
name|format_data
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"checksum"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
name|xar
operator|->
name|opt_sumalg
operator|=
name|CKSUM_NONE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"sha1"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|opt_sumalg
operator|=
name|CKSUM_SHA1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"md5"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|opt_sumalg
operator|=
name|CKSUM_MD5
expr_stmt|;
else|else
block|{
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Unknown checksum name: `%s'"
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"compression"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
name|xar
operator|->
name|opt_compression
operator|=
name|NONE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"gzip"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|opt_compression
operator|=
name|GZIP
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"bzip2"
argument_list|)
operator|==
literal|0
condition|)
if|#
directive|if
name|defined
argument_list|(
name|HAVE_BZLIB_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|BZ_CONFIG_ERROR
argument_list|)
name|xar
operator|->
name|opt_compression
operator|=
name|BZIP2
expr_stmt|;
else|#
directive|else
name|name
operator|=
literal|"bzip2"
expr_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"lzma"
argument_list|)
operator|==
literal|0
condition|)
if|#
directive|if
name|HAVE_LZMA_H
name|xar
operator|->
name|opt_compression
operator|=
name|LZMA
expr_stmt|;
else|#
directive|else
name|name
operator|=
literal|"lzma"
expr_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"xz"
argument_list|)
operator|==
literal|0
condition|)
if|#
directive|if
name|HAVE_LZMA_H
name|xar
operator|->
name|opt_compression
operator|=
name|XZ
expr_stmt|;
else|#
directive|else
name|name
operator|=
literal|"xz"
expr_stmt|;
endif|#
directive|endif
else|else
block|{
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Unknown compression name: `%s'"
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"`%s' compression not supported "
literal|"on this platform"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"compression-level"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|value
operator|==
name|NULL
operator|||
operator|!
operator|(
name|value
index|[
literal|0
index|]
operator|>=
literal|'0'
operator|&&
name|value
index|[
literal|0
index|]
operator|<=
literal|'9'
operator|)
operator|||
name|value
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Illegal value `%s'"
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|xar
operator|->
name|opt_compression_level
operator|=
name|value
index|[
literal|0
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"toc-checksum"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
name|xar
operator|->
name|opt_toc_sumalg
operator|=
name|CKSUM_NONE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"sha1"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|opt_toc_sumalg
operator|=
name|CKSUM_SHA1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"md5"
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|opt_toc_sumalg
operator|=
name|CKSUM_MD5
expr_stmt|;
else|else
block|{
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Unknown checksum name: `%s'"
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
comment|/* Note: The "warn" return is just to inform the options 	 * supervisor that we didn't handle it.  It will generate 	 * a suitable error if no one used this option. */
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xar_write_header
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
name|struct
name|file
modifier|*
name|file
decl_stmt|;
name|struct
name|archive_entry
modifier|*
name|file_entry
decl_stmt|;
name|int
name|r
decl_stmt|,
name|r2
decl_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
name|a
operator|->
name|format_data
expr_stmt|;
name|xar
operator|->
name|cur_file
operator|=
name|NULL
expr_stmt|;
name|xar
operator|->
name|bytes_remaining
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xar
operator|->
name|sconv
operator|==
name|NULL
condition|)
block|{
name|xar
operator|->
name|sconv
operator|=
name|archive_string_conversion_to_charset
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
literal|"UTF-8"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xar
operator|->
name|sconv
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|file
operator|=
name|file_new
argument_list|(
name|a
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|r2
operator|=
name|file_gen_utility_names
argument_list|(
name|a
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|r2
operator|<
name|ARCHIVE_WARN
condition|)
return|return
operator|(
name|r2
operator|)
return|;
comment|/* 	 * Ignore a path which looks like the top of directory name 	 * since we have already made the root directory of an Xar archive. 	 */
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
operator|(
name|file
operator|->
name|parentdir
operator|)
argument_list|)
operator|==
literal|0
operator|&&
name|archive_strlen
argument_list|(
operator|&
operator|(
name|file
operator|->
name|basename
operator|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|file_free
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|r2
operator|)
return|;
block|}
comment|/* Add entry into tree */
name|file_entry
operator|=
name|file
operator|->
name|entry
expr_stmt|;
name|r
operator|=
name|file_tree
argument_list|(
name|a
argument_list|,
operator|&
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
comment|/* There is the same file in tree and 	 * the current file is older than the file in tree. 	 * So we don't need the current file data anymore. */
if|if
condition|(
name|file
operator|->
name|entry
operator|!=
name|file_entry
condition|)
return|return
operator|(
name|r2
operator|)
return|;
if|if
condition|(
name|file
operator|->
name|id
operator|==
literal|0
condition|)
name|file_register
argument_list|(
name|xar
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* A virtual file, which is a directory, does not have 	 * any contents and we won't store it into a archive 	 * file other than its name. */
if|if
condition|(
name|file
operator|->
name|virtual
condition|)
return|return
operator|(
name|r2
operator|)
return|;
comment|/* 	 * Prepare to save the contents of the file. 	 */
if|if
condition|(
name|xar
operator|->
name|temp_fd
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|algsize
decl_stmt|;
name|xar
operator|->
name|temp_offset
operator|=
literal|0
expr_stmt|;
name|xar
operator|->
name|temp_fd
operator|=
name|__archive_mktemp
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|xar
operator|->
name|temp_fd
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Couldn't create temporary file"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|algsize
operator|=
name|getalgsize
argument_list|(
name|xar
operator|->
name|opt_toc_sumalg
argument_list|)
expr_stmt|;
if|if
condition|(
name|algsize
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|lseek
argument_list|(
name|xar
operator|->
name|temp_fd
argument_list|,
name|algsize
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|errno
argument_list|,
literal|"lseek failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|xar
operator|->
name|temp_offset
operator|=
name|algsize
expr_stmt|;
block|}
block|}
if|if
condition|(
name|archive_entry_hardlink
argument_list|(
name|file
operator|->
name|entry
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|save_xattrs
argument_list|(
name|a
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Non regular files contents are unneeded to be saved to 	 * a temporary file. */
if|if
condition|(
name|archive_entry_filetype
argument_list|(
name|file
operator|->
name|entry
argument_list|)
operator|!=
name|AE_IFREG
condition|)
return|return
operator|(
name|r2
operator|)
return|;
comment|/* 	 * Set the current file to cur_file to read its contents. 	 */
name|xar
operator|->
name|cur_file
operator|=
name|file
expr_stmt|;
if|if
condition|(
name|archive_entry_nlink
argument_list|(
name|file
operator|->
name|entry
argument_list|)
operator|>
literal|1
condition|)
block|{
name|r
operator|=
name|file_register_hardlink
argument_list|(
name|a
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
if|if
condition|(
name|archive_entry_hardlink
argument_list|(
name|file
operator|->
name|entry
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|archive_entry_unset_size
argument_list|(
name|file
operator|->
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
name|r2
operator|)
return|;
block|}
block|}
comment|/* Save a offset of current file in temporary file. */
name|file
operator|->
name|data
operator|.
name|temp_offset
operator|=
name|xar
operator|->
name|temp_offset
expr_stmt|;
name|file
operator|->
name|data
operator|.
name|size
operator|=
name|archive_entry_size
argument_list|(
name|file
operator|->
name|entry
argument_list|)
expr_stmt|;
name|file
operator|->
name|data
operator|.
name|compression
operator|=
name|xar
operator|->
name|opt_compression
expr_stmt|;
name|xar
operator|->
name|bytes_remaining
operator|=
name|archive_entry_size
argument_list|(
name|file
operator|->
name|entry
argument_list|)
expr_stmt|;
name|checksum_init
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|a_sumwrk
operator|)
argument_list|,
name|xar
operator|->
name|opt_sumalg
argument_list|)
expr_stmt|;
name|checksum_init
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|e_sumwrk
operator|)
argument_list|,
name|xar
operator|->
name|opt_sumalg
argument_list|)
expr_stmt|;
name|r
operator|=
name|xar_compression_init_encoder
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
else|else
return|return
operator|(
name|r2
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|write_to_temp
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|ssize_t
name|ws
decl_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
name|a
operator|->
name|format_data
expr_stmt|;
name|p
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|buff
expr_stmt|;
while|while
condition|(
name|s
condition|)
block|{
name|ws
operator|=
name|write
argument_list|(
name|xar
operator|->
name|temp_fd
argument_list|,
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ws
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|errno
argument_list|,
literal|"fwrite function failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|s
operator|-=
name|ws
expr_stmt|;
name|p
operator|+=
name|ws
expr_stmt|;
name|xar
operator|->
name|temp_offset
operator|+=
name|ws
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|xar_write_data
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
name|enum
name|la_zaction
name|run
decl_stmt|;
name|size_t
name|size
decl_stmt|,
name|rsize
decl_stmt|;
name|int
name|r
decl_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
name|a
operator|->
name|format_data
expr_stmt|;
if|if
condition|(
name|s
operator|>
name|xar
operator|->
name|bytes_remaining
condition|)
name|s
operator|=
operator|(
name|size_t
operator|)
name|xar
operator|->
name|bytes_remaining
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
operator|||
name|xar
operator|->
name|cur_file
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|xar
operator|->
name|cur_file
operator|->
name|data
operator|.
name|compression
operator|==
name|NONE
condition|)
block|{
name|checksum_update
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|e_sumwrk
operator|)
argument_list|,
name|buff
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|checksum_update
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|a_sumwrk
operator|)
argument_list|,
name|buff
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|size
operator|=
name|rsize
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
name|xar
operator|->
name|stream
operator|.
name|next_in
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|buff
expr_stmt|;
name|xar
operator|->
name|stream
operator|.
name|avail_in
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|xar
operator|->
name|bytes_remaining
operator|>
name|s
condition|)
name|run
operator|=
name|ARCHIVE_Z_RUN
expr_stmt|;
else|else
name|run
operator|=
name|ARCHIVE_Z_FINISH
expr_stmt|;
comment|/* Compress file data. */
name|r
operator|=
name|compression_code
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
operator|&
operator|(
name|xar
operator|->
name|stream
operator|)
argument_list|,
name|run
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
operator|&&
name|r
operator|!=
name|ARCHIVE_EOF
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|rsize
operator|=
name|s
operator|-
name|xar
operator|->
name|stream
operator|.
name|avail_in
expr_stmt|;
name|checksum_update
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|e_sumwrk
operator|)
argument_list|,
name|buff
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|xar
operator|->
name|wbuff
argument_list|)
operator|-
name|xar
operator|->
name|stream
operator|.
name|avail_out
expr_stmt|;
name|checksum_update
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|a_sumwrk
operator|)
argument_list|,
name|xar
operator|->
name|wbuff
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
if|if
condition|(
name|xar
operator|->
name|bytes_remaining
operator|==
operator|(
name|uint64_t
operator|)
name|archive_entry_size
argument_list|(
name|xar
operator|->
name|cur_file
operator|->
name|entry
argument_list|)
condition|)
block|{
comment|/* 		 * Get the path of a shell script if so. 		 */
specifier|const
name|unsigned
name|char
modifier|*
name|b
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|buff
decl_stmt|;
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|cur_file
operator|->
name|script
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsize
operator|>
literal|2
operator|&&
name|b
index|[
literal|0
index|]
operator|==
literal|'#'
operator|&&
name|b
index|[
literal|1
index|]
operator|==
literal|'!'
condition|)
block|{
name|size_t
name|i
decl_stmt|,
name|end
decl_stmt|,
name|off
decl_stmt|;
name|off
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|b
index|[
name|off
index|]
operator|==
literal|' '
condition|)
name|off
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|PATH_MAX
if|if
condition|(
operator|(
name|rsize
operator|-
name|off
operator|)
operator|>
name|PATH_MAX
condition|)
name|end
operator|=
name|off
operator|+
name|PATH_MAX
expr_stmt|;
else|else
endif|#
directive|endif
name|end
operator|=
name|rsize
expr_stmt|;
comment|/* Find the end of a script path. */
for|for
control|(
name|i
operator|=
name|off
init|;
name|i
operator|<
name|end
operator|&&
name|b
index|[
name|i
index|]
operator|!=
literal|'\0'
operator|&&
name|b
index|[
name|i
index|]
operator|!=
literal|'\n'
operator|&&
name|b
index|[
name|i
index|]
operator|!=
literal|'\r'
operator|&&
name|b
index|[
name|i
index|]
operator|!=
literal|' '
operator|&&
name|b
index|[
name|i
index|]
operator|!=
literal|'\t'
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|archive_strncpy
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|cur_file
operator|->
name|script
operator|)
argument_list|,
name|b
operator|+
name|off
argument_list|,
name|i
operator|-
name|off
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|xar
operator|->
name|cur_file
operator|->
name|data
operator|.
name|compression
operator|==
name|NONE
condition|)
block|{
if|if
condition|(
name|write_to_temp
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|size
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|write_to_temp
argument_list|(
name|a
argument_list|,
name|xar
operator|->
name|wbuff
argument_list|,
name|size
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|xar
operator|->
name|bytes_remaining
operator|-=
name|rsize
expr_stmt|;
name|xar
operator|->
name|cur_file
operator|->
name|data
operator|.
name|length
operator|+=
name|size
expr_stmt|;
return|return
operator|(
name|rsize
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xar_finish_entry
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
name|struct
name|file
modifier|*
name|file
decl_stmt|;
name|size_t
name|s
decl_stmt|;
name|ssize_t
name|w
decl_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
name|a
operator|->
name|format_data
expr_stmt|;
if|if
condition|(
name|xar
operator|->
name|cur_file
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
while|while
condition|(
name|xar
operator|->
name|bytes_remaining
operator|>
literal|0
condition|)
block|{
name|s
operator|=
operator|(
name|size_t
operator|)
name|xar
operator|->
name|bytes_remaining
expr_stmt|;
if|if
condition|(
name|s
operator|>
name|a
operator|->
name|null_length
condition|)
name|s
operator|=
name|a
operator|->
name|null_length
expr_stmt|;
name|w
operator|=
name|xar_write_data
argument_list|(
name|a
argument_list|,
name|a
operator|->
name|nulls
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|>
literal|0
condition|)
name|xar
operator|->
name|bytes_remaining
operator|-=
name|w
expr_stmt|;
else|else
return|return
operator|(
name|w
operator|)
return|;
block|}
name|file
operator|=
name|xar
operator|->
name|cur_file
expr_stmt|;
name|checksum_final
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|e_sumwrk
operator|)
argument_list|,
operator|&
operator|(
name|file
operator|->
name|data
operator|.
name|e_sum
operator|)
argument_list|)
expr_stmt|;
name|checksum_final
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|a_sumwrk
operator|)
argument_list|,
operator|&
operator|(
name|file
operator|->
name|data
operator|.
name|a_sum
operator|)
argument_list|)
expr_stmt|;
name|xar
operator|->
name|cur_file
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xmlwrite_string_attr
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|xmlTextWriterPtr
name|writer
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|attrkey
parameter_list|,
specifier|const
name|char
modifier|*
name|attrvalue
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|BAD_CAST_CONST
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterStartElement() failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|attrkey
operator|!=
name|NULL
operator|&&
name|attrvalue
operator|!=
name|NULL
condition|)
block|{
name|r
operator|=
name|xmlTextWriterWriteAttribute
argument_list|(
name|writer
argument_list|,
name|BAD_CAST_CONST
argument_list|(
name|attrkey
argument_list|)
argument_list|,
name|BAD_CAST_CONST
argument_list|(
name|attrvalue
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterWriteAttribute() failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
name|r
operator|=
name|xmlTextWriterWriteString
argument_list|(
name|writer
argument_list|,
name|BAD_CAST_CONST
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterWriteString() failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
name|r
operator|=
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterEndElement() failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xmlwrite_string
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|xmlTextWriterPtr
name|writer
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
name|r
operator|=
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|BAD_CAST_CONST
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterStartElement() failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
name|r
operator|=
name|xmlTextWriterWriteString
argument_list|(
name|writer
argument_list|,
name|BAD_CAST_CONST
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterWriteString() failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
name|r
operator|=
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterEndElement() failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xmlwrite_fstring
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|xmlTextWriterPtr
name|writer
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
name|a
operator|->
name|format_data
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
name|xar
operator|->
name|vstr
argument_list|)
expr_stmt|;
name|archive_string_vsprintf
argument_list|(
operator|&
name|xar
operator|->
name|vstr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|xmlwrite_string
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
name|key
argument_list|,
name|xar
operator|->
name|vstr
operator|.
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xmlwrite_time
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|xmlTextWriterPtr
name|writer
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|time_t
name|t
parameter_list|,
name|int
name|z
parameter_list|)
block|{
name|char
name|timestr
index|[
literal|100
index|]
decl_stmt|;
name|struct
name|tm
name|tm
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_GMTIME_R
argument_list|)
name|gmtime_r
argument_list|(
operator|&
name|t
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE__GMTIME64_S
argument_list|)
name|_gmtime64_s
argument_list|(
operator|&
name|tm
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
else|#
directive|else
name|memcpy
argument_list|(
operator|&
name|tm
argument_list|,
name|gmtime
argument_list|(
operator|&
name|t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tm
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
operator|&
name|timestr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|timestr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do not use %F and %T for portability. */
name|strftime
argument_list|(
name|timestr
argument_list|,
sizeof|sizeof
argument_list|(
name|timestr
argument_list|)
argument_list|,
literal|"%Y-%m-%dT%H:%M:%S"
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
condition|)
name|strcat
argument_list|(
name|timestr
argument_list|,
literal|"Z"
argument_list|)
expr_stmt|;
return|return
operator|(
name|xmlwrite_string
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
name|key
argument_list|,
name|timestr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xmlwrite_mode
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|xmlTextWriterPtr
name|writer
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|mode_t
name|mode
parameter_list|)
block|{
name|char
name|ms
index|[
literal|5
index|]
decl_stmt|;
name|ms
index|[
literal|0
index|]
operator|=
literal|'0'
expr_stmt|;
name|ms
index|[
literal|1
index|]
operator|=
literal|'0'
operator|+
operator|(
operator|(
name|mode
operator|>>
literal|6
operator|)
operator|&
literal|07
operator|)
expr_stmt|;
name|ms
index|[
literal|2
index|]
operator|=
literal|'0'
operator|+
operator|(
operator|(
name|mode
operator|>>
literal|3
operator|)
operator|&
literal|07
operator|)
expr_stmt|;
name|ms
index|[
literal|3
index|]
operator|=
literal|'0'
operator|+
operator|(
name|mode
operator|&
literal|07
operator|)
expr_stmt|;
name|ms
index|[
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|xmlwrite_string
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
name|key
argument_list|,
name|ms
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xmlwrite_sum
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|xmlTextWriterPtr
name|writer
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|struct
name|chksumval
modifier|*
name|sum
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|algname
decl_stmt|;
name|int
name|algsize
decl_stmt|;
name|char
name|buff
index|[
name|MAX_SUM_SIZE
operator|*
literal|2
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|,
name|r
decl_stmt|;
if|if
condition|(
name|sum
operator|->
name|len
operator|>
literal|0
condition|)
block|{
name|algname
operator|=
name|getalgname
argument_list|(
name|sum
operator|->
name|alg
argument_list|)
expr_stmt|;
name|algsize
operator|=
name|getalgsize
argument_list|(
name|sum
operator|->
name|alg
argument_list|)
expr_stmt|;
if|if
condition|(
name|algname
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|hex
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|p
operator|=
name|buff
expr_stmt|;
name|s
operator|=
name|sum
operator|->
name|val
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|algsize
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|hex
index|[
operator|(
operator|*
name|s
operator|>>
literal|4
operator|)
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|hex
index|[
operator|(
operator|*
name|s
operator|&
literal|0x0f
operator|)
index|]
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|r
operator|=
name|xmlwrite_string_attr
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
name|key
argument_list|,
name|buff
argument_list|,
literal|"style"
argument_list|,
name|algname
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xmlwrite_heap
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|xmlTextWriterPtr
name|writer
parameter_list|,
name|struct
name|heap_data
modifier|*
name|heap
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|encname
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|xmlwrite_fstring
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
literal|"length"
argument_list|,
literal|"%ju"
argument_list|,
name|heap
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|r
operator|=
name|xmlwrite_fstring
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
literal|"offset"
argument_list|,
literal|"%ju"
argument_list|,
name|heap
operator|->
name|temp_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|r
operator|=
name|xmlwrite_fstring
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
literal|"size"
argument_list|,
literal|"%ju"
argument_list|,
name|heap
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
switch|switch
condition|(
name|heap
operator|->
name|compression
condition|)
block|{
case|case
name|GZIP
case|:
name|encname
operator|=
literal|"application/x-gzip"
expr_stmt|;
break|break;
case|case
name|BZIP2
case|:
name|encname
operator|=
literal|"application/x-bzip2"
expr_stmt|;
break|break;
case|case
name|LZMA
case|:
name|encname
operator|=
literal|"application/x-lzma"
expr_stmt|;
break|break;
case|case
name|XZ
case|:
name|encname
operator|=
literal|"application/x-xz"
expr_stmt|;
break|break;
default|default:
name|encname
operator|=
literal|"application/octet-stream"
expr_stmt|;
break|break;
block|}
name|r
operator|=
name|xmlwrite_string_attr
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
literal|"encoding"
argument_list|,
name|NULL
argument_list|,
literal|"style"
argument_list|,
name|encname
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|r
operator|=
name|xmlwrite_sum
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
literal|"archived-checksum"
argument_list|,
operator|&
operator|(
name|heap
operator|->
name|a_sum
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|r
operator|=
name|xmlwrite_sum
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
literal|"extracted-checksum"
argument_list|,
operator|&
operator|(
name|heap
operator|->
name|e_sum
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * xar utility records fflags as following xml elements:  *<flags>  *<UserNoDump/>  *     .....  *</flags>  * or  *<ext2>  *<NoDump/>  *     .....  *</ext2>  * If xar is running on BSD platform, records<flags>..</flags>;  * if xar is running on linux platform, records<ext2>..</ext2>;  * otherwise does not record.  *  * Our implements records both<flags> and<ext2> if it's necessary.  */
end_comment

begin_function
specifier|static
name|int
name|make_fflags_entry
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|xmlTextWriterPtr
name|writer
parameter_list|,
specifier|const
name|char
modifier|*
name|element
parameter_list|,
specifier|const
name|char
modifier|*
name|fflags_text
parameter_list|)
block|{
specifier|static
specifier|const
struct|struct
name|flagentry
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|xarname
decl_stmt|;
block|}
name|flagbsd
index|[]
init|=
block|{
block|{
literal|"sappnd"
block|,
literal|"SystemAppend"
block|}
block|,
block|{
literal|"sappend"
block|,
literal|"SystemAppend"
block|}
block|,
block|{
literal|"arch"
block|,
literal|"SystemArchived"
block|}
block|,
block|{
literal|"archived"
block|,
literal|"SystemArchived"
block|}
block|,
block|{
literal|"schg"
block|,
literal|"SystemImmutable"
block|}
block|,
block|{
literal|"schange"
block|,
literal|"SystemImmutable"
block|}
block|,
block|{
literal|"simmutable"
block|,
literal|"SystemImmutable"
block|}
block|,
block|{
literal|"nosunlnk"
block|,
literal|"SystemNoUnlink"
block|}
block|,
block|{
literal|"nosunlink"
block|,
literal|"SystemNoUnlink"
block|}
block|,
block|{
literal|"snapshot"
block|,
literal|"SystemSnapshot"
block|}
block|,
block|{
literal|"uappnd"
block|,
literal|"UserAppend"
block|}
block|,
block|{
literal|"uappend"
block|,
literal|"UserAppend"
block|}
block|,
block|{
literal|"uchg"
block|,
literal|"UserImmutable"
block|}
block|,
block|{
literal|"uchange"
block|,
literal|"UserImmutable"
block|}
block|,
block|{
literal|"uimmutable"
block|,
literal|"UserImmutable"
block|}
block|,
block|{
literal|"nodump"
block|,
literal|"UserNoDump"
block|}
block|,
block|{
literal|"noopaque"
block|,
literal|"UserOpaque"
block|}
block|,
block|{
literal|"nouunlnk"
block|,
literal|"UserNoUnlink"
block|}
block|,
block|{
literal|"nouunlink"
block|,
literal|"UserNoUnlink"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
struct|,
name|flagext2
index|[]
init|=
block|{
block|{
literal|"sappnd"
block|,
literal|"AppendOnly"
block|}
block|,
block|{
literal|"sappend"
block|,
literal|"AppendOnly"
block|}
block|,
block|{
literal|"schg"
block|,
literal|"Immutable"
block|}
block|,
block|{
literal|"schange"
block|,
literal|"Immutable"
block|}
block|,
block|{
literal|"simmutable"
block|,
literal|"Immutable"
block|}
block|,
block|{
literal|"nodump"
block|,
literal|"NoDump"
block|}
block|,
block|{
literal|"nouunlnk"
block|,
literal|"Undelete"
block|}
block|,
block|{
literal|"nouunlink"
block|,
literal|"Undelete"
block|}
block|,
block|{
literal|"btree"
block|,
literal|"BTree"
block|}
block|,
block|{
literal|"comperr"
block|,
literal|"CompError"
block|}
block|,
block|{
literal|"compress"
block|,
literal|"Compress"
block|}
block|,
block|{
literal|"noatime"
block|,
literal|"NoAtime"
block|}
block|,
block|{
literal|"compdirty"
block|,
literal|"CompDirty"
block|}
block|,
block|{
literal|"comprblk"
block|,
literal|"CompBlock"
block|}
block|,
block|{
literal|"dirsync"
block|,
literal|"DirSync"
block|}
block|,
block|{
literal|"hashidx"
block|,
literal|"HashIndexed"
block|}
block|,
block|{
literal|"imagic"
block|,
literal|"iMagic"
block|}
block|,
block|{
literal|"journal"
block|,
literal|"Journaled"
block|}
block|,
block|{
literal|"securedeletion"
block|,
literal|"SecureDeletion"
block|}
block|,
block|{
literal|"sync"
block|,
literal|"Synchronous"
block|}
block|,
block|{
literal|"notail"
block|,
literal|"NoTail"
block|}
block|,
block|{
literal|"topdir"
block|,
literal|"TopDir"
block|}
block|,
block|{
literal|"reserved"
block|,
literal|"Reserved"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
struct|;
specifier|const
name|struct
name|flagentry
modifier|*
name|fe
decl_stmt|,
modifier|*
name|flagentry
decl_stmt|;
define|#
directive|define
name|FLAGENTRY_MAXSIZE
value|((sizeof(flagbsd)+sizeof(flagext2))/sizeof(flagbsd))
specifier|const
name|struct
name|flagentry
modifier|*
name|avail
index|[
name|FLAGENTRY_MAXSIZE
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|r
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|element
argument_list|,
literal|"ext2"
argument_list|)
operator|==
literal|0
condition|)
name|flagentry
operator|=
name|flagext2
expr_stmt|;
else|else
name|flagentry
operator|=
name|flagbsd
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|fflags_text
expr_stmt|;
do|do
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|p
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|fe
operator|=
name|flagentry
init|;
name|fe
operator|->
name|name
operator|!=
name|NULL
condition|;
name|fe
operator|++
control|)
block|{
if|if
condition|(
name|fe
operator|->
name|name
index|[
name|cp
operator|-
name|p
index|]
operator|!=
literal|'\0'
operator|||
name|p
index|[
literal|0
index|]
operator|!=
name|fe
operator|->
name|name
index|[
literal|0
index|]
condition|)
continue|continue;
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
name|fe
operator|->
name|name
argument_list|,
name|cp
operator|-
name|p
argument_list|)
operator|==
literal|0
condition|)
block|{
name|avail
index|[
name|n
operator|++
index|]
operator|=
name|fe
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|','
condition|)
name|p
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
else|else
name|p
operator|=
name|NULL
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|r
operator|=
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|BAD_CAST_CONST
argument_list|(
name|element
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterStartElement() failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|=
name|xmlwrite_string
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
name|avail
index|[
name|i
index|]
operator|->
name|xarname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
name|r
operator|=
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterEndElement() failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|make_file_entry
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|xmlTextWriterPtr
name|writer
parameter_list|,
name|struct
name|file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
specifier|const
name|char
modifier|*
name|filetype
decl_stmt|,
modifier|*
name|filelink
decl_stmt|,
modifier|*
name|fflags
decl_stmt|;
name|struct
name|archive_string
name|linkto
decl_stmt|;
name|struct
name|heap_data
modifier|*
name|heap
decl_stmt|;
name|unsigned
name|char
modifier|*
name|tmp
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|r
decl_stmt|,
name|r2
decl_stmt|,
name|l
decl_stmt|,
name|ll
decl_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
name|a
operator|->
name|format_data
expr_stmt|;
name|r2
operator|=
name|ARCHIVE_OK
expr_stmt|;
comment|/* 	 * Make a file name entry, "<name>". 	 */
name|l
operator|=
name|ll
operator|=
name|archive_strlen
argument_list|(
operator|&
operator|(
name|file
operator|->
name|basename
operator|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|malloc
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|r
operator|=
name|UTF8Toisolat1
argument_list|(
name|tmp
argument_list|,
operator|&
name|l
argument_list|,
name|BAD_CAST
argument_list|(
name|file
operator|->
name|basename
operator|.
name|s
argument_list|)
argument_list|,
operator|&
name|ll
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|r
operator|=
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|BAD_CAST
argument_list|(
literal|"name"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterStartElement() failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|r
operator|=
name|xmlTextWriterWriteAttribute
argument_list|(
name|writer
argument_list|,
name|BAD_CAST
argument_list|(
literal|"enctype"
argument_list|)
argument_list|,
name|BAD_CAST
argument_list|(
literal|"base64"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterWriteAttribute() failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|r
operator|=
name|xmlTextWriterWriteBase64
argument_list|(
name|writer
argument_list|,
name|file
operator|->
name|basename
operator|.
name|s
argument_list|,
literal|0
argument_list|,
name|archive_strlen
argument_list|(
operator|&
operator|(
name|file
operator|->
name|basename
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterWriteBase64() failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|r
operator|=
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterEndElement() failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
else|else
block|{
name|r
operator|=
name|xmlwrite_string
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
literal|"name"
argument_list|,
name|file
operator|->
name|basename
operator|.
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* 	 * Make a file type entry, "<type>". 	 */
name|filelink
operator|=
name|NULL
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|linkto
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|archive_entry_filetype
argument_list|(
name|file
operator|->
name|entry
argument_list|)
condition|)
block|{
case|case
name|AE_IFDIR
case|:
name|filetype
operator|=
literal|"directory"
expr_stmt|;
break|break;
case|case
name|AE_IFLNK
case|:
name|filetype
operator|=
literal|"symlink"
expr_stmt|;
break|break;
case|case
name|AE_IFCHR
case|:
name|filetype
operator|=
literal|"character special"
expr_stmt|;
break|break;
case|case
name|AE_IFBLK
case|:
name|filetype
operator|=
literal|"block special"
expr_stmt|;
break|break;
case|case
name|AE_IFSOCK
case|:
name|filetype
operator|=
literal|"socket"
expr_stmt|;
break|break;
case|case
name|AE_IFIFO
case|:
name|filetype
operator|=
literal|"fifo"
expr_stmt|;
break|break;
case|case
name|AE_IFREG
case|:
default|default:
if|if
condition|(
name|file
operator|->
name|hardlink_target
operator|!=
name|NULL
condition|)
block|{
name|filetype
operator|=
literal|"hardlink"
expr_stmt|;
name|filelink
operator|=
literal|"link"
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|hardlink_target
operator|==
name|file
condition|)
name|archive_strcpy
argument_list|(
operator|&
name|linkto
argument_list|,
literal|"original"
argument_list|)
expr_stmt|;
else|else
name|archive_string_sprintf
argument_list|(
operator|&
name|linkto
argument_list|,
literal|"%d"
argument_list|,
name|file
operator|->
name|hardlink_target
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
else|else
name|filetype
operator|=
literal|"file"
expr_stmt|;
break|break;
block|}
name|r
operator|=
name|xmlwrite_string_attr
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
literal|"type"
argument_list|,
name|filetype
argument_list|,
name|filelink
argument_list|,
name|linkto
operator|.
name|s
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|linkto
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
comment|/* 	 * On a virtual directory, we record "name" and "type" only. 	 */
if|if
condition|(
name|file
operator|->
name|virtual
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
switch|switch
condition|(
name|archive_entry_filetype
argument_list|(
name|file
operator|->
name|entry
argument_list|)
condition|)
block|{
case|case
name|AE_IFLNK
case|:
comment|/* 		 * xar utility has checked a file type, which 		 * a symblic-link file has referenced. 		 * For example: 		 *<link type="directory">../ref/</link> 		 *   The symlink target file is "../ref/" and its 		 *   file type is a directory. 		 * 		 *<link type="file">../f</link> 		 *   The symlink target file is "../f" and its 		 *   file type is a regular file. 		 * 		 * But our implemention cannot do it, and then we 		 * always record that a attribute "type" is "borken", 		 * for example: 		 *<link type="broken">foo/bar</link> 		 *   It means "foo/bar" is not reachable. 		 */
name|r
operator|=
name|xmlwrite_string_attr
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
literal|"link"
argument_list|,
name|file
operator|->
name|symlink
operator|.
name|s
argument_list|,
literal|"type"
argument_list|,
literal|"broken"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
break|break;
case|case
name|AE_IFCHR
case|:
case|case
name|AE_IFBLK
case|:
name|r
operator|=
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|BAD_CAST
argument_list|(
literal|"device"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterStartElement() failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|r
operator|=
name|xmlwrite_fstring
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
literal|"major"
argument_list|,
literal|"%d"
argument_list|,
name|archive_entry_rdevmajor
argument_list|(
name|file
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|r
operator|=
name|xmlwrite_fstring
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
literal|"minor"
argument_list|,
literal|"%d"
argument_list|,
name|archive_entry_rdevminor
argument_list|(
name|file
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|r
operator|=
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterEndElement() failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
break|break;
default|default:
break|break;
block|}
comment|/* 	 * Make a inode entry, "<inode>". 	 */
name|r
operator|=
name|xmlwrite_fstring
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
literal|"inode"
argument_list|,
literal|"%jd"
argument_list|,
name|archive_entry_ino64
argument_list|(
name|file
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
if|if
condition|(
name|archive_entry_dev
argument_list|(
name|file
operator|->
name|entry
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|r
operator|=
name|xmlwrite_fstring
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
literal|"deviceno"
argument_list|,
literal|"%d"
argument_list|,
name|archive_entry_dev
argument_list|(
name|file
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* 	 * Make a file mode entry, "<mode>". 	 */
name|r
operator|=
name|xmlwrite_mode
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
literal|"mode"
argument_list|,
name|archive_entry_mode
argument_list|(
name|file
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
comment|/* 	 * Make a user entry, "<uid>" and "<user>. 	 */
name|r
operator|=
name|xmlwrite_fstring
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
literal|"uid"
argument_list|,
literal|"%d"
argument_list|,
name|archive_entry_uid
argument_list|(
name|file
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|r
operator|=
name|archive_entry_uname_l
argument_list|(
name|file
operator|->
name|entry
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|,
name|xar
operator|->
name|sconv
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for Uname"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Can't translate uname '%s' to UTF-8"
argument_list|,
name|archive_entry_uname
argument_list|(
name|file
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|r2
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|r
operator|=
name|xmlwrite_string
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
literal|"user"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* 	 * Make a group entry, "<gid>" and "<group>. 	 */
name|r
operator|=
name|xmlwrite_fstring
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
literal|"gid"
argument_list|,
literal|"%d"
argument_list|,
name|archive_entry_gid
argument_list|(
name|file
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|r
operator|=
name|archive_entry_gname_l
argument_list|(
name|file
operator|->
name|entry
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|,
name|xar
operator|->
name|sconv
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for Gname"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Can't translate gname '%s' to UTF-8"
argument_list|,
name|archive_entry_gname
argument_list|(
name|file
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|r2
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|r
operator|=
name|xmlwrite_string
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
literal|"group"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* 	 * Make a ctime entry, "<ctime>". 	 */
if|if
condition|(
name|archive_entry_ctime_is_set
argument_list|(
name|file
operator|->
name|entry
argument_list|)
condition|)
block|{
name|r
operator|=
name|xmlwrite_time
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
literal|"ctime"
argument_list|,
name|archive_entry_ctime
argument_list|(
name|file
operator|->
name|entry
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* 	 * Make a mtime entry, "<mtime>". 	 */
if|if
condition|(
name|archive_entry_mtime_is_set
argument_list|(
name|file
operator|->
name|entry
argument_list|)
condition|)
block|{
name|r
operator|=
name|xmlwrite_time
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
literal|"mtime"
argument_list|,
name|archive_entry_mtime
argument_list|(
name|file
operator|->
name|entry
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* 	 * Make a atime entry, "<atime>". 	 */
if|if
condition|(
name|archive_entry_atime_is_set
argument_list|(
name|file
operator|->
name|entry
argument_list|)
condition|)
block|{
name|r
operator|=
name|xmlwrite_time
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
literal|"atime"
argument_list|,
name|archive_entry_atime
argument_list|(
name|file
operator|->
name|entry
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* 	 * Make fflags entries, "<flags>" and "<ext2>". 	 */
name|fflags
operator|=
name|archive_entry_fflags_text
argument_list|(
name|file
operator|->
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflags
operator|!=
name|NULL
condition|)
block|{
name|r
operator|=
name|make_fflags_entry
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
literal|"flags"
argument_list|,
name|fflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|r
operator|=
name|make_fflags_entry
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
literal|"ext2"
argument_list|,
name|fflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
comment|/* 	 * Make extended attribute entries, "<ea>". 	 */
name|archive_entry_xattr_reset
argument_list|(
name|file
operator|->
name|entry
argument_list|)
expr_stmt|;
for|for
control|(
name|heap
operator|=
name|file
operator|->
name|xattr
operator|.
name|first
init|;
name|heap
operator|!=
name|NULL
condition|;
name|heap
operator|=
name|heap
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|void
modifier|*
name|value
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|archive_entry_xattr_next
argument_list|(
name|file
operator|->
name|entry
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|r
operator|=
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|BAD_CAST
argument_list|(
literal|"ea"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterStartElement() failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|r
operator|=
name|xmlTextWriterWriteFormatAttribute
argument_list|(
name|writer
argument_list|,
name|BAD_CAST
argument_list|(
literal|"id"
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|heap
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterWriteAttribute() failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|r
operator|=
name|xmlwrite_heap
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
name|heap
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|r
operator|=
name|xmlwrite_string
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
literal|"name"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|r
operator|=
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterEndElement() failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
comment|/* 	 * Make a file data entry, "<data>". 	 */
if|if
condition|(
name|file
operator|->
name|data
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|r
operator|=
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|BAD_CAST
argument_list|(
literal|"data"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterStartElement() failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|r
operator|=
name|xmlwrite_heap
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
operator|&
operator|(
name|file
operator|->
name|data
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|r
operator|=
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterEndElement() failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
name|file
operator|->
name|script
argument_list|)
operator|>
literal|0
condition|)
block|{
name|r
operator|=
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|BAD_CAST
argument_list|(
literal|"content"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterStartElement() failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|r
operator|=
name|xmlwrite_string
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
literal|"interpreter"
argument_list|,
name|file
operator|->
name|script
operator|.
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|r
operator|=
name|xmlwrite_string
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
literal|"type"
argument_list|,
literal|"script"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|r
operator|=
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterEndElement() failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
return|return
operator|(
name|r2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make the TOC  */
end_comment

begin_function
specifier|static
name|int
name|make_toc
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
name|struct
name|file
modifier|*
name|np
decl_stmt|;
name|xmlBufferPtr
name|bp
decl_stmt|;
name|xmlTextWriterPtr
name|writer
decl_stmt|;
name|int
name|algsize
decl_stmt|;
name|int
name|r
decl_stmt|,
name|ret
decl_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
name|a
operator|->
name|format_data
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
comment|/* 	 * Initialize xml writer. 	 */
name|writer
operator|=
name|NULL
expr_stmt|;
name|bp
operator|=
name|xmlBufferCreate
argument_list|()
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"xmlBufferCreate() "
literal|"couldn't create xml buffer"
argument_list|)
expr_stmt|;
goto|goto
name|exit_toc
goto|;
block|}
name|writer
operator|=
name|xmlNewTextWriterMemory
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|writer
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlNewTextWriterMemory() "
literal|"couldn't create xml writer"
argument_list|)
expr_stmt|;
goto|goto
name|exit_toc
goto|;
block|}
name|r
operator|=
name|xmlTextWriterStartDocument
argument_list|(
name|writer
argument_list|,
literal|"1.0"
argument_list|,
literal|"UTF-8"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterStartDocument() failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|exit_toc
goto|;
block|}
name|r
operator|=
name|xmlTextWriterSetIndent
argument_list|(
name|writer
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterSetIndent() failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|exit_toc
goto|;
block|}
comment|/* 	 * Start recoding TOC 	 */
name|r
operator|=
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|BAD_CAST
argument_list|(
literal|"xar"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterStartElement() failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|exit_toc
goto|;
block|}
name|r
operator|=
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|BAD_CAST
argument_list|(
literal|"toc"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterStartDocument() failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|exit_toc
goto|;
block|}
comment|/* 	 * Record the creation time of the archive file. 	 */
name|r
operator|=
name|xmlwrite_time
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
literal|"creation-time"
argument_list|,
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
goto|goto
name|exit_toc
goto|;
comment|/* 	 * Record the checksum value of TOC 	 */
name|algsize
operator|=
name|getalgsize
argument_list|(
name|xar
operator|->
name|opt_toc_sumalg
argument_list|)
expr_stmt|;
if|if
condition|(
name|algsize
condition|)
block|{
comment|/* 		 * Record TOC checksum 		 */
name|r
operator|=
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|BAD_CAST
argument_list|(
literal|"checksum"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterStartElement() failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|exit_toc
goto|;
block|}
name|r
operator|=
name|xmlTextWriterWriteAttribute
argument_list|(
name|writer
argument_list|,
name|BAD_CAST
argument_list|(
literal|"style"
argument_list|)
argument_list|,
name|BAD_CAST_CONST
argument_list|(
name|getalgname
argument_list|(
name|xar
operator|->
name|opt_toc_sumalg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterWriteAttribute() failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|exit_toc
goto|;
block|}
comment|/* 		 * Record the offset of the value of checksum of TOC 		 */
name|r
operator|=
name|xmlwrite_string
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
literal|"offset"
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
goto|goto
name|exit_toc
goto|;
comment|/* 		 * Record the size of the value of checksum of TOC 		 */
name|r
operator|=
name|xmlwrite_fstring
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
literal|"size"
argument_list|,
literal|"%d"
argument_list|,
name|algsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
goto|goto
name|exit_toc
goto|;
name|r
operator|=
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterEndElement() failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|exit_toc
goto|;
block|}
block|}
name|np
operator|=
name|xar
operator|->
name|root
expr_stmt|;
do|do
block|{
if|if
condition|(
name|np
operator|!=
name|np
operator|->
name|parent
condition|)
block|{
name|r
operator|=
name|make_file_entry
argument_list|(
name|a
argument_list|,
name|writer
argument_list|,
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
goto|goto
name|exit_toc
goto|;
block|}
if|if
condition|(
name|np
operator|->
name|dir
operator|&&
name|np
operator|->
name|children
operator|.
name|first
operator|!=
name|NULL
condition|)
block|{
comment|/* Enter to sub directories. */
name|np
operator|=
name|np
operator|->
name|children
operator|.
name|first
expr_stmt|;
name|r
operator|=
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|BAD_CAST
argument_list|(
literal|"file"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterStartElement() "
literal|"failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|exit_toc
goto|;
block|}
name|r
operator|=
name|xmlTextWriterWriteFormatAttribute
argument_list|(
name|writer
argument_list|,
name|BAD_CAST
argument_list|(
literal|"id"
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|np
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterWriteAttribute() "
literal|"failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|exit_toc
goto|;
block|}
continue|continue;
block|}
while|while
condition|(
name|np
operator|!=
name|np
operator|->
name|parent
condition|)
block|{
name|r
operator|=
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterEndElement() "
literal|"failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|exit_toc
goto|;
block|}
if|if
condition|(
name|np
operator|->
name|chnext
operator|==
name|NULL
condition|)
block|{
comment|/* Return to the parent directory. */
name|np
operator|=
name|np
operator|->
name|parent
expr_stmt|;
block|}
else|else
block|{
name|np
operator|=
name|np
operator|->
name|chnext
expr_stmt|;
name|r
operator|=
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|BAD_CAST
argument_list|(
literal|"file"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterStartElement() "
literal|"failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|exit_toc
goto|;
block|}
name|r
operator|=
name|xmlTextWriterWriteFormatAttribute
argument_list|(
name|writer
argument_list|,
name|BAD_CAST
argument_list|(
literal|"id"
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|np
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterWriteAttribute() "
literal|"failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|exit_toc
goto|;
block|}
break|break;
block|}
block|}
block|}
do|while
condition|(
name|np
operator|!=
name|np
operator|->
name|parent
condition|)
do|;
name|r
operator|=
name|xmlTextWriterEndDocument
argument_list|(
name|writer
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"xmlTextWriterEndDocument() failed: %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|exit_toc
goto|;
block|}
if|#
directive|if
name|DEBUG_PRINT_TOC
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n---TOC-- %d bytes --\n%s\n"
argument_list|,
name|strlen
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|bp
operator|->
name|content
argument_list|)
argument_list|,
name|bp
operator|->
name|content
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Compress the TOC and calculate the sum of the TOC. 	 */
name|xar
operator|->
name|toc
operator|.
name|temp_offset
operator|=
name|xar
operator|->
name|temp_offset
expr_stmt|;
name|xar
operator|->
name|toc
operator|.
name|size
operator|=
name|bp
operator|->
name|use
expr_stmt|;
name|checksum_init
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|a_sumwrk
operator|)
argument_list|,
name|xar
operator|->
name|opt_toc_sumalg
argument_list|)
expr_stmt|;
name|r
operator|=
name|compression_init_encoder_gzip
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
operator|&
operator|(
name|xar
operator|->
name|stream
operator|)
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
goto|goto
name|exit_toc
goto|;
name|xar
operator|->
name|stream
operator|.
name|next_in
operator|=
name|bp
operator|->
name|content
expr_stmt|;
name|xar
operator|->
name|stream
operator|.
name|avail_in
operator|=
name|bp
operator|->
name|use
expr_stmt|;
name|xar
operator|->
name|stream
operator|.
name|total_in
operator|=
literal|0
expr_stmt|;
name|xar
operator|->
name|stream
operator|.
name|next_out
operator|=
name|xar
operator|->
name|wbuff
expr_stmt|;
name|xar
operator|->
name|stream
operator|.
name|avail_out
operator|=
sizeof|sizeof
argument_list|(
name|xar
operator|->
name|wbuff
argument_list|)
expr_stmt|;
name|xar
operator|->
name|stream
operator|.
name|total_out
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|size_t
name|size
decl_stmt|;
name|r
operator|=
name|compression_code
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
operator|&
operator|(
name|xar
operator|->
name|stream
operator|)
argument_list|,
name|ARCHIVE_Z_FINISH
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
operator|&&
name|r
operator|!=
name|ARCHIVE_EOF
condition|)
goto|goto
name|exit_toc
goto|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|xar
operator|->
name|wbuff
argument_list|)
operator|-
name|xar
operator|->
name|stream
operator|.
name|avail_out
expr_stmt|;
name|checksum_update
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|a_sumwrk
operator|)
argument_list|,
name|xar
operator|->
name|wbuff
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_to_temp
argument_list|(
name|a
argument_list|,
name|xar
operator|->
name|wbuff
argument_list|,
name|size
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
goto|goto
name|exit_toc
goto|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_EOF
condition|)
break|break;
name|xar
operator|->
name|stream
operator|.
name|next_out
operator|=
name|xar
operator|->
name|wbuff
expr_stmt|;
name|xar
operator|->
name|stream
operator|.
name|avail_out
operator|=
sizeof|sizeof
argument_list|(
name|xar
operator|->
name|wbuff
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|compression_end
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
operator|&
operator|(
name|xar
operator|->
name|stream
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
goto|goto
name|exit_toc
goto|;
name|xar
operator|->
name|toc
operator|.
name|length
operator|=
name|xar
operator|->
name|stream
operator|.
name|total_out
expr_stmt|;
name|xar
operator|->
name|toc
operator|.
name|compression
operator|=
name|GZIP
expr_stmt|;
name|checksum_final
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|a_sumwrk
operator|)
argument_list|,
operator|&
operator|(
name|xar
operator|->
name|toc
operator|.
name|a_sum
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_OK
expr_stmt|;
name|exit_toc
label|:
if|if
condition|(
name|writer
condition|)
name|xmlFreeTextWriter
argument_list|(
name|writer
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
condition|)
name|xmlBufferFree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|flush_wbuff
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
name|int
name|r
decl_stmt|;
name|size_t
name|s
decl_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
name|a
operator|->
name|format_data
expr_stmt|;
name|s
operator|=
sizeof|sizeof
argument_list|(
name|xar
operator|->
name|wbuff
argument_list|)
operator|-
name|xar
operator|->
name|wbuff_remaining
expr_stmt|;
name|r
operator|=
name|__archive_write_output
argument_list|(
name|a
argument_list|,
name|xar
operator|->
name|wbuff
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|xar
operator|->
name|wbuff_remaining
operator|=
sizeof|sizeof
argument_list|(
name|xar
operator|->
name|wbuff
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|copy_out
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|length
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
name|int
name|r
decl_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
name|a
operator|->
name|format_data
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|xar
operator|->
name|temp_fd
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|errno
argument_list|,
literal|"lseek failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
while|while
condition|(
name|length
condition|)
block|{
name|size_t
name|rsize
decl_stmt|;
name|ssize_t
name|rs
decl_stmt|;
name|unsigned
name|char
modifier|*
name|wb
decl_stmt|;
if|if
condition|(
name|length
operator|>
name|xar
operator|->
name|wbuff_remaining
condition|)
name|rsize
operator|=
name|xar
operator|->
name|wbuff_remaining
expr_stmt|;
else|else
name|rsize
operator|=
operator|(
name|size_t
operator|)
name|length
expr_stmt|;
name|wb
operator|=
name|xar
operator|->
name|wbuff
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|xar
operator|->
name|wbuff
argument_list|)
operator|-
name|xar
operator|->
name|wbuff_remaining
operator|)
expr_stmt|;
name|rs
operator|=
name|read
argument_list|(
name|xar
operator|->
name|temp_fd
argument_list|,
name|wb
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
name|errno
argument_list|,
literal|"Can't read temporary file(%jd)"
argument_list|,
operator|(
name|intmax_t
operator|)
name|rs
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|rs
operator|==
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
literal|0
argument_list|,
literal|"Truncated xar archive"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|xar
operator|->
name|wbuff_remaining
operator|-=
name|rs
expr_stmt|;
name|length
operator|-=
name|rs
expr_stmt|;
if|if
condition|(
name|xar
operator|->
name|wbuff_remaining
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|flush_wbuff
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xar_close
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
name|unsigned
name|char
modifier|*
name|wb
decl_stmt|;
name|uint64_t
name|length
decl_stmt|;
name|int
name|r
decl_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
name|a
operator|->
name|format_data
expr_stmt|;
comment|/* Empty! */
if|if
condition|(
name|xar
operator|->
name|root
operator|->
name|children
operator|.
name|first
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
comment|/* Save the length of all file extended attributes and contents. */
name|length
operator|=
name|xar
operator|->
name|temp_offset
expr_stmt|;
comment|/* Connect hardlinked files */
name|file_connect_hardlink_files
argument_list|(
name|xar
argument_list|)
expr_stmt|;
comment|/* Make the TOC */
name|r
operator|=
name|make_toc
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
comment|/* 	 * Make the xar header on wbuff(write buffer). 	 */
name|wb
operator|=
name|xar
operator|->
name|wbuff
expr_stmt|;
name|xar
operator|->
name|wbuff_remaining
operator|=
sizeof|sizeof
argument_list|(
name|xar
operator|->
name|wbuff
argument_list|)
expr_stmt|;
name|archive_be32enc
argument_list|(
operator|&
name|wb
index|[
literal|0
index|]
argument_list|,
name|HEADER_MAGIC
argument_list|)
expr_stmt|;
name|archive_be16enc
argument_list|(
operator|&
name|wb
index|[
literal|4
index|]
argument_list|,
name|HEADER_SIZE
argument_list|)
expr_stmt|;
name|archive_be16enc
argument_list|(
operator|&
name|wb
index|[
literal|6
index|]
argument_list|,
name|HEADER_VERSION
argument_list|)
expr_stmt|;
name|archive_be64enc
argument_list|(
operator|&
name|wb
index|[
literal|8
index|]
argument_list|,
name|xar
operator|->
name|toc
operator|.
name|length
argument_list|)
expr_stmt|;
name|archive_be64enc
argument_list|(
operator|&
name|wb
index|[
literal|16
index|]
argument_list|,
name|xar
operator|->
name|toc
operator|.
name|size
argument_list|)
expr_stmt|;
name|archive_be32enc
argument_list|(
operator|&
name|wb
index|[
literal|24
index|]
argument_list|,
name|xar
operator|->
name|toc
operator|.
name|a_sum
operator|.
name|alg
argument_list|)
expr_stmt|;
name|xar
operator|->
name|wbuff_remaining
operator|-=
name|HEADER_SIZE
expr_stmt|;
comment|/* 	 * Write the TOC 	 */
name|r
operator|=
name|copy_out
argument_list|(
name|a
argument_list|,
name|xar
operator|->
name|toc
operator|.
name|temp_offset
argument_list|,
name|xar
operator|->
name|toc
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
comment|/* Write the checksum value of the TOC. */
if|if
condition|(
name|xar
operator|->
name|toc
operator|.
name|a_sum
operator|.
name|len
condition|)
block|{
if|if
condition|(
name|xar
operator|->
name|wbuff_remaining
operator|<
name|xar
operator|->
name|toc
operator|.
name|a_sum
operator|.
name|len
condition|)
block|{
name|r
operator|=
name|flush_wbuff
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
name|wb
operator|=
name|xar
operator|->
name|wbuff
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|xar
operator|->
name|wbuff
argument_list|)
operator|-
name|xar
operator|->
name|wbuff_remaining
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|wb
argument_list|,
name|xar
operator|->
name|toc
operator|.
name|a_sum
operator|.
name|val
argument_list|,
name|xar
operator|->
name|toc
operator|.
name|a_sum
operator|.
name|len
argument_list|)
expr_stmt|;
name|xar
operator|->
name|wbuff_remaining
operator|-=
name|xar
operator|->
name|toc
operator|.
name|a_sum
operator|.
name|len
expr_stmt|;
block|}
comment|/* 	 * Write all file extended attributes and contents. 	 */
name|r
operator|=
name|copy_out
argument_list|(
name|a
argument_list|,
name|xar
operator|->
name|toc
operator|.
name|a_sum
operator|.
name|len
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|r
operator|=
name|flush_wbuff
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xar_free
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
name|a
operator|->
name|format_data
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|cur_dirstr
operator|)
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|tstr
operator|)
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|vstr
operator|)
argument_list|)
expr_stmt|;
name|file_free_hardlinks
argument_list|(
name|xar
argument_list|)
expr_stmt|;
name|file_free_register
argument_list|(
name|xar
argument_list|)
expr_stmt|;
name|compression_end
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
operator|&
operator|(
name|xar
operator|->
name|stream
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xar
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|file_cmp_node
parameter_list|(
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|n1
parameter_list|,
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|n2
parameter_list|)
block|{
specifier|const
name|struct
name|file
modifier|*
name|f1
init|=
operator|(
specifier|const
expr|struct
name|file
operator|*
operator|)
name|n1
decl_stmt|;
specifier|const
name|struct
name|file
modifier|*
name|f2
init|=
operator|(
specifier|const
expr|struct
name|file
operator|*
operator|)
name|n2
decl_stmt|;
return|return
operator|(
name|strcmp
argument_list|(
name|f1
operator|->
name|basename
operator|.
name|s
argument_list|,
name|f2
operator|->
name|basename
operator|.
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|file_cmp_key
parameter_list|(
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|n
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|)
block|{
specifier|const
name|struct
name|file
modifier|*
name|f
init|=
operator|(
specifier|const
expr|struct
name|file
operator|*
operator|)
name|n
decl_stmt|;
return|return
operator|(
name|strcmp
argument_list|(
name|f
operator|->
name|basename
operator|.
name|s
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|key
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|file
modifier|*
name|file_new
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|file
modifier|*
name|file
decl_stmt|;
specifier|static
specifier|const
name|struct
name|archive_rb_tree_ops
name|rb_ops
init|=
block|{
name|file_cmp_node
block|,
name|file_cmp_key
block|}
decl_stmt|;
name|file
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|file
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
name|file
operator|->
name|entry
operator|=
name|archive_entry_clone
argument_list|(
name|entry
argument_list|)
expr_stmt|;
else|else
name|file
operator|->
name|entry
operator|=
name|archive_entry_new2
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|entry
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|__archive_rb_tree_init
argument_list|(
operator|&
operator|(
name|file
operator|->
name|rbtree
operator|)
argument_list|,
operator|&
name|rb_ops
argument_list|)
expr_stmt|;
name|file
operator|->
name|children
operator|.
name|first
operator|=
name|NULL
expr_stmt|;
name|file
operator|->
name|children
operator|.
name|last
operator|=
operator|&
operator|(
name|file
operator|->
name|children
operator|.
name|first
operator|)
expr_stmt|;
name|file
operator|->
name|xattr
operator|.
name|first
operator|=
name|NULL
expr_stmt|;
name|file
operator|->
name|xattr
operator|.
name|last
operator|=
operator|&
operator|(
name|file
operator|->
name|xattr
operator|.
name|first
operator|)
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
operator|(
name|file
operator|->
name|parentdir
operator|)
argument_list|)
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
operator|(
name|file
operator|->
name|basename
operator|)
argument_list|)
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
operator|(
name|file
operator|->
name|symlink
operator|)
argument_list|)
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
operator|(
name|file
operator|->
name|script
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
operator|&&
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
operator|==
name|AE_IFDIR
condition|)
name|file
operator|->
name|dir
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|file
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|file_free
parameter_list|(
name|struct
name|file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|heap_data
modifier|*
name|heap
decl_stmt|,
modifier|*
name|next_heap
decl_stmt|;
name|heap
operator|=
name|file
operator|->
name|xattr
operator|.
name|first
expr_stmt|;
while|while
condition|(
name|heap
operator|!=
name|NULL
condition|)
block|{
name|next_heap
operator|=
name|heap
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|heap
argument_list|)
expr_stmt|;
name|heap
operator|=
name|next_heap
expr_stmt|;
block|}
name|archive_string_free
argument_list|(
operator|&
operator|(
name|file
operator|->
name|parentdir
operator|)
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|file
operator|->
name|basename
operator|)
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|file
operator|->
name|symlink
operator|)
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|file
operator|->
name|script
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|file
modifier|*
name|file_create_virtual_dir
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|xar
modifier|*
name|xar
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|)
block|{
name|struct
name|file
modifier|*
name|file
decl_stmt|;
operator|(
name|void
operator|)
name|xar
expr_stmt|;
comment|/* UNUSED */
name|file
operator|=
name|file_new
argument_list|(
name|a
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|archive_entry_set_pathname
argument_list|(
name|file
operator|->
name|entry
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|archive_entry_set_mode
argument_list|(
name|file
operator|->
name|entry
argument_list|,
literal|0555
operator||
name|AE_IFDIR
argument_list|)
expr_stmt|;
name|file
operator|->
name|dir
operator|=
literal|1
expr_stmt|;
name|file
operator|->
name|virtual
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|file
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|file_add_child_tail
parameter_list|(
name|struct
name|file
modifier|*
name|parent
parameter_list|,
name|struct
name|file
modifier|*
name|child
parameter_list|)
block|{
if|if
condition|(
operator|!
name|__archive_rb_tree_insert_node
argument_list|(
operator|&
operator|(
name|parent
operator|->
name|rbtree
operator|)
argument_list|,
operator|(
expr|struct
name|archive_rb_node
operator|*
operator|)
name|child
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|child
operator|->
name|chnext
operator|=
name|NULL
expr_stmt|;
operator|*
name|parent
operator|->
name|children
operator|.
name|last
operator|=
name|child
expr_stmt|;
name|parent
operator|->
name|children
operator|.
name|last
operator|=
operator|&
operator|(
name|child
operator|->
name|chnext
operator|)
expr_stmt|;
name|child
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find a entry from `parent'  */
end_comment

begin_function
specifier|static
name|struct
name|file
modifier|*
name|file_find_child
parameter_list|(
name|struct
name|file
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|child_name
parameter_list|)
block|{
name|struct
name|file
modifier|*
name|np
decl_stmt|;
name|np
operator|=
operator|(
expr|struct
name|file
operator|*
operator|)
name|__archive_rb_tree_find_node
argument_list|(
operator|&
operator|(
name|parent
operator|->
name|rbtree
operator|)
argument_list|,
name|child_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|np
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_function
specifier|static
name|void
name|cleanup_backslash
parameter_list|(
name|char
modifier|*
name|utf8
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
comment|/* Convert a path-separator from '\' to  '/' */
while|while
condition|(
operator|*
name|utf8
operator|!=
literal|'\0'
operator|&&
name|len
condition|)
block|{
if|if
condition|(
operator|*
name|utf8
operator|==
literal|'\\'
condition|)
operator|*
name|utf8
operator|=
literal|'/'
expr_stmt|;
operator|++
name|utf8
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|cleanup_backslash
parameter_list|(
name|p
parameter_list|,
name|len
parameter_list|)
end_define

begin_comment
comment|/* nop */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Generate a parent directory name and a base name from a pathname.  */
end_comment

begin_function
specifier|static
name|int
name|file_gen_utility_names
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
specifier|const
name|char
modifier|*
name|pp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|dirname
decl_stmt|,
modifier|*
name|slash
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|r
init|=
name|ARCHIVE_OK
decl_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
name|a
operator|->
name|format_data
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|file
operator|->
name|parentdir
operator|)
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|file
operator|->
name|basename
operator|)
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|file
operator|->
name|symlink
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|parent
operator|==
name|file
condition|)
comment|/* virtual root */
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
if|if
condition|(
name|archive_entry_pathname_l
argument_list|(
name|file
operator|->
name|entry
argument_list|,
operator|&
name|pp
argument_list|,
operator|&
name|len
argument_list|,
name|xar
operator|->
name|sconv
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for Pathname"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Can't translate pathname '%s' to UTF-8"
argument_list|,
name|archive_entry_pathname
argument_list|(
name|file
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
name|archive_strncpy
argument_list|(
operator|&
operator|(
name|file
operator|->
name|parentdir
operator|)
argument_list|,
name|pp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
name|file
operator|->
name|parentdir
operator|.
name|length
expr_stmt|;
name|p
operator|=
name|dirname
operator|=
name|file
operator|->
name|parentdir
operator|.
name|s
expr_stmt|;
comment|/* 	 * Convert a path-separator from '\' to  '/' 	 */
name|cleanup_backslash
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 	 * Remove leading '/', '../' and './' elements 	 */
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
break|break;
elseif|else
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'/'
condition|)
block|{
name|p
operator|+=
literal|3
expr_stmt|;
name|len
operator|-=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
operator|||
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|p
operator|!=
name|dirname
condition|)
block|{
name|memmove
argument_list|(
name|dirname
argument_list|,
name|p
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|dirname
expr_stmt|;
block|}
comment|/* 	 * Remove "/","/." and "/.." elements from tail. 	 */
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|size_t
name|ll
init|=
name|len
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|1
operator|&&
name|p
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'/'
operator|&&
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
name|p
index|[
name|len
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|2
operator|&&
name|p
index|[
name|len
operator|-
literal|3
index|]
operator|==
literal|'/'
operator|&&
name|p
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
name|p
index|[
name|len
operator|-
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|-=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|ll
operator|==
name|len
condition|)
break|break;
block|}
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
comment|/* Convert '//' --> '/' */
name|strcpy
argument_list|(
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'/'
condition|)
comment|/* Convert '/./' --> '/' */
name|strcpy
argument_list|(
name|p
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* Convert 'dir/dir1/../dir2/' 				 *     --> 'dir/dir2/' 				 */
name|char
modifier|*
name|rp
init|=
name|p
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|rp
operator|>=
name|dirname
condition|)
block|{
if|if
condition|(
operator|*
name|rp
operator|==
literal|'/'
condition|)
break|break;
operator|--
name|rp
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|>
name|dirname
condition|)
block|{
name|strcpy
argument_list|(
name|rp
argument_list|,
name|p
operator|+
literal|3
argument_list|)
expr_stmt|;
name|p
operator|=
name|rp
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|dirname
argument_list|,
name|p
operator|+
literal|4
argument_list|)
expr_stmt|;
name|p
operator|=
name|dirname
expr_stmt|;
block|}
block|}
else|else
name|p
operator|++
expr_stmt|;
block|}
else|else
name|p
operator|++
expr_stmt|;
block|}
name|p
operator|=
name|dirname
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_entry_filetype
argument_list|(
name|file
operator|->
name|entry
argument_list|)
operator|==
name|AE_IFLNK
condition|)
block|{
name|size_t
name|len2
decl_stmt|;
comment|/* Convert symlink name too. */
if|if
condition|(
name|archive_entry_symlink_l
argument_list|(
name|file
operator|->
name|entry
argument_list|,
operator|&
name|pp
argument_list|,
operator|&
name|len2
argument_list|,
name|xar
operator|->
name|sconv
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for Linkname"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Can't translate symlink '%s' to UTF-8"
argument_list|,
name|archive_entry_symlink
argument_list|(
name|file
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
name|archive_strncpy
argument_list|(
operator|&
operator|(
name|file
operator|->
name|symlink
operator|)
argument_list|,
name|pp
argument_list|,
name|len2
argument_list|)
expr_stmt|;
name|cleanup_backslash
argument_list|(
name|file
operator|->
name|symlink
operator|.
name|s
argument_list|,
name|file
operator|->
name|symlink
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * - Count up directory elements. 	 * - Find out the position which points the last position of 	 *   path separator('/'). 	 */
name|slash
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
name|slash
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|slash
operator|==
name|NULL
condition|)
block|{
comment|/* The pathname doesn't have a parent directory. */
name|file
operator|->
name|parentdir
operator|.
name|length
operator|=
name|len
expr_stmt|;
name|archive_string_copy
argument_list|(
operator|&
operator|(
name|file
operator|->
name|basename
operator|)
argument_list|,
operator|&
operator|(
name|file
operator|->
name|parentdir
operator|)
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|file
operator|->
name|parentdir
operator|)
argument_list|)
expr_stmt|;
name|file
operator|->
name|parentdir
operator|.
name|s
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
comment|/* Make a basename from dirname and slash */
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
name|file
operator|->
name|parentdir
operator|.
name|length
operator|=
name|slash
operator|-
name|dirname
expr_stmt|;
name|archive_strcpy
argument_list|(
operator|&
operator|(
name|file
operator|->
name|basename
operator|)
argument_list|,
name|slash
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_path_component
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|l
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|fn
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|l
operator|=
name|strlen
argument_list|(
name|fn
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
name|l
operator|=
name|p
operator|-
name|fn
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|n
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|memcpy
argument_list|(
name|name
argument_list|,
name|fn
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|name
index|[
name|l
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|l
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a new entry into the tree.  */
end_comment

begin_function
specifier|static
name|int
name|file_tree
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|file
modifier|*
modifier|*
name|filepp
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
name|char
name|name
index|[
name|_MAX_FNAME
index|]
decl_stmt|;
comment|/* Included null terminator size. */
elif|#
directive|elif
name|defined
argument_list|(
name|NAME_MAX
argument_list|)
operator|&&
name|NAME_MAX
operator|>=
literal|255
name|char
name|name
index|[
name|NAME_MAX
operator|+
literal|1
index|]
decl_stmt|;
else|#
directive|else
name|char
name|name
index|[
literal|256
index|]
decl_stmt|;
endif|#
directive|endif
name|struct
name|xar
modifier|*
name|xar
init|=
operator|(
expr|struct
name|xar
operator|*
operator|)
name|a
operator|->
name|format_data
decl_stmt|;
name|struct
name|file
modifier|*
name|dent
decl_stmt|,
modifier|*
name|file
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|struct
name|archive_entry
modifier|*
name|ent
decl_stmt|;
specifier|const
name|char
modifier|*
name|fn
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|l
decl_stmt|;
name|file
operator|=
operator|*
name|filepp
expr_stmt|;
name|dent
operator|=
name|xar
operator|->
name|root
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|parentdir
operator|.
name|length
operator|>
literal|0
condition|)
name|fn
operator|=
name|p
operator|=
name|file
operator|->
name|parentdir
operator|.
name|s
expr_stmt|;
else|else
name|fn
operator|=
name|p
operator|=
literal|""
expr_stmt|;
comment|/* 	 * If the path of the parent directory of `file' entry is 	 * the same as the path of `cur_dirent', add isoent to 	 * `cur_dirent'. 	 */
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|cur_dirstr
operator|)
argument_list|)
operator|==
name|archive_strlen
argument_list|(
operator|&
operator|(
name|file
operator|->
name|parentdir
operator|)
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|xar
operator|->
name|cur_dirstr
operator|.
name|s
argument_list|,
name|fn
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|file_add_child_tail
argument_list|(
name|xar
operator|->
name|cur_dirent
argument_list|,
name|file
argument_list|)
condition|)
block|{
name|np
operator|=
operator|(
expr|struct
name|file
operator|*
operator|)
name|__archive_rb_tree_find_node
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|cur_dirent
operator|->
name|rbtree
operator|)
argument_list|,
name|file
operator|->
name|basename
operator|.
name|s
argument_list|)
expr_stmt|;
goto|goto
name|same_entry
goto|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|l
operator|=
name|get_path_component
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
block|{
name|np
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|l
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"A name buffer is too small"
argument_list|)
expr_stmt|;
name|file_free
argument_list|(
name|file
argument_list|)
expr_stmt|;
operator|*
name|filepp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|np
operator|=
name|file_find_child
argument_list|(
name|dent
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
operator|||
name|fn
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
break|break;
comment|/* Find next subdirectory. */
if|if
condition|(
operator|!
name|np
operator|->
name|dir
condition|)
block|{
comment|/* NOT Directory! */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"`%s' is not directory, we cannot insert `%s' "
argument_list|,
name|archive_entry_pathname
argument_list|(
name|np
operator|->
name|entry
argument_list|)
argument_list|,
name|archive_entry_pathname
argument_list|(
name|file
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|file_free
argument_list|(
name|file
argument_list|)
expr_stmt|;
operator|*
name|filepp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|fn
operator|+=
name|l
expr_stmt|;
if|if
condition|(
name|fn
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|fn
operator|++
expr_stmt|;
name|dent
operator|=
name|np
expr_stmt|;
block|}
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Create virtual parent directories. 		 */
while|while
condition|(
name|fn
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|struct
name|file
modifier|*
name|vp
decl_stmt|;
name|struct
name|archive_string
name|as
decl_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|as
argument_list|)
expr_stmt|;
name|archive_strncat
argument_list|(
operator|&
name|as
argument_list|,
name|p
argument_list|,
name|fn
operator|-
name|p
operator|+
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|as
operator|.
name|s
index|[
name|as
operator|.
name|length
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|as
operator|.
name|s
index|[
name|as
operator|.
name|length
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|as
operator|.
name|length
operator|--
expr_stmt|;
block|}
name|vp
operator|=
name|file_create_virtual_dir
argument_list|(
name|a
argument_list|,
name|xar
argument_list|,
name|as
operator|.
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|archive_string_free
argument_list|(
operator|&
name|as
argument_list|)
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
name|file_free
argument_list|(
name|file
argument_list|)
expr_stmt|;
operator|*
name|filepp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_string_free
argument_list|(
operator|&
name|as
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_gen_utility_names
argument_list|(
name|a
argument_list|,
name|vp
argument_list|)
operator|<=
name|ARCHIVE_FAILED
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|file_add_child_tail
argument_list|(
name|dent
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|file_register
argument_list|(
name|xar
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|np
operator|=
name|vp
expr_stmt|;
name|fn
operator|+=
name|l
expr_stmt|;
if|if
condition|(
name|fn
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|fn
operator|++
expr_stmt|;
name|l
operator|=
name|get_path_component
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|<
literal|0
condition|)
block|{
name|archive_string_free
argument_list|(
operator|&
name|as
argument_list|)
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"A name buffer is too small"
argument_list|)
expr_stmt|;
name|file_free
argument_list|(
name|file
argument_list|)
expr_stmt|;
operator|*
name|filepp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|dent
operator|=
name|np
expr_stmt|;
block|}
comment|/* Found out the parent directory where isoent can be 		 * inserted. */
name|xar
operator|->
name|cur_dirent
operator|=
name|dent
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|cur_dirstr
operator|)
argument_list|)
expr_stmt|;
name|archive_string_ensure
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|cur_dirstr
operator|)
argument_list|,
name|archive_strlen
argument_list|(
operator|&
operator|(
name|dent
operator|->
name|parentdir
operator|)
argument_list|)
operator|+
name|archive_strlen
argument_list|(
operator|&
operator|(
name|dent
operator|->
name|basename
operator|)
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
operator|(
name|dent
operator|->
name|parentdir
operator|)
argument_list|)
operator|+
name|archive_strlen
argument_list|(
operator|&
operator|(
name|dent
operator|->
name|basename
operator|)
argument_list|)
operator|==
literal|0
condition|)
name|xar
operator|->
name|cur_dirstr
operator|.
name|s
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
operator|(
name|dent
operator|->
name|parentdir
operator|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|archive_string_copy
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|cur_dirstr
operator|)
argument_list|,
operator|&
operator|(
name|dent
operator|->
name|parentdir
operator|)
argument_list|)
expr_stmt|;
name|archive_strappend_char
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|cur_dirstr
operator|)
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
block|}
name|archive_string_concat
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|cur_dirstr
operator|)
argument_list|,
operator|&
operator|(
name|dent
operator|->
name|basename
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|file_add_child_tail
argument_list|(
name|dent
argument_list|,
name|file
argument_list|)
condition|)
block|{
name|np
operator|=
operator|(
expr|struct
name|file
operator|*
operator|)
name|__archive_rb_tree_find_node
argument_list|(
operator|&
operator|(
name|dent
operator|->
name|rbtree
operator|)
argument_list|,
name|file
operator|->
name|basename
operator|.
name|s
argument_list|)
expr_stmt|;
goto|goto
name|same_entry
goto|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
name|same_entry
label|:
comment|/* 	 * We have already has the entry the filename of which is 	 * the same. 	 */
if|if
condition|(
name|archive_entry_filetype
argument_list|(
name|np
operator|->
name|entry
argument_list|)
operator|!=
name|archive_entry_filetype
argument_list|(
name|file
operator|->
name|entry
argument_list|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Found duplicate entries `%s' and its file type is "
literal|"different"
argument_list|,
name|archive_entry_pathname
argument_list|(
name|np
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|file_free
argument_list|(
name|file
argument_list|)
expr_stmt|;
operator|*
name|filepp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
comment|/* Swap files. */
name|ent
operator|=
name|np
operator|->
name|entry
expr_stmt|;
name|np
operator|->
name|entry
operator|=
name|file
operator|->
name|entry
expr_stmt|;
name|file
operator|->
name|entry
operator|=
name|ent
expr_stmt|;
name|np
operator|->
name|virtual
operator|=
literal|0
expr_stmt|;
name|file_free
argument_list|(
name|file
argument_list|)
expr_stmt|;
operator|*
name|filepp
operator|=
name|np
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|file_register
parameter_list|(
name|struct
name|xar
modifier|*
name|xar
parameter_list|,
name|struct
name|file
modifier|*
name|file
parameter_list|)
block|{
name|file
operator|->
name|id
operator|=
name|xar
operator|->
name|file_idx
operator|++
expr_stmt|;
name|file
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|xar
operator|->
name|file_list
operator|.
name|last
operator|=
name|file
expr_stmt|;
name|xar
operator|->
name|file_list
operator|.
name|last
operator|=
operator|&
operator|(
name|file
operator|->
name|next
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|file_init_register
parameter_list|(
name|struct
name|xar
modifier|*
name|xar
parameter_list|)
block|{
name|xar
operator|->
name|file_list
operator|.
name|first
operator|=
name|NULL
expr_stmt|;
name|xar
operator|->
name|file_list
operator|.
name|last
operator|=
operator|&
operator|(
name|xar
operator|->
name|file_list
operator|.
name|first
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|file_free_register
parameter_list|(
name|struct
name|xar
modifier|*
name|xar
parameter_list|)
block|{
name|struct
name|file
modifier|*
name|file
decl_stmt|,
modifier|*
name|file_next
decl_stmt|;
name|file
operator|=
name|xar
operator|->
name|file_list
operator|.
name|first
expr_stmt|;
while|while
condition|(
name|file
operator|!=
name|NULL
condition|)
block|{
name|file_next
operator|=
name|file
operator|->
name|next
expr_stmt|;
name|file_free
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|file
operator|=
name|file_next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Register entry to get a hardlink target.  */
end_comment

begin_function
specifier|static
name|int
name|file_register_hardlink
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
init|=
operator|(
expr|struct
name|xar
operator|*
operator|)
name|a
operator|->
name|format_data
decl_stmt|;
name|struct
name|hardlink
modifier|*
name|hl
decl_stmt|;
specifier|const
name|char
modifier|*
name|pathname
decl_stmt|;
name|archive_entry_set_nlink
argument_list|(
name|file
operator|->
name|entry
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pathname
operator|=
name|archive_entry_hardlink
argument_list|(
name|file
operator|->
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|pathname
operator|==
name|NULL
condition|)
block|{
comment|/* This `file` is a hardlink target. */
name|hl
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hl
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|hl
operator|->
name|nlink
operator|=
literal|1
expr_stmt|;
comment|/* A hardlink target must be the first position. */
name|file
operator|->
name|hlnext
operator|=
name|NULL
expr_stmt|;
name|hl
operator|->
name|file_list
operator|.
name|first
operator|=
name|file
expr_stmt|;
name|hl
operator|->
name|file_list
operator|.
name|last
operator|=
operator|&
operator|(
name|file
operator|->
name|hlnext
operator|)
expr_stmt|;
name|__archive_rb_tree_insert_node
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|hardlink_rbtree
operator|)
argument_list|,
operator|(
expr|struct
name|archive_rb_node
operator|*
operator|)
name|hl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hl
operator|=
operator|(
expr|struct
name|hardlink
operator|*
operator|)
name|__archive_rb_tree_find_node
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|hardlink_rbtree
operator|)
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|hl
operator|!=
name|NULL
condition|)
block|{
comment|/* Insert `file` entry into the tail. */
name|file
operator|->
name|hlnext
operator|=
name|NULL
expr_stmt|;
operator|*
name|hl
operator|->
name|file_list
operator|.
name|last
operator|=
name|file
expr_stmt|;
name|hl
operator|->
name|file_list
operator|.
name|last
operator|=
operator|&
operator|(
name|file
operator|->
name|hlnext
operator|)
expr_stmt|;
name|hl
operator|->
name|nlink
operator|++
expr_stmt|;
block|}
name|archive_entry_unset_size
argument_list|(
name|file
operator|->
name|entry
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hardlinked files have to have the same location of extent.  * We have to find out hardlink target entries for entries which  * have a hardlink target name.  */
end_comment

begin_function
specifier|static
name|void
name|file_connect_hardlink_files
parameter_list|(
name|struct
name|xar
modifier|*
name|xar
parameter_list|)
block|{
name|struct
name|archive_rb_node
modifier|*
name|n
decl_stmt|;
name|struct
name|hardlink
modifier|*
name|hl
decl_stmt|;
name|struct
name|file
modifier|*
name|target
decl_stmt|,
modifier|*
name|nf
decl_stmt|;
name|ARCHIVE_RB_TREE_FOREACH
argument_list|(
argument|n
argument_list|,
argument|&(xar->hardlink_rbtree)
argument_list|)
block|{
name|hl
operator|=
operator|(
expr|struct
name|hardlink
operator|*
operator|)
name|n
expr_stmt|;
comment|/* The first entry must be a hardlink target. */
name|target
operator|=
name|hl
operator|->
name|file_list
operator|.
name|first
expr_stmt|;
name|archive_entry_set_nlink
argument_list|(
name|target
operator|->
name|entry
argument_list|,
name|hl
operator|->
name|nlink
argument_list|)
expr_stmt|;
if|if
condition|(
name|hl
operator|->
name|nlink
operator|>
literal|1
condition|)
comment|/* It means this file is a hardlink 			 * targe itself. */
name|target
operator|->
name|hardlink_target
operator|=
name|target
expr_stmt|;
for|for
control|(
name|nf
operator|=
name|target
operator|->
name|hlnext
init|;
name|nf
operator|!=
name|NULL
condition|;
name|nf
operator|=
name|nf
operator|->
name|hlnext
control|)
block|{
name|nf
operator|->
name|hardlink_target
operator|=
name|target
expr_stmt|;
name|archive_entry_set_nlink
argument_list|(
name|nf
operator|->
name|entry
argument_list|,
name|hl
operator|->
name|nlink
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|file_hd_cmp_node
parameter_list|(
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|n1
parameter_list|,
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|n2
parameter_list|)
block|{
specifier|const
name|struct
name|hardlink
modifier|*
name|h1
init|=
operator|(
specifier|const
expr|struct
name|hardlink
operator|*
operator|)
name|n1
decl_stmt|;
specifier|const
name|struct
name|hardlink
modifier|*
name|h2
init|=
operator|(
specifier|const
expr|struct
name|hardlink
operator|*
operator|)
name|n2
decl_stmt|;
return|return
operator|(
name|strcmp
argument_list|(
name|archive_entry_pathname
argument_list|(
name|h1
operator|->
name|file_list
operator|.
name|first
operator|->
name|entry
argument_list|)
argument_list|,
name|archive_entry_pathname
argument_list|(
name|h2
operator|->
name|file_list
operator|.
name|first
operator|->
name|entry
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|file_hd_cmp_key
parameter_list|(
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|n
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|)
block|{
specifier|const
name|struct
name|hardlink
modifier|*
name|h
init|=
operator|(
specifier|const
expr|struct
name|hardlink
operator|*
operator|)
name|n
decl_stmt|;
return|return
operator|(
name|strcmp
argument_list|(
name|archive_entry_pathname
argument_list|(
name|h
operator|->
name|file_list
operator|.
name|first
operator|->
name|entry
argument_list|)
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|key
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|file_init_hardlinks
parameter_list|(
name|struct
name|xar
modifier|*
name|xar
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|archive_rb_tree_ops
name|rb_ops
init|=
block|{
name|file_hd_cmp_node
block|,
name|file_hd_cmp_key
block|, 	}
decl_stmt|;
name|__archive_rb_tree_init
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|hardlink_rbtree
operator|)
argument_list|,
operator|&
name|rb_ops
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|file_free_hardlinks
parameter_list|(
name|struct
name|xar
modifier|*
name|xar
parameter_list|)
block|{
name|struct
name|archive_rb_node
modifier|*
name|n
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|n
operator|=
name|ARCHIVE_RB_TREE_MIN
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|hardlink_rbtree
operator|)
argument_list|)
init|;
name|n
condition|;
control|)
block|{
name|next
operator|=
name|__archive_rb_tree_iterate
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|hardlink_rbtree
operator|)
argument_list|,
name|n
argument_list|,
name|ARCHIVE_RB_DIR_RIGHT
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|checksum_init
parameter_list|(
name|struct
name|chksumwork
modifier|*
name|sumwrk
parameter_list|,
name|enum
name|sumalg
name|sum_alg
parameter_list|)
block|{
name|sumwrk
operator|->
name|alg
operator|=
name|sum_alg
expr_stmt|;
switch|switch
condition|(
name|sum_alg
condition|)
block|{
case|case
name|CKSUM_NONE
case|:
break|break;
case|case
name|CKSUM_SHA1
case|:
name|archive_sha1_init
argument_list|(
operator|&
operator|(
name|sumwrk
operator|->
name|sha1ctx
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CKSUM_MD5
case|:
name|archive_md5_init
argument_list|(
operator|&
operator|(
name|sumwrk
operator|->
name|md5ctx
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|checksum_update
parameter_list|(
name|struct
name|chksumwork
modifier|*
name|sumwrk
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
switch|switch
condition|(
name|sumwrk
operator|->
name|alg
condition|)
block|{
case|case
name|CKSUM_NONE
case|:
break|break;
case|case
name|CKSUM_SHA1
case|:
name|archive_sha1_update
argument_list|(
operator|&
operator|(
name|sumwrk
operator|->
name|sha1ctx
operator|)
argument_list|,
name|buff
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|CKSUM_MD5
case|:
name|archive_md5_update
argument_list|(
operator|&
operator|(
name|sumwrk
operator|->
name|md5ctx
operator|)
argument_list|,
name|buff
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|checksum_final
parameter_list|(
name|struct
name|chksumwork
modifier|*
name|sumwrk
parameter_list|,
name|struct
name|chksumval
modifier|*
name|sumval
parameter_list|)
block|{
switch|switch
condition|(
name|sumwrk
operator|->
name|alg
condition|)
block|{
case|case
name|CKSUM_NONE
case|:
name|sumval
operator|->
name|len
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CKSUM_SHA1
case|:
name|archive_sha1_final
argument_list|(
operator|&
operator|(
name|sumwrk
operator|->
name|sha1ctx
operator|)
argument_list|,
name|sumval
operator|->
name|val
argument_list|)
expr_stmt|;
name|sumval
operator|->
name|len
operator|=
name|SHA1_SIZE
expr_stmt|;
break|break;
case|case
name|CKSUM_MD5
case|:
name|archive_md5_final
argument_list|(
operator|&
operator|(
name|sumwrk
operator|->
name|md5ctx
operator|)
argument_list|,
name|sumval
operator|->
name|val
argument_list|)
expr_stmt|;
name|sumval
operator|->
name|len
operator|=
name|MD5_SIZE
expr_stmt|;
break|break;
block|}
name|sumval
operator|->
name|alg
operator|=
name|sumwrk
operator|->
name|alg
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_BZLIB_H
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|BZ_CONFIG_ERROR
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAVE_LZMA_H
argument_list|)
end_if

begin_function
specifier|static
name|int
name|compression_unsupported_encoder
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|la_zstream
modifier|*
name|lastrm
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"%s compression not supported on this platform"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|lastrm
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
name|lastrm
operator|->
name|real_stream
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|compression_init_encoder_gzip
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|la_zstream
modifier|*
name|lastrm
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|withheader
parameter_list|)
block|{
name|z_stream
modifier|*
name|strm
decl_stmt|;
if|if
condition|(
name|lastrm
operator|->
name|valid
condition|)
name|compression_end
argument_list|(
name|a
argument_list|,
name|lastrm
argument_list|)
expr_stmt|;
name|strm
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|strm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strm
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for gzip stream"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* zlib.h is not const-correct, so we need this one bit 	 * of ugly hackery to convert a const * pointer to 	 * a non-const pointer. */
name|strm
operator|->
name|next_in
operator|=
operator|(
name|Bytef
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|(
specifier|const
name|void
operator|*
operator|)
name|lastrm
operator|->
name|next_in
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|=
name|lastrm
operator|->
name|avail_in
expr_stmt|;
name|strm
operator|->
name|total_in
operator|=
operator|(
name|uLong
operator|)
name|lastrm
operator|->
name|total_in
expr_stmt|;
name|strm
operator|->
name|next_out
operator|=
name|lastrm
operator|->
name|next_out
expr_stmt|;
name|strm
operator|->
name|avail_out
operator|=
name|lastrm
operator|->
name|avail_out
expr_stmt|;
name|strm
operator|->
name|total_out
operator|=
operator|(
name|uLong
operator|)
name|lastrm
operator|->
name|total_out
expr_stmt|;
if|if
condition|(
name|deflateInit2
argument_list|(
name|strm
argument_list|,
name|level
argument_list|,
name|Z_DEFLATED
argument_list|,
operator|(
name|withheader
operator|)
condition|?
literal|15
else|:
operator|-
literal|15
argument_list|,
literal|8
argument_list|,
name|Z_DEFAULT_STRATEGY
argument_list|)
operator|!=
name|Z_OK
condition|)
block|{
name|free
argument_list|(
name|strm
argument_list|)
expr_stmt|;
name|lastrm
operator|->
name|real_stream
operator|=
name|NULL
expr_stmt|;
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Internal error initializing compression library"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|lastrm
operator|->
name|real_stream
operator|=
name|strm
expr_stmt|;
name|lastrm
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
name|lastrm
operator|->
name|code
operator|=
name|compression_code_gzip
expr_stmt|;
name|lastrm
operator|->
name|end
operator|=
name|compression_end_gzip
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|compression_code_gzip
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|la_zstream
modifier|*
name|lastrm
parameter_list|,
name|enum
name|la_zaction
name|action
parameter_list|)
block|{
name|z_stream
modifier|*
name|strm
decl_stmt|;
name|int
name|r
decl_stmt|;
name|strm
operator|=
operator|(
name|z_stream
operator|*
operator|)
name|lastrm
operator|->
name|real_stream
expr_stmt|;
comment|/* zlib.h is not const-correct, so we need this one bit 	 * of ugly hackery to convert a const * pointer to 	 * a non-const pointer. */
name|strm
operator|->
name|next_in
operator|=
operator|(
name|Bytef
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|(
specifier|const
name|void
operator|*
operator|)
name|lastrm
operator|->
name|next_in
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|=
name|lastrm
operator|->
name|avail_in
expr_stmt|;
name|strm
operator|->
name|total_in
operator|=
operator|(
name|uLong
operator|)
name|lastrm
operator|->
name|total_in
expr_stmt|;
name|strm
operator|->
name|next_out
operator|=
name|lastrm
operator|->
name|next_out
expr_stmt|;
name|strm
operator|->
name|avail_out
operator|=
name|lastrm
operator|->
name|avail_out
expr_stmt|;
name|strm
operator|->
name|total_out
operator|=
operator|(
name|uLong
operator|)
name|lastrm
operator|->
name|total_out
expr_stmt|;
name|r
operator|=
name|deflate
argument_list|(
name|strm
argument_list|,
operator|(
name|action
operator|==
name|ARCHIVE_Z_FINISH
operator|)
condition|?
name|Z_FINISH
else|:
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
name|lastrm
operator|->
name|next_in
operator|=
name|strm
operator|->
name|next_in
expr_stmt|;
name|lastrm
operator|->
name|avail_in
operator|=
name|strm
operator|->
name|avail_in
expr_stmt|;
name|lastrm
operator|->
name|total_in
operator|=
name|strm
operator|->
name|total_in
expr_stmt|;
name|lastrm
operator|->
name|next_out
operator|=
name|strm
operator|->
name|next_out
expr_stmt|;
name|lastrm
operator|->
name|avail_out
operator|=
name|strm
operator|->
name|avail_out
expr_stmt|;
name|lastrm
operator|->
name|total_out
operator|=
name|strm
operator|->
name|total_out
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|Z_OK
case|:
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
case|case
name|Z_STREAM_END
case|:
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
default|default:
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"GZip compression failed:"
literal|" deflate() call returned status %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|compression_end_gzip
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|la_zstream
modifier|*
name|lastrm
parameter_list|)
block|{
name|z_stream
modifier|*
name|strm
decl_stmt|;
name|int
name|r
decl_stmt|;
name|strm
operator|=
operator|(
name|z_stream
operator|*
operator|)
name|lastrm
operator|->
name|real_stream
expr_stmt|;
name|r
operator|=
name|deflateEnd
argument_list|(
name|strm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|strm
argument_list|)
expr_stmt|;
name|lastrm
operator|->
name|real_stream
operator|=
name|NULL
expr_stmt|;
name|lastrm
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|Z_OK
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Failed to clean up compressor"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_BZLIB_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|BZ_CONFIG_ERROR
argument_list|)
end_if

begin_function
specifier|static
name|int
name|compression_init_encoder_bzip2
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|la_zstream
modifier|*
name|lastrm
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|bz_stream
modifier|*
name|strm
decl_stmt|;
if|if
condition|(
name|lastrm
operator|->
name|valid
condition|)
name|compression_end
argument_list|(
name|a
argument_list|,
name|lastrm
argument_list|)
expr_stmt|;
name|strm
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|strm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strm
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for bzip2 stream"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* bzlib.h is not const-correct, so we need this one bit 	 * of ugly hackery to convert a const * pointer to 	 * a non-const pointer. */
name|strm
operator|->
name|next_in
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|(
specifier|const
name|void
operator|*
operator|)
name|lastrm
operator|->
name|next_in
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|=
name|lastrm
operator|->
name|avail_in
expr_stmt|;
name|strm
operator|->
name|total_in_lo32
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|lastrm
operator|->
name|total_in
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|strm
operator|->
name|total_in_hi32
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|lastrm
operator|->
name|total_in
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|strm
operator|->
name|next_out
operator|=
operator|(
name|char
operator|*
operator|)
name|lastrm
operator|->
name|next_out
expr_stmt|;
name|strm
operator|->
name|avail_out
operator|=
name|lastrm
operator|->
name|avail_out
expr_stmt|;
name|strm
operator|->
name|total_out_lo32
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|lastrm
operator|->
name|total_out
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|strm
operator|->
name|total_out_hi32
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|lastrm
operator|->
name|total_out
operator|>>
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|BZ2_bzCompressInit
argument_list|(
name|strm
argument_list|,
name|level
argument_list|,
literal|0
argument_list|,
literal|30
argument_list|)
operator|!=
name|BZ_OK
condition|)
block|{
name|free
argument_list|(
name|strm
argument_list|)
expr_stmt|;
name|lastrm
operator|->
name|real_stream
operator|=
name|NULL
expr_stmt|;
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Internal error initializing compression library"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|lastrm
operator|->
name|real_stream
operator|=
name|strm
expr_stmt|;
name|lastrm
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
name|lastrm
operator|->
name|code
operator|=
name|compression_code_bzip2
expr_stmt|;
name|lastrm
operator|->
name|end
operator|=
name|compression_end_bzip2
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|compression_code_bzip2
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|la_zstream
modifier|*
name|lastrm
parameter_list|,
name|enum
name|la_zaction
name|action
parameter_list|)
block|{
name|bz_stream
modifier|*
name|strm
decl_stmt|;
name|int
name|r
decl_stmt|;
name|strm
operator|=
operator|(
name|bz_stream
operator|*
operator|)
name|lastrm
operator|->
name|real_stream
expr_stmt|;
comment|/* bzlib.h is not const-correct, so we need this one bit 	 * of ugly hackery to convert a const * pointer to 	 * a non-const pointer. */
name|strm
operator|->
name|next_in
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|(
specifier|const
name|void
operator|*
operator|)
name|lastrm
operator|->
name|next_in
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|=
name|lastrm
operator|->
name|avail_in
expr_stmt|;
name|strm
operator|->
name|total_in_lo32
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|lastrm
operator|->
name|total_in
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|strm
operator|->
name|total_in_hi32
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|lastrm
operator|->
name|total_in
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|strm
operator|->
name|next_out
operator|=
operator|(
name|char
operator|*
operator|)
name|lastrm
operator|->
name|next_out
expr_stmt|;
name|strm
operator|->
name|avail_out
operator|=
name|lastrm
operator|->
name|avail_out
expr_stmt|;
name|strm
operator|->
name|total_out_lo32
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|lastrm
operator|->
name|total_out
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|strm
operator|->
name|total_out_hi32
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|lastrm
operator|->
name|total_out
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|r
operator|=
name|BZ2_bzCompress
argument_list|(
name|strm
argument_list|,
operator|(
name|action
operator|==
name|ARCHIVE_Z_FINISH
operator|)
condition|?
name|BZ_FINISH
else|:
name|BZ_RUN
argument_list|)
expr_stmt|;
name|lastrm
operator|->
name|next_in
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|strm
operator|->
name|next_in
expr_stmt|;
name|lastrm
operator|->
name|avail_in
operator|=
name|strm
operator|->
name|avail_in
expr_stmt|;
name|lastrm
operator|->
name|total_in
operator|=
operator|(
operator|(
operator|(
name|uint64_t
operator|)
operator|(
name|uint32_t
operator|)
name|strm
operator|->
name|total_in_hi32
operator|)
operator|<<
literal|32
operator|)
operator|+
operator|(
name|uint64_t
operator|)
operator|(
name|uint32_t
operator|)
name|strm
operator|->
name|total_in_lo32
expr_stmt|;
name|lastrm
operator|->
name|next_out
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|strm
operator|->
name|next_out
expr_stmt|;
name|lastrm
operator|->
name|avail_out
operator|=
name|strm
operator|->
name|avail_out
expr_stmt|;
name|lastrm
operator|->
name|total_out
operator|=
operator|(
operator|(
operator|(
name|uint64_t
operator|)
operator|(
name|uint32_t
operator|)
name|strm
operator|->
name|total_out_hi32
operator|)
operator|<<
literal|32
operator|)
operator|+
operator|(
name|uint64_t
operator|)
operator|(
name|uint32_t
operator|)
name|strm
operator|->
name|total_out_lo32
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|BZ_RUN_OK
case|:
comment|/* Non-finishing */
case|case
name|BZ_FINISH_OK
case|:
comment|/* Finishing: There's more work to do */
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
case|case
name|BZ_STREAM_END
case|:
comment|/* Finishing: all done */
comment|/* Only occurs in finishing case */
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
default|default:
comment|/* Any other return value indicates an error */
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Bzip2 compression failed:"
literal|" BZ2_bzCompress() call returned status %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|compression_end_bzip2
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|la_zstream
modifier|*
name|lastrm
parameter_list|)
block|{
name|bz_stream
modifier|*
name|strm
decl_stmt|;
name|int
name|r
decl_stmt|;
name|strm
operator|=
operator|(
name|bz_stream
operator|*
operator|)
name|lastrm
operator|->
name|real_stream
expr_stmt|;
name|r
operator|=
name|BZ2_bzCompressEnd
argument_list|(
name|strm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|strm
argument_list|)
expr_stmt|;
name|lastrm
operator|->
name|real_stream
operator|=
name|NULL
expr_stmt|;
name|lastrm
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|BZ_OK
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Failed to clean up compressor"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|compression_init_encoder_bzip2
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|la_zstream
modifier|*
name|lastrm
parameter_list|,
name|int
name|level
parameter_list|)
block|{
operator|(
name|void
operator|)
name|level
expr_stmt|;
comment|/* UNUSED */
if|if
condition|(
name|lastrm
operator|->
name|valid
condition|)
name|compression_end
argument_list|(
name|a
argument_list|,
name|lastrm
argument_list|)
expr_stmt|;
return|return
operator|(
name|compression_unsupported_encoder
argument_list|(
name|a
argument_list|,
name|lastrm
argument_list|,
literal|"bzip2"
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LZMA_H
argument_list|)
end_if

begin_function
specifier|static
name|int
name|compression_init_encoder_lzma
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|la_zstream
modifier|*
name|lastrm
parameter_list|,
name|int
name|level
parameter_list|)
block|{
specifier|static
specifier|const
name|lzma_stream
name|lzma_init_data
init|=
name|LZMA_STREAM_INIT
decl_stmt|;
name|lzma_stream
modifier|*
name|strm
decl_stmt|;
name|lzma_options_lzma
name|lzma_opt
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|lastrm
operator|->
name|valid
condition|)
name|compression_end
argument_list|(
name|a
argument_list|,
name|lastrm
argument_list|)
expr_stmt|;
if|if
condition|(
name|lzma_lzma_preset
argument_list|(
operator|&
name|lzma_opt
argument_list|,
name|level
argument_list|)
condition|)
block|{
name|lastrm
operator|->
name|real_stream
operator|=
name|NULL
expr_stmt|;
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ENOMEM
argument_list|,
literal|"Internal error initializing compression library"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|strm
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|strm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strm
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for lzma stream"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
operator|*
name|strm
operator|=
name|lzma_init_data
expr_stmt|;
name|r
operator|=
name|lzma_alone_encoder
argument_list|(
name|strm
argument_list|,
operator|&
name|lzma_opt
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|LZMA_OK
case|:
name|lastrm
operator|->
name|real_stream
operator|=
name|strm
expr_stmt|;
name|lastrm
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
name|lastrm
operator|->
name|code
operator|=
name|compression_code_lzma
expr_stmt|;
name|lastrm
operator|->
name|end
operator|=
name|compression_end_lzma
expr_stmt|;
name|r
operator|=
name|ARCHIVE_OK
expr_stmt|;
break|break;
case|case
name|LZMA_MEM_ERROR
case|:
name|free
argument_list|(
name|strm
argument_list|)
expr_stmt|;
name|lastrm
operator|->
name|real_stream
operator|=
name|NULL
expr_stmt|;
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ENOMEM
argument_list|,
literal|"Internal error initializing compression library: "
literal|"Cannot allocate memory"
argument_list|)
expr_stmt|;
name|r
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
break|break;
default|default:
name|free
argument_list|(
name|strm
argument_list|)
expr_stmt|;
name|lastrm
operator|->
name|real_stream
operator|=
name|NULL
expr_stmt|;
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Internal error initializing compression library: "
literal|"It's a bug in liblzma"
argument_list|)
expr_stmt|;
name|r
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|compression_init_encoder_xz
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|la_zstream
modifier|*
name|lastrm
parameter_list|,
name|int
name|level
parameter_list|)
block|{
specifier|static
specifier|const
name|lzma_stream
name|lzma_init_data
init|=
name|LZMA_STREAM_INIT
decl_stmt|;
name|lzma_stream
modifier|*
name|strm
decl_stmt|;
name|lzma_filter
modifier|*
name|lzmafilters
decl_stmt|;
name|lzma_options_lzma
name|lzma_opt
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|lastrm
operator|->
name|valid
condition|)
name|compression_end
argument_list|(
name|a
argument_list|,
name|lastrm
argument_list|)
expr_stmt|;
name|strm
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|strm
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|lzmafilters
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|strm
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for xz stream"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|lzmafilters
operator|=
operator|(
name|lzma_filter
operator|*
operator|)
operator|(
name|strm
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|level
operator|>
literal|6
condition|)
name|level
operator|=
literal|6
expr_stmt|;
if|if
condition|(
name|lzma_lzma_preset
argument_list|(
operator|&
name|lzma_opt
argument_list|,
name|level
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|strm
argument_list|)
expr_stmt|;
name|lastrm
operator|->
name|real_stream
operator|=
name|NULL
expr_stmt|;
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ENOMEM
argument_list|,
literal|"Internal error initializing compression library"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|lzmafilters
index|[
literal|0
index|]
operator|.
name|id
operator|=
name|LZMA_FILTER_LZMA2
expr_stmt|;
name|lzmafilters
index|[
literal|0
index|]
operator|.
name|options
operator|=
operator|&
name|lzma_opt
expr_stmt|;
name|lzmafilters
index|[
literal|1
index|]
operator|.
name|id
operator|=
name|LZMA_VLI_UNKNOWN
expr_stmt|;
comment|/* Terminate */
operator|*
name|strm
operator|=
name|lzma_init_data
expr_stmt|;
name|r
operator|=
name|lzma_stream_encoder
argument_list|(
name|strm
argument_list|,
name|lzmafilters
argument_list|,
name|LZMA_CHECK_CRC64
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|LZMA_OK
case|:
name|lastrm
operator|->
name|real_stream
operator|=
name|strm
expr_stmt|;
name|lastrm
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
name|lastrm
operator|->
name|code
operator|=
name|compression_code_lzma
expr_stmt|;
name|lastrm
operator|->
name|end
operator|=
name|compression_end_lzma
expr_stmt|;
name|r
operator|=
name|ARCHIVE_OK
expr_stmt|;
break|break;
case|case
name|LZMA_MEM_ERROR
case|:
name|free
argument_list|(
name|strm
argument_list|)
expr_stmt|;
name|lastrm
operator|->
name|real_stream
operator|=
name|NULL
expr_stmt|;
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ENOMEM
argument_list|,
literal|"Internal error initializing compression library: "
literal|"Cannot allocate memory"
argument_list|)
expr_stmt|;
name|r
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
break|break;
default|default:
name|free
argument_list|(
name|strm
argument_list|)
expr_stmt|;
name|lastrm
operator|->
name|real_stream
operator|=
name|NULL
expr_stmt|;
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Internal error initializing compression library: "
literal|"It's a bug in liblzma"
argument_list|)
expr_stmt|;
name|r
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|compression_code_lzma
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|la_zstream
modifier|*
name|lastrm
parameter_list|,
name|enum
name|la_zaction
name|action
parameter_list|)
block|{
name|lzma_stream
modifier|*
name|strm
decl_stmt|;
name|int
name|r
decl_stmt|;
name|strm
operator|=
operator|(
name|lzma_stream
operator|*
operator|)
name|lastrm
operator|->
name|real_stream
expr_stmt|;
name|strm
operator|->
name|next_in
operator|=
name|lastrm
operator|->
name|next_in
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|=
name|lastrm
operator|->
name|avail_in
expr_stmt|;
name|strm
operator|->
name|total_in
operator|=
name|lastrm
operator|->
name|total_in
expr_stmt|;
name|strm
operator|->
name|next_out
operator|=
name|lastrm
operator|->
name|next_out
expr_stmt|;
name|strm
operator|->
name|avail_out
operator|=
name|lastrm
operator|->
name|avail_out
expr_stmt|;
name|strm
operator|->
name|total_out
operator|=
name|lastrm
operator|->
name|total_out
expr_stmt|;
name|r
operator|=
name|lzma_code
argument_list|(
name|strm
argument_list|,
operator|(
name|action
operator|==
name|ARCHIVE_Z_FINISH
operator|)
condition|?
name|LZMA_FINISH
else|:
name|LZMA_RUN
argument_list|)
expr_stmt|;
name|lastrm
operator|->
name|next_in
operator|=
name|strm
operator|->
name|next_in
expr_stmt|;
name|lastrm
operator|->
name|avail_in
operator|=
name|strm
operator|->
name|avail_in
expr_stmt|;
name|lastrm
operator|->
name|total_in
operator|=
name|strm
operator|->
name|total_in
expr_stmt|;
name|lastrm
operator|->
name|next_out
operator|=
name|strm
operator|->
name|next_out
expr_stmt|;
name|lastrm
operator|->
name|avail_out
operator|=
name|strm
operator|->
name|avail_out
expr_stmt|;
name|lastrm
operator|->
name|total_out
operator|=
name|strm
operator|->
name|total_out
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|LZMA_OK
case|:
comment|/* Non-finishing case */
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
case|case
name|LZMA_STREAM_END
case|:
comment|/* This return can only occur in finishing case. */
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
case|case
name|LZMA_MEMLIMIT_ERROR
case|:
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ENOMEM
argument_list|,
literal|"lzma compression error:"
literal|" %ju MiB would have been needed"
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
operator|(
name|lzma_memusage
argument_list|(
name|strm
argument_list|)
operator|+
literal|1024
operator|*
literal|1024
operator|-
literal|1
operator|)
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
default|default:
comment|/* Any other return value indicates an error */
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"lzma compression failed:"
literal|" lzma_code() call returned status %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|compression_end_lzma
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|la_zstream
modifier|*
name|lastrm
parameter_list|)
block|{
name|lzma_stream
modifier|*
name|strm
decl_stmt|;
operator|(
name|void
operator|)
name|a
expr_stmt|;
comment|/* UNUSED */
name|strm
operator|=
operator|(
name|lzma_stream
operator|*
operator|)
name|lastrm
operator|->
name|real_stream
expr_stmt|;
name|lzma_end
argument_list|(
name|strm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|strm
argument_list|)
expr_stmt|;
name|lastrm
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
name|lastrm
operator|->
name|real_stream
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|compression_init_encoder_lzma
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|la_zstream
modifier|*
name|lastrm
parameter_list|,
name|int
name|level
parameter_list|)
block|{
operator|(
name|void
operator|)
name|level
expr_stmt|;
comment|/* UNUSED */
if|if
condition|(
name|lastrm
operator|->
name|valid
condition|)
name|compression_end
argument_list|(
name|a
argument_list|,
name|lastrm
argument_list|)
expr_stmt|;
return|return
operator|(
name|compression_unsupported_encoder
argument_list|(
name|a
argument_list|,
name|lastrm
argument_list|,
literal|"lzma"
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|compression_init_encoder_xz
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|la_zstream
modifier|*
name|lastrm
parameter_list|,
name|int
name|level
parameter_list|)
block|{
operator|(
name|void
operator|)
name|level
expr_stmt|;
comment|/* UNUSED */
if|if
condition|(
name|lastrm
operator|->
name|valid
condition|)
name|compression_end
argument_list|(
name|a
argument_list|,
name|lastrm
argument_list|)
expr_stmt|;
return|return
operator|(
name|compression_unsupported_encoder
argument_list|(
name|a
argument_list|,
name|lastrm
argument_list|,
literal|"xz"
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|xar_compression_init_encoder
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
name|int
name|r
decl_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
name|a
operator|->
name|format_data
expr_stmt|;
switch|switch
condition|(
name|xar
operator|->
name|opt_compression
condition|)
block|{
case|case
name|GZIP
case|:
name|r
operator|=
name|compression_init_encoder_gzip
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
operator|&
operator|(
name|xar
operator|->
name|stream
operator|)
argument_list|,
name|xar
operator|->
name|opt_compression_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|BZIP2
case|:
name|r
operator|=
name|compression_init_encoder_bzip2
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
operator|&
operator|(
name|xar
operator|->
name|stream
operator|)
argument_list|,
name|xar
operator|->
name|opt_compression_level
argument_list|)
expr_stmt|;
break|break;
case|case
name|LZMA
case|:
name|r
operator|=
name|compression_init_encoder_lzma
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
operator|&
operator|(
name|xar
operator|->
name|stream
operator|)
argument_list|,
name|xar
operator|->
name|opt_compression_level
argument_list|)
expr_stmt|;
break|break;
case|case
name|XZ
case|:
name|r
operator|=
name|compression_init_encoder_xz
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
operator|&
operator|(
name|xar
operator|->
name|stream
operator|)
argument_list|,
name|xar
operator|->
name|opt_compression_level
argument_list|)
expr_stmt|;
break|break;
default|default:
name|r
operator|=
name|ARCHIVE_OK
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|r
operator|==
name|ARCHIVE_OK
condition|)
block|{
name|xar
operator|->
name|stream
operator|.
name|total_in
operator|=
literal|0
expr_stmt|;
name|xar
operator|->
name|stream
operator|.
name|next_out
operator|=
name|xar
operator|->
name|wbuff
expr_stmt|;
name|xar
operator|->
name|stream
operator|.
name|avail_out
operator|=
sizeof|sizeof
argument_list|(
name|xar
operator|->
name|wbuff
argument_list|)
expr_stmt|;
name|xar
operator|->
name|stream
operator|.
name|total_out
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|compression_code
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|la_zstream
modifier|*
name|lastrm
parameter_list|,
name|enum
name|la_zaction
name|action
parameter_list|)
block|{
if|if
condition|(
name|lastrm
operator|->
name|valid
condition|)
return|return
operator|(
name|lastrm
operator|->
name|code
argument_list|(
name|a
argument_list|,
name|lastrm
argument_list|,
name|action
argument_list|)
operator|)
return|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|compression_end
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|la_zstream
modifier|*
name|lastrm
parameter_list|)
block|{
if|if
condition|(
name|lastrm
operator|->
name|valid
condition|)
return|return
operator|(
name|lastrm
operator|->
name|end
argument_list|(
name|a
argument_list|,
name|lastrm
argument_list|)
operator|)
return|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|save_xattrs
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|xar
modifier|*
name|xar
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|void
modifier|*
name|value
decl_stmt|;
name|struct
name|heap_data
modifier|*
name|heap
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|count
decl_stmt|,
name|r
decl_stmt|;
name|xar
operator|=
operator|(
expr|struct
name|xar
operator|*
operator|)
name|a
operator|->
name|format_data
expr_stmt|;
name|count
operator|=
name|archive_entry_xattr_reset
argument_list|(
name|file
operator|->
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
name|archive_entry_xattr_next
argument_list|(
name|file
operator|->
name|entry
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|checksum_init
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|a_sumwrk
operator|)
argument_list|,
name|xar
operator|->
name|opt_sumalg
argument_list|)
expr_stmt|;
name|checksum_init
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|e_sumwrk
operator|)
argument_list|,
name|xar
operator|->
name|opt_sumalg
argument_list|)
expr_stmt|;
name|heap
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|heap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|heap
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for xattr"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|heap
operator|->
name|id
operator|=
name|file
operator|->
name|ea_idx
operator|++
expr_stmt|;
name|heap
operator|->
name|temp_offset
operator|=
name|xar
operator|->
name|temp_offset
expr_stmt|;
name|heap
operator|->
name|size
operator|=
name|size
expr_stmt|;
comment|/* save a extracted size */
name|heap
operator|->
name|compression
operator|=
name|xar
operator|->
name|opt_compression
expr_stmt|;
comment|/* Get a extracted sumcheck value. */
name|checksum_update
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|e_sumwrk
operator|)
argument_list|,
name|value
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|checksum_final
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|e_sumwrk
operator|)
argument_list|,
operator|&
operator|(
name|heap
operator|->
name|e_sum
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Not compression to xattr is simple way. 		 */
if|if
condition|(
name|heap
operator|->
name|compression
operator|==
name|NONE
condition|)
block|{
name|checksum_update
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|a_sumwrk
operator|)
argument_list|,
name|value
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|checksum_final
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|a_sumwrk
operator|)
argument_list|,
operator|&
operator|(
name|heap
operator|->
name|a_sum
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_to_temp
argument_list|(
name|a
argument_list|,
name|value
argument_list|,
name|size
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|free
argument_list|(
name|heap
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|heap
operator|->
name|length
operator|=
name|size
expr_stmt|;
comment|/* Add heap to the tail of file->xattr. */
name|heap
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|file
operator|->
name|xattr
operator|.
name|last
operator|=
name|heap
expr_stmt|;
name|file
operator|->
name|xattr
operator|.
name|last
operator|=
operator|&
operator|(
name|heap
operator|->
name|next
operator|)
expr_stmt|;
comment|/* Next xattr */
continue|continue;
block|}
comment|/* 		 * Init compression library. 		 */
name|r
operator|=
name|xar_compression_init_encoder
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|free
argument_list|(
name|heap
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|xar
operator|->
name|stream
operator|.
name|next_in
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|value
expr_stmt|;
name|xar
operator|->
name|stream
operator|.
name|avail_in
operator|=
name|size
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|r
operator|=
name|compression_code
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
operator|&
operator|(
name|xar
operator|->
name|stream
operator|)
argument_list|,
name|ARCHIVE_Z_FINISH
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
operator|&&
name|r
operator|!=
name|ARCHIVE_EOF
condition|)
block|{
name|free
argument_list|(
name|heap
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|size
operator|=
sizeof|sizeof
argument_list|(
name|xar
operator|->
name|wbuff
argument_list|)
operator|-
name|xar
operator|->
name|stream
operator|.
name|avail_out
expr_stmt|;
name|checksum_update
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|a_sumwrk
operator|)
argument_list|,
name|xar
operator|->
name|wbuff
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_to_temp
argument_list|(
name|a
argument_list|,
name|xar
operator|->
name|wbuff
argument_list|,
name|size
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_OK
condition|)
block|{
name|xar
operator|->
name|stream
operator|.
name|next_out
operator|=
name|xar
operator|->
name|wbuff
expr_stmt|;
name|xar
operator|->
name|stream
operator|.
name|avail_out
operator|=
sizeof|sizeof
argument_list|(
name|xar
operator|->
name|wbuff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|checksum_final
argument_list|(
operator|&
operator|(
name|xar
operator|->
name|a_sumwrk
operator|)
argument_list|,
operator|&
operator|(
name|heap
operator|->
name|a_sum
operator|)
argument_list|)
expr_stmt|;
name|heap
operator|->
name|length
operator|=
name|xar
operator|->
name|stream
operator|.
name|total_out
expr_stmt|;
comment|/* Add heap to the tail of file->xattr. */
name|heap
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|file
operator|->
name|xattr
operator|.
name|last
operator|=
name|heap
expr_stmt|;
name|file
operator|->
name|xattr
operator|.
name|last
operator|=
operator|&
operator|(
name|heap
operator|->
name|next
operator|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Clean up compression library. */
name|r
operator|=
name|compression_end
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
operator|&
operator|(
name|xar
operator|->
name|stream
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getalgsize
parameter_list|(
name|enum
name|sumalg
name|sumalg
parameter_list|)
block|{
switch|switch
condition|(
name|sumalg
condition|)
block|{
default|default:
case|case
name|CKSUM_NONE
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CKSUM_SHA1
case|:
return|return
operator|(
name|SHA1_SIZE
operator|)
return|;
case|case
name|CKSUM_MD5
case|:
return|return
operator|(
name|MD5_SIZE
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|getalgname
parameter_list|(
name|enum
name|sumalg
name|sumalg
parameter_list|)
block|{
switch|switch
condition|(
name|sumalg
condition|)
block|{
default|default:
case|case
name|CKSUM_NONE
case|:
return|return
operator|(
name|NULL
operator|)
return|;
case|case
name|CKSUM_SHA1
case|:
return|return
operator|(
name|SHA1_NAME
operator|)
return|;
case|case
name|CKSUM_MD5
case|:
return|return
operator|(
name|MD5_NAME
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Support xar format */
end_comment

end_unit

