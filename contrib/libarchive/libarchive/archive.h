begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2010 Tim Kientzle  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ARCHIVE_H_INCLUDED
end_ifndef

begin_define
define|#
directive|define
name|ARCHIVE_H_INCLUDED
end_define

begin_comment
comment|/*  * The version number is expressed as a single integer that makes it  * easy to compare versions at build time: for version a.b.c, the  * version number is printf("%d%03d%03d",a,b,c).  For example, if you  * know your application requires version 2.12.108 or later, you can  * assert that ARCHIVE_VERSION_NUMBER>= 2012108.  */
end_comment

begin_comment
comment|/* Note: Compiler will complain if this does not match archive_entry.h! */
end_comment

begin_define
define|#
directive|define
name|ARCHIVE_VERSION_NUMBER
value|3002002
end_define

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_comment
comment|/* for wchar_t */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* For FILE * */
end_comment

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_comment
comment|/* For time_t */
end_comment

begin_comment
comment|/*  * Note: archive.h is for use outside of libarchive; the configuration  * headers (config.h, archive_platform.h, etc.) are purely internal.  * Do NOT use HAVE_XXX configuration macros to control the behavior of  * this header!  If you must conditionalize, use predefined compiler and/or  * platform macros.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
operator|&&
name|__BORLANDC__
operator|>=
literal|0x560
end_if

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_elif
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|__WATCOMC__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__INTERIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_SCO_DS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__osf__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Get appropriate definitions of 64-bit integer */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__LA_INT64_T_DEFINED
argument_list|)
end_if

begin_comment
comment|/* Older code relied on the __LA_INT64_T macro; after 4.0 we'll switch to the typedef exclusively. */
end_comment

begin_if
if|#
directive|if
name|ARCHIVE_VERSION_NUMBER
operator|<
literal|4000000
end_if

begin_define
define|#
directive|define
name|__LA_INT64_T
value|la_int64_t
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|__LA_INT64_T_DEFINED
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__WATCOMC__
argument_list|)
end_if

begin_typedef
typedef|typedef
name|__int64
name|la_int64_t
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* ssize_t */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_SCO_DS
argument_list|)
operator|||
name|defined
argument_list|(
name|__osf__
argument_list|)
end_if

begin_typedef
typedef|typedef
name|long
name|long
name|la_int64_t
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|int64_t
name|la_int64_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The la_ssize_t should match the type used in 'struct stat' */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__LA_SSIZE_T_DEFINED
argument_list|)
end_if

begin_comment
comment|/* Older code relied on the __LA_SSIZE_T macro; after 4.0 we'll switch to the typedef exclusively. */
end_comment

begin_if
if|#
directive|if
name|ARCHIVE_VERSION_NUMBER
operator|<
literal|4000000
end_if

begin_define
define|#
directive|define
name|__LA_SSIZE_T
value|la_ssize_t
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|__LA_SSIZE_T_DEFINED
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__WATCOMC__
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_SSIZE_T_DEFINED
argument_list|)
operator|||
name|defined
argument_list|(
name|_SSIZE_T_
argument_list|)
end_if

begin_typedef
typedef|typedef
name|ssize_t
name|la_ssize_t
typedef|;
end_typedef

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_WIN64
argument_list|)
end_elif

begin_typedef
typedef|typedef
name|__int64
name|la_ssize_t
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|long
name|la_ssize_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* ssize_t */
end_comment

begin_typedef
typedef|typedef
name|ssize_t
name|la_ssize_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Large file support for Android */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__ANDROID__
end_ifdef

begin_include
include|#
directive|include
file|"android_lf.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * On Windows, define LIBARCHIVE_STATIC if you're building or using a  * .lib.  The default here assumes you're building a DLL.  Only  * libarchive source should ever define __LIBARCHIVE_BUILD.  */
end_comment

begin_if
if|#
directive|if
operator|(
operator|(
name|defined
name|__WIN32__
operator|)
operator|||
operator|(
name|defined
name|_WIN32
operator|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|defined
name|LIBARCHIVE_STATIC
operator|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|__LIBARCHIVE_BUILD
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|__LA_DECL
value|__attribute__((dllexport)) extern
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|__LA_DECL
value|__declspec(dllexport)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|__LA_DECL
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|__LA_DECL
value|__declspec(dllimport)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Static libraries or non-Windows needs no special declaration. */
end_comment

begin_define
define|#
directive|define
name|__LA_DECL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|__GNUC__
operator|>=
literal|3
operator|&&
operator|!
name|defined
argument_list|(
name|__MINGW32__
argument_list|)
end_if

begin_define
define|#
directive|define
name|__LA_PRINTF
parameter_list|(
name|fmtarg
parameter_list|,
name|firstvararg
parameter_list|)
define|\
value|__attribute__((__format__ (__printf__, fmtarg, firstvararg)))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|__LA_PRINTF
parameter_list|(
name|fmtarg
parameter_list|,
name|firstvararg
parameter_list|)
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|__GNUC__
operator|>=
literal|3
operator|&&
name|__GNUC_MINOR__
operator|>=
literal|1
end_if

begin_define
define|#
directive|define
name|__LA_DEPRECATED
value|__attribute__((deprecated))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|__LA_DEPRECATED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/*  * The version number is provided as both a macro and a function.  * The macro identifies the installed header; the function identifies  * the library version (which may not be the same if you're using a  * dynamically-linked version of the library).  Of course, if the  * header and library are very different, you should expect some  * strangeness.  Don't do that.  */
name|__LA_DECL
name|int
name|archive_version_number
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/*  * Textual name/version of the library, useful for version displays.  */
define|#
directive|define
name|ARCHIVE_VERSION_ONLY_STRING
value|"3.2.2"
define|#
directive|define
name|ARCHIVE_VERSION_STRING
value|"libarchive " ARCHIVE_VERSION_ONLY_STRING
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_version_string
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/*  * Detailed textual name/version of the library and its dependencies.  * This has the form:  *    "libarchive x.y.z zlib/a.b.c liblzma/d.e.f ... etc ..."  * the list of libraries described here will vary depending on how  * libarchive was compiled.  */
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_version_details
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/*  * Returns NULL if libarchive was compiled without the associated library.  * Otherwise, returns the version number that libarchive was compiled  * against.  */
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_zlib_version
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_liblzma_version
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_bzlib_version
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_liblz4_version
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Declare our basic types. */
struct_decl|struct
name|archive
struct_decl|;
struct_decl|struct
name|archive_entry
struct_decl|;
comment|/*  * Error codes: Use archive_errno() and archive_error_string()  * to retrieve details.  Unless specified otherwise, all functions  * that return 'int' use these codes.  */
define|#
directive|define
name|ARCHIVE_EOF
value|1
comment|/* Found end of archive. */
define|#
directive|define
name|ARCHIVE_OK
value|0
comment|/* Operation was successful. */
define|#
directive|define
name|ARCHIVE_RETRY
value|(-10)
comment|/* Retry might succeed. */
define|#
directive|define
name|ARCHIVE_WARN
value|(-20)
comment|/* Partial success. */
comment|/* For example, if write_header "fails", then you can't push data. */
define|#
directive|define
name|ARCHIVE_FAILED
value|(-25)
comment|/* Current operation cannot complete. */
comment|/* But if write_header is "fatal," then this archive is dead and useless. */
define|#
directive|define
name|ARCHIVE_FATAL
value|(-30)
comment|/* No more operations are possible. */
comment|/*  * As far as possible, archive_errno returns standard platform errno codes.  * Of course, the details vary by platform, so the actual definitions  * here are stored in "archive_platform.h".  The symbols are listed here  * for reference; as a rule, clients should not need to know the exact  * platform-dependent error code.  */
comment|/* Unrecognized or invalid file format. */
comment|/* #define	ARCHIVE_ERRNO_FILE_FORMAT */
comment|/* Illegal usage of the library. */
comment|/* #define	ARCHIVE_ERRNO_PROGRAMMER_ERROR */
comment|/* Unknown or unclassified error. */
comment|/* #define	ARCHIVE_ERRNO_MISC */
comment|/*  * Callbacks are invoked to automatically read/skip/write/open/close the  * archive. You can provide your own for complex tasks (like breaking  * archives across multiple tapes) or use standard ones built into the  * library.  */
comment|/* Returns pointer and size of next block of data from archive. */
typedef|typedef
name|la_ssize_t
name|archive_read_callback
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|void
modifier|*
name|_client_data
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|_buffer
parameter_list|)
function_decl|;
comment|/* Skips at most request bytes from archive and returns the skipped amount.  * This may skip fewer bytes than requested; it may even skip zero bytes.  * If you do skip fewer bytes than requested, libarchive will invoke your  * read callback and discard data as necessary to make up the full skip.  */
typedef|typedef
name|la_int64_t
name|archive_skip_callback
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|void
modifier|*
name|_client_data
parameter_list|,
name|la_int64_t
name|request
parameter_list|)
function_decl|;
comment|/* Seeks to specified location in the file and returns the position.  * Whence values are SEEK_SET, SEEK_CUR, SEEK_END from stdio.h.  * Return ARCHIVE_FATAL if the seek fails for any reason.  */
typedef|typedef
name|la_int64_t
name|archive_seek_callback
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|void
modifier|*
name|_client_data
parameter_list|,
name|la_int64_t
name|offset
parameter_list|,
name|int
name|whence
parameter_list|)
function_decl|;
comment|/* Returns size actually written, zero on EOF, -1 on error. */
typedef|typedef
name|la_ssize_t
name|archive_write_callback
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|void
modifier|*
name|_client_data
parameter_list|,
specifier|const
name|void
modifier|*
name|_buffer
parameter_list|,
name|size_t
name|_length
parameter_list|)
function_decl|;
typedef|typedef
name|int
name|archive_open_callback
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|void
modifier|*
name|_client_data
parameter_list|)
function_decl|;
typedef|typedef
name|int
name|archive_close_callback
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|void
modifier|*
name|_client_data
parameter_list|)
function_decl|;
comment|/* Switches from one client data object to the next/prev client data object.  * This is useful for reading from different data blocks such as a set of files  * that make up one large file.  */
typedef|typedef
name|int
name|archive_switch_callback
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|void
modifier|*
name|_client_data1
parameter_list|,
name|void
modifier|*
name|_client_data2
parameter_list|)
function_decl|;
comment|/*  * Returns a passphrase used for encryption or decryption, NULL on nothing  * to do and give it up.  */
typedef|typedef
specifier|const
name|char
modifier|*
name|archive_passphrase_callback
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|void
modifier|*
name|_client_data
parameter_list|)
function_decl|;
comment|/*  * Codes to identify various stream filters.  */
define|#
directive|define
name|ARCHIVE_FILTER_NONE
value|0
define|#
directive|define
name|ARCHIVE_FILTER_GZIP
value|1
define|#
directive|define
name|ARCHIVE_FILTER_BZIP2
value|2
define|#
directive|define
name|ARCHIVE_FILTER_COMPRESS
value|3
define|#
directive|define
name|ARCHIVE_FILTER_PROGRAM
value|4
define|#
directive|define
name|ARCHIVE_FILTER_LZMA
value|5
define|#
directive|define
name|ARCHIVE_FILTER_XZ
value|6
define|#
directive|define
name|ARCHIVE_FILTER_UU
value|7
define|#
directive|define
name|ARCHIVE_FILTER_RPM
value|8
define|#
directive|define
name|ARCHIVE_FILTER_LZIP
value|9
define|#
directive|define
name|ARCHIVE_FILTER_LRZIP
value|10
define|#
directive|define
name|ARCHIVE_FILTER_LZOP
value|11
define|#
directive|define
name|ARCHIVE_FILTER_GRZIP
value|12
define|#
directive|define
name|ARCHIVE_FILTER_LZ4
value|13
if|#
directive|if
name|ARCHIVE_VERSION_NUMBER
operator|<
literal|4000000
define|#
directive|define
name|ARCHIVE_COMPRESSION_NONE
value|ARCHIVE_FILTER_NONE
define|#
directive|define
name|ARCHIVE_COMPRESSION_GZIP
value|ARCHIVE_FILTER_GZIP
define|#
directive|define
name|ARCHIVE_COMPRESSION_BZIP2
value|ARCHIVE_FILTER_BZIP2
define|#
directive|define
name|ARCHIVE_COMPRESSION_COMPRESS
value|ARCHIVE_FILTER_COMPRESS
define|#
directive|define
name|ARCHIVE_COMPRESSION_PROGRAM
value|ARCHIVE_FILTER_PROGRAM
define|#
directive|define
name|ARCHIVE_COMPRESSION_LZMA
value|ARCHIVE_FILTER_LZMA
define|#
directive|define
name|ARCHIVE_COMPRESSION_XZ
value|ARCHIVE_FILTER_XZ
define|#
directive|define
name|ARCHIVE_COMPRESSION_UU
value|ARCHIVE_FILTER_UU
define|#
directive|define
name|ARCHIVE_COMPRESSION_RPM
value|ARCHIVE_FILTER_RPM
define|#
directive|define
name|ARCHIVE_COMPRESSION_LZIP
value|ARCHIVE_FILTER_LZIP
define|#
directive|define
name|ARCHIVE_COMPRESSION_LRZIP
value|ARCHIVE_FILTER_LRZIP
endif|#
directive|endif
comment|/*  * Codes returned by archive_format.  *  * Top 16 bits identifies the format family (e.g., "tar"); lower  * 16 bits indicate the variant.  This is updated by read_next_header.  * Note that the lower 16 bits will often vary from entry to entry.  * In some cases, this variation occurs as libarchive learns more about  * the archive (for example, later entries might utilize extensions that  * weren't necessary earlier in the archive; in this case, libarchive  * will change the format code to indicate the extended format that  * was used).  In other cases, it's because different tools have  * modified the archive and so different parts of the archive  * actually have slightly different formats.  (Both tar and cpio store  * format codes in each entry, so it is quite possible for each  * entry to be in a different format.)  */
define|#
directive|define
name|ARCHIVE_FORMAT_BASE_MASK
value|0xff0000
define|#
directive|define
name|ARCHIVE_FORMAT_CPIO
value|0x10000
define|#
directive|define
name|ARCHIVE_FORMAT_CPIO_POSIX
value|(ARCHIVE_FORMAT_CPIO | 1)
define|#
directive|define
name|ARCHIVE_FORMAT_CPIO_BIN_LE
value|(ARCHIVE_FORMAT_CPIO | 2)
define|#
directive|define
name|ARCHIVE_FORMAT_CPIO_BIN_BE
value|(ARCHIVE_FORMAT_CPIO | 3)
define|#
directive|define
name|ARCHIVE_FORMAT_CPIO_SVR4_NOCRC
value|(ARCHIVE_FORMAT_CPIO | 4)
define|#
directive|define
name|ARCHIVE_FORMAT_CPIO_SVR4_CRC
value|(ARCHIVE_FORMAT_CPIO | 5)
define|#
directive|define
name|ARCHIVE_FORMAT_CPIO_AFIO_LARGE
value|(ARCHIVE_FORMAT_CPIO | 6)
define|#
directive|define
name|ARCHIVE_FORMAT_SHAR
value|0x20000
define|#
directive|define
name|ARCHIVE_FORMAT_SHAR_BASE
value|(ARCHIVE_FORMAT_SHAR | 1)
define|#
directive|define
name|ARCHIVE_FORMAT_SHAR_DUMP
value|(ARCHIVE_FORMAT_SHAR | 2)
define|#
directive|define
name|ARCHIVE_FORMAT_TAR
value|0x30000
define|#
directive|define
name|ARCHIVE_FORMAT_TAR_USTAR
value|(ARCHIVE_FORMAT_TAR | 1)
define|#
directive|define
name|ARCHIVE_FORMAT_TAR_PAX_INTERCHANGE
value|(ARCHIVE_FORMAT_TAR | 2)
define|#
directive|define
name|ARCHIVE_FORMAT_TAR_PAX_RESTRICTED
value|(ARCHIVE_FORMAT_TAR | 3)
define|#
directive|define
name|ARCHIVE_FORMAT_TAR_GNUTAR
value|(ARCHIVE_FORMAT_TAR | 4)
define|#
directive|define
name|ARCHIVE_FORMAT_ISO9660
value|0x40000
define|#
directive|define
name|ARCHIVE_FORMAT_ISO9660_ROCKRIDGE
value|(ARCHIVE_FORMAT_ISO9660 | 1)
define|#
directive|define
name|ARCHIVE_FORMAT_ZIP
value|0x50000
define|#
directive|define
name|ARCHIVE_FORMAT_EMPTY
value|0x60000
define|#
directive|define
name|ARCHIVE_FORMAT_AR
value|0x70000
define|#
directive|define
name|ARCHIVE_FORMAT_AR_GNU
value|(ARCHIVE_FORMAT_AR | 1)
define|#
directive|define
name|ARCHIVE_FORMAT_AR_BSD
value|(ARCHIVE_FORMAT_AR | 2)
define|#
directive|define
name|ARCHIVE_FORMAT_MTREE
value|0x80000
define|#
directive|define
name|ARCHIVE_FORMAT_RAW
value|0x90000
define|#
directive|define
name|ARCHIVE_FORMAT_XAR
value|0xA0000
define|#
directive|define
name|ARCHIVE_FORMAT_LHA
value|0xB0000
define|#
directive|define
name|ARCHIVE_FORMAT_CAB
value|0xC0000
define|#
directive|define
name|ARCHIVE_FORMAT_RAR
value|0xD0000
define|#
directive|define
name|ARCHIVE_FORMAT_7ZIP
value|0xE0000
define|#
directive|define
name|ARCHIVE_FORMAT_WARC
value|0xF0000
comment|/*  * Codes returned by archive_read_format_capabilities().  *  * This list can be extended with values between 0 and 0xffff.  * The original purpose of this list was to let different archive  * format readers expose their general capabilities in terms of  * encryption.  */
define|#
directive|define
name|ARCHIVE_READ_FORMAT_CAPS_NONE
value|(0)
comment|/* no special capabilities */
define|#
directive|define
name|ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_DATA
value|(1<<0)
comment|/* reader can detect encrypted data */
define|#
directive|define
name|ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_METADATA
value|(1<<1)
comment|/* reader can detect encryptable metadata (pathname, mtime, etc.) */
comment|/*  * Codes returned by archive_read_has_encrypted_entries().  *  * In case the archive does not support encryption detection at all  * ARCHIVE_READ_FORMAT_ENCRYPTION_UNSUPPORTED is returned. If the reader  * for some other reason (e.g. not enough bytes read) cannot say if  * there are encrypted entries, ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW  * is returned.  */
define|#
directive|define
name|ARCHIVE_READ_FORMAT_ENCRYPTION_UNSUPPORTED
value|-2
define|#
directive|define
name|ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW
value|-1
comment|/*-  * Basic outline for reading an archive:  *   1) Ask archive_read_new for an archive reader object.  *   2) Update any global properties as appropriate.  *      In particular, you'll certainly want to call appropriate  *      archive_read_support_XXX functions.  *   3) Call archive_read_open_XXX to open the archive  *   4) Repeatedly call archive_read_next_header to get information about  *      successive archive entries.  Call archive_read_data to extract  *      data for entries of interest.  *   5) Call archive_read_finish to end processing.  */
name|__LA_DECL
name|struct
name|archive
modifier|*
name|archive_read_new
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/*  * The archive_read_support_XXX calls enable auto-detect for this  * archive handle.  They also link in the necessary support code.  * For example, if you don't want bzlib linked in, don't invoke  * support_compression_bzip2().  The "all" functions provide the  * obvious shorthand.  */
if|#
directive|if
name|ARCHIVE_VERSION_NUMBER
operator|<
literal|4000000
name|__LA_DECL
name|int
name|archive_read_support_compression_all
argument_list|(
expr|struct
name|archive
operator|*
argument_list|)
name|__LA_DEPRECATED
decl_stmt|;
name|__LA_DECL
name|int
name|archive_read_support_compression_bzip2
argument_list|(
expr|struct
name|archive
operator|*
argument_list|)
name|__LA_DEPRECATED
decl_stmt|;
name|__LA_DECL
name|int
name|archive_read_support_compression_compress
argument_list|(
expr|struct
name|archive
operator|*
argument_list|)
name|__LA_DEPRECATED
decl_stmt|;
name|__LA_DECL
name|int
name|archive_read_support_compression_gzip
argument_list|(
expr|struct
name|archive
operator|*
argument_list|)
name|__LA_DEPRECATED
decl_stmt|;
name|__LA_DECL
name|int
name|archive_read_support_compression_lzip
argument_list|(
expr|struct
name|archive
operator|*
argument_list|)
name|__LA_DEPRECATED
decl_stmt|;
name|__LA_DECL
name|int
name|archive_read_support_compression_lzma
argument_list|(
expr|struct
name|archive
operator|*
argument_list|)
name|__LA_DEPRECATED
decl_stmt|;
name|__LA_DECL
name|int
name|archive_read_support_compression_none
argument_list|(
expr|struct
name|archive
operator|*
argument_list|)
name|__LA_DEPRECATED
decl_stmt|;
name|__LA_DECL
name|int
name|archive_read_support_compression_program
argument_list|(
expr|struct
name|archive
operator|*
argument_list|,
specifier|const
name|char
operator|*
name|command
argument_list|)
name|__LA_DEPRECATED
decl_stmt|;
name|__LA_DECL
name|int
name|archive_read_support_compression_program_signature
argument_list|(
expr|struct
name|archive
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
specifier|const
name|void
operator|*
comment|/* match */
argument_list|,
name|size_t
argument_list|)
name|__LA_DEPRECATED
decl_stmt|;
name|__LA_DECL
name|int
name|archive_read_support_compression_rpm
argument_list|(
expr|struct
name|archive
operator|*
argument_list|)
name|__LA_DEPRECATED
decl_stmt|;
name|__LA_DECL
name|int
name|archive_read_support_compression_uu
argument_list|(
expr|struct
name|archive
operator|*
argument_list|)
name|__LA_DEPRECATED
decl_stmt|;
name|__LA_DECL
name|int
name|archive_read_support_compression_xz
argument_list|(
expr|struct
name|archive
operator|*
argument_list|)
name|__LA_DEPRECATED
decl_stmt|;
endif|#
directive|endif
name|__LA_DECL
name|int
name|archive_read_support_filter_all
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_support_filter_bzip2
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_support_filter_compress
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_support_filter_gzip
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_support_filter_grzip
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_support_filter_lrzip
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_support_filter_lz4
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_support_filter_lzip
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_support_filter_lzma
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_support_filter_lzop
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_support_filter_none
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_support_filter_program
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|command
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_support_filter_program_signature
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
comment|/* cmd */
parameter_list|,
specifier|const
name|void
modifier|*
comment|/* match */
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_support_filter_rpm
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_support_filter_uu
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_support_filter_xz
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_support_format_7zip
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_support_format_all
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_support_format_ar
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_support_format_by_code
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_support_format_cab
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_support_format_cpio
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_support_format_empty
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_support_format_gnutar
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_support_format_iso9660
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_support_format_lha
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_support_format_mtree
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_support_format_rar
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_support_format_raw
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_support_format_tar
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_support_format_warc
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_support_format_xar
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
comment|/* archive_read_support_format_zip() enables both streamable and seekable  * zip readers. */
name|__LA_DECL
name|int
name|archive_read_support_format_zip
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
comment|/* Reads Zip archives as stream from beginning to end.  Doesn't  * correctly handle SFX ZIP files or ZIP archives that have been modified  * in-place. */
name|__LA_DECL
name|int
name|archive_read_support_format_zip_streamable
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
comment|/* Reads starting from central directory; requires seekable input. */
name|__LA_DECL
name|int
name|archive_read_support_format_zip_seekable
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
comment|/* Functions to manually set the format and filters to be used. This is  * useful to bypass the bidding process when the format and filters to use  * is known in advance.  */
name|__LA_DECL
name|int
name|archive_read_set_format
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_append_filter
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_append_filter_program
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_append_filter_program_signature
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
comment|/* match */
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
comment|/* Set various callbacks. */
name|__LA_DECL
name|int
name|archive_read_set_open_callback
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|archive_open_callback
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_set_read_callback
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|archive_read_callback
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_set_seek_callback
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|archive_seek_callback
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_set_skip_callback
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|archive_skip_callback
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_set_close_callback
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|archive_close_callback
modifier|*
parameter_list|)
function_decl|;
comment|/* Callback used to switch between one data object to the next */
name|__LA_DECL
name|int
name|archive_read_set_switch_callback
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|archive_switch_callback
modifier|*
parameter_list|)
function_decl|;
comment|/* This sets the first data object. */
name|__LA_DECL
name|int
name|archive_read_set_callback_data
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/* This sets data object at specified index */
name|__LA_DECL
name|int
name|archive_read_set_callback_data2
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
comment|/* This adds a data object at the specified index. */
name|__LA_DECL
name|int
name|archive_read_add_callback_data
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
comment|/* This appends a data object to the end of list */
name|__LA_DECL
name|int
name|archive_read_append_callback_data
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/* This prepends a data object to the beginning of list */
name|__LA_DECL
name|int
name|archive_read_prepend_callback_data
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/* Opening freezes the callbacks. */
name|__LA_DECL
name|int
name|archive_read_open1
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
comment|/* Convenience wrappers around the above. */
name|__LA_DECL
name|int
name|archive_read_open
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|void
modifier|*
name|_client_data
parameter_list|,
name|archive_open_callback
modifier|*
parameter_list|,
name|archive_read_callback
modifier|*
parameter_list|,
name|archive_close_callback
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_open2
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|void
modifier|*
name|_client_data
parameter_list|,
name|archive_open_callback
modifier|*
parameter_list|,
name|archive_read_callback
modifier|*
parameter_list|,
name|archive_skip_callback
modifier|*
parameter_list|,
name|archive_close_callback
modifier|*
parameter_list|)
function_decl|;
comment|/*  * A variety of shortcuts that invoke archive_read_open() with  * canned callbacks suitable for common situations.  The ones that  * accept a block size handle tape blocking correctly.  */
comment|/* Use this if you know the filename.  Note: NULL indicates stdin. */
name|__LA_DECL
name|int
name|archive_read_open_filename
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|_filename
parameter_list|,
name|size_t
name|_block_size
parameter_list|)
function_decl|;
comment|/* Use this for reading multivolume files by filenames.  * NOTE: Must be NULL terminated. Sorting is NOT done. */
name|__LA_DECL
name|int
name|archive_read_open_filenames
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|_filenames
parameter_list|,
name|size_t
name|_block_size
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_open_filename_w
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|_filename
parameter_list|,
name|size_t
name|_block_size
parameter_list|)
function_decl|;
comment|/* archive_read_open_file() is a deprecated synonym for ..._open_filename(). */
name|__LA_DECL
name|int
name|archive_read_open_file
argument_list|(
expr|struct
name|archive
operator|*
argument_list|,
specifier|const
name|char
operator|*
name|_filename
argument_list|,
name|size_t
name|_block_size
argument_list|)
name|__LA_DEPRECATED
decl_stmt|;
comment|/* Read an archive that's stored in memory. */
name|__LA_DECL
name|int
name|archive_read_open_memory
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
comment|/* A more involved version that is only used for internal testing. */
name|__LA_DECL
name|int
name|archive_read_open_memory2
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|read_size
parameter_list|)
function_decl|;
comment|/* Read an archive that's already open, using the file descriptor. */
name|__LA_DECL
name|int
name|archive_read_open_fd
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
name|_fd
parameter_list|,
name|size_t
name|_block_size
parameter_list|)
function_decl|;
comment|/* Read an archive that's already open, using a FILE *. */
comment|/* Note: DO NOT use this with tape drives. */
name|__LA_DECL
name|int
name|archive_read_open_FILE
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|FILE
modifier|*
name|_file
parameter_list|)
function_decl|;
comment|/* Parses and returns next entry header. */
name|__LA_DECL
name|int
name|archive_read_next_header
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
modifier|*
parameter_list|)
function_decl|;
comment|/* Parses and returns next entry header using the archive_entry passed in */
name|__LA_DECL
name|int
name|archive_read_next_header2
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
comment|/*  * Retrieve the byte offset in UNCOMPRESSED data where last-read  * header started.  */
name|__LA_DECL
name|la_int64_t
name|archive_read_header_position
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
comment|/*  * Returns 1 if the archive contains at least one encrypted entry.  * If the archive format not support encryption at all  * ARCHIVE_READ_FORMAT_ENCRYPTION_UNSUPPORTED is returned.  * If for any other reason (e.g. not enough data read so far)  * we cannot say whether there are encrypted entries, then  * ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW is returned.  * In general, this function will return values below zero when the  * reader is uncertain or totally incapable of encryption support.  * When this function returns 0 you can be sure that the reader  * supports encryption detection but no encrypted entries have  * been found yet.  *  * NOTE: If the metadata/header of an archive is also encrypted, you  * cannot rely on the number of encrypted entries. That is why this  * function does not return the number of encrypted entries but#  * just shows that there are some.  */
name|__LA_DECL
name|int
name|archive_read_has_encrypted_entries
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
comment|/*  * Returns a bitmask of capabilities that are supported by the archive format reader.  * If the reader has no special capabilities, ARCHIVE_READ_FORMAT_CAPS_NONE is returned.  */
name|__LA_DECL
name|int
name|archive_read_format_capabilities
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
comment|/* Read data from the body of an entry.  Similar to read(2). */
name|__LA_DECL
name|la_ssize_t
name|archive_read_data
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
comment|/* Seek within the body of an entry.  Similar to lseek(2). */
name|__LA_DECL
name|la_int64_t
name|archive_seek_data
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|la_int64_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/*  * A zero-copy version of archive_read_data that also exposes the file offset  * of each returned block.  Note that the client has no way to specify  * the desired size of the block.  The API does guarantee that offsets will  * be strictly increasing and that returned blocks will not overlap.  */
name|__LA_DECL
name|int
name|archive_read_data_block
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|la_int64_t
modifier|*
name|offset
parameter_list|)
function_decl|;
comment|/*-  * Some convenience functions that are built on archive_read_data:  *  'skip': skips entire entry  *  'into_buffer': writes data into memory buffer that you provide  *  'into_fd': writes data to specified filedes  */
name|__LA_DECL
name|int
name|archive_read_data_skip
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_data_into_fd
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
name|fd
parameter_list|)
function_decl|;
comment|/*  * Set read options.  */
comment|/* Apply option to the format only. */
name|__LA_DECL
name|int
name|archive_read_set_format_option
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
specifier|const
name|char
modifier|*
name|m
parameter_list|,
specifier|const
name|char
modifier|*
name|o
parameter_list|,
specifier|const
name|char
modifier|*
name|v
parameter_list|)
function_decl|;
comment|/* Apply option to the filter only. */
name|__LA_DECL
name|int
name|archive_read_set_filter_option
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
specifier|const
name|char
modifier|*
name|m
parameter_list|,
specifier|const
name|char
modifier|*
name|o
parameter_list|,
specifier|const
name|char
modifier|*
name|v
parameter_list|)
function_decl|;
comment|/* Apply option to both the format and the filter. */
name|__LA_DECL
name|int
name|archive_read_set_option
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
specifier|const
name|char
modifier|*
name|m
parameter_list|,
specifier|const
name|char
modifier|*
name|o
parameter_list|,
specifier|const
name|char
modifier|*
name|v
parameter_list|)
function_decl|;
comment|/* Apply option string to both the format and the filter. */
name|__LA_DECL
name|int
name|archive_read_set_options
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
specifier|const
name|char
modifier|*
name|opts
parameter_list|)
function_decl|;
comment|/*  * Add a decryption passphrase.  */
name|__LA_DECL
name|int
name|archive_read_add_passphrase
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_set_passphrase_callback
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|void
modifier|*
name|client_data
parameter_list|,
name|archive_passphrase_callback
modifier|*
parameter_list|)
function_decl|;
comment|/*-  * Convenience function to recreate the current entry (whose header  * has just been read) on disk.  *  * This does quite a bit more than just copy data to disk. It also:  *  - Creates intermediate directories as required.  *  - Manages directory permissions:  non-writable directories will  *    be initially created with write permission enabled; when the  *    archive is closed, dir permissions are edited to the values specified  *    in the archive.  *  - Checks hardlinks:  hardlinks will not be extracted unless the  *    linked-to file was also extracted within the same session. (TODO)  */
comment|/* The "flags" argument selects optional behavior, 'OR' the flags you want. */
comment|/* Default: Do not try to set owner/group. */
define|#
directive|define
name|ARCHIVE_EXTRACT_OWNER
value|(0x0001)
comment|/* Default: Do obey umask, do not restore SUID/SGID/SVTX bits. */
define|#
directive|define
name|ARCHIVE_EXTRACT_PERM
value|(0x0002)
comment|/* Default: Do not restore mtime/atime. */
define|#
directive|define
name|ARCHIVE_EXTRACT_TIME
value|(0x0004)
comment|/* Default: Replace existing files. */
define|#
directive|define
name|ARCHIVE_EXTRACT_NO_OVERWRITE
value|(0x0008)
comment|/* Default: Try create first, unlink only if create fails with EEXIST. */
define|#
directive|define
name|ARCHIVE_EXTRACT_UNLINK
value|(0x0010)
comment|/* Default: Do not restore ACLs. */
define|#
directive|define
name|ARCHIVE_EXTRACT_ACL
value|(0x0020)
comment|/* Default: Do not restore fflags. */
define|#
directive|define
name|ARCHIVE_EXTRACT_FFLAGS
value|(0x0040)
comment|/* Default: Do not restore xattrs. */
define|#
directive|define
name|ARCHIVE_EXTRACT_XATTR
value|(0x0080)
comment|/* Default: Do not try to guard against extracts redirected by symlinks. */
comment|/* Note: With ARCHIVE_EXTRACT_UNLINK, will remove any intermediate symlink. */
define|#
directive|define
name|ARCHIVE_EXTRACT_SECURE_SYMLINKS
value|(0x0100)
comment|/* Default: Do not reject entries with '..' as path elements. */
define|#
directive|define
name|ARCHIVE_EXTRACT_SECURE_NODOTDOT
value|(0x0200)
comment|/* Default: Create parent directories as needed. */
define|#
directive|define
name|ARCHIVE_EXTRACT_NO_AUTODIR
value|(0x0400)
comment|/* Default: Overwrite files, even if one on disk is newer. */
define|#
directive|define
name|ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER
value|(0x0800)
comment|/* Detect blocks of 0 and write holes instead. */
define|#
directive|define
name|ARCHIVE_EXTRACT_SPARSE
value|(0x1000)
comment|/* Default: Do not restore Mac extended metadata. */
comment|/* This has no effect except on Mac OS. */
define|#
directive|define
name|ARCHIVE_EXTRACT_MAC_METADATA
value|(0x2000)
comment|/* Default: Use HFS+ compression if it was compressed. */
comment|/* This has no effect except on Mac OS v10.6 or later. */
define|#
directive|define
name|ARCHIVE_EXTRACT_NO_HFS_COMPRESSION
value|(0x4000)
comment|/* Default: Do not use HFS+ compression if it was not compressed. */
comment|/* This has no effect except on Mac OS v10.6 or later. */
define|#
directive|define
name|ARCHIVE_EXTRACT_HFS_COMPRESSION_FORCED
value|(0x8000)
comment|/* Default: Do not reject entries with absolute paths */
define|#
directive|define
name|ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS
value|(0x10000)
comment|/* Default: Do not clear no-change flags when unlinking object */
define|#
directive|define
name|ARCHIVE_EXTRACT_CLEAR_NOCHANGE_FFLAGS
value|(0x20000)
name|__LA_DECL
name|int
name|archive_read_extract
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_extract2
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|struct
name|archive
modifier|*
comment|/* dest */
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_read_extract_set_progress_callback
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|void
function_decl|(
modifier|*
name|_progress_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|_user_data
parameter_list|)
function_decl|;
comment|/* Record the dev/ino of a file that will not be written.  This is  * generally set to the dev/ino of the archive being read. */
name|__LA_DECL
name|void
name|archive_read_extract_set_skip_file
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|la_int64_t
parameter_list|,
name|la_int64_t
parameter_list|)
function_decl|;
comment|/* Close the file and release most resources. */
name|__LA_DECL
name|int
name|archive_read_close
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
comment|/* Release all resources and destroy the object. */
comment|/* Note that archive_read_free will call archive_read_close for you. */
name|__LA_DECL
name|int
name|archive_read_free
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
if|#
directive|if
name|ARCHIVE_VERSION_NUMBER
operator|<
literal|4000000
comment|/* Synonym for archive_read_free() for backwards compatibility. */
name|__LA_DECL
name|int
name|archive_read_finish
argument_list|(
expr|struct
name|archive
operator|*
argument_list|)
name|__LA_DEPRECATED
decl_stmt|;
endif|#
directive|endif
comment|/*-  * To create an archive:  *   1) Ask archive_write_new for an archive writer object.  *   2) Set any global properties.  In particular, you should set  *      the compression and format to use.  *   3) Call archive_write_open to open the file (most people  *       will use archive_write_open_file or archive_write_open_fd,  *       which provide convenient canned I/O callbacks for you).  *   4) For each entry:  *      - construct an appropriate struct archive_entry structure  *      - archive_write_header to write the header  *      - archive_write_data to write the entry data  *   5) archive_write_close to close the output  *   6) archive_write_free to cleanup the writer and release resources  */
name|__LA_DECL
name|struct
name|archive
modifier|*
name|archive_write_new
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_set_bytes_per_block
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
name|bytes_per_block
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_get_bytes_per_block
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
comment|/* XXX This is badly misnamed; suggestions appreciated. XXX */
name|__LA_DECL
name|int
name|archive_write_set_bytes_in_last_block
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
name|bytes_in_last_block
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_get_bytes_in_last_block
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
comment|/* The dev/ino of a file that won't be archived.  This is used  * to avoid recursively adding an archive to itself. */
name|__LA_DECL
name|int
name|archive_write_set_skip_file
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|la_int64_t
parameter_list|,
name|la_int64_t
parameter_list|)
function_decl|;
if|#
directive|if
name|ARCHIVE_VERSION_NUMBER
operator|<
literal|4000000
name|__LA_DECL
name|int
name|archive_write_set_compression_bzip2
argument_list|(
expr|struct
name|archive
operator|*
argument_list|)
name|__LA_DEPRECATED
decl_stmt|;
name|__LA_DECL
name|int
name|archive_write_set_compression_compress
argument_list|(
expr|struct
name|archive
operator|*
argument_list|)
name|__LA_DEPRECATED
decl_stmt|;
name|__LA_DECL
name|int
name|archive_write_set_compression_gzip
argument_list|(
expr|struct
name|archive
operator|*
argument_list|)
name|__LA_DEPRECATED
decl_stmt|;
name|__LA_DECL
name|int
name|archive_write_set_compression_lzip
argument_list|(
expr|struct
name|archive
operator|*
argument_list|)
name|__LA_DEPRECATED
decl_stmt|;
name|__LA_DECL
name|int
name|archive_write_set_compression_lzma
argument_list|(
expr|struct
name|archive
operator|*
argument_list|)
name|__LA_DEPRECATED
decl_stmt|;
name|__LA_DECL
name|int
name|archive_write_set_compression_none
argument_list|(
expr|struct
name|archive
operator|*
argument_list|)
name|__LA_DEPRECATED
decl_stmt|;
name|__LA_DECL
name|int
name|archive_write_set_compression_program
argument_list|(
expr|struct
name|archive
operator|*
argument_list|,
specifier|const
name|char
operator|*
name|cmd
argument_list|)
name|__LA_DEPRECATED
decl_stmt|;
name|__LA_DECL
name|int
name|archive_write_set_compression_xz
argument_list|(
expr|struct
name|archive
operator|*
argument_list|)
name|__LA_DEPRECATED
decl_stmt|;
endif|#
directive|endif
comment|/* A convenience function to set the filter based on the code. */
name|__LA_DECL
name|int
name|archive_write_add_filter
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
name|filter_code
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_add_filter_by_name
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_add_filter_b64encode
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_add_filter_bzip2
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_add_filter_compress
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_add_filter_grzip
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_add_filter_gzip
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_add_filter_lrzip
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_add_filter_lz4
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_add_filter_lzip
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_add_filter_lzma
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_add_filter_lzop
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_add_filter_none
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_add_filter_program
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|cmd
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_add_filter_uuencode
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_add_filter_xz
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
comment|/* A convenience function to set the format based on the code or name. */
name|__LA_DECL
name|int
name|archive_write_set_format
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
name|format_code
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_set_format_by_name
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
comment|/* To minimize link pollution, use one or more of the following. */
name|__LA_DECL
name|int
name|archive_write_set_format_7zip
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_set_format_ar_bsd
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_set_format_ar_svr4
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_set_format_cpio
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_set_format_cpio_newc
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_set_format_gnutar
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_set_format_iso9660
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_set_format_mtree
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_set_format_mtree_classic
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
comment|/* TODO: int archive_write_set_format_old_tar(struct archive *); */
name|__LA_DECL
name|int
name|archive_write_set_format_pax
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_set_format_pax_restricted
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_set_format_raw
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_set_format_shar
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_set_format_shar_dump
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_set_format_ustar
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_set_format_v7tar
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_set_format_warc
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_set_format_xar
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_set_format_zip
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_set_format_filter_by_ext
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_set_format_filter_by_ext_def
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|char
modifier|*
name|def_ext
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_zip_set_compression_deflate
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_zip_set_compression_store
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_open
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|archive_open_callback
modifier|*
parameter_list|,
name|archive_write_callback
modifier|*
parameter_list|,
name|archive_close_callback
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_open_fd
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
name|_fd
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_open_filename
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|_file
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_open_filename_w
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|_file
parameter_list|)
function_decl|;
comment|/* A deprecated synonym for archive_write_open_filename() */
name|__LA_DECL
name|int
name|archive_write_open_file
argument_list|(
expr|struct
name|archive
operator|*
argument_list|,
specifier|const
name|char
operator|*
name|_file
argument_list|)
name|__LA_DEPRECATED
decl_stmt|;
name|__LA_DECL
name|int
name|archive_write_open_FILE
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
comment|/* _buffSize is the size of the buffer, _used refers to a variable that  * will be updated after each write into the buffer. */
name|__LA_DECL
name|int
name|archive_write_open_memory
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|void
modifier|*
name|_buffer
parameter_list|,
name|size_t
name|_buffSize
parameter_list|,
name|size_t
modifier|*
name|_used
parameter_list|)
function_decl|;
comment|/*  * Note that the library will truncate writes beyond the size provided  * to archive_write_header or pad if the provided data is short.  */
name|__LA_DECL
name|int
name|archive_write_header
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|la_ssize_t
name|archive_write_data
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
comment|/* This interface is currently only available for archive_write_disk handles.  */
name|__LA_DECL
name|la_ssize_t
name|archive_write_data_block
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|la_int64_t
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_finish_entry
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_close
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
comment|/* Marks the archive as FATAL so that a subsequent free() operation  * won't try to close() cleanly.  Provides a fast abort capability  * when the client discovers that things have gone wrong. */
name|__LA_DECL
name|int
name|archive_write_fail
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
comment|/* This can fail if the archive wasn't already closed, in which case  * archive_write_free() will implicitly call archive_write_close(). */
name|__LA_DECL
name|int
name|archive_write_free
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
if|#
directive|if
name|ARCHIVE_VERSION_NUMBER
operator|<
literal|4000000
comment|/* Synonym for archive_write_free() for backwards compatibility. */
name|__LA_DECL
name|int
name|archive_write_finish
argument_list|(
expr|struct
name|archive
operator|*
argument_list|)
name|__LA_DEPRECATED
decl_stmt|;
endif|#
directive|endif
comment|/*  * Set write options.  */
comment|/* Apply option to the format only. */
name|__LA_DECL
name|int
name|archive_write_set_format_option
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
specifier|const
name|char
modifier|*
name|m
parameter_list|,
specifier|const
name|char
modifier|*
name|o
parameter_list|,
specifier|const
name|char
modifier|*
name|v
parameter_list|)
function_decl|;
comment|/* Apply option to the filter only. */
name|__LA_DECL
name|int
name|archive_write_set_filter_option
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
specifier|const
name|char
modifier|*
name|m
parameter_list|,
specifier|const
name|char
modifier|*
name|o
parameter_list|,
specifier|const
name|char
modifier|*
name|v
parameter_list|)
function_decl|;
comment|/* Apply option to both the format and the filter. */
name|__LA_DECL
name|int
name|archive_write_set_option
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
specifier|const
name|char
modifier|*
name|m
parameter_list|,
specifier|const
name|char
modifier|*
name|o
parameter_list|,
specifier|const
name|char
modifier|*
name|v
parameter_list|)
function_decl|;
comment|/* Apply option string to both the format and the filter. */
name|__LA_DECL
name|int
name|archive_write_set_options
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
specifier|const
name|char
modifier|*
name|opts
parameter_list|)
function_decl|;
comment|/*  * Set a encryption passphrase.  */
name|__LA_DECL
name|int
name|archive_write_set_passphrase
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_set_passphrase_callback
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|void
modifier|*
name|client_data
parameter_list|,
name|archive_passphrase_callback
modifier|*
parameter_list|)
function_decl|;
comment|/*-  * ARCHIVE_WRITE_DISK API  *  * To create objects on disk:  *   1) Ask archive_write_disk_new for a new archive_write_disk object.  *   2) Set any global properties.  In particular, you probably  *      want to set the options.  *   3) For each entry:  *      - construct an appropriate struct archive_entry structure  *      - archive_write_header to create the file/dir/etc on disk  *      - archive_write_data to write the entry data  *   4) archive_write_free to cleanup the writer and release resources  *  * In particular, you can use this in conjunction with archive_read()  * to pull entries out of an archive and create them on disk.  */
name|__LA_DECL
name|struct
name|archive
modifier|*
name|archive_write_disk_new
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* This file will not be overwritten. */
name|__LA_DECL
name|int
name|archive_write_disk_set_skip_file
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|la_int64_t
parameter_list|,
name|la_int64_t
parameter_list|)
function_decl|;
comment|/* Set flags to control how the next item gets created.  * This accepts a bitmask of ARCHIVE_EXTRACT_XXX flags defined above. */
name|__LA_DECL
name|int
name|archive_write_disk_set_options
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
comment|/*  * The lookup functions are given uname/uid (or gname/gid) pairs and  * return a uid (gid) suitable for this system.  These are used for  * restoring ownership and for setting ACLs.  The default functions  * are naive, they just return the uid/gid.  These are small, so reasonable  * for applications that don't need to preserve ownership; they  * are probably also appropriate for applications that are doing  * same-system backup and restore.  */
comment|/*  * The "standard" lookup functions use common system calls to lookup  * the uname/gname, falling back to the uid/gid if the names can't be  * found.  They cache lookups and are reasonably fast, but can be very  * large, so they are not used unless you ask for them.  In  * particular, these match the specifications of POSIX "pax" and old  * POSIX "tar".  */
name|__LA_DECL
name|int
name|archive_write_disk_set_standard_lookup
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
comment|/*  * If neither the default (naive) nor the standard (big) functions suit  * your needs, you can write your own and register them.  Be sure to  * include a cleanup function if you have allocated private data.  */
name|__LA_DECL
name|int
name|archive_write_disk_set_group_lookup
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|void
modifier|*
comment|/* private_data */
parameter_list|,
name|la_int64_t
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|la_int64_t
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
comment|/* cleanup */
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_write_disk_set_user_lookup
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|void
modifier|*
comment|/* private_data */
parameter_list|,
name|la_int64_t
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|la_int64_t
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
comment|/* cleanup */
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
name|__LA_DECL
name|la_int64_t
name|archive_write_disk_gid
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|la_int64_t
parameter_list|)
function_decl|;
name|__LA_DECL
name|la_int64_t
name|archive_write_disk_uid
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|la_int64_t
parameter_list|)
function_decl|;
comment|/*  * ARCHIVE_READ_DISK API  *  * This is still evolving and somewhat experimental.  */
name|__LA_DECL
name|struct
name|archive
modifier|*
name|archive_read_disk_new
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* The names for symlink modes here correspond to an old BSD  * command-line argument convention: -L, -P, -H */
comment|/* Follow all symlinks. */
name|__LA_DECL
name|int
name|archive_read_disk_set_symlink_logical
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
comment|/* Follow no symlinks. */
name|__LA_DECL
name|int
name|archive_read_disk_set_symlink_physical
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
comment|/* Follow symlink initially, then not. */
name|__LA_DECL
name|int
name|archive_read_disk_set_symlink_hybrid
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
comment|/* TODO: Handle Linux stat32/stat64 ugliness.<sigh> */
name|__LA_DECL
name|int
name|archive_read_disk_entry_from_file
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
comment|/* fd */
parameter_list|,
specifier|const
name|struct
name|stat
modifier|*
parameter_list|)
function_decl|;
comment|/* Look up gname for gid or uname for uid. */
comment|/* Default implementations are very, very stupid. */
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_read_disk_gname
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|la_int64_t
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_read_disk_uname
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|la_int64_t
parameter_list|)
function_decl|;
comment|/* "Standard" implementation uses getpwuid_r, getgrgid_r and caches the  * results for performance. */
name|__LA_DECL
name|int
name|archive_read_disk_set_standard_lookup
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
comment|/* You can install your own lookups if you like. */
name|__LA_DECL
name|int
name|archive_read_disk_set_gname_lookup
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|void
modifier|*
comment|/* private_data */
parameter_list|,
specifier|const
name|char
modifier|*
function_decl|(
modifier|*
comment|/* lookup_fn */
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|la_int64_t
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
comment|/* cleanup_fn */
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_disk_set_uname_lookup
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|void
modifier|*
comment|/* private_data */
parameter_list|,
specifier|const
name|char
modifier|*
function_decl|(
modifier|*
comment|/* lookup_fn */
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|la_int64_t
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
comment|/* cleanup_fn */
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
comment|/* Start traversal. */
name|__LA_DECL
name|int
name|archive_read_disk_open
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_disk_open_w
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|wchar_t
modifier|*
parameter_list|)
function_decl|;
comment|/*  * Request that current entry be visited.  If you invoke it on every  * directory, you'll get a physical traversal.  This is ignored if the  * current entry isn't a directory or a link to a directory.  So, if  * you invoke this on every returned path, you'll get a full logical  * traversal.  */
name|__LA_DECL
name|int
name|archive_read_disk_descend
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_disk_can_descend
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_disk_current_filesystem
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_disk_current_filesystem_is_synthetic
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_disk_current_filesystem_is_remote
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
comment|/* Request that the access time of the entry visited by traversal be restored. */
name|__LA_DECL
name|int
name|archive_read_disk_set_atime_restored
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
comment|/*  * Set behavior. The "flags" argument selects optional behavior.  */
comment|/* Request that the access time of the entry visited by traversal be restored.  * This is the same as archive_read_disk_set_atime_restored. */
define|#
directive|define
name|ARCHIVE_READDISK_RESTORE_ATIME
value|(0x0001)
comment|/* Default: Do not skip an entry which has nodump flags. */
define|#
directive|define
name|ARCHIVE_READDISK_HONOR_NODUMP
value|(0x0002)
comment|/* Default: Skip a mac resource fork file whose prefix is "._" because of  * using copyfile. */
define|#
directive|define
name|ARCHIVE_READDISK_MAC_COPYFILE
value|(0x0004)
comment|/* Default: Traverse mount points. */
define|#
directive|define
name|ARCHIVE_READDISK_NO_TRAVERSE_MOUNTS
value|(0x0008)
comment|/* Default: Xattrs are read from disk. */
define|#
directive|define
name|ARCHIVE_READDISK_NO_XATTR
value|(0x0010)
name|__LA_DECL
name|int
name|archive_read_disk_set_behavior
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
comment|/*  * Set archive_match object that will be used in archive_read_disk to  * know whether an entry should be skipped. The callback function  * _excluded_func will be invoked when an entry is skipped by the result  * of archive_match.  */
name|__LA_DECL
name|int
name|archive_read_disk_set_matching
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive
modifier|*
name|_matching
parameter_list|,
name|void
function_decl|(
modifier|*
name|_excluded_func
function_decl|)
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|_client_data
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_read_disk_set_metadata_filter_callback
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
function_decl|(
modifier|*
name|_metadata_filter_func
function_decl|)
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|_client_data
parameter_list|)
function_decl|;
comment|/* Simplified cleanup interface;  * This calls archive_read_free() or archive_write_free() as needed. */
name|__LA_DECL
name|int
name|archive_free
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
comment|/*  * Accessor functions to read/set various information in  * the struct archive object:  */
comment|/* Number of filters in the current filter pipeline. */
comment|/* Filter #0 is the one closest to the format, -1 is a synonym for the  * last filter, which is always the pseudo-filter that wraps the  * client callbacks. */
name|__LA_DECL
name|int
name|archive_filter_count
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|la_int64_t
name|archive_filter_bytes
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_filter_code
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_filter_name
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
if|#
directive|if
name|ARCHIVE_VERSION_NUMBER
operator|<
literal|4000000
comment|/* These don't properly handle multiple filters, so are deprecated and  * will eventually be removed. */
comment|/* As of libarchive 3.0, this is an alias for archive_filter_bytes(a, -1); */
name|__LA_DECL
name|la_int64_t
name|archive_position_compressed
argument_list|(
expr|struct
name|archive
operator|*
argument_list|)
name|__LA_DEPRECATED
decl_stmt|;
comment|/* As of libarchive 3.0, this is an alias for archive_filter_bytes(a, 0); */
name|__LA_DECL
name|la_int64_t
name|archive_position_uncompressed
argument_list|(
expr|struct
name|archive
operator|*
argument_list|)
name|__LA_DEPRECATED
decl_stmt|;
comment|/* As of libarchive 3.0, this is an alias for archive_filter_name(a, 0); */
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_compression_name
argument_list|(
expr|struct
name|archive
operator|*
argument_list|)
name|__LA_DEPRECATED
decl_stmt|;
comment|/* As of libarchive 3.0, this is an alias for archive_filter_code(a, 0); */
name|__LA_DECL
name|int
name|archive_compression
argument_list|(
expr|struct
name|archive
operator|*
argument_list|)
name|__LA_DEPRECATED
decl_stmt|;
endif|#
directive|endif
name|__LA_DECL
name|int
name|archive_errno
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_error_string
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_format_name
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_format
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_clear_error
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_set_error
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
name|_err
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|__LA_PRINTF
parameter_list|(
function_decl|3
operator|,
function_decl|4
block|)
empty_stmt|;
end_extern

begin_function_decl
name|__LA_DECL
name|void
name|archive_copy_error
parameter_list|(
name|struct
name|archive
modifier|*
name|dest
parameter_list|,
name|struct
name|archive
modifier|*
name|src
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|__LA_DECL
name|int
name|archive_file_count
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * ARCHIVE_MATCH API  */
end_comment

begin_function_decl
name|__LA_DECL
name|struct
name|archive
modifier|*
name|archive_match_new
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|__LA_DECL
name|int
name|archive_match_free
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Test if archive_entry is excluded.  * This is a convenience function. This is the same as calling all  * archive_match_path_excluded, archive_match_time_excluded  * and archive_match_owner_excluded.  */
end_comment

begin_function_decl
name|__LA_DECL
name|int
name|archive_match_excluded
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Test if pathname is excluded. The conditions are set by following functions.  */
end_comment

begin_function_decl
name|__LA_DECL
name|int
name|archive_match_path_excluded
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Add exclusion pathname pattern. */
end_comment

begin_function_decl
name|__LA_DECL
name|int
name|archive_match_exclude_pattern
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|__LA_DECL
name|int
name|archive_match_exclude_pattern_w
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|wchar_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Add exclusion pathname pattern from file. */
end_comment

begin_function_decl
name|__LA_DECL
name|int
name|archive_match_exclude_pattern_from_file
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
name|_nullSeparator
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|__LA_DECL
name|int
name|archive_match_exclude_pattern_from_file_w
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|wchar_t
modifier|*
parameter_list|,
name|int
name|_nullSeparator
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Add inclusion pathname pattern. */
end_comment

begin_function_decl
name|__LA_DECL
name|int
name|archive_match_include_pattern
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|__LA_DECL
name|int
name|archive_match_include_pattern_w
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|wchar_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Add inclusion pathname pattern from file. */
end_comment

begin_function_decl
name|__LA_DECL
name|int
name|archive_match_include_pattern_from_file
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
name|_nullSeparator
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|__LA_DECL
name|int
name|archive_match_include_pattern_from_file_w
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|wchar_t
modifier|*
parameter_list|,
name|int
name|_nullSeparator
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * How to get statistic information for inclusion patterns.  */
end_comment

begin_comment
comment|/* Return the amount number of unmatched inclusion patterns. */
end_comment

begin_function_decl
name|__LA_DECL
name|int
name|archive_match_path_unmatched_inclusions
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Return the pattern of unmatched inclusion with ARCHIVE_OK.  * Return ARCHIVE_EOF if there is no inclusion pattern. */
end_comment

begin_function_decl
name|__LA_DECL
name|int
name|archive_match_path_unmatched_inclusions_next
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|__LA_DECL
name|int
name|archive_match_path_unmatched_inclusions_next_w
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|wchar_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Test if a file is excluded by its time stamp.  * The conditions are set by following functions.  */
end_comment

begin_function_decl
name|__LA_DECL
name|int
name|archive_match_time_excluded
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Flags to tell a matching type of time stamps. These are used for  * following functions.  */
end_comment

begin_comment
comment|/* Time flag: mtime to be tested. */
end_comment

begin_define
define|#
directive|define
name|ARCHIVE_MATCH_MTIME
value|(0x0100)
end_define

begin_comment
comment|/* Time flag: ctime to be tested. */
end_comment

begin_define
define|#
directive|define
name|ARCHIVE_MATCH_CTIME
value|(0x0200)
end_define

begin_comment
comment|/* Comparison flag: Match the time if it is newer than. */
end_comment

begin_define
define|#
directive|define
name|ARCHIVE_MATCH_NEWER
value|(0x0001)
end_define

begin_comment
comment|/* Comparison flag: Match the time if it is older than. */
end_comment

begin_define
define|#
directive|define
name|ARCHIVE_MATCH_OLDER
value|(0x0002)
end_define

begin_comment
comment|/* Comparison flag: Match the time if it is equal to. */
end_comment

begin_define
define|#
directive|define
name|ARCHIVE_MATCH_EQUAL
value|(0x0010)
end_define

begin_comment
comment|/* Set inclusion time. */
end_comment

begin_function_decl
name|__LA_DECL
name|int
name|archive_match_include_time
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
name|_flag
parameter_list|,
name|time_t
name|_sec
parameter_list|,
name|long
name|_nsec
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Set inclusion time by a date string. */
end_comment

begin_function_decl
name|__LA_DECL
name|int
name|archive_match_include_date
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
name|_flag
parameter_list|,
specifier|const
name|char
modifier|*
name|_datestr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|__LA_DECL
name|int
name|archive_match_include_date_w
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
name|_flag
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|_datestr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Set inclusion time by a particular file. */
end_comment

begin_function_decl
name|__LA_DECL
name|int
name|archive_match_include_file_time
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
name|_flag
parameter_list|,
specifier|const
name|char
modifier|*
name|_pathname
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|__LA_DECL
name|int
name|archive_match_include_file_time_w
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
name|_flag
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|_pathname
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Add exclusion entry. */
end_comment

begin_function_decl
name|__LA_DECL
name|int
name|archive_match_exclude_entry
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
name|_flag
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Test if a file is excluded by its uid ,gid, uname or gname.  * The conditions are set by following functions.  */
end_comment

begin_function_decl
name|__LA_DECL
name|int
name|archive_match_owner_excluded
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Add inclusion uid, gid, uname and gname. */
end_comment

begin_function_decl
name|__LA_DECL
name|int
name|archive_match_include_uid
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|la_int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|__LA_DECL
name|int
name|archive_match_include_gid
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|la_int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|__LA_DECL
name|int
name|archive_match_include_uname
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|__LA_DECL
name|int
name|archive_match_include_uname_w
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|wchar_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|__LA_DECL
name|int
name|archive_match_include_gname
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|__LA_DECL
name|int
name|archive_match_include_gname_w
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|wchar_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Utility functions */
end_comment

begin_comment
comment|/* Convenience function to sort a NULL terminated list of strings */
end_comment

begin_function_decl
name|__LA_DECL
name|int
name|archive_utility_string_sort
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* These are meaningless outside of this header. */
end_comment

begin_undef
undef|#
directive|undef
name|__LA_DECL
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !ARCHIVE_H_INCLUDED */
end_comment

end_unit

