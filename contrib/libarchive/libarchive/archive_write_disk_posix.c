begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2010 Tim Kientzle  * Copyright (c) 2012 Michihiro NAKAJIMA  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"archive_platform.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TYPES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_ACL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/acl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_EXTATTR_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/extattr.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_SYS_XATTR_H
end_if

begin_include
include|#
directive|include
file|<sys/xattr.h>
end_include

begin_elif
elif|#
directive|elif
name|HAVE_ATTR_XATTR_H
end_elif

begin_include
include|#
directive|include
file|<attr/xattr.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_EA_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ea.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_IOCTL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_STAT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_UTIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/utime.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_COPYFILE_H
end_ifdef

begin_include
include|#
directive|include
file|<copyfile.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ERRNO_H
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FCNTL_H
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GRP_H
end_ifdef

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LANGINFO_H
end_ifdef

begin_include
include|#
directive|include
file|<langinfo.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LINUX_FS_H
end_ifdef

begin_include
include|#
directive|include
file|<linux/fs.h>
end_include

begin_comment
comment|/* for Linux file flags */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Some Linux distributions have both linux/ext2_fs.h and ext2fs/ext2_fs.h.  * As the include guards don't agree, the order of include is important.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LINUX_EXT2_FS_H
end_ifdef

begin_include
include|#
directive|include
file|<linux/ext2_fs.h>
end_include

begin_comment
comment|/* for Linux file flags */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_EXT2FS_EXT2_FS_H
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<ext2fs/ext2_fs.h>
end_include

begin_comment
comment|/* Linux file flags, broken on Cygwin */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIMITS_H
end_ifdef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PWD_H
end_ifdef

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UTIME_H
end_ifdef

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|F_GETTIMES
end_ifdef

begin_comment
comment|/* Tru64 specific */
end_comment

begin_include
include|#
directive|include
file|<sys/fcntl1.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Macro to cast st_mtime and time_t to an int64 so that 2 numbers can reliably be compared.  *  * It assumes that the input is an integer type of no more than 64 bits.  * If the number is less than zero, t must be a signed type, so it fits in  * int64_t. Otherwise, it's a nonnegative value so we can cast it to uint64_t  * without loss. But it could be a large unsigned value, so we have to clip it  * to INT64_MAX.*  */
end_comment

begin_define
define|#
directive|define
name|to_int64_time
parameter_list|(
name|t
parameter_list|)
define|\
value|((t)< 0 ? (int64_t)(t) : (uint64_t)(t)> (uint64_t)INT64_MAX ? INT64_MAX : (int64_t)(t))
end_define

begin_if
if|#
directive|if
name|__APPLE__
end_if

begin_include
include|#
directive|include
file|<TargetConditionals.h>
end_include

begin_if
if|#
directive|if
name|TARGET_OS_MAC
operator|&&
operator|!
name|TARGET_OS_EMBEDDED
operator|&&
name|HAVE_QUARANTINE_H
end_if

begin_include
include|#
directive|include
file|<quarantine.h>
end_include

begin_define
define|#
directive|define
name|HAVE_QUARANTINE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TODO: Support Mac OS 'quarantine' feature.  This is really just a  * standard tag to mark files that have been downloaded as "tainted".  * On Mac OS, we should mark the extracted files as tainted if the  * archive being read was tainted.  Windows has a similar feature; we  * should investigate ways to support this generically. */
end_comment

begin_include
include|#
directive|include
file|"archive.h"
end_include

begin_include
include|#
directive|include
file|"archive_acl_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_string.h"
end_include

begin_include
include|#
directive|include
file|"archive_endian.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry.h"
end_include

begin_include
include|#
directive|include
file|"archive_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_write_disk_private.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|O_BINARY
end_ifndef

begin_define
define|#
directive|define
name|O_BINARY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_CLOEXEC
end_ifndef

begin_define
define|#
directive|define
name|O_CLOEXEC
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Ignore non-int O_NOFOLLOW constant. */
end_comment

begin_comment
comment|/* gnulib's fcntl.h does this on AIX, but it seems practical everywhere */
end_comment

begin_if
if|#
directive|if
name|defined
name|O_NOFOLLOW
operator|&&
operator|!
operator|(
name|INT_MIN
operator|<=
name|O_NOFOLLOW
operator|&&
name|O_NOFOLLOW
operator|<=
name|INT_MAX
operator|)
end_if

begin_undef
undef|#
directive|undef
name|O_NOFOLLOW
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_NOFOLLOW
end_ifndef

begin_define
define|#
directive|define
name|O_NOFOLLOW
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|fixup_entry
block|{
name|struct
name|fixup_entry
modifier|*
name|next
decl_stmt|;
name|struct
name|archive_acl
name|acl
decl_stmt|;
name|mode_t
name|mode
decl_stmt|;
name|int64_t
name|atime
decl_stmt|;
name|int64_t
name|birthtime
decl_stmt|;
name|int64_t
name|mtime
decl_stmt|;
name|int64_t
name|ctime
decl_stmt|;
name|unsigned
name|long
name|atime_nanos
decl_stmt|;
name|unsigned
name|long
name|birthtime_nanos
decl_stmt|;
name|unsigned
name|long
name|mtime_nanos
decl_stmt|;
name|unsigned
name|long
name|ctime_nanos
decl_stmt|;
name|unsigned
name|long
name|fflags_set
decl_stmt|;
name|size_t
name|mac_metadata_size
decl_stmt|;
name|void
modifier|*
name|mac_metadata
decl_stmt|;
name|int
name|fixup
decl_stmt|;
comment|/* bitmask of what needs fixing */
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * We use a bitmask to track which operations remain to be done for  * this file.  In particular, this helps us avoid unnecessary  * operations when it's possible to take care of one step as a  * side-effect of another.  For example, mkdir() can specify the mode  * for the newly-created object but symlink() cannot.  This means we  * can skip chmod() if mkdir() succeeded, but we must explicitly  * chmod() if we're trying to create a directory that already exists  * (mkdir() failed) or if we're restoring a symlink.  Similarly, we  * need to verify UID/GID before trying to restore SUID/SGID bits;  * that verification can occur explicitly through a stat() call or  * implicitly because of a successful chown() call.  */
end_comment

begin_define
define|#
directive|define
name|TODO_MODE_FORCE
value|0x40000000
end_define

begin_define
define|#
directive|define
name|TODO_MODE_BASE
value|0x20000000
end_define

begin_define
define|#
directive|define
name|TODO_SUID
value|0x10000000
end_define

begin_define
define|#
directive|define
name|TODO_SUID_CHECK
value|0x08000000
end_define

begin_define
define|#
directive|define
name|TODO_SGID
value|0x04000000
end_define

begin_define
define|#
directive|define
name|TODO_SGID_CHECK
value|0x02000000
end_define

begin_define
define|#
directive|define
name|TODO_APPLEDOUBLE
value|0x01000000
end_define

begin_define
define|#
directive|define
name|TODO_MODE
value|(TODO_MODE_BASE|TODO_SUID|TODO_SGID)
end_define

begin_define
define|#
directive|define
name|TODO_TIMES
value|ARCHIVE_EXTRACT_TIME
end_define

begin_define
define|#
directive|define
name|TODO_OWNER
value|ARCHIVE_EXTRACT_OWNER
end_define

begin_define
define|#
directive|define
name|TODO_FFLAGS
value|ARCHIVE_EXTRACT_FFLAGS
end_define

begin_define
define|#
directive|define
name|TODO_ACLS
value|ARCHIVE_EXTRACT_ACL
end_define

begin_define
define|#
directive|define
name|TODO_XATTR
value|ARCHIVE_EXTRACT_XATTR
end_define

begin_define
define|#
directive|define
name|TODO_MAC_METADATA
value|ARCHIVE_EXTRACT_MAC_METADATA
end_define

begin_define
define|#
directive|define
name|TODO_HFS_COMPRESSION
value|ARCHIVE_EXTRACT_HFS_COMPRESSION_FORCED
end_define

begin_struct
struct|struct
name|archive_write_disk
block|{
name|struct
name|archive
name|archive
decl_stmt|;
name|mode_t
name|user_umask
decl_stmt|;
name|struct
name|fixup_entry
modifier|*
name|fixup_list
decl_stmt|;
name|struct
name|fixup_entry
modifier|*
name|current_fixup
decl_stmt|;
name|int64_t
name|user_uid
decl_stmt|;
name|int
name|skip_file_set
decl_stmt|;
name|int64_t
name|skip_file_dev
decl_stmt|;
name|int64_t
name|skip_file_ino
decl_stmt|;
name|time_t
name|start_time
decl_stmt|;
name|int64_t
function_decl|(
modifier|*
name|lookup_gid
function_decl|)
parameter_list|(
name|void
modifier|*
name|private
parameter_list|,
specifier|const
name|char
modifier|*
name|gname
parameter_list|,
name|int64_t
name|gid
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|cleanup_gid
function_decl|)
parameter_list|(
name|void
modifier|*
name|private
parameter_list|)
function_decl|;
name|void
modifier|*
name|lookup_gid_data
decl_stmt|;
name|int64_t
function_decl|(
modifier|*
name|lookup_uid
function_decl|)
parameter_list|(
name|void
modifier|*
name|private
parameter_list|,
specifier|const
name|char
modifier|*
name|uname
parameter_list|,
name|int64_t
name|uid
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|cleanup_uid
function_decl|)
parameter_list|(
name|void
modifier|*
name|private
parameter_list|)
function_decl|;
name|void
modifier|*
name|lookup_uid_data
decl_stmt|;
comment|/* 	 * Full path of last file to satisfy symlink checks. 	 */
name|struct
name|archive_string
name|path_safe
decl_stmt|;
comment|/* 	 * Cached stat data from disk for the current entry. 	 * If this is valid, pst points to st.  Otherwise, 	 * pst is null. 	 */
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|stat
modifier|*
name|pst
decl_stmt|;
comment|/* Information about the object being restored right now. */
name|struct
name|archive_entry
modifier|*
name|entry
decl_stmt|;
comment|/* Entry being extracted. */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of entry, possibly edited. */
name|struct
name|archive_string
name|_name_data
decl_stmt|;
comment|/* backing store for 'name' */
comment|/* Tasks remaining for this object. */
name|int
name|todo
decl_stmt|;
comment|/* Tasks deferred until end-of-archive. */
name|int
name|deferred
decl_stmt|;
comment|/* Options requested by the client. */
name|int
name|flags
decl_stmt|;
comment|/* Handle for the file we're restoring. */
name|int
name|fd
decl_stmt|;
comment|/* Current offset for writing data to the file. */
name|int64_t
name|offset
decl_stmt|;
comment|/* Last offset actually written to disk. */
name|int64_t
name|fd_offset
decl_stmt|;
comment|/* Total bytes actually written to files. */
name|int64_t
name|total_bytes_written
decl_stmt|;
comment|/* Maximum size of file, -1 if unknown. */
name|int64_t
name|filesize
decl_stmt|;
comment|/* Dir we were in before this restore; only for deep paths. */
name|int
name|restore_pwd
decl_stmt|;
comment|/* Mode we should use for this entry; affected by _PERM and umask. */
name|mode_t
name|mode
decl_stmt|;
comment|/* UID/GID to use in restoring this entry. */
name|int64_t
name|uid
decl_stmt|;
name|int64_t
name|gid
decl_stmt|;
comment|/* 	 * HFS+ Compression. 	 */
comment|/* Xattr "com.apple.decmpfs". */
name|uint32_t
name|decmpfs_attr_size
decl_stmt|;
name|unsigned
name|char
modifier|*
name|decmpfs_header_p
decl_stmt|;
comment|/* ResourceFork set options used for fsetxattr. */
name|int
name|rsrc_xattr_options
decl_stmt|;
comment|/* Xattr "com.apple.ResourceFork". */
name|unsigned
name|char
modifier|*
name|resource_fork
decl_stmt|;
name|size_t
name|resource_fork_allocated_size
decl_stmt|;
name|unsigned
name|int
name|decmpfs_block_count
decl_stmt|;
name|uint32_t
modifier|*
name|decmpfs_block_info
decl_stmt|;
comment|/* Buffer for compressed data. */
name|unsigned
name|char
modifier|*
name|compressed_buffer
decl_stmt|;
name|size_t
name|compressed_buffer_size
decl_stmt|;
name|size_t
name|compressed_buffer_remaining
decl_stmt|;
comment|/* The offset of the ResourceFork where compressed data will 	 * be placed. */
name|uint32_t
name|compressed_rsrc_position
decl_stmt|;
name|uint32_t
name|compressed_rsrc_position_v
decl_stmt|;
comment|/* Buffer for uncompressed data. */
name|char
modifier|*
name|uncompressed_buffer
decl_stmt|;
name|size_t
name|block_remaining_bytes
decl_stmt|;
name|size_t
name|file_remaining_bytes
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
name|z_stream
name|stream
decl_stmt|;
name|int
name|stream_valid
decl_stmt|;
name|int
name|decmpfs_compression_level
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/*  * Default mode for dirs created automatically (will be modified by umask).  * Note that POSIX specifies 0777 for implicitly-created dirs, "modified  * by the process' file creation mask."  */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_DIR_MODE
value|0777
end_define

begin_comment
comment|/*  * Dir modes are restored in two steps:  During the extraction, the permissions  * in the archive are modified to match the following limits.  During  * the post-extract fixup pass, the permissions from the archive are  * applied.  */
end_comment

begin_define
define|#
directive|define
name|MINIMUM_DIR_MODE
value|0700
end_define

begin_define
define|#
directive|define
name|MAXIMUM_DIR_MODE
value|0775
end_define

begin_comment
comment|/*  * Maximum uncompressed size of a decmpfs block.  */
end_comment

begin_define
define|#
directive|define
name|MAX_DECMPFS_BLOCK_SIZE
value|(64 * 1024)
end_define

begin_comment
comment|/*  * HFS+ compression type.  */
end_comment

begin_define
define|#
directive|define
name|CMP_XATTR
value|3
end_define

begin_comment
comment|/* Compressed data in xattr. */
end_comment

begin_define
define|#
directive|define
name|CMP_RESOURCE_FORK
value|4
end_define

begin_comment
comment|/* Compressed data in resource fork. */
end_comment

begin_comment
comment|/*  * HFS+ compression resource fork.  */
end_comment

begin_define
define|#
directive|define
name|RSRC_H_SIZE
value|260
end_define

begin_comment
comment|/* Base size of Resource fork header. */
end_comment

begin_define
define|#
directive|define
name|RSRC_F_SIZE
value|50
end_define

begin_comment
comment|/* Size of Resource fork footer. */
end_comment

begin_comment
comment|/* Size to write compressed data to resource fork. */
end_comment

begin_define
define|#
directive|define
name|COMPRESSED_W_SIZE
value|(64 * 1024)
end_define

begin_comment
comment|/* decmpfs definitions. */
end_comment

begin_define
define|#
directive|define
name|MAX_DECMPFS_XATTR_SIZE
value|3802
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|DECMPFS_XATTR_NAME
end_ifndef

begin_define
define|#
directive|define
name|DECMPFS_XATTR_NAME
value|"com.apple.decmpfs"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DECMPFS_MAGIC
value|0x636d7066
end_define

begin_define
define|#
directive|define
name|DECMPFS_COMPRESSION_MAGIC
value|0
end_define

begin_define
define|#
directive|define
name|DECMPFS_COMPRESSION_TYPE
value|4
end_define

begin_define
define|#
directive|define
name|DECMPFS_UNCOMPRESSED_SIZE
value|8
end_define

begin_define
define|#
directive|define
name|DECMPFS_HEADER_SIZE
value|16
end_define

begin_define
define|#
directive|define
name|HFS_BLOCKS
parameter_list|(
name|s
parameter_list|)
value|((s)>> 12)
end_define

begin_function_decl
specifier|static
name|void
name|fsobj_error
parameter_list|(
name|int
modifier|*
parameter_list|,
name|struct
name|archive_string
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_symlinks_fsobj
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|struct
name|archive_string
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_symlinks
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|create_filesystem_object
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|fixup_entry
modifier|*
name|current_fixup
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_FCHDIR
argument_list|)
operator|&&
name|defined
argument_list|(
name|PATH_MAX
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|edit_deep_directories
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|ad
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|cleanup_pathname_fsobj
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|struct
name|archive_string
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cleanup_pathname
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|create_dir
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|create_parent_dir
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssize_t
name|hfs_write_data_block
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fixup_appledouble
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|older
parameter_list|(
name|struct
name|stat
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|restore_entry
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_mac_metadata
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_xattrs
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|clear_nochange_fflags
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_fflags
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_fflags_platform
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
parameter_list|,
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|mode_t
name|mode
parameter_list|,
name|unsigned
name|long
name|fflags_set
parameter_list|,
name|unsigned
name|long
name|fflags_clear
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_ownership
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_mode
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
parameter_list|,
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_time
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|time_t
parameter_list|,
name|long
parameter_list|,
name|time_t
parameter_list|,
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_times
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|time_t
parameter_list|,
name|long
parameter_list|,
name|time_t
parameter_list|,
name|long
parameter_list|,
name|time_t
parameter_list|,
name|long
parameter_list|,
name|time_t
parameter_list|,
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_times_from_entry
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|fixup_entry
modifier|*
name|sort_dir_list
parameter_list|(
name|struct
name|fixup_entry
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssize_t
name|write_data_block
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|archive_vtable
modifier|*
name|archive_write_disk_vtable
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_archive_write_disk_close
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_archive_write_disk_free
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_archive_write_disk_header
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|_archive_write_disk_filter_bytes
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_archive_write_disk_finish_entry
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssize_t
name|_archive_write_disk_data
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssize_t
name|_archive_write_disk_data_block
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|lazy_stat
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|->
name|pst
operator|!=
name|NULL
condition|)
block|{
comment|/* Already have stat() data available. */
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|HAVE_FSTAT
if|if
condition|(
name|a
operator|->
name|fd
operator|>=
literal|0
operator|&&
name|fstat
argument_list|(
name|a
operator|->
name|fd
argument_list|,
operator|&
name|a
operator|->
name|st
argument_list|)
operator|==
literal|0
condition|)
block|{
name|a
operator|->
name|pst
operator|=
operator|&
name|a
operator|->
name|st
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* 	 * XXX At this point, symlinks should not be hit, otherwise 	 * XXX a race occurred.  Do we want to check explicitly for that? 	 */
if|if
condition|(
name|lstat
argument_list|(
name|a
operator|->
name|name
argument_list|,
operator|&
name|a
operator|->
name|st
argument_list|)
operator|==
literal|0
condition|)
block|{
name|a
operator|->
name|pst
operator|=
operator|&
name|a
operator|->
name|st
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Couldn't stat file"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|archive_vtable
modifier|*
name|archive_write_disk_vtable
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|struct
name|archive_vtable
name|av
decl_stmt|;
specifier|static
name|int
name|inited
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|inited
condition|)
block|{
name|av
operator|.
name|archive_close
operator|=
name|_archive_write_disk_close
expr_stmt|;
name|av
operator|.
name|archive_filter_bytes
operator|=
name|_archive_write_disk_filter_bytes
expr_stmt|;
name|av
operator|.
name|archive_free
operator|=
name|_archive_write_disk_free
expr_stmt|;
name|av
operator|.
name|archive_write_header
operator|=
name|_archive_write_disk_header
expr_stmt|;
name|av
operator|.
name|archive_write_finish_entry
operator|=
name|_archive_write_disk_finish_entry
expr_stmt|;
name|av
operator|.
name|archive_write_data
operator|=
name|_archive_write_disk_data
expr_stmt|;
name|av
operator|.
name|archive_write_data_block
operator|=
name|_archive_write_disk_data_block
expr_stmt|;
name|inited
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|av
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int64_t
name|_archive_write_disk_filter_bytes
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|struct
name|archive_write_disk
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_write_disk
operator|*
operator|)
name|_a
decl_stmt|;
operator|(
name|void
operator|)
name|n
expr_stmt|;
comment|/* UNUSED */
if|if
condition|(
name|n
operator|==
operator|-
literal|1
operator|||
name|n
operator|==
literal|0
condition|)
return|return
operator|(
name|a
operator|->
name|total_bytes_written
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|archive_write_disk_set_options
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|archive_write_disk
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_write_disk
operator|*
operator|)
name|_a
decl_stmt|;
name|a
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Extract this entry to disk.  *  * TODO: Validate hardlinks.  According to the standards, we're  * supposed to check each extracted hardlink and squawk if it refers  * to a file that we didn't restore.  I'm not entirely convinced this  * is a good idea, but more importantly: Is there any way to validate  * hardlinks without keeping a complete list of filenames from the  * entire archive?? Ugh.  *  */
end_comment

begin_function
specifier|static
name|int
name|_archive_write_disk_header
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|archive_write_disk
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_write_disk
operator|*
operator|)
name|_a
decl_stmt|;
name|struct
name|fixup_entry
modifier|*
name|fe
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|r
decl_stmt|;
name|archive_check_magic
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_WRITE_DISK_MAGIC
argument_list|,
name|ARCHIVE_STATE_HEADER
operator||
name|ARCHIVE_STATE_DATA
argument_list|,
literal|"archive_write_disk_header"
argument_list|)
expr_stmt|;
name|archive_clear_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|archive
operator|.
name|state
operator|&
name|ARCHIVE_STATE_DATA
condition|)
block|{
name|r
operator|=
name|_archive_write_disk_finish_entry
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_FATAL
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
comment|/* Set up for this particular entry. */
name|a
operator|->
name|pst
operator|=
name|NULL
expr_stmt|;
name|a
operator|->
name|current_fixup
operator|=
name|NULL
expr_stmt|;
name|a
operator|->
name|deferred
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|entry
condition|)
block|{
name|archive_entry_free
argument_list|(
name|a
operator|->
name|entry
argument_list|)
expr_stmt|;
name|a
operator|->
name|entry
operator|=
name|NULL
expr_stmt|;
block|}
name|a
operator|->
name|entry
operator|=
name|archive_entry_clone
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|a
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|a
operator|->
name|fd_offset
operator|=
literal|0
expr_stmt|;
name|a
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|a
operator|->
name|restore_pwd
operator|=
operator|-
literal|1
expr_stmt|;
name|a
operator|->
name|uid
operator|=
name|a
operator|->
name|user_uid
expr_stmt|;
name|a
operator|->
name|mode
operator|=
name|archive_entry_mode
argument_list|(
name|a
operator|->
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_entry_size_is_set
argument_list|(
name|a
operator|->
name|entry
argument_list|)
condition|)
name|a
operator|->
name|filesize
operator|=
name|archive_entry_size
argument_list|(
name|a
operator|->
name|entry
argument_list|)
expr_stmt|;
else|else
name|a
operator|->
name|filesize
operator|=
operator|-
literal|1
expr_stmt|;
name|archive_strcpy
argument_list|(
operator|&
operator|(
name|a
operator|->
name|_name_data
operator|)
argument_list|,
name|archive_entry_pathname
argument_list|(
name|a
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|->
name|name
operator|=
name|a
operator|->
name|_name_data
operator|.
name|s
expr_stmt|;
name|archive_clear_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|)
expr_stmt|;
comment|/* 	 * Clean up the requested path.  This is necessary for correct 	 * dir restores; the dir restore logic otherwise gets messed 	 * up by nonsense like "dir/.". 	 */
name|ret
operator|=
name|cleanup_pathname
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ret
operator|)
return|;
comment|/* 	 * Query the umask so we get predictable mode settings. 	 * This gets done on every call to _write_header in case the 	 * user edits their umask during the extraction for some 	 * reason. 	 */
name|umask
argument_list|(
name|a
operator|->
name|user_umask
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Figure out what we need to do for this entry. */
name|a
operator|->
name|todo
operator|=
name|TODO_MODE_BASE
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|flags
operator|&
name|ARCHIVE_EXTRACT_PERM
condition|)
block|{
name|a
operator|->
name|todo
operator||=
name|TODO_MODE_FORCE
expr_stmt|;
comment|/* Be pushy about permissions. */
comment|/* 		 * SGID requires an extra "check" step because we 		 * cannot easily predict the GID that the system will 		 * assign.  (Different systems assign GIDs to files 		 * based on a variety of criteria, including process 		 * credentials and the gid of the enclosing 		 * directory.)  We can only restore the SGID bit if 		 * the file has the right GID, and we only know the 		 * GID if we either set it (see set_ownership) or if 		 * we've actually called stat() on the file after it 		 * was restored.  Since there are several places at 		 * which we might verify the GID, we need a TODO bit 		 * to keep track. 		 */
if|if
condition|(
name|a
operator|->
name|mode
operator|&
name|S_ISGID
condition|)
name|a
operator|->
name|todo
operator||=
name|TODO_SGID
operator||
name|TODO_SGID_CHECK
expr_stmt|;
comment|/* 		 * Verifying the SUID is simpler, but can still be 		 * done in multiple ways, hence the separate "check" bit. 		 */
if|if
condition|(
name|a
operator|->
name|mode
operator|&
name|S_ISUID
condition|)
name|a
operator|->
name|todo
operator||=
name|TODO_SUID
operator||
name|TODO_SUID_CHECK
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * User didn't request full permissions, so don't 		 * restore SUID, SGID bits and obey umask. 		 */
name|a
operator|->
name|mode
operator|&=
operator|~
name|S_ISUID
expr_stmt|;
name|a
operator|->
name|mode
operator|&=
operator|~
name|S_ISGID
expr_stmt|;
name|a
operator|->
name|mode
operator|&=
operator|~
name|S_ISVTX
expr_stmt|;
name|a
operator|->
name|mode
operator|&=
operator|~
name|a
operator|->
name|user_umask
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|->
name|flags
operator|&
name|ARCHIVE_EXTRACT_OWNER
condition|)
name|a
operator|->
name|todo
operator||=
name|TODO_OWNER
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|flags
operator|&
name|ARCHIVE_EXTRACT_TIME
condition|)
name|a
operator|->
name|todo
operator||=
name|TODO_TIMES
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|flags
operator|&
name|ARCHIVE_EXTRACT_ACL
condition|)
block|{
if|#
directive|if
name|ARCHIVE_ACL_DARWIN
comment|/* 		 * On MacOS, platform ACLs get stored in mac_metadata, too. 		 * If we intend to extract mac_metadata and it is present 		 * we skip extracting libarchive NFSv4 ACLs. 		 */
name|size_t
name|metadata_size
decl_stmt|;
if|if
condition|(
operator|(
name|a
operator|->
name|flags
operator|&
name|ARCHIVE_EXTRACT_MAC_METADATA
operator|)
operator|==
literal|0
operator|||
name|archive_entry_mac_metadata
argument_list|(
name|a
operator|->
name|entry
argument_list|,
operator|&
name|metadata_size
argument_list|)
operator|==
name|NULL
operator|||
name|metadata_size
operator|==
literal|0
condition|)
endif|#
directive|endif
if|#
directive|if
name|ARCHIVE_ACL_LIBRICHACL
comment|/* 		 * RichACLs are stored in an extended attribute. 		 * If we intend to extract extended attributes and have this 		 * attribute we skip extracting libarchive NFSv4 ACLs. 		 */
name|short
name|extract_acls
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|flags
operator|&
name|ARCHIVE_EXTRACT_XATTR
operator|&&
operator|(
name|archive_entry_acl_types
argument_list|(
name|a
operator|->
name|entry
argument_list|)
operator|&
name|ARCHIVE_ENTRY_ACL_TYPE_NFS4
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|attr_name
decl_stmt|;
specifier|const
name|void
modifier|*
name|attr_value
decl_stmt|;
name|size_t
name|attr_size
decl_stmt|;
name|int
name|i
init|=
name|archive_entry_xattr_reset
argument_list|(
name|a
operator|->
name|entry
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|archive_entry_xattr_next
argument_list|(
name|a
operator|->
name|entry
argument_list|,
operator|&
name|attr_name
argument_list|,
operator|&
name|attr_value
argument_list|,
operator|&
name|attr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr_name
operator|!=
name|NULL
operator|&&
name|attr_value
operator|!=
name|NULL
operator|&&
name|attr_size
operator|>
literal|0
operator|&&
name|strcmp
argument_list|(
name|attr_name
argument_list|,
literal|"trusted.richacl"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|extract_acls
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|extract_acls
condition|)
endif|#
directive|endif
if|#
directive|if
name|ARCHIVE_ACL_DARWIN
operator|||
name|ARCHIVE_ACL_LIBRICHACL
block|{
endif|#
directive|endif
if|if
condition|(
name|archive_entry_filetype
argument_list|(
name|a
operator|->
name|entry
argument_list|)
operator|==
name|AE_IFDIR
condition|)
name|a
operator|->
name|deferred
operator||=
name|TODO_ACLS
expr_stmt|;
else|else
name|a
operator|->
name|todo
operator||=
name|TODO_ACLS
expr_stmt|;
if|#
directive|if
name|ARCHIVE_ACL_DARWIN
operator|||
name|ARCHIVE_ACL_LIBRICHACL
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|a
operator|->
name|flags
operator|&
name|ARCHIVE_EXTRACT_MAC_METADATA
condition|)
block|{
if|if
condition|(
name|archive_entry_filetype
argument_list|(
name|a
operator|->
name|entry
argument_list|)
operator|==
name|AE_IFDIR
condition|)
name|a
operator|->
name|deferred
operator||=
name|TODO_MAC_METADATA
expr_stmt|;
else|else
name|a
operator|->
name|todo
operator||=
name|TODO_MAC_METADATA
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
name|defined
argument_list|(
name|UF_COMPRESSED
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_ZLIB_H
argument_list|)
if|if
condition|(
operator|(
name|a
operator|->
name|flags
operator|&
name|ARCHIVE_EXTRACT_NO_HFS_COMPRESSION
operator|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|long
name|set
decl_stmt|,
name|clear
decl_stmt|;
name|archive_entry_fflags
argument_list|(
name|a
operator|->
name|entry
argument_list|,
operator|&
name|set
argument_list|,
operator|&
name|clear
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|set
operator|&
operator|~
name|clear
operator|)
operator|&
name|UF_COMPRESSED
condition|)
block|{
name|a
operator|->
name|todo
operator||=
name|TODO_HFS_COMPRESSION
expr_stmt|;
name|a
operator|->
name|decmpfs_block_count
operator|=
operator|(
name|unsigned
operator|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|a
operator|->
name|flags
operator|&
name|ARCHIVE_EXTRACT_HFS_COMPRESSION_FORCED
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|a
operator|->
name|mode
operator|&
name|AE_IFMT
operator|)
operator|==
name|AE_IFREG
operator|&&
name|a
operator|->
name|filesize
operator|>
literal|0
condition|)
block|{
name|a
operator|->
name|todo
operator||=
name|TODO_HFS_COMPRESSION
expr_stmt|;
name|a
operator|->
name|decmpfs_block_count
operator|=
operator|(
name|unsigned
operator|)
operator|-
literal|1
expr_stmt|;
block|}
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Check if the current file name is a type of the 		 * resource fork file. */
name|p
operator|=
name|strrchr
argument_list|(
name|a
operator|->
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|a
operator|->
name|name
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'_'
condition|)
block|{
comment|/* Do not compress "._XXX" files. */
name|a
operator|->
name|todo
operator|&=
operator|~
name|TODO_HFS_COMPRESSION
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|filesize
operator|>
literal|0
condition|)
name|a
operator|->
name|todo
operator||=
name|TODO_APPLEDOUBLE
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|a
operator|->
name|flags
operator|&
name|ARCHIVE_EXTRACT_XATTR
condition|)
block|{
if|#
directive|if
name|ARCHIVE_XATTR_DARWIN
comment|/* 		 * On MacOS, extended attributes get stored in mac_metadata, 		 * too. If we intend to extract mac_metadata and it is present 		 * we skip extracting extended attributes. 		 */
name|size_t
name|metadata_size
decl_stmt|;
if|if
condition|(
operator|(
name|a
operator|->
name|flags
operator|&
name|ARCHIVE_EXTRACT_MAC_METADATA
operator|)
operator|==
literal|0
operator|||
name|archive_entry_mac_metadata
argument_list|(
name|a
operator|->
name|entry
argument_list|,
operator|&
name|metadata_size
argument_list|)
operator|==
name|NULL
operator|||
name|metadata_size
operator|==
literal|0
condition|)
endif|#
directive|endif
name|a
operator|->
name|todo
operator||=
name|TODO_XATTR
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|->
name|flags
operator|&
name|ARCHIVE_EXTRACT_FFLAGS
condition|)
name|a
operator|->
name|todo
operator||=
name|TODO_FFLAGS
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|flags
operator|&
name|ARCHIVE_EXTRACT_SECURE_SYMLINKS
condition|)
block|{
name|ret
operator|=
name|check_symlinks
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_FCHDIR
argument_list|)
operator|&&
name|defined
argument_list|(
name|PATH_MAX
argument_list|)
comment|/* If path exceeds PATH_MAX, shorten the path. */
name|edit_deep_directories
argument_list|(
name|a
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ret
operator|=
name|restore_entry
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
name|defined
argument_list|(
name|UF_COMPRESSED
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_ZLIB_H
argument_list|)
comment|/* 	 * Check if the filesystem the file is restoring on supports 	 * HFS+ Compression. If not, cancel HFS+ Compression. 	 */
if|if
condition|(
name|a
operator|->
name|todo
operator||
name|TODO_HFS_COMPRESSION
condition|)
block|{
comment|/* 		 * NOTE: UF_COMPRESSED is ignored even if the filesystem 		 * supports HFS+ Compression because the file should 		 * have at least an extended attribute "com.apple.decmpfs" 		 * before the flag is set to indicate that the file have 		 * been compressed. If the filesystem does not support 		 * HFS+ Compression the system call will fail. 		 */
if|if
condition|(
name|a
operator|->
name|fd
operator|<
literal|0
operator|||
name|fchflags
argument_list|(
name|a
operator|->
name|fd
argument_list|,
name|UF_COMPRESSED
argument_list|)
operator|!=
literal|0
condition|)
name|a
operator|->
name|todo
operator|&=
operator|~
name|TODO_HFS_COMPRESSION
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * TODO: There are rumours that some extended attributes must 	 * be restored before file data is written.  If this is true, 	 * then we either need to write all extended attributes both 	 * before and after restoring the data, or find some rule for 	 * determining which must go first and which last.  Due to the 	 * many ways people are using xattrs, this may prove to be an 	 * intractable problem. 	 */
ifdef|#
directive|ifdef
name|HAVE_FCHDIR
comment|/* If we changed directory above, restore it here. */
if|if
condition|(
name|a
operator|->
name|restore_pwd
operator|>=
literal|0
condition|)
block|{
name|r
operator|=
name|fchdir
argument_list|(
name|a
operator|->
name|restore_pwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"chdir() failure"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
block|}
name|close
argument_list|(
name|a
operator|->
name|restore_pwd
argument_list|)
expr_stmt|;
name|a
operator|->
name|restore_pwd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Fixup uses the unedited pathname from archive_entry_pathname(), 	 * because it is relative to the base dir and the edited path 	 * might be relative to some intermediate dir as a result of the 	 * deep restore logic. 	 */
if|if
condition|(
name|a
operator|->
name|deferred
operator|&
name|TODO_MODE
condition|)
block|{
name|fe
operator|=
name|current_fixup
argument_list|(
name|a
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fe
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|fe
operator|->
name|fixup
operator||=
name|TODO_MODE_BASE
expr_stmt|;
name|fe
operator|->
name|mode
operator|=
name|a
operator|->
name|mode
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|a
operator|->
name|deferred
operator|&
name|TODO_TIMES
operator|)
operator|&&
operator|(
name|archive_entry_mtime_is_set
argument_list|(
name|entry
argument_list|)
operator|||
name|archive_entry_atime_is_set
argument_list|(
name|entry
argument_list|)
operator|)
condition|)
block|{
name|fe
operator|=
name|current_fixup
argument_list|(
name|a
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fe
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|fe
operator|->
name|mode
operator|=
name|a
operator|->
name|mode
expr_stmt|;
name|fe
operator|->
name|fixup
operator||=
name|TODO_TIMES
expr_stmt|;
if|if
condition|(
name|archive_entry_atime_is_set
argument_list|(
name|entry
argument_list|)
condition|)
block|{
name|fe
operator|->
name|atime
operator|=
name|archive_entry_atime
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|fe
operator|->
name|atime_nanos
operator|=
name|archive_entry_atime_nsec
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If atime is unset, use start time. */
name|fe
operator|->
name|atime
operator|=
name|a
operator|->
name|start_time
expr_stmt|;
name|fe
operator|->
name|atime_nanos
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|archive_entry_mtime_is_set
argument_list|(
name|entry
argument_list|)
condition|)
block|{
name|fe
operator|->
name|mtime
operator|=
name|archive_entry_mtime
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|fe
operator|->
name|mtime_nanos
operator|=
name|archive_entry_mtime_nsec
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If mtime is unset, use start time. */
name|fe
operator|->
name|mtime
operator|=
name|a
operator|->
name|start_time
expr_stmt|;
name|fe
operator|->
name|mtime_nanos
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|archive_entry_birthtime_is_set
argument_list|(
name|entry
argument_list|)
condition|)
block|{
name|fe
operator|->
name|birthtime
operator|=
name|archive_entry_birthtime
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|fe
operator|->
name|birthtime_nanos
operator|=
name|archive_entry_birthtime_nsec
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If birthtime is unset, use mtime. */
name|fe
operator|->
name|birthtime
operator|=
name|fe
operator|->
name|mtime
expr_stmt|;
name|fe
operator|->
name|birthtime_nanos
operator|=
name|fe
operator|->
name|mtime_nanos
expr_stmt|;
block|}
block|}
if|if
condition|(
name|a
operator|->
name|deferred
operator|&
name|TODO_ACLS
condition|)
block|{
name|fe
operator|=
name|current_fixup
argument_list|(
name|a
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fe
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|fe
operator|->
name|fixup
operator||=
name|TODO_ACLS
expr_stmt|;
name|archive_acl_copy
argument_list|(
operator|&
name|fe
operator|->
name|acl
argument_list|,
name|archive_entry_acl
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|->
name|deferred
operator|&
name|TODO_MAC_METADATA
condition|)
block|{
specifier|const
name|void
modifier|*
name|metadata
decl_stmt|;
name|size_t
name|metadata_size
decl_stmt|;
name|metadata
operator|=
name|archive_entry_mac_metadata
argument_list|(
name|a
operator|->
name|entry
argument_list|,
operator|&
name|metadata_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|metadata
operator|!=
name|NULL
operator|&&
name|metadata_size
operator|>
literal|0
condition|)
block|{
name|fe
operator|=
name|current_fixup
argument_list|(
name|a
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fe
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|fe
operator|->
name|mac_metadata
operator|=
name|malloc
argument_list|(
name|metadata_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|fe
operator|->
name|mac_metadata
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|fe
operator|->
name|mac_metadata
argument_list|,
name|metadata
argument_list|,
name|metadata_size
argument_list|)
expr_stmt|;
name|fe
operator|->
name|mac_metadata_size
operator|=
name|metadata_size
expr_stmt|;
name|fe
operator|->
name|fixup
operator||=
name|TODO_MAC_METADATA
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|a
operator|->
name|deferred
operator|&
name|TODO_FFLAGS
condition|)
block|{
name|fe
operator|=
name|current_fixup
argument_list|(
name|a
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fe
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|fe
operator|->
name|fixup
operator||=
name|TODO_FFLAGS
expr_stmt|;
comment|/* TODO: Complete this.. defer fflags from below. */
block|}
comment|/* We've created the object and are ready to pour data into it. */
if|if
condition|(
name|ret
operator|>=
name|ARCHIVE_WARN
condition|)
name|a
operator|->
name|archive
operator|.
name|state
operator|=
name|ARCHIVE_STATE_DATA
expr_stmt|;
comment|/* 	 * If it's not open, tell our client not to try writing. 	 * In particular, dirs, links, etc, don't get written to. 	 */
if|if
condition|(
name|a
operator|->
name|fd
operator|<
literal|0
condition|)
block|{
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|a
operator|->
name|filesize
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|archive_write_disk_set_skip_file
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
name|int64_t
name|d
parameter_list|,
name|int64_t
name|i
parameter_list|)
block|{
name|struct
name|archive_write_disk
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_write_disk
operator|*
operator|)
name|_a
decl_stmt|;
name|archive_check_magic
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_WRITE_DISK_MAGIC
argument_list|,
name|ARCHIVE_STATE_ANY
argument_list|,
literal|"archive_write_disk_set_skip_file"
argument_list|)
expr_stmt|;
name|a
operator|->
name|skip_file_set
operator|=
literal|1
expr_stmt|;
name|a
operator|->
name|skip_file_dev
operator|=
name|d
expr_stmt|;
name|a
operator|->
name|skip_file_ino
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|write_data_block
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|buff
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|uint64_t
name|start_size
init|=
name|size
decl_stmt|;
name|ssize_t
name|bytes_written
init|=
literal|0
decl_stmt|;
name|ssize_t
name|block_size
init|=
literal|0
decl_stmt|,
name|bytes_to_write
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|filesize
operator|==
literal|0
operator|||
name|a
operator|->
name|fd
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
literal|0
argument_list|,
literal|"Attempt to write to an empty file"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
if|if
condition|(
name|a
operator|->
name|flags
operator|&
name|ARCHIVE_EXTRACT_SPARSE
condition|)
block|{
if|#
directive|if
name|HAVE_STRUCT_STAT_ST_BLKSIZE
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|lazy_stat
argument_list|(
name|a
argument_list|)
operator|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|block_size
operator|=
name|a
operator|->
name|pst
operator|->
name|st_blksize
expr_stmt|;
else|#
directive|else
comment|/* XXX TODO XXX Is there a more appropriate choice here ? */
comment|/* This needn't match the filesystem allocation size. */
name|block_size
operator|=
literal|16
operator|*
literal|1024
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* If this write would run beyond the file size, truncate it. */
if|if
condition|(
name|a
operator|->
name|filesize
operator|>=
literal|0
operator|&&
call|(
name|int64_t
call|)
argument_list|(
name|a
operator|->
name|offset
operator|+
name|size
argument_list|)
operator|>
name|a
operator|->
name|filesize
condition|)
name|start_size
operator|=
name|size
operator|=
call|(
name|size_t
call|)
argument_list|(
name|a
operator|->
name|filesize
operator|-
name|a
operator|->
name|offset
argument_list|)
expr_stmt|;
comment|/* Write the data. */
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|block_size
operator|==
literal|0
condition|)
block|{
name|bytes_to_write
operator|=
name|size
expr_stmt|;
block|}
else|else
block|{
comment|/* We're sparsifying the file. */
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int64_t
name|block_end
decl_stmt|;
comment|/* Skip leading zero bytes. */
for|for
control|(
name|p
operator|=
name|buff
operator|,
name|end
operator|=
name|buff
operator|+
name|size
init|;
name|p
operator|<
name|end
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
break|break;
block|}
name|a
operator|->
name|offset
operator|+=
name|p
operator|-
name|buff
expr_stmt|;
name|size
operator|-=
name|p
operator|-
name|buff
expr_stmt|;
name|buff
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
break|break;
comment|/* Calculate next block boundary after offset. */
name|block_end
operator|=
operator|(
name|a
operator|->
name|offset
operator|/
name|block_size
operator|+
literal|1
operator|)
operator|*
name|block_size
expr_stmt|;
comment|/* If the adjusted write would cross block boundary, 			 * truncate it to the block boundary. */
name|bytes_to_write
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|offset
operator|+
name|bytes_to_write
operator|>
name|block_end
condition|)
name|bytes_to_write
operator|=
name|block_end
operator|-
name|a
operator|->
name|offset
expr_stmt|;
block|}
comment|/* Seek if necessary to the specified offset. */
if|if
condition|(
name|a
operator|->
name|offset
operator|!=
name|a
operator|->
name|fd_offset
condition|)
block|{
if|if
condition|(
name|lseek
argument_list|(
name|a
operator|->
name|fd
argument_list|,
name|a
operator|->
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Seek failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|a
operator|->
name|fd_offset
operator|=
name|a
operator|->
name|offset
expr_stmt|;
block|}
name|bytes_written
operator|=
name|write
argument_list|(
name|a
operator|->
name|fd
argument_list|,
name|buff
argument_list|,
name|bytes_to_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_written
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Write failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
name|buff
operator|+=
name|bytes_written
expr_stmt|;
name|size
operator|-=
name|bytes_written
expr_stmt|;
name|a
operator|->
name|total_bytes_written
operator|+=
name|bytes_written
expr_stmt|;
name|a
operator|->
name|offset
operator|+=
name|bytes_written
expr_stmt|;
name|a
operator|->
name|fd_offset
operator|=
name|a
operator|->
name|offset
expr_stmt|;
block|}
return|return
operator|(
name|start_size
operator|-
name|size
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
name|defined
argument_list|(
name|UF_COMPRESSED
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_SYS_XATTR_H
argument_list|)
expr|\
operator|&&
name|defined
argument_list|(
name|HAVE_ZLIB_H
argument_list|)
end_if

begin_comment
comment|/*  * Set UF_COMPRESSED file flag.  * This have to be called after hfs_write_decmpfs() because if the  * file does not have "com.apple.decmpfs" xattr the flag is ignored.  */
end_comment

begin_function
specifier|static
name|int
name|hfs_set_compressed_fflag
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|lazy_stat
argument_list|(
name|a
argument_list|)
operator|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|a
operator|->
name|st
operator|.
name|st_flags
operator||=
name|UF_COMPRESSED
expr_stmt|;
if|if
condition|(
name|fchflags
argument_list|(
name|a
operator|->
name|fd
argument_list|,
name|a
operator|->
name|st
operator|.
name|st_flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Failed to set UF_COMPRESSED file flag"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * HFS+ Compression decmpfs  *  *     +------------------------------+ +0  *     |      Magic(LE 4 bytes)       |  *     +------------------------------+  *     |      Type(LE 4 bytes)        |  *     +------------------------------+  *     | Uncompressed size(LE 8 bytes)|  *     +------------------------------+ +16  *     |                              |  *     |       Compressed data        |  *     |  (Placed only if Type == 3)  |  *     |                              |  *     +------------------------------+  +3802 = MAX_DECMPFS_XATTR_SIZE  *  *  Type is 3: decmpfs has compressed data.  *  Type is 4: Resource Fork has compressed data.  */
end_comment

begin_comment
comment|/*  * Write "com.apple.decmpfs"  */
end_comment

begin_function
specifier|static
name|int
name|hfs_write_decmpfs
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|uint32_t
name|compression_type
decl_stmt|;
name|r
operator|=
name|fsetxattr
argument_list|(
name|a
operator|->
name|fd
argument_list|,
name|DECMPFS_XATTR_NAME
argument_list|,
name|a
operator|->
name|decmpfs_header_p
argument_list|,
name|a
operator|->
name|decmpfs_attr_size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Cannot restore xattr:%s"
argument_list|,
name|DECMPFS_XATTR_NAME
argument_list|)
expr_stmt|;
name|compression_type
operator|=
name|archive_le32dec
argument_list|(
operator|&
name|a
operator|->
name|decmpfs_header_p
index|[
name|DECMPFS_COMPRESSION_TYPE
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|compression_type
operator|==
name|CMP_RESOURCE_FORK
condition|)
name|fremovexattr
argument_list|(
name|a
operator|->
name|fd
argument_list|,
name|XATTR_RESOURCEFORK_NAME
argument_list|,
name|XATTR_SHOWCOMPRESSION
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * HFS+ Compression Resource Fork  *  *     +-----------------------------+  *     |     Header(260 bytes)       |  *     +-----------------------------+  *     |   Block count(LE 4 bytes)   |  *     +-----------------------------+  --+  * +-- |     Offset (LE 4 bytes)     |    |  * |   | [distance from Block count] |    | Block 0  * |   +-----------------------------+    |  * |   | Compressed size(LE 4 bytes) |    |  * |   +-----------------------------+  --+  * |   |                             |  * |   |      ..................     |  * |   |                             |  * |   +-----------------------------+  --+  * |   |     Offset (LE 4 bytes)     |    |  * |   +-----------------------------+    | Block (Block count -1)  * |   | Compressed size(LE 4 bytes) |    |  * +-> +-----------------------------+  --+  *     |   Compressed data(n bytes)  |  Block 0  *     +-----------------------------+  *     |                             |  *     |      ..................     |  *     |                             |  *     +-----------------------------+  *     |   Compressed data(n bytes)  |  Block (Block count -1)  *     +-----------------------------+  *     |      Footer(50 bytes)       |  *     +-----------------------------+  *  */
end_comment

begin_comment
comment|/*  * Write the header of "com.apple.ResourceFork"  */
end_comment

begin_function
specifier|static
name|int
name|hfs_write_resource_fork
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|,
name|unsigned
name|char
modifier|*
name|buff
parameter_list|,
name|size_t
name|bytes
parameter_list|,
name|uint32_t
name|position
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|fsetxattr
argument_list|(
name|a
operator|->
name|fd
argument_list|,
name|XATTR_RESOURCEFORK_NAME
argument_list|,
name|buff
argument_list|,
name|bytes
argument_list|,
name|position
argument_list|,
name|a
operator|->
name|rsrc_xattr_options
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Cannot restore xattr: %s at %u pos %u bytes"
argument_list|,
name|XATTR_RESOURCEFORK_NAME
argument_list|,
operator|(
name|unsigned
operator|)
name|position
argument_list|,
operator|(
name|unsigned
operator|)
name|bytes
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
name|a
operator|->
name|rsrc_xattr_options
operator|&=
operator|~
name|XATTR_CREATE
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hfs_write_compressed_data
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|,
name|size_t
name|bytes_compressed
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|hfs_write_resource_fork
argument_list|(
name|a
argument_list|,
name|a
operator|->
name|compressed_buffer
argument_list|,
name|bytes_compressed
argument_list|,
name|a
operator|->
name|compressed_rsrc_position
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|ARCHIVE_OK
condition|)
name|a
operator|->
name|compressed_rsrc_position
operator|+=
name|bytes_compressed
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hfs_write_resource_fork_header
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|buff
decl_stmt|;
name|uint32_t
name|rsrc_bytes
decl_stmt|;
name|uint32_t
name|rsrc_header_bytes
decl_stmt|;
comment|/* 	 * Write resource fork header + block info. 	 */
name|buff
operator|=
name|a
operator|->
name|resource_fork
expr_stmt|;
name|rsrc_bytes
operator|=
name|a
operator|->
name|compressed_rsrc_position
operator|-
name|RSRC_F_SIZE
expr_stmt|;
name|rsrc_header_bytes
operator|=
name|RSRC_H_SIZE
operator|+
comment|/* Header base size. */
literal|4
operator|+
comment|/* Block count. */
operator|(
name|a
operator|->
name|decmpfs_block_count
operator|*
literal|8
operator|)
expr_stmt|;
comment|/* Block info */
name|archive_be32enc
argument_list|(
name|buff
argument_list|,
literal|0x100
argument_list|)
expr_stmt|;
name|archive_be32enc
argument_list|(
name|buff
operator|+
literal|4
argument_list|,
name|rsrc_bytes
argument_list|)
expr_stmt|;
name|archive_be32enc
argument_list|(
name|buff
operator|+
literal|8
argument_list|,
name|rsrc_bytes
operator|-
literal|256
argument_list|)
expr_stmt|;
name|archive_be32enc
argument_list|(
name|buff
operator|+
literal|12
argument_list|,
literal|0x32
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buff
operator|+
literal|16
argument_list|,
literal|0
argument_list|,
literal|240
argument_list|)
expr_stmt|;
name|archive_be32enc
argument_list|(
name|buff
operator|+
literal|256
argument_list|,
name|rsrc_bytes
operator|-
literal|260
argument_list|)
expr_stmt|;
return|return
name|hfs_write_resource_fork
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|rsrc_header_bytes
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|hfs_set_resource_fork_footer
parameter_list|(
name|unsigned
name|char
modifier|*
name|buff
parameter_list|,
name|size_t
name|buff_size
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|rsrc_footer
index|[
name|RSRC_F_SIZE
index|]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x1c
block|,
literal|0x00
block|,
literal|0x32
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|'c'
block|,
literal|'m'
block|,
literal|'p'
block|,
literal|'f'
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x0a
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
if|if
condition|(
name|buff_size
operator|<
sizeof|sizeof
argument_list|(
name|rsrc_footer
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|memcpy
argument_list|(
name|buff
argument_list|,
name|rsrc_footer
argument_list|,
sizeof|sizeof
argument_list|(
name|rsrc_footer
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
sizeof|sizeof
argument_list|(
name|rsrc_footer
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hfs_reset_compressor
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|stream_valid
condition|)
name|ret
operator|=
name|deflateReset
argument_list|(
operator|&
name|a
operator|->
name|stream
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|deflateInit
argument_list|(
operator|&
name|a
operator|->
name|stream
argument_list|,
name|a
operator|->
name|decmpfs_compression_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Failed to initialize compressor"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
else|else
name|a
operator|->
name|stream_valid
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hfs_decompress
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|)
block|{
name|uint32_t
modifier|*
name|block_info
decl_stmt|;
name|unsigned
name|int
name|block_count
decl_stmt|;
name|uint32_t
name|data_pos
decl_stmt|,
name|data_size
decl_stmt|;
name|ssize_t
name|r
decl_stmt|;
name|ssize_t
name|bytes_written
decl_stmt|,
name|bytes_to_write
decl_stmt|;
name|unsigned
name|char
modifier|*
name|b
decl_stmt|;
name|block_info
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|a
operator|->
name|resource_fork
operator|+
name|RSRC_H_SIZE
operator|)
expr_stmt|;
name|block_count
operator|=
name|archive_le32dec
argument_list|(
name|block_info
operator|++
argument_list|)
expr_stmt|;
while|while
condition|(
name|block_count
operator|--
condition|)
block|{
name|data_pos
operator|=
name|RSRC_H_SIZE
operator|+
name|archive_le32dec
argument_list|(
name|block_info
operator|++
argument_list|)
expr_stmt|;
name|data_size
operator|=
name|archive_le32dec
argument_list|(
name|block_info
operator|++
argument_list|)
expr_stmt|;
name|r
operator|=
name|fgetxattr
argument_list|(
name|a
operator|->
name|fd
argument_list|,
name|XATTR_RESOURCEFORK_NAME
argument_list|,
name|a
operator|->
name|compressed_buffer
argument_list|,
name|data_size
argument_list|,
name|data_pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|data_size
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
operator|(
name|r
operator|<
literal|0
operator|)
condition|?
name|errno
else|:
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Failed to read resource fork"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
if|if
condition|(
name|a
operator|->
name|compressed_buffer
index|[
literal|0
index|]
operator|==
literal|0xff
condition|)
block|{
name|bytes_to_write
operator|=
name|data_size
operator|-
literal|1
expr_stmt|;
name|b
operator|=
name|a
operator|->
name|compressed_buffer
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|uLong
name|dest_len
init|=
name|MAX_DECMPFS_BLOCK_SIZE
decl_stmt|;
name|int
name|zr
decl_stmt|;
name|zr
operator|=
name|uncompress
argument_list|(
operator|(
name|Bytef
operator|*
operator|)
name|a
operator|->
name|uncompressed_buffer
argument_list|,
operator|&
name|dest_len
argument_list|,
name|a
operator|->
name|compressed_buffer
argument_list|,
name|data_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|zr
operator|!=
name|Z_OK
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Failed to decompress resource fork"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
name|bytes_to_write
operator|=
name|dest_len
expr_stmt|;
name|b
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|a
operator|->
name|uncompressed_buffer
expr_stmt|;
block|}
do|do
block|{
name|bytes_written
operator|=
name|write
argument_list|(
name|a
operator|->
name|fd
argument_list|,
name|b
argument_list|,
name|bytes_to_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_written
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Write failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
name|bytes_to_write
operator|-=
name|bytes_written
expr_stmt|;
name|b
operator|+=
name|bytes_written
expr_stmt|;
block|}
do|while
condition|(
name|bytes_to_write
operator|>
literal|0
condition|)
do|;
block|}
name|r
operator|=
name|fremovexattr
argument_list|(
name|a
operator|->
name|fd
argument_list|,
name|XATTR_RESOURCEFORK_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Failed to remove resource fork"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hfs_drive_compressor
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|buff
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|buffer_compressed
decl_stmt|;
name|size_t
name|bytes_compressed
decl_stmt|;
name|size_t
name|bytes_used
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|hfs_reset_compressor
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|compressed_buffer
operator|==
name|NULL
condition|)
block|{
name|size_t
name|block_size
decl_stmt|;
name|block_size
operator|=
name|COMPRESSED_W_SIZE
operator|+
name|RSRC_F_SIZE
operator|+
operator|+
name|compressBound
argument_list|(
name|MAX_DECMPFS_BLOCK_SIZE
argument_list|)
expr_stmt|;
name|a
operator|->
name|compressed_buffer
operator|=
name|malloc
argument_list|(
name|block_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|compressed_buffer
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for Resource Fork"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|a
operator|->
name|compressed_buffer_size
operator|=
name|block_size
expr_stmt|;
name|a
operator|->
name|compressed_buffer_remaining
operator|=
name|block_size
expr_stmt|;
block|}
name|buffer_compressed
operator|=
name|a
operator|->
name|compressed_buffer
operator|+
name|a
operator|->
name|compressed_buffer_size
operator|-
name|a
operator|->
name|compressed_buffer_remaining
expr_stmt|;
name|a
operator|->
name|stream
operator|.
name|next_in
operator|=
operator|(
name|Bytef
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|(
specifier|const
name|void
operator|*
operator|)
name|buff
expr_stmt|;
name|a
operator|->
name|stream
operator|.
name|avail_in
operator|=
name|size
expr_stmt|;
name|a
operator|->
name|stream
operator|.
name|next_out
operator|=
name|buffer_compressed
expr_stmt|;
name|a
operator|->
name|stream
operator|.
name|avail_out
operator|=
name|a
operator|->
name|compressed_buffer_remaining
expr_stmt|;
do|do
block|{
name|ret
operator|=
name|deflate
argument_list|(
operator|&
name|a
operator|->
name|stream
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|Z_OK
case|:
case|case
name|Z_STREAM_END
case|:
break|break;
default|default:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Failed to compress data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
block|}
do|while
condition|(
name|ret
operator|==
name|Z_OK
condition|)
do|;
name|bytes_compressed
operator|=
name|a
operator|->
name|compressed_buffer_remaining
operator|-
name|a
operator|->
name|stream
operator|.
name|avail_out
expr_stmt|;
comment|/* 	 * If the compressed size is larger than the original size, 	 * throw away compressed data, use uncompressed data instead. 	 */
if|if
condition|(
name|bytes_compressed
operator|>
name|size
condition|)
block|{
name|buffer_compressed
index|[
literal|0
index|]
operator|=
literal|0xFF
expr_stmt|;
comment|/* uncompressed marker. */
name|memcpy
argument_list|(
name|buffer_compressed
operator|+
literal|1
argument_list|,
name|buff
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|bytes_compressed
operator|=
name|size
operator|+
literal|1
expr_stmt|;
block|}
name|a
operator|->
name|compressed_buffer_remaining
operator|-=
name|bytes_compressed
expr_stmt|;
comment|/* 	 * If the compressed size is smaller than MAX_DECMPFS_XATTR_SIZE 	 * and the block count in the file is only one, store compressed 	 * data to decmpfs xattr instead of the resource fork. 	 */
if|if
condition|(
name|a
operator|->
name|decmpfs_block_count
operator|==
literal|1
operator|&&
operator|(
name|a
operator|->
name|decmpfs_attr_size
operator|+
name|bytes_compressed
operator|)
operator|<=
name|MAX_DECMPFS_XATTR_SIZE
condition|)
block|{
name|archive_le32enc
argument_list|(
operator|&
name|a
operator|->
name|decmpfs_header_p
index|[
name|DECMPFS_COMPRESSION_TYPE
index|]
argument_list|,
name|CMP_XATTR
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|a
operator|->
name|decmpfs_header_p
operator|+
name|DECMPFS_HEADER_SIZE
argument_list|,
name|buffer_compressed
argument_list|,
name|bytes_compressed
argument_list|)
expr_stmt|;
name|a
operator|->
name|decmpfs_attr_size
operator|+=
name|bytes_compressed
expr_stmt|;
name|a
operator|->
name|compressed_buffer_remaining
operator|=
name|a
operator|->
name|compressed_buffer_size
expr_stmt|;
comment|/* 		 * Finish HFS+ Compression. 		 * - Write the decmpfs xattr. 		 * - Set the UF_COMPRESSED file flag. 		 */
name|ret
operator|=
name|hfs_write_decmpfs
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|ARCHIVE_OK
condition|)
name|ret
operator|=
name|hfs_set_compressed_fflag
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* Update block info. */
name|archive_le32enc
argument_list|(
name|a
operator|->
name|decmpfs_block_info
operator|++
argument_list|,
name|a
operator|->
name|compressed_rsrc_position_v
operator|-
name|RSRC_H_SIZE
argument_list|)
expr_stmt|;
name|archive_le32enc
argument_list|(
name|a
operator|->
name|decmpfs_block_info
operator|++
argument_list|,
name|bytes_compressed
argument_list|)
expr_stmt|;
name|a
operator|->
name|compressed_rsrc_position_v
operator|+=
name|bytes_compressed
expr_stmt|;
comment|/* 	 * Write the compressed data to the resource fork. 	 */
name|bytes_used
operator|=
name|a
operator|->
name|compressed_buffer_size
operator|-
name|a
operator|->
name|compressed_buffer_remaining
expr_stmt|;
while|while
condition|(
name|bytes_used
operator|>=
name|COMPRESSED_W_SIZE
condition|)
block|{
name|ret
operator|=
name|hfs_write_compressed_data
argument_list|(
name|a
argument_list|,
name|COMPRESSED_W_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|bytes_used
operator|-=
name|COMPRESSED_W_SIZE
expr_stmt|;
if|if
condition|(
name|bytes_used
operator|>
name|COMPRESSED_W_SIZE
condition|)
name|memmove
argument_list|(
name|a
operator|->
name|compressed_buffer
argument_list|,
name|a
operator|->
name|compressed_buffer
operator|+
name|COMPRESSED_W_SIZE
argument_list|,
name|bytes_used
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|a
operator|->
name|compressed_buffer
argument_list|,
name|a
operator|->
name|compressed_buffer
operator|+
name|COMPRESSED_W_SIZE
argument_list|,
name|bytes_used
argument_list|)
expr_stmt|;
block|}
name|a
operator|->
name|compressed_buffer_remaining
operator|=
name|a
operator|->
name|compressed_buffer_size
operator|-
name|bytes_used
expr_stmt|;
comment|/* 	 * If the current block is the last block, write the remaining 	 * compressed data and the resource fork footer. 	 */
if|if
condition|(
name|a
operator|->
name|file_remaining_bytes
operator|==
literal|0
condition|)
block|{
name|size_t
name|rsrc_size
decl_stmt|;
name|int64_t
name|bk
decl_stmt|;
comment|/* Append the resource footer. */
name|rsrc_size
operator|=
name|hfs_set_resource_fork_footer
argument_list|(
name|a
operator|->
name|compressed_buffer
operator|+
name|bytes_used
argument_list|,
name|a
operator|->
name|compressed_buffer_remaining
argument_list|)
expr_stmt|;
name|ret
operator|=
name|hfs_write_compressed_data
argument_list|(
name|a
argument_list|,
name|bytes_used
operator|+
name|rsrc_size
argument_list|)
expr_stmt|;
name|a
operator|->
name|compressed_buffer_remaining
operator|=
name|a
operator|->
name|compressed_buffer_size
expr_stmt|;
comment|/* If the compressed size is not enough smaller than 		 * the uncompressed size. cancel HFS+ compression. 		 * TODO: study a behavior of ditto utility and improve 		 * the condition to fall back into no HFS+ compression. */
name|bk
operator|=
name|HFS_BLOCKS
argument_list|(
name|a
operator|->
name|compressed_rsrc_position
argument_list|)
expr_stmt|;
name|bk
operator|+=
name|bk
operator|>>
literal|7
expr_stmt|;
if|if
condition|(
name|bk
operator|>
name|HFS_BLOCKS
argument_list|(
name|a
operator|->
name|filesize
argument_list|)
condition|)
return|return
name|hfs_decompress
argument_list|(
name|a
argument_list|)
return|;
comment|/* 		 * Write the resourcefork header. 		 */
if|if
condition|(
name|ret
operator|==
name|ARCHIVE_OK
condition|)
name|ret
operator|=
name|hfs_write_resource_fork_header
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|/* 		 * Finish HFS+ Compression. 		 * - Write the decmpfs xattr. 		 * - Set the UF_COMPRESSED file flag. 		 */
if|if
condition|(
name|ret
operator|==
name|ARCHIVE_OK
condition|)
name|ret
operator|=
name|hfs_write_decmpfs
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|ARCHIVE_OK
condition|)
name|ret
operator|=
name|hfs_set_compressed_fflag
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|hfs_write_decmpfs_block
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|buff
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|buffer_to_write
decl_stmt|;
name|size_t
name|bytes_to_write
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|decmpfs_block_count
operator|==
operator|(
name|unsigned
operator|)
operator|-
literal|1
condition|)
block|{
name|void
modifier|*
name|new_block
decl_stmt|;
name|size_t
name|new_size
decl_stmt|;
name|unsigned
name|int
name|block_count
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|decmpfs_header_p
operator|==
name|NULL
condition|)
block|{
name|new_block
operator|=
name|malloc
argument_list|(
name|MAX_DECMPFS_XATTR_SIZE
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_block
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for decmpfs"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|a
operator|->
name|decmpfs_header_p
operator|=
name|new_block
expr_stmt|;
block|}
name|a
operator|->
name|decmpfs_attr_size
operator|=
name|DECMPFS_HEADER_SIZE
expr_stmt|;
name|archive_le32enc
argument_list|(
operator|&
name|a
operator|->
name|decmpfs_header_p
index|[
name|DECMPFS_COMPRESSION_MAGIC
index|]
argument_list|,
name|DECMPFS_MAGIC
argument_list|)
expr_stmt|;
name|archive_le32enc
argument_list|(
operator|&
name|a
operator|->
name|decmpfs_header_p
index|[
name|DECMPFS_COMPRESSION_TYPE
index|]
argument_list|,
name|CMP_RESOURCE_FORK
argument_list|)
expr_stmt|;
name|archive_le64enc
argument_list|(
operator|&
name|a
operator|->
name|decmpfs_header_p
index|[
name|DECMPFS_UNCOMPRESSED_SIZE
index|]
argument_list|,
name|a
operator|->
name|filesize
argument_list|)
expr_stmt|;
comment|/* Calculate a block count of the file. */
name|block_count
operator|=
operator|(
name|a
operator|->
name|filesize
operator|+
name|MAX_DECMPFS_BLOCK_SIZE
operator|-
literal|1
operator|)
operator|/
name|MAX_DECMPFS_BLOCK_SIZE
expr_stmt|;
comment|/* 		 * Allocate buffer for resource fork. 		 * Set up related pointers; 		 */
name|new_size
operator|=
name|RSRC_H_SIZE
operator|+
comment|/* header */
literal|4
operator|+
comment|/* Block count */
operator|(
name|block_count
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
literal|2
operator|)
operator|+
name|RSRC_F_SIZE
expr_stmt|;
comment|/* footer */
if|if
condition|(
name|new_size
operator|>
name|a
operator|->
name|resource_fork_allocated_size
condition|)
block|{
name|new_block
operator|=
name|realloc
argument_list|(
name|a
operator|->
name|resource_fork
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_block
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for ResourceFork"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|a
operator|->
name|resource_fork_allocated_size
operator|=
name|new_size
expr_stmt|;
name|a
operator|->
name|resource_fork
operator|=
name|new_block
expr_stmt|;
block|}
comment|/* Allocate uncompressed buffer */
if|if
condition|(
name|a
operator|->
name|uncompressed_buffer
operator|==
name|NULL
condition|)
block|{
name|new_block
operator|=
name|malloc
argument_list|(
name|MAX_DECMPFS_BLOCK_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_block
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for decmpfs"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|a
operator|->
name|uncompressed_buffer
operator|=
name|new_block
expr_stmt|;
block|}
name|a
operator|->
name|block_remaining_bytes
operator|=
name|MAX_DECMPFS_BLOCK_SIZE
expr_stmt|;
name|a
operator|->
name|file_remaining_bytes
operator|=
name|a
operator|->
name|filesize
expr_stmt|;
name|a
operator|->
name|compressed_buffer_remaining
operator|=
name|a
operator|->
name|compressed_buffer_size
expr_stmt|;
comment|/* 		 * Set up a resource fork. 		 */
name|a
operator|->
name|rsrc_xattr_options
operator|=
name|XATTR_CREATE
expr_stmt|;
comment|/* Get the position where we are going to set a bunch 		 * of block info. */
name|a
operator|->
name|decmpfs_block_info
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|a
operator|->
name|resource_fork
operator|+
name|RSRC_H_SIZE
operator|)
expr_stmt|;
comment|/* Set the block count to the resource fork. */
name|archive_le32enc
argument_list|(
name|a
operator|->
name|decmpfs_block_info
operator|++
argument_list|,
name|block_count
argument_list|)
expr_stmt|;
comment|/* Get the position where we are going to set compressed 		 * data. */
name|a
operator|->
name|compressed_rsrc_position
operator|=
name|RSRC_H_SIZE
operator|+
literal|4
operator|+
operator|(
name|block_count
operator|*
literal|8
operator|)
expr_stmt|;
name|a
operator|->
name|compressed_rsrc_position_v
operator|=
name|a
operator|->
name|compressed_rsrc_position
expr_stmt|;
name|a
operator|->
name|decmpfs_block_count
operator|=
name|block_count
expr_stmt|;
block|}
comment|/* Ignore redundant bytes. */
if|if
condition|(
name|a
operator|->
name|file_remaining_bytes
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|ssize_t
operator|)
name|size
operator|)
return|;
comment|/* Do not overrun a block size. */
if|if
condition|(
name|size
operator|>
name|a
operator|->
name|block_remaining_bytes
condition|)
name|bytes_to_write
operator|=
name|a
operator|->
name|block_remaining_bytes
expr_stmt|;
else|else
name|bytes_to_write
operator|=
name|size
expr_stmt|;
comment|/* Do not overrun the file size. */
if|if
condition|(
name|bytes_to_write
operator|>
name|a
operator|->
name|file_remaining_bytes
condition|)
name|bytes_to_write
operator|=
name|a
operator|->
name|file_remaining_bytes
expr_stmt|;
comment|/* For efficiency, if a copy length is full of the uncompressed 	 * buffer size, do not copy writing data to it. */
if|if
condition|(
name|bytes_to_write
operator|==
name|MAX_DECMPFS_BLOCK_SIZE
condition|)
name|buffer_to_write
operator|=
name|buff
expr_stmt|;
else|else
block|{
name|memcpy
argument_list|(
name|a
operator|->
name|uncompressed_buffer
operator|+
name|MAX_DECMPFS_BLOCK_SIZE
operator|-
name|a
operator|->
name|block_remaining_bytes
argument_list|,
name|buff
argument_list|,
name|bytes_to_write
argument_list|)
expr_stmt|;
name|buffer_to_write
operator|=
name|a
operator|->
name|uncompressed_buffer
expr_stmt|;
block|}
name|a
operator|->
name|block_remaining_bytes
operator|-=
name|bytes_to_write
expr_stmt|;
name|a
operator|->
name|file_remaining_bytes
operator|-=
name|bytes_to_write
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|block_remaining_bytes
operator|==
literal|0
operator|||
name|a
operator|->
name|file_remaining_bytes
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|hfs_drive_compressor
argument_list|(
name|a
argument_list|,
name|buffer_to_write
argument_list|,
name|MAX_DECMPFS_BLOCK_SIZE
operator|-
name|a
operator|->
name|block_remaining_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|a
operator|->
name|block_remaining_bytes
operator|=
name|MAX_DECMPFS_BLOCK_SIZE
expr_stmt|;
block|}
comment|/* Ignore redundant bytes. */
if|if
condition|(
name|a
operator|->
name|file_remaining_bytes
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|ssize_t
operator|)
name|size
operator|)
return|;
return|return
operator|(
name|bytes_to_write
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|hfs_write_data_block
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|buff
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|uint64_t
name|start_size
init|=
name|size
decl_stmt|;
name|ssize_t
name|bytes_written
init|=
literal|0
decl_stmt|;
name|ssize_t
name|bytes_to_write
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|filesize
operator|==
literal|0
operator|||
name|a
operator|->
name|fd
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
literal|0
argument_list|,
literal|"Attempt to write to an empty file"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* If this write would run beyond the file size, truncate it. */
if|if
condition|(
name|a
operator|->
name|filesize
operator|>=
literal|0
operator|&&
call|(
name|int64_t
call|)
argument_list|(
name|a
operator|->
name|offset
operator|+
name|size
argument_list|)
operator|>
name|a
operator|->
name|filesize
condition|)
name|start_size
operator|=
name|size
operator|=
call|(
name|size_t
call|)
argument_list|(
name|a
operator|->
name|filesize
operator|-
name|a
operator|->
name|offset
argument_list|)
expr_stmt|;
comment|/* Write the data. */
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|bytes_to_write
operator|=
name|size
expr_stmt|;
comment|/* Seek if necessary to the specified offset. */
if|if
condition|(
name|a
operator|->
name|offset
operator|<
name|a
operator|->
name|fd_offset
condition|)
block|{
comment|/* Can't support backward move. */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Seek failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|a
operator|->
name|offset
operator|>
name|a
operator|->
name|fd_offset
condition|)
block|{
name|int64_t
name|skip
init|=
name|a
operator|->
name|offset
operator|-
name|a
operator|->
name|fd_offset
decl_stmt|;
name|char
name|nullblock
index|[
literal|1024
index|]
decl_stmt|;
name|memset
argument_list|(
name|nullblock
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|nullblock
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|skip
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|skip
operator|>
operator|(
name|int64_t
operator|)
sizeof|sizeof
argument_list|(
name|nullblock
argument_list|)
condition|)
name|bytes_written
operator|=
name|hfs_write_decmpfs_block
argument_list|(
name|a
argument_list|,
name|nullblock
argument_list|,
sizeof|sizeof
argument_list|(
name|nullblock
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|bytes_written
operator|=
name|hfs_write_decmpfs_block
argument_list|(
name|a
argument_list|,
name|nullblock
argument_list|,
name|skip
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_written
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Write failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
name|skip
operator|-=
name|bytes_written
expr_stmt|;
block|}
name|a
operator|->
name|fd_offset
operator|=
name|a
operator|->
name|offset
expr_stmt|;
block|}
name|bytes_written
operator|=
name|hfs_write_decmpfs_block
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|bytes_to_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_written
operator|<
literal|0
condition|)
return|return
operator|(
name|bytes_written
operator|)
return|;
name|buff
operator|+=
name|bytes_written
expr_stmt|;
name|size
operator|-=
name|bytes_written
expr_stmt|;
name|a
operator|->
name|total_bytes_written
operator|+=
name|bytes_written
expr_stmt|;
name|a
operator|->
name|offset
operator|+=
name|bytes_written
expr_stmt|;
name|a
operator|->
name|fd_offset
operator|=
name|a
operator|->
name|offset
expr_stmt|;
block|}
return|return
operator|(
name|start_size
operator|-
name|size
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|ssize_t
name|hfs_write_data_block
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|buff
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|write_data_block
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|ssize_t
name|_archive_write_disk_data_block
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int64_t
name|offset
parameter_list|)
block|{
name|struct
name|archive_write_disk
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_write_disk
operator|*
operator|)
name|_a
decl_stmt|;
name|ssize_t
name|r
decl_stmt|;
name|archive_check_magic
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_WRITE_DISK_MAGIC
argument_list|,
name|ARCHIVE_STATE_DATA
argument_list|,
literal|"archive_write_data_block"
argument_list|)
expr_stmt|;
name|a
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|todo
operator|&
name|TODO_HFS_COMPRESSION
condition|)
name|r
operator|=
name|hfs_write_data_block
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|write_data_block
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|r
operator|<
name|size
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
literal|0
argument_list|,
literal|"Too much data: Truncating file at %ju bytes"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|a
operator|->
name|filesize
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
if|#
directive|if
name|ARCHIVE_VERSION_NUMBER
operator|<
literal|3999000
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|size
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|_archive_write_disk_data
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|archive_write_disk
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_write_disk
operator|*
operator|)
name|_a
decl_stmt|;
name|archive_check_magic
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_WRITE_DISK_MAGIC
argument_list|,
name|ARCHIVE_STATE_DATA
argument_list|,
literal|"archive_write_data"
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|todo
operator|&
name|TODO_HFS_COMPRESSION
condition|)
return|return
operator|(
name|hfs_write_data_block
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|size
argument_list|)
operator|)
return|;
return|return
operator|(
name|write_data_block
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_archive_write_disk_finish_entry
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_write_disk
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_write_disk
operator|*
operator|)
name|_a
decl_stmt|;
name|int
name|ret
init|=
name|ARCHIVE_OK
decl_stmt|;
name|archive_check_magic
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_WRITE_DISK_MAGIC
argument_list|,
name|ARCHIVE_STATE_HEADER
operator||
name|ARCHIVE_STATE_DATA
argument_list|,
literal|"archive_write_finish_entry"
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|archive
operator|.
name|state
operator|&
name|ARCHIVE_STATE_HEADER
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
name|archive_clear_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|)
expr_stmt|;
comment|/* Pad or truncate file to the right size. */
if|if
condition|(
name|a
operator|->
name|fd
operator|<
literal|0
condition|)
block|{
comment|/* There's no file. */
block|}
elseif|else
if|if
condition|(
name|a
operator|->
name|filesize
operator|<
literal|0
condition|)
block|{
comment|/* File size is unknown, so we can't set the size. */
block|}
elseif|else
if|if
condition|(
name|a
operator|->
name|fd_offset
operator|==
name|a
operator|->
name|filesize
condition|)
block|{
comment|/* Last write ended at exactly the filesize; we're done. */
comment|/* Hopefully, this is the common case. */
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
name|defined
argument_list|(
name|UF_COMPRESSED
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_ZLIB_H
argument_list|)
block|}
elseif|else
if|if
condition|(
name|a
operator|->
name|todo
operator|&
name|TODO_HFS_COMPRESSION
condition|)
block|{
name|char
name|null_d
index|[
literal|1024
index|]
decl_stmt|;
name|ssize_t
name|r
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|file_remaining_bytes
condition|)
name|memset
argument_list|(
name|null_d
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|null_d
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|a
operator|->
name|file_remaining_bytes
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|file_remaining_bytes
operator|>
sizeof|sizeof
argument_list|(
name|null_d
argument_list|)
condition|)
name|r
operator|=
name|hfs_write_data_block
argument_list|(
name|a
argument_list|,
name|null_d
argument_list|,
sizeof|sizeof
argument_list|(
name|null_d
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|hfs_write_data_block
argument_list|(
name|a
argument_list|,
name|null_d
argument_list|,
name|a
operator|->
name|file_remaining_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|r
operator|)
return|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
if|#
directive|if
name|HAVE_FTRUNCATE
if|if
condition|(
name|ftruncate
argument_list|(
name|a
operator|->
name|fd
argument_list|,
name|a
operator|->
name|filesize
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|a
operator|->
name|filesize
operator|==
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"File size could not be restored"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* 		 * Not all platforms implement the XSI option to 		 * extend files via ftruncate.  Stat() the file again 		 * to see what happened. 		 */
name|a
operator|->
name|pst
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|lazy_stat
argument_list|(
name|a
argument_list|)
operator|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ret
operator|)
return|;
comment|/* We can use lseek()/write() to extend the file if 		 * ftruncate didn't work or isn't available. */
if|if
condition|(
name|a
operator|->
name|st
operator|.
name|st_size
operator|<
name|a
operator|->
name|filesize
condition|)
block|{
specifier|const
name|char
name|nul
init|=
literal|'\0'
decl_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|a
operator|->
name|fd
argument_list|,
name|a
operator|->
name|filesize
operator|-
literal|1
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Seek failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|write
argument_list|(
name|a
operator|->
name|fd
argument_list|,
operator|&
name|nul
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Write to restore size failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|a
operator|->
name|pst
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Restore metadata. */
comment|/* 	 * This is specific to Mac OS X. 	 * If the current file is an AppleDouble file, it should be 	 * linked with the data fork file and remove it. 	 */
if|if
condition|(
name|a
operator|->
name|todo
operator|&
name|TODO_APPLEDOUBLE
condition|)
block|{
name|int
name|r2
init|=
name|fixup_appledouble
argument_list|(
name|a
argument_list|,
name|a
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|r2
operator|==
name|ARCHIVE_EOF
condition|)
block|{
comment|/* The current file has been successfully linked 			 * with the data fork file and removed. So there 			 * is nothing to do on the current file.  */
goto|goto
name|finish_metadata
goto|;
block|}
if|if
condition|(
name|r2
operator|<
name|ret
condition|)
name|ret
operator|=
name|r2
expr_stmt|;
block|}
comment|/* 	 * Look up the "real" UID only if we're going to need it. 	 * TODO: the TODO_SGID condition can be dropped here, can't it? 	 */
if|if
condition|(
name|a
operator|->
name|todo
operator|&
operator|(
name|TODO_OWNER
operator||
name|TODO_SUID
operator||
name|TODO_SGID
operator|)
condition|)
block|{
name|a
operator|->
name|uid
operator|=
name|archive_write_disk_uid
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|archive_entry_uname
argument_list|(
name|a
operator|->
name|entry
argument_list|)
argument_list|,
name|archive_entry_uid
argument_list|(
name|a
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Look up the "real" GID only if we're going to need it. */
comment|/* TODO: the TODO_SUID condition can be dropped here, can't it? */
if|if
condition|(
name|a
operator|->
name|todo
operator|&
operator|(
name|TODO_OWNER
operator||
name|TODO_SGID
operator||
name|TODO_SUID
operator|)
condition|)
block|{
name|a
operator|->
name|gid
operator|=
name|archive_write_disk_gid
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|archive_entry_gname
argument_list|(
name|a
operator|->
name|entry
argument_list|)
argument_list|,
name|archive_entry_gid
argument_list|(
name|a
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Restore ownership before set_mode tries to restore suid/sgid 	 * bits.  If we set the owner, we know what it is and can skip 	 * a stat() call to examine the ownership of the file on disk. 	 */
if|if
condition|(
name|a
operator|->
name|todo
operator|&
name|TODO_OWNER
condition|)
block|{
name|int
name|r2
init|=
name|set_ownership
argument_list|(
name|a
argument_list|)
decl_stmt|;
if|if
condition|(
name|r2
operator|<
name|ret
condition|)
name|ret
operator|=
name|r2
expr_stmt|;
block|}
comment|/* 	 * set_mode must precede ACLs on systems such as Solaris and 	 * FreeBSD where setting the mode implicitly clears extended ACLs 	 */
if|if
condition|(
name|a
operator|->
name|todo
operator|&
name|TODO_MODE
condition|)
block|{
name|int
name|r2
init|=
name|set_mode
argument_list|(
name|a
argument_list|,
name|a
operator|->
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|r2
operator|<
name|ret
condition|)
name|ret
operator|=
name|r2
expr_stmt|;
block|}
comment|/* 	 * Security-related extended attributes (such as 	 * security.capability on Linux) have to be restored last, 	 * since they're implicitly removed by other file changes. 	 */
if|if
condition|(
name|a
operator|->
name|todo
operator|&
name|TODO_XATTR
condition|)
block|{
name|int
name|r2
init|=
name|set_xattrs
argument_list|(
name|a
argument_list|)
decl_stmt|;
if|if
condition|(
name|r2
operator|<
name|ret
condition|)
name|ret
operator|=
name|r2
expr_stmt|;
block|}
comment|/* 	 * Some flags prevent file modification; they must be restored after 	 * file contents are written. 	 */
if|if
condition|(
name|a
operator|->
name|todo
operator|&
name|TODO_FFLAGS
condition|)
block|{
name|int
name|r2
init|=
name|set_fflags
argument_list|(
name|a
argument_list|)
decl_stmt|;
if|if
condition|(
name|r2
operator|<
name|ret
condition|)
name|ret
operator|=
name|r2
expr_stmt|;
block|}
comment|/* 	 * Time must follow most other metadata; 	 * otherwise atime will get changed. 	 */
if|if
condition|(
name|a
operator|->
name|todo
operator|&
name|TODO_TIMES
condition|)
block|{
name|int
name|r2
init|=
name|set_times_from_entry
argument_list|(
name|a
argument_list|)
decl_stmt|;
if|if
condition|(
name|r2
operator|<
name|ret
condition|)
name|ret
operator|=
name|r2
expr_stmt|;
block|}
comment|/* 	 * Mac extended metadata includes ACLs. 	 */
if|if
condition|(
name|a
operator|->
name|todo
operator|&
name|TODO_MAC_METADATA
condition|)
block|{
specifier|const
name|void
modifier|*
name|metadata
decl_stmt|;
name|size_t
name|metadata_size
decl_stmt|;
name|metadata
operator|=
name|archive_entry_mac_metadata
argument_list|(
name|a
operator|->
name|entry
argument_list|,
operator|&
name|metadata_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|metadata
operator|!=
name|NULL
operator|&&
name|metadata_size
operator|>
literal|0
condition|)
block|{
name|int
name|r2
init|=
name|set_mac_metadata
argument_list|(
name|a
argument_list|,
name|archive_entry_pathname
argument_list|(
name|a
operator|->
name|entry
argument_list|)
argument_list|,
name|metadata
argument_list|,
name|metadata_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|r2
operator|<
name|ret
condition|)
name|ret
operator|=
name|r2
expr_stmt|;
block|}
block|}
comment|/* 	 * ACLs must be restored after timestamps because there are 	 * ACLs that prevent attribute changes (including time). 	 */
if|if
condition|(
name|a
operator|->
name|todo
operator|&
name|TODO_ACLS
condition|)
block|{
name|int
name|r2
decl_stmt|;
name|r2
operator|=
name|archive_write_disk_set_acls
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|a
operator|->
name|fd
argument_list|,
name|archive_entry_pathname
argument_list|(
name|a
operator|->
name|entry
argument_list|)
argument_list|,
name|archive_entry_acl
argument_list|(
name|a
operator|->
name|entry
argument_list|)
argument_list|,
name|archive_entry_mode
argument_list|(
name|a
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r2
operator|<
name|ret
condition|)
name|ret
operator|=
name|r2
expr_stmt|;
block|}
name|finish_metadata
label|:
comment|/* If there's an fd, we can close it now. */
if|if
condition|(
name|a
operator|->
name|fd
operator|>=
literal|0
condition|)
block|{
name|close
argument_list|(
name|a
operator|->
name|fd
argument_list|)
expr_stmt|;
name|a
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* If there's an entry, we can release it now. */
if|if
condition|(
name|a
operator|->
name|entry
condition|)
block|{
name|archive_entry_free
argument_list|(
name|a
operator|->
name|entry
argument_list|)
expr_stmt|;
name|a
operator|->
name|entry
operator|=
name|NULL
expr_stmt|;
block|}
name|a
operator|->
name|archive
operator|.
name|state
operator|=
name|ARCHIVE_STATE_HEADER
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|archive_write_disk_set_group_lookup
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
name|void
modifier|*
name|private_data
parameter_list|,
name|int64_t
function_decl|(
modifier|*
name|lookup_gid
function_decl|)
parameter_list|(
name|void
modifier|*
name|private
parameter_list|,
specifier|const
name|char
modifier|*
name|gname
parameter_list|,
name|int64_t
name|gid
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|cleanup_gid
function_decl|)
parameter_list|(
name|void
modifier|*
name|private
parameter_list|)
parameter_list|)
block|{
name|struct
name|archive_write_disk
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_write_disk
operator|*
operator|)
name|_a
decl_stmt|;
name|archive_check_magic
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_WRITE_DISK_MAGIC
argument_list|,
name|ARCHIVE_STATE_ANY
argument_list|,
literal|"archive_write_disk_set_group_lookup"
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|cleanup_gid
operator|!=
name|NULL
operator|&&
name|a
operator|->
name|lookup_gid_data
operator|!=
name|NULL
condition|)
call|(
name|a
operator|->
name|cleanup_gid
call|)
argument_list|(
name|a
operator|->
name|lookup_gid_data
argument_list|)
expr_stmt|;
name|a
operator|->
name|lookup_gid
operator|=
name|lookup_gid
expr_stmt|;
name|a
operator|->
name|cleanup_gid
operator|=
name|cleanup_gid
expr_stmt|;
name|a
operator|->
name|lookup_gid_data
operator|=
name|private_data
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
name|int
name|archive_write_disk_set_user_lookup
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
name|void
modifier|*
name|private_data
parameter_list|,
name|int64_t
function_decl|(
modifier|*
name|lookup_uid
function_decl|)
parameter_list|(
name|void
modifier|*
name|private
parameter_list|,
specifier|const
name|char
modifier|*
name|uname
parameter_list|,
name|int64_t
name|uid
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|cleanup_uid
function_decl|)
parameter_list|(
name|void
modifier|*
name|private
parameter_list|)
parameter_list|)
block|{
name|struct
name|archive_write_disk
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_write_disk
operator|*
operator|)
name|_a
decl_stmt|;
name|archive_check_magic
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_WRITE_DISK_MAGIC
argument_list|,
name|ARCHIVE_STATE_ANY
argument_list|,
literal|"archive_write_disk_set_user_lookup"
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|cleanup_uid
operator|!=
name|NULL
operator|&&
name|a
operator|->
name|lookup_uid_data
operator|!=
name|NULL
condition|)
call|(
name|a
operator|->
name|cleanup_uid
call|)
argument_list|(
name|a
operator|->
name|lookup_uid_data
argument_list|)
expr_stmt|;
name|a
operator|->
name|lookup_uid
operator|=
name|lookup_uid
expr_stmt|;
name|a
operator|->
name|cleanup_uid
operator|=
name|cleanup_uid
expr_stmt|;
name|a
operator|->
name|lookup_uid_data
operator|=
name|private_data
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
name|int64_t
name|archive_write_disk_gid
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int64_t
name|id
parameter_list|)
block|{
name|struct
name|archive_write_disk
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_write_disk
operator|*
operator|)
name|_a
decl_stmt|;
name|archive_check_magic
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_WRITE_DISK_MAGIC
argument_list|,
name|ARCHIVE_STATE_ANY
argument_list|,
literal|"archive_write_disk_gid"
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|lookup_gid
condition|)
return|return
call|(
name|a
operator|->
name|lookup_gid
call|)
argument_list|(
name|a
operator|->
name|lookup_gid_data
argument_list|,
name|name
argument_list|,
name|id
argument_list|)
return|;
return|return
operator|(
name|id
operator|)
return|;
block|}
end_function

begin_function
name|int64_t
name|archive_write_disk_uid
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int64_t
name|id
parameter_list|)
block|{
name|struct
name|archive_write_disk
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_write_disk
operator|*
operator|)
name|_a
decl_stmt|;
name|archive_check_magic
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_WRITE_DISK_MAGIC
argument_list|,
name|ARCHIVE_STATE_ANY
argument_list|,
literal|"archive_write_disk_uid"
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|lookup_uid
condition|)
return|return
call|(
name|a
operator|->
name|lookup_uid
call|)
argument_list|(
name|a
operator|->
name|lookup_uid_data
argument_list|,
name|name
argument_list|,
name|id
argument_list|)
return|;
return|return
operator|(
name|id
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a new archive_write_disk object and initialize it with global state.  */
end_comment

begin_function
name|struct
name|archive
modifier|*
name|archive_write_disk_new
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|archive_write_disk
modifier|*
name|a
decl_stmt|;
name|a
operator|=
operator|(
expr|struct
name|archive_write_disk
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|a
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|a
operator|->
name|archive
operator|.
name|magic
operator|=
name|ARCHIVE_WRITE_DISK_MAGIC
expr_stmt|;
comment|/* We're ready to write a header immediately. */
name|a
operator|->
name|archive
operator|.
name|state
operator|=
name|ARCHIVE_STATE_HEADER
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|vtable
operator|=
name|archive_write_disk_vtable
argument_list|()
expr_stmt|;
name|a
operator|->
name|start_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Query and restore the umask. */
name|umask
argument_list|(
name|a
operator|->
name|user_umask
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_GETEUID
name|a
operator|->
name|user_uid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_GETEUID */
if|if
condition|(
name|archive_string_ensure
argument_list|(
operator|&
name|a
operator|->
name|path_safe
argument_list|,
literal|512
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
name|a
operator|->
name|decmpfs_compression_level
operator|=
literal|5
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|&
name|a
operator|->
name|archive
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If pathname is longer than PATH_MAX, chdir to a suitable  * intermediate dir and edit the path down to a shorter suffix.  Note  * that this routine never returns an error; if the chdir() attempt  * fails for any reason, we just go ahead with the long pathname.  The  * object creation is likely to fail, but any error will get handled  * at that time.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_FCHDIR
argument_list|)
operator|&&
name|defined
argument_list|(
name|PATH_MAX
argument_list|)
end_if

begin_function
specifier|static
name|void
name|edit_deep_directories
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|char
modifier|*
name|tail
init|=
name|a
operator|->
name|name
decl_stmt|;
comment|/* If path is short, avoid the open() below. */
if|if
condition|(
name|strlen
argument_list|(
name|tail
argument_list|)
operator|<
name|PATH_MAX
condition|)
return|return;
comment|/* Try to record our starting dir. */
name|a
operator|->
name|restore_pwd
operator|=
name|open
argument_list|(
literal|"."
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
operator||
name|O_CLOEXEC
argument_list|)
expr_stmt|;
name|__archive_ensure_cloexec_flag
argument_list|(
name|a
operator|->
name|restore_pwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|restore_pwd
operator|<
literal|0
condition|)
return|return;
comment|/* As long as the path is too long... */
while|while
condition|(
name|strlen
argument_list|(
name|tail
argument_list|)
operator|>=
name|PATH_MAX
condition|)
block|{
comment|/* Locate a dir prefix shorter than PATH_MAX. */
name|tail
operator|+=
name|PATH_MAX
operator|-
literal|8
expr_stmt|;
while|while
condition|(
name|tail
operator|>
name|a
operator|->
name|name
operator|&&
operator|*
name|tail
operator|!=
literal|'/'
condition|)
name|tail
operator|--
expr_stmt|;
comment|/* Exit if we find a too-long path component. */
if|if
condition|(
name|tail
operator|<=
name|a
operator|->
name|name
condition|)
return|return;
comment|/* Create the intermediate dir and chdir to it. */
operator|*
name|tail
operator|=
literal|'\0'
expr_stmt|;
comment|/* Terminate dir portion */
name|ret
operator|=
name|create_dir
argument_list|(
name|a
argument_list|,
name|a
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|ARCHIVE_OK
operator|&&
name|chdir
argument_list|(
name|a
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|)
name|ret
operator|=
name|ARCHIVE_FAILED
expr_stmt|;
operator|*
name|tail
operator|=
literal|'/'
expr_stmt|;
comment|/* Restore the / we removed. */
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return;
name|tail
operator|++
expr_stmt|;
comment|/* The chdir() succeeded; we've now shortened the path. */
name|a
operator|->
name|name
operator|=
name|tail
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The main restore function.  */
end_comment

begin_function
specifier|static
name|int
name|restore_entry
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|)
block|{
name|int
name|ret
init|=
name|ARCHIVE_OK
decl_stmt|,
name|en
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|flags
operator|&
name|ARCHIVE_EXTRACT_UNLINK
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|a
operator|->
name|mode
argument_list|)
condition|)
block|{
comment|/* 		 * TODO: Fix this.  Apparently, there are platforms 		 * that still allow root to hose the entire filesystem 		 * by unlinking a dir.  The S_ISDIR() test above 		 * prevents us from using unlink() here if the new 		 * object is a dir, but that doesn't mean the old 		 * object isn't a dir. 		 */
if|if
condition|(
name|a
operator|->
name|flags
operator|&
name|ARCHIVE_EXTRACT_CLEAR_NOCHANGE_FFLAGS
condition|)
operator|(
name|void
operator|)
name|clear_nochange_fflags
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|a
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We removed it, reset cached stat. */
name|a
operator|->
name|pst
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
comment|/* File didn't exist, that's just as good. */
block|}
elseif|else
if|if
condition|(
name|rmdir
argument_list|(
name|a
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* It was a dir, but now it's gone. */
name|a
operator|->
name|pst
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* We tried, but couldn't get rid of it. */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Could not unlink"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
block|}
comment|/* Try creating it first; if this fails, we'll try to recover. */
name|en
operator|=
name|create_filesystem_object
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|en
operator|==
name|ENOTDIR
operator|||
name|en
operator|==
name|ENOENT
operator|)
operator|&&
operator|!
operator|(
name|a
operator|->
name|flags
operator|&
name|ARCHIVE_EXTRACT_NO_AUTODIR
operator|)
condition|)
block|{
comment|/* If the parent dir doesn't exist, try creating it. */
name|create_parent_dir
argument_list|(
name|a
argument_list|,
name|a
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Now try to create the object again. */
name|en
operator|=
name|create_filesystem_object
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|en
operator|==
name|ENOENT
operator|)
operator|&&
operator|(
name|archive_entry_hardlink
argument_list|(
name|a
operator|->
name|entry
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|en
argument_list|,
literal|"Hard-link target '%s' does not exist."
argument_list|,
name|archive_entry_hardlink
argument_list|(
name|a
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|en
operator|==
name|EISDIR
operator|||
name|en
operator|==
name|EEXIST
operator|)
operator|&&
operator|(
name|a
operator|->
name|flags
operator|&
name|ARCHIVE_EXTRACT_NO_OVERWRITE
operator|)
condition|)
block|{
comment|/* If we're not overwriting, we're done. */
name|archive_entry_unset_size
argument_list|(
name|a
operator|->
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
comment|/* 	 * Some platforms return EISDIR if you call 	 * open(O_WRONLY | O_EXCL | O_CREAT) on a directory, some 	 * return EEXIST.  POSIX is ambiguous, requiring EISDIR 	 * for open(O_WRONLY) on a dir and EEXIST for open(O_EXCL | O_CREAT) 	 * on an existing item. 	 */
if|if
condition|(
name|en
operator|==
name|EISDIR
condition|)
block|{
comment|/* A dir is in the way of a non-dir, rmdir it. */
if|if
condition|(
name|rmdir
argument_list|(
name|a
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Can't remove already-existing dir"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|a
operator|->
name|pst
operator|=
name|NULL
expr_stmt|;
comment|/* Try again. */
name|en
operator|=
name|create_filesystem_object
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|en
operator|==
name|EEXIST
condition|)
block|{
comment|/* 		 * We know something is in the way, but we don't know what; 		 * we need to find out before we go any further. 		 */
name|int
name|r
init|=
literal|0
decl_stmt|;
comment|/* 		 * The SECURE_SYMLINKS logic has already removed a 		 * symlink to a dir if the client wants that.  So 		 * follow the symlink if we're creating a dir. 		 */
if|if
condition|(
name|S_ISDIR
argument_list|(
name|a
operator|->
name|mode
argument_list|)
condition|)
name|r
operator|=
name|stat
argument_list|(
name|a
operator|->
name|name
argument_list|,
operator|&
name|a
operator|->
name|st
argument_list|)
expr_stmt|;
comment|/* 		 * If it's not a dir (or it's a broken symlink), 		 * then don't follow it. 		 */
if|if
condition|(
name|r
operator|!=
literal|0
operator|||
operator|!
name|S_ISDIR
argument_list|(
name|a
operator|->
name|mode
argument_list|)
condition|)
name|r
operator|=
name|lstat
argument_list|(
name|a
operator|->
name|name
argument_list|,
operator|&
name|a
operator|->
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Can't stat existing object"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
comment|/* 		 * NO_OVERWRITE_NEWER doesn't apply to directories. 		 */
if|if
condition|(
operator|(
name|a
operator|->
name|flags
operator|&
name|ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER
operator|)
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|a
operator|->
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|older
argument_list|(
operator|&
operator|(
name|a
operator|->
name|st
operator|)
argument_list|,
name|a
operator|->
name|entry
argument_list|)
condition|)
block|{
name|archive_entry_unset_size
argument_list|(
name|a
operator|->
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
block|}
comment|/* If it's our archive, we're done. */
if|if
condition|(
name|a
operator|->
name|skip_file_set
operator|&&
name|a
operator|->
name|st
operator|.
name|st_dev
operator|==
operator|(
name|dev_t
operator|)
name|a
operator|->
name|skip_file_dev
operator|&&
name|a
operator|->
name|st
operator|.
name|st_ino
operator|==
operator|(
name|ino_t
operator|)
name|a
operator|->
name|skip_file_ino
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
literal|0
argument_list|,
literal|"Refusing to overwrite archive"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|a
operator|->
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* A non-dir is in the way, unlink it. */
if|if
condition|(
name|a
operator|->
name|flags
operator|&
name|ARCHIVE_EXTRACT_CLEAR_NOCHANGE_FFLAGS
condition|)
operator|(
name|void
operator|)
name|clear_nochange_fflags
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|a
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Can't unlink already-existing object"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|a
operator|->
name|pst
operator|=
name|NULL
expr_stmt|;
comment|/* Try again. */
name|en
operator|=
name|create_filesystem_object
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|a
operator|->
name|mode
argument_list|)
condition|)
block|{
comment|/* A dir is in the way of a non-dir, rmdir it. */
if|if
condition|(
name|a
operator|->
name|flags
operator|&
name|ARCHIVE_EXTRACT_CLEAR_NOCHANGE_FFLAGS
condition|)
operator|(
name|void
operator|)
name|clear_nochange_fflags
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|rmdir
argument_list|(
name|a
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Can't replace existing directory with non-directory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
comment|/* Try again. */
name|en
operator|=
name|create_filesystem_object
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * There's a dir in the way of a dir.  Don't 			 * waste time with rmdir()/mkdir(), just fix 			 * up the permissions on the existing dir. 			 * Note that we don't change perms on existing 			 * dirs unless _EXTRACT_PERM is specified. 			 */
if|if
condition|(
operator|(
name|a
operator|->
name|mode
operator|!=
name|a
operator|->
name|st
operator|.
name|st_mode
operator|)
operator|&&
operator|(
name|a
operator|->
name|todo
operator|&
name|TODO_MODE_FORCE
operator|)
condition|)
name|a
operator|->
name|deferred
operator||=
operator|(
name|a
operator|->
name|todo
operator|&
name|TODO_MODE
operator|)
expr_stmt|;
comment|/* Ownership doesn't need deferred fixup. */
name|en
operator|=
literal|0
expr_stmt|;
comment|/* Forget the EEXIST. */
block|}
block|}
if|if
condition|(
name|en
condition|)
block|{
comment|/* Everything failed; give up here. */
if|if
condition|(
operator|(
operator|&
name|a
operator|->
name|archive
operator|)
operator|->
name|error
operator|==
name|NULL
condition|)
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|en
argument_list|,
literal|"Can't create '%s'"
argument_list|,
name|a
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|a
operator|->
name|pst
operator|=
name|NULL
expr_stmt|;
comment|/* Cached stat data no longer valid. */
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns 0 if creation succeeds, or else returns errno value from  * the failed system call.   Note:  This function should only ever perform  * a single system call.  */
end_comment

begin_function
specifier|static
name|int
name|create_filesystem_object
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|)
block|{
comment|/* Create the entry. */
specifier|const
name|char
modifier|*
name|linkname
decl_stmt|;
name|mode_t
name|final_mode
decl_stmt|,
name|mode
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* these for check_symlinks_fsobj */
name|char
modifier|*
name|linkname_copy
decl_stmt|;
comment|/* non-const copy of linkname */
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|archive_string
name|error_string
decl_stmt|;
name|int
name|error_number
decl_stmt|;
comment|/* We identify hard/symlinks according to the link names. */
comment|/* Since link(2) and symlink(2) don't handle modes, we're done here. */
name|linkname
operator|=
name|archive_entry_hardlink
argument_list|(
name|a
operator|->
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|linkname
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
operator|!
name|HAVE_LINK
return|return
operator|(
name|EPERM
operator|)
return|;
else|#
directive|else
name|archive_string_init
argument_list|(
operator|&
name|error_string
argument_list|)
expr_stmt|;
name|linkname_copy
operator|=
name|strdup
argument_list|(
name|linkname
argument_list|)
expr_stmt|;
if|if
condition|(
name|linkname_copy
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
comment|/* 		 * TODO: consider using the cleaned-up path as the link 		 * target? 		 */
name|r
operator|=
name|cleanup_pathname_fsobj
argument_list|(
name|linkname_copy
argument_list|,
operator|&
name|error_number
argument_list|,
operator|&
name|error_string
argument_list|,
name|a
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|error_number
argument_list|,
literal|"%s"
argument_list|,
name|error_string
operator|.
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|linkname_copy
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|error_string
argument_list|)
expr_stmt|;
comment|/* 			 * EPERM is more appropriate than error_number for our 			 * callers 			 */
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
name|r
operator|=
name|check_symlinks_fsobj
argument_list|(
name|linkname_copy
argument_list|,
operator|&
name|error_number
argument_list|,
operator|&
name|error_string
argument_list|,
name|a
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|error_number
argument_list|,
literal|"%s"
argument_list|,
name|error_string
operator|.
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|linkname_copy
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|error_string
argument_list|)
expr_stmt|;
comment|/* 			 * EPERM is more appropriate than error_number for our 			 * callers 			 */
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
name|free
argument_list|(
name|linkname_copy
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|error_string
argument_list|)
expr_stmt|;
name|r
operator|=
name|link
argument_list|(
name|linkname
argument_list|,
name|a
operator|->
name|name
argument_list|)
condition|?
name|errno
else|:
literal|0
expr_stmt|;
comment|/* 		 * New cpio and pax formats allow hardlink entries 		 * to carry data, so we may have to open the file 		 * for hardlink entries. 		 * 		 * If the hardlink was successfully created and 		 * the archive doesn't have carry data for it, 		 * consider it to be non-authoritative for meta data. 		 * This is consistent with GNU tar and BSD pax. 		 * If the hardlink does carry data, let the last 		 * archive entry decide ownership. 		 */
if|if
condition|(
name|r
operator|==
literal|0
operator|&&
name|a
operator|->
name|filesize
operator|<=
literal|0
condition|)
block|{
name|a
operator|->
name|todo
operator|=
literal|0
expr_stmt|;
name|a
operator|->
name|deferred
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
literal|0
operator|&&
name|a
operator|->
name|filesize
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_LSTAT
name|r
operator|=
name|lstat
argument_list|(
name|a
operator|->
name|name
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
else|#
directive|else
name|r
operator|=
name|stat
argument_list|(
name|a
operator|->
name|name
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
name|r
operator|=
name|errno
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|st
operator|.
name|st_mode
operator|&
name|AE_IFMT
operator|)
operator|==
name|AE_IFREG
condition|)
block|{
name|a
operator|->
name|fd
operator|=
name|open
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
operator||
name|O_BINARY
operator||
name|O_CLOEXEC
operator||
name|O_NOFOLLOW
argument_list|)
expr_stmt|;
name|__archive_ensure_cloexec_flag
argument_list|(
name|a
operator|->
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|fd
operator|<
literal|0
condition|)
name|r
operator|=
name|errno
expr_stmt|;
block|}
block|}
return|return
operator|(
name|r
operator|)
return|;
endif|#
directive|endif
block|}
name|linkname
operator|=
name|archive_entry_symlink
argument_list|(
name|a
operator|->
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|linkname
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
name|HAVE_SYMLINK
return|return
name|symlink
argument_list|(
name|linkname
argument_list|,
name|a
operator|->
name|name
argument_list|)
condition|?
name|errno
else|:
literal|0
return|;
else|#
directive|else
return|return
operator|(
name|EPERM
operator|)
return|;
endif|#
directive|endif
block|}
comment|/* 	 * The remaining system calls all set permissions, so let's 	 * try to take advantage of that to avoid an extra chmod() 	 * call.  (Recall that umask is set to zero right now!) 	 */
comment|/* Mode we want for the final restored object (w/o file type bits). */
name|final_mode
operator|=
name|a
operator|->
name|mode
operator|&
literal|07777
expr_stmt|;
comment|/* 	 * The mode that will actually be restored in this step.  Note 	 * that SUID, SGID, etc, require additional work to ensure 	 * security, so we never restore them at this point. 	 */
name|mode
operator|=
name|final_mode
operator|&
literal|0777
operator|&
operator|~
name|a
operator|->
name|user_umask
expr_stmt|;
switch|switch
condition|(
name|a
operator|->
name|mode
operator|&
name|AE_IFMT
condition|)
block|{
default|default:
comment|/* POSIX requires that we fall through here. */
comment|/* FALLTHROUGH */
case|case
name|AE_IFREG
case|:
name|a
operator|->
name|fd
operator|=
name|open
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
operator||
name|O_BINARY
operator||
name|O_CLOEXEC
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|__archive_ensure_cloexec_flag
argument_list|(
name|a
operator|->
name|fd
argument_list|)
expr_stmt|;
name|r
operator|=
operator|(
name|a
operator|->
name|fd
operator|<
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|AE_IFCHR
case|:
ifdef|#
directive|ifdef
name|HAVE_MKNOD
comment|/* Note: we use AE_IFCHR for the case label, and 		 * S_IFCHR for the mknod() call.  This is correct.  */
name|r
operator|=
name|mknod
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|mode
operator||
name|S_IFCHR
argument_list|,
name|archive_entry_rdev
argument_list|(
name|a
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
comment|/* TODO: Find a better way to warn about our inability 		 * to restore a char device node. */
return|return
operator|(
name|EINVAL
operator|)
return|;
endif|#
directive|endif
comment|/* HAVE_MKNOD */
case|case
name|AE_IFBLK
case|:
ifdef|#
directive|ifdef
name|HAVE_MKNOD
name|r
operator|=
name|mknod
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|mode
operator||
name|S_IFBLK
argument_list|,
name|archive_entry_rdev
argument_list|(
name|a
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
comment|/* TODO: Find a better way to warn about our inability 		 * to restore a block device node. */
return|return
operator|(
name|EINVAL
operator|)
return|;
endif|#
directive|endif
comment|/* HAVE_MKNOD */
case|case
name|AE_IFDIR
case|:
name|mode
operator|=
operator|(
name|mode
operator||
name|MINIMUM_DIR_MODE
operator|)
operator|&
name|MAXIMUM_DIR_MODE
expr_stmt|;
name|r
operator|=
name|mkdir
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
comment|/* Defer setting dir times. */
name|a
operator|->
name|deferred
operator||=
operator|(
name|a
operator|->
name|todo
operator|&
name|TODO_TIMES
operator|)
expr_stmt|;
name|a
operator|->
name|todo
operator|&=
operator|~
name|TODO_TIMES
expr_stmt|;
comment|/* Never use an immediate chmod(). */
comment|/* We can't avoid the chmod() entirely if EXTRACT_PERM 			 * because of SysV SGID inheritance. */
if|if
condition|(
operator|(
name|mode
operator|!=
name|final_mode
operator|)
operator|||
operator|(
name|a
operator|->
name|flags
operator|&
name|ARCHIVE_EXTRACT_PERM
operator|)
condition|)
name|a
operator|->
name|deferred
operator||=
operator|(
name|a
operator|->
name|todo
operator|&
name|TODO_MODE
operator|)
expr_stmt|;
name|a
operator|->
name|todo
operator|&=
operator|~
name|TODO_MODE
expr_stmt|;
block|}
break|break;
case|case
name|AE_IFIFO
case|:
ifdef|#
directive|ifdef
name|HAVE_MKFIFO
name|r
operator|=
name|mkfifo
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
comment|/* TODO: Find a better way to warn about our inability 		 * to restore a fifo. */
return|return
operator|(
name|EINVAL
operator|)
return|;
endif|#
directive|endif
comment|/* HAVE_MKFIFO */
block|}
comment|/* All the system calls above set errno on failure. */
if|if
condition|(
name|r
condition|)
return|return
operator|(
name|errno
operator|)
return|;
comment|/* If we managed to set the final mode, we've avoided a chmod(). */
if|if
condition|(
name|mode
operator|==
name|final_mode
condition|)
name|a
operator|->
name|todo
operator|&=
operator|~
name|TODO_MODE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Cleanup function for archive_extract.  Mostly, this involves processing  * the fixup list, which is used to address a number of problems:  *   * Dir permissions might prevent us from restoring a file in that  *     dir, so we restore the dir with minimum 0700 permissions first,  *     then correct the mode at the end.  *   * Similarly, the act of restoring a file touches the directory  *     and changes the timestamp on the dir, so we have to touch-up dir  *     timestamps at the end as well.  *   * Some file flags can interfere with the restore by, for example,  *     preventing the creation of hardlinks to those files.  *   * Mac OS extended metadata includes ACLs, so must be deferred on dirs.  *  * Note that tar/cpio do not require that archives be in a particular  * order; there is no way to know when the last file has been restored  * within a directory, so there's no way to optimize the memory usage  * here by fixing up the directory any earlier than the  * end-of-archive.  *  * XXX TODO: Directory ACLs should be restored here, for the same  * reason we set directory perms here. XXX  */
end_comment

begin_function
specifier|static
name|int
name|_archive_write_disk_close
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_write_disk
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_write_disk
operator|*
operator|)
name|_a
decl_stmt|;
name|struct
name|fixup_entry
modifier|*
name|next
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|archive_check_magic
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_WRITE_DISK_MAGIC
argument_list|,
name|ARCHIVE_STATE_HEADER
operator||
name|ARCHIVE_STATE_DATA
argument_list|,
literal|"archive_write_disk_close"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_archive_write_disk_finish_entry
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|)
expr_stmt|;
comment|/* Sort dir list so directories are fixed up in depth-first order. */
name|p
operator|=
name|sort_dir_list
argument_list|(
name|a
operator|->
name|fixup_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|a
operator|->
name|pst
operator|=
name|NULL
expr_stmt|;
comment|/* Mark stat cache as out-of-date. */
if|if
condition|(
name|p
operator|->
name|fixup
operator|&
name|TODO_TIMES
condition|)
block|{
name|set_times
argument_list|(
name|a
argument_list|,
operator|-
literal|1
argument_list|,
name|p
operator|->
name|mode
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|atime
argument_list|,
name|p
operator|->
name|atime_nanos
argument_list|,
name|p
operator|->
name|birthtime
argument_list|,
name|p
operator|->
name|birthtime_nanos
argument_list|,
name|p
operator|->
name|mtime
argument_list|,
name|p
operator|->
name|mtime_nanos
argument_list|,
name|p
operator|->
name|ctime
argument_list|,
name|p
operator|->
name|ctime_nanos
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|fixup
operator|&
name|TODO_MODE_BASE
condition|)
name|chmod
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|fixup
operator|&
name|TODO_ACLS
condition|)
name|archive_write_disk_set_acls
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
operator|-
literal|1
argument_list|,
name|p
operator|->
name|name
argument_list|,
operator|&
name|p
operator|->
name|acl
argument_list|,
name|p
operator|->
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|fixup
operator|&
name|TODO_FFLAGS
condition|)
name|set_fflags_platform
argument_list|(
name|a
argument_list|,
operator|-
literal|1
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|mode
argument_list|,
name|p
operator|->
name|fflags_set
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|fixup
operator|&
name|TODO_MAC_METADATA
condition|)
name|set_mac_metadata
argument_list|(
name|a
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|mac_metadata
argument_list|,
name|p
operator|->
name|mac_metadata_size
argument_list|)
expr_stmt|;
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|archive_acl_clear
argument_list|(
operator|&
name|p
operator|->
name|acl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|mac_metadata
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|next
expr_stmt|;
block|}
name|a
operator|->
name|fixup_list
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_archive_write_disk_free
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_write_disk
modifier|*
name|a
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|_a
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_WRITE_DISK_MAGIC
argument_list|,
name|ARCHIVE_STATE_ANY
operator||
name|ARCHIVE_STATE_FATAL
argument_list|,
literal|"archive_write_disk_free"
argument_list|)
expr_stmt|;
name|a
operator|=
operator|(
expr|struct
name|archive_write_disk
operator|*
operator|)
name|_a
expr_stmt|;
name|ret
operator|=
name|_archive_write_disk_close
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|)
expr_stmt|;
name|archive_write_disk_set_group_lookup
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|archive_write_disk_set_user_lookup
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|entry
condition|)
name|archive_entry_free
argument_list|(
name|a
operator|->
name|entry
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|a
operator|->
name|_name_data
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|a
operator|->
name|archive
operator|.
name|error_string
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|a
operator|->
name|path_safe
argument_list|)
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|magic
operator|=
literal|0
expr_stmt|;
name|__archive_clean
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|a
operator|->
name|decmpfs_header_p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|a
operator|->
name|resource_fork
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|a
operator|->
name|compressed_buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|a
operator|->
name|uncompressed_buffer
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
name|defined
argument_list|(
name|UF_COMPRESSED
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_SYS_XATTR_H
argument_list|)
expr|\
operator|&&
name|defined
argument_list|(
name|HAVE_ZLIB_H
argument_list|)
if|if
condition|(
name|a
operator|->
name|stream_valid
condition|)
block|{
switch|switch
condition|(
name|deflateEnd
argument_list|(
operator|&
name|a
operator|->
name|stream
argument_list|)
condition|)
block|{
case|case
name|Z_OK
case|:
break|break;
default|default:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Failed to clean up compressor"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
name|free
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Simple O(n log n) merge sort to order the fixup list.  In  * particular, we want to restore dir timestamps depth-first.  */
end_comment

begin_function
specifier|static
name|struct
name|fixup_entry
modifier|*
name|sort_dir_list
parameter_list|(
name|struct
name|fixup_entry
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|fixup_entry
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* A one-item list is already sorted. */
if|if
condition|(
name|p
operator|->
name|next
operator|==
name|NULL
condition|)
return|return
operator|(
name|p
operator|)
return|;
comment|/* Step 1: split the list. */
name|t
operator|=
name|p
expr_stmt|;
name|a
operator|=
name|p
operator|->
name|next
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|a
operator|!=
name|NULL
condition|)
block|{
comment|/* Step a twice, t once. */
name|a
operator|=
name|a
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|a
operator|!=
name|NULL
condition|)
name|a
operator|=
name|a
operator|->
name|next
expr_stmt|;
name|t
operator|=
name|t
operator|->
name|next
expr_stmt|;
block|}
comment|/* Now, t is at the mid-point, so break the list here. */
name|b
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|a
operator|=
name|p
expr_stmt|;
comment|/* Step 2: Recursively sort the two sub-lists. */
name|a
operator|=
name|sort_dir_list
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|b
operator|=
name|sort_dir_list
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* Step 3: Merge the returned lists. */
comment|/* Pick the first element for the merged list. */
if|if
condition|(
name|strcmp
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|b
operator|->
name|name
argument_list|)
operator|>
literal|0
condition|)
block|{
name|t
operator|=
name|p
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|a
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|p
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|b
operator|->
name|next
expr_stmt|;
block|}
comment|/* Always put the later element on the list first. */
while|while
condition|(
name|a
operator|!=
name|NULL
operator|&&
name|b
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|b
operator|->
name|name
argument_list|)
operator|>
literal|0
condition|)
block|{
name|t
operator|->
name|next
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|a
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|t
operator|->
name|next
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|b
operator|->
name|next
expr_stmt|;
block|}
name|t
operator|=
name|t
operator|->
name|next
expr_stmt|;
block|}
comment|/* Only one list is non-empty, so just splice it on. */
if|if
condition|(
name|a
operator|!=
name|NULL
condition|)
name|t
operator|->
name|next
operator|=
name|a
expr_stmt|;
if|if
condition|(
name|b
operator|!=
name|NULL
condition|)
name|t
operator|->
name|next
operator|=
name|b
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns a new, initialized fixup entry.  *  * TODO: Reduce the memory requirements for this list by using a tree  * structure rather than a simple list of names.  */
end_comment

begin_function
specifier|static
name|struct
name|fixup_entry
modifier|*
name|new_fixup
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|)
block|{
name|struct
name|fixup_entry
modifier|*
name|fe
decl_stmt|;
name|fe
operator|=
operator|(
expr|struct
name|fixup_entry
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fixup_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fe
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for a fixup"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|fe
operator|->
name|next
operator|=
name|a
operator|->
name|fixup_list
expr_stmt|;
name|a
operator|->
name|fixup_list
operator|=
name|fe
expr_stmt|;
name|fe
operator|->
name|fixup
operator|=
literal|0
expr_stmt|;
name|fe
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
return|return
operator|(
name|fe
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns a fixup structure for the current entry.  */
end_comment

begin_function
specifier|static
name|struct
name|fixup_entry
modifier|*
name|current_fixup
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|)
block|{
if|if
condition|(
name|a
operator|->
name|current_fixup
operator|==
name|NULL
condition|)
name|a
operator|->
name|current_fixup
operator|=
name|new_fixup
argument_list|(
name|a
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
return|return
operator|(
name|a
operator|->
name|current_fixup
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Error helper for new *_fsobj functions */
end_comment

begin_function
specifier|static
name|void
name|fsobj_error
parameter_list|(
name|int
modifier|*
name|a_eno
parameter_list|,
name|struct
name|archive_string
modifier|*
name|a_estr
parameter_list|,
name|int
name|err
parameter_list|,
specifier|const
name|char
modifier|*
name|errstr
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
if|if
condition|(
name|a_eno
condition|)
operator|*
name|a_eno
operator|=
name|err
expr_stmt|;
if|if
condition|(
name|a_estr
condition|)
name|archive_string_sprintf
argument_list|(
name|a_estr
argument_list|,
literal|"%s%s"
argument_list|,
name|errstr
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * TODO: Someday, integrate this with the deep dir support; they both  * scan the path and both can be optimized by comparing against other  * recent paths.  */
end_comment

begin_comment
comment|/* TODO: Extend this to support symlinks on Windows Vista and later. */
end_comment

begin_comment
comment|/*  * Checks the given path to see if any elements along it are symlinks.  Returns  * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.  */
end_comment

begin_function
specifier|static
name|int
name|check_symlinks_fsobj
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|int
modifier|*
name|a_eno
parameter_list|,
name|struct
name|archive_string
modifier|*
name|a_estr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_LSTAT
argument_list|)
comment|/* Platform doesn't have lstat, so we can't look for symlinks. */
operator|(
name|void
operator|)
name|path
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|error_number
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|error_string
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|flags
expr_stmt|;
comment|/* UNUSED */
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
else|#
directive|else
name|int
name|res
init|=
name|ARCHIVE_OK
decl_stmt|;
name|char
modifier|*
name|tail
decl_stmt|;
name|char
modifier|*
name|head
decl_stmt|;
name|int
name|last
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|r
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|restore_pwd
decl_stmt|;
comment|/* Nothing to do here if name is empty */
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
comment|/* 	 * Guard against symlink tricks.  Reject any archive entry whose 	 * destination would be altered by a symlink. 	 * 	 * Walk the filename in chunks separated by '/'.  For each segment: 	 *  - if it doesn't exist, continue 	 *  - if it's symlink, abort or remove it 	 *  - if it's a directory and it's not the last chunk, cd into it 	 * As we go: 	 *  head points to the current (relative) path 	 *  tail points to the temporary \0 terminating the segment we're 	 *      currently examining 	 *  c holds what used to be in *tail 	 *  last is 1 if this is the last tail 	 */
name|restore_pwd
operator|=
name|open
argument_list|(
literal|"."
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
operator||
name|O_CLOEXEC
argument_list|)
expr_stmt|;
name|__archive_ensure_cloexec_flag
argument_list|(
name|restore_pwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|restore_pwd
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|head
operator|=
name|path
expr_stmt|;
name|tail
operator|=
name|path
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
comment|/* TODO: reintroduce a safe cache here? */
comment|/* Skip the root directory if the path is absolute. */
if|if
condition|(
name|tail
operator|==
name|path
operator|&&
name|tail
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
operator|++
name|tail
expr_stmt|;
comment|/* Keep going until we've checked the entire name. 	 * head, tail, path all alias the same string, which is 	 * temporarily zeroed at tail, so be careful restoring the 	 * stashed (c=tail[0]) for error messages. 	 * Exiting the loop with break is okay; continue is not. 	 */
while|while
condition|(
operator|!
name|last
condition|)
block|{
comment|/* 		 * Skip the separator we just consumed, plus any adjacent ones 		 */
while|while
condition|(
operator|*
name|tail
operator|==
literal|'/'
condition|)
operator|++
name|tail
expr_stmt|;
comment|/* Skip the next path element. */
while|while
condition|(
operator|*
name|tail
operator|!=
literal|'\0'
operator|&&
operator|*
name|tail
operator|!=
literal|'/'
condition|)
operator|++
name|tail
expr_stmt|;
comment|/* is this the last path component? */
name|last
operator|=
operator|(
name|tail
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|tail
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|tail
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
expr_stmt|;
comment|/* temporarily truncate the string here */
name|c
operator|=
name|tail
index|[
literal|0
index|]
expr_stmt|;
name|tail
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Check that we haven't hit a symlink. */
name|r
operator|=
name|lstat
argument_list|(
name|head
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|tail
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
comment|/* We've hit a dir that doesn't exist; stop now. */
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
break|break;
block|}
else|else
block|{
comment|/* 				 * Treat any other error as fatal - best to be 				 * paranoid here. 				 * Note: This effectively disables deep 				 * directory support when security checks are 				 * enabled. Otherwise, very long pathnames that 				 * trigger an error here could evade the 				 * sandbox. 				 * TODO: We could do better, but it would 				 * probably require merging the symlink checks 				 * with the deep-directory editing. 				 */
name|fsobj_error
argument_list|(
name|a_eno
argument_list|,
name|a_estr
argument_list|,
name|errno
argument_list|,
literal|"Could not stat "
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|res
operator|=
name|ARCHIVE_FAILED
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|last
condition|)
block|{
if|if
condition|(
name|chdir
argument_list|(
name|head
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tail
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|fsobj_error
argument_list|(
name|a_eno
argument_list|,
name|a_estr
argument_list|,
name|errno
argument_list|,
literal|"Could not chdir "
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|res
operator|=
operator|(
name|ARCHIVE_FATAL
operator|)
expr_stmt|;
break|break;
block|}
comment|/* Our view is now from inside this dir: */
name|head
operator|=
name|tail
operator|+
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|S_ISLNK
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|last
condition|)
block|{
comment|/* 				 * Last element is symlink; remove it 				 * so we can overwrite it with the 				 * item being extracted. 				 */
if|if
condition|(
name|unlink
argument_list|(
name|head
argument_list|)
condition|)
block|{
name|tail
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|fsobj_error
argument_list|(
name|a_eno
argument_list|,
name|a_estr
argument_list|,
name|errno
argument_list|,
literal|"Could not remove symlink "
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|res
operator|=
name|ARCHIVE_FAILED
expr_stmt|;
break|break;
block|}
comment|/* 				 * Even if we did remove it, a warning 				 * is in order.  The warning is silly, 				 * though, if we're just replacing one 				 * symlink with another symlink. 				 */
name|tail
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
comment|/* 				 * FIXME:  not sure how important this is to 				 * restore 				 */
comment|/* 				if (!S_ISLNK(path)) { 					fsobj_error(a_eno, a_estr, 0, 					    "Removing symlink ", path); 				} 				*/
comment|/* Symlink gone.  No more problem! */
name|res
operator|=
name|ARCHIVE_OK
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|ARCHIVE_EXTRACT_UNLINK
condition|)
block|{
comment|/* User asked us to remove problems. */
if|if
condition|(
name|unlink
argument_list|(
name|head
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tail
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|fsobj_error
argument_list|(
name|a_eno
argument_list|,
name|a_estr
argument_list|,
literal|0
argument_list|,
literal|"Cannot remove intervening "
literal|"symlink "
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|res
operator|=
name|ARCHIVE_FAILED
expr_stmt|;
break|break;
block|}
name|tail
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|ARCHIVE_EXTRACT_SECURE_SYMLINKS
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * We are not the last element and we want to 				 * follow symlinks if they are a directory. 				 *  				 * This is needed to extract hardlinks over 				 * symlinks. 				 */
name|r
operator|=
name|stat
argument_list|(
name|head
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|tail
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
break|break;
block|}
else|else
block|{
name|fsobj_error
argument_list|(
name|a_eno
argument_list|,
name|a_estr
argument_list|,
name|errno
argument_list|,
literal|"Could not stat "
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|res
operator|=
operator|(
name|ARCHIVE_FAILED
operator|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|chdir
argument_list|(
name|head
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tail
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|fsobj_error
argument_list|(
name|a_eno
argument_list|,
name|a_estr
argument_list|,
name|errno
argument_list|,
literal|"Could not chdir "
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|res
operator|=
operator|(
name|ARCHIVE_FATAL
operator|)
expr_stmt|;
break|break;
block|}
comment|/* 					 * Our view is now from inside 					 * this dir: 					 */
name|head
operator|=
name|tail
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tail
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|fsobj_error
argument_list|(
name|a_eno
argument_list|,
name|a_estr
argument_list|,
literal|0
argument_list|,
literal|"Cannot extract through "
literal|"symlink "
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|res
operator|=
name|ARCHIVE_FAILED
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|tail
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|fsobj_error
argument_list|(
name|a_eno
argument_list|,
name|a_estr
argument_list|,
literal|0
argument_list|,
literal|"Cannot extract through symlink "
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|res
operator|=
name|ARCHIVE_FAILED
expr_stmt|;
break|break;
block|}
block|}
comment|/* be sure to always maintain this */
name|tail
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|tail
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|tail
operator|++
expr_stmt|;
comment|/* Advance to the next segment. */
block|}
comment|/* Catches loop exits via break */
name|tail
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FCHDIR
comment|/* If we changed directory above, restore it here. */
if|if
condition|(
name|restore_pwd
operator|>=
literal|0
condition|)
block|{
name|r
operator|=
name|fchdir
argument_list|(
name|restore_pwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|fsobj_error
argument_list|(
name|a_eno
argument_list|,
name|a_estr
argument_list|,
name|errno
argument_list|,
literal|"chdir() failure"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|restore_pwd
argument_list|)
expr_stmt|;
name|restore_pwd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|res
operator|=
operator|(
name|ARCHIVE_FATAL
operator|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* TODO: reintroduce a safe cache here? */
return|return
name|res
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise  * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}  */
end_comment

begin_function
specifier|static
name|int
name|check_symlinks
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|archive_string
name|error_string
decl_stmt|;
name|int
name|error_number
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|error_string
argument_list|)
expr_stmt|;
name|rc
operator|=
name|check_symlinks_fsobj
argument_list|(
name|a
operator|->
name|name
argument_list|,
operator|&
name|error_number
argument_list|,
operator|&
name|error_string
argument_list|,
name|a
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|error_number
argument_list|,
literal|"%s"
argument_list|,
name|error_string
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
name|archive_string_free
argument_list|(
operator|&
name|error_string
argument_list|)
expr_stmt|;
name|a
operator|->
name|pst
operator|=
name|NULL
expr_stmt|;
comment|/* to be safe */
return|return
name|rc
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_comment
comment|/*  * 1. Convert a path separator from '\' to '/' .  *    We shouldn't check multibyte character directly because some  *    character-set have been using the '\' character for a part of  *    its multibyte character code.  * 2. Replace unusable characters in Windows with underscore('_').  * See also : http://msdn.microsoft.com/en-us/library/aa365247.aspx  */
end_comment

begin_function
specifier|static
name|void
name|cleanup_pathname_win
parameter_list|(
name|char
modifier|*
name|path
parameter_list|)
block|{
name|wchar_t
name|wc
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|alen
decl_stmt|,
name|l
decl_stmt|;
name|int
name|mb
decl_stmt|,
name|complete
decl_stmt|,
name|utf8
decl_stmt|;
name|alen
operator|=
literal|0
expr_stmt|;
name|mb
operator|=
literal|0
expr_stmt|;
name|complete
operator|=
literal|1
expr_stmt|;
name|utf8
operator|=
operator|(
name|strcmp
argument_list|(
name|nl_langinfo
argument_list|(
name|CODESET
argument_list|)
argument_list|,
literal|"UTF-8"
argument_list|)
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|path
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
operator|++
name|alen
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
comment|/* If previous byte is smaller than 128, 			 * this is not second byte of multibyte characters, 			 * so we can replace '\' with '/'. */
if|if
condition|(
name|utf8
operator|||
operator|!
name|mb
condition|)
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
else|else
name|complete
operator|=
literal|0
expr_stmt|;
comment|/* uncompleted. */
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
operator|>
literal|127
condition|)
name|mb
operator|=
literal|1
expr_stmt|;
else|else
name|mb
operator|=
literal|0
expr_stmt|;
comment|/* Rewrite the path name if its next character is unusable. */
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
operator|||
operator|*
name|p
operator|==
literal|'*'
operator|||
operator|*
name|p
operator|==
literal|'?'
operator|||
operator|*
name|p
operator|==
literal|'"'
operator|||
operator|*
name|p
operator|==
literal|'<'
operator|||
operator|*
name|p
operator|==
literal|'>'
operator|||
operator|*
name|p
operator|==
literal|'|'
condition|)
operator|*
name|p
operator|=
literal|'_'
expr_stmt|;
block|}
if|if
condition|(
name|complete
condition|)
return|return;
comment|/* 	 * Convert path separator in wide-character. 	 */
name|p
operator|=
name|path
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
name|alen
condition|)
block|{
name|l
operator|=
name|mbtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|p
argument_list|,
name|alen
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|l
operator|==
literal|1
operator|&&
name|wc
operator|==
literal|L'
expr|\\'
condition|)
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
name|p
operator|+=
name|l
expr_stmt|;
name|alen
operator|-=
name|l
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Canonicalize the pathname.  In particular, this strips duplicate  * '/' characters, '.' elements, and trailing '/'.  It also raises an  * error for an empty path, a trailing '..', (if _SECURE_NODOTDOT is  * set) any '..' in the path or (if ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS  * is set) if the path is absolute.  */
end_comment

begin_function
specifier|static
name|int
name|cleanup_pathname_fsobj
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|int
modifier|*
name|a_eno
parameter_list|,
name|struct
name|archive_string
modifier|*
name|a_estr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|char
modifier|*
name|dest
decl_stmt|,
modifier|*
name|src
decl_stmt|;
name|char
name|separator
init|=
literal|'\0'
decl_stmt|;
name|dest
operator|=
name|src
operator|=
name|path
expr_stmt|;
if|if
condition|(
operator|*
name|src
operator|==
literal|'\0'
condition|)
block|{
name|fsobj_error
argument_list|(
name|a_eno
argument_list|,
name|a_estr
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Invalid empty "
argument_list|,
literal|"pathname"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
name|cleanup_pathname_win
argument_list|(
name|path
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Skip leading '/'. */
if|if
condition|(
operator|*
name|src
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS
condition|)
block|{
name|fsobj_error
argument_list|(
name|a_eno
argument_list|,
name|a_estr
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Path is "
argument_list|,
literal|"absolute"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|separator
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
comment|/* Scan the pathname one element at a time. */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* src points to first char after '/' */
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* Found '//', ignore second one. */
name|src
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Ignore trailing '.' */
break|break;
block|}
elseif|else
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* Skip './'. */
name|src
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|==
literal|'/'
operator|||
name|src
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Conditionally warn about '..' */
if|if
condition|(
name|flags
operator|&
name|ARCHIVE_EXTRACT_SECURE_NODOTDOT
condition|)
block|{
name|fsobj_error
argument_list|(
name|a_eno
argument_list|,
name|a_estr
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Path contains "
argument_list|,
literal|"'..'"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
block|}
comment|/* 				 * Note: Under no circumstances do we 				 * remove '..' elements.  In 				 * particular, restoring 				 * '/foo/../bar/' should create the 				 * 'foo' dir as a side-effect. 				 */
block|}
block|}
comment|/* Copy current element, including leading '/'. */
if|if
condition|(
name|separator
condition|)
operator|*
name|dest
operator|++
operator|=
literal|'/'
expr_stmt|;
while|while
condition|(
operator|*
name|src
operator|!=
literal|'\0'
operator|&&
operator|*
name|src
operator|!=
literal|'/'
condition|)
block|{
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|src
operator|==
literal|'\0'
condition|)
break|break;
comment|/* Skip '/' separator. */
name|separator
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
comment|/* 	 * We've just copied zero or more path elements, not including the 	 * final '/'. 	 */
if|if
condition|(
name|dest
operator|==
name|path
condition|)
block|{
comment|/* 		 * Nothing got copied.  The path must have been something 		 * like '.' or '/' or './' or '/././././/./'. 		 */
if|if
condition|(
name|separator
condition|)
operator|*
name|dest
operator|++
operator|=
literal|'/'
expr_stmt|;
else|else
operator|*
name|dest
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
comment|/* Terminate the result. */
operator|*
name|dest
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cleanup_pathname
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|archive_string
name|error_string
decl_stmt|;
name|int
name|error_number
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|error_string
argument_list|)
expr_stmt|;
name|rc
operator|=
name|cleanup_pathname_fsobj
argument_list|(
name|a
operator|->
name|name
argument_list|,
operator|&
name|error_number
argument_list|,
operator|&
name|error_string
argument_list|,
name|a
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|error_number
argument_list|,
literal|"%s"
argument_list|,
name|error_string
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
name|archive_string_free
argument_list|(
operator|&
name|error_string
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/*  * Create the parent directory of the specified path, assuming path  * is already in mutable storage.  */
end_comment

begin_function
specifier|static
name|int
name|create_parent_dir
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|,
name|char
modifier|*
name|path
parameter_list|)
block|{
name|char
modifier|*
name|slash
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* Remove tail element to obtain parent name. */
name|slash
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
name|r
operator|=
name|create_dir
argument_list|(
name|a
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|*
name|slash
operator|=
literal|'/'
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create the specified dir, recursing to create parents as necessary.  *  * Returns ARCHIVE_OK if the path exists when we're done here.  * Otherwise, returns ARCHIVE_FAILED.  * Assumes path is in mutable storage; path is unchanged on exit.  */
end_comment

begin_function
specifier|static
name|int
name|create_dir
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|,
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|fixup_entry
modifier|*
name|le
decl_stmt|;
name|char
modifier|*
name|slash
decl_stmt|,
modifier|*
name|base
decl_stmt|;
name|mode_t
name|mode_final
decl_stmt|,
name|mode
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* Check for special names and just skip them. */
name|slash
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
operator|==
name|NULL
condition|)
name|base
operator|=
name|path
expr_stmt|;
else|else
name|base
operator|=
name|slash
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|base
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|base
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|base
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|base
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|base
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|base
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
comment|/* Don't bother trying to create null path, '.', or '..'. */
if|if
condition|(
name|slash
operator|!=
name|NULL
condition|)
block|{
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
name|r
operator|=
name|create_dir
argument_list|(
name|a
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|*
name|slash
operator|=
literal|'/'
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
comment|/* 	 * Yes, this should be stat() and not lstat().  Using lstat() 	 * here loses the ability to extract through symlinks.  Also note 	 * that this should not use the a->st cache. 	 */
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
if|if
condition|(
operator|(
name|a
operator|->
name|flags
operator|&
name|ARCHIVE_EXTRACT_NO_OVERWRITE
operator|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|EEXIST
argument_list|,
literal|"Can't create directory '%s'"
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
if|if
condition|(
name|unlink
argument_list|(
name|path
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Can't create directory '%s': "
literal|"Conflicting file cannot be removed"
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|errno
operator|!=
name|ENOENT
operator|&&
name|errno
operator|!=
name|ENOTDIR
condition|)
block|{
comment|/* Stat failed? */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Can't test directory '%s'"
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|slash
operator|!=
name|NULL
condition|)
block|{
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
name|r
operator|=
name|create_dir
argument_list|(
name|a
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|*
name|slash
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
comment|/* 	 * Mode we want for the final restored directory.  Per POSIX, 	 * implicitly-created dirs must be created obeying the umask. 	 * There's no mention whether this is different for privileged 	 * restores (which the rest of this code handles by pretending 	 * umask=0).  I've chosen here to always obey the user's umask for 	 * implicit dirs, even if _EXTRACT_PERM was specified. 	 */
name|mode_final
operator|=
name|DEFAULT_DIR_MODE
operator|&
operator|~
name|a
operator|->
name|user_umask
expr_stmt|;
comment|/* Mode we want on disk during the restore process. */
name|mode
operator|=
name|mode_final
expr_stmt|;
name|mode
operator||=
name|MINIMUM_DIR_MODE
expr_stmt|;
name|mode
operator|&=
name|MAXIMUM_DIR_MODE
expr_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mode
operator|!=
name|mode_final
condition|)
block|{
name|le
operator|=
name|new_fixup
argument_list|(
name|a
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|le
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|le
operator|->
name|fixup
operator||=
name|TODO_MODE_BASE
expr_stmt|;
name|le
operator|->
name|mode
operator|=
name|mode_final
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
comment|/* 	 * Without the following check, a/b/../b/c/d fails at the 	 * second visit to 'b', so 'd' can't be created.  Note that we 	 * don't add it to the fixup list here, as it's already been 	 * added. 	 */
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
operator|&&
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Failed to create dir '%s'"
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Note: Although we can skip setting the user id if the desired user  * id matches the current user, we cannot skip setting the group, as  * many systems set the gid based on the containing directory.  So  * we have to perform a chown syscall if we want to set the SGID  * bit.  (The alternative is to stat() and then possibly chown(); it's  * more efficient to skip the stat() and just always chown().)  Note  * that a successful chown() here clears the TODO_SGID_CHECK bit, which  * allows set_mode to skip the stat() check for the GID.  */
end_comment

begin_function
specifier|static
name|int
name|set_ownership
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|__CYGWIN__
comment|/* unfortunately, on win32 there is no 'root' user with uid 0,    so we just have to try the chown and see if it works */
comment|/* If we know we can't change it, don't bother trying. */
if|if
condition|(
name|a
operator|->
name|user_uid
operator|!=
literal|0
operator|&&
name|a
operator|->
name|user_uid
operator|!=
name|a
operator|->
name|uid
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Can't set UID=%jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|a
operator|->
name|uid
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_FCHOWN
comment|/* If we have an fd, we can avoid a race. */
if|if
condition|(
name|a
operator|->
name|fd
operator|>=
literal|0
operator|&&
name|fchown
argument_list|(
name|a
operator|->
name|fd
argument_list|,
name|a
operator|->
name|uid
argument_list|,
name|a
operator|->
name|gid
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We've set owner and know uid/gid are correct. */
name|a
operator|->
name|todo
operator|&=
operator|~
operator|(
name|TODO_OWNER
operator||
name|TODO_SGID_CHECK
operator||
name|TODO_SUID_CHECK
operator|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* We prefer lchown() but will use chown() if that's all we have. */
comment|/* Of course, if we have neither, this will always fail. */
ifdef|#
directive|ifdef
name|HAVE_LCHOWN
if|if
condition|(
name|lchown
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|a
operator|->
name|uid
argument_list|,
name|a
operator|->
name|gid
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We've set owner and know uid/gid are correct. */
name|a
operator|->
name|todo
operator|&=
operator|~
operator|(
name|TODO_OWNER
operator||
name|TODO_SGID_CHECK
operator||
name|TODO_SUID_CHECK
operator|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
elif|#
directive|elif
name|HAVE_CHOWN
if|if
condition|(
operator|!
name|S_ISLNK
argument_list|(
name|a
operator|->
name|mode
argument_list|)
operator|&&
name|chown
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|a
operator|->
name|uid
argument_list|,
name|a
operator|->
name|gid
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We've set owner and know uid/gid are correct. */
name|a
operator|->
name|todo
operator|&=
operator|~
operator|(
name|TODO_OWNER
operator||
name|TODO_SGID_CHECK
operator||
name|TODO_SUID_CHECK
operator|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
endif|#
directive|endif
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Can't set user=%jd/group=%jd for %s"
argument_list|,
operator|(
name|intmax_t
operator|)
name|a
operator|->
name|uid
argument_list|,
operator|(
name|intmax_t
operator|)
name|a
operator|->
name|gid
argument_list|,
name|a
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Note: Returns 0 on success, non-zero on failure.  */
end_comment

begin_function
specifier|static
name|int
name|set_time
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|mode
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|time_t
name|atime
parameter_list|,
name|long
name|atime_nsec
parameter_list|,
name|time_t
name|mtime
parameter_list|,
name|long
name|mtime_nsec
parameter_list|)
block|{
comment|/* Select the best implementation for this platform. */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UTIMENSAT
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_FUTIMENS
argument_list|)
comment|/* 	 * utimensat() and futimens() are defined in 	 * POSIX.1-2008. They support ns resolution and setting times 	 * on fds and symlinks. 	 */
name|struct
name|timespec
name|ts
index|[
literal|2
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|mode
expr_stmt|;
comment|/* UNUSED */
name|ts
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|atime
expr_stmt|;
name|ts
index|[
literal|0
index|]
operator|.
name|tv_nsec
operator|=
name|atime_nsec
expr_stmt|;
name|ts
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|mtime
expr_stmt|;
name|ts
index|[
literal|1
index|]
operator|.
name|tv_nsec
operator|=
name|mtime_nsec
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
return|return
name|futimens
argument_list|(
name|fd
argument_list|,
name|ts
argument_list|)
return|;
return|return
name|utimensat
argument_list|(
name|AT_FDCWD
argument_list|,
name|name
argument_list|,
name|ts
argument_list|,
name|AT_SYMLINK_NOFOLLOW
argument_list|)
return|;
elif|#
directive|elif
name|HAVE_UTIMES
comment|/* 	 * The utimes()-family functions support Âµs-resolution and 	 * setting times fds and symlinks.  utimes() is documented as 	 * LEGACY by POSIX, futimes() and lutimes() are not described 	 * in POSIX. 	 */
name|struct
name|timeval
name|times
index|[
literal|2
index|]
decl_stmt|;
name|times
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|atime
expr_stmt|;
name|times
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
name|atime_nsec
operator|/
literal|1000
expr_stmt|;
name|times
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|mtime
expr_stmt|;
name|times
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
name|mtime_nsec
operator|/
literal|1000
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FUTIMES
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
return|return
operator|(
name|futimes
argument_list|(
name|fd
argument_list|,
name|times
argument_list|)
operator|)
return|;
else|#
directive|else
operator|(
name|void
operator|)
name|fd
expr_stmt|;
comment|/* UNUSED */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_LUTIMES
operator|(
name|void
operator|)
name|mode
expr_stmt|;
comment|/* UNUSED */
return|return
operator|(
name|lutimes
argument_list|(
name|name
argument_list|,
name|times
argument_list|)
operator|)
return|;
else|#
directive|else
if|if
condition|(
name|S_ISLNK
argument_list|(
name|mode
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|utimes
argument_list|(
name|name
argument_list|,
name|times
argument_list|)
operator|)
return|;
endif|#
directive|endif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_UTIME
argument_list|)
comment|/* 	 * utime() is POSIX-standard but only supports 1s resolution and 	 * does not support fds or symlinks. 	 */
name|struct
name|utimbuf
name|times
decl_stmt|;
operator|(
name|void
operator|)
name|fd
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|name
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|atime_nsec
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|mtime_nsec
expr_stmt|;
comment|/* UNUSED */
name|times
operator|.
name|actime
operator|=
name|atime
expr_stmt|;
name|times
operator|.
name|modtime
operator|=
name|mtime
expr_stmt|;
if|if
condition|(
name|S_ISLNK
argument_list|(
name|mode
argument_list|)
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
return|return
operator|(
name|utime
argument_list|(
name|name
argument_list|,
operator|&
name|times
argument_list|)
operator|)
return|;
else|#
directive|else
comment|/* 	 * We don't know how to set the time on this platform. 	 */
operator|(
name|void
operator|)
name|fd
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|mode
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|name
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|atime_nsec
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|mtime_nsec
expr_stmt|;
comment|/* UNUSED */
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|F_SETTIMES
end_ifdef

begin_function
specifier|static
name|int
name|set_time_tru64
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|mode
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|time_t
name|atime
parameter_list|,
name|long
name|atime_nsec
parameter_list|,
name|time_t
name|mtime
parameter_list|,
name|long
name|mtime_nsec
parameter_list|,
name|time_t
name|ctime
parameter_list|,
name|long
name|ctime_nsec
parameter_list|)
block|{
name|struct
name|attr_timbuf
name|tstamp
decl_stmt|;
name|tstamp
operator|.
name|atime
operator|.
name|tv_sec
operator|=
name|atime
expr_stmt|;
name|tstamp
operator|.
name|mtime
operator|.
name|tv_sec
operator|=
name|mtime
expr_stmt|;
name|tstamp
operator|.
name|ctime
operator|.
name|tv_sec
operator|=
name|ctime
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|&&
name|defined
argument_list|(
name|__ia64
argument_list|)
name|tstamp
operator|.
name|atime
operator|.
name|tv_nsec
operator|=
name|atime_nsec
expr_stmt|;
name|tstamp
operator|.
name|mtime
operator|.
name|tv_nsec
operator|=
name|mtime_nsec
expr_stmt|;
name|tstamp
operator|.
name|ctime
operator|.
name|tv_nsec
operator|=
name|ctime_nsec
expr_stmt|;
else|#
directive|else
name|tstamp
operator|.
name|atime
operator|.
name|tv_usec
operator|=
name|atime_nsec
operator|/
literal|1000
expr_stmt|;
name|tstamp
operator|.
name|mtime
operator|.
name|tv_usec
operator|=
name|mtime_nsec
operator|/
literal|1000
expr_stmt|;
name|tstamp
operator|.
name|ctime
operator|.
name|tv_usec
operator|=
name|ctime_nsec
operator|/
literal|1000
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETTIMES
argument_list|,
operator|&
name|tstamp
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* F_SETTIMES */
end_comment

begin_function
specifier|static
name|int
name|set_times
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|mode
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|time_t
name|atime
parameter_list|,
name|long
name|atime_nanos
parameter_list|,
name|time_t
name|birthtime
parameter_list|,
name|long
name|birthtime_nanos
parameter_list|,
name|time_t
name|mtime
parameter_list|,
name|long
name|mtime_nanos
parameter_list|,
name|time_t
name|cctime
parameter_list|,
name|long
name|ctime_nanos
parameter_list|)
block|{
comment|/* Note: set_time doesn't use libarchive return conventions! 	 * It uses syscall conventions.  So 0 here instead of ARCHIVE_OK. */
name|int
name|r1
init|=
literal|0
decl_stmt|,
name|r2
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|F_SETTIMES
comment|/* 	 * on Tru64 try own fcntl first which can restore even the 	 * ctime, fall back to default code path below if it fails 	 * or if we are not running as root 	 */
if|if
condition|(
name|a
operator|->
name|user_uid
operator|==
literal|0
operator|&&
name|set_time_tru64
argument_list|(
name|fd
argument_list|,
name|mode
argument_list|,
name|name
argument_list|,
name|atime
argument_list|,
name|atime_nanos
argument_list|,
name|mtime
argument_list|,
name|mtime_nanos
argument_list|,
name|cctime
argument_list|,
name|ctime_nanos
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
else|#
directive|else
comment|/* Tru64 */
operator|(
name|void
operator|)
name|cctime
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|ctime_nanos
expr_stmt|;
comment|/* UNUSED */
endif|#
directive|endif
comment|/* Tru64 */
ifdef|#
directive|ifdef
name|HAVE_STRUCT_STAT_ST_BIRTHTIME
comment|/* 	 * If you have struct stat.st_birthtime, we assume BSD 	 * birthtime semantics, in which {f,l,}utimes() updates 	 * birthtime to earliest mtime.  So we set the time twice, 	 * first using the birthtime, then using the mtime.  If 	 * birthtime == mtime, this isn't necessary, so we skip it. 	 * If birthtime> mtime, then this won't work, so we skip it. 	 */
if|if
condition|(
name|birthtime
operator|<
name|mtime
operator|||
operator|(
name|birthtime
operator|==
name|mtime
operator|&&
name|birthtime_nanos
operator|<
name|mtime_nanos
operator|)
condition|)
name|r1
operator|=
name|set_time
argument_list|(
name|fd
argument_list|,
name|mode
argument_list|,
name|name
argument_list|,
name|atime
argument_list|,
name|atime_nanos
argument_list|,
name|birthtime
argument_list|,
name|birthtime_nanos
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|birthtime
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|birthtime_nanos
expr_stmt|;
comment|/* UNUSED */
endif|#
directive|endif
name|r2
operator|=
name|set_time
argument_list|(
name|fd
argument_list|,
name|mode
argument_list|,
name|name
argument_list|,
name|atime
argument_list|,
name|atime_nanos
argument_list|,
name|mtime
argument_list|,
name|mtime_nanos
argument_list|)
expr_stmt|;
if|if
condition|(
name|r1
operator|!=
literal|0
operator|||
name|r2
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Can't restore time"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_times_from_entry
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|)
block|{
name|time_t
name|atime
decl_stmt|,
name|birthtime
decl_stmt|,
name|mtime
decl_stmt|,
name|cctime
decl_stmt|;
name|long
name|atime_nsec
decl_stmt|,
name|birthtime_nsec
decl_stmt|,
name|mtime_nsec
decl_stmt|,
name|ctime_nsec
decl_stmt|;
comment|/* Suitable defaults. */
name|atime
operator|=
name|birthtime
operator|=
name|mtime
operator|=
name|cctime
operator|=
name|a
operator|->
name|start_time
expr_stmt|;
name|atime_nsec
operator|=
name|birthtime_nsec
operator|=
name|mtime_nsec
operator|=
name|ctime_nsec
operator|=
literal|0
expr_stmt|;
comment|/* If no time was provided, we're done. */
if|if
condition|(
operator|!
name|archive_entry_atime_is_set
argument_list|(
name|a
operator|->
name|entry
argument_list|)
if|#
directive|if
name|HAVE_STRUCT_STAT_ST_BIRTHTIME
operator|&&
operator|!
name|archive_entry_birthtime_is_set
argument_list|(
name|a
operator|->
name|entry
argument_list|)
endif|#
directive|endif
operator|&&
operator|!
name|archive_entry_mtime_is_set
argument_list|(
name|a
operator|->
name|entry
argument_list|)
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
if|if
condition|(
name|archive_entry_atime_is_set
argument_list|(
name|a
operator|->
name|entry
argument_list|)
condition|)
block|{
name|atime
operator|=
name|archive_entry_atime
argument_list|(
name|a
operator|->
name|entry
argument_list|)
expr_stmt|;
name|atime_nsec
operator|=
name|archive_entry_atime_nsec
argument_list|(
name|a
operator|->
name|entry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|archive_entry_birthtime_is_set
argument_list|(
name|a
operator|->
name|entry
argument_list|)
condition|)
block|{
name|birthtime
operator|=
name|archive_entry_birthtime
argument_list|(
name|a
operator|->
name|entry
argument_list|)
expr_stmt|;
name|birthtime_nsec
operator|=
name|archive_entry_birthtime_nsec
argument_list|(
name|a
operator|->
name|entry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|archive_entry_mtime_is_set
argument_list|(
name|a
operator|->
name|entry
argument_list|)
condition|)
block|{
name|mtime
operator|=
name|archive_entry_mtime
argument_list|(
name|a
operator|->
name|entry
argument_list|)
expr_stmt|;
name|mtime_nsec
operator|=
name|archive_entry_mtime_nsec
argument_list|(
name|a
operator|->
name|entry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|archive_entry_ctime_is_set
argument_list|(
name|a
operator|->
name|entry
argument_list|)
condition|)
block|{
name|cctime
operator|=
name|archive_entry_ctime
argument_list|(
name|a
operator|->
name|entry
argument_list|)
expr_stmt|;
name|ctime_nsec
operator|=
name|archive_entry_ctime_nsec
argument_list|(
name|a
operator|->
name|entry
argument_list|)
expr_stmt|;
block|}
return|return
name|set_times
argument_list|(
name|a
argument_list|,
name|a
operator|->
name|fd
argument_list|,
name|a
operator|->
name|mode
argument_list|,
name|a
operator|->
name|name
argument_list|,
name|atime
argument_list|,
name|atime_nsec
argument_list|,
name|birthtime
argument_list|,
name|birthtime_nsec
argument_list|,
name|mtime
argument_list|,
name|mtime_nsec
argument_list|,
name|cctime
argument_list|,
name|ctime_nsec
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_mode
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|r
init|=
name|ARCHIVE_OK
decl_stmt|;
name|mode
operator|&=
literal|07777
expr_stmt|;
comment|/* Strip off file type bits. */
if|if
condition|(
name|a
operator|->
name|todo
operator|&
name|TODO_SGID_CHECK
condition|)
block|{
comment|/* 		 * If we don't know the GID is right, we must stat() 		 * to verify it.  We can't just check the GID of this 		 * process, since systems sometimes set GID from 		 * the enclosing dir or based on ACLs. 		 */
if|if
condition|(
operator|(
name|r
operator|=
name|lazy_stat
argument_list|(
name|a
argument_list|)
operator|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|pst
operator|->
name|st_gid
operator|!=
name|a
operator|->
name|gid
condition|)
block|{
name|mode
operator|&=
operator|~
name|S_ISGID
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|flags
operator|&
name|ARCHIVE_EXTRACT_OWNER
condition|)
block|{
comment|/* 				 * This is only an error if you 				 * requested owner restore.  If you 				 * didn't, we'll try to restore 				 * sgid/suid, but won't consider it a 				 * problem if we can't. 				 */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
operator|-
literal|1
argument_list|,
literal|"Can't restore SGID bit"
argument_list|)
expr_stmt|;
name|r
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
block|}
comment|/* While we're here, double-check the UID. */
if|if
condition|(
name|a
operator|->
name|pst
operator|->
name|st_uid
operator|!=
name|a
operator|->
name|uid
operator|&&
operator|(
name|a
operator|->
name|todo
operator|&
name|TODO_SUID
operator|)
condition|)
block|{
name|mode
operator|&=
operator|~
name|S_ISUID
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|flags
operator|&
name|ARCHIVE_EXTRACT_OWNER
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
operator|-
literal|1
argument_list|,
literal|"Can't restore SUID bit"
argument_list|)
expr_stmt|;
name|r
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
block|}
name|a
operator|->
name|todo
operator|&=
operator|~
name|TODO_SGID_CHECK
expr_stmt|;
name|a
operator|->
name|todo
operator|&=
operator|~
name|TODO_SUID_CHECK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|->
name|todo
operator|&
name|TODO_SUID_CHECK
condition|)
block|{
comment|/* 		 * If we don't know the UID is right, we can just check 		 * the user, since all systems set the file UID from 		 * the process UID. 		 */
if|if
condition|(
name|a
operator|->
name|user_uid
operator|!=
name|a
operator|->
name|uid
condition|)
block|{
name|mode
operator|&=
operator|~
name|S_ISUID
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|flags
operator|&
name|ARCHIVE_EXTRACT_OWNER
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
operator|-
literal|1
argument_list|,
literal|"Can't make file SUID"
argument_list|)
expr_stmt|;
name|r
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
block|}
name|a
operator|->
name|todo
operator|&=
operator|~
name|TODO_SUID_CHECK
expr_stmt|;
block|}
if|if
condition|(
name|S_ISLNK
argument_list|(
name|a
operator|->
name|mode
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_LCHMOD
comment|/* 		 * If this is a symlink, use lchmod().  If the 		 * platform doesn't support lchmod(), just skip it.  A 		 * platform that doesn't provide a way to set 		 * permissions on symlinks probably ignores 		 * permissions on symlinks, so a failure here has no 		 * impact. 		 */
if|if
condition|(
name|lchmod
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|mode
argument_list|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOTSUP
case|:
case|case
name|ENOSYS
case|:
if|#
directive|if
name|ENOTSUP
operator|!=
name|EOPNOTSUPP
case|case
name|EOPNOTSUPP
case|:
endif|#
directive|endif
comment|/* 				 * if lchmod is defined but the platform 				 * doesn't support it, silently ignore 				 * error 				 */
break|break;
default|default:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Can't set permissions to 0%o"
argument_list|,
operator|(
name|int
operator|)
name|mode
argument_list|)
expr_stmt|;
name|r
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|a
operator|->
name|mode
argument_list|)
condition|)
block|{
comment|/* 		 * If it's not a symlink and not a dir, then use 		 * fchmod() or chmod(), depending on whether we have 		 * an fd.  Dirs get their perms set during the 		 * post-extract fixup, which is handled elsewhere. 		 */
ifdef|#
directive|ifdef
name|HAVE_FCHMOD
if|if
condition|(
name|a
operator|->
name|fd
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|fchmod
argument_list|(
name|a
operator|->
name|fd
argument_list|,
name|mode
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Can't set permissions to 0%o"
argument_list|,
operator|(
name|int
operator|)
name|mode
argument_list|)
expr_stmt|;
name|r
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
block|}
elseif|else
endif|#
directive|endif
comment|/* If this platform lacks fchmod(), then 			 * we'll just use chmod(). */
if|if
condition|(
name|chmod
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|mode
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Can't set permissions to 0%o"
argument_list|,
operator|(
name|int
operator|)
name|mode
argument_list|)
expr_stmt|;
name|r
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_fflags
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|fixup_entry
modifier|*
name|le
decl_stmt|;
name|unsigned
name|long
name|set
decl_stmt|,
name|clear
decl_stmt|;
name|int
name|r
decl_stmt|;
name|int
name|critical_flags
decl_stmt|;
name|mode_t
name|mode
init|=
name|archive_entry_mode
argument_list|(
name|a
operator|->
name|entry
argument_list|)
decl_stmt|;
comment|/* 	 * Make 'critical_flags' hold all file flags that can't be 	 * immediately restored.  For example, on BSD systems, 	 * SF_IMMUTABLE prevents hardlinks from being created, so 	 * should not be set until after any hardlinks are created.  To 	 * preserve some semblance of portability, this uses #ifdef 	 * extensively.  Ugly, but it works. 	 * 	 * Yes, Virginia, this does create a security race.  It's mitigated 	 * somewhat by the practice of creating dirs 0700 until the extract 	 * is done, but it would be nice if we could do more than that. 	 * People restoring critical file systems should be wary of 	 * other programs that might try to muck with files as they're 	 * being restored. 	 */
comment|/* Hopefully, the compiler will optimize this mess into a constant. */
name|critical_flags
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SF_IMMUTABLE
name|critical_flags
operator||=
name|SF_IMMUTABLE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UF_IMMUTABLE
name|critical_flags
operator||=
name|UF_IMMUTABLE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SF_APPEND
name|critical_flags
operator||=
name|SF_APPEND
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UF_APPEND
name|critical_flags
operator||=
name|UF_APPEND
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FS_APPEND_FL
argument_list|)
name|critical_flags
operator||=
name|FS_APPEND_FL
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|EXT2_APPEND_FL
argument_list|)
name|critical_flags
operator||=
name|EXT2_APPEND_FL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FS_IMMUTABLE_FL
argument_list|)
name|critical_flags
operator||=
name|FS_IMMUTABLE_FL
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|EXT2_IMMUTABLE_FL
argument_list|)
name|critical_flags
operator||=
name|EXT2_IMMUTABLE_FL
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FS_JOURNAL_DATA_FL
name|critical_flags
operator||=
name|FS_JOURNAL_DATA_FL
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|a
operator|->
name|todo
operator|&
name|TODO_FFLAGS
condition|)
block|{
name|archive_entry_fflags
argument_list|(
name|a
operator|->
name|entry
argument_list|,
operator|&
name|set
argument_list|,
operator|&
name|clear
argument_list|)
expr_stmt|;
comment|/* 		 * The first test encourages the compiler to eliminate 		 * all of this if it's not necessary. 		 */
if|if
condition|(
operator|(
name|critical_flags
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|set
operator|&
name|critical_flags
operator|)
condition|)
block|{
name|le
operator|=
name|current_fixup
argument_list|(
name|a
argument_list|,
name|a
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|le
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|le
operator|->
name|fixup
operator||=
name|TODO_FFLAGS
expr_stmt|;
name|le
operator|->
name|fflags_set
operator|=
name|set
expr_stmt|;
comment|/* Store the mode if it's not already there. */
if|if
condition|(
operator|(
name|le
operator|->
name|fixup
operator|&
name|TODO_MODE
operator|)
operator|==
literal|0
condition|)
name|le
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|set_fflags_platform
argument_list|(
name|a
argument_list|,
name|a
operator|->
name|fd
argument_list|,
name|a
operator|->
name|name
argument_list|,
name|mode
argument_list|,
name|set
argument_list|,
name|clear
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|clear_nochange_fflags
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|)
block|{
name|int
name|nochange_flags
decl_stmt|;
name|mode_t
name|mode
init|=
name|archive_entry_mode
argument_list|(
name|a
operator|->
name|entry
argument_list|)
decl_stmt|;
comment|/* Hopefully, the compiler will optimize this mess into a constant. */
name|nochange_flags
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SF_IMMUTABLE
name|nochange_flags
operator||=
name|SF_IMMUTABLE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UF_IMMUTABLE
name|nochange_flags
operator||=
name|UF_IMMUTABLE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SF_APPEND
name|nochange_flags
operator||=
name|SF_APPEND
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UF_APPEND
name|nochange_flags
operator||=
name|UF_APPEND
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EXT2_APPEND_FL
name|nochange_flags
operator||=
name|EXT2_APPEND_FL
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EXT2_IMMUTABLE_FL
name|nochange_flags
operator||=
name|EXT2_IMMUTABLE_FL
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|set_fflags_platform
argument_list|(
name|a
argument_list|,
name|a
operator|->
name|fd
argument_list|,
name|a
operator|->
name|name
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|,
name|nochange_flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|HAVE_LCHFLAGS
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_CHFLAGS
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_FCHFLAGS
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|HAVE_STRUCT_STAT_ST_FLAGS
argument_list|)
end_if

begin_comment
comment|/*  * BSD reads flags using stat() and sets them with one of {f,l,}chflags()  */
end_comment

begin_function
specifier|static
name|int
name|set_fflags_platform
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|,
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|mode_t
name|mode
parameter_list|,
name|unsigned
name|long
name|set
parameter_list|,
name|unsigned
name|long
name|clear
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
operator|(
name|void
operator|)
name|mode
expr_stmt|;
comment|/* UNUSED */
if|if
condition|(
name|set
operator|==
literal|0
operator|&&
name|clear
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
comment|/* 	 * XXX Is the stat here really necessary?  Or can I just use 	 * the 'set' flags directly?  In particular, I'm not sure 	 * about the correct approach if we're overwriting an existing 	 * file that already has flags on it. XXX 	 */
if|if
condition|(
operator|(
name|r
operator|=
name|lazy_stat
argument_list|(
name|a
argument_list|)
operator|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|a
operator|->
name|st
operator|.
name|st_flags
operator|&=
operator|~
name|clear
expr_stmt|;
name|a
operator|->
name|st
operator|.
name|st_flags
operator||=
name|set
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FCHFLAGS
comment|/* If platform has fchflags() and we were given an fd, use it. */
if|if
condition|(
name|fd
operator|>=
literal|0
operator|&&
name|fchflags
argument_list|(
name|fd
argument_list|,
name|a
operator|->
name|st
operator|.
name|st_flags
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
endif|#
directive|endif
comment|/* 	 * If we can't use the fd to set the flags, we'll use the 	 * pathname to set flags.  We prefer lchflags() but will use 	 * chflags() if we must. 	 */
ifdef|#
directive|ifdef
name|HAVE_LCHFLAGS
if|if
condition|(
name|lchflags
argument_list|(
name|name
argument_list|,
name|a
operator|->
name|st
operator|.
name|st_flags
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_CHFLAGS
argument_list|)
if|if
condition|(
name|S_ISLNK
argument_list|(
name|a
operator|->
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Can't set file flags on symlink."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
if|if
condition|(
name|chflags
argument_list|(
name|name
argument_list|,
name|a
operator|->
name|st
operator|.
name|st_flags
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
endif|#
directive|endif
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Failed to set file flags"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|FS_IOC_GETFLAGS
argument_list|)
operator|&&
name|defined
argument_list|(
name|FS_IOC_SETFLAGS
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|HAVE_WORKING_FS_IOC_GETFLAGS
argument_list|)
operator|)
operator|||
expr|\
operator|(
name|defined
argument_list|(
name|EXT2_IOC_GETFLAGS
argument_list|)
operator|&&
name|defined
argument_list|(
name|EXT2_IOC_SETFLAGS
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|HAVE_WORKING_EXT2_IOC_GETFLAGS
argument_list|)
operator|)
end_elif

begin_comment
comment|/*  * Linux uses ioctl() to read and write file flags.  */
end_comment

begin_function
specifier|static
name|int
name|set_fflags_platform
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|,
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|mode_t
name|mode
parameter_list|,
name|unsigned
name|long
name|set
parameter_list|,
name|unsigned
name|long
name|clear
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|int
name|myfd
init|=
name|fd
decl_stmt|;
name|int
name|newflags
decl_stmt|,
name|oldflags
decl_stmt|;
name|int
name|sf_mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|set
operator|==
literal|0
operator|&&
name|clear
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
comment|/* Only regular files and dirs can have flags. */
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|mode
argument_list|)
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
comment|/* If we weren't given an fd, open it ourselves. */
if|if
condition|(
name|myfd
operator|<
literal|0
condition|)
block|{
name|myfd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
operator||
name|O_NONBLOCK
operator||
name|O_BINARY
operator||
name|O_CLOEXEC
argument_list|)
expr_stmt|;
name|__archive_ensure_cloexec_flag
argument_list|(
name|myfd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|myfd
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
comment|/* 	 * Linux has no define for the flags that are only settable by 	 * the root user.  This code may seem a little complex, but 	 * there seem to be some Linux systems that lack these 	 * defines. (?)  The code below degrades reasonably gracefully 	 * if sf_mask is incomplete. 	 */
if|#
directive|if
name|defined
argument_list|(
name|FS_IMMUTABLE_FL
argument_list|)
name|sf_mask
operator||=
name|FS_IMMUTABLE_FL
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|EXT2_IMMUTABLE_FL
argument_list|)
name|sf_mask
operator||=
name|EXT2_IMMUTABLE_FL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FS_APPEND_FL
argument_list|)
name|sf_mask
operator||=
name|FS_APPEND_FL
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|EXT2_APPEND_FL
argument_list|)
name|sf_mask
operator||=
name|EXT2_APPEND_FL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FS_JOURNAL_DATA_FL
argument_list|)
name|sf_mask
operator||=
name|FS_JOURNAL_DATA_FL
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * XXX As above, this would be way simpler if we didn't have 	 * to read the current flags from disk. XXX 	 */
name|ret
operator|=
name|ARCHIVE_OK
expr_stmt|;
comment|/* Read the current file flags. */
if|if
condition|(
name|ioctl
argument_list|(
name|myfd
argument_list|,
ifdef|#
directive|ifdef
name|FS_IOC_GETFLAGS
name|FS_IOC_GETFLAGS
argument_list|,
else|#
directive|else
name|EXT2_IOC_GETFLAGS
argument_list|,
endif|#
directive|endif
operator|&
name|oldflags
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* Try setting the flags as given. */
name|newflags
operator|=
operator|(
name|oldflags
operator|&
operator|~
name|clear
operator|)
operator||
name|set
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|myfd
argument_list|,
ifdef|#
directive|ifdef
name|FS_IOC_SETFLAGS
name|FS_IOC_SETFLAGS
argument_list|,
else|#
directive|else
name|EXT2_IOC_SETFLAGS
argument_list|,
endif|#
directive|endif
operator|&
name|newflags
argument_list|)
operator|>=
literal|0
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|errno
operator|!=
name|EPERM
condition|)
goto|goto
name|fail
goto|;
comment|/* If we couldn't set all the flags, try again with a subset. */
name|newflags
operator|&=
operator|~
name|sf_mask
expr_stmt|;
name|oldflags
operator|&=
name|sf_mask
expr_stmt|;
name|newflags
operator||=
name|oldflags
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|myfd
argument_list|,
ifdef|#
directive|ifdef
name|FS_IOC_SETFLAGS
name|FS_IOC_SETFLAGS
argument_list|,
else|#
directive|else
name|EXT2_IOC_SETFLAGS
argument_list|,
endif|#
directive|endif
operator|&
name|newflags
argument_list|)
operator|>=
literal|0
condition|)
goto|goto
name|cleanup
goto|;
comment|/* We couldn't set the flags, so report the failure. */
name|fail
label|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Failed to set file flags"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|close
argument_list|(
name|myfd
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * Of course, some systems have neither BSD chflags() nor Linux' flags  * support through ioctl().  */
end_comment

begin_function
specifier|static
name|int
name|set_fflags_platform
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|,
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|mode_t
name|mode
parameter_list|,
name|unsigned
name|long
name|set
parameter_list|,
name|unsigned
name|long
name|clear
parameter_list|)
block|{
operator|(
name|void
operator|)
name|a
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|fd
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|name
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|mode
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|set
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|clear
expr_stmt|;
comment|/* UNUSED */
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __linux */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_COPYFILE_H
end_ifndef

begin_comment
comment|/* Default is to simply drop Mac extended metadata. */
end_comment

begin_function
specifier|static
name|int
name|set_mac_metadata
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
specifier|const
name|void
modifier|*
name|metadata
parameter_list|,
name|size_t
name|metadata_size
parameter_list|)
block|{
operator|(
name|void
operator|)
name|a
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|pathname
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|metadata
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|metadata_size
expr_stmt|;
comment|/* UNUSED */
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fixup_appledouble
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|)
block|{
operator|(
name|void
operator|)
name|a
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|pathname
expr_stmt|;
comment|/* UNUSED */
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * On Mac OS, we use copyfile() to unpack the metadata and  * apply it to the target file.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_XATTR_H
argument_list|)
end_if

begin_function
specifier|static
name|int
name|copy_xattrs
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|,
name|int
name|tmpfd
parameter_list|,
name|int
name|dffd
parameter_list|)
block|{
name|ssize_t
name|xattr_size
decl_stmt|;
name|char
modifier|*
name|xattr_names
init|=
name|NULL
decl_stmt|,
modifier|*
name|xattr_val
init|=
name|NULL
decl_stmt|;
name|int
name|ret
init|=
name|ARCHIVE_OK
decl_stmt|,
name|xattr_i
decl_stmt|;
name|xattr_size
operator|=
name|flistxattr
argument_list|(
name|tmpfd
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xattr_size
operator|==
operator|-
literal|1
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Failed to read metadata(xattr)"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
goto|goto
name|exit_xattr
goto|;
block|}
name|xattr_names
operator|=
name|malloc
argument_list|(
name|xattr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|xattr_names
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for metadata(xattr)"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
goto|goto
name|exit_xattr
goto|;
block|}
name|xattr_size
operator|=
name|flistxattr
argument_list|(
name|tmpfd
argument_list|,
name|xattr_names
argument_list|,
name|xattr_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xattr_size
operator|==
operator|-
literal|1
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Failed to read metadata(xattr)"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
goto|goto
name|exit_xattr
goto|;
block|}
for|for
control|(
name|xattr_i
operator|=
literal|0
init|;
name|xattr_i
operator|<
name|xattr_size
condition|;
name|xattr_i
operator|+=
name|strlen
argument_list|(
name|xattr_names
operator|+
name|xattr_i
argument_list|)
operator|+
literal|1
control|)
block|{
name|char
modifier|*
name|xattr_val_saved
decl_stmt|;
name|ssize_t
name|s
decl_stmt|;
name|int
name|f
decl_stmt|;
name|s
operator|=
name|fgetxattr
argument_list|(
name|tmpfd
argument_list|,
name|xattr_names
operator|+
name|xattr_i
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
operator|-
literal|1
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Failed to get metadata(xattr)"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
goto|goto
name|exit_xattr
goto|;
block|}
name|xattr_val_saved
operator|=
name|xattr_val
expr_stmt|;
name|xattr_val
operator|=
name|realloc
argument_list|(
name|xattr_val
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|xattr_val
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Failed to get metadata(xattr)"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
name|free
argument_list|(
name|xattr_val_saved
argument_list|)
expr_stmt|;
goto|goto
name|exit_xattr
goto|;
block|}
name|s
operator|=
name|fgetxattr
argument_list|(
name|tmpfd
argument_list|,
name|xattr_names
operator|+
name|xattr_i
argument_list|,
name|xattr_val
argument_list|,
name|s
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
operator|-
literal|1
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Failed to get metadata(xattr)"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
goto|goto
name|exit_xattr
goto|;
block|}
name|f
operator|=
name|fsetxattr
argument_list|(
name|dffd
argument_list|,
name|xattr_names
operator|+
name|xattr_i
argument_list|,
name|xattr_val
argument_list|,
name|s
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
operator|-
literal|1
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Failed to get metadata(xattr)"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
goto|goto
name|exit_xattr
goto|;
block|}
block|}
name|exit_xattr
label|:
name|free
argument_list|(
name|xattr_names
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xattr_val
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|copy_acls
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|,
name|int
name|tmpfd
parameter_list|,
name|int
name|dffd
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|HAVE_SYS_ACL_H
return|return
literal|0
return|;
else|#
directive|else
name|acl_t
name|acl
decl_stmt|,
name|dfacl
init|=
name|NULL
decl_stmt|;
name|int
name|acl_r
decl_stmt|,
name|ret
init|=
name|ARCHIVE_OK
decl_stmt|;
name|acl
operator|=
name|acl_get_fd
argument_list|(
name|tmpfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|acl
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
comment|/* There are not any ACLs. */
return|return
operator|(
name|ret
operator|)
return|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Failed to get metadata(acl)"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
goto|goto
name|exit_acl
goto|;
block|}
name|dfacl
operator|=
name|acl_dup
argument_list|(
name|acl
argument_list|)
expr_stmt|;
name|acl_r
operator|=
name|acl_set_fd
argument_list|(
name|dffd
argument_list|,
name|dfacl
argument_list|)
expr_stmt|;
if|if
condition|(
name|acl_r
operator|==
operator|-
literal|1
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Failed to get metadata(acl)"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
goto|goto
name|exit_acl
goto|;
block|}
name|exit_acl
label|:
if|if
condition|(
name|acl
condition|)
name|acl_free
argument_list|(
name|acl
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfacl
condition|)
name|acl_free
argument_list|(
name|dfacl
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|create_tempdatafork
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|)
block|{
name|struct
name|archive_string
name|tmpdatafork
decl_stmt|;
name|int
name|tmpfd
decl_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|tmpdatafork
argument_list|)
expr_stmt|;
name|archive_strcpy
argument_list|(
operator|&
name|tmpdatafork
argument_list|,
literal|"tar.md.XXXXXX"
argument_list|)
expr_stmt|;
name|tmpfd
operator|=
name|mkstemp
argument_list|(
name|tmpdatafork
operator|.
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpfd
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Failed to mkstemp"
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|tmpdatafork
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|copyfile
argument_list|(
name|pathname
argument_list|,
name|tmpdatafork
operator|.
name|s
argument_list|,
literal|0
argument_list|,
name|COPYFILE_UNPACK
operator||
name|COPYFILE_NOFOLLOW
operator||
name|COPYFILE_ACL
operator||
name|COPYFILE_XATTR
argument_list|)
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Failed to restore metadata"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|tmpfd
argument_list|)
expr_stmt|;
name|tmpfd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|unlink
argument_list|(
name|tmpdatafork
operator|.
name|s
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|tmpdatafork
argument_list|)
expr_stmt|;
return|return
operator|(
name|tmpfd
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|copy_metadata
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|metadata
parameter_list|,
specifier|const
name|char
modifier|*
name|datafork
parameter_list|,
name|int
name|datafork_compressed
parameter_list|)
block|{
name|int
name|ret
init|=
name|ARCHIVE_OK
decl_stmt|;
if|if
condition|(
name|datafork_compressed
condition|)
block|{
name|int
name|dffd
decl_stmt|,
name|tmpfd
decl_stmt|;
name|tmpfd
operator|=
name|create_tempdatafork
argument_list|(
name|a
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpfd
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
comment|/* 		 * Do not open the data fork compressed by HFS+ compression 		 * with at least a writing mode(O_RDWR or O_WRONLY). it 		 * makes the data fork uncompressed. 		 */
name|dffd
operator|=
name|open
argument_list|(
name|datafork
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dffd
operator|==
operator|-
literal|1
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Failed to open the data fork for metadata"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|tmpfd
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_XATTR_H
argument_list|)
name|ret
operator|=
name|copy_xattrs
argument_list|(
name|a
argument_list|,
name|tmpfd
argument_list|,
name|dffd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|ARCHIVE_OK
condition|)
endif|#
directive|endif
name|ret
operator|=
name|copy_acls
argument_list|(
name|a
argument_list|,
name|tmpfd
argument_list|,
name|dffd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|tmpfd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|dffd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|copyfile
argument_list|(
name|metadata
argument_list|,
name|datafork
argument_list|,
literal|0
argument_list|,
name|COPYFILE_UNPACK
operator||
name|COPYFILE_NOFOLLOW
operator||
name|COPYFILE_ACL
operator||
name|COPYFILE_XATTR
argument_list|)
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Failed to restore metadata"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_mac_metadata
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
specifier|const
name|void
modifier|*
name|metadata
parameter_list|,
name|size_t
name|metadata_size
parameter_list|)
block|{
name|struct
name|archive_string
name|tmp
decl_stmt|;
name|ssize_t
name|written
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|ret
init|=
name|ARCHIVE_OK
decl_stmt|;
comment|/* This would be simpler if copyfile() could just accept the 	 * metadata as a block of memory; then we could sidestep this 	 * silly dance of writing the data to disk just so that 	 * copyfile() can read it back in again. */
name|archive_string_init
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|archive_strcpy
argument_list|(
operator|&
name|tmp
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|archive_strcat
argument_list|(
operator|&
name|tmp
argument_list|,
literal|".XXXXXX"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|mkstemp
argument_list|(
name|tmp
operator|.
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Failed to restore metadata"
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
name|written
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|metadata
argument_list|,
name|metadata_size
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|written
operator|!=
name|metadata_size
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Failed to restore metadata"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
else|else
block|{
name|int
name|compressed
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|UF_COMPRESSED
argument_list|)
if|if
condition|(
operator|(
name|a
operator|->
name|todo
operator|&
name|TODO_HFS_COMPRESSION
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ret
operator|=
name|lazy_stat
argument_list|(
name|a
argument_list|)
operator|)
operator|==
name|ARCHIVE_OK
condition|)
name|compressed
operator|=
name|a
operator|->
name|st
operator|.
name|st_flags
operator|&
name|UF_COMPRESSED
expr_stmt|;
else|else
endif|#
directive|endif
name|compressed
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|copy_metadata
argument_list|(
name|a
argument_list|,
name|tmp
operator|.
name|s
argument_list|,
name|pathname
argument_list|,
name|compressed
argument_list|)
expr_stmt|;
block|}
name|unlink
argument_list|(
name|tmp
operator|.
name|s
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fixup_appledouble
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|)
block|{
name|char
name|buff
index|[
literal|8
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|archive_string
name|datafork
decl_stmt|;
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|,
name|ret
init|=
name|ARCHIVE_OK
decl_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|datafork
argument_list|)
expr_stmt|;
comment|/* Check if the current file name is a type of the resource 	 * fork file. */
name|p
operator|=
name|strrchr
argument_list|(
name|pathname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|pathname
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|||
name|p
index|[
literal|1
index|]
operator|!=
literal|'_'
condition|)
goto|goto
name|skip_appledouble
goto|;
comment|/* 	 * Check if the data fork file exists. 	 * 	 * TODO: Check if this write disk object has handled it. 	 */
name|archive_strncpy
argument_list|(
operator|&
name|datafork
argument_list|,
name|pathname
argument_list|,
name|p
operator|-
name|pathname
argument_list|)
expr_stmt|;
name|archive_strcat
argument_list|(
operator|&
name|datafork
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|datafork
operator|.
name|s
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
operator|||
operator|(
name|st
operator|.
name|st_mode
operator|&
name|AE_IFMT
operator|)
operator|!=
name|AE_IFREG
condition|)
goto|goto
name|skip_appledouble
goto|;
comment|/* 	 * Check if the file is in the AppleDouble form. 	 */
name|fd
operator|=
name|open
argument_list|(
name|pathname
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
operator||
name|O_CLOEXEC
argument_list|)
expr_stmt|;
name|__archive_ensure_cloexec_flag
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Failed to open a restoring file"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
goto|goto
name|skip_appledouble
goto|;
block|}
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|buff
argument_list|,
literal|8
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Failed to read a restoring file"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
goto|goto
name|skip_appledouble
goto|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* Check AppleDouble Magic Code. */
if|if
condition|(
name|archive_be32dec
argument_list|(
name|buff
argument_list|)
operator|!=
literal|0x00051607
condition|)
goto|goto
name|skip_appledouble
goto|;
comment|/* Check AppleDouble Version. */
if|if
condition|(
name|archive_be32dec
argument_list|(
name|buff
operator|+
literal|4
argument_list|)
operator|!=
literal|0x00020000
condition|)
goto|goto
name|skip_appledouble
goto|;
name|ret
operator|=
name|copy_metadata
argument_list|(
name|a
argument_list|,
name|pathname
argument_list|,
name|datafork
operator|.
name|s
argument_list|,
if|#
directive|if
name|defined
argument_list|(
name|UF_COMPRESSED
argument_list|)
name|st
operator|.
name|st_flags
operator|&
name|UF_COMPRESSED
argument_list|)
expr_stmt|;
else|#
directive|else
literal|0
block|)
function|;
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|ret
operator|==
name|ARCHIVE_OK
condition|)
block|{
name|unlink
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_EOF
expr_stmt|;
block|}
end_if

begin_label
name|skip_appledouble
label|:
end_label

begin_expr_stmt
name|archive_string_free
argument_list|(
operator|&
name|datafork
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|ret
operator|)
return|;
end_return

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|ARCHIVE_XATTR_LINUX
operator|||
name|ARCHIVE_XATTR_DARWIN
operator|||
name|ARCHIVE_XATTR_AIX
end_if

begin_comment
comment|/*  * Restore extended attributes -  Linux, Darwin and AIX implementations:  * AIX' ea interface is syntaxwise identical to the Linux xattr interface.  */
end_comment

begin_function
unit|static
name|int
name|set_xattrs
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|archive_entry
modifier|*
name|entry
init|=
name|a
operator|->
name|entry
decl_stmt|;
name|struct
name|archive_string
name|errlist
decl_stmt|;
name|int
name|ret
init|=
name|ARCHIVE_OK
decl_stmt|;
name|int
name|i
init|=
name|archive_entry_xattr_reset
argument_list|(
name|entry
argument_list|)
decl_stmt|;
name|short
name|fail
init|=
literal|0
decl_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|errlist
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|void
modifier|*
name|value
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|e
decl_stmt|;
name|archive_entry_xattr_next
argument_list|(
name|entry
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
continue|continue;
if|#
directive|if
name|ARCHIVE_XATTR_LINUX
comment|/* Linux: quietly skip POSIX.1e ACL extended attributes */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"system."
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
operator|+
literal|7
argument_list|,
literal|"posix_acl_access"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
operator|+
literal|7
argument_list|,
literal|"posix_acl_default"
argument_list|)
operator|==
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"trusted.SGI_"
argument_list|,
literal|12
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
operator|+
literal|12
argument_list|,
literal|"ACL_DEFAULT"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
operator|+
literal|12
argument_list|,
literal|"ACL_FILE"
argument_list|)
operator|==
literal|0
operator|)
condition|)
continue|continue;
comment|/* Linux: xfsroot namespace is obsolete and unsupported */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"xfsroot."
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fail
operator|=
literal|1
expr_stmt|;
name|archive_strcat
argument_list|(
operator|&
name|errlist
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|archive_strappend_char
argument_list|(
operator|&
name|errlist
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
name|a
operator|->
name|fd
operator|>=
literal|0
condition|)
block|{
if|#
directive|if
name|ARCHIVE_XATTR_LINUX
name|e
operator|=
name|fsetxattr
argument_list|(
name|a
operator|->
name|fd
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|ARCHIVE_XATTR_DARWIN
name|e
operator|=
name|fsetxattr
argument_list|(
name|a
operator|->
name|fd
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|ARCHIVE_XATTR_AIX
name|e
operator|=
name|fsetea
argument_list|(
name|a
operator|->
name|fd
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|#
directive|if
name|ARCHIVE_XATTR_LINUX
name|e
operator|=
name|lsetxattr
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|ARCHIVE_XATTR_DARWIN
name|e
operator|=
name|setxattr
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
name|XATTR_NOFOLLOW
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|ARCHIVE_XATTR_AIX
name|e
operator|=
name|lsetea
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|e
operator|==
operator|-
literal|1
condition|)
block|{
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
name|archive_strcat
argument_list|(
operator|&
name|errlist
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|archive_strappend_char
argument_list|(
operator|&
name|errlist
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
name|ENOTSUP
operator|&&
name|errno
operator|!=
name|ENOSYS
condition|)
name|fail
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret
operator|==
name|ARCHIVE_WARN
condition|)
block|{
if|if
condition|(
name|fail
operator|&&
name|errlist
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|errlist
operator|.
name|length
operator|--
expr_stmt|;
name|errlist
operator|.
name|s
index|[
name|errlist
operator|.
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Cannot restore extended attributes: %s"
argument_list|,
name|errlist
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Cannot restore extended "
literal|"attributes on this file system."
argument_list|)
expr_stmt|;
block|}
name|archive_string_free
argument_list|(
operator|&
name|errlist
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|ARCHIVE_XATTR_FREEBSD
end_elif

begin_comment
comment|/*  * Restore extended attributes -  FreeBSD implementation  */
end_comment

begin_function
specifier|static
name|int
name|set_xattrs
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|archive_entry
modifier|*
name|entry
init|=
name|a
operator|->
name|entry
decl_stmt|;
name|struct
name|archive_string
name|errlist
decl_stmt|;
name|int
name|ret
init|=
name|ARCHIVE_OK
decl_stmt|;
name|int
name|i
init|=
name|archive_entry_xattr_reset
argument_list|(
name|entry
argument_list|)
decl_stmt|;
name|short
name|fail
init|=
literal|0
decl_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|errlist
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|void
modifier|*
name|value
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|archive_entry_xattr_next
argument_list|(
name|entry
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
name|ssize_t
name|e
decl_stmt|;
name|int
name|namespace
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"user."
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* "user." attributes go to user namespace */
name|name
operator|+=
literal|5
expr_stmt|;
name|namespace
operator|=
name|EXTATTR_NAMESPACE_USER
expr_stmt|;
block|}
else|else
block|{
comment|/* Other namespaces are unsupported */
name|archive_strcat
argument_list|(
operator|&
name|errlist
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|archive_strappend_char
argument_list|(
operator|&
name|errlist
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|fail
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|a
operator|->
name|fd
operator|>=
literal|0
condition|)
block|{
name|e
operator|=
name|extattr_set_fd
argument_list|(
name|a
operator|->
name|fd
argument_list|,
name|namespace
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e
operator|=
name|extattr_set_link
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|namespace
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|!=
operator|(
name|ssize_t
operator|)
name|size
condition|)
block|{
name|archive_strcat
argument_list|(
operator|&
name|errlist
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|archive_strappend_char
argument_list|(
operator|&
name|errlist
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
name|ENOTSUP
operator|&&
name|errno
operator|!=
name|ENOSYS
condition|)
name|fail
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ret
operator|==
name|ARCHIVE_WARN
condition|)
block|{
if|if
condition|(
name|fail
operator|&&
name|errlist
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|errlist
operator|.
name|length
operator|--
expr_stmt|;
name|errlist
operator|.
name|s
index|[
name|errlist
operator|.
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Cannot restore extended attributes: %s"
argument_list|,
name|errlist
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Cannot restore extended "
literal|"attributes on this file system."
argument_list|)
expr_stmt|;
block|}
name|archive_string_free
argument_list|(
operator|&
name|errlist
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * Restore extended attributes - stub implementation for unsupported systems  */
end_comment

begin_function
specifier|static
name|int
name|set_xattrs
parameter_list|(
name|struct
name|archive_write_disk
modifier|*
name|a
parameter_list|)
block|{
specifier|static
name|int
name|warning_done
init|=
literal|0
decl_stmt|;
comment|/* If there aren't any extended attributes, then it's okay not 	 * to extract them, otherwise, issue a single warning. */
if|if
condition|(
name|archive_entry_xattr_count
argument_list|(
name|a
operator|->
name|entry
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|warning_done
condition|)
block|{
name|warning_done
operator|=
literal|1
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Cannot restore extended attributes on this system"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* Warning was already emitted; suppress further warnings. */
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Test if file on disk is older than entry.  */
end_comment

begin_function
specifier|static
name|int
name|older
parameter_list|(
name|struct
name|stat
modifier|*
name|st
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
comment|/* First, test the seconds and return if we have a definite answer. */
comment|/* Definitely older. */
if|if
condition|(
name|to_int64_time
argument_list|(
name|st
operator|->
name|st_mtime
argument_list|)
operator|<
name|to_int64_time
argument_list|(
name|archive_entry_mtime
argument_list|(
name|entry
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Definitely younger. */
if|if
condition|(
name|to_int64_time
argument_list|(
name|st
operator|->
name|st_mtime
argument_list|)
operator|>
name|to_int64_time
argument_list|(
name|archive_entry_mtime
argument_list|(
name|entry
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* If this platform supports fractional seconds, try those. */
if|#
directive|if
name|HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC
comment|/* Definitely older. */
if|if
condition|(
name|st
operator|->
name|st_mtimespec
operator|.
name|tv_nsec
operator|<
name|archive_entry_mtime_nsec
argument_list|(
name|entry
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
elif|#
directive|elif
name|HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC
comment|/* Definitely older. */
if|if
condition|(
name|st
operator|->
name|st_mtim
operator|.
name|tv_nsec
operator|<
name|archive_entry_mtime_nsec
argument_list|(
name|entry
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
elif|#
directive|elif
name|HAVE_STRUCT_STAT_ST_MTIME_N
comment|/* older. */
if|if
condition|(
name|st
operator|->
name|st_mtime_n
operator|<
name|archive_entry_mtime_nsec
argument_list|(
name|entry
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
elif|#
directive|elif
name|HAVE_STRUCT_STAT_ST_UMTIME
comment|/* older. */
if|if
condition|(
name|st
operator|->
name|st_umtime
operator|*
literal|1000
operator|<
name|archive_entry_mtime_nsec
argument_list|(
name|entry
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
elif|#
directive|elif
name|HAVE_STRUCT_STAT_ST_MTIME_USEC
comment|/* older. */
if|if
condition|(
name|st
operator|->
name|st_mtime_usec
operator|*
literal|1000
operator|<
name|archive_entry_mtime_nsec
argument_list|(
name|entry
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
comment|/* This system doesn't have high-res timestamps. */
endif|#
directive|endif
comment|/* Same age or newer, so not older. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|ARCHIVE_ACL_SUPPORT
end_ifndef

begin_function
name|int
name|archive_write_disk_set_acls
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|archive_acl
modifier|*
name|abstract_acl
parameter_list|,
name|__LA_MODE_T
name|mode
parameter_list|)
block|{
operator|(
name|void
operator|)
name|a
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|fd
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|name
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|abstract_acl
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|mode
expr_stmt|;
comment|/* UNUSED */
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !_WIN32 || __CYGWIN__ */
end_comment

end_unit

