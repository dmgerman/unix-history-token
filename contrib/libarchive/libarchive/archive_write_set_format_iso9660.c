begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009-2012 Michihiro NAKAJIMA  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"archive_platform.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TYPES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_UTSNAME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ERRNO_H
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIMITS_H
end_ifdef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"archive.h"
end_include

begin_include
include|#
directive|include
file|"archive_endian.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry_locale.h"
end_include

begin_include
include|#
directive|include
file|"archive_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_rb.h"
end_include

begin_include
include|#
directive|include
file|"archive_write_private.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_define
define|#
directive|define
name|getuid
parameter_list|()
value|0
end_define

begin_define
define|#
directive|define
name|getgid
parameter_list|()
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*#define DEBUG 1*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/* To compare to the ISO image file made by mkisofs. */
end_comment

begin_define
define|#
directive|define
name|COMPAT_MKISOFS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|LOGICAL_BLOCK_BITS
value|11
end_define

begin_define
define|#
directive|define
name|LOGICAL_BLOCK_SIZE
value|2048
end_define

begin_define
define|#
directive|define
name|PATH_TABLE_BLOCK_SIZE
value|4096
end_define

begin_define
define|#
directive|define
name|SYSTEM_AREA_BLOCK
value|16
end_define

begin_define
define|#
directive|define
name|PRIMARY_VOLUME_DESCRIPTOR_BLOCK
value|1
end_define

begin_define
define|#
directive|define
name|SUPPLEMENTARY_VOLUME_DESCRIPTOR_BLOCK
value|1
end_define

begin_define
define|#
directive|define
name|BOOT_RECORD_DESCRIPTOR_BLOCK
value|1
end_define

begin_define
define|#
directive|define
name|VOLUME_DESCRIPTOR_SET_TERMINATOR_BLOCK
value|1
end_define

begin_define
define|#
directive|define
name|NON_ISO_FILE_SYSTEM_INFORMATION_BLOCK
value|1
end_define

begin_define
define|#
directive|define
name|RRIP_ER_BLOCK
value|1
end_define

begin_define
define|#
directive|define
name|PADDING_BLOCK
value|150
end_define

begin_define
define|#
directive|define
name|FD_1_2M_SIZE
value|(1024 * 1200)
end_define

begin_define
define|#
directive|define
name|FD_1_44M_SIZE
value|(1024 * 1440)
end_define

begin_define
define|#
directive|define
name|FD_2_88M_SIZE
value|(1024 * 2880)
end_define

begin_define
define|#
directive|define
name|MULTI_EXTENT_SIZE
value|(ARCHIVE_LITERAL_LL(1)<< 32)
end_define

begin_comment
comment|/* 4Gi bytes. */
end_comment

begin_define
define|#
directive|define
name|MAX_DEPTH
value|8
end_define

begin_define
define|#
directive|define
name|RR_CE_SIZE
value|28
end_define

begin_comment
comment|/* SUSP "CE" extension size */
end_comment

begin_define
define|#
directive|define
name|FILE_FLAG_EXISTENCE
value|0x01
end_define

begin_define
define|#
directive|define
name|FILE_FLAG_DIRECTORY
value|0x02
end_define

begin_define
define|#
directive|define
name|FILE_FLAG_ASSOCIATED
value|0x04
end_define

begin_define
define|#
directive|define
name|FILE_FLAG_RECORD
value|0x08
end_define

begin_define
define|#
directive|define
name|FILE_FLAG_PROTECTION
value|0x10
end_define

begin_define
define|#
directive|define
name|FILE_FLAG_MULTI_EXTENT
value|0x80
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rrip_identifier
index|[]
init|=
literal|"RRIP_1991A"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rrip_descriptor
index|[]
init|=
literal|"THE ROCK RIDGE INTERCHANGE PROTOCOL PROVIDES SUPPORT FOR "
literal|"POSIX FILE SYSTEM SEMANTICS"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rrip_source
index|[]
init|=
literal|"PLEASE CONTACT DISC PUBLISHER FOR SPECIFICATION SOURCE.  "
literal|"SEE PUBLISHER IDENTIFIER IN PRIMARY VOLUME DESCRIPTOR FOR "
literal|"CONTACT INFORMATION."
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RRIP_ER_ID_SIZE
value|(sizeof(rrip_identifier)-1)
end_define

begin_define
define|#
directive|define
name|RRIP_ER_DSC_SIZE
value|(sizeof(rrip_descriptor)-1)
end_define

begin_define
define|#
directive|define
name|RRIP_ER_SRC_SIZE
value|(sizeof(rrip_source)-1)
end_define

begin_define
define|#
directive|define
name|RRIP_ER_SIZE
value|(8 + RRIP_ER_ID_SIZE + \ 				RRIP_ER_DSC_SIZE + RRIP_ER_SRC_SIZE)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|zisofs_magic
index|[
literal|8
index|]
init|=
block|{
literal|0x37
block|,
literal|0xE4
block|,
literal|0x53
block|,
literal|0x96
block|,
literal|0xC9
block|,
literal|0xDB
block|,
literal|0xD6
block|,
literal|0x07
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ZF_HEADER_SIZE
value|16
end_define

begin_comment
comment|/* zisofs header size. */
end_comment

begin_define
define|#
directive|define
name|ZF_LOG2_BS
value|15
end_define

begin_comment
comment|/* log2 block size; 32K bytes. */
end_comment

begin_define
define|#
directive|define
name|ZF_BLOCK_SIZE
value|(1UL<< ZF_LOG2_BS)
end_define

begin_comment
comment|/*  * Manage extra records.  */
end_comment

begin_struct
struct|struct
name|extr_rec
block|{
name|int
name|location
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
name|LOGICAL_BLOCK_SIZE
index|]
decl_stmt|;
name|struct
name|extr_rec
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ctl_extr_rec
block|{
name|int
name|use_extr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bp
decl_stmt|;
name|struct
name|isoent
modifier|*
name|isoent
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ce_ptr
decl_stmt|;
name|int
name|cur_len
decl_stmt|;
name|int
name|dr_len
decl_stmt|;
name|int
name|limit
decl_stmt|;
name|int
name|extr_off
decl_stmt|;
name|int
name|extr_loc
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DR_SAFETY
value|RR_CE_SIZE
end_define

begin_define
define|#
directive|define
name|DR_LIMIT
value|(254 - DR_SAFETY)
end_define

begin_comment
comment|/*  * The relation of struct isofile and isoent and archive_entry.  *  * Primary volume tree  --> struct isoent  *                                |  *                                v  *                          struct isofile --> archive_entry  *                                ^  *                                |  * Joliet volume tree   --> struct isoent  *  * struct isoent has specific information for volume.  */
end_comment

begin_struct
struct|struct
name|isofile
block|{
comment|/* Used for managing struct isofile list. */
name|struct
name|isofile
modifier|*
name|allnext
decl_stmt|;
name|struct
name|isofile
modifier|*
name|datanext
decl_stmt|;
comment|/* Used for managing a hardlined struct isofile list. */
name|struct
name|isofile
modifier|*
name|hlnext
decl_stmt|;
name|struct
name|isofile
modifier|*
name|hardlink_target
decl_stmt|;
name|struct
name|archive_entry
modifier|*
name|entry
decl_stmt|;
comment|/* 	 * Used for making a directory tree. 	 */
name|struct
name|archive_string
name|parentdir
decl_stmt|;
name|struct
name|archive_string
name|basename
decl_stmt|;
name|struct
name|archive_string
name|basename_utf16
decl_stmt|;
name|struct
name|archive_string
name|symlink
decl_stmt|;
name|int
name|dircnt
decl_stmt|;
comment|/* The number of elements of 						 * its parent directory */
comment|/* 	 * Used for a Directory Record. 	 */
struct|struct
name|content
block|{
name|int64_t
name|offset_of_temp
decl_stmt|;
name|int64_t
name|size
decl_stmt|;
name|int
name|blocks
decl_stmt|;
name|uint32_t
name|location
decl_stmt|;
comment|/* 		 * One extent equals one content. 		 * If this entry has multi extent, `next' variable points 		 * next content data. 		 */
name|struct
name|content
modifier|*
name|next
decl_stmt|;
comment|/* next content	*/
block|}
name|content
struct|,
modifier|*
name|cur_content
struct|;
name|int
name|write_content
decl_stmt|;
enum|enum
block|{
name|NO
init|=
literal|0
block|,
name|BOOT_CATALOG
block|,
name|BOOT_IMAGE
block|, 	}
name|boot
enum|;
comment|/* 	 * Used for a zisofs. 	 */
struct|struct
block|{
name|unsigned
name|char
name|header_size
decl_stmt|;
name|unsigned
name|char
name|log2_bs
decl_stmt|;
name|uint32_t
name|uncompressed_size
decl_stmt|;
block|}
name|zisofs
struct|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|isoent
block|{
comment|/* Keep `rbnode' at the first member of struct isoent. */
name|struct
name|archive_rb_node
name|rbnode
decl_stmt|;
name|struct
name|isofile
modifier|*
name|file
decl_stmt|;
name|struct
name|isoent
modifier|*
name|parent
decl_stmt|;
comment|/* A list of children.(use chnext) */
struct|struct
block|{
name|struct
name|isoent
modifier|*
name|first
decl_stmt|;
name|struct
name|isoent
modifier|*
modifier|*
name|last
decl_stmt|;
name|int
name|cnt
decl_stmt|;
block|}
name|children
struct|;
name|struct
name|archive_rb_tree
name|rbtree
decl_stmt|;
comment|/* A list of sub directories.(use drnext) */
struct|struct
block|{
name|struct
name|isoent
modifier|*
name|first
decl_stmt|;
name|struct
name|isoent
modifier|*
modifier|*
name|last
decl_stmt|;
name|int
name|cnt
decl_stmt|;
block|}
name|subdirs
struct|;
comment|/* A sorted list of sub directories. */
name|struct
name|isoent
modifier|*
modifier|*
name|children_sorted
decl_stmt|;
comment|/* Used for managing struct isoent list. */
name|struct
name|isoent
modifier|*
name|chnext
decl_stmt|;
name|struct
name|isoent
modifier|*
name|drnext
decl_stmt|;
name|struct
name|isoent
modifier|*
name|ptnext
decl_stmt|;
comment|/* 	 * Used for making a Directory Record. 	 */
name|int
name|dir_number
decl_stmt|;
struct|struct
block|{
name|int
name|vd
decl_stmt|;
name|int
name|self
decl_stmt|;
name|int
name|parent
decl_stmt|;
name|int
name|normal
decl_stmt|;
block|}
name|dr_len
struct|;
name|uint32_t
name|dir_location
decl_stmt|;
name|int
name|dir_block
decl_stmt|;
comment|/* 	 * Identifier: 	 *   on primary, ISO9660 file/directory name. 	 *   on joliet, UCS2 file/directory name. 	 * ext_off   : offset of identifier extension. 	 * ext_len   : length of identifier extension. 	 * id_len    : byte size of identifier. 	 *   on primary, this is ext_off + ext_len + version length. 	 *   on joliet, this is ext_off + ext_len. 	 * mb_len    : length of multibyte-character of identifier. 	 *   on primary, mb_len and id_len are always the same. 	 *   on joliet, mb_len and id_len are different. 	 */
name|char
modifier|*
name|identifier
decl_stmt|;
name|int
name|ext_off
decl_stmt|;
name|int
name|ext_len
decl_stmt|;
name|int
name|id_len
decl_stmt|;
name|int
name|mb_len
decl_stmt|;
comment|/* 	 * Used for making a Rockridge extension. 	 * This is a part of Directory Records. 	 */
name|struct
name|isoent
modifier|*
name|rr_parent
decl_stmt|;
name|struct
name|isoent
modifier|*
name|rr_child
decl_stmt|;
comment|/* Extra Record.(which we call in this source file) 	 * A maximum size of the Directory Record is 254. 	 * so, if generated RRIP data of a file cannot into a Directory 	 * Record because of its size, that surplus data relocate this 	 * Extra Record. 	 */
struct|struct
block|{
name|struct
name|extr_rec
modifier|*
name|first
decl_stmt|;
name|struct
name|extr_rec
modifier|*
modifier|*
name|last
decl_stmt|;
name|struct
name|extr_rec
modifier|*
name|current
decl_stmt|;
block|}
name|extr_rec_list
struct|;
name|int
name|virtual
range|:
literal|1
decl_stmt|;
comment|/* If set to one, this file type is a directory. 	 * A convenience flag to be used as 	 * "archive_entry_filetype(isoent->file->entry) == AE_IFDIR". 	 */
name|int
name|dir
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|hardlink
block|{
name|struct
name|archive_rb_node
name|rbnode
decl_stmt|;
name|int
name|nlink
decl_stmt|;
struct|struct
block|{
name|struct
name|isofile
modifier|*
name|first
decl_stmt|;
name|struct
name|isofile
modifier|*
modifier|*
name|last
decl_stmt|;
block|}
name|file_list
struct|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * ISO writer options  */
end_comment

begin_struct
struct|struct
name|iso_option
block|{
comment|/* 	 * Usage  : abstract-file=<value> 	 * Type   : string, max 37 bytes 	 * Default: Not specified 	 * COMPAT : mkisofs -abstract<value> 	 * 	 * Specifies Abstract Filename. 	 * This file shall be described in the Root Directory 	 * and containing a abstract statement. 	 */
name|unsigned
name|int
name|abstract_file
range|:
literal|1
decl_stmt|;
define|#
directive|define
name|OPT_ABSTRACT_FILE_DEFAULT
value|0
comment|/* Not specified */
define|#
directive|define
name|ABSTRACT_FILE_SIZE
value|37
comment|/* 	 * Usage  : application-id=<value> 	 * Type   : string, max 128 bytes 	 * Default: Not specified 	 * COMPAT : mkisofs -A/-appid<value>. 	 * 	 * Specifies Application Identifier. 	 * If the first byte is set to '_'(5F), the remaining 	 * bytes of this option shall specify an identifier 	 * for a file containing the identification of the 	 * application. 	 * This file shall be described in the Root Directory. 	 */
name|unsigned
name|int
name|application_id
range|:
literal|1
decl_stmt|;
define|#
directive|define
name|OPT_APPLICATION_ID_DEFAULT
value|0
comment|/* Use default identifier */
define|#
directive|define
name|APPLICATION_IDENTIFIER_SIZE
value|128
comment|/* 	 * Usage : !allow-vernum 	 * Type  : boolean 	 * Default: Enabled 	 *	  : Violates the ISO9660 standard if disable. 	 * COMPAT: mkisofs -N 	 * 	 * Allow filenames to use version numbers. 	 */
name|unsigned
name|int
name|allow_vernum
range|:
literal|1
decl_stmt|;
define|#
directive|define
name|OPT_ALLOW_VERNUM_DEFAULT
value|1
comment|/* Enabled */
comment|/* 	 * Usage  : biblio-file=<value> 	 * Type   : string, max 37 bytes 	 * Default: Not specified 	 * COMPAT : mkisofs -biblio<value> 	 * 	 * Specifies Bibliographic Filename. 	 * This file shall be described in the Root Directory 	 * and containing bibliographic records. 	 */
name|unsigned
name|int
name|biblio_file
range|:
literal|1
decl_stmt|;
define|#
directive|define
name|OPT_BIBLIO_FILE_DEFAULT
value|0
comment|/* Not specified */
define|#
directive|define
name|BIBLIO_FILE_SIZE
value|37
comment|/* 	 * Usage  : boot=<value> 	 * Type   : string 	 * Default: Not specified 	 * COMPAT : mkisofs -b/-eltorito-boot<value> 	 * 	 * Specifies "El Torito" boot image file to make 	 * a bootable CD. 	 */
name|unsigned
name|int
name|boot
range|:
literal|1
decl_stmt|;
define|#
directive|define
name|OPT_BOOT_DEFAULT
value|0
comment|/* Not specified */
comment|/* 	 * Usage  : boot-catalog=<value> 	 * Type   : string 	 * Default: "boot.catalog" 	 * COMPAT : mkisofs -c/-eltorito-catalog<value> 	 * 	 * Specifies a fullpath of El Torito boot catalog. 	 */
name|unsigned
name|int
name|boot_catalog
range|:
literal|1
decl_stmt|;
define|#
directive|define
name|OPT_BOOT_CATALOG_DEFAULT
value|0
comment|/* Not specified */
comment|/* 	 * Usage  : boot-info-table 	 * Type   : boolean 	 * Default: Disabled 	 * COMPAT : mkisofs -boot-info-table 	 * 	 * Modify the boot image file specified by `boot' 	 * option; ISO writer stores boot file information 	 * into the boot file in ISO image at offset 8 	 * through offset 64. 	 */
name|unsigned
name|int
name|boot_info_table
range|:
literal|1
decl_stmt|;
define|#
directive|define
name|OPT_BOOT_INFO_TABLE_DEFAULT
value|0
comment|/* Disabled */
comment|/* 	 * Usage  : boot-load-seg=<value> 	 * Type   : hexadecimal 	 * Default: Not specified 	 * COMPAT : mkisofs -boot-load-seg<value> 	 * 	 * Specifies a load segment for boot image. 	 * This is used with no-emulation mode. 	 */
name|unsigned
name|int
name|boot_load_seg
range|:
literal|1
decl_stmt|;
define|#
directive|define
name|OPT_BOOT_LOAD_SEG_DEFAULT
value|0
comment|/* Not specified */
comment|/* 	 * Usage  : boot-load-size=<value> 	 * Type   : decimal 	 * Default: Not specified 	 * COMPAT : mkisofs -boot-load-size<value> 	 * 	 * Specifies a sector count for boot image. 	 * This is used with no-emulation mode. 	 */
name|unsigned
name|int
name|boot_load_size
range|:
literal|1
decl_stmt|;
define|#
directive|define
name|OPT_BOOT_LOAD_SIZE_DEFAULT
value|0
comment|/* Not specified */
comment|/* 	 * Usage  : boot-type=<boot-media-type> 	 *        : 'no-emulation' : 'no emulation' image 	 *        :           'fd' : floppy disk image 	 *        :    'hard-disk' : hard disk image 	 * Type   : string 	 * Default: Auto detect 	 *        : We check a size of boot image; 	 *        : If ths size is just 1.22M/1.44M/2.88M, 	 *        : we assume boot_type is 'fd'; 	 *        : otherwise boot_type is 'no-emulation'. 	 * COMPAT : 	 *    boot=no-emulation 	 *	mkisofs -no-emul-boot 	 *    boot=fd 	 *	This is a default on the mkisofs. 	 *    boot=hard-disk 	 *	mkisofs -hard-disk-boot 	 * 	 * Specifies a type of "El Torito" boot image. 	 */
name|unsigned
name|int
name|boot_type
range|:
literal|2
decl_stmt|;
define|#
directive|define
name|OPT_BOOT_TYPE_AUTO
value|0
comment|/* auto detect		  */
define|#
directive|define
name|OPT_BOOT_TYPE_NO_EMU
value|1
comment|/* ``no emulation'' image */
define|#
directive|define
name|OPT_BOOT_TYPE_FD
value|2
comment|/* floppy disk image	  */
define|#
directive|define
name|OPT_BOOT_TYPE_HARD_DISK
value|3
comment|/* hard disk image	  */
define|#
directive|define
name|OPT_BOOT_TYPE_DEFAULT
value|OPT_BOOT_TYPE_AUTO
comment|/* 	 * Usage  : compression-level=<value> 	 * Type   : decimal 	 * Default: Not specified 	 * COMPAT : NONE 	 * 	 * Specifies compression level for option zisofs=direct. 	 */
name|unsigned
name|int
name|compression_level
range|:
literal|1
decl_stmt|;
define|#
directive|define
name|OPT_COMPRESSION_LEVEL_DEFAULT
value|0
comment|/* Not specified */
comment|/* 	 * Usage  : copyright-file=<value> 	 * Type   : string, max 37 bytes 	 * Default: Not specified 	 * COMPAT : mkisofs -copyright<value> 	 * 	 * Specifies Copyright Filename. 	 * This file shall be described in the Root Directory 	 * and containing a copyright statement. 	 */
name|unsigned
name|int
name|copyright_file
range|:
literal|1
decl_stmt|;
define|#
directive|define
name|OPT_COPYRIGHT_FILE_DEFAULT
value|0
comment|/* Not specified */
define|#
directive|define
name|COPYRIGHT_FILE_SIZE
value|37
comment|/* 	 * Usage  : gid=<value> 	 * Type   : decimal 	 * Default: Not specified 	 * COMPAT : mkisofs -gid<value> 	 * 	 * Specifies a group id to rewrite the group id of all files. 	 */
name|unsigned
name|int
name|gid
range|:
literal|1
decl_stmt|;
define|#
directive|define
name|OPT_GID_DEFAULT
value|0
comment|/* Not specified */
comment|/* 	 * Usage  : iso-level=[1234] 	 * Type   : decimal 	 * Default: 1 	 * COMPAT : mkisofs -iso-level<value> 	 * 	 * Specifies ISO9600 Level. 	 * Level 1: [DEFAULT] 	 *   - limits each file size less than 4Gi bytes; 	 *   - a File Name shall not contain more than eight 	 *     d-characters or eight d1-characters; 	 *   - a File Name Extension shall not contain more than 	 *     three d-characters or three d1-characters; 	 *   - a Directory Identifier shall not contain more 	 *     than eight d-characters or eight d1-characters. 	 * Level 2: 	 *   - limits each file size less than 4Giga bytes; 	 *   - a File Name shall not contain more than thirty 	 *     d-characters or thirty d1-characters; 	 *   - a File Name Extension shall not contain more than 	 *     thirty d-characters or thirty d1-characters; 	 *   - a Directory Identifier shall not contain more 	 *     than thirty-one d-characters or thirty-one 	 *     d1-characters. 	 * Level 3: 	 *   - no limit of file size; use multi extent. 	 * Level 4: 	 *   - this level 4 simulates mkisofs option 	 *     '-iso-level 4'; 	 *   - crate a enhanced volume as mkisofs doing; 	 *   - allow a File Name to have leading dot; 	 *   - allow a File Name to have all ASCII letters; 	 *   - allow a File Name to have multiple dots; 	 *   - allow more then 8 depths of directory trees; 	 *   - disable a version number to a File Name; 	 *   - disable a forced period to the tail of a File Name; 	 *   - the maxinum length of files and directories is raised to 193. 	 *     if rockridge option is disabled, raised to 207. 	 */
name|unsigned
name|int
name|iso_level
range|:
literal|3
decl_stmt|;
define|#
directive|define
name|OPT_ISO_LEVEL_DEFAULT
value|1
comment|/* ISO Level 1 */
comment|/* 	 * Usage  : joliet[=long] 	 *        : !joliet 	 *        :   Do not generate Joliet Volume and Records. 	 *        : joliet [DEFAULT] 	 *        :   Generates Joliet Volume and Directory Records. 	 *        :   [COMPAT: mkisofs -J/-joliet] 	 *        : joliet=long 	 *        :   The joliet filenames are up to 103 Unicode 	 *        :   characters. 	 *        :   This option breaks the Joliet specification. 	 *        :   [COMPAT: mkisofs -J -joliet-long] 	 * Type   : boolean/string 	 * Default: Enabled 	 * COMPAT : mkisofs -J / -joliet-long 	 * 	 * Generates Joliet Volume and Directory Records. 	 */
name|unsigned
name|int
name|joliet
range|:
literal|2
decl_stmt|;
define|#
directive|define
name|OPT_JOLIET_DISABLE
value|0
comment|/* Not generate Joliet Records. */
define|#
directive|define
name|OPT_JOLIET_ENABLE
value|1
comment|/* Generate Joliet Records.  */
define|#
directive|define
name|OPT_JOLIET_LONGNAME
value|2
comment|/* Use long joliet filenames.*/
define|#
directive|define
name|OPT_JOLIET_DEFAULT
value|OPT_JOLIET_ENABLE
comment|/* 	 * Usage  : !limit-depth 	 * Type   : boolean 	 * Default: Enabled 	 *	  : Violates the ISO9660 standard if disable. 	 * COMPAT : mkisofs -D/-disable-deep-relocation 	 * 	 * The number of levels in hierarchy cannot exceed eight. 	 */
name|unsigned
name|int
name|limit_depth
range|:
literal|1
decl_stmt|;
define|#
directive|define
name|OPT_LIMIT_DEPTH_DEFAULT
value|1
comment|/* Enabled */
comment|/* 	 * Usage  : !limit-dirs 	 * Type   : boolean 	 * Default: Enabled 	 *	  : Violates the ISO9660 standard if disable. 	 * COMPAT : mkisofs -no-limit-pathtables 	 * 	 * Limits the number of directories less than 65536 due 	 * to the size of the Parent Directory Number of Path 	 * Table. 	 */
name|unsigned
name|int
name|limit_dirs
range|:
literal|1
decl_stmt|;
define|#
directive|define
name|OPT_LIMIT_DIRS_DEFAULT
value|1
comment|/* Enabled */
comment|/* 	 * Usage  : !pad 	 * Type   : boolean 	 * Default: Enabled 	 * COMPAT : -pad/-no-pad 	 * 	 * Pads the end of the ISO image by null of 300Ki bytes. 	 */
name|unsigned
name|int
name|pad
range|:
literal|1
decl_stmt|;
define|#
directive|define
name|OPT_PAD_DEFAULT
value|1
comment|/* Enabled */
comment|/* 	 * Usage  : publisher=<value> 	 * Type   : string, max 128 bytes 	 * Default: Not specified 	 * COMPAT : mkisofs -publisher<value> 	 * 	 * Specifies Publisher Identifier. 	 * If the first byte is set to '_'(5F), the remaining 	 * bytes of this option shall specify an identifier 	 * for a file containing the identification of the user. 	 * This file shall be described in the Root Directory. 	 */
name|unsigned
name|int
name|publisher
range|:
literal|1
decl_stmt|;
define|#
directive|define
name|OPT_PUBLISHER_DEFAULT
value|0
comment|/* Not specified */
define|#
directive|define
name|PUBLISHER_IDENTIFIER_SIZE
value|128
comment|/* 	 * Usage  : rockridge 	 *        : !rockridge 	 *        :    disable to generate SUSP and RR records. 	 *        : rockridge 	 *        :    the same as 'rockridge=useful'. 	 *        : rockridge=strict 	 *        :    generate SUSP and RR records. 	 *        :    [COMPAT: mkisofs -R] 	 *        : rockridge=useful [DEFAULT] 	 *        :    generate SUSP and RR records. 	 *        :    [COMPAT: mkisofs -r] 	 *        :    NOTE  Our rockridge=useful option does not set a zero 	 *        :          to uid and gid, you should use application 	 *        :          option such as --gid,--gname,--uid and --uname 	 *        :          badtar options instead. 	 * Type   : boolean/string 	 * Default: Enabled as rockridge=useful 	 * COMPAT : mkisofs -r / -R 	 * 	 * Generates SUSP and RR records. 	 */
name|unsigned
name|int
name|rr
range|:
literal|2
decl_stmt|;
define|#
directive|define
name|OPT_RR_DISABLED
value|0
define|#
directive|define
name|OPT_RR_STRICT
value|1
define|#
directive|define
name|OPT_RR_USEFUL
value|2
define|#
directive|define
name|OPT_RR_DEFAULT
value|OPT_RR_USEFUL
comment|/* 	 * Usage  : volume-id=<value> 	 * Type   : string, max 32 bytes 	 * Default: Not specified 	 * COMPAT : mkisofs -V<value> 	 * 	 * Specifies Volume Identifier. 	 */
name|unsigned
name|int
name|volume_id
range|:
literal|1
decl_stmt|;
define|#
directive|define
name|OPT_VOLUME_ID_DEFAULT
value|0
comment|/* Use default identifier */
define|#
directive|define
name|VOLUME_IDENTIFIER_SIZE
value|32
comment|/* 	 * Usage  : !zisofs [DEFAULT]  	 *        :    Disable to generate RRIP 'ZF' extension. 	 *        : zisofs 	 *        :    Make files zisofs file and generate RRIP 'ZF'  	 *        :    extension. So you do not need mkzftree utility 	 *        :    for making zisofs. 	 *        :    When the file size is less than one Logical Block 	 *        :    size, that file will not zisofs'ed since it does 	 *        :    reduece an ISO-image size. 	 *        : 	 *        :    When you specify option 'boot=<boot-image>', that 	 *        :    'boot-image' file won't be converted to zisofs file. 	 * Type   : boolean 	 * Default: Disabled 	 * 	 * Generates RRIP 'ZF' System Use Entry. 	 */
name|unsigned
name|int
name|zisofs
range|:
literal|1
decl_stmt|;
define|#
directive|define
name|OPT_ZISOFS_DISABLED
value|0
define|#
directive|define
name|OPT_ZISOFS_DIRECT
value|1
define|#
directive|define
name|OPT_ZISOFS_DEFAULT
value|OPT_ZISOFS_DISABLED
block|}
struct|;
end_struct

begin_struct
struct|struct
name|iso9660
block|{
comment|/* The creation time of ISO image. */
name|time_t
name|birth_time
decl_stmt|;
comment|/* A file stream of a temporary file, which file contents 	 * save to until ISO iamge can be created. */
name|int
name|temp_fd
decl_stmt|;
name|struct
name|isofile
modifier|*
name|cur_file
decl_stmt|;
name|struct
name|isoent
modifier|*
name|cur_dirent
decl_stmt|;
name|struct
name|archive_string
name|cur_dirstr
decl_stmt|;
name|uint64_t
name|bytes_remaining
decl_stmt|;
name|int
name|need_multi_extent
decl_stmt|;
comment|/* Temporary string buffer for Joliet extension. */
name|struct
name|archive_string
name|utf16be
decl_stmt|;
name|struct
name|archive_string
name|mbs
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|sconv_to_utf16be
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|sconv_from_utf16be
decl_stmt|;
comment|/* A list of all of struct isofile entries. */
struct|struct
block|{
name|struct
name|isofile
modifier|*
name|first
decl_stmt|;
name|struct
name|isofile
modifier|*
modifier|*
name|last
decl_stmt|;
block|}
name|all_file_list
struct|;
comment|/* A list of struct isofile entries which have its 	 * contents and are not a directory, a hardlined file 	 * and a symlink file. */
struct|struct
block|{
name|struct
name|isofile
modifier|*
name|first
decl_stmt|;
name|struct
name|isofile
modifier|*
modifier|*
name|last
decl_stmt|;
block|}
name|data_file_list
struct|;
comment|/* Used for managing to find hardlinking files. */
name|struct
name|archive_rb_tree
name|hardlink_rbtree
decl_stmt|;
comment|/* Used for making the Path Table Record. */
struct|struct
name|vdd
block|{
comment|/* the root of entry tree. */
name|struct
name|isoent
modifier|*
name|rootent
decl_stmt|;
enum|enum
name|vdd_type
block|{
name|VDD_PRIMARY
block|,
name|VDD_JOLIET
block|,
name|VDD_ENHANCED
block|}
name|vdd_type
enum|;
struct|struct
name|path_table
block|{
name|struct
name|isoent
modifier|*
name|first
decl_stmt|;
name|struct
name|isoent
modifier|*
modifier|*
name|last
decl_stmt|;
name|struct
name|isoent
modifier|*
modifier|*
name|sorted
decl_stmt|;
name|int
name|cnt
decl_stmt|;
block|}
modifier|*
name|pathtbl
struct|;
name|int
name|max_depth
decl_stmt|;
name|int
name|path_table_block
decl_stmt|;
name|int
name|path_table_size
decl_stmt|;
name|int
name|location_type_L_path_table
decl_stmt|;
name|int
name|location_type_M_path_table
decl_stmt|;
name|int
name|total_dir_block
decl_stmt|;
block|}
name|primary
struct|,
name|joliet
struct|;
comment|/* Used for making a Volume Descriptor. */
name|int
name|volume_space_size
decl_stmt|;
name|int
name|volume_sequence_number
decl_stmt|;
name|int
name|total_file_block
decl_stmt|;
name|struct
name|archive_string
name|volume_identifier
decl_stmt|;
name|struct
name|archive_string
name|publisher_identifier
decl_stmt|;
name|struct
name|archive_string
name|data_preparer_identifier
decl_stmt|;
name|struct
name|archive_string
name|application_identifier
decl_stmt|;
name|struct
name|archive_string
name|copyright_file_identifier
decl_stmt|;
name|struct
name|archive_string
name|abstract_file_identifier
decl_stmt|;
name|struct
name|archive_string
name|bibliographic_file_identifier
decl_stmt|;
comment|/* Used for making rockridge extensions. */
name|int
name|location_rrip_er
decl_stmt|;
comment|/* Used for making zisofs. */
struct|struct
block|{
name|int
name|detect_magic
range|:
literal|1
decl_stmt|;
name|int
name|making
range|:
literal|1
decl_stmt|;
name|int
name|allzero
range|:
literal|1
decl_stmt|;
name|unsigned
name|char
name|magic_buffer
index|[
literal|64
index|]
decl_stmt|;
name|int
name|magic_cnt
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
comment|/* 		 * Copy a compressed file to iso9660.zisofs.temp_fd 		 * and also copy a uncompressed file(original file) to 		 * iso9660.temp_fd . If the number of logical block 		 * of the compressed file is less than the number of 		 * logical block of the uncompressed file, use it and 		 * remove the copy of the uncompressed file. 		 * but if not, we use uncompressed file and remove 		 * the copy of the compressed file. 		 */
name|uint32_t
modifier|*
name|block_pointers
decl_stmt|;
name|size_t
name|block_pointers_allocated
decl_stmt|;
name|int
name|block_pointers_cnt
decl_stmt|;
name|int
name|block_pointers_idx
decl_stmt|;
name|int64_t
name|total_size
decl_stmt|;
name|int64_t
name|block_offset
decl_stmt|;
name|z_stream
name|stream
decl_stmt|;
name|int
name|stream_valid
decl_stmt|;
name|int64_t
name|remaining
decl_stmt|;
name|int
name|compression_level
decl_stmt|;
endif|#
directive|endif
block|}
name|zisofs
struct|;
name|struct
name|isoent
modifier|*
name|directories_too_deep
decl_stmt|;
name|int
name|dircnt_max
decl_stmt|;
comment|/* Write buffer. */
define|#
directive|define
name|wb_buffmax
parameter_list|()
value|(LOGICAL_BLOCK_SIZE * 32)
define|#
directive|define
name|wb_remaining
parameter_list|(
name|a
parameter_list|)
value|(((struct iso9660 *)(a)->format_data)->wbuff_remaining)
define|#
directive|define
name|wb_offset
parameter_list|(
name|a
parameter_list|)
value|(((struct iso9660 *)(a)->format_data)->wbuff_offset \ 		+ wb_buffmax() - wb_remaining(a))
name|unsigned
name|char
name|wbuff
index|[
name|LOGICAL_BLOCK_SIZE
operator|*
literal|32
index|]
decl_stmt|;
name|size_t
name|wbuff_remaining
decl_stmt|;
enum|enum
block|{
name|WB_TO_STREAM
block|,
name|WB_TO_TEMP
block|}
name|wbuff_type
enum|;
name|int64_t
name|wbuff_offset
decl_stmt|;
name|int64_t
name|wbuff_written
decl_stmt|;
name|int64_t
name|wbuff_tail
decl_stmt|;
comment|/* 'El Torito' boot data. */
struct|struct
block|{
comment|/* boot catalog file */
name|struct
name|archive_string
name|catalog_filename
decl_stmt|;
name|struct
name|isoent
modifier|*
name|catalog
decl_stmt|;
comment|/* boot image file */
name|struct
name|archive_string
name|boot_filename
decl_stmt|;
name|struct
name|isoent
modifier|*
name|boot
decl_stmt|;
name|unsigned
name|char
name|platform_id
decl_stmt|;
define|#
directive|define
name|BOOT_PLATFORM_X86
value|0
define|#
directive|define
name|BOOT_PLATFORM_PPC
value|1
define|#
directive|define
name|BOOT_PLATFORM_MAC
value|2
name|struct
name|archive_string
name|id
decl_stmt|;
name|unsigned
name|char
name|media_type
decl_stmt|;
define|#
directive|define
name|BOOT_MEDIA_NO_EMULATION
value|0
define|#
directive|define
name|BOOT_MEDIA_1_2M_DISKETTE
value|1
define|#
directive|define
name|BOOT_MEDIA_1_44M_DISKETTE
value|2
define|#
directive|define
name|BOOT_MEDIA_2_88M_DISKETTE
value|3
define|#
directive|define
name|BOOT_MEDIA_HARD_DISK
value|4
name|unsigned
name|char
name|system_type
decl_stmt|;
name|uint16_t
name|boot_load_seg
decl_stmt|;
name|uint16_t
name|boot_load_size
decl_stmt|;
define|#
directive|define
name|BOOT_LOAD_SIZE
value|4
block|}
name|el_torito
struct|;
name|struct
name|iso_option
name|opt
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Types of Volume Descriptor  */
end_comment

begin_enum
enum|enum
name|VD_type
block|{
name|VDT_BOOT_RECORD
init|=
literal|0
block|,
comment|/* Boot Record Volume Descriptor 	*/
name|VDT_PRIMARY
init|=
literal|1
block|,
comment|/* Primary Volume Descriptor		*/
name|VDT_SUPPLEMENTARY
init|=
literal|2
block|,
comment|/* Supplementary Volume Descriptor	*/
name|VDT_TERMINATOR
init|=
literal|255
comment|/* Volume Descriptor Set Terminator	*/
block|}
enum|;
end_enum

begin_comment
comment|/*  * Types of Directory Record  */
end_comment

begin_enum
enum|enum
name|dir_rec_type
block|{
name|DIR_REC_VD
block|,
comment|/* Stored in Volume Descriptor.	*/
name|DIR_REC_SELF
block|,
comment|/* Stored as Current Directory.	*/
name|DIR_REC_PARENT
block|,
comment|/* Stored as Parent Directory.	*/
name|DIR_REC_NORMAL
block|,
comment|/* Stored as Child.		*/
block|}
enum|;
end_enum

begin_comment
comment|/*  * Kinds of Volume Descriptor Character  */
end_comment

begin_enum
enum|enum
name|vdc
block|{
name|VDC_STD
block|,
name|VDC_LOWERCASE
block|,
name|VDC_UCS2
block|,
name|VDC_UCS2_DIRECT
block|, }
enum|;
end_enum

begin_comment
comment|/*  * IDentifier Resolver.  * Used for resolving duplicated filenames.  */
end_comment

begin_struct
struct|struct
name|idr
block|{
struct|struct
name|idrent
block|{
name|struct
name|archive_rb_node
name|rbnode
decl_stmt|;
comment|/* Used in wait_list. */
name|struct
name|idrent
modifier|*
name|wnext
decl_stmt|;
name|struct
name|idrent
modifier|*
name|avail
decl_stmt|;
name|struct
name|isoent
modifier|*
name|isoent
decl_stmt|;
name|int
name|weight
decl_stmt|;
name|int
name|noff
decl_stmt|;
name|int
name|rename_num
decl_stmt|;
block|}
modifier|*
name|idrent_pool
struct|;
name|struct
name|archive_rb_tree
name|rbtree
decl_stmt|;
struct|struct
block|{
name|struct
name|idrent
modifier|*
name|first
decl_stmt|;
name|struct
name|idrent
modifier|*
modifier|*
name|last
decl_stmt|;
block|}
name|wait_list
struct|;
name|int
name|pool_size
decl_stmt|;
name|int
name|pool_idx
decl_stmt|;
name|int
name|num_size
decl_stmt|;
name|int
name|null_size
decl_stmt|;
name|char
name|char_map
index|[
literal|0x80
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|char_type
block|{
name|A_CHAR
block|,
name|D_CHAR
block|, }
enum|;
end_enum

begin_function_decl
specifier|static
name|int
name|iso9660_options
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iso9660_write_header
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssize_t
name|iso9660_write_data
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iso9660_finish_entry
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iso9660_close
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iso9660_free
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_system_identitier
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_str
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|char
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|joliet_allowed_char
parameter_list|(
name|unsigned
name|char
parameter_list|,
name|unsigned
name|char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_str_utf16be
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|uint16_t
parameter_list|,
name|enum
name|vdc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_str_a_characters_bp
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|enum
name|vdc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_str_d_characters_bp
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|enum
name|vdc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_VD_bp
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|enum
name|VD_type
parameter_list|,
name|unsigned
name|char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|set_unused_field_bp
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|char
modifier|*
name|extra_open_record
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|isoent
modifier|*
parameter_list|,
name|struct
name|ctl_extr_rec
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|extra_close_record
parameter_list|(
name|struct
name|ctl_extr_rec
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|char
modifier|*
name|extra_next_record
parameter_list|(
name|struct
name|ctl_extr_rec
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|char
modifier|*
name|extra_get_record
parameter_list|(
name|struct
name|isoent
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|extra_tell_used_size
parameter_list|(
name|struct
name|ctl_extr_rec
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|extra_setup_location
parameter_list|(
name|struct
name|isoent
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_directory_record_rr
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|isoent
modifier|*
parameter_list|,
name|struct
name|iso9660
modifier|*
parameter_list|,
name|enum
name|dir_rec_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_directory_record
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|isoent
modifier|*
parameter_list|,
name|struct
name|iso9660
modifier|*
parameter_list|,
name|enum
name|dir_rec_type
parameter_list|,
name|enum
name|vdd_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|get_dir_rec_size
parameter_list|(
name|struct
name|iso9660
modifier|*
parameter_list|,
name|struct
name|isoent
modifier|*
parameter_list|,
name|enum
name|dir_rec_type
parameter_list|,
name|enum
name|vdd_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|unsigned
name|char
modifier|*
name|wb_buffptr
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wb_write_out
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wb_consume
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
end_ifdef

begin_function_decl
specifier|static
name|int
name|wb_set_offset
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|write_null
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|write_VD_terminator
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_file_identifier
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|enum
name|vdc
parameter_list|,
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|vdd
modifier|*
parameter_list|,
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|enum
name|char_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|write_VD
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|vdd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|write_VD_boot_record
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|write_information_block
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|write_path_table
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|vdd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|write_directory_descriptors
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|vdd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|write_file_descriptors
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|write_rr_ER
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|calculate_path_table_size
parameter_list|(
name|struct
name|vdd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isofile_init_entry_list
parameter_list|(
name|struct
name|iso9660
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isofile_add_entry
parameter_list|(
name|struct
name|iso9660
modifier|*
parameter_list|,
name|struct
name|isofile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isofile_free_all_entries
parameter_list|(
name|struct
name|iso9660
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isofile_init_entry_data_file_list
parameter_list|(
name|struct
name|iso9660
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isofile_add_data_file
parameter_list|(
name|struct
name|iso9660
modifier|*
parameter_list|,
name|struct
name|isofile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|isofile
modifier|*
name|isofile_new
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isofile_free
parameter_list|(
name|struct
name|isofile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isofile_gen_utility_names
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|isofile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isofile_register_hardlink
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|isofile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isofile_connect_hardlink_files
parameter_list|(
name|struct
name|iso9660
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isofile_init_hardlinks
parameter_list|(
name|struct
name|iso9660
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isofile_free_hardlinks
parameter_list|(
name|struct
name|iso9660
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|isoent
modifier|*
name|isoent_new
parameter_list|(
name|struct
name|isofile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isoent_clone_tree
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|isoent
modifier|*
modifier|*
parameter_list|,
name|struct
name|isoent
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_isoent_free
parameter_list|(
name|struct
name|isoent
modifier|*
name|isoent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isoent_free_all
parameter_list|(
name|struct
name|isoent
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|isoent
modifier|*
name|isoent_create_virtual_dir
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|iso9660
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isoent_cmp_node
parameter_list|(
specifier|const
name|struct
name|archive_rb_node
modifier|*
parameter_list|,
specifier|const
name|struct
name|archive_rb_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isoent_cmp_key
parameter_list|(
specifier|const
name|struct
name|archive_rb_node
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isoent_add_child_head
parameter_list|(
name|struct
name|isoent
modifier|*
parameter_list|,
name|struct
name|isoent
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isoent_add_child_tail
parameter_list|(
name|struct
name|isoent
modifier|*
parameter_list|,
name|struct
name|isoent
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isoent_remove_child
parameter_list|(
name|struct
name|isoent
modifier|*
parameter_list|,
name|struct
name|isoent
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isoent_setup_directory_location
parameter_list|(
name|struct
name|iso9660
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|vdd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isoent_setup_file_location
parameter_list|(
name|struct
name|iso9660
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_path_component
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isoent_tree
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|isoent
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|isoent
modifier|*
name|isoent_find_child
parameter_list|(
name|struct
name|isoent
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|isoent
modifier|*
name|isoent_find_entry
parameter_list|(
name|struct
name|isoent
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|idr_relaxed_filenames
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|idr_init
parameter_list|(
name|struct
name|iso9660
modifier|*
parameter_list|,
name|struct
name|vdd
modifier|*
parameter_list|,
name|struct
name|idr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|idr_cleanup
parameter_list|(
name|struct
name|idr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|idr_ensure_poolsize
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|idr
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|idr_start
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|idr
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|struct
name|archive_rb_tree_ops
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|idr_register
parameter_list|(
name|struct
name|idr
modifier|*
parameter_list|,
name|struct
name|isoent
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|idr_extend_identifier
parameter_list|(
name|struct
name|idrent
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|idr_resolve
parameter_list|(
name|struct
name|idr
modifier|*
parameter_list|,
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|idr_set_num
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|idr_set_num_beutf16
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isoent_gen_iso9660_identifier
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|isoent
modifier|*
parameter_list|,
name|struct
name|idr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isoent_gen_joliet_identifier
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|isoent
modifier|*
parameter_list|,
name|struct
name|idr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isoent_cmp_iso9660_identifier
parameter_list|(
specifier|const
name|struct
name|isoent
modifier|*
parameter_list|,
specifier|const
name|struct
name|isoent
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isoent_cmp_node_iso9660
parameter_list|(
specifier|const
name|struct
name|archive_rb_node
modifier|*
parameter_list|,
specifier|const
name|struct
name|archive_rb_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isoent_cmp_key_iso9660
parameter_list|(
specifier|const
name|struct
name|archive_rb_node
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isoent_cmp_joliet_identifier
parameter_list|(
specifier|const
name|struct
name|isoent
modifier|*
parameter_list|,
specifier|const
name|struct
name|isoent
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isoent_cmp_node_joliet
parameter_list|(
specifier|const
name|struct
name|archive_rb_node
modifier|*
parameter_list|,
specifier|const
name|struct
name|archive_rb_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isoent_cmp_key_joliet
parameter_list|(
specifier|const
name|struct
name|archive_rb_node
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|path_table_add_entry
parameter_list|(
name|struct
name|path_table
modifier|*
parameter_list|,
name|struct
name|isoent
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|struct
name|isoent
modifier|*
name|path_table_last_entry
parameter_list|(
name|struct
name|path_table
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isoent_make_path_table
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isoent_find_out_boot_file
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|isoent
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isoent_create_boot_catalog
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|isoent
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|fd_boot_image_size
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|make_boot_catalog
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|setup_boot_information
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zisofs_init
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|isofile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zisofs_detect_magic
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zisofs_write_to_temp
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zisofs_finish_entry
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zisofs_rewind_boot_file
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zisofs_free
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|archive_write_set_format_iso9660
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_write
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_write
operator|*
operator|)
name|_a
decl_stmt|;
name|struct
name|iso9660
modifier|*
name|iso9660
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_WRITE_MAGIC
argument_list|,
name|ARCHIVE_STATE_NEW
argument_list|,
literal|"archive_write_set_format_iso9660"
argument_list|)
expr_stmt|;
comment|/* If another format was already registered, unregister it. */
if|if
condition|(
name|a
operator|->
name|format_free
operator|!=
name|NULL
condition|)
call|(
name|a
operator|->
name|format_free
call|)
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|iso9660
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|iso9660
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate iso9660 data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|iso9660
operator|->
name|birth_time
operator|=
literal|0
expr_stmt|;
name|iso9660
operator|->
name|temp_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|iso9660
operator|->
name|cur_file
operator|=
name|NULL
expr_stmt|;
name|iso9660
operator|->
name|primary
operator|.
name|max_depth
operator|=
literal|0
expr_stmt|;
name|iso9660
operator|->
name|primary
operator|.
name|vdd_type
operator|=
name|VDD_PRIMARY
expr_stmt|;
name|iso9660
operator|->
name|primary
operator|.
name|pathtbl
operator|=
name|NULL
expr_stmt|;
name|iso9660
operator|->
name|joliet
operator|.
name|rootent
operator|=
name|NULL
expr_stmt|;
name|iso9660
operator|->
name|joliet
operator|.
name|max_depth
operator|=
literal|0
expr_stmt|;
name|iso9660
operator|->
name|joliet
operator|.
name|vdd_type
operator|=
name|VDD_JOLIET
expr_stmt|;
name|iso9660
operator|->
name|joliet
operator|.
name|pathtbl
operator|=
name|NULL
expr_stmt|;
name|isofile_init_entry_list
argument_list|(
name|iso9660
argument_list|)
expr_stmt|;
name|isofile_init_entry_data_file_list
argument_list|(
name|iso9660
argument_list|)
expr_stmt|;
name|isofile_init_hardlinks
argument_list|(
name|iso9660
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|directories_too_deep
operator|=
name|NULL
expr_stmt|;
name|iso9660
operator|->
name|dircnt_max
operator|=
literal|1
expr_stmt|;
name|iso9660
operator|->
name|wbuff_remaining
operator|=
name|wb_buffmax
argument_list|()
expr_stmt|;
name|iso9660
operator|->
name|wbuff_type
operator|=
name|WB_TO_TEMP
expr_stmt|;
name|iso9660
operator|->
name|wbuff_offset
operator|=
literal|0
expr_stmt|;
name|iso9660
operator|->
name|wbuff_written
operator|=
literal|0
expr_stmt|;
name|iso9660
operator|->
name|wbuff_tail
operator|=
literal|0
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|utf16be
operator|)
argument_list|)
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|mbs
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Init Identifiers used for PVD and SVD. 	 */
name|archive_string_init
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|volume_identifier
operator|)
argument_list|)
expr_stmt|;
name|archive_strcpy
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|volume_identifier
operator|)
argument_list|,
literal|"CDROM"
argument_list|)
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|publisher_identifier
operator|)
argument_list|)
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|data_preparer_identifier
operator|)
argument_list|)
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|application_identifier
operator|)
argument_list|)
expr_stmt|;
name|archive_strcpy
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|application_identifier
operator|)
argument_list|,
name|archive_version_string
argument_list|()
argument_list|)
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|copyright_file_identifier
operator|)
argument_list|)
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|abstract_file_identifier
operator|)
argument_list|)
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|bibliographic_file_identifier
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Init El Torito bootable CD variables. 	 */
name|archive_string_init
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|el_torito
operator|.
name|catalog_filename
operator|)
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|el_torito
operator|.
name|catalog
operator|=
name|NULL
expr_stmt|;
comment|/* Set default file name of boot catalog  */
name|archive_strcpy
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|el_torito
operator|.
name|catalog_filename
operator|)
argument_list|,
literal|"boot.catalog"
argument_list|)
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|el_torito
operator|.
name|boot_filename
operator|)
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|el_torito
operator|.
name|boot
operator|=
name|NULL
expr_stmt|;
name|iso9660
operator|->
name|el_torito
operator|.
name|platform_id
operator|=
name|BOOT_PLATFORM_X86
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|el_torito
operator|.
name|id
operator|)
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|el_torito
operator|.
name|boot_load_seg
operator|=
literal|0
expr_stmt|;
name|iso9660
operator|->
name|el_torito
operator|.
name|boot_load_size
operator|=
name|BOOT_LOAD_SIZE
expr_stmt|;
comment|/* 	 * Init zisofs variables. 	 */
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
name|iso9660
operator|->
name|zisofs
operator|.
name|block_pointers
operator|=
name|NULL
expr_stmt|;
name|iso9660
operator|->
name|zisofs
operator|.
name|block_pointers_allocated
operator|=
literal|0
expr_stmt|;
name|iso9660
operator|->
name|zisofs
operator|.
name|stream_valid
operator|=
literal|0
expr_stmt|;
name|iso9660
operator|->
name|zisofs
operator|.
name|compression_level
operator|=
literal|9
expr_stmt|;
name|memset
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|zisofs
operator|.
name|stream
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|iso9660
operator|->
name|zisofs
operator|.
name|stream
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Set default value of iso9660 options. 	 */
name|iso9660
operator|->
name|opt
operator|.
name|abstract_file
operator|=
name|OPT_ABSTRACT_FILE_DEFAULT
expr_stmt|;
name|iso9660
operator|->
name|opt
operator|.
name|application_id
operator|=
name|OPT_APPLICATION_ID_DEFAULT
expr_stmt|;
name|iso9660
operator|->
name|opt
operator|.
name|allow_vernum
operator|=
name|OPT_ALLOW_VERNUM_DEFAULT
expr_stmt|;
name|iso9660
operator|->
name|opt
operator|.
name|biblio_file
operator|=
name|OPT_BIBLIO_FILE_DEFAULT
expr_stmt|;
name|iso9660
operator|->
name|opt
operator|.
name|boot
operator|=
name|OPT_BOOT_DEFAULT
expr_stmt|;
name|iso9660
operator|->
name|opt
operator|.
name|boot_catalog
operator|=
name|OPT_BOOT_CATALOG_DEFAULT
expr_stmt|;
name|iso9660
operator|->
name|opt
operator|.
name|boot_info_table
operator|=
name|OPT_BOOT_INFO_TABLE_DEFAULT
expr_stmt|;
name|iso9660
operator|->
name|opt
operator|.
name|boot_load_seg
operator|=
name|OPT_BOOT_LOAD_SEG_DEFAULT
expr_stmt|;
name|iso9660
operator|->
name|opt
operator|.
name|boot_load_size
operator|=
name|OPT_BOOT_LOAD_SIZE_DEFAULT
expr_stmt|;
name|iso9660
operator|->
name|opt
operator|.
name|boot_type
operator|=
name|OPT_BOOT_TYPE_DEFAULT
expr_stmt|;
name|iso9660
operator|->
name|opt
operator|.
name|compression_level
operator|=
name|OPT_COMPRESSION_LEVEL_DEFAULT
expr_stmt|;
name|iso9660
operator|->
name|opt
operator|.
name|copyright_file
operator|=
name|OPT_COPYRIGHT_FILE_DEFAULT
expr_stmt|;
name|iso9660
operator|->
name|opt
operator|.
name|iso_level
operator|=
name|OPT_ISO_LEVEL_DEFAULT
expr_stmt|;
name|iso9660
operator|->
name|opt
operator|.
name|joliet
operator|=
name|OPT_JOLIET_DEFAULT
expr_stmt|;
name|iso9660
operator|->
name|opt
operator|.
name|limit_depth
operator|=
name|OPT_LIMIT_DEPTH_DEFAULT
expr_stmt|;
name|iso9660
operator|->
name|opt
operator|.
name|limit_dirs
operator|=
name|OPT_LIMIT_DIRS_DEFAULT
expr_stmt|;
name|iso9660
operator|->
name|opt
operator|.
name|pad
operator|=
name|OPT_PAD_DEFAULT
expr_stmt|;
name|iso9660
operator|->
name|opt
operator|.
name|publisher
operator|=
name|OPT_PUBLISHER_DEFAULT
expr_stmt|;
name|iso9660
operator|->
name|opt
operator|.
name|rr
operator|=
name|OPT_RR_DEFAULT
expr_stmt|;
name|iso9660
operator|->
name|opt
operator|.
name|volume_id
operator|=
name|OPT_VOLUME_ID_DEFAULT
expr_stmt|;
name|iso9660
operator|->
name|opt
operator|.
name|zisofs
operator|=
name|OPT_ZISOFS_DEFAULT
expr_stmt|;
comment|/* Create the root directory. */
name|iso9660
operator|->
name|primary
operator|.
name|rootent
operator|=
name|isoent_create_virtual_dir
argument_list|(
name|a
argument_list|,
name|iso9660
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|primary
operator|.
name|rootent
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|iso9660
argument_list|)
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|iso9660
operator|->
name|primary
operator|.
name|rootent
operator|->
name|parent
operator|=
name|iso9660
operator|->
name|primary
operator|.
name|rootent
expr_stmt|;
name|iso9660
operator|->
name|cur_dirent
operator|=
name|iso9660
operator|->
name|primary
operator|.
name|rootent
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|cur_dirstr
operator|)
argument_list|)
expr_stmt|;
name|archive_string_ensure
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|cur_dirstr
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|cur_dirstr
operator|.
name|s
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|iso9660
operator|->
name|sconv_to_utf16be
operator|=
name|NULL
expr_stmt|;
name|iso9660
operator|->
name|sconv_from_utf16be
operator|=
name|NULL
expr_stmt|;
name|a
operator|->
name|format_data
operator|=
name|iso9660
expr_stmt|;
name|a
operator|->
name|format_name
operator|=
literal|"iso9660"
expr_stmt|;
name|a
operator|->
name|format_options
operator|=
name|iso9660_options
expr_stmt|;
name|a
operator|->
name|format_write_header
operator|=
name|iso9660_write_header
expr_stmt|;
name|a
operator|->
name|format_write_data
operator|=
name|iso9660_write_data
expr_stmt|;
name|a
operator|->
name|format_finish_entry
operator|=
name|iso9660_finish_entry
expr_stmt|;
name|a
operator|->
name|format_close
operator|=
name|iso9660_close
expr_stmt|;
name|a
operator|->
name|format_free
operator|=
name|iso9660_free
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_ISO9660
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"ISO9660"
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_str_opt
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|archive_string
modifier|*
name|s
parameter_list|,
name|size_t
name|maxsize
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|value
argument_list|)
operator|>
name|maxsize
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Value is longer than %zu characters "
literal|"for option ``%s''"
argument_list|,
name|maxsize
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_strcpy
argument_list|(
name|s
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_num_opt
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|int
modifier|*
name|num
parameter_list|,
name|int
name|high
parameter_list|,
name|int
name|low
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|value
decl_stmt|;
name|int
name|data
init|=
literal|0
decl_stmt|;
name|int
name|neg
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Invalid value(empty) for option ``%s''"
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|neg
operator|=
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
name|data
operator|=
name|data
operator|*
literal|10
operator|+
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
else|else
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Invalid value for option ``%s''"
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|data
operator|>
name|high
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Invalid value(over %d) for "
literal|"option ``%s''"
argument_list|,
name|high
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|data
operator|<
name|low
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Invalid value(under %d) for "
literal|"option ``%s''"
argument_list|,
name|low
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|neg
condition|)
name|data
operator|*=
operator|-
literal|1
expr_stmt|;
operator|*
name|num
operator|=
name|data
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iso9660_options
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
name|a
operator|->
name|format_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|r
decl_stmt|;
switch|switch
condition|(
name|key
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'a'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"abstract-file"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|get_str_opt
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|abstract_file_identifier
operator|)
argument_list|,
name|ABSTRACT_FILE_SIZE
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|opt
operator|.
name|abstract_file
operator|=
name|r
operator|==
name|ARCHIVE_OK
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"application-id"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|get_str_opt
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|application_identifier
operator|)
argument_list|,
name|APPLICATION_IDENTIFIER_SIZE
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|opt
operator|.
name|application_id
operator|=
name|r
operator|==
name|ARCHIVE_OK
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"allow-vernum"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|iso9660
operator|->
name|opt
operator|.
name|allow_vernum
operator|=
name|value
operator|!=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"biblio-file"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|get_str_opt
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|bibliographic_file_identifier
operator|)
argument_list|,
name|BIBLIO_FILE_SIZE
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|opt
operator|.
name|biblio_file
operator|=
name|r
operator|==
name|ARCHIVE_OK
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"boot"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
name|iso9660
operator|->
name|opt
operator|.
name|boot
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|iso9660
operator|->
name|opt
operator|.
name|boot
operator|=
literal|1
expr_stmt|;
name|archive_strcpy
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|el_torito
operator|.
name|boot_filename
operator|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"boot-catalog"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|get_str_opt
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|el_torito
operator|.
name|catalog_filename
operator|)
argument_list|,
literal|1024
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|opt
operator|.
name|boot_catalog
operator|=
name|r
operator|==
name|ARCHIVE_OK
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"boot-info-table"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|iso9660
operator|->
name|opt
operator|.
name|boot_info_table
operator|=
name|value
operator|!=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"boot-load-seg"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|uint32_t
name|seg
decl_stmt|;
name|iso9660
operator|->
name|opt
operator|.
name|boot_load_seg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
goto|goto
name|invalid_value
goto|;
name|seg
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'x'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
name|seg
condition|)
name|seg
operator|<<=
literal|4
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|>=
literal|'A'
operator|&&
operator|*
name|p
operator|<=
literal|'F'
condition|)
name|seg
operator|+=
operator|*
name|p
operator|-
literal|'A'
operator|+
literal|0x0a
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|>=
literal|'a'
operator|&&
operator|*
name|p
operator|<=
literal|'f'
condition|)
name|seg
operator|+=
operator|*
name|p
operator|-
literal|'a'
operator|+
literal|0x0a
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
name|seg
operator|+=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
else|else
goto|goto
name|invalid_value
goto|;
if|if
condition|(
name|seg
operator|>
literal|0xffff
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Invalid value(over 0xffff) for "
literal|"option ``%s''"
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|p
operator|++
expr_stmt|;
block|}
name|iso9660
operator|->
name|el_torito
operator|.
name|boot_load_seg
operator|=
operator|(
name|uint16_t
operator|)
name|seg
expr_stmt|;
name|iso9660
operator|->
name|opt
operator|.
name|boot_load_seg
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"boot-load-size"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|num
init|=
literal|0
decl_stmt|;
name|r
operator|=
name|get_num_opt
argument_list|(
name|a
argument_list|,
operator|&
name|num
argument_list|,
literal|0xffff
argument_list|,
literal|1
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|opt
operator|.
name|boot_load_size
operator|=
name|r
operator|==
name|ARCHIVE_OK
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|iso9660
operator|->
name|el_torito
operator|.
name|boot_load_size
operator|=
operator|(
name|uint16_t
operator|)
name|num
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"boot-type"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
goto|goto
name|invalid_value
goto|;
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"no-emulation"
argument_list|)
operator|==
literal|0
condition|)
name|iso9660
operator|->
name|opt
operator|.
name|boot_type
operator|=
name|OPT_BOOT_TYPE_NO_EMU
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"fd"
argument_list|)
operator|==
literal|0
condition|)
name|iso9660
operator|->
name|opt
operator|.
name|boot_type
operator|=
name|OPT_BOOT_TYPE_FD
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"hard-disk"
argument_list|)
operator|==
literal|0
condition|)
name|iso9660
operator|->
name|opt
operator|.
name|boot_type
operator|=
name|OPT_BOOT_TYPE_HARD_DISK
expr_stmt|;
else|else
goto|goto
name|invalid_value
goto|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"compression-level"
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
if|if
condition|(
name|value
operator|==
name|NULL
operator|||
operator|!
operator|(
name|value
index|[
literal|0
index|]
operator|>=
literal|'0'
operator|&&
name|value
index|[
literal|0
index|]
operator|<=
literal|'9'
operator|)
operator|||
name|value
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
goto|goto
name|invalid_value
goto|;
name|iso9660
operator|->
name|zisofs
operator|.
name|compression_level
operator|=
name|value
index|[
literal|0
index|]
operator|-
literal|'0'
expr_stmt|;
name|iso9660
operator|->
name|opt
operator|.
name|compression_level
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
else|#
directive|else
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Option ``%s'' "
literal|"is not supported on this platform."
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
endif|#
directive|endif
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"copyright-file"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|get_str_opt
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|copyright_file_identifier
operator|)
argument_list|,
name|COPYRIGHT_FILE_SIZE
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|opt
operator|.
name|copyright_file
operator|=
name|r
operator|==
name|ARCHIVE_OK
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
comment|/* Specifies Volume creation date and time; 		 * year(4),month(2),day(2),hour(2),minute(2),second(2). 		 * e.g. "20090929033757" 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"creation"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|tm
name|tm
decl_stmt|;
name|char
name|buf
index|[
literal|5
index|]
decl_stmt|;
name|p
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|p
argument_list|)
operator|<
literal|14
condition|)
goto|goto
name|invalid_value
goto|;
name|memset
argument_list|(
operator|&
name|tm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tm
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|tm
operator|.
name|tm_year
operator|=
name|strtol
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
operator|-
literal|1900
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
name|tm
operator|.
name|tm_mon
operator|=
name|strtol
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
operator|-
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
name|tm
operator|.
name|tm_mday
operator|=
name|strtol
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
name|tm
operator|.
name|tm_hour
operator|=
name|strtol
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
name|tm
operator|.
name|tm_min
operator|=
name|strtol
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tm
operator|.
name|tm_sec
operator|=
name|strtol
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|birth_time
operator|=
name|mktime
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
endif|#
directive|endif
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"iso-level"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|value
operator|!=
name|NULL
operator|&&
name|value
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|&&
operator|(
name|value
index|[
literal|0
index|]
operator|>=
literal|'1'
operator|&&
name|value
index|[
literal|0
index|]
operator|<=
literal|'4'
operator|)
condition|)
block|{
name|iso9660
operator|->
name|opt
operator|.
name|iso_level
operator|=
name|value
index|[
literal|0
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
goto|goto
name|invalid_value
goto|;
block|}
break|break;
case|case
literal|'j'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"joliet"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
name|iso9660
operator|->
name|opt
operator|.
name|joliet
operator|=
name|OPT_JOLIET_DISABLE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"1"
argument_list|)
operator|==
literal|0
condition|)
name|iso9660
operator|->
name|opt
operator|.
name|joliet
operator|=
name|OPT_JOLIET_ENABLE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"long"
argument_list|)
operator|==
literal|0
condition|)
name|iso9660
operator|->
name|opt
operator|.
name|joliet
operator|=
name|OPT_JOLIET_LONGNAME
expr_stmt|;
else|else
goto|goto
name|invalid_value
goto|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"limit-depth"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|iso9660
operator|->
name|opt
operator|.
name|limit_depth
operator|=
name|value
operator|!=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"limit-dirs"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|iso9660
operator|->
name|opt
operator|.
name|limit_dirs
operator|=
name|value
operator|!=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"pad"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|iso9660
operator|->
name|opt
operator|.
name|pad
operator|=
name|value
operator|!=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"publisher"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|get_str_opt
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|publisher_identifier
operator|)
argument_list|,
name|PUBLISHER_IDENTIFIER_SIZE
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|opt
operator|.
name|publisher
operator|=
name|r
operator|==
name|ARCHIVE_OK
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"rockridge"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"Rockridge"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
name|iso9660
operator|->
name|opt
operator|.
name|rr
operator|=
name|OPT_RR_DISABLED
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"1"
argument_list|)
operator|==
literal|0
condition|)
name|iso9660
operator|->
name|opt
operator|.
name|rr
operator|=
name|OPT_RR_USEFUL
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"strict"
argument_list|)
operator|==
literal|0
condition|)
name|iso9660
operator|->
name|opt
operator|.
name|rr
operator|=
name|OPT_RR_STRICT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"useful"
argument_list|)
operator|==
literal|0
condition|)
name|iso9660
operator|->
name|opt
operator|.
name|rr
operator|=
name|OPT_RR_USEFUL
expr_stmt|;
else|else
goto|goto
name|invalid_value
goto|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
break|break;
case|case
literal|'v'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"volume-id"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|get_str_opt
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|volume_identifier
operator|)
argument_list|,
name|VOLUME_IDENTIFIER_SIZE
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|opt
operator|.
name|volume_id
operator|=
name|r
operator|==
name|ARCHIVE_OK
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
break|break;
case|case
literal|'z'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"zisofs"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
name|iso9660
operator|->
name|opt
operator|.
name|zisofs
operator|=
name|OPT_ZISOFS_DISABLED
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
name|iso9660
operator|->
name|opt
operator|.
name|zisofs
operator|=
name|OPT_ZISOFS_DIRECT
expr_stmt|;
else|#
directive|else
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"``zisofs'' "
literal|"is not supported on this platform."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
endif|#
directive|endif
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
break|break;
block|}
comment|/* Note: The "warn" return is just to inform the options 	 * supervisor that we didn't handle it.  It will generate 	 * a suitable error if no one used this option. */
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
name|invalid_value
label|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Invalid value for option ``%s''"
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iso9660_write_header
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
decl_stmt|;
name|struct
name|isofile
modifier|*
name|file
decl_stmt|;
name|struct
name|isoent
modifier|*
name|isoent
decl_stmt|;
name|int
name|r
decl_stmt|,
name|ret
init|=
name|ARCHIVE_OK
decl_stmt|;
name|iso9660
operator|=
name|a
operator|->
name|format_data
expr_stmt|;
name|iso9660
operator|->
name|cur_file
operator|=
name|NULL
expr_stmt|;
name|iso9660
operator|->
name|bytes_remaining
operator|=
literal|0
expr_stmt|;
name|iso9660
operator|->
name|need_multi_extent
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
operator|==
name|AE_IFLNK
operator|&&
name|iso9660
operator|->
name|opt
operator|.
name|rr
operator|==
name|OPT_RR_DISABLED
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Ignore symlink file."
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|cur_file
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
if|if
condition|(
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
operator|==
name|AE_IFREG
operator|&&
name|archive_entry_size
argument_list|(
name|entry
argument_list|)
operator|>=
name|MULTI_EXTENT_SIZE
condition|)
block|{
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|iso_level
operator|<
literal|3
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Ignore over %lld bytes file. "
literal|"This file too large."
argument_list|,
name|MULTI_EXTENT_SIZE
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|cur_file
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
name|iso9660
operator|->
name|need_multi_extent
operator|=
literal|1
expr_stmt|;
block|}
name|file
operator|=
name|isofile_new
argument_list|(
name|a
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|r
operator|=
name|isofile_gen_utility_names
argument_list|(
name|a
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|ARCHIVE_WARN
condition|)
block|{
name|isofile_free
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|<
name|ret
condition|)
name|ret
operator|=
name|r
expr_stmt|;
comment|/* 	 * Ignore a path which looks like the top of directory name 	 * since we have already made the root directory of an ISO image. 	 */
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
operator|(
name|file
operator|->
name|parentdir
operator|)
argument_list|)
operator|==
literal|0
operator|&&
name|archive_strlen
argument_list|(
operator|&
operator|(
name|file
operator|->
name|basename
operator|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|isofile_free
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
name|isofile_add_entry
argument_list|(
name|iso9660
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|isoent
operator|=
name|isoent_new
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|isoent
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|isoent
operator|->
name|file
operator|->
name|dircnt
operator|>
name|iso9660
operator|->
name|dircnt_max
condition|)
name|iso9660
operator|->
name|dircnt_max
operator|=
name|isoent
operator|->
name|file
operator|->
name|dircnt
expr_stmt|;
comment|/* Add the current file into tree */
name|r
operator|=
name|isoent_tree
argument_list|(
name|a
argument_list|,
operator|&
name|isoent
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
comment|/* If there is the same file in tree and 	 * the current file is older than the file in tree. 	 * So we don't need the current file data anymore. */
if|if
condition|(
name|isoent
operator|->
name|file
operator|!=
name|file
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
comment|/* Non regular files contents are unneeded to be saved to 	 * temporary files. */
if|if
condition|(
name|archive_entry_filetype
argument_list|(
name|file
operator|->
name|entry
argument_list|)
operator|!=
name|AE_IFREG
condition|)
return|return
operator|(
name|ret
operator|)
return|;
comment|/* 	 * Set the current file to cur_file to read its contents. 	 */
name|iso9660
operator|->
name|cur_file
operator|=
name|file
expr_stmt|;
if|if
condition|(
name|archive_entry_nlink
argument_list|(
name|file
operator|->
name|entry
argument_list|)
operator|>
literal|1
condition|)
block|{
name|r
operator|=
name|isofile_register_hardlink
argument_list|(
name|a
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* 	 * Prepare to save the contents of the file. 	 */
if|if
condition|(
name|iso9660
operator|->
name|temp_fd
operator|<
literal|0
condition|)
block|{
name|iso9660
operator|->
name|temp_fd
operator|=
name|__archive_mktemp
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|temp_fd
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Couldn't create temporary file"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
comment|/* Save an offset of current file in temporary file. */
name|file
operator|->
name|content
operator|.
name|offset_of_temp
operator|=
name|wb_offset
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|file
operator|->
name|cur_content
operator|=
operator|&
operator|(
name|file
operator|->
name|content
operator|)
expr_stmt|;
name|r
operator|=
name|zisofs_init
argument_list|(
name|a
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|ret
condition|)
name|ret
operator|=
name|r
expr_stmt|;
name|iso9660
operator|->
name|bytes_remaining
operator|=
name|archive_entry_size
argument_list|(
name|file
operator|->
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|write_to_temp
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|ssize_t
name|written
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|b
decl_stmt|;
name|b
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|buff
expr_stmt|;
while|while
condition|(
name|s
condition|)
block|{
name|written
operator|=
name|write
argument_list|(
name|iso9660
operator|->
name|temp_fd
argument_list|,
name|b
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|written
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Can't write to temporary file"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|s
operator|-=
name|written
expr_stmt|;
name|b
operator|+=
name|written
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wb_write_to_temp
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|xp
init|=
name|buff
decl_stmt|;
name|size_t
name|xs
init|=
name|s
decl_stmt|;
comment|/* 	 * If a written data size is big enough to use system-call 	 * and there is no waiting data, this calls write_to_temp() in 	 * order to reduce a extra memory copy. 	 */
if|if
condition|(
name|wb_remaining
argument_list|(
name|a
argument_list|)
operator|==
name|wb_buffmax
argument_list|()
operator|&&
name|s
operator|>
operator|(
literal|1024
operator|*
literal|16
operator|)
condition|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
operator|(
expr|struct
name|iso9660
operator|*
operator|)
name|a
operator|->
name|format_data
decl_stmt|;
name|xs
operator|=
name|s
operator|%
name|LOGICAL_BLOCK_SIZE
expr_stmt|;
name|iso9660
operator|->
name|wbuff_offset
operator|+=
name|s
operator|-
name|xs
expr_stmt|;
if|if
condition|(
name|write_to_temp
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|s
operator|-
name|xs
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
if|if
condition|(
name|xs
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
name|xp
operator|+=
name|s
operator|-
name|xs
expr_stmt|;
block|}
while|while
condition|(
name|xs
condition|)
block|{
name|size_t
name|size
init|=
name|xs
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|wb_remaining
argument_list|(
name|a
argument_list|)
condition|)
name|size
operator|=
name|wb_remaining
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|wb_buffptr
argument_list|(
name|a
argument_list|)
argument_list|,
name|xp
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|wb_consume
argument_list|(
name|a
argument_list|,
name|size
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|xs
operator|-=
name|size
expr_stmt|;
name|xp
operator|+=
name|size
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wb_write_padding_to_temp
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|int64_t
name|csize
parameter_list|)
block|{
name|size_t
name|ns
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ns
operator|=
call|(
name|size_t
call|)
argument_list|(
name|csize
operator|%
name|LOGICAL_BLOCK_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns
operator|!=
literal|0
condition|)
name|ret
operator|=
name|write_null
argument_list|(
name|a
argument_list|,
name|LOGICAL_BLOCK_SIZE
operator|-
name|ns
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|ARCHIVE_OK
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|write_iso9660_data
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|size_t
name|ws
decl_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|temp_fd
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Couldn't create temporary file"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|ws
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|need_multi_extent
operator|&&
operator|(
name|iso9660
operator|->
name|cur_file
operator|->
name|cur_content
operator|->
name|size
operator|+
name|ws
operator|)
operator|>=
operator|(
name|MULTI_EXTENT_SIZE
operator|-
name|LOGICAL_BLOCK_SIZE
operator|)
condition|)
block|{
name|struct
name|content
modifier|*
name|con
decl_stmt|;
name|size_t
name|ts
decl_stmt|;
name|ts
operator|=
call|(
name|size_t
call|)
argument_list|(
name|MULTI_EXTENT_SIZE
operator|-
name|LOGICAL_BLOCK_SIZE
operator|-
name|iso9660
operator|->
name|cur_file
operator|->
name|cur_content
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|zisofs
operator|.
name|detect_magic
condition|)
name|zisofs_detect_magic
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|zisofs
operator|.
name|making
condition|)
block|{
if|if
condition|(
name|zisofs_write_to_temp
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|ts
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|wb_write_to_temp
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|ts
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|iso9660
operator|->
name|cur_file
operator|->
name|cur_content
operator|->
name|size
operator|+=
name|ts
expr_stmt|;
block|}
comment|/* Write padding. */
if|if
condition|(
name|wb_write_padding_to_temp
argument_list|(
name|a
argument_list|,
name|iso9660
operator|->
name|cur_file
operator|->
name|cur_content
operator|->
name|size
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
comment|/* Compute the logical block number. */
name|iso9660
operator|->
name|cur_file
operator|->
name|cur_content
operator|->
name|blocks
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|iso9660
operator|->
name|cur_file
operator|->
name|cur_content
operator|->
name|size
operator|+
name|LOGICAL_BLOCK_SIZE
operator|-
literal|1
operator|)
operator|>>
name|LOGICAL_BLOCK_BITS
argument_list|)
expr_stmt|;
comment|/* 		 * Make next extent. 		 */
name|ws
operator|-=
name|ts
expr_stmt|;
name|buff
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|buff
operator|)
operator|+
name|ts
operator|)
expr_stmt|;
comment|/* Make a content for next extent. */
name|con
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|con
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|con
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate content data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|con
operator|->
name|offset_of_temp
operator|=
name|wb_offset
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|cur_file
operator|->
name|cur_content
operator|->
name|next
operator|=
name|con
expr_stmt|;
name|iso9660
operator|->
name|cur_file
operator|->
name|cur_content
operator|=
name|con
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
name|iso9660
operator|->
name|zisofs
operator|.
name|block_offset
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|iso9660
operator|->
name|zisofs
operator|.
name|detect_magic
condition|)
name|zisofs_detect_magic
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|ws
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|zisofs
operator|.
name|making
condition|)
block|{
if|if
condition|(
name|zisofs_write_to_temp
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|ws
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|wb_write_to_temp
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|ws
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|iso9660
operator|->
name|cur_file
operator|->
name|cur_content
operator|->
name|size
operator|+=
name|ws
expr_stmt|;
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|iso9660_write_data
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|ssize_t
name|r
decl_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|cur_file
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|archive_entry_filetype
argument_list|(
name|iso9660
operator|->
name|cur_file
operator|->
name|entry
argument_list|)
operator|!=
name|AE_IFREG
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|s
operator|>
name|iso9660
operator|->
name|bytes_remaining
condition|)
name|s
operator|=
operator|(
name|size_t
operator|)
name|iso9660
operator|->
name|bytes_remaining
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|r
operator|=
name|write_iso9660_data
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>
literal|0
condition|)
name|iso9660
operator|->
name|bytes_remaining
operator|-=
name|r
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iso9660_finish_entry
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
name|a
operator|->
name|format_data
decl_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|cur_file
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
if|if
condition|(
name|archive_entry_filetype
argument_list|(
name|iso9660
operator|->
name|cur_file
operator|->
name|entry
argument_list|)
operator|!=
name|AE_IFREG
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
if|if
condition|(
name|iso9660
operator|->
name|cur_file
operator|->
name|content
operator|.
name|size
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
comment|/* If there are unwritten data, write null data instead. */
while|while
condition|(
name|iso9660
operator|->
name|bytes_remaining
operator|>
literal|0
condition|)
block|{
name|size_t
name|s
decl_stmt|;
name|s
operator|=
operator|(
name|iso9660
operator|->
name|bytes_remaining
operator|>
name|a
operator|->
name|null_length
operator|)
condition|?
name|a
operator|->
name|null_length
else|:
operator|(
name|size_t
operator|)
name|iso9660
operator|->
name|bytes_remaining
expr_stmt|;
if|if
condition|(
name|write_iso9660_data
argument_list|(
name|a
argument_list|,
name|a
operator|->
name|nulls
argument_list|,
name|s
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|iso9660
operator|->
name|bytes_remaining
operator|-=
name|s
expr_stmt|;
block|}
if|if
condition|(
name|iso9660
operator|->
name|zisofs
operator|.
name|making
operator|&&
name|zisofs_finish_entry
argument_list|(
name|a
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
comment|/* Write padding. */
if|if
condition|(
name|wb_write_padding_to_temp
argument_list|(
name|a
argument_list|,
name|iso9660
operator|->
name|cur_file
operator|->
name|cur_content
operator|->
name|size
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
comment|/* Compute the logical block number. */
name|iso9660
operator|->
name|cur_file
operator|->
name|cur_content
operator|->
name|blocks
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|iso9660
operator|->
name|cur_file
operator|->
name|cur_content
operator|->
name|size
operator|+
name|LOGICAL_BLOCK_SIZE
operator|-
literal|1
operator|)
operator|>>
name|LOGICAL_BLOCK_BITS
argument_list|)
expr_stmt|;
comment|/* Add the current file to data file list. */
name|isofile_add_data_file
argument_list|(
name|iso9660
argument_list|,
name|iso9660
operator|->
name|cur_file
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iso9660_close
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|blocks
decl_stmt|;
name|iso9660
operator|=
name|a
operator|->
name|format_data
expr_stmt|;
comment|/* 	 * Write remaining data out to the temporary file. 	 */
if|if
condition|(
name|wb_remaining
argument_list|(
name|a
argument_list|)
operator|>
literal|0
condition|)
block|{
name|ret
operator|=
name|wb_write_out
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* 	 * Preparations... 	 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|iso9660
operator|->
name|birth_time
operator|==
literal|0
condition|)
endif|#
directive|endif
name|time
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|birth_time
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Prepare a bootable ISO image. 	 */
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|boot
condition|)
block|{
comment|/* Find out the boot file entry. */
name|ret
operator|=
name|isoent_find_out_boot_file
argument_list|(
name|a
argument_list|,
name|iso9660
operator|->
name|primary
operator|.
name|rootent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
comment|/* Reconvert the boot file from zisofs'ed form to 		 * plain form. */
name|ret
operator|=
name|zisofs_rewind_boot_file
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
comment|/* Write remaining data out to the temporary file. */
if|if
condition|(
name|wb_remaining
argument_list|(
name|a
argument_list|)
operator|>
literal|0
condition|)
block|{
name|ret
operator|=
name|wb_write_out
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* Create the boot catalog. */
name|ret
operator|=
name|isoent_create_boot_catalog
argument_list|(
name|a
argument_list|,
name|iso9660
operator|->
name|primary
operator|.
name|rootent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* 	 * Prepare joliet extensions. 	 */
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|joliet
condition|)
block|{
comment|/* Make a new tree for joliet. */
name|ret
operator|=
name|isoent_clone_tree
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|joliet
operator|.
name|rootent
operator|)
argument_list|,
name|iso9660
operator|->
name|primary
operator|.
name|rootent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
comment|/* Make sure we have UTF-16BE convertors. 		 * if there is no file entry, convertors are still 		 * uninitilized. */
if|if
condition|(
name|iso9660
operator|->
name|sconv_to_utf16be
operator|==
name|NULL
condition|)
block|{
name|iso9660
operator|->
name|sconv_to_utf16be
operator|=
name|archive_string_conversion_to_charset
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
literal|"UTF-16BE"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|sconv_to_utf16be
operator|==
name|NULL
condition|)
comment|/* Couldn't allocate memory */
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|iso9660
operator|->
name|sconv_from_utf16be
operator|=
name|archive_string_conversion_from_charset
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
literal|"UTF-16BE"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|sconv_from_utf16be
operator|==
name|NULL
condition|)
comment|/* Couldn't allocate memory */
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
comment|/* 	 * Make Path Tables. 	 */
name|ret
operator|=
name|isoent_make_path_table
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
comment|/* 	 * Calculate a total volume size and setup all locations of 	 * contents of an iso9660 image. 	 */
name|blocks
operator|=
name|SYSTEM_AREA_BLOCK
operator|+
name|PRIMARY_VOLUME_DESCRIPTOR_BLOCK
operator|+
name|VOLUME_DESCRIPTOR_SET_TERMINATOR_BLOCK
operator|+
name|NON_ISO_FILE_SYSTEM_INFORMATION_BLOCK
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|boot
condition|)
name|blocks
operator|+=
name|BOOT_RECORD_DESCRIPTOR_BLOCK
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|joliet
condition|)
name|blocks
operator|+=
name|SUPPLEMENTARY_VOLUME_DESCRIPTOR_BLOCK
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|iso_level
operator|==
literal|4
condition|)
name|blocks
operator|+=
name|SUPPLEMENTARY_VOLUME_DESCRIPTOR_BLOCK
expr_stmt|;
comment|/* Setup the locations of Path Table. */
name|iso9660
operator|->
name|primary
operator|.
name|location_type_L_path_table
operator|=
name|blocks
expr_stmt|;
name|blocks
operator|+=
name|iso9660
operator|->
name|primary
operator|.
name|path_table_block
expr_stmt|;
name|iso9660
operator|->
name|primary
operator|.
name|location_type_M_path_table
operator|=
name|blocks
expr_stmt|;
name|blocks
operator|+=
name|iso9660
operator|->
name|primary
operator|.
name|path_table_block
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|joliet
condition|)
block|{
name|iso9660
operator|->
name|joliet
operator|.
name|location_type_L_path_table
operator|=
name|blocks
expr_stmt|;
name|blocks
operator|+=
name|iso9660
operator|->
name|joliet
operator|.
name|path_table_block
expr_stmt|;
name|iso9660
operator|->
name|joliet
operator|.
name|location_type_M_path_table
operator|=
name|blocks
expr_stmt|;
name|blocks
operator|+=
name|iso9660
operator|->
name|joliet
operator|.
name|path_table_block
expr_stmt|;
block|}
comment|/* Setup the locations of directories. */
name|isoent_setup_directory_location
argument_list|(
name|iso9660
argument_list|,
name|blocks
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|primary
operator|)
argument_list|)
expr_stmt|;
name|blocks
operator|+=
name|iso9660
operator|->
name|primary
operator|.
name|total_dir_block
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|joliet
condition|)
block|{
name|isoent_setup_directory_location
argument_list|(
name|iso9660
argument_list|,
name|blocks
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|joliet
operator|)
argument_list|)
expr_stmt|;
name|blocks
operator|+=
name|iso9660
operator|->
name|joliet
operator|.
name|total_dir_block
expr_stmt|;
block|}
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|rr
condition|)
block|{
name|iso9660
operator|->
name|location_rrip_er
operator|=
name|blocks
expr_stmt|;
name|blocks
operator|+=
name|RRIP_ER_BLOCK
expr_stmt|;
block|}
comment|/* Setup the locations of all file contents. */
name|isoent_setup_file_location
argument_list|(
name|iso9660
argument_list|,
name|blocks
argument_list|)
expr_stmt|;
name|blocks
operator|+=
name|iso9660
operator|->
name|total_file_block
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|boot
operator|&&
name|iso9660
operator|->
name|opt
operator|.
name|boot_info_table
condition|)
block|{
name|ret
operator|=
name|setup_boot_information
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* Now we have a total volume size. */
name|iso9660
operator|->
name|volume_space_size
operator|=
name|blocks
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|pad
condition|)
name|iso9660
operator|->
name|volume_space_size
operator|+=
name|PADDING_BLOCK
expr_stmt|;
name|iso9660
operator|->
name|volume_sequence_number
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Write an ISO 9660 image. 	 */
comment|/* Switc to start using wbuff as file buffer. */
name|iso9660
operator|->
name|wbuff_remaining
operator|=
name|wb_buffmax
argument_list|()
expr_stmt|;
name|iso9660
operator|->
name|wbuff_type
operator|=
name|WB_TO_STREAM
expr_stmt|;
name|iso9660
operator|->
name|wbuff_offset
operator|=
literal|0
expr_stmt|;
name|iso9660
operator|->
name|wbuff_written
operator|=
literal|0
expr_stmt|;
name|iso9660
operator|->
name|wbuff_tail
operator|=
literal|0
expr_stmt|;
comment|/* Write The System Area */
name|ret
operator|=
name|write_null
argument_list|(
name|a
argument_list|,
name|SYSTEM_AREA_BLOCK
operator|*
name|LOGICAL_BLOCK_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
comment|/* Write Primary Volume Descriptor */
name|ret
operator|=
name|write_VD
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|primary
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|boot
condition|)
block|{
comment|/* Write Boot Record Volume Descriptor */
name|ret
operator|=
name|write_VD_boot_record
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|iso_level
operator|==
literal|4
condition|)
block|{
comment|/* Write Enhanced Volume Descriptor */
name|iso9660
operator|->
name|primary
operator|.
name|vdd_type
operator|=
name|VDD_ENHANCED
expr_stmt|;
name|ret
operator|=
name|write_VD
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|primary
operator|)
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|primary
operator|.
name|vdd_type
operator|=
name|VDD_PRIMARY
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|joliet
condition|)
block|{
name|ret
operator|=
name|write_VD
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|joliet
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Write Volume Descriptor Set Terminator */
name|ret
operator|=
name|write_VD_terminator
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
comment|/* Write Non-ISO File System Information */
name|ret
operator|=
name|write_information_block
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
comment|/* Write Type L Path Table */
name|ret
operator|=
name|write_path_table
argument_list|(
name|a
argument_list|,
literal|0
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|primary
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
comment|/* Write Type M Path Table */
name|ret
operator|=
name|write_path_table
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|primary
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|joliet
condition|)
block|{
comment|/* Write Type L Path Table */
name|ret
operator|=
name|write_path_table
argument_list|(
name|a
argument_list|,
literal|0
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|joliet
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
comment|/* Write Type M Path Table */
name|ret
operator|=
name|write_path_table
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|joliet
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Write Directory Descriptors */
name|ret
operator|=
name|write_directory_descriptors
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|primary
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|joliet
condition|)
block|{
name|ret
operator|=
name|write_directory_descriptors
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|joliet
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|rr
condition|)
block|{
comment|/* Write Rockridge ER(Extensions Reference) */
name|ret
operator|=
name|write_rr_ER
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Write File Descriptors */
name|ret
operator|=
name|write_file_descriptors
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
comment|/* Write Padding  */
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|pad
condition|)
block|{
name|ret
operator|=
name|write_null
argument_list|(
name|a
argument_list|,
name|PADDING_BLOCK
operator|*
name|LOGICAL_BLOCK_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|iso9660
operator|->
name|directories_too_deep
operator|!=
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"%s: Directories too deep."
argument_list|,
name|archive_entry_pathname
argument_list|(
name|iso9660
operator|->
name|directories_too_deep
operator|->
name|file
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* Write remaining data out. */
name|ret
operator|=
name|wb_write_out
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iso9660_free
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|iso9660
operator|=
name|a
operator|->
name|format_data
expr_stmt|;
comment|/* Close the temporary file. */
if|if
condition|(
name|iso9660
operator|->
name|temp_fd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|iso9660
operator|->
name|temp_fd
argument_list|)
expr_stmt|;
comment|/* Free some stuff for zisofs operations. */
name|ret
operator|=
name|zisofs_free
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|/* Remove directory entries in tree which includes file entries. */
name|isoent_free_all
argument_list|(
name|iso9660
operator|->
name|primary
operator|.
name|rootent
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iso9660
operator|->
name|primary
operator|.
name|max_depth
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|iso9660
operator|->
name|primary
operator|.
name|pathtbl
index|[
name|i
index|]
operator|.
name|sorted
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|iso9660
operator|->
name|primary
operator|.
name|pathtbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|joliet
condition|)
block|{
name|isoent_free_all
argument_list|(
name|iso9660
operator|->
name|joliet
operator|.
name|rootent
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iso9660
operator|->
name|joliet
operator|.
name|max_depth
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|iso9660
operator|->
name|joliet
operator|.
name|pathtbl
index|[
name|i
index|]
operator|.
name|sorted
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|iso9660
operator|->
name|joliet
operator|.
name|pathtbl
argument_list|)
expr_stmt|;
block|}
comment|/* Remove isofile entries. */
name|isofile_free_all_entries
argument_list|(
name|iso9660
argument_list|)
expr_stmt|;
name|isofile_free_hardlinks
argument_list|(
name|iso9660
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|cur_dirstr
operator|)
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|volume_identifier
operator|)
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|publisher_identifier
operator|)
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|data_preparer_identifier
operator|)
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|application_identifier
operator|)
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|copyright_file_identifier
operator|)
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|abstract_file_identifier
operator|)
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|bibliographic_file_identifier
operator|)
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|el_torito
operator|.
name|catalog_filename
operator|)
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|el_torito
operator|.
name|boot_filename
operator|)
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|el_torito
operator|.
name|id
operator|)
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|utf16be
operator|)
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|mbs
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|iso9660
argument_list|)
expr_stmt|;
name|a
operator|->
name|format_data
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the System Identifier  */
end_comment

begin_function
specifier|static
name|void
name|get_system_identitier
parameter_list|(
name|char
modifier|*
name|system_id
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_UTSNAME_H
argument_list|)
name|struct
name|utsname
name|u
decl_stmt|;
name|uname
argument_list|(
operator|&
name|u
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|system_id
argument_list|,
name|u
operator|.
name|sysname
argument_list|,
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|system_id
index|[
name|size
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
name|strncpy
argument_list|(
name|system_id
argument_list|,
literal|"Windows"
argument_list|,
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|system_id
index|[
name|size
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
else|#
directive|else
error|#
directive|error
error|no way to get the system identifier on your platform.
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|set_str
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|l
parameter_list|,
name|char
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|map
parameter_list|)
block|{
name|unsigned
name|char
name|c
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|s
operator|=
literal|""
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|0
operator|&&
name|l
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|>=
literal|0x80
operator|||
name|map
index|[
name|c
index|]
operator|==
literal|0
condition|)
block|{
comment|/* illegal character */
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
condition|)
block|{
comment|/* convert c from a-z to A-Z */
name|c
operator|-=
literal|0x20
expr_stmt|;
block|}
else|else
name|c
operator|=
literal|0x5f
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|l
operator|--
expr_stmt|;
block|}
comment|/* If l isn't zero, fill p buffer by the character 	 * which indicated by f. */
if|if
condition|(
name|l
operator|>
literal|0
condition|)
name|memset
argument_list|(
name|p
argument_list|,
name|f
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|joliet_allowed_char
parameter_list|(
name|unsigned
name|char
name|high
parameter_list|,
name|unsigned
name|char
name|low
parameter_list|)
block|{
name|int
name|utf16
init|=
operator|(
name|high
operator|<<
literal|8
operator|)
operator||
name|low
decl_stmt|;
if|if
condition|(
name|utf16
operator|<=
literal|0x001F
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|utf16
condition|)
block|{
case|case
literal|0x002A
case|:
comment|/* '*' */
case|case
literal|0x002F
case|:
comment|/* '/' */
case|case
literal|0x003A
case|:
comment|/* ':' */
case|case
literal|0x003B
case|:
comment|/* ';' */
case|case
literal|0x003F
case|:
comment|/* '?' */
case|case
literal|0x005C
case|:
comment|/* '\' */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Not allowed. */
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_str_utf16be
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|l
parameter_list|,
name|uint16_t
name|uf
parameter_list|,
name|enum
name|vdc
name|vdc
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|,
name|i
decl_stmt|;
name|int
name|onepad
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|s
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|l
operator|&
literal|0x01
condition|)
block|{
name|onepad
operator|=
literal|1
expr_stmt|;
name|l
operator|&=
operator|~
literal|1
expr_stmt|;
block|}
else|else
name|onepad
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vdc
operator|==
name|VDC_UCS2
condition|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
name|a
operator|->
name|format_data
decl_stmt|;
if|if
condition|(
name|archive_strncpy_l
argument_list|(
operator|&
name|iso9660
operator|->
name|utf16be
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|,
name|iso9660
operator|->
name|sconv_to_utf16be
argument_list|)
operator|!=
literal|0
operator|&&
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for UTF-16BE"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|size
operator|=
name|iso9660
operator|->
name|utf16be
operator|.
name|length
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|l
condition|)
name|size
operator|=
name|l
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|iso9660
operator|->
name|utf16be
operator|.
name|s
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|uint16_t
modifier|*
name|u16
init|=
operator|(
specifier|const
name|uint16_t
operator|*
operator|)
name|s
decl_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|u16
operator|++
condition|)
name|size
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|l
condition|)
name|size
operator|=
name|l
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|+=
literal|2
operator|,
name|p
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|!
name|joliet_allowed_char
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|)
condition|)
name|archive_be16enc
argument_list|(
name|p
argument_list|,
literal|0x005F
argument_list|)
expr_stmt|;
comment|/* '_' */
block|}
name|l
operator|-=
name|size
expr_stmt|;
while|while
condition|(
name|l
operator|>
literal|0
condition|)
block|{
name|archive_be16enc
argument_list|(
name|p
argument_list|,
name|uf
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
name|l
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|onepad
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
name|a_characters_map
index|[
literal|0x80
index|]
init|=
block|{
comment|/*  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F          */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 00-0F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 10-1F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 20-2F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 30-3F */
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 40-4F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
comment|/* 50-5F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 60-6F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 70-7F */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|a1_characters_map
index|[
literal|0x80
index|]
init|=
block|{
comment|/*  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F          */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 00-0F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 10-1F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 20-2F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 30-3F */
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 40-4F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
comment|/* 50-5F */
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 60-6F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 70-7F */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|d_characters_map
index|[
literal|0x80
index|]
init|=
block|{
comment|/*  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F          */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 00-0F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 10-1F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 20-2F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 30-3F */
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 40-4F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
comment|/* 50-5F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 60-6F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 70-7F */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|d1_characters_map
index|[
literal|0x80
index|]
init|=
block|{
comment|/*  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F          */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 00-0F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 10-1F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 20-2F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 30-3F */
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 40-4F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
comment|/* 50-5F */
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 60-6F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 70-7F */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|set_str_a_characters_bp
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|unsigned
name|char
modifier|*
name|bp
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|enum
name|vdc
name|vdc
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
switch|switch
condition|(
name|vdc
condition|)
block|{
case|case
name|VDC_STD
case|:
name|set_str
argument_list|(
name|bp
operator|+
name|from
argument_list|,
name|s
argument_list|,
name|to
operator|-
name|from
operator|+
literal|1
argument_list|,
literal|0x20
argument_list|,
name|a_characters_map
argument_list|)
expr_stmt|;
name|r
operator|=
name|ARCHIVE_OK
expr_stmt|;
break|break;
case|case
name|VDC_LOWERCASE
case|:
name|set_str
argument_list|(
name|bp
operator|+
name|from
argument_list|,
name|s
argument_list|,
name|to
operator|-
name|from
operator|+
literal|1
argument_list|,
literal|0x20
argument_list|,
name|a1_characters_map
argument_list|)
expr_stmt|;
name|r
operator|=
name|ARCHIVE_OK
expr_stmt|;
break|break;
case|case
name|VDC_UCS2
case|:
case|case
name|VDC_UCS2_DIRECT
case|:
name|r
operator|=
name|set_str_utf16be
argument_list|(
name|a
argument_list|,
name|bp
operator|+
name|from
argument_list|,
name|s
argument_list|,
name|to
operator|-
name|from
operator|+
literal|1
argument_list|,
literal|0x0020
argument_list|,
name|vdc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|r
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_str_d_characters_bp
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|unsigned
name|char
modifier|*
name|bp
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|enum
name|vdc
name|vdc
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
switch|switch
condition|(
name|vdc
condition|)
block|{
case|case
name|VDC_STD
case|:
name|set_str
argument_list|(
name|bp
operator|+
name|from
argument_list|,
name|s
argument_list|,
name|to
operator|-
name|from
operator|+
literal|1
argument_list|,
literal|0x20
argument_list|,
name|d_characters_map
argument_list|)
expr_stmt|;
name|r
operator|=
name|ARCHIVE_OK
expr_stmt|;
break|break;
case|case
name|VDC_LOWERCASE
case|:
name|set_str
argument_list|(
name|bp
operator|+
name|from
argument_list|,
name|s
argument_list|,
name|to
operator|-
name|from
operator|+
literal|1
argument_list|,
literal|0x20
argument_list|,
name|d1_characters_map
argument_list|)
expr_stmt|;
name|r
operator|=
name|ARCHIVE_OK
expr_stmt|;
break|break;
case|case
name|VDC_UCS2
case|:
case|case
name|VDC_UCS2_DIRECT
case|:
name|r
operator|=
name|set_str_utf16be
argument_list|(
name|a
argument_list|,
name|bp
operator|+
name|from
argument_list|,
name|s
argument_list|,
name|to
operator|-
name|from
operator|+
literal|1
argument_list|,
literal|0x0020
argument_list|,
name|vdc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|r
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_VD_bp
parameter_list|(
name|unsigned
name|char
modifier|*
name|bp
parameter_list|,
name|enum
name|VD_type
name|type
parameter_list|,
name|unsigned
name|char
name|ver
parameter_list|)
block|{
comment|/* Volume Descriptor Type */
name|bp
index|[
literal|1
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|type
expr_stmt|;
comment|/* Standard Identifier */
name|memcpy
argument_list|(
name|bp
operator|+
literal|2
argument_list|,
literal|"CD001"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/* Volume Descriptor Version */
name|bp
index|[
literal|7
index|]
operator|=
name|ver
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|set_unused_field_bp
parameter_list|(
name|unsigned
name|char
modifier|*
name|bp
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
name|memset
argument_list|(
name|bp
operator|+
name|from
argument_list|,
literal|0
argument_list|,
name|to
operator|-
name|from
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * 8-bit unsigned numerical values.  * ISO9660 Standard 7.1.1  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_num_711
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|unsigned
name|char
name|value
parameter_list|)
block|{
operator|*
name|p
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * 8-bit signed numerical values.  * ISO9660 Standard 7.1.2  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_num_712
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|char
name|value
parameter_list|)
block|{
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|p
operator|)
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Least significant byte first.  * ISO9660 Standard 7.2.1  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_num_721
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|uint16_t
name|value
parameter_list|)
block|{
name|archive_le16enc
argument_list|(
name|p
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Most significant byte first.  * ISO9660 Standard 7.2.2  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_num_722
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|uint16_t
name|value
parameter_list|)
block|{
name|archive_be16enc
argument_list|(
name|p
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Both-byte orders.  * ISO9660 Standard 7.2.3  */
end_comment

begin_function
specifier|static
name|void
name|set_num_723
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|uint16_t
name|value
parameter_list|)
block|{
name|archive_le16enc
argument_list|(
name|p
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|archive_be16enc
argument_list|(
name|p
operator|+
literal|2
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Least significant byte first.  * ISO9660 Standard 7.3.1  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_num_731
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|archive_le32enc
argument_list|(
name|p
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Most significant byte first.  * ISO9660 Standard 7.3.2  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_num_732
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|archive_be32enc
argument_list|(
name|p
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Both-byte orders.  * ISO9660 Standard 7.3.3  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_num_733
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|archive_le32enc
argument_list|(
name|p
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|archive_be32enc
argument_list|(
name|p
operator|+
literal|4
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_digit
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|s
parameter_list|,
name|int
name|value
parameter_list|)
block|{
while|while
condition|(
name|s
operator|--
condition|)
block|{
name|p
index|[
name|s
index|]
operator|=
literal|'0'
operator|+
operator|(
name|value
operator|%
literal|10
operator|)
expr_stmt|;
name|value
operator|/=
literal|10
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STRUCT_TM_TM_GMTOFF
argument_list|)
end_if

begin_define
define|#
directive|define
name|get_gmoffset
parameter_list|(
name|tm
parameter_list|)
value|((tm)->tm_gmtoff)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_STRUCT_TM___TM_GMTOFF
argument_list|)
end_elif

begin_define
define|#
directive|define
name|get_gmoffset
parameter_list|(
name|tm
parameter_list|)
value|((tm)->__tm_gmtoff)
end_define

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|long
name|get_gmoffset
parameter_list|(
name|struct
name|tm
modifier|*
name|tm
parameter_list|)
block|{
name|long
name|offset
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE__GET_TIMEZONE
argument_list|)
name|_get_timezone
argument_list|(
operator|&
name|offset
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|||
name|defined
argument_list|(
name|__MINGW32__
argument_list|)
operator|||
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
name|offset
operator|=
name|_timezone
expr_stmt|;
else|#
directive|else
name|offset
operator|=
name|timezone
expr_stmt|;
endif|#
directive|endif
name|offset
operator|*=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|tm
operator|->
name|tm_isdst
condition|)
name|offset
operator|+=
literal|3600
expr_stmt|;
return|return
operator|(
name|offset
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|get_tmfromtime
parameter_list|(
name|struct
name|tm
modifier|*
name|tm
parameter_list|,
name|time_t
modifier|*
name|t
parameter_list|)
block|{
if|#
directive|if
name|HAVE_LOCALTIME_R
name|tzset
argument_list|()
expr_stmt|;
name|localtime_r
argument_list|(
name|t
argument_list|,
name|tm
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|HAVE__LOCALTIME64_S
name|_localtime64_s
argument_list|(
name|tm
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|#
directive|else
name|memcpy
argument_list|(
name|tm
argument_list|,
name|localtime
argument_list|(
name|t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tm
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Date and Time Format.  * ISO9660 Standard 8.4.26.1  */
end_comment

begin_function
specifier|static
name|void
name|set_date_time
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|time_t
name|t
parameter_list|)
block|{
name|struct
name|tm
name|tm
decl_stmt|;
name|get_tmfromtime
argument_list|(
operator|&
name|tm
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|set_digit
argument_list|(
name|p
argument_list|,
literal|4
argument_list|,
name|tm
operator|.
name|tm_year
operator|+
literal|1900
argument_list|)
expr_stmt|;
name|set_digit
argument_list|(
name|p
operator|+
literal|4
argument_list|,
literal|2
argument_list|,
name|tm
operator|.
name|tm_mon
operator|+
literal|1
argument_list|)
expr_stmt|;
name|set_digit
argument_list|(
name|p
operator|+
literal|6
argument_list|,
literal|2
argument_list|,
name|tm
operator|.
name|tm_mday
argument_list|)
expr_stmt|;
name|set_digit
argument_list|(
name|p
operator|+
literal|8
argument_list|,
literal|2
argument_list|,
name|tm
operator|.
name|tm_hour
argument_list|)
expr_stmt|;
name|set_digit
argument_list|(
name|p
operator|+
literal|10
argument_list|,
literal|2
argument_list|,
name|tm
operator|.
name|tm_min
argument_list|)
expr_stmt|;
name|set_digit
argument_list|(
name|p
operator|+
literal|12
argument_list|,
literal|2
argument_list|,
name|tm
operator|.
name|tm_sec
argument_list|)
expr_stmt|;
name|set_digit
argument_list|(
name|p
operator|+
literal|14
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_num_712
argument_list|(
name|p
operator|+
literal|16
argument_list|,
call|(
name|char
call|)
argument_list|(
name|get_gmoffset
argument_list|(
operator|&
name|tm
argument_list|)
operator|/
operator|(
literal|60
operator|*
literal|15
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_date_time_null
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|)
block|{
name|memset
argument_list|(
name|p
argument_list|,
literal|'0'
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|p
index|[
literal|16
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_time_915
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|time_t
name|t
parameter_list|)
block|{
name|struct
name|tm
name|tm
decl_stmt|;
name|get_tmfromtime
argument_list|(
operator|&
name|tm
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|set_num_711
argument_list|(
name|p
operator|+
literal|0
argument_list|,
name|tm
operator|.
name|tm_year
argument_list|)
expr_stmt|;
name|set_num_711
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|tm
operator|.
name|tm_mon
operator|+
literal|1
argument_list|)
expr_stmt|;
name|set_num_711
argument_list|(
name|p
operator|+
literal|2
argument_list|,
name|tm
operator|.
name|tm_mday
argument_list|)
expr_stmt|;
name|set_num_711
argument_list|(
name|p
operator|+
literal|3
argument_list|,
name|tm
operator|.
name|tm_hour
argument_list|)
expr_stmt|;
name|set_num_711
argument_list|(
name|p
operator|+
literal|4
argument_list|,
name|tm
operator|.
name|tm_min
argument_list|)
expr_stmt|;
name|set_num_711
argument_list|(
name|p
operator|+
literal|5
argument_list|,
name|tm
operator|.
name|tm_sec
argument_list|)
expr_stmt|;
name|set_num_712
argument_list|(
name|p
operator|+
literal|6
argument_list|,
call|(
name|char
call|)
argument_list|(
name|get_gmoffset
argument_list|(
operator|&
name|tm
argument_list|)
operator|/
operator|(
literal|60
operator|*
literal|15
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write SUSP "CE" System Use Entry.  */
end_comment

begin_function
specifier|static
name|int
name|set_SUSP_CE
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|int
name|location
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|bp
init|=
name|p
operator|-
literal|1
decl_stmt|;
comment|/*  Extend the System Use Area 	 *   "CE" Format: 	 *               len  ver 	 *    +----+----+----+----+-----------+-----------+ 	 *    | 'C'| 'E'| 1C | 01 | LOCATION1 | LOCATION2 | 	 *    +----+----+----+----+-----------+-----------+ 	 *    0    1    2    3    4          12          20 	 *    +-----------+ 	 *    | LOCATION3 | 	 *    +-----------+ 	 *   20          28 	 *   LOCATION1 : Location of Continuation of System Use Area. 	 *   LOCATION2 : Offset to Start of Continuation. 	 *   LOCATION3 : Length of the Continuation. 	 */
name|bp
index|[
literal|1
index|]
operator|=
literal|'C'
expr_stmt|;
name|bp
index|[
literal|2
index|]
operator|=
literal|'E'
expr_stmt|;
name|bp
index|[
literal|3
index|]
operator|=
name|RR_CE_SIZE
expr_stmt|;
comment|/* length	*/
name|bp
index|[
literal|4
index|]
operator|=
literal|1
expr_stmt|;
comment|/* version	*/
name|set_num_733
argument_list|(
name|bp
operator|+
literal|5
argument_list|,
name|location
argument_list|)
expr_stmt|;
name|set_num_733
argument_list|(
name|bp
operator|+
literal|13
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|set_num_733
argument_list|(
name|bp
operator|+
literal|21
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|RR_CE_SIZE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The functions, which names are beginning with extra_, are used to  * control extra records.  * The maximum size of a Directory Record is 254. When a filename is  * very long, all of RRIP data of a file won't stored to the Directory  * Record and so remaining RRIP data store to an extra record instead.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|extra_open_record
parameter_list|(
name|unsigned
name|char
modifier|*
name|bp
parameter_list|,
name|int
name|dr_len
parameter_list|,
name|struct
name|isoent
modifier|*
name|isoent
parameter_list|,
name|struct
name|ctl_extr_rec
modifier|*
name|ctl
parameter_list|)
block|{
name|ctl
operator|->
name|bp
operator|=
name|bp
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|bp
operator|+=
name|dr_len
expr_stmt|;
name|ctl
operator|->
name|use_extr
operator|=
literal|0
expr_stmt|;
name|ctl
operator|->
name|isoent
operator|=
name|isoent
expr_stmt|;
name|ctl
operator|->
name|ce_ptr
operator|=
name|NULL
expr_stmt|;
name|ctl
operator|->
name|cur_len
operator|=
name|ctl
operator|->
name|dr_len
operator|=
name|dr_len
expr_stmt|;
name|ctl
operator|->
name|limit
operator|=
name|DR_LIMIT
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|extra_close_record
parameter_list|(
name|struct
name|ctl_extr_rec
modifier|*
name|ctl
parameter_list|,
name|int
name|ce_size
parameter_list|)
block|{
name|int
name|padding
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ce_size
operator|>
literal|0
condition|)
name|extra_tell_used_size
argument_list|(
name|ctl
argument_list|,
name|ce_size
argument_list|)
expr_stmt|;
comment|/* Padding. */
if|if
condition|(
name|ctl
operator|->
name|cur_len
operator|&
literal|0x01
condition|)
block|{
name|ctl
operator|->
name|cur_len
operator|++
expr_stmt|;
if|if
condition|(
name|ctl
operator|->
name|bp
operator|!=
name|NULL
condition|)
name|ctl
operator|->
name|bp
index|[
name|ctl
operator|->
name|cur_len
index|]
operator|=
literal|0
expr_stmt|;
name|padding
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ctl
operator|->
name|use_extr
condition|)
block|{
if|if
condition|(
name|ctl
operator|->
name|ce_ptr
operator|!=
name|NULL
condition|)
name|set_SUSP_CE
argument_list|(
name|ctl
operator|->
name|ce_ptr
argument_list|,
name|ctl
operator|->
name|extr_loc
argument_list|,
name|ctl
operator|->
name|extr_off
argument_list|,
name|ctl
operator|->
name|cur_len
operator|-
name|padding
argument_list|)
expr_stmt|;
block|}
else|else
name|ctl
operator|->
name|dr_len
operator|=
name|ctl
operator|->
name|cur_len
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|extra_space
parameter_list|(
name|ctl
parameter_list|)
value|((ctl)->limit - (ctl)->cur_len)
end_define

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|extra_next_record
parameter_list|(
name|struct
name|ctl_extr_rec
modifier|*
name|ctl
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|cur_len
init|=
name|ctl
operator|->
name|cur_len
decl_stmt|;
comment|/* save cur_len */
comment|/* Close the current extra record or Directory Record. */
name|extra_close_record
argument_list|(
name|ctl
argument_list|,
name|RR_CE_SIZE
argument_list|)
expr_stmt|;
comment|/* Get a next extra record. */
name|ctl
operator|->
name|use_extr
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ctl
operator|->
name|bp
operator|!=
name|NULL
condition|)
block|{
comment|/* Storing data into an extra record. */
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Save the pointer where a CE extension will be 		 * stored to. */
name|ctl
operator|->
name|ce_ptr
operator|=
operator|&
name|ctl
operator|->
name|bp
index|[
name|cur_len
operator|+
literal|1
index|]
expr_stmt|;
name|p
operator|=
name|extra_get_record
argument_list|(
name|ctl
operator|->
name|isoent
argument_list|,
operator|&
name|ctl
operator|->
name|limit
argument_list|,
operator|&
name|ctl
operator|->
name|extr_off
argument_list|,
operator|&
name|ctl
operator|->
name|extr_loc
argument_list|)
expr_stmt|;
name|ctl
operator|->
name|bp
operator|=
name|p
operator|-
literal|1
expr_stmt|;
comment|/* the base of bp offset is 1. */
block|}
else|else
comment|/* Calculating the size of an extra record. */
operator|(
name|void
operator|)
name|extra_get_record
argument_list|(
name|ctl
operator|->
name|isoent
argument_list|,
operator|&
name|ctl
operator|->
name|limit
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ctl
operator|->
name|cur_len
operator|=
literal|0
expr_stmt|;
comment|/* Check if an extra record is almost full. 	 * If so, get a next one. */
if|if
condition|(
name|extra_space
argument_list|(
name|ctl
argument_list|)
operator|<
name|length
condition|)
operator|(
name|void
operator|)
name|extra_next_record
argument_list|(
name|ctl
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
name|ctl
operator|->
name|bp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|extr_rec
modifier|*
name|extra_last_record
parameter_list|(
name|struct
name|isoent
modifier|*
name|isoent
parameter_list|)
block|{
if|if
condition|(
name|isoent
operator|->
name|extr_rec_list
operator|.
name|first
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
operator|(
expr|struct
name|extr_rec
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|isoent
operator|->
name|extr_rec_list
operator|.
name|last
operator|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|extr_rec
argument_list|,
name|next
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|extra_get_record
parameter_list|(
name|struct
name|isoent
modifier|*
name|isoent
parameter_list|,
name|int
modifier|*
name|space
parameter_list|,
name|int
modifier|*
name|off
parameter_list|,
name|int
modifier|*
name|loc
parameter_list|)
block|{
name|struct
name|extr_rec
modifier|*
name|rec
decl_stmt|;
name|isoent
operator|=
name|isoent
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|off
operator|!=
name|NULL
condition|)
block|{
comment|/* Storing data into an extra record. */
name|rec
operator|=
name|isoent
operator|->
name|extr_rec_list
operator|.
name|current
expr_stmt|;
if|if
condition|(
name|DR_SAFETY
operator|>
name|LOGICAL_BLOCK_SIZE
operator|-
name|rec
operator|->
name|offset
condition|)
name|rec
operator|=
name|rec
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
comment|/* Calculating the size of an extra record. */
name|rec
operator|=
name|extra_last_record
argument_list|(
name|isoent
argument_list|)
expr_stmt|;
if|if
condition|(
name|rec
operator|==
name|NULL
operator|||
name|DR_SAFETY
operator|>
name|LOGICAL_BLOCK_SIZE
operator|-
name|rec
operator|->
name|offset
condition|)
block|{
name|rec
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rec
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|rec
operator|->
name|location
operator|=
literal|0
expr_stmt|;
name|rec
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* Insert `rec` into the tail of isoent->extr_rec_list */
name|rec
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|isoent
operator|->
name|extr_rec_list
operator|.
name|last
operator|=
name|rec
expr_stmt|;
name|isoent
operator|->
name|extr_rec_list
operator|.
name|last
operator|=
operator|&
operator|(
name|rec
operator|->
name|next
operator|)
expr_stmt|;
block|}
block|}
operator|*
name|space
operator|=
name|LOGICAL_BLOCK_SIZE
operator|-
name|rec
operator|->
name|offset
operator|-
name|DR_SAFETY
expr_stmt|;
if|if
condition|(
operator|*
name|space
operator|&
literal|0x01
condition|)
operator|*
name|space
operator|-=
literal|1
expr_stmt|;
comment|/* Keep padding space. */
if|if
condition|(
name|off
operator|!=
name|NULL
condition|)
operator|*
name|off
operator|=
name|rec
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|loc
operator|!=
name|NULL
condition|)
operator|*
name|loc
operator|=
name|rec
operator|->
name|location
expr_stmt|;
name|isoent
operator|->
name|extr_rec_list
operator|.
name|current
operator|=
name|rec
expr_stmt|;
return|return
operator|(
operator|&
name|rec
operator|->
name|buf
index|[
name|rec
operator|->
name|offset
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|extra_tell_used_size
parameter_list|(
name|struct
name|ctl_extr_rec
modifier|*
name|ctl
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|isoent
modifier|*
name|isoent
decl_stmt|;
name|struct
name|extr_rec
modifier|*
name|rec
decl_stmt|;
if|if
condition|(
name|ctl
operator|->
name|use_extr
condition|)
block|{
name|isoent
operator|=
name|ctl
operator|->
name|isoent
operator|->
name|parent
expr_stmt|;
name|rec
operator|=
name|isoent
operator|->
name|extr_rec_list
operator|.
name|current
expr_stmt|;
if|if
condition|(
name|rec
operator|!=
name|NULL
condition|)
name|rec
operator|->
name|offset
operator|+=
name|size
expr_stmt|;
block|}
name|ctl
operator|->
name|cur_len
operator|+=
name|size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|extra_setup_location
parameter_list|(
name|struct
name|isoent
modifier|*
name|isoent
parameter_list|,
name|int
name|location
parameter_list|)
block|{
name|struct
name|extr_rec
modifier|*
name|rec
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
name|rec
operator|=
name|isoent
operator|->
name|extr_rec_list
operator|.
name|first
expr_stmt|;
name|isoent
operator|->
name|extr_rec_list
operator|.
name|current
operator|=
name|rec
expr_stmt|;
while|while
condition|(
name|rec
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
name|rec
operator|->
name|location
operator|=
name|location
operator|++
expr_stmt|;
name|rec
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|rec
operator|=
name|rec
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
name|cnt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create the RRIP entries.  */
end_comment

begin_function
specifier|static
name|int
name|set_directory_record_rr
parameter_list|(
name|unsigned
name|char
modifier|*
name|bp
parameter_list|,
name|int
name|dr_len
parameter_list|,
name|struct
name|isoent
modifier|*
name|isoent
parameter_list|,
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
name|enum
name|dir_rec_type
name|t
parameter_list|)
block|{
comment|/* Flags(BP 5) of the Rockridge "RR" System Use Field */
name|unsigned
name|char
name|rr_flag
decl_stmt|;
define|#
directive|define
name|RR_USE_PX
value|0x01
define|#
directive|define
name|RR_USE_PN
value|0x02
define|#
directive|define
name|RR_USE_SL
value|0x04
define|#
directive|define
name|RR_USE_NM
value|0x08
define|#
directive|define
name|RR_USE_CL
value|0x10
define|#
directive|define
name|RR_USE_PL
value|0x20
define|#
directive|define
name|RR_USE_RE
value|0x40
define|#
directive|define
name|RR_USE_TF
value|0x80
name|int
name|length
decl_stmt|;
name|struct
name|ctl_extr_rec
name|ctl
decl_stmt|;
name|struct
name|isoent
modifier|*
name|rr_parent
decl_stmt|,
modifier|*
name|pxent
decl_stmt|;
name|struct
name|isofile
modifier|*
name|file
decl_stmt|;
name|bp
operator|=
name|extra_open_record
argument_list|(
name|bp
argument_list|,
name|dr_len
argument_list|,
name|isoent
argument_list|,
operator|&
name|ctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|DIR_REC_PARENT
condition|)
block|{
name|rr_parent
operator|=
name|isoent
operator|->
name|rr_parent
expr_stmt|;
name|pxent
operator|=
name|isoent
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|rr_parent
operator|!=
name|NULL
condition|)
name|isoent
operator|=
name|rr_parent
expr_stmt|;
else|else
name|isoent
operator|=
name|isoent
operator|->
name|parent
expr_stmt|;
block|}
else|else
block|{
name|rr_parent
operator|=
name|NULL
expr_stmt|;
name|pxent
operator|=
name|isoent
expr_stmt|;
block|}
name|file
operator|=
name|isoent
operator|->
name|file
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|DIR_REC_NORMAL
condition|)
block|{
name|rr_flag
operator|=
name|RR_USE_PX
operator||
name|RR_USE_TF
expr_stmt|;
if|if
condition|(
name|rr_parent
operator|!=
name|NULL
condition|)
name|rr_flag
operator||=
name|RR_USE_PL
expr_stmt|;
block|}
else|else
block|{
name|rr_flag
operator|=
name|RR_USE_PX
operator||
name|RR_USE_NM
operator||
name|RR_USE_TF
expr_stmt|;
if|if
condition|(
name|archive_entry_filetype
argument_list|(
name|file
operator|->
name|entry
argument_list|)
operator|==
name|AE_IFLNK
condition|)
name|rr_flag
operator||=
name|RR_USE_SL
expr_stmt|;
if|if
condition|(
name|isoent
operator|->
name|rr_parent
operator|!=
name|NULL
condition|)
name|rr_flag
operator||=
name|RR_USE_RE
expr_stmt|;
if|if
condition|(
name|isoent
operator|->
name|rr_child
operator|!=
name|NULL
condition|)
name|rr_flag
operator||=
name|RR_USE_CL
expr_stmt|;
if|if
condition|(
name|archive_entry_filetype
argument_list|(
name|file
operator|->
name|entry
argument_list|)
operator|==
name|AE_IFCHR
operator|||
name|archive_entry_filetype
argument_list|(
name|file
operator|->
name|entry
argument_list|)
operator|==
name|AE_IFBLK
condition|)
name|rr_flag
operator||=
name|RR_USE_PN
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_MKISOFS
comment|/* 		 * mkisofs 2.01.01a63 records "RE" extension to 		 * the entry of "rr_moved" directory. 		 * I don't understand this behavior. 		 */
if|if
condition|(
name|isoent
operator|->
name|virtual
operator|&&
name|isoent
operator|->
name|parent
operator|==
name|iso9660
operator|->
name|primary
operator|.
name|rootent
operator|&&
name|strcmp
argument_list|(
name|isoent
operator|->
name|file
operator|->
name|basename
operator|.
name|s
argument_list|,
literal|"rr_moved"
argument_list|)
operator|==
literal|0
condition|)
name|rr_flag
operator||=
name|RR_USE_RE
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Write "SP" System Use Entry. */
if|if
condition|(
name|t
operator|==
name|DIR_REC_SELF
operator|&&
name|isoent
operator|==
name|isoent
operator|->
name|parent
condition|)
block|{
name|length
operator|=
literal|7
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|bp
index|[
literal|1
index|]
operator|=
literal|'S'
expr_stmt|;
name|bp
index|[
literal|2
index|]
operator|=
literal|'P'
expr_stmt|;
name|bp
index|[
literal|3
index|]
operator|=
name|length
expr_stmt|;
name|bp
index|[
literal|4
index|]
operator|=
literal|1
expr_stmt|;
comment|/* version	*/
name|bp
index|[
literal|5
index|]
operator|=
literal|0xBE
expr_stmt|;
comment|/* Check Byte	*/
name|bp
index|[
literal|6
index|]
operator|=
literal|0xEF
expr_stmt|;
comment|/* Check Byte	*/
name|bp
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
name|bp
operator|+=
name|length
expr_stmt|;
block|}
name|extra_tell_used_size
argument_list|(
operator|&
name|ctl
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
comment|/* Write "RR" System Use Entry. */
name|length
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|extra_space
argument_list|(
operator|&
name|ctl
argument_list|)
operator|<
name|length
condition|)
name|bp
operator|=
name|extra_next_record
argument_list|(
operator|&
name|ctl
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|bp
index|[
literal|1
index|]
operator|=
literal|'R'
expr_stmt|;
name|bp
index|[
literal|2
index|]
operator|=
literal|'R'
expr_stmt|;
name|bp
index|[
literal|3
index|]
operator|=
name|length
expr_stmt|;
name|bp
index|[
literal|4
index|]
operator|=
literal|1
expr_stmt|;
comment|/* version */
name|bp
index|[
literal|5
index|]
operator|=
name|rr_flag
expr_stmt|;
name|bp
operator|+=
name|length
expr_stmt|;
block|}
name|extra_tell_used_size
argument_list|(
operator|&
name|ctl
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/* Write "NM" System Use Entry. */
if|if
condition|(
name|rr_flag
operator|&
name|RR_USE_NM
condition|)
block|{
comment|/* 		 *   "NM" Format: 		 *     e.g. a basename is 'foo' 		 *               len  ver  flg 		 *    +----+----+----+----+----+----+----+----+ 		 *    | 'N'| 'M'| 08 | 01 | 00 | 'f'| 'o'| 'o'| 		 *    +----+----+----+----+----+----+----+----+ 		 *<----------------- len -----------------> 		 */
name|size_t
name|nmlen
init|=
name|file
operator|->
name|basename
operator|.
name|length
decl_stmt|;
specifier|const
name|char
modifier|*
name|nm
init|=
name|file
operator|->
name|basename
operator|.
name|s
decl_stmt|;
name|size_t
name|nmmax
decl_stmt|;
if|if
condition|(
name|extra_space
argument_list|(
operator|&
name|ctl
argument_list|)
operator|<
literal|6
condition|)
name|bp
operator|=
name|extra_next_record
argument_list|(
operator|&
name|ctl
argument_list|,
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|bp
index|[
literal|1
index|]
operator|=
literal|'N'
expr_stmt|;
name|bp
index|[
literal|2
index|]
operator|=
literal|'M'
expr_stmt|;
name|bp
index|[
literal|4
index|]
operator|=
literal|1
expr_stmt|;
comment|/* version	*/
block|}
name|nmmax
operator|=
name|extra_space
argument_list|(
operator|&
name|ctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmmax
operator|>
literal|0xff
condition|)
name|nmmax
operator|=
literal|0xff
expr_stmt|;
while|while
condition|(
name|nmlen
operator|+
literal|5
operator|>
name|nmmax
condition|)
block|{
name|length
operator|=
operator|(
name|int
operator|)
name|nmmax
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|bp
index|[
literal|3
index|]
operator|=
name|length
expr_stmt|;
name|bp
index|[
literal|5
index|]
operator|=
literal|0x01
expr_stmt|;
comment|/* Alternate Name continues 					       * in next "NM" field */
name|memcpy
argument_list|(
name|bp
operator|+
literal|6
argument_list|,
name|nm
argument_list|,
name|length
operator|-
literal|5
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|length
expr_stmt|;
block|}
name|nmlen
operator|-=
name|length
operator|-
literal|5
expr_stmt|;
name|nm
operator|+=
name|length
operator|-
literal|5
expr_stmt|;
name|extra_tell_used_size
argument_list|(
operator|&
name|ctl
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_space
argument_list|(
operator|&
name|ctl
argument_list|)
operator|<
literal|6
condition|)
block|{
name|bp
operator|=
name|extra_next_record
argument_list|(
operator|&
name|ctl
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|nmmax
operator|=
name|extra_space
argument_list|(
operator|&
name|ctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmmax
operator|>
literal|0xff
condition|)
name|nmmax
operator|=
literal|0xff
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|bp
index|[
literal|1
index|]
operator|=
literal|'N'
expr_stmt|;
name|bp
index|[
literal|2
index|]
operator|=
literal|'M'
expr_stmt|;
name|bp
index|[
literal|4
index|]
operator|=
literal|1
expr_stmt|;
comment|/* version */
block|}
block|}
name|length
operator|=
literal|5
operator|+
operator|(
name|int
operator|)
name|nmlen
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|bp
index|[
literal|3
index|]
operator|=
name|length
expr_stmt|;
name|bp
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
name|bp
operator|+
literal|6
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|length
expr_stmt|;
block|}
name|extra_tell_used_size
argument_list|(
operator|&
name|ctl
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
comment|/* Write "PX" System Use Entry. */
if|if
condition|(
name|rr_flag
operator|&
name|RR_USE_PX
condition|)
block|{
comment|/* 		 *   "PX" Format: 		 *               len  ver 		 *    +----+----+----+----+-----------+-----------+ 		 *    | 'P'| 'X'| 2C | 01 | FILE MODE |   LINKS   | 		 *    +----+----+----+----+-----------+-----------+ 		 *    0    1    2    3    4          12          20 		 *    +-----------+-----------+------------------+ 		 *    |  USER ID  | GROUP ID  |FILE SERIAL NUMBER| 		 *    +-----------+-----------+------------------+ 		 *   20          28          36                 44 		 */
name|length
operator|=
literal|44
expr_stmt|;
if|if
condition|(
name|extra_space
argument_list|(
operator|&
name|ctl
argument_list|)
operator|<
name|length
condition|)
name|bp
operator|=
name|extra_next_record
argument_list|(
operator|&
name|ctl
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|mode_t
name|mode
decl_stmt|;
name|int64_t
name|uid
decl_stmt|;
name|int64_t
name|gid
decl_stmt|;
name|mode
operator|=
name|archive_entry_mode
argument_list|(
name|file
operator|->
name|entry
argument_list|)
expr_stmt|;
name|uid
operator|=
name|archive_entry_uid
argument_list|(
name|file
operator|->
name|entry
argument_list|)
expr_stmt|;
name|gid
operator|=
name|archive_entry_gid
argument_list|(
name|file
operator|->
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|rr
operator|==
name|OPT_RR_USEFUL
condition|)
block|{
comment|/* 				 * This action is simular mkisofs -r option 				 * but our rockridge=useful option does not 				 * set a zero to uid and gid. 				 */
comment|/* set all read bit ON */
name|mode
operator||=
literal|0444
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
if|if
condition|(
name|mode
operator|&
literal|0111
condition|)
endif|#
directive|endif
comment|/* set all exec bit ON */
name|mode
operator||=
literal|0111
expr_stmt|;
comment|/* clear all write bits. */
name|mode
operator|&=
operator|~
literal|0222
expr_stmt|;
comment|/* clear setuid,setgid,sticky bits. */
name|mode
operator|&=
operator|~
literal|07000
expr_stmt|;
block|}
name|bp
index|[
literal|1
index|]
operator|=
literal|'P'
expr_stmt|;
name|bp
index|[
literal|2
index|]
operator|=
literal|'X'
expr_stmt|;
name|bp
index|[
literal|3
index|]
operator|=
name|length
expr_stmt|;
name|bp
index|[
literal|4
index|]
operator|=
literal|1
expr_stmt|;
comment|/* version	*/
comment|/* file mode */
name|set_num_733
argument_list|(
name|bp
operator|+
literal|5
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* file links (stat.st_nlink) */
name|set_num_733
argument_list|(
name|bp
operator|+
literal|13
argument_list|,
name|archive_entry_nlink
argument_list|(
name|file
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|set_num_733
argument_list|(
name|bp
operator|+
literal|21
argument_list|,
operator|(
name|uint32_t
operator|)
name|uid
argument_list|)
expr_stmt|;
name|set_num_733
argument_list|(
name|bp
operator|+
literal|29
argument_list|,
operator|(
name|uint32_t
operator|)
name|gid
argument_list|)
expr_stmt|;
comment|/* File Serial Number */
if|if
condition|(
name|pxent
operator|->
name|dir
condition|)
name|set_num_733
argument_list|(
name|bp
operator|+
literal|37
argument_list|,
name|pxent
operator|->
name|dir_location
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|file
operator|->
name|hardlink_target
operator|!=
name|NULL
condition|)
name|set_num_733
argument_list|(
name|bp
operator|+
literal|37
argument_list|,
name|file
operator|->
name|hardlink_target
operator|->
name|cur_content
operator|->
name|location
argument_list|)
expr_stmt|;
else|else
name|set_num_733
argument_list|(
name|bp
operator|+
literal|37
argument_list|,
name|file
operator|->
name|cur_content
operator|->
name|location
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|length
expr_stmt|;
block|}
name|extra_tell_used_size
argument_list|(
operator|&
name|ctl
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
comment|/* Write "SL" System Use Entry. */
if|if
condition|(
name|rr_flag
operator|&
name|RR_USE_SL
condition|)
block|{
comment|/* 		 *   "SL" Format: 		 *     e.g. a symbolic name is 'foo/bar' 		 *               len  ver  flg 		 *    +----+----+----+----+----+------------+ 		 *    | 'S'| 'L'| 0F | 01 | 00 | components | 		 *    +----+----+----+----+----+-----+------+ 		 *    0    1    2    3    4    5  ...|...  15 		 *<----------------- len --------+------> 		 *    components :                   | 		 *     cflg clen                     | 		 *    +----+----+----+----+----+     | 		 *    | 00 | 03 | 'f'| 'o'| 'o'|<---+ 		 *    +----+----+----+----+----+     | 		 *    5    6    7    8    9   10     | 		 *     cflg clen                     | 		 *    +----+----+----+----+----+     | 		 *    | 00 | 03 | 'b'| 'a'| 'r'|<---+ 		 *    +----+----+----+----+----+ 		 *   10   11   12   13   14   15 		 * 	 	 *    - cflg : flag of componet 		 *    - clen : length of componet 		 */
specifier|const
name|char
modifier|*
name|sl
decl_stmt|;
name|char
name|sl_last
decl_stmt|;
if|if
condition|(
name|extra_space
argument_list|(
operator|&
name|ctl
argument_list|)
operator|<
literal|7
condition|)
name|bp
operator|=
name|extra_next_record
argument_list|(
operator|&
name|ctl
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|sl
operator|=
name|file
operator|->
name|symlink
operator|.
name|s
expr_stmt|;
name|sl_last
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|bp
index|[
literal|1
index|]
operator|=
literal|'S'
expr_stmt|;
name|bp
index|[
literal|2
index|]
operator|=
literal|'L'
expr_stmt|;
name|bp
index|[
literal|4
index|]
operator|=
literal|1
expr_stmt|;
comment|/* version	*/
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|char
modifier|*
name|nc
decl_stmt|,
modifier|*
name|cf
decl_stmt|,
modifier|*
name|cl
decl_stmt|,
name|cldmy
init|=
literal|0
decl_stmt|;
name|int
name|sllen
decl_stmt|,
name|slmax
decl_stmt|;
name|slmax
operator|=
name|extra_space
argument_list|(
operator|&
name|ctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|slmax
operator|>
literal|0xff
condition|)
name|slmax
operator|=
literal|0xff
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|nc
operator|=
operator|&
name|bp
index|[
literal|6
index|]
expr_stmt|;
else|else
name|nc
operator|=
name|NULL
expr_stmt|;
name|cf
operator|=
name|cl
operator|=
name|NULL
expr_stmt|;
name|sllen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|sl
operator|&&
name|sllen
operator|+
literal|11
operator|<
name|slmax
condition|)
block|{
if|if
condition|(
name|sl_last
operator|==
literal|'\0'
operator|&&
name|sl
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* 					 *     flg  len 					 *    +----+----+ 					 *    | 08 | 00 | ROOT component. 					 *    +----+----+ ("/") 					 * 				 	 * Root component has to appear 				 	 * at the first component only. 					 */
if|if
condition|(
name|nc
operator|!=
name|NULL
condition|)
block|{
name|cf
operator|=
name|nc
operator|++
expr_stmt|;
operator|*
name|cf
operator|=
literal|0x08
expr_stmt|;
comment|/* ROOT */
operator|*
name|nc
operator|++
operator|=
literal|0
expr_stmt|;
block|}
name|sllen
operator|+=
literal|2
expr_stmt|;
name|sl
operator|++
expr_stmt|;
name|sl_last
operator|=
literal|'/'
expr_stmt|;
name|cl
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
operator|(
name|sl_last
operator|==
literal|'\0'
operator|||
name|sl_last
operator|==
literal|'/'
operator|)
operator|&&
name|sl
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|sl
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|sl
index|[
literal|2
index|]
operator|==
literal|'/'
operator|||
name|sl
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
operator|)
operator|||
operator|(
name|sl
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|sl
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|sl
index|[
literal|2
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|sl
index|[
literal|3
index|]
operator|==
literal|'/'
operator|||
name|sl
index|[
literal|3
index|]
operator|==
literal|'\0'
operator|)
operator|)
condition|)
block|{
comment|/* 					 *     flg  len 					 *    +----+----+ 					 *    | 04 | 00 | PARENT component. 					 *    +----+----+ ("..") 					 */
if|if
condition|(
name|nc
operator|!=
name|NULL
condition|)
block|{
name|cf
operator|=
name|nc
operator|++
expr_stmt|;
operator|*
name|cf
operator|=
literal|0x04
expr_stmt|;
comment|/* PARENT */
operator|*
name|nc
operator|++
operator|=
literal|0
expr_stmt|;
block|}
name|sllen
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|sl
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|sl
operator|+=
literal|3
expr_stmt|;
comment|/* skip "/.." */
else|else
name|sl
operator|+=
literal|2
expr_stmt|;
comment|/* skip ".." */
name|sl_last
operator|=
literal|'.'
expr_stmt|;
name|cl
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
operator|(
name|sl_last
operator|==
literal|'\0'
operator|||
name|sl_last
operator|==
literal|'/'
operator|)
operator|&&
name|sl
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|sl
index|[
literal|1
index|]
operator|==
literal|'/'
operator|||
name|sl
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
operator|)
operator|||
operator|(
name|sl
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|sl
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|sl
index|[
literal|2
index|]
operator|==
literal|'/'
operator|||
name|sl
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
operator|)
condition|)
block|{
comment|/* 					 *     flg  len 					 *    +----+----+ 					 *    | 02 | 00 | CURREENT component. 					 *    +----+----+ (".") 					 */
if|if
condition|(
name|nc
operator|!=
name|NULL
condition|)
block|{
name|cf
operator|=
name|nc
operator|++
expr_stmt|;
operator|*
name|cf
operator|=
literal|0x02
expr_stmt|;
comment|/* CURRENT */
operator|*
name|nc
operator|++
operator|=
literal|0
expr_stmt|;
block|}
name|sllen
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|sl
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|sl
operator|+=
literal|2
expr_stmt|;
comment|/* skip "/." */
else|else
name|sl
operator|++
expr_stmt|;
comment|/* skip "." */
name|sl_last
operator|=
literal|'.'
expr_stmt|;
name|cl
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sl
index|[
literal|0
index|]
operator|==
literal|'/'
operator|||
name|cl
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|nc
operator|!=
name|NULL
condition|)
block|{
name|cf
operator|=
name|nc
operator|++
expr_stmt|;
operator|*
name|cf
operator|=
literal|0
expr_stmt|;
name|cl
operator|=
name|nc
operator|++
expr_stmt|;
operator|*
name|cl
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|cl
operator|=
operator|&
name|cldmy
expr_stmt|;
name|sllen
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|sl
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|sl_last
operator|=
operator|*
name|sl
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
name|sl_last
operator|=
operator|*
name|sl
operator|++
expr_stmt|;
if|if
condition|(
name|nc
operator|!=
name|NULL
condition|)
block|{
operator|*
name|nc
operator|++
operator|=
name|sl_last
expr_stmt|;
operator|(
operator|*
name|cl
operator|)
operator|++
expr_stmt|;
block|}
name|sllen
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|sl
condition|)
block|{
name|length
operator|=
literal|5
operator|+
name|sllen
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
comment|/* 					 * Mark flg as CONTINUE component. 					 */
operator|*
name|cf
operator||=
literal|0x01
expr_stmt|;
comment|/* 					 *               len  ver  flg 					 *    +----+----+----+----+----+- 					 *    | 'S'| 'L'| XX | 01 | 01 | 					 *    +----+----+----+----+----+- 					 *                           ^ 					 *           continues in next "SL" 					 */
name|bp
index|[
literal|3
index|]
operator|=
name|length
expr_stmt|;
name|bp
index|[
literal|5
index|]
operator|=
literal|0x01
expr_stmt|;
comment|/* This Symbolic Link 						      * continues in next 						      * "SL" field */
name|bp
operator|+=
name|length
expr_stmt|;
block|}
name|extra_tell_used_size
argument_list|(
operator|&
name|ctl
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_space
argument_list|(
operator|&
name|ctl
argument_list|)
operator|<
literal|11
condition|)
name|bp
operator|=
name|extra_next_record
argument_list|(
operator|&
name|ctl
argument_list|,
literal|11
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
comment|/* Next 'SL' */
name|bp
index|[
literal|1
index|]
operator|=
literal|'S'
expr_stmt|;
name|bp
index|[
literal|2
index|]
operator|=
literal|'L'
expr_stmt|;
name|bp
index|[
literal|4
index|]
operator|=
literal|1
expr_stmt|;
comment|/* version */
block|}
block|}
else|else
block|{
name|length
operator|=
literal|5
operator|+
name|sllen
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|bp
index|[
literal|3
index|]
operator|=
name|length
expr_stmt|;
name|bp
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|bp
operator|+=
name|length
expr_stmt|;
block|}
name|extra_tell_used_size
argument_list|(
operator|&
name|ctl
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Write "TF" System Use Entry. */
if|if
condition|(
name|rr_flag
operator|&
name|RR_USE_TF
condition|)
block|{
comment|/* 		 *   "TF" Format: 		 *               len  ver 		 *    +----+----+----+----+-----+-------------+ 		 *    | 'T'| 'F'| XX | 01 |FLAGS| TIME STAMPS | 		 *    +----+----+----+----+-----+-------------+ 		 *    0    1    2    3    4     5            XX 		 *    TIME STAMPS : ISO 9660 Standard 9.1.5. 		 *                  If TF_LONG_FORM FLAGS is set, 		 *                  use ISO9660 Standard 8.4.26.1. 		 */
define|#
directive|define
name|TF_CREATION
value|0x01
comment|/* Creation time recorded		*/
define|#
directive|define
name|TF_MODIFY
value|0x02
comment|/* Modification time recorded		*/
define|#
directive|define
name|TF_ACCESS
value|0x04
comment|/* Last Access time recorded		*/
define|#
directive|define
name|TF_ATTRIBUTES
value|0x08
comment|/* Last Attribute Change time recorded  */
define|#
directive|define
name|TF_BACKUP
value|0x10
comment|/* Last Backup time recorded		*/
define|#
directive|define
name|TF_EXPIRATION
value|0x20
comment|/* Expiration time recorded		*/
define|#
directive|define
name|TF_EFFECTIVE
value|0x40
comment|/* Effective time recorded		*/
define|#
directive|define
name|TF_LONG_FORM
value|0x80
comment|/* ISO 9660 17-byte time format used	*/
name|unsigned
name|char
name|tf_flags
decl_stmt|;
name|length
operator|=
literal|5
expr_stmt|;
name|tf_flags
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|COMPAT_MKISOFS
if|if
condition|(
name|archive_entry_birthtime_is_set
argument_list|(
name|file
operator|->
name|entry
argument_list|)
operator|&&
name|archive_entry_birthtime
argument_list|(
name|file
operator|->
name|entry
argument_list|)
operator|<=
name|archive_entry_mtime
argument_list|(
name|file
operator|->
name|entry
argument_list|)
condition|)
block|{
name|length
operator|+=
literal|7
expr_stmt|;
name|tf_flags
operator||=
name|TF_CREATION
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|archive_entry_mtime_is_set
argument_list|(
name|file
operator|->
name|entry
argument_list|)
condition|)
block|{
name|length
operator|+=
literal|7
expr_stmt|;
name|tf_flags
operator||=
name|TF_MODIFY
expr_stmt|;
block|}
if|if
condition|(
name|archive_entry_atime_is_set
argument_list|(
name|file
operator|->
name|entry
argument_list|)
condition|)
block|{
name|length
operator|+=
literal|7
expr_stmt|;
name|tf_flags
operator||=
name|TF_ACCESS
expr_stmt|;
block|}
if|if
condition|(
name|archive_entry_ctime_is_set
argument_list|(
name|file
operator|->
name|entry
argument_list|)
condition|)
block|{
name|length
operator|+=
literal|7
expr_stmt|;
name|tf_flags
operator||=
name|TF_ATTRIBUTES
expr_stmt|;
block|}
if|if
condition|(
name|extra_space
argument_list|(
operator|&
name|ctl
argument_list|)
operator|<
name|length
condition|)
name|bp
operator|=
name|extra_next_record
argument_list|(
operator|&
name|ctl
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|bp
index|[
literal|1
index|]
operator|=
literal|'T'
expr_stmt|;
name|bp
index|[
literal|2
index|]
operator|=
literal|'F'
expr_stmt|;
name|bp
index|[
literal|3
index|]
operator|=
name|length
expr_stmt|;
name|bp
index|[
literal|4
index|]
operator|=
literal|1
expr_stmt|;
comment|/* version	*/
name|bp
index|[
literal|5
index|]
operator|=
name|tf_flags
expr_stmt|;
name|bp
operator|+=
literal|5
expr_stmt|;
comment|/* Creation time */
if|if
condition|(
name|tf_flags
operator|&
name|TF_CREATION
condition|)
block|{
name|set_time_915
argument_list|(
name|bp
operator|+
literal|1
argument_list|,
name|archive_entry_birthtime
argument_list|(
name|file
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|+=
literal|7
expr_stmt|;
block|}
comment|/* Modification time */
if|if
condition|(
name|tf_flags
operator|&
name|TF_MODIFY
condition|)
block|{
name|set_time_915
argument_list|(
name|bp
operator|+
literal|1
argument_list|,
name|archive_entry_mtime
argument_list|(
name|file
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|+=
literal|7
expr_stmt|;
block|}
comment|/* Last Access time */
if|if
condition|(
name|tf_flags
operator|&
name|TF_ACCESS
condition|)
block|{
name|set_time_915
argument_list|(
name|bp
operator|+
literal|1
argument_list|,
name|archive_entry_atime
argument_list|(
name|file
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|+=
literal|7
expr_stmt|;
block|}
comment|/* Last Attribute Change time */
if|if
condition|(
name|tf_flags
operator|&
name|TF_ATTRIBUTES
condition|)
block|{
name|set_time_915
argument_list|(
name|bp
operator|+
literal|1
argument_list|,
name|archive_entry_ctime
argument_list|(
name|file
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|+=
literal|7
expr_stmt|;
block|}
block|}
name|extra_tell_used_size
argument_list|(
operator|&
name|ctl
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
comment|/* Write "RE" System Use Entry. */
if|if
condition|(
name|rr_flag
operator|&
name|RR_USE_RE
condition|)
block|{
comment|/* 		 *   "RE" Format: 		 *               len  ver 		 *    +----+----+----+----+ 		 *    | 'R'| 'E'| 04 | 01 | 		 *    +----+----+----+----+ 		 *    0    1    2    3    4 		 */
name|length
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|extra_space
argument_list|(
operator|&
name|ctl
argument_list|)
operator|<
name|length
condition|)
name|bp
operator|=
name|extra_next_record
argument_list|(
operator|&
name|ctl
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|bp
index|[
literal|1
index|]
operator|=
literal|'R'
expr_stmt|;
name|bp
index|[
literal|2
index|]
operator|=
literal|'E'
expr_stmt|;
name|bp
index|[
literal|3
index|]
operator|=
name|length
expr_stmt|;
name|bp
index|[
literal|4
index|]
operator|=
literal|1
expr_stmt|;
comment|/* version	*/
name|bp
operator|+=
name|length
expr_stmt|;
block|}
name|extra_tell_used_size
argument_list|(
operator|&
name|ctl
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
comment|/* Write "PL" System Use Entry. */
if|if
condition|(
name|rr_flag
operator|&
name|RR_USE_PL
condition|)
block|{
comment|/* 		 *   "PL" Format: 		 *               len  ver 		 *    +----+----+----+----+------------+ 		 *    | 'P'| 'L'| 0C | 01 | *LOCATION  | 		 *    +----+----+----+----+------------+ 		 *    0    1    2    3    4           12 		 *    *LOCATION: location of parent directory 		 */
name|length
operator|=
literal|12
expr_stmt|;
if|if
condition|(
name|extra_space
argument_list|(
operator|&
name|ctl
argument_list|)
operator|<
name|length
condition|)
name|bp
operator|=
name|extra_next_record
argument_list|(
operator|&
name|ctl
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|bp
index|[
literal|1
index|]
operator|=
literal|'P'
expr_stmt|;
name|bp
index|[
literal|2
index|]
operator|=
literal|'L'
expr_stmt|;
name|bp
index|[
literal|3
index|]
operator|=
name|length
expr_stmt|;
name|bp
index|[
literal|4
index|]
operator|=
literal|1
expr_stmt|;
comment|/* version	*/
name|set_num_733
argument_list|(
name|bp
operator|+
literal|5
argument_list|,
name|rr_parent
operator|->
name|dir_location
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|length
expr_stmt|;
block|}
name|extra_tell_used_size
argument_list|(
operator|&
name|ctl
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
comment|/* Write "CL" System Use Entry. */
if|if
condition|(
name|rr_flag
operator|&
name|RR_USE_CL
condition|)
block|{
comment|/* 		 *   "CL" Format: 		 *               len  ver 		 *    +----+----+----+----+------------+ 		 *    | 'C'| 'L'| 0C | 01 | *LOCATION  | 		 *    +----+----+----+----+------------+ 		 *    0    1    2    3    4           12 		 *    *LOCATION: location of child directory 		 */
name|length
operator|=
literal|12
expr_stmt|;
if|if
condition|(
name|extra_space
argument_list|(
operator|&
name|ctl
argument_list|)
operator|<
name|length
condition|)
name|bp
operator|=
name|extra_next_record
argument_list|(
operator|&
name|ctl
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|bp
index|[
literal|1
index|]
operator|=
literal|'C'
expr_stmt|;
name|bp
index|[
literal|2
index|]
operator|=
literal|'L'
expr_stmt|;
name|bp
index|[
literal|3
index|]
operator|=
name|length
expr_stmt|;
name|bp
index|[
literal|4
index|]
operator|=
literal|1
expr_stmt|;
comment|/* version	*/
name|set_num_733
argument_list|(
name|bp
operator|+
literal|5
argument_list|,
name|isoent
operator|->
name|rr_child
operator|->
name|dir_location
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|length
expr_stmt|;
block|}
name|extra_tell_used_size
argument_list|(
operator|&
name|ctl
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
comment|/* Write "PN" System Use Entry. */
if|if
condition|(
name|rr_flag
operator|&
name|RR_USE_PN
condition|)
block|{
comment|/* 		 *   "PN" Format: 		 *               len  ver 		 *    +----+----+----+----+------------+------------+ 		 *    | 'P'| 'N'| 14 | 01 | dev_t high | dev_t low  | 		 *    +----+----+----+----+------------+------------+ 		 *    0    1    2    3    4           12           20 		 */
name|length
operator|=
literal|20
expr_stmt|;
if|if
condition|(
name|extra_space
argument_list|(
operator|&
name|ctl
argument_list|)
operator|<
name|length
condition|)
name|bp
operator|=
name|extra_next_record
argument_list|(
operator|&
name|ctl
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|uint64_t
name|dev
decl_stmt|;
name|bp
index|[
literal|1
index|]
operator|=
literal|'P'
expr_stmt|;
name|bp
index|[
literal|2
index|]
operator|=
literal|'N'
expr_stmt|;
name|bp
index|[
literal|3
index|]
operator|=
name|length
expr_stmt|;
name|bp
index|[
literal|4
index|]
operator|=
literal|1
expr_stmt|;
comment|/* version	*/
name|dev
operator|=
operator|(
name|uint64_t
operator|)
name|archive_entry_rdev
argument_list|(
name|file
operator|->
name|entry
argument_list|)
expr_stmt|;
name|set_num_733
argument_list|(
name|bp
operator|+
literal|5
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|dev
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|set_num_733
argument_list|(
name|bp
operator|+
literal|13
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|dev
operator|&
literal|0xFFFFFFFF
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|length
expr_stmt|;
block|}
name|extra_tell_used_size
argument_list|(
operator|&
name|ctl
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
comment|/* Write "ZF" System Use Entry. */
if|if
condition|(
name|file
operator|->
name|zisofs
operator|.
name|header_size
condition|)
block|{
comment|/* 		 *   "ZF" Format: 		 *               len  ver 		 *    +----+----+----+----+----+----+-------------+ 		 *    | 'Z'| 'F'| 10 | 01 | 'p'| 'z'| Header Size | 		 *    +----+----+----+----+----+----+-------------+ 		 *    0    1    2    3    4    5    6             7 		 *    +--------------------+-------------------+ 		 *    | Log2 of block Size | Uncompressed Size | 		 *    +--------------------+-------------------+ 		 *    7                    8                   16 		 */
name|length
operator|=
literal|16
expr_stmt|;
if|if
condition|(
name|extra_space
argument_list|(
operator|&
name|ctl
argument_list|)
operator|<
name|length
condition|)
name|bp
operator|=
name|extra_next_record
argument_list|(
operator|&
name|ctl
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|bp
index|[
literal|1
index|]
operator|=
literal|'Z'
expr_stmt|;
name|bp
index|[
literal|2
index|]
operator|=
literal|'F'
expr_stmt|;
name|bp
index|[
literal|3
index|]
operator|=
name|length
expr_stmt|;
name|bp
index|[
literal|4
index|]
operator|=
literal|1
expr_stmt|;
comment|/* version	*/
name|bp
index|[
literal|5
index|]
operator|=
literal|'p'
expr_stmt|;
name|bp
index|[
literal|6
index|]
operator|=
literal|'z'
expr_stmt|;
name|bp
index|[
literal|7
index|]
operator|=
name|file
operator|->
name|zisofs
operator|.
name|header_size
expr_stmt|;
name|bp
index|[
literal|8
index|]
operator|=
name|file
operator|->
name|zisofs
operator|.
name|log2_bs
expr_stmt|;
name|set_num_733
argument_list|(
name|bp
operator|+
literal|9
argument_list|,
name|file
operator|->
name|zisofs
operator|.
name|uncompressed_size
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|length
expr_stmt|;
block|}
name|extra_tell_used_size
argument_list|(
operator|&
name|ctl
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
comment|/* Write "CE" System Use Entry. */
if|if
condition|(
name|t
operator|==
name|DIR_REC_SELF
operator|&&
name|isoent
operator|==
name|isoent
operator|->
name|parent
condition|)
block|{
name|length
operator|=
name|RR_CE_SIZE
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|set_SUSP_CE
argument_list|(
name|bp
operator|+
literal|1
argument_list|,
name|iso9660
operator|->
name|location_rrip_er
argument_list|,
literal|0
argument_list|,
name|RRIP_ER_SIZE
argument_list|)
expr_stmt|;
name|extra_tell_used_size
argument_list|(
operator|&
name|ctl
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|extra_close_record
argument_list|(
operator|&
name|ctl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ctl
operator|.
name|dr_len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write data of a Directory Record or calculate writing bytes itself.  * If parameter `p' is NULL, calculates the size of writing data, which  * a Directory Record needs to write, then it saved and return  * the calculated size.  * Parameter `n' is a remaining size of buffer. when parameter `p' is  * not NULL, check whether that `n' is not less than the saved size.  * if that `n' is small, return zero.  *  * This format of the Directory Record is according to  * ISO9660 Standard 9.1  */
end_comment

begin_function
specifier|static
name|int
name|set_directory_record
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|n
parameter_list|,
name|struct
name|isoent
modifier|*
name|isoent
parameter_list|,
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
name|enum
name|dir_rec_type
name|t
parameter_list|,
name|enum
name|vdd_type
name|vdd_type
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|bp
decl_stmt|;
name|size_t
name|dr_len
decl_stmt|;
name|size_t
name|fi_len
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Check whether a write buffer size is less than the 		 * saved size which is needed to write this Directory 		 * Record. 		 */
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|DIR_REC_VD
case|:
name|dr_len
operator|=
name|isoent
operator|->
name|dr_len
operator|.
name|vd
expr_stmt|;
break|break;
case|case
name|DIR_REC_SELF
case|:
name|dr_len
operator|=
name|isoent
operator|->
name|dr_len
operator|.
name|self
expr_stmt|;
break|break;
case|case
name|DIR_REC_PARENT
case|:
name|dr_len
operator|=
name|isoent
operator|->
name|dr_len
operator|.
name|parent
expr_stmt|;
break|break;
case|case
name|DIR_REC_NORMAL
case|:
default|default:
name|dr_len
operator|=
name|isoent
operator|->
name|dr_len
operator|.
name|normal
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dr_len
operator|>
name|n
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Needs more buffer size. */
block|}
if|if
condition|(
name|t
operator|==
name|DIR_REC_NORMAL
operator|&&
name|isoent
operator|->
name|identifier
operator|!=
name|NULL
condition|)
name|fi_len
operator|=
name|isoent
operator|->
name|id_len
expr_stmt|;
else|else
name|fi_len
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|struct
name|isoent
modifier|*
name|xisoent
decl_stmt|;
name|struct
name|isofile
modifier|*
name|file
decl_stmt|;
name|unsigned
name|char
name|flag
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|DIR_REC_PARENT
condition|)
name|xisoent
operator|=
name|isoent
operator|->
name|parent
expr_stmt|;
else|else
name|xisoent
operator|=
name|isoent
expr_stmt|;
name|file
operator|=
name|isoent
operator|->
name|file
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|hardlink_target
operator|!=
name|NULL
condition|)
name|file
operator|=
name|file
operator|->
name|hardlink_target
expr_stmt|;
comment|/* Make a file flag. */
if|if
condition|(
name|xisoent
operator|->
name|dir
condition|)
name|flag
operator|=
name|FILE_FLAG_DIRECTORY
expr_stmt|;
else|else
block|{
if|if
condition|(
name|file
operator|->
name|cur_content
operator|->
name|next
operator|!=
name|NULL
condition|)
name|flag
operator|=
name|FILE_FLAG_MULTI_EXTENT
expr_stmt|;
else|else
name|flag
operator|=
literal|0
expr_stmt|;
block|}
name|bp
operator|=
name|p
operator|-
literal|1
expr_stmt|;
comment|/* Extended Attribute Record Length */
name|set_num_711
argument_list|(
name|bp
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Location of Extent */
if|if
condition|(
name|xisoent
operator|->
name|dir
condition|)
name|set_num_733
argument_list|(
name|bp
operator|+
literal|3
argument_list|,
name|xisoent
operator|->
name|dir_location
argument_list|)
expr_stmt|;
else|else
name|set_num_733
argument_list|(
name|bp
operator|+
literal|3
argument_list|,
name|file
operator|->
name|cur_content
operator|->
name|location
argument_list|)
expr_stmt|;
comment|/* Data Length */
if|if
condition|(
name|xisoent
operator|->
name|dir
condition|)
name|set_num_733
argument_list|(
name|bp
operator|+
literal|11
argument_list|,
name|xisoent
operator|->
name|dir_block
operator|*
name|LOGICAL_BLOCK_SIZE
argument_list|)
expr_stmt|;
else|else
name|set_num_733
argument_list|(
name|bp
operator|+
literal|11
argument_list|,
operator|(
name|uint32_t
operator|)
name|file
operator|->
name|cur_content
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/* Recording Date and Time */
comment|/* NOTE: 		 *  If a file type is symbolic link, you are seeing this 		 *  field value is different from a value mkisofs makes. 		 *  libarchive uses lstat to get this one, but it 		 *  seems mkisofs uses stat to get. 		 */
name|set_time_915
argument_list|(
name|bp
operator|+
literal|19
argument_list|,
name|archive_entry_mtime
argument_list|(
name|xisoent
operator|->
name|file
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* File Flags */
name|bp
index|[
literal|26
index|]
operator|=
name|flag
expr_stmt|;
comment|/* File Unit Size */
name|set_num_711
argument_list|(
name|bp
operator|+
literal|27
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Interleave Gap Size */
name|set_num_711
argument_list|(
name|bp
operator|+
literal|28
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Volume Sequence Number */
name|set_num_723
argument_list|(
name|bp
operator|+
literal|29
argument_list|,
name|iso9660
operator|->
name|volume_sequence_number
argument_list|)
expr_stmt|;
comment|/* Length of File Identifier */
name|set_num_711
argument_list|(
name|bp
operator|+
literal|33
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|fi_len
argument_list|)
expr_stmt|;
comment|/* File Identifier */
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|DIR_REC_VD
case|:
case|case
name|DIR_REC_SELF
case|:
name|set_num_711
argument_list|(
name|bp
operator|+
literal|34
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIR_REC_PARENT
case|:
name|set_num_711
argument_list|(
name|bp
operator|+
literal|34
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIR_REC_NORMAL
case|:
if|if
condition|(
name|isoent
operator|->
name|identifier
operator|!=
name|NULL
condition|)
name|memcpy
argument_list|(
name|bp
operator|+
literal|34
argument_list|,
name|isoent
operator|->
name|identifier
argument_list|,
name|fi_len
argument_list|)
expr_stmt|;
else|else
name|set_num_711
argument_list|(
name|bp
operator|+
literal|34
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
name|bp
operator|=
name|NULL
expr_stmt|;
name|dr_len
operator|=
literal|33
operator|+
name|fi_len
expr_stmt|;
comment|/* Padding Field */
if|if
condition|(
name|dr_len
operator|&
literal|0x01
condition|)
block|{
name|dr_len
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|bp
index|[
name|dr_len
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Volume Descriptor does not record extension. */
if|if
condition|(
name|t
operator|==
name|DIR_REC_VD
condition|)
block|{
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
comment|/* Length of Directory Record */
name|set_num_711
argument_list|(
name|p
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|dr_len
argument_list|)
expr_stmt|;
else|else
name|isoent
operator|->
name|dr_len
operator|.
name|vd
operator|=
operator|(
name|int
operator|)
name|dr_len
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|dr_len
operator|)
return|;
block|}
comment|/* Rockridge */
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|rr
operator|&&
name|vdd_type
operator|!=
name|VDD_JOLIET
condition|)
name|dr_len
operator|=
name|set_directory_record_rr
argument_list|(
name|bp
argument_list|,
operator|(
name|int
operator|)
name|dr_len
argument_list|,
name|isoent
argument_list|,
name|iso9660
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
comment|/* Length of Directory Record */
name|set_num_711
argument_list|(
name|p
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|dr_len
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 		 * Save the size which is needed to write this 		 * Directory Record. 		 */
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|DIR_REC_VD
case|:
comment|/* This case does not come, but compiler 			 * complains that DIR_REC_VD not handled 			 *  in switch ....  */
break|break;
case|case
name|DIR_REC_SELF
case|:
name|isoent
operator|->
name|dr_len
operator|.
name|self
operator|=
operator|(
name|int
operator|)
name|dr_len
expr_stmt|;
break|break;
case|case
name|DIR_REC_PARENT
case|:
name|isoent
operator|->
name|dr_len
operator|.
name|parent
operator|=
operator|(
name|int
operator|)
name|dr_len
expr_stmt|;
break|break;
case|case
name|DIR_REC_NORMAL
case|:
name|isoent
operator|->
name|dr_len
operator|.
name|normal
operator|=
operator|(
name|int
operator|)
name|dr_len
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
operator|(
name|int
operator|)
name|dr_len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the size of a directory record.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|get_dir_rec_size
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
name|struct
name|isoent
modifier|*
name|isoent
parameter_list|,
name|enum
name|dir_rec_type
name|t
parameter_list|,
name|enum
name|vdd_type
name|vdd_type
parameter_list|)
block|{
return|return
operator|(
name|set_directory_record
argument_list|(
name|NULL
argument_list|,
name|SIZE_MAX
argument_list|,
name|isoent
argument_list|,
name|iso9660
argument_list|,
name|t
argument_list|,
name|vdd_type
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Manage to write ISO-image data with wbuff to reduce calling  * __archive_write_output() for performance.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|char
modifier|*
name|wb_buffptr
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
operator|(
expr|struct
name|iso9660
operator|*
operator|)
name|a
operator|->
name|format_data
decl_stmt|;
return|return
operator|(
operator|&
operator|(
name|iso9660
operator|->
name|wbuff
index|[
sizeof|sizeof
argument_list|(
name|iso9660
operator|->
name|wbuff
argument_list|)
operator|-
name|iso9660
operator|->
name|wbuff_remaining
index|]
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wb_write_out
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
operator|(
expr|struct
name|iso9660
operator|*
operator|)
name|a
operator|->
name|format_data
decl_stmt|;
name|size_t
name|wsize
decl_stmt|,
name|nw
decl_stmt|;
name|int
name|r
decl_stmt|;
name|wsize
operator|=
sizeof|sizeof
argument_list|(
name|iso9660
operator|->
name|wbuff
argument_list|)
operator|-
name|iso9660
operator|->
name|wbuff_remaining
expr_stmt|;
name|nw
operator|=
name|wsize
operator|%
name|LOGICAL_BLOCK_SIZE
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|wbuff_type
operator|==
name|WB_TO_STREAM
condition|)
name|r
operator|=
name|__archive_write_output
argument_list|(
name|a
argument_list|,
name|iso9660
operator|->
name|wbuff
argument_list|,
name|wsize
operator|-
name|nw
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|write_to_temp
argument_list|(
name|a
argument_list|,
name|iso9660
operator|->
name|wbuff
argument_list|,
name|wsize
operator|-
name|nw
argument_list|)
expr_stmt|;
comment|/* Increase the offset. */
name|iso9660
operator|->
name|wbuff_offset
operator|+=
name|wsize
operator|-
name|nw
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|wbuff_offset
operator|>
name|iso9660
operator|->
name|wbuff_written
condition|)
name|iso9660
operator|->
name|wbuff_written
operator|=
name|iso9660
operator|->
name|wbuff_offset
expr_stmt|;
name|iso9660
operator|->
name|wbuff_remaining
operator|=
sizeof|sizeof
argument_list|(
name|iso9660
operator|->
name|wbuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|nw
condition|)
block|{
name|iso9660
operator|->
name|wbuff_remaining
operator|-=
name|nw
expr_stmt|;
name|memmove
argument_list|(
name|iso9660
operator|->
name|wbuff
argument_list|,
name|iso9660
operator|->
name|wbuff
operator|+
name|wsize
operator|-
name|nw
argument_list|,
name|nw
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wb_consume
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
operator|(
expr|struct
name|iso9660
operator|*
operator|)
name|a
operator|->
name|format_data
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|iso9660
operator|->
name|wbuff_remaining
operator|||
name|iso9660
operator|->
name|wbuff_remaining
operator|==
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Internal Programing error: iso9660:wb_consume()"
literal|" size=%jd, wbuff_remaining=%jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|size
argument_list|,
operator|(
name|intmax_t
operator|)
name|iso9660
operator|->
name|wbuff_remaining
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|iso9660
operator|->
name|wbuff_remaining
operator|-=
name|size
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|wbuff_remaining
operator|<
name|LOGICAL_BLOCK_SIZE
condition|)
return|return
operator|(
name|wb_write_out
argument_list|(
name|a
argument_list|)
operator|)
return|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
end_ifdef

begin_function
specifier|static
name|int
name|wb_set_offset
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|int64_t
name|off
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
operator|(
expr|struct
name|iso9660
operator|*
operator|)
name|a
operator|->
name|format_data
decl_stmt|;
name|int64_t
name|used
decl_stmt|,
name|ext_bytes
decl_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|wbuff_type
operator|!=
name|WB_TO_TEMP
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Internal Programing error: iso9660:wb_set_offset()"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|used
operator|=
sizeof|sizeof
argument_list|(
name|iso9660
operator|->
name|wbuff
argument_list|)
operator|-
name|iso9660
operator|->
name|wbuff_remaining
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|wbuff_offset
operator|+
name|used
operator|>
name|iso9660
operator|->
name|wbuff_tail
condition|)
name|iso9660
operator|->
name|wbuff_tail
operator|=
name|iso9660
operator|->
name|wbuff_offset
operator|+
name|used
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|wbuff_offset
operator|<
name|iso9660
operator|->
name|wbuff_written
condition|)
block|{
if|if
condition|(
name|used
operator|>
literal|0
operator|&&
name|write_to_temp
argument_list|(
name|a
argument_list|,
name|iso9660
operator|->
name|wbuff
argument_list|,
operator|(
name|size_t
operator|)
name|used
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|iso9660
operator|->
name|wbuff_offset
operator|=
name|iso9660
operator|->
name|wbuff_written
expr_stmt|;
name|lseek
argument_list|(
name|iso9660
operator|->
name|temp_fd
argument_list|,
name|iso9660
operator|->
name|wbuff_offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|wbuff_remaining
operator|=
sizeof|sizeof
argument_list|(
name|iso9660
operator|->
name|wbuff
argument_list|)
expr_stmt|;
name|used
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|off
operator|<
name|iso9660
operator|->
name|wbuff_offset
condition|)
block|{
comment|/* 		 * Write out waiting data. 		 */
if|if
condition|(
name|used
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|wb_write_out
argument_list|(
name|a
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|lseek
argument_list|(
name|iso9660
operator|->
name|temp_fd
argument_list|,
name|off
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|wbuff_offset
operator|=
name|off
expr_stmt|;
name|iso9660
operator|->
name|wbuff_remaining
operator|=
sizeof|sizeof
argument_list|(
name|iso9660
operator|->
name|wbuff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|off
operator|<=
name|iso9660
operator|->
name|wbuff_tail
condition|)
block|{
name|iso9660
operator|->
name|wbuff_remaining
operator|=
call|(
name|size_t
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|iso9660
operator|->
name|wbuff
argument_list|)
operator|-
operator|(
name|off
operator|-
name|iso9660
operator|->
name|wbuff_offset
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ext_bytes
operator|=
name|off
operator|-
name|iso9660
operator|->
name|wbuff_tail
expr_stmt|;
name|iso9660
operator|->
name|wbuff_remaining
operator|=
call|(
name|size_t
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|iso9660
operator|->
name|wbuff
argument_list|)
operator|-
operator|(
name|iso9660
operator|->
name|wbuff_tail
operator|-
name|iso9660
operator|->
name|wbuff_offset
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|ext_bytes
operator|>=
operator|(
name|int64_t
operator|)
name|iso9660
operator|->
name|wbuff_remaining
condition|)
block|{
if|if
condition|(
name|write_null
argument_list|(
name|a
argument_list|,
operator|(
name|size_t
operator|)
name|iso9660
operator|->
name|wbuff_remaining
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|ext_bytes
operator|-=
name|iso9660
operator|->
name|wbuff_remaining
expr_stmt|;
block|}
if|if
condition|(
name|ext_bytes
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|write_null
argument_list|(
name|a
argument_list|,
operator|(
name|size_t
operator|)
name|ext_bytes
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_ZLIB_H */
end_comment

begin_function
specifier|static
name|int
name|write_null
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|remaining
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|old
decl_stmt|;
name|int
name|r
decl_stmt|;
name|remaining
operator|=
name|wb_remaining
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|p
operator|=
name|wb_buffptr
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
name|remaining
condition|)
block|{
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|wb_consume
argument_list|(
name|a
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|remaining
argument_list|)
expr_stmt|;
name|r
operator|=
name|wb_consume
argument_list|(
name|a
argument_list|,
name|remaining
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|size
operator|-=
name|remaining
expr_stmt|;
name|old
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|wb_buffptr
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|old
operator|-
name|p
argument_list|)
expr_stmt|;
name|remaining
operator|=
name|wb_remaining
argument_list|(
name|a
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
condition|)
block|{
name|size_t
name|wsize
init|=
name|size
decl_stmt|;
if|if
condition|(
name|wsize
operator|>
name|remaining
condition|)
name|wsize
operator|=
name|remaining
expr_stmt|;
name|r
operator|=
name|wb_consume
argument_list|(
name|a
argument_list|,
name|wsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|size
operator|-=
name|wsize
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write Volume Descriptor Set Terminator  */
end_comment

begin_function
specifier|static
name|int
name|write_VD_terminator
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|wb_buffptr
argument_list|(
name|a
argument_list|)
operator|-
literal|1
expr_stmt|;
name|set_VD_bp
argument_list|(
name|bp
argument_list|,
name|VDT_TERMINATOR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_unused_field_bp
argument_list|(
name|bp
argument_list|,
literal|8
argument_list|,
name|LOGICAL_BLOCK_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
name|wb_consume
argument_list|(
name|a
argument_list|,
name|LOGICAL_BLOCK_SIZE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_file_identifier
parameter_list|(
name|unsigned
name|char
modifier|*
name|bp
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|,
name|enum
name|vdc
name|vdc
parameter_list|,
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|vdd
modifier|*
name|vdd
parameter_list|,
name|struct
name|archive_string
modifier|*
name|id
parameter_list|,
specifier|const
name|char
modifier|*
name|label
parameter_list|,
name|int
name|leading_under
parameter_list|,
name|enum
name|char_type
name|char_type
parameter_list|)
block|{
name|char
name|identifier
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|isoent
modifier|*
name|isoent
decl_stmt|;
specifier|const
name|char
modifier|*
name|ids
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|id
operator|->
name|length
operator|>
literal|0
operator|&&
name|leading_under
operator|&&
name|id
operator|->
name|s
index|[
literal|0
index|]
operator|!=
literal|'_'
condition|)
block|{
if|if
condition|(
name|char_type
operator|==
name|A_CHAR
condition|)
name|r
operator|=
name|set_str_a_characters_bp
argument_list|(
name|a
argument_list|,
name|bp
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|id
operator|->
name|s
argument_list|,
name|vdc
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|set_str_d_characters_bp
argument_list|(
name|a
argument_list|,
name|bp
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|id
operator|->
name|s
argument_list|,
name|vdc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|id
operator|->
name|length
operator|>
literal|0
condition|)
block|{
name|ids
operator|=
name|id
operator|->
name|s
expr_stmt|;
if|if
condition|(
name|leading_under
condition|)
name|ids
operator|++
expr_stmt|;
name|isoent
operator|=
name|isoent_find_entry
argument_list|(
name|vdd
operator|->
name|rootent
argument_list|,
name|ids
argument_list|)
expr_stmt|;
if|if
condition|(
name|isoent
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Not Found %s `%s'."
argument_list|,
name|label
argument_list|,
name|ids
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|len
operator|=
name|isoent
operator|->
name|ext_off
operator|+
name|isoent
operator|->
name|ext_len
expr_stmt|;
if|if
condition|(
name|vdd
operator|->
name|vdd_type
operator|==
name|VDD_JOLIET
condition|)
block|{
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|identifier
argument_list|)
operator|-
literal|2
condition|)
name|len
operator|=
sizeof|sizeof
argument_list|(
name|identifier
argument_list|)
operator|-
literal|2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|identifier
argument_list|)
operator|-
literal|1
condition|)
name|len
operator|=
sizeof|sizeof
argument_list|(
name|identifier
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|identifier
argument_list|,
name|isoent
operator|->
name|identifier
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|identifier
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|vdd
operator|->
name|vdd_type
operator|==
name|VDD_JOLIET
condition|)
block|{
name|identifier
index|[
name|len
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|vdc
operator|=
name|VDC_UCS2_DIRECT
expr_stmt|;
block|}
if|if
condition|(
name|char_type
operator|==
name|A_CHAR
condition|)
name|r
operator|=
name|set_str_a_characters_bp
argument_list|(
name|a
argument_list|,
name|bp
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|identifier
argument_list|,
name|vdc
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|set_str_d_characters_bp
argument_list|(
name|a
argument_list|,
name|bp
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|identifier
argument_list|,
name|vdc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|char_type
operator|==
name|A_CHAR
condition|)
name|r
operator|=
name|set_str_a_characters_bp
argument_list|(
name|a
argument_list|,
name|bp
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|NULL
argument_list|,
name|vdc
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|set_str_d_characters_bp
argument_list|(
name|a
argument_list|,
name|bp
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|NULL
argument_list|,
name|vdc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write Primary/Supplementary Volume Descriptor  */
end_comment

begin_function
specifier|static
name|int
name|write_VD
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|vdd
modifier|*
name|vdd
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bp
decl_stmt|;
name|uint16_t
name|volume_set_size
init|=
literal|1
decl_stmt|;
name|char
name|identifier
index|[
literal|256
index|]
decl_stmt|;
name|enum
name|VD_type
name|vdt
decl_stmt|;
name|enum
name|vdc
name|vdc
decl_stmt|;
name|unsigned
name|char
name|vd_ver
decl_stmt|,
name|fst_ver
decl_stmt|;
name|int
name|r
decl_stmt|;
name|iso9660
operator|=
name|a
operator|->
name|format_data
expr_stmt|;
switch|switch
condition|(
name|vdd
operator|->
name|vdd_type
condition|)
block|{
case|case
name|VDD_JOLIET
case|:
name|vdt
operator|=
name|VDT_SUPPLEMENTARY
expr_stmt|;
name|vd_ver
operator|=
name|fst_ver
operator|=
literal|1
expr_stmt|;
name|vdc
operator|=
name|VDC_UCS2
expr_stmt|;
break|break;
case|case
name|VDD_ENHANCED
case|:
name|vdt
operator|=
name|VDT_SUPPLEMENTARY
expr_stmt|;
name|vd_ver
operator|=
name|fst_ver
operator|=
literal|2
expr_stmt|;
name|vdc
operator|=
name|VDC_LOWERCASE
expr_stmt|;
break|break;
case|case
name|VDD_PRIMARY
case|:
default|default:
name|vdt
operator|=
name|VDT_PRIMARY
expr_stmt|;
name|vd_ver
operator|=
name|fst_ver
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_MKISOFS
name|vdc
operator|=
name|VDC_LOWERCASE
expr_stmt|;
else|#
directive|else
name|vdc
operator|=
name|VDC_STD
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|bp
operator|=
name|wb_buffptr
argument_list|(
name|a
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Volume Descriptor Type */
name|set_VD_bp
argument_list|(
name|bp
argument_list|,
name|vdt
argument_list|,
name|vd_ver
argument_list|)
expr_stmt|;
comment|/* Unused Field */
name|set_unused_field_bp
argument_list|(
name|bp
argument_list|,
literal|8
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* System Identifier */
name|get_system_identitier
argument_list|(
name|identifier
argument_list|,
sizeof|sizeof
argument_list|(
name|identifier
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|set_str_a_characters_bp
argument_list|(
name|a
argument_list|,
name|bp
argument_list|,
literal|9
argument_list|,
literal|40
argument_list|,
name|identifier
argument_list|,
name|vdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
comment|/* Volume Identifier */
name|r
operator|=
name|set_str_d_characters_bp
argument_list|(
name|a
argument_list|,
name|bp
argument_list|,
literal|41
argument_list|,
literal|72
argument_list|,
name|iso9660
operator|->
name|volume_identifier
operator|.
name|s
argument_list|,
name|vdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
comment|/* Unused Field */
name|set_unused_field_bp
argument_list|(
name|bp
argument_list|,
literal|73
argument_list|,
literal|80
argument_list|)
expr_stmt|;
comment|/* Volume Space Size */
name|set_num_733
argument_list|(
name|bp
operator|+
literal|81
argument_list|,
name|iso9660
operator|->
name|volume_space_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdd
operator|->
name|vdd_type
operator|==
name|VDD_JOLIET
condition|)
block|{
comment|/* Escape Sequences */
name|bp
index|[
literal|89
index|]
operator|=
literal|0x25
expr_stmt|;
comment|/* UCS-2 Level 3 */
name|bp
index|[
literal|90
index|]
operator|=
literal|0x2F
expr_stmt|;
name|bp
index|[
literal|91
index|]
operator|=
literal|0x45
expr_stmt|;
name|memset
argument_list|(
name|bp
operator|+
literal|92
argument_list|,
literal|0
argument_list|,
literal|120
operator|-
literal|92
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Unused Field */
name|set_unused_field_bp
argument_list|(
name|bp
argument_list|,
literal|89
argument_list|,
literal|120
argument_list|)
expr_stmt|;
block|}
comment|/* Volume Set Size */
name|set_num_723
argument_list|(
name|bp
operator|+
literal|121
argument_list|,
name|volume_set_size
argument_list|)
expr_stmt|;
comment|/* Volume Sequence Number */
name|set_num_723
argument_list|(
name|bp
operator|+
literal|125
argument_list|,
name|iso9660
operator|->
name|volume_sequence_number
argument_list|)
expr_stmt|;
comment|/* Logical Block Size */
name|set_num_723
argument_list|(
name|bp
operator|+
literal|129
argument_list|,
name|LOGICAL_BLOCK_SIZE
argument_list|)
expr_stmt|;
comment|/* Path Table Size */
name|set_num_733
argument_list|(
name|bp
operator|+
literal|133
argument_list|,
name|vdd
operator|->
name|path_table_size
argument_list|)
expr_stmt|;
comment|/* Location of Occurrence of Type L Path Table */
name|set_num_731
argument_list|(
name|bp
operator|+
literal|141
argument_list|,
name|vdd
operator|->
name|location_type_L_path_table
argument_list|)
expr_stmt|;
comment|/* Location of Optional Occurrence of Type L Path Table */
name|set_num_731
argument_list|(
name|bp
operator|+
literal|145
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Location of Occurrence of Type M Path Table */
name|set_num_732
argument_list|(
name|bp
operator|+
literal|149
argument_list|,
name|vdd
operator|->
name|location_type_M_path_table
argument_list|)
expr_stmt|;
comment|/* Location of Optional Occurrence of Type M Path Table */
name|set_num_732
argument_list|(
name|bp
operator|+
literal|153
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Directory Record for Root Directory(BP 157 to 190) */
name|set_directory_record
argument_list|(
name|bp
operator|+
literal|157
argument_list|,
literal|190
operator|-
literal|157
operator|+
literal|1
argument_list|,
name|vdd
operator|->
name|rootent
argument_list|,
name|iso9660
argument_list|,
name|DIR_REC_VD
argument_list|,
name|vdd
operator|->
name|vdd_type
argument_list|)
expr_stmt|;
comment|/* Volume Set Identifier */
name|r
operator|=
name|set_str_d_characters_bp
argument_list|(
name|a
argument_list|,
name|bp
argument_list|,
literal|191
argument_list|,
literal|318
argument_list|,
literal|""
argument_list|,
name|vdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
comment|/* Publisher Identifier */
name|r
operator|=
name|set_file_identifier
argument_list|(
name|bp
argument_list|,
literal|319
argument_list|,
literal|446
argument_list|,
name|vdc
argument_list|,
name|a
argument_list|,
name|vdd
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|publisher_identifier
operator|)
argument_list|,
literal|"Publisher File"
argument_list|,
literal|1
argument_list|,
name|A_CHAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
comment|/* Data Preparer Identifier */
name|r
operator|=
name|set_file_identifier
argument_list|(
name|bp
argument_list|,
literal|447
argument_list|,
literal|574
argument_list|,
name|vdc
argument_list|,
name|a
argument_list|,
name|vdd
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|data_preparer_identifier
operator|)
argument_list|,
literal|"Data Preparer File"
argument_list|,
literal|1
argument_list|,
name|A_CHAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
comment|/* Application Identifier */
name|r
operator|=
name|set_file_identifier
argument_list|(
name|bp
argument_list|,
literal|575
argument_list|,
literal|702
argument_list|,
name|vdc
argument_list|,
name|a
argument_list|,
name|vdd
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|application_identifier
operator|)
argument_list|,
literal|"Application File"
argument_list|,
literal|1
argument_list|,
name|A_CHAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
comment|/* Copyright File Identifier */
name|r
operator|=
name|set_file_identifier
argument_list|(
name|bp
argument_list|,
literal|703
argument_list|,
literal|739
argument_list|,
name|vdc
argument_list|,
name|a
argument_list|,
name|vdd
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|copyright_file_identifier
operator|)
argument_list|,
literal|"Copyright File"
argument_list|,
literal|0
argument_list|,
name|D_CHAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
comment|/* Abstract File Identifier */
name|r
operator|=
name|set_file_identifier
argument_list|(
name|bp
argument_list|,
literal|740
argument_list|,
literal|776
argument_list|,
name|vdc
argument_list|,
name|a
argument_list|,
name|vdd
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|abstract_file_identifier
operator|)
argument_list|,
literal|"Abstract File"
argument_list|,
literal|0
argument_list|,
name|D_CHAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
comment|/* Bibliongraphic File Identifier */
name|r
operator|=
name|set_file_identifier
argument_list|(
name|bp
argument_list|,
literal|777
argument_list|,
literal|813
argument_list|,
name|vdc
argument_list|,
name|a
argument_list|,
name|vdd
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|bibliographic_file_identifier
operator|)
argument_list|,
literal|"Bibliongraphic File"
argument_list|,
literal|0
argument_list|,
name|D_CHAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
comment|/* Volume Creation Date and Time */
name|set_date_time
argument_list|(
name|bp
operator|+
literal|814
argument_list|,
name|iso9660
operator|->
name|birth_time
argument_list|)
expr_stmt|;
comment|/* Volume Modification Date and Time */
name|set_date_time
argument_list|(
name|bp
operator|+
literal|831
argument_list|,
name|iso9660
operator|->
name|birth_time
argument_list|)
expr_stmt|;
comment|/* Volume Expiration Date and Time(obsolete) */
name|set_date_time_null
argument_list|(
name|bp
operator|+
literal|848
argument_list|)
expr_stmt|;
comment|/* Volume Effective Date and Time */
name|set_date_time
argument_list|(
name|bp
operator|+
literal|865
argument_list|,
name|iso9660
operator|->
name|birth_time
argument_list|)
expr_stmt|;
comment|/* File Structure Version */
name|bp
index|[
literal|882
index|]
operator|=
name|fst_ver
expr_stmt|;
comment|/* Reserved */
name|bp
index|[
literal|883
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Application Use */
name|memset
argument_list|(
name|bp
operator|+
literal|884
argument_list|,
literal|0x20
argument_list|,
literal|1395
operator|-
literal|884
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Reserved */
name|set_unused_field_bp
argument_list|(
name|bp
argument_list|,
literal|1396
argument_list|,
name|LOGICAL_BLOCK_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
name|wb_consume
argument_list|(
name|a
argument_list|,
name|LOGICAL_BLOCK_SIZE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write Boot Record Volume Descriptor  */
end_comment

begin_function
specifier|static
name|int
name|write_VD_boot_record
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bp
decl_stmt|;
name|iso9660
operator|=
name|a
operator|->
name|format_data
expr_stmt|;
name|bp
operator|=
name|wb_buffptr
argument_list|(
name|a
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Volume Descriptor Type */
name|set_VD_bp
argument_list|(
name|bp
argument_list|,
name|VDT_BOOT_RECORD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Boot System Identifier */
name|memcpy
argument_list|(
name|bp
operator|+
literal|8
argument_list|,
literal|"EL TORITO SPECIFICATION"
argument_list|,
literal|23
argument_list|)
expr_stmt|;
name|set_unused_field_bp
argument_list|(
name|bp
argument_list|,
literal|8
operator|+
literal|23
argument_list|,
literal|39
argument_list|)
expr_stmt|;
comment|/* Unused */
name|set_unused_field_bp
argument_list|(
name|bp
argument_list|,
literal|40
argument_list|,
literal|71
argument_list|)
expr_stmt|;
comment|/* Absolute pointer to first sector of Boot Catalog */
name|set_num_731
argument_list|(
name|bp
operator|+
literal|72
argument_list|,
name|iso9660
operator|->
name|el_torito
operator|.
name|catalog
operator|->
name|file
operator|->
name|content
operator|.
name|location
argument_list|)
expr_stmt|;
comment|/* Unused */
name|set_unused_field_bp
argument_list|(
name|bp
argument_list|,
literal|76
argument_list|,
name|LOGICAL_BLOCK_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
name|wb_consume
argument_list|(
name|a
argument_list|,
name|LOGICAL_BLOCK_SIZE
argument_list|)
operator|)
return|;
block|}
end_function

begin_enum
enum|enum
name|keytype
block|{
name|KEY_FLG
block|,
name|KEY_STR
block|,
name|KEY_INT
block|,
name|KEY_HEX
block|, }
enum|;
end_enum

begin_function
specifier|static
name|void
name|set_option_info
parameter_list|(
name|struct
name|archive_string
modifier|*
name|info
parameter_list|,
name|int
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|enum
name|keytype
name|type
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|char
name|prefix
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|d
decl_stmt|;
name|prefix
operator|=
operator|(
operator|*
name|opt
operator|==
literal|0
operator|)
condition|?
literal|' '
else|:
literal|','
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|KEY_FLG
case|:
name|d
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|archive_string_sprintf
argument_list|(
name|info
argument_list|,
literal|"%c%s%s"
argument_list|,
name|prefix
argument_list|,
operator|(
name|d
operator|==
literal|0
operator|)
condition|?
literal|"!"
else|:
literal|""
argument_list|,
name|key
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_STR
case|:
name|s
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|archive_string_sprintf
argument_list|(
name|info
argument_list|,
literal|"%c%s=%s"
argument_list|,
name|prefix
argument_list|,
name|key
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_INT
case|:
name|d
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|archive_string_sprintf
argument_list|(
name|info
argument_list|,
literal|"%c%s=%d"
argument_list|,
name|prefix
argument_list|,
name|key
argument_list|,
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_HEX
case|:
name|d
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|archive_string_sprintf
argument_list|(
name|info
argument_list|,
literal|"%c%s=%x"
argument_list|,
name|prefix
argument_list|,
name|key
argument_list|,
name|d
argument_list|)
expr_stmt|;
break|break;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
operator|*
name|opt
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make Non-ISO File System Information  */
end_comment

begin_function
specifier|static
name|int
name|write_information_block
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|v
decl_stmt|;
name|int
name|opt
decl_stmt|,
name|r
decl_stmt|;
name|struct
name|archive_string
name|info
decl_stmt|;
name|size_t
name|info_size
init|=
name|LOGICAL_BLOCK_SIZE
operator|*
name|NON_ISO_FILE_SYSTEM_INFORMATION_BLOCK
decl_stmt|;
name|iso9660
operator|=
operator|(
expr|struct
name|iso9660
operator|*
operator|)
name|a
operator|->
name|format_data
expr_stmt|;
if|if
condition|(
name|info_size
operator|>
name|wb_remaining
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|r
operator|=
name|wb_write_out
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
name|archive_string_init
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_string_ensure
argument_list|(
operator|&
name|info
argument_list|,
name|info_size
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|memset
argument_list|(
name|info
operator|.
name|s
argument_list|,
literal|0
argument_list|,
name|info_size
argument_list|)
expr_stmt|;
name|opt
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE__CTIME64_S
argument_list|)
name|_ctime64_s
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|birth_time
operator|)
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_CTIME_R
argument_list|)
name|ctime_r
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|birth_time
operator|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|#
directive|else
name|strncpy
argument_list|(
name|buf
argument_list|,
name|ctime
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|birth_time
operator|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
name|archive_string_sprintf
argument_list|(
operator|&
name|info
argument_list|,
literal|"INFO %s%s"
argument_list|,
name|buf
argument_list|,
name|archive_version_string
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|abstract_file
operator|!=
name|OPT_ABSTRACT_FILE_DEFAULT
condition|)
name|set_option_info
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|opt
argument_list|,
literal|"abstract-file"
argument_list|,
name|KEY_STR
argument_list|,
name|iso9660
operator|->
name|abstract_file_identifier
operator|.
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|application_id
operator|!=
name|OPT_APPLICATION_ID_DEFAULT
condition|)
name|set_option_info
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|opt
argument_list|,
literal|"application-id"
argument_list|,
name|KEY_STR
argument_list|,
name|iso9660
operator|->
name|application_identifier
operator|.
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|allow_vernum
operator|!=
name|OPT_ALLOW_VERNUM_DEFAULT
condition|)
name|set_option_info
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|opt
argument_list|,
literal|"allow-vernum"
argument_list|,
name|KEY_FLG
argument_list|,
name|iso9660
operator|->
name|opt
operator|.
name|allow_vernum
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|biblio_file
operator|!=
name|OPT_BIBLIO_FILE_DEFAULT
condition|)
name|set_option_info
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|opt
argument_list|,
literal|"biblio-file"
argument_list|,
name|KEY_STR
argument_list|,
name|iso9660
operator|->
name|bibliographic_file_identifier
operator|.
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|boot
operator|!=
name|OPT_BOOT_DEFAULT
condition|)
name|set_option_info
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|opt
argument_list|,
literal|"boot"
argument_list|,
name|KEY_STR
argument_list|,
name|iso9660
operator|->
name|el_torito
operator|.
name|boot_filename
operator|.
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|boot_catalog
operator|!=
name|OPT_BOOT_CATALOG_DEFAULT
condition|)
name|set_option_info
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|opt
argument_list|,
literal|"boot-catalog"
argument_list|,
name|KEY_STR
argument_list|,
name|iso9660
operator|->
name|el_torito
operator|.
name|catalog_filename
operator|.
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|boot_info_table
operator|!=
name|OPT_BOOT_INFO_TABLE_DEFAULT
condition|)
name|set_option_info
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|opt
argument_list|,
literal|"boot-info-table"
argument_list|,
name|KEY_FLG
argument_list|,
name|iso9660
operator|->
name|opt
operator|.
name|boot_info_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|boot_load_seg
operator|!=
name|OPT_BOOT_LOAD_SEG_DEFAULT
condition|)
name|set_option_info
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|opt
argument_list|,
literal|"boot-load-seg"
argument_list|,
name|KEY_HEX
argument_list|,
name|iso9660
operator|->
name|el_torito
operator|.
name|boot_load_seg
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|boot_load_size
operator|!=
name|OPT_BOOT_LOAD_SIZE_DEFAULT
condition|)
name|set_option_info
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|opt
argument_list|,
literal|"boot-load-size"
argument_list|,
name|KEY_INT
argument_list|,
name|iso9660
operator|->
name|el_torito
operator|.
name|boot_load_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|boot_type
operator|!=
name|OPT_BOOT_TYPE_DEFAULT
condition|)
block|{
name|v
operator|=
literal|"no-emulation"
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|boot_type
operator|==
name|OPT_BOOT_TYPE_FD
condition|)
name|v
operator|=
literal|"fd"
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|boot_type
operator|==
name|OPT_BOOT_TYPE_HARD_DISK
condition|)
name|v
operator|=
literal|"hard-disk"
expr_stmt|;
name|set_option_info
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|opt
argument_list|,
literal|"boot-type"
argument_list|,
name|KEY_STR
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|compression_level
operator|!=
name|OPT_COMPRESSION_LEVEL_DEFAULT
condition|)
name|set_option_info
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|opt
argument_list|,
literal|"compression-level"
argument_list|,
name|KEY_INT
argument_list|,
name|iso9660
operator|->
name|zisofs
operator|.
name|compression_level
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|copyright_file
operator|!=
name|OPT_COPYRIGHT_FILE_DEFAULT
condition|)
name|set_option_info
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|opt
argument_list|,
literal|"copyright-file"
argument_list|,
name|KEY_STR
argument_list|,
name|iso9660
operator|->
name|copyright_file_identifier
operator|.
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|iso_level
operator|!=
name|OPT_ISO_LEVEL_DEFAULT
condition|)
name|set_option_info
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|opt
argument_list|,
literal|"iso-level"
argument_list|,
name|KEY_INT
argument_list|,
name|iso9660
operator|->
name|opt
operator|.
name|iso_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|joliet
operator|!=
name|OPT_JOLIET_DEFAULT
condition|)
block|{
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|joliet
operator|==
name|OPT_JOLIET_LONGNAME
condition|)
name|set_option_info
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|opt
argument_list|,
literal|"joliet"
argument_list|,
name|KEY_STR
argument_list|,
literal|"long"
argument_list|)
expr_stmt|;
else|else
name|set_option_info
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|opt
argument_list|,
literal|"joliet"
argument_list|,
name|KEY_FLG
argument_list|,
name|iso9660
operator|->
name|opt
operator|.
name|joliet
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|limit_depth
operator|!=
name|OPT_LIMIT_DEPTH_DEFAULT
condition|)
name|set_option_info
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|opt
argument_list|,
literal|"limit-depth"
argument_list|,
name|KEY_FLG
argument_list|,
name|iso9660
operator|->
name|opt
operator|.
name|limit_depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|limit_dirs
operator|!=
name|OPT_LIMIT_DIRS_DEFAULT
condition|)
name|set_option_info
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|opt
argument_list|,
literal|"limit-dirs"
argument_list|,
name|KEY_FLG
argument_list|,
name|iso9660
operator|->
name|opt
operator|.
name|limit_dirs
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|pad
operator|!=
name|OPT_PAD_DEFAULT
condition|)
name|set_option_info
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|opt
argument_list|,
literal|"pad"
argument_list|,
name|KEY_FLG
argument_list|,
name|iso9660
operator|->
name|opt
operator|.
name|pad
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|publisher
operator|!=
name|OPT_PUBLISHER_DEFAULT
condition|)
name|set_option_info
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|opt
argument_list|,
literal|"publisher"
argument_list|,
name|KEY_STR
argument_list|,
name|iso9660
operator|->
name|publisher_identifier
operator|.
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|rr
operator|!=
name|OPT_RR_DEFAULT
condition|)
block|{
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|rr
operator|==
name|OPT_RR_DISABLED
condition|)
name|set_option_info
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|opt
argument_list|,
literal|"rockridge"
argument_list|,
name|KEY_FLG
argument_list|,
name|iso9660
operator|->
name|opt
operator|.
name|rr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|rr
operator|==
name|OPT_RR_STRICT
condition|)
name|set_option_info
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|opt
argument_list|,
literal|"rockridge"
argument_list|,
name|KEY_STR
argument_list|,
literal|"strict"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|rr
operator|==
name|OPT_RR_USEFUL
condition|)
name|set_option_info
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|opt
argument_list|,
literal|"rockridge"
argument_list|,
name|KEY_STR
argument_list|,
literal|"useful"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|volume_id
operator|!=
name|OPT_VOLUME_ID_DEFAULT
condition|)
name|set_option_info
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|opt
argument_list|,
literal|"volume-id"
argument_list|,
name|KEY_STR
argument_list|,
name|iso9660
operator|->
name|volume_identifier
operator|.
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|zisofs
operator|!=
name|OPT_ZISOFS_DEFAULT
condition|)
name|set_option_info
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|opt
argument_list|,
literal|"zisofs"
argument_list|,
name|KEY_FLG
argument_list|,
name|iso9660
operator|->
name|opt
operator|.
name|zisofs
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|wb_buffptr
argument_list|(
name|a
argument_list|)
argument_list|,
name|info
operator|.
name|s
argument_list|,
name|info_size
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
return|return
operator|(
name|wb_consume
argument_list|(
name|a
argument_list|,
name|info_size
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|write_rr_ER
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|wb_buffptr
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|LOGICAL_BLOCK_SIZE
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
literal|'E'
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|'R'
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
literal|0x01
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
name|RRIP_ER_SIZE
expr_stmt|;
name|p
index|[
literal|4
index|]
operator|=
name|RRIP_ER_ID_SIZE
expr_stmt|;
name|p
index|[
literal|5
index|]
operator|=
name|RRIP_ER_DSC_SIZE
expr_stmt|;
name|p
index|[
literal|6
index|]
operator|=
name|RRIP_ER_SRC_SIZE
expr_stmt|;
name|p
index|[
literal|7
index|]
operator|=
literal|0x01
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p
index|[
literal|8
index|]
argument_list|,
name|rrip_identifier
argument_list|,
name|p
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p
index|[
literal|8
operator|+
name|p
index|[
literal|4
index|]
index|]
argument_list|,
name|rrip_descriptor
argument_list|,
name|p
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p
index|[
literal|8
operator|+
name|p
index|[
literal|4
index|]
operator|+
name|p
index|[
literal|5
index|]
index|]
argument_list|,
name|rrip_source
argument_list|,
name|p
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|wb_consume
argument_list|(
name|a
argument_list|,
name|LOGICAL_BLOCK_SIZE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|calculate_path_table_size
parameter_list|(
name|struct
name|vdd
modifier|*
name|vdd
parameter_list|)
block|{
name|int
name|depth
decl_stmt|,
name|size
decl_stmt|;
name|struct
name|path_table
modifier|*
name|pt
decl_stmt|;
name|pt
operator|=
name|vdd
operator|->
name|pathtbl
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|depth
operator|=
literal|0
init|;
name|depth
operator|<
name|vdd
operator|->
name|max_depth
condition|;
name|depth
operator|++
control|)
block|{
name|struct
name|isoent
modifier|*
modifier|*
name|ptbl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cnt
decl_stmt|;
if|if
condition|(
operator|(
name|cnt
operator|=
name|pt
index|[
name|depth
index|]
operator|.
name|cnt
operator|)
operator|==
literal|0
condition|)
break|break;
name|ptbl
operator|=
name|pt
index|[
name|depth
index|]
operator|.
name|sorted
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
name|ptbl
index|[
name|i
index|]
operator|->
name|identifier
operator|==
name|NULL
condition|)
name|len
operator|=
literal|1
expr_stmt|;
comment|/* root directory */
else|else
name|len
operator|=
name|ptbl
index|[
name|i
index|]
operator|->
name|id_len
expr_stmt|;
if|if
condition|(
name|len
operator|&
literal|0x01
condition|)
name|len
operator|++
expr_stmt|;
comment|/* Padding Field */
name|size
operator|+=
literal|8
operator|+
name|len
expr_stmt|;
block|}
block|}
name|vdd
operator|->
name|path_table_size
operator|=
name|size
expr_stmt|;
name|vdd
operator|->
name|path_table_block
operator|=
operator|(
operator|(
name|size
operator|+
name|PATH_TABLE_BLOCK_SIZE
operator|-
literal|1
operator|)
operator|/
name|PATH_TABLE_BLOCK_SIZE
operator|)
operator|*
operator|(
name|PATH_TABLE_BLOCK_SIZE
operator|/
name|LOGICAL_BLOCK_SIZE
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|_write_path_table
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|int
name|type_m
parameter_list|,
name|int
name|depth
parameter_list|,
name|struct
name|vdd
modifier|*
name|vdd
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|wb
decl_stmt|;
name|struct
name|isoent
modifier|*
modifier|*
name|ptbl
decl_stmt|;
name|size_t
name|wbremaining
decl_stmt|;
name|int
name|i
decl_stmt|,
name|r
decl_stmt|,
name|wsize
decl_stmt|;
if|if
condition|(
name|vdd
operator|->
name|pathtbl
index|[
name|depth
index|]
operator|.
name|cnt
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|wsize
operator|=
literal|0
expr_stmt|;
name|wb
operator|=
name|wb_buffptr
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|wbremaining
operator|=
name|wb_remaining
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bp
operator|=
name|wb
operator|-
literal|1
expr_stmt|;
name|ptbl
operator|=
name|vdd
operator|->
name|pathtbl
index|[
name|depth
index|]
operator|.
name|sorted
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vdd
operator|->
name|pathtbl
index|[
name|depth
index|]
operator|.
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|isoent
modifier|*
name|np
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|np
operator|=
name|ptbl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|identifier
operator|==
name|NULL
condition|)
name|len
operator|=
literal|1
expr_stmt|;
comment|/* root directory */
else|else
name|len
operator|=
name|np
operator|->
name|id_len
expr_stmt|;
if|if
condition|(
name|wbremaining
operator|-
operator|(
operator|(
name|bp
operator|+
literal|1
operator|)
operator|-
name|wb
operator|)
operator|<
operator|(
name|len
operator|+
literal|1
operator|+
literal|8
operator|)
condition|)
block|{
name|r
operator|=
name|wb_consume
argument_list|(
name|a
argument_list|,
operator|(
name|bp
operator|+
literal|1
operator|)
operator|-
name|wb
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|wb
operator|=
name|wb_buffptr
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|wbremaining
operator|=
name|wb_remaining
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bp
operator|=
name|wb
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Length of Directory Identifier */
name|set_num_711
argument_list|(
name|bp
operator|+
literal|1
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|len
argument_list|)
expr_stmt|;
comment|/* Extended Attribute Record Length */
name|set_num_711
argument_list|(
name|bp
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Location of Extent */
if|if
condition|(
name|type_m
condition|)
name|set_num_732
argument_list|(
name|bp
operator|+
literal|3
argument_list|,
name|np
operator|->
name|dir_location
argument_list|)
expr_stmt|;
else|else
name|set_num_731
argument_list|(
name|bp
operator|+
literal|3
argument_list|,
name|np
operator|->
name|dir_location
argument_list|)
expr_stmt|;
comment|/* Parent Directory Number */
if|if
condition|(
name|type_m
condition|)
name|set_num_722
argument_list|(
name|bp
operator|+
literal|7
argument_list|,
name|np
operator|->
name|parent
operator|->
name|dir_number
argument_list|)
expr_stmt|;
else|else
name|set_num_721
argument_list|(
name|bp
operator|+
literal|7
argument_list|,
name|np
operator|->
name|parent
operator|->
name|dir_number
argument_list|)
expr_stmt|;
comment|/* Directory Identifier */
if|if
condition|(
name|np
operator|->
name|identifier
operator|==
name|NULL
condition|)
name|bp
index|[
literal|9
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|memcpy
argument_list|(
operator|&
name|bp
index|[
literal|9
index|]
argument_list|,
name|np
operator|->
name|identifier
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|&
literal|0x01
condition|)
block|{
comment|/* Padding Field */
name|bp
index|[
literal|9
operator|+
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
name|wsize
operator|+=
literal|8
operator|+
operator|(
name|int
operator|)
name|len
expr_stmt|;
name|bp
operator|+=
literal|8
operator|+
name|len
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bp
operator|+
literal|1
operator|)
operator|>
name|wb
condition|)
block|{
name|r
operator|=
name|wb_consume
argument_list|(
name|a
argument_list|,
operator|(
name|bp
operator|+
literal|1
operator|)
operator|-
name|wb
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
return|return
operator|(
name|wsize
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|write_path_table
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|int
name|type_m
parameter_list|,
name|struct
name|vdd
modifier|*
name|vdd
parameter_list|)
block|{
name|int
name|depth
decl_stmt|,
name|r
decl_stmt|;
name|size_t
name|path_table_size
decl_stmt|;
name|r
operator|=
name|ARCHIVE_OK
expr_stmt|;
name|path_table_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|depth
operator|=
literal|0
init|;
name|depth
operator|<
name|vdd
operator|->
name|max_depth
condition|;
name|depth
operator|++
control|)
block|{
name|r
operator|=
name|_write_path_table
argument_list|(
name|a
argument_list|,
name|type_m
argument_list|,
name|depth
argument_list|,
name|vdd
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|path_table_size
operator|+=
name|r
expr_stmt|;
block|}
comment|/* Write padding data. */
name|path_table_size
operator|=
name|path_table_size
operator|%
name|PATH_TABLE_BLOCK_SIZE
expr_stmt|;
if|if
condition|(
name|path_table_size
operator|>
literal|0
condition|)
name|r
operator|=
name|write_null
argument_list|(
name|a
argument_list|,
name|PATH_TABLE_BLOCK_SIZE
operator|-
name|path_table_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|calculate_directory_descriptors
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
name|struct
name|vdd
modifier|*
name|vdd
parameter_list|,
name|struct
name|isoent
modifier|*
name|isoent
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|struct
name|isoent
modifier|*
modifier|*
name|enttbl
decl_stmt|;
name|int
name|bs
decl_stmt|,
name|block
decl_stmt|,
name|i
decl_stmt|;
name|block
operator|=
literal|1
expr_stmt|;
name|bs
operator|=
name|get_dir_rec_size
argument_list|(
name|iso9660
argument_list|,
name|isoent
argument_list|,
name|DIR_REC_SELF
argument_list|,
name|vdd
operator|->
name|vdd_type
argument_list|)
expr_stmt|;
name|bs
operator|+=
name|get_dir_rec_size
argument_list|(
name|iso9660
argument_list|,
name|isoent
argument_list|,
name|DIR_REC_PARENT
argument_list|,
name|vdd
operator|->
name|vdd_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|isoent
operator|->
name|children
operator|.
name|cnt
operator|<=
literal|0
operator|||
operator|(
name|vdd
operator|->
name|vdd_type
operator|!=
name|VDD_JOLIET
operator|&&
operator|!
name|iso9660
operator|->
name|opt
operator|.
name|rr
operator|&&
name|depth
operator|+
literal|1
operator|>=
name|vdd
operator|->
name|max_depth
operator|)
condition|)
return|return
operator|(
name|block
operator|)
return|;
name|enttbl
operator|=
name|isoent
operator|->
name|children_sorted
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|isoent
operator|->
name|children
operator|.
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|isoent
modifier|*
name|np
init|=
name|enttbl
index|[
name|i
index|]
decl_stmt|;
name|struct
name|isofile
modifier|*
name|file
decl_stmt|;
name|file
operator|=
name|np
operator|->
name|file
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|hardlink_target
operator|!=
name|NULL
condition|)
name|file
operator|=
name|file
operator|->
name|hardlink_target
expr_stmt|;
name|file
operator|->
name|cur_content
operator|=
operator|&
operator|(
name|file
operator|->
name|content
operator|)
expr_stmt|;
do|do
block|{
name|int
name|dr_l
decl_stmt|;
name|dr_l
operator|=
name|get_dir_rec_size
argument_list|(
name|iso9660
argument_list|,
name|np
argument_list|,
name|DIR_REC_NORMAL
argument_list|,
name|vdd
operator|->
name|vdd_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bs
operator|+
name|dr_l
operator|)
operator|>
name|LOGICAL_BLOCK_SIZE
condition|)
block|{
name|block
operator|++
expr_stmt|;
name|bs
operator|=
name|dr_l
expr_stmt|;
block|}
else|else
name|bs
operator|+=
name|dr_l
expr_stmt|;
name|file
operator|->
name|cur_content
operator|=
name|file
operator|->
name|cur_content
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|file
operator|->
name|cur_content
operator|!=
name|NULL
condition|)
do|;
block|}
return|return
operator|(
name|block
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_write_directory_descriptors
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|vdd
modifier|*
name|vdd
parameter_list|,
name|struct
name|isoent
modifier|*
name|isoent
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|struct
name|isoent
modifier|*
modifier|*
name|enttbl
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|wb
decl_stmt|;
name|int
name|i
decl_stmt|,
name|r
decl_stmt|;
name|int
name|dr_l
decl_stmt|;
name|p
operator|=
name|wb
operator|=
name|wb_buffptr
argument_list|(
name|a
argument_list|)
expr_stmt|;
define|#
directive|define
name|WD_REMAINING
value|(LOGICAL_BLOCK_SIZE - (p - wb))
name|p
operator|+=
name|set_directory_record
argument_list|(
name|p
argument_list|,
name|WD_REMAINING
argument_list|,
name|isoent
argument_list|,
name|iso9660
argument_list|,
name|DIR_REC_SELF
argument_list|,
name|vdd
operator|->
name|vdd_type
argument_list|)
expr_stmt|;
name|p
operator|+=
name|set_directory_record
argument_list|(
name|p
argument_list|,
name|WD_REMAINING
argument_list|,
name|isoent
argument_list|,
name|iso9660
argument_list|,
name|DIR_REC_PARENT
argument_list|,
name|vdd
operator|->
name|vdd_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|isoent
operator|->
name|children
operator|.
name|cnt
operator|<=
literal|0
operator|||
operator|(
name|vdd
operator|->
name|vdd_type
operator|!=
name|VDD_JOLIET
operator|&&
operator|!
name|iso9660
operator|->
name|opt
operator|.
name|rr
operator|&&
name|depth
operator|+
literal|1
operator|>=
name|vdd
operator|->
name|max_depth
operator|)
condition|)
block|{
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|WD_REMAINING
argument_list|)
expr_stmt|;
return|return
operator|(
name|wb_consume
argument_list|(
name|a
argument_list|,
name|LOGICAL_BLOCK_SIZE
argument_list|)
operator|)
return|;
block|}
name|enttbl
operator|=
name|isoent
operator|->
name|children_sorted
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|isoent
operator|->
name|children
operator|.
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|isoent
modifier|*
name|np
init|=
name|enttbl
index|[
name|i
index|]
decl_stmt|;
name|struct
name|isofile
modifier|*
name|file
init|=
name|np
operator|->
name|file
decl_stmt|;
if|if
condition|(
name|file
operator|->
name|hardlink_target
operator|!=
name|NULL
condition|)
name|file
operator|=
name|file
operator|->
name|hardlink_target
expr_stmt|;
name|file
operator|->
name|cur_content
operator|=
operator|&
operator|(
name|file
operator|->
name|content
operator|)
expr_stmt|;
do|do
block|{
name|dr_l
operator|=
name|set_directory_record
argument_list|(
name|p
argument_list|,
name|WD_REMAINING
argument_list|,
name|np
argument_list|,
name|iso9660
argument_list|,
name|DIR_REC_NORMAL
argument_list|,
name|vdd
operator|->
name|vdd_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|dr_l
operator|==
literal|0
condition|)
block|{
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|WD_REMAINING
argument_list|)
expr_stmt|;
name|r
operator|=
name|wb_consume
argument_list|(
name|a
argument_list|,
name|LOGICAL_BLOCK_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|p
operator|=
name|wb
operator|=
name|wb_buffptr
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|dr_l
operator|=
name|set_directory_record
argument_list|(
name|p
argument_list|,
name|WD_REMAINING
argument_list|,
name|np
argument_list|,
name|iso9660
argument_list|,
name|DIR_REC_NORMAL
argument_list|,
name|vdd
operator|->
name|vdd_type
argument_list|)
expr_stmt|;
block|}
name|p
operator|+=
name|dr_l
expr_stmt|;
name|file
operator|->
name|cur_content
operator|=
name|file
operator|->
name|cur_content
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|file
operator|->
name|cur_content
operator|!=
name|NULL
condition|)
do|;
block|}
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|WD_REMAINING
argument_list|)
expr_stmt|;
return|return
operator|(
name|wb_consume
argument_list|(
name|a
argument_list|,
name|LOGICAL_BLOCK_SIZE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|write_directory_descriptors
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|vdd
modifier|*
name|vdd
parameter_list|)
block|{
name|struct
name|isoent
modifier|*
name|np
decl_stmt|;
name|int
name|depth
decl_stmt|,
name|r
decl_stmt|;
name|depth
operator|=
literal|0
expr_stmt|;
name|np
operator|=
name|vdd
operator|->
name|rootent
expr_stmt|;
do|do
block|{
name|struct
name|extr_rec
modifier|*
name|extr
decl_stmt|;
name|r
operator|=
name|_write_directory_descriptors
argument_list|(
name|a
argument_list|,
name|vdd
argument_list|,
name|np
argument_list|,
name|depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
if|if
condition|(
name|vdd
operator|->
name|vdd_type
operator|!=
name|VDD_JOLIET
condition|)
block|{
comment|/* 			 * This extract record is used by SUSP,RRIP. 			 * Not for joliet. 			 */
for|for
control|(
name|extr
operator|=
name|np
operator|->
name|extr_rec_list
operator|.
name|first
init|;
name|extr
operator|!=
name|NULL
condition|;
name|extr
operator|=
name|extr
operator|->
name|next
control|)
block|{
name|unsigned
name|char
modifier|*
name|wb
decl_stmt|;
name|wb
operator|=
name|wb_buffptr
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|wb
argument_list|,
name|extr
operator|->
name|buf
argument_list|,
name|extr
operator|->
name|offset
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|wb
operator|+
name|extr
operator|->
name|offset
argument_list|,
literal|0
argument_list|,
name|LOGICAL_BLOCK_SIZE
operator|-
name|extr
operator|->
name|offset
argument_list|)
expr_stmt|;
name|r
operator|=
name|wb_consume
argument_list|(
name|a
argument_list|,
name|LOGICAL_BLOCK_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
block|}
if|if
condition|(
name|np
operator|->
name|subdirs
operator|.
name|first
operator|!=
name|NULL
operator|&&
name|depth
operator|+
literal|1
operator|<
name|vdd
operator|->
name|max_depth
condition|)
block|{
comment|/* Enter to sub directories. */
name|np
operator|=
name|np
operator|->
name|subdirs
operator|.
name|first
expr_stmt|;
name|depth
operator|++
expr_stmt|;
continue|continue;
block|}
while|while
condition|(
name|np
operator|!=
name|np
operator|->
name|parent
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|drnext
operator|==
name|NULL
condition|)
block|{
comment|/* Return to the parent directory. */
name|np
operator|=
name|np
operator|->
name|parent
expr_stmt|;
name|depth
operator|--
expr_stmt|;
block|}
else|else
block|{
name|np
operator|=
name|np
operator|->
name|drnext
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|np
operator|!=
name|np
operator|->
name|parent
condition|)
do|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read file contents from the temporary file, and write it.  */
end_comment

begin_function
specifier|static
name|int
name|write_file_contents
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|int64_t
name|offset
parameter_list|,
name|int64_t
name|size
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|int
name|r
decl_stmt|;
name|lseek
argument_list|(
name|iso9660
operator|->
name|temp_fd
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
condition|)
block|{
name|size_t
name|rsize
decl_stmt|;
name|ssize_t
name|rs
decl_stmt|;
name|unsigned
name|char
modifier|*
name|wb
decl_stmt|;
name|wb
operator|=
name|wb_buffptr
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|wb_remaining
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsize
operator|>
operator|(
name|size_t
operator|)
name|size
condition|)
name|rsize
operator|=
operator|(
name|size_t
operator|)
name|size
expr_stmt|;
name|rs
operator|=
name|read
argument_list|(
name|iso9660
operator|->
name|temp_fd
argument_list|,
name|wb
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|<=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Can't read temporary file(%jd)"
argument_list|,
operator|(
name|intmax_t
operator|)
name|rs
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|size
operator|-=
name|rs
expr_stmt|;
name|r
operator|=
name|wb_consume
argument_list|(
name|a
argument_list|,
name|rs
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|write_file_descriptors
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|struct
name|isofile
modifier|*
name|file
decl_stmt|;
name|int64_t
name|blocks
decl_stmt|,
name|offset
decl_stmt|;
name|int
name|r
decl_stmt|;
name|blocks
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* Make the boot catalog contents, and write it. */
if|if
condition|(
name|iso9660
operator|->
name|el_torito
operator|.
name|catalog
operator|!=
name|NULL
condition|)
block|{
name|r
operator|=
name|make_boot_catalog
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
comment|/* Write the boot file contents. */
if|if
condition|(
name|iso9660
operator|->
name|el_torito
operator|.
name|boot
operator|!=
name|NULL
condition|)
block|{
name|file
operator|=
name|iso9660
operator|->
name|el_torito
operator|.
name|boot
operator|->
name|file
expr_stmt|;
name|blocks
operator|=
name|file
operator|->
name|content
operator|.
name|blocks
expr_stmt|;
name|offset
operator|=
name|file
operator|->
name|content
operator|.
name|offset_of_temp
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|r
operator|=
name|write_file_contents
argument_list|(
name|a
argument_list|,
name|offset
argument_list|,
name|blocks
operator|<<
name|LOGICAL_BLOCK_BITS
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|blocks
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Write out all file contents. */
for|for
control|(
name|file
operator|=
name|iso9660
operator|->
name|data_file_list
operator|.
name|first
init|;
name|file
operator|!=
name|NULL
condition|;
name|file
operator|=
name|file
operator|->
name|datanext
control|)
block|{
if|if
condition|(
operator|!
name|file
operator|->
name|write_content
condition|)
continue|continue;
if|if
condition|(
operator|(
name|offset
operator|+
operator|(
name|blocks
operator|<<
name|LOGICAL_BLOCK_BITS
operator|)
operator|)
operator|<
name|file
operator|->
name|content
operator|.
name|offset_of_temp
condition|)
block|{
if|if
condition|(
name|blocks
operator|>
literal|0
condition|)
block|{
name|r
operator|=
name|write_file_contents
argument_list|(
name|a
argument_list|,
name|offset
argument_list|,
name|blocks
operator|<<
name|LOGICAL_BLOCK_BITS
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
name|blocks
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
name|file
operator|->
name|content
operator|.
name|offset_of_temp
expr_stmt|;
block|}
name|file
operator|->
name|cur_content
operator|=
operator|&
operator|(
name|file
operator|->
name|content
operator|)
expr_stmt|;
do|do
block|{
name|blocks
operator|+=
name|file
operator|->
name|cur_content
operator|->
name|blocks
expr_stmt|;
comment|/* Next fragument */
name|file
operator|->
name|cur_content
operator|=
name|file
operator|->
name|cur_content
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|file
operator|->
name|cur_content
operator|!=
name|NULL
condition|)
do|;
block|}
comment|/* Flush out remaining blocks. */
if|if
condition|(
name|blocks
operator|>
literal|0
condition|)
block|{
name|r
operator|=
name|write_file_contents
argument_list|(
name|a
argument_list|,
name|offset
argument_list|,
name|blocks
operator|<<
name|LOGICAL_BLOCK_BITS
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|isofile_init_entry_list
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|)
block|{
name|iso9660
operator|->
name|all_file_list
operator|.
name|first
operator|=
name|NULL
expr_stmt|;
name|iso9660
operator|->
name|all_file_list
operator|.
name|last
operator|=
operator|&
operator|(
name|iso9660
operator|->
name|all_file_list
operator|.
name|first
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|isofile_add_entry
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
name|struct
name|isofile
modifier|*
name|file
parameter_list|)
block|{
name|file
operator|->
name|allnext
operator|=
name|NULL
expr_stmt|;
operator|*
name|iso9660
operator|->
name|all_file_list
operator|.
name|last
operator|=
name|file
expr_stmt|;
name|iso9660
operator|->
name|all_file_list
operator|.
name|last
operator|=
operator|&
operator|(
name|file
operator|->
name|allnext
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|isofile_free_all_entries
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|)
block|{
name|struct
name|isofile
modifier|*
name|file
decl_stmt|,
modifier|*
name|file_next
decl_stmt|;
name|file
operator|=
name|iso9660
operator|->
name|all_file_list
operator|.
name|first
expr_stmt|;
while|while
condition|(
name|file
operator|!=
name|NULL
condition|)
block|{
name|file_next
operator|=
name|file
operator|->
name|allnext
expr_stmt|;
name|isofile_free
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|file
operator|=
name|file_next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|isofile_init_entry_data_file_list
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|)
block|{
name|iso9660
operator|->
name|data_file_list
operator|.
name|first
operator|=
name|NULL
expr_stmt|;
name|iso9660
operator|->
name|data_file_list
operator|.
name|last
operator|=
operator|&
operator|(
name|iso9660
operator|->
name|data_file_list
operator|.
name|first
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|isofile_add_data_file
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
name|struct
name|isofile
modifier|*
name|file
parameter_list|)
block|{
name|file
operator|->
name|datanext
operator|=
name|NULL
expr_stmt|;
operator|*
name|iso9660
operator|->
name|data_file_list
operator|.
name|last
operator|=
name|file
expr_stmt|;
name|iso9660
operator|->
name|data_file_list
operator|.
name|last
operator|=
operator|&
operator|(
name|file
operator|->
name|datanext
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|isofile
modifier|*
name|isofile_new
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|isofile
modifier|*
name|file
decl_stmt|;
name|file
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|file
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
name|file
operator|->
name|entry
operator|=
name|archive_entry_clone
argument_list|(
name|entry
argument_list|)
expr_stmt|;
else|else
name|file
operator|->
name|entry
operator|=
name|archive_entry_new2
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|entry
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|archive_string_init
argument_list|(
operator|&
operator|(
name|file
operator|->
name|parentdir
operator|)
argument_list|)
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
operator|(
name|file
operator|->
name|basename
operator|)
argument_list|)
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
operator|(
name|file
operator|->
name|basename_utf16
operator|)
argument_list|)
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
operator|(
name|file
operator|->
name|symlink
operator|)
argument_list|)
expr_stmt|;
name|file
operator|->
name|cur_content
operator|=
operator|&
operator|(
name|file
operator|->
name|content
operator|)
expr_stmt|;
return|return
operator|(
name|file
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|isofile_free
parameter_list|(
name|struct
name|isofile
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|content
modifier|*
name|con
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|con
operator|=
name|file
operator|->
name|content
operator|.
name|next
expr_stmt|;
while|while
condition|(
name|con
operator|!=
name|NULL
condition|)
block|{
name|tmp
operator|=
name|con
expr_stmt|;
name|con
operator|=
name|con
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
name|archive_entry_free
argument_list|(
name|file
operator|->
name|entry
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|file
operator|->
name|parentdir
operator|)
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|file
operator|->
name|basename
operator|)
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|file
operator|->
name|basename_utf16
operator|)
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|file
operator|->
name|symlink
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_function
specifier|static
name|int
name|cleanup_backslash_1
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
name|int
name|mb
decl_stmt|,
name|dos
decl_stmt|;
name|mb
operator|=
name|dos
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
operator|>
literal|127
condition|)
name|mb
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
comment|/* If we have not met any multi-byte characters, 			 * we can replace '\' with '/'. */
if|if
condition|(
operator|!
name|mb
condition|)
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
name|dos
operator|=
literal|1
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mb
operator|||
operator|!
name|dos
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cleanup_backslash_2
parameter_list|(
name|wchar_t
modifier|*
name|p
parameter_list|)
block|{
comment|/* Convert a path-separator from '\' to  '/' */
while|while
condition|(
operator|*
name|p
operator|!=
literal|L'
expr|\0'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|L'
expr|\\'
condition|)
operator|*
name|p
operator|=
literal|L'
expr|/'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Generate a parent directory name and a base name from a pathname.  */
end_comment

begin_function
specifier|static
name|int
name|isofile_gen_utility_names
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|isofile
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
decl_stmt|;
specifier|const
name|char
modifier|*
name|pathname
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|dirname
decl_stmt|,
modifier|*
name|slash
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|ret
init|=
name|ARCHIVE_OK
decl_stmt|;
name|iso9660
operator|=
name|a
operator|->
name|format_data
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|file
operator|->
name|parentdir
operator|)
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|file
operator|->
name|basename
operator|)
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|file
operator|->
name|basename_utf16
operator|)
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|file
operator|->
name|symlink
operator|)
argument_list|)
expr_stmt|;
name|pathname
operator|=
name|archive_entry_pathname
argument_list|(
name|file
operator|->
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|pathname
operator|==
name|NULL
operator|||
name|pathname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* virtual root */
name|file
operator|->
name|dircnt
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* 	 * Make a UTF-16BE basename if Joliet extension enabled. 	 */
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|joliet
condition|)
block|{
specifier|const
name|char
modifier|*
name|u16
decl_stmt|,
modifier|*
name|ulast
decl_stmt|;
name|size_t
name|u16len
decl_stmt|,
name|ulen_last
decl_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|sconv_to_utf16be
operator|==
name|NULL
condition|)
block|{
name|iso9660
operator|->
name|sconv_to_utf16be
operator|=
name|archive_string_conversion_to_charset
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
literal|"UTF-16BE"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|sconv_to_utf16be
operator|==
name|NULL
condition|)
comment|/* Couldn't allocate memory */
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|iso9660
operator|->
name|sconv_from_utf16be
operator|=
name|archive_string_conversion_from_charset
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
literal|"UTF-16BE"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|sconv_from_utf16be
operator|==
name|NULL
condition|)
comment|/* Couldn't allocate memory */
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* 		 * Converte a filename to UTF-16BE. 		 */
if|if
condition|(
literal|0
operator|>
name|archive_entry_pathname_l
argument_list|(
name|file
operator|->
name|entry
argument_list|,
operator|&
name|u16
argument_list|,
operator|&
name|u16len
argument_list|,
name|iso9660
operator|->
name|sconv_to_utf16be
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for UTF-16BE"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"A filename cannot be converted to UTF-16BE;"
literal|"You should disable making Joliet extension"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
comment|/* 		 * Make sure a path separator is not in the last; 		 * Remove trailing '/'. 		 */
while|while
condition|(
name|u16len
operator|>=
literal|2
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
if|if
condition|(
name|u16
index|[
name|u16len
operator|-
literal|2
index|]
operator|==
literal|0
operator|&&
operator|(
name|u16
index|[
name|u16len
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|||
name|u16
index|[
name|u16len
operator|-
literal|1
index|]
operator|==
literal|'\\'
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|u16
index|[
name|u16len
operator|-
literal|2
index|]
operator|==
literal|0
operator|&&
name|u16
index|[
name|u16len
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
endif|#
directive|endif
block|{
name|u16len
operator|-=
literal|2
expr_stmt|;
block|}
else|else
break|break;
block|}
comment|/* 		 * Find a basename in UTF-16BE. 		 */
name|ulast
operator|=
name|u16
expr_stmt|;
name|u16len
operator|>>=
literal|1
expr_stmt|;
name|ulen_last
operator|=
name|u16len
expr_stmt|;
while|while
condition|(
name|u16len
operator|>
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
if|if
condition|(
name|u16
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
operator|(
name|u16
index|[
literal|1
index|]
operator|==
literal|'/'
operator|||
name|u16
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|u16
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|u16
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
endif|#
directive|endif
block|{
name|ulast
operator|=
name|u16
operator|+
literal|2
expr_stmt|;
name|ulen_last
operator|=
name|u16len
operator|-
literal|1
expr_stmt|;
block|}
name|u16
operator|+=
literal|2
expr_stmt|;
name|u16len
operator|--
expr_stmt|;
block|}
name|ulen_last
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|archive_string_ensure
argument_list|(
operator|&
operator|(
name|file
operator|->
name|basename_utf16
operator|)
argument_list|,
name|ulen_last
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for UTF-16BE"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* 		 * Set UTF-16BE basename. 		 */
name|memcpy
argument_list|(
name|file
operator|->
name|basename_utf16
operator|.
name|s
argument_list|,
name|ulast
argument_list|,
name|ulen_last
argument_list|)
expr_stmt|;
name|file
operator|->
name|basename_utf16
operator|.
name|length
operator|=
name|ulen_last
expr_stmt|;
block|}
name|archive_strcpy
argument_list|(
operator|&
operator|(
name|file
operator|->
name|parentdir
operator|)
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
comment|/* 	 * Convert a path-separator from '\' to  '/' 	 */
if|if
condition|(
name|cleanup_backslash_1
argument_list|(
name|file
operator|->
name|parentdir
operator|.
name|s
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|const
name|wchar_t
modifier|*
name|wp
init|=
name|archive_entry_pathname_w
argument_list|(
name|file
operator|->
name|entry
argument_list|)
decl_stmt|;
name|struct
name|archive_wstring
name|ws
decl_stmt|;
if|if
condition|(
name|wp
operator|!=
name|NULL
condition|)
block|{
name|int
name|r
decl_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|ws
argument_list|)
expr_stmt|;
name|archive_wstrcpy
argument_list|(
operator|&
name|ws
argument_list|,
name|wp
argument_list|)
expr_stmt|;
name|cleanup_backslash_2
argument_list|(
name|ws
operator|.
name|s
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|file
operator|->
name|parentdir
operator|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|archive_string_append_from_wcs
argument_list|(
operator|&
operator|(
name|file
operator|->
name|parentdir
operator|)
argument_list|,
name|ws
operator|.
name|s
argument_list|,
name|ws
operator|.
name|length
argument_list|)
expr_stmt|;
name|archive_wstring_free
argument_list|(
operator|&
name|ws
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
operator|&&
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
block|}
endif|#
directive|endif
name|len
operator|=
name|file
operator|->
name|parentdir
operator|.
name|length
expr_stmt|;
name|p
operator|=
name|dirname
operator|=
name|file
operator|->
name|parentdir
operator|.
name|s
expr_stmt|;
comment|/* 	 * Remove leading '/', '../' and './' elements 	 */
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
break|break;
elseif|else
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'/'
condition|)
block|{
name|p
operator|+=
literal|3
expr_stmt|;
name|len
operator|-=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
operator|||
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|p
operator|!=
name|dirname
condition|)
block|{
name|memmove
argument_list|(
name|dirname
argument_list|,
name|p
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|dirname
expr_stmt|;
block|}
comment|/* 	 * Remove "/","/." and "/.." elements from tail. 	 */
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|size_t
name|ll
init|=
name|len
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|1
operator|&&
name|p
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'/'
operator|&&
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
name|p
index|[
name|len
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|2
operator|&&
name|p
index|[
name|len
operator|-
literal|3
index|]
operator|==
literal|'/'
operator|&&
name|p
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
name|p
index|[
name|len
operator|-
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|-=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|ll
operator|==
name|len
condition|)
break|break;
block|}
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
comment|/* Convert '//' --> '/' */
name|strcpy
argument_list|(
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'/'
condition|)
comment|/* Convert '/./' --> '/' */
name|strcpy
argument_list|(
name|p
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* Convert 'dir/dir1/../dir2/' 				 *     --> 'dir/dir2/' 				 */
name|char
modifier|*
name|rp
init|=
name|p
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|rp
operator|>=
name|dirname
condition|)
block|{
if|if
condition|(
operator|*
name|rp
operator|==
literal|'/'
condition|)
break|break;
operator|--
name|rp
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|>
name|dirname
condition|)
block|{
name|strcpy
argument_list|(
name|rp
argument_list|,
name|p
operator|+
literal|3
argument_list|)
expr_stmt|;
name|p
operator|=
name|rp
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|dirname
argument_list|,
name|p
operator|+
literal|4
argument_list|)
expr_stmt|;
name|p
operator|=
name|dirname
expr_stmt|;
block|}
block|}
else|else
name|p
operator|++
expr_stmt|;
block|}
else|else
name|p
operator|++
expr_stmt|;
block|}
name|p
operator|=
name|dirname
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_entry_filetype
argument_list|(
name|file
operator|->
name|entry
argument_list|)
operator|==
name|AE_IFLNK
condition|)
block|{
comment|/* Convert symlink name too. */
name|pathname
operator|=
name|archive_entry_symlink
argument_list|(
name|file
operator|->
name|entry
argument_list|)
expr_stmt|;
name|archive_strcpy
argument_list|(
operator|&
operator|(
name|file
operator|->
name|symlink
operator|)
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
comment|/* 		 * Convert a path-separator from '\' to  '/' 		 */
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
operator|(
name|file
operator|->
name|symlink
operator|)
argument_list|)
operator|>
literal|0
operator|&&
name|cleanup_backslash_1
argument_list|(
name|file
operator|->
name|symlink
operator|.
name|s
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|const
name|wchar_t
modifier|*
name|wp
init|=
name|archive_entry_symlink_w
argument_list|(
name|file
operator|->
name|entry
argument_list|)
decl_stmt|;
name|struct
name|archive_wstring
name|ws
decl_stmt|;
if|if
condition|(
name|wp
operator|!=
name|NULL
condition|)
block|{
name|int
name|r
decl_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|ws
argument_list|)
expr_stmt|;
name|archive_wstrcpy
argument_list|(
operator|&
name|ws
argument_list|,
name|wp
argument_list|)
expr_stmt|;
name|cleanup_backslash_2
argument_list|(
name|ws
operator|.
name|s
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|file
operator|->
name|symlink
operator|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|archive_string_append_from_wcs
argument_list|(
operator|&
operator|(
name|file
operator|->
name|symlink
operator|)
argument_list|,
name|ws
operator|.
name|s
argument_list|,
name|ws
operator|.
name|length
argument_list|)
expr_stmt|;
name|archive_wstring_free
argument_list|(
operator|&
name|ws
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
operator|&&
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
block|}
endif|#
directive|endif
block|}
comment|/* 	 * - Count up directory elements. 	 * - Find out the position which points the last position of 	 *   path separator('/'). 	 */
name|slash
operator|=
name|NULL
expr_stmt|;
name|file
operator|->
name|dircnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
block|{
name|slash
operator|=
name|p
expr_stmt|;
name|file
operator|->
name|dircnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|slash
operator|==
name|NULL
condition|)
block|{
comment|/* The pathname doesn't have a parent directory. */
name|file
operator|->
name|parentdir
operator|.
name|length
operator|=
name|len
expr_stmt|;
name|archive_string_copy
argument_list|(
operator|&
operator|(
name|file
operator|->
name|basename
operator|)
argument_list|,
operator|&
operator|(
name|file
operator|->
name|parentdir
operator|)
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|file
operator|->
name|parentdir
operator|)
argument_list|)
expr_stmt|;
operator|*
name|file
operator|->
name|parentdir
operator|.
name|s
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* Make a basename from dirname and slash */
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
name|file
operator|->
name|parentdir
operator|.
name|length
operator|=
name|slash
operator|-
name|dirname
expr_stmt|;
name|archive_strcpy
argument_list|(
operator|&
operator|(
name|file
operator|->
name|basename
operator|)
argument_list|,
name|slash
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_entry_filetype
argument_list|(
name|file
operator|->
name|entry
argument_list|)
operator|==
name|AE_IFDIR
condition|)
name|file
operator|->
name|dircnt
operator|++
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Register a entry to get a hardlink target.  */
end_comment

begin_function
specifier|static
name|int
name|isofile_register_hardlink
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|isofile
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|struct
name|hardlink
modifier|*
name|hl
decl_stmt|;
specifier|const
name|char
modifier|*
name|pathname
decl_stmt|;
name|archive_entry_set_nlink
argument_list|(
name|file
operator|->
name|entry
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pathname
operator|=
name|archive_entry_hardlink
argument_list|(
name|file
operator|->
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|pathname
operator|==
name|NULL
condition|)
block|{
comment|/* This `file` is a hardlink target. */
name|hl
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hl
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|hl
operator|->
name|nlink
operator|=
literal|1
expr_stmt|;
comment|/* A hardlink target must be the first position. */
name|file
operator|->
name|hlnext
operator|=
name|NULL
expr_stmt|;
name|hl
operator|->
name|file_list
operator|.
name|first
operator|=
name|file
expr_stmt|;
name|hl
operator|->
name|file_list
operator|.
name|last
operator|=
operator|&
operator|(
name|file
operator|->
name|hlnext
operator|)
expr_stmt|;
name|__archive_rb_tree_insert_node
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|hardlink_rbtree
operator|)
argument_list|,
operator|(
expr|struct
name|archive_rb_node
operator|*
operator|)
name|hl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hl
operator|=
operator|(
expr|struct
name|hardlink
operator|*
operator|)
name|__archive_rb_tree_find_node
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|hardlink_rbtree
operator|)
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|hl
operator|!=
name|NULL
condition|)
block|{
comment|/* Insert `file` entry into the tail. */
name|file
operator|->
name|hlnext
operator|=
name|NULL
expr_stmt|;
operator|*
name|hl
operator|->
name|file_list
operator|.
name|last
operator|=
name|file
expr_stmt|;
name|hl
operator|->
name|file_list
operator|.
name|last
operator|=
operator|&
operator|(
name|file
operator|->
name|hlnext
operator|)
expr_stmt|;
name|hl
operator|->
name|nlink
operator|++
expr_stmt|;
block|}
name|archive_entry_unset_size
argument_list|(
name|file
operator|->
name|entry
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hardlinked files have to have the same location of extent.  * We have to find out hardlink target entries for the entries  * which have a hardlink target name.  */
end_comment

begin_function
specifier|static
name|void
name|isofile_connect_hardlink_files
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|)
block|{
name|struct
name|archive_rb_node
modifier|*
name|n
decl_stmt|;
name|struct
name|hardlink
modifier|*
name|hl
decl_stmt|;
name|struct
name|isofile
modifier|*
name|target
decl_stmt|,
modifier|*
name|nf
decl_stmt|;
name|ARCHIVE_RB_TREE_FOREACH
argument_list|(
argument|n
argument_list|,
argument|&(iso9660->hardlink_rbtree)
argument_list|)
block|{
name|hl
operator|=
operator|(
expr|struct
name|hardlink
operator|*
operator|)
name|n
expr_stmt|;
comment|/* The first entry must be a hardlink target. */
name|target
operator|=
name|hl
operator|->
name|file_list
operator|.
name|first
expr_stmt|;
name|archive_entry_set_nlink
argument_list|(
name|target
operator|->
name|entry
argument_list|,
name|hl
operator|->
name|nlink
argument_list|)
expr_stmt|;
comment|/* Set a hardlink target to reference entries. */
for|for
control|(
name|nf
operator|=
name|target
operator|->
name|hlnext
init|;
name|nf
operator|!=
name|NULL
condition|;
name|nf
operator|=
name|nf
operator|->
name|hlnext
control|)
block|{
name|nf
operator|->
name|hardlink_target
operator|=
name|target
expr_stmt|;
name|archive_entry_set_nlink
argument_list|(
name|nf
operator|->
name|entry
argument_list|,
name|hl
operator|->
name|nlink
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|isofile_hd_cmp_node
parameter_list|(
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|n1
parameter_list|,
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|n2
parameter_list|)
block|{
specifier|const
name|struct
name|hardlink
modifier|*
name|h1
init|=
operator|(
specifier|const
expr|struct
name|hardlink
operator|*
operator|)
name|n1
decl_stmt|;
specifier|const
name|struct
name|hardlink
modifier|*
name|h2
init|=
operator|(
specifier|const
expr|struct
name|hardlink
operator|*
operator|)
name|n2
decl_stmt|;
return|return
operator|(
name|strcmp
argument_list|(
name|archive_entry_pathname
argument_list|(
name|h1
operator|->
name|file_list
operator|.
name|first
operator|->
name|entry
argument_list|)
argument_list|,
name|archive_entry_pathname
argument_list|(
name|h2
operator|->
name|file_list
operator|.
name|first
operator|->
name|entry
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isofile_hd_cmp_key
parameter_list|(
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|n
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|)
block|{
specifier|const
name|struct
name|hardlink
modifier|*
name|h
init|=
operator|(
specifier|const
expr|struct
name|hardlink
operator|*
operator|)
name|n
decl_stmt|;
return|return
operator|(
name|strcmp
argument_list|(
name|archive_entry_pathname
argument_list|(
name|h
operator|->
name|file_list
operator|.
name|first
operator|->
name|entry
argument_list|)
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|key
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|isofile_init_hardlinks
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|archive_rb_tree_ops
name|rb_ops
init|=
block|{
name|isofile_hd_cmp_node
block|,
name|isofile_hd_cmp_key
block|, 	}
decl_stmt|;
name|__archive_rb_tree_init
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|hardlink_rbtree
operator|)
argument_list|,
operator|&
name|rb_ops
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|isofile_free_hardlinks
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|)
block|{
name|struct
name|archive_rb_node
modifier|*
name|n
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|n
operator|=
name|ARCHIVE_RB_TREE_MIN
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|hardlink_rbtree
operator|)
argument_list|)
init|;
name|n
condition|;
control|)
block|{
name|next
operator|=
name|__archive_rb_tree_iterate
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|hardlink_rbtree
operator|)
argument_list|,
name|n
argument_list|,
name|ARCHIVE_RB_DIR_RIGHT
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|isoent
modifier|*
name|isoent_new
parameter_list|(
name|struct
name|isofile
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|isoent
modifier|*
name|isoent
decl_stmt|;
specifier|static
specifier|const
name|struct
name|archive_rb_tree_ops
name|rb_ops
init|=
block|{
name|isoent_cmp_node
block|,
name|isoent_cmp_key
block|, 	}
decl_stmt|;
name|isoent
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|isoent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isoent
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|isoent
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|isoent
operator|->
name|children
operator|.
name|first
operator|=
name|NULL
expr_stmt|;
name|isoent
operator|->
name|children
operator|.
name|last
operator|=
operator|&
operator|(
name|isoent
operator|->
name|children
operator|.
name|first
operator|)
expr_stmt|;
name|__archive_rb_tree_init
argument_list|(
operator|&
operator|(
name|isoent
operator|->
name|rbtree
operator|)
argument_list|,
operator|&
name|rb_ops
argument_list|)
expr_stmt|;
name|isoent
operator|->
name|subdirs
operator|.
name|first
operator|=
name|NULL
expr_stmt|;
name|isoent
operator|->
name|subdirs
operator|.
name|last
operator|=
operator|&
operator|(
name|isoent
operator|->
name|subdirs
operator|.
name|first
operator|)
expr_stmt|;
name|isoent
operator|->
name|extr_rec_list
operator|.
name|first
operator|=
name|NULL
expr_stmt|;
name|isoent
operator|->
name|extr_rec_list
operator|.
name|last
operator|=
operator|&
operator|(
name|isoent
operator|->
name|extr_rec_list
operator|.
name|first
operator|)
expr_stmt|;
name|isoent
operator|->
name|extr_rec_list
operator|.
name|current
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|archive_entry_filetype
argument_list|(
name|file
operator|->
name|entry
argument_list|)
operator|==
name|AE_IFDIR
condition|)
name|isoent
operator|->
name|dir
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|isoent
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|isoent
modifier|*
name|isoent_clone
parameter_list|(
name|struct
name|isoent
modifier|*
name|src
parameter_list|)
block|{
return|return
operator|(
name|isoent_new
argument_list|(
name|src
operator|->
name|file
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_isoent_free
parameter_list|(
name|struct
name|isoent
modifier|*
name|isoent
parameter_list|)
block|{
name|struct
name|extr_rec
modifier|*
name|er
decl_stmt|,
modifier|*
name|er_next
decl_stmt|;
name|free
argument_list|(
name|isoent
operator|->
name|children_sorted
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|isoent
operator|->
name|identifier
argument_list|)
expr_stmt|;
name|er
operator|=
name|isoent
operator|->
name|extr_rec_list
operator|.
name|first
expr_stmt|;
while|while
condition|(
name|er
operator|!=
name|NULL
condition|)
block|{
name|er_next
operator|=
name|er
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|er
argument_list|)
expr_stmt|;
name|er
operator|=
name|er_next
expr_stmt|;
block|}
name|free
argument_list|(
name|isoent
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|isoent_free_all
parameter_list|(
name|struct
name|isoent
modifier|*
name|isoent
parameter_list|)
block|{
name|struct
name|isoent
modifier|*
name|np
decl_stmt|,
modifier|*
name|np_temp
decl_stmt|;
if|if
condition|(
name|isoent
operator|==
name|NULL
condition|)
return|return;
name|np
operator|=
name|isoent
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|np
operator|->
name|dir
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|children
operator|.
name|first
operator|!=
name|NULL
condition|)
block|{
comment|/* Enter to sub directories. */
name|np
operator|=
name|np
operator|->
name|children
operator|.
name|first
expr_stmt|;
continue|continue;
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|np_temp
operator|=
name|np
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|chnext
operator|==
name|NULL
condition|)
block|{
comment|/* Return to the parent directory. */
name|np
operator|=
name|np
operator|->
name|parent
expr_stmt|;
name|_isoent_free
argument_list|(
name|np_temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|np_temp
condition|)
return|return;
block|}
else|else
block|{
name|np
operator|=
name|np
operator|->
name|chnext
expr_stmt|;
name|_isoent_free
argument_list|(
name|np_temp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|isoent
modifier|*
name|isoent_create_virtual_dir
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|)
block|{
name|struct
name|isofile
modifier|*
name|file
decl_stmt|;
name|struct
name|isoent
modifier|*
name|isoent
decl_stmt|;
name|file
operator|=
name|isofile_new
argument_list|(
name|a
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|archive_entry_set_pathname
argument_list|(
name|file
operator|->
name|entry
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|archive_entry_unset_mtime
argument_list|(
name|file
operator|->
name|entry
argument_list|)
expr_stmt|;
name|archive_entry_unset_atime
argument_list|(
name|file
operator|->
name|entry
argument_list|)
expr_stmt|;
name|archive_entry_unset_ctime
argument_list|(
name|file
operator|->
name|entry
argument_list|)
expr_stmt|;
name|archive_entry_set_uid
argument_list|(
name|file
operator|->
name|entry
argument_list|,
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|archive_entry_set_gid
argument_list|(
name|file
operator|->
name|entry
argument_list|,
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
name|archive_entry_set_mode
argument_list|(
name|file
operator|->
name|entry
argument_list|,
literal|0555
operator||
name|AE_IFDIR
argument_list|)
expr_stmt|;
name|archive_entry_set_nlink
argument_list|(
name|file
operator|->
name|entry
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|isofile_gen_utility_names
argument_list|(
name|a
argument_list|,
name|file
argument_list|)
operator|<
name|ARCHIVE_WARN
condition|)
block|{
name|isofile_free
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|isofile_add_entry
argument_list|(
name|iso9660
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|isoent
operator|=
name|isoent_new
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|isoent
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|isoent
operator|->
name|dir
operator|=
literal|1
expr_stmt|;
name|isoent
operator|->
name|virtual
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|isoent
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isoent_cmp_node
parameter_list|(
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|n1
parameter_list|,
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|n2
parameter_list|)
block|{
specifier|const
name|struct
name|isoent
modifier|*
name|e1
init|=
operator|(
specifier|const
expr|struct
name|isoent
operator|*
operator|)
name|n1
decl_stmt|;
specifier|const
name|struct
name|isoent
modifier|*
name|e2
init|=
operator|(
specifier|const
expr|struct
name|isoent
operator|*
operator|)
name|n2
decl_stmt|;
return|return
operator|(
name|strcmp
argument_list|(
name|e1
operator|->
name|file
operator|->
name|basename
operator|.
name|s
argument_list|,
name|e2
operator|->
name|file
operator|->
name|basename
operator|.
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isoent_cmp_key
parameter_list|(
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|n
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|)
block|{
specifier|const
name|struct
name|isoent
modifier|*
name|e
init|=
operator|(
specifier|const
expr|struct
name|isoent
operator|*
operator|)
name|n
decl_stmt|;
return|return
operator|(
name|strcmp
argument_list|(
name|e
operator|->
name|file
operator|->
name|basename
operator|.
name|s
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|key
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isoent_add_child_head
parameter_list|(
name|struct
name|isoent
modifier|*
name|parent
parameter_list|,
name|struct
name|isoent
modifier|*
name|child
parameter_list|)
block|{
if|if
condition|(
operator|!
name|__archive_rb_tree_insert_node
argument_list|(
operator|&
operator|(
name|parent
operator|->
name|rbtree
operator|)
argument_list|,
operator|(
expr|struct
name|archive_rb_node
operator|*
operator|)
name|child
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|child
operator|->
name|chnext
operator|=
name|parent
operator|->
name|children
operator|.
name|first
operator|)
operator|==
name|NULL
condition|)
name|parent
operator|->
name|children
operator|.
name|last
operator|=
operator|&
operator|(
name|child
operator|->
name|chnext
operator|)
expr_stmt|;
name|parent
operator|->
name|children
operator|.
name|first
operator|=
name|child
expr_stmt|;
name|parent
operator|->
name|children
operator|.
name|cnt
operator|++
expr_stmt|;
name|child
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
comment|/* Add a child to a sub-directory chain */
if|if
condition|(
name|child
operator|->
name|dir
condition|)
block|{
if|if
condition|(
operator|(
name|child
operator|->
name|drnext
operator|=
name|parent
operator|->
name|subdirs
operator|.
name|first
operator|)
operator|==
name|NULL
condition|)
name|parent
operator|->
name|subdirs
operator|.
name|last
operator|=
operator|&
operator|(
name|child
operator|->
name|drnext
operator|)
expr_stmt|;
name|parent
operator|->
name|subdirs
operator|.
name|first
operator|=
name|child
expr_stmt|;
name|parent
operator|->
name|subdirs
operator|.
name|cnt
operator|++
expr_stmt|;
name|child
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
block|}
else|else
name|child
operator|->
name|drnext
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isoent_add_child_tail
parameter_list|(
name|struct
name|isoent
modifier|*
name|parent
parameter_list|,
name|struct
name|isoent
modifier|*
name|child
parameter_list|)
block|{
if|if
condition|(
operator|!
name|__archive_rb_tree_insert_node
argument_list|(
operator|&
operator|(
name|parent
operator|->
name|rbtree
operator|)
argument_list|,
operator|(
expr|struct
name|archive_rb_node
operator|*
operator|)
name|child
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|child
operator|->
name|chnext
operator|=
name|NULL
expr_stmt|;
operator|*
name|parent
operator|->
name|children
operator|.
name|last
operator|=
name|child
expr_stmt|;
name|parent
operator|->
name|children
operator|.
name|last
operator|=
operator|&
operator|(
name|child
operator|->
name|chnext
operator|)
expr_stmt|;
name|parent
operator|->
name|children
operator|.
name|cnt
operator|++
expr_stmt|;
name|child
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
comment|/* Add a child to a sub-directory chain */
name|child
operator|->
name|drnext
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|dir
condition|)
block|{
operator|*
name|parent
operator|->
name|subdirs
operator|.
name|last
operator|=
name|child
expr_stmt|;
name|parent
operator|->
name|subdirs
operator|.
name|last
operator|=
operator|&
operator|(
name|child
operator|->
name|drnext
operator|)
expr_stmt|;
name|parent
operator|->
name|subdirs
operator|.
name|cnt
operator|++
expr_stmt|;
name|child
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|isoent_remove_child
parameter_list|(
name|struct
name|isoent
modifier|*
name|parent
parameter_list|,
name|struct
name|isoent
modifier|*
name|child
parameter_list|)
block|{
name|struct
name|isoent
modifier|*
name|ent
decl_stmt|;
comment|/* Remove a child entry from children chain. */
name|ent
operator|=
name|parent
operator|->
name|children
operator|.
name|first
expr_stmt|;
while|while
condition|(
name|ent
operator|->
name|chnext
operator|!=
name|child
condition|)
name|ent
operator|=
name|ent
operator|->
name|chnext
expr_stmt|;
if|if
condition|(
operator|(
name|ent
operator|->
name|chnext
operator|=
name|ent
operator|->
name|chnext
operator|->
name|chnext
operator|)
operator|==
name|NULL
condition|)
name|parent
operator|->
name|children
operator|.
name|last
operator|=
operator|&
operator|(
name|ent
operator|->
name|chnext
operator|)
expr_stmt|;
name|parent
operator|->
name|children
operator|.
name|cnt
operator|--
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|dir
condition|)
block|{
comment|/* Remove a child entry from sub-directory chain. */
name|ent
operator|=
name|parent
operator|->
name|subdirs
operator|.
name|first
expr_stmt|;
while|while
condition|(
name|ent
operator|->
name|drnext
operator|!=
name|child
condition|)
name|ent
operator|=
name|ent
operator|->
name|drnext
expr_stmt|;
if|if
condition|(
operator|(
name|ent
operator|->
name|drnext
operator|=
name|ent
operator|->
name|drnext
operator|->
name|drnext
operator|)
operator|==
name|NULL
condition|)
name|parent
operator|->
name|subdirs
operator|.
name|last
operator|=
operator|&
operator|(
name|ent
operator|->
name|drnext
operator|)
expr_stmt|;
name|parent
operator|->
name|subdirs
operator|.
name|cnt
operator|--
expr_stmt|;
block|}
name|__archive_rb_tree_remove_node
argument_list|(
operator|&
operator|(
name|parent
operator|->
name|rbtree
operator|)
argument_list|,
operator|(
expr|struct
name|archive_rb_node
operator|*
operator|)
name|child
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|isoent_clone_tree
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|isoent
modifier|*
modifier|*
name|nroot
parameter_list|,
name|struct
name|isoent
modifier|*
name|root
parameter_list|)
block|{
name|struct
name|isoent
modifier|*
name|np
decl_stmt|,
modifier|*
name|xroot
decl_stmt|,
modifier|*
name|newent
decl_stmt|;
name|np
operator|=
name|root
expr_stmt|;
name|xroot
operator|=
name|NULL
expr_stmt|;
do|do
block|{
name|newent
operator|=
name|isoent_clone
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|newent
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|xroot
operator|==
name|NULL
condition|)
block|{
operator|*
name|nroot
operator|=
name|xroot
operator|=
name|newent
expr_stmt|;
name|newent
operator|->
name|parent
operator|=
name|xroot
expr_stmt|;
block|}
else|else
name|isoent_add_child_tail
argument_list|(
name|xroot
argument_list|,
name|newent
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|dir
operator|&&
name|np
operator|->
name|children
operator|.
name|first
operator|!=
name|NULL
condition|)
block|{
comment|/* Enter to sub directories. */
name|np
operator|=
name|np
operator|->
name|children
operator|.
name|first
expr_stmt|;
name|xroot
operator|=
name|newent
expr_stmt|;
continue|continue;
block|}
while|while
condition|(
name|np
operator|!=
name|np
operator|->
name|parent
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|chnext
operator|==
name|NULL
condition|)
block|{
comment|/* Return to the parent directory. */
name|np
operator|=
name|np
operator|->
name|parent
expr_stmt|;
name|xroot
operator|=
name|xroot
operator|->
name|parent
expr_stmt|;
block|}
else|else
block|{
name|np
operator|=
name|np
operator|->
name|chnext
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|np
operator|!=
name|np
operator|->
name|parent
condition|)
do|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Setup directory locations.  */
end_comment

begin_function
specifier|static
name|void
name|isoent_setup_directory_location
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
name|int
name|location
parameter_list|,
name|struct
name|vdd
modifier|*
name|vdd
parameter_list|)
block|{
name|struct
name|isoent
modifier|*
name|np
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|vdd
operator|->
name|total_dir_block
operator|=
literal|0
expr_stmt|;
name|depth
operator|=
literal|0
expr_stmt|;
name|np
operator|=
name|vdd
operator|->
name|rootent
expr_stmt|;
do|do
block|{
name|int
name|block
decl_stmt|;
name|np
operator|->
name|dir_block
operator|=
name|calculate_directory_descriptors
argument_list|(
name|iso9660
argument_list|,
name|vdd
argument_list|,
name|np
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|vdd
operator|->
name|total_dir_block
operator|+=
name|np
operator|->
name|dir_block
expr_stmt|;
name|np
operator|->
name|dir_location
operator|=
name|location
expr_stmt|;
name|location
operator|+=
name|np
operator|->
name|dir_block
expr_stmt|;
name|block
operator|=
name|extra_setup_location
argument_list|(
name|np
argument_list|,
name|location
argument_list|)
expr_stmt|;
name|vdd
operator|->
name|total_dir_block
operator|+=
name|block
expr_stmt|;
name|location
operator|+=
name|block
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|subdirs
operator|.
name|first
operator|!=
name|NULL
operator|&&
name|depth
operator|+
literal|1
operator|<
name|vdd
operator|->
name|max_depth
condition|)
block|{
comment|/* Enter to sub directories. */
name|np
operator|=
name|np
operator|->
name|subdirs
operator|.
name|first
expr_stmt|;
name|depth
operator|++
expr_stmt|;
continue|continue;
block|}
while|while
condition|(
name|np
operator|!=
name|np
operator|->
name|parent
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|drnext
operator|==
name|NULL
condition|)
block|{
comment|/* Return to the parent directory. */
name|np
operator|=
name|np
operator|->
name|parent
expr_stmt|;
name|depth
operator|--
expr_stmt|;
block|}
else|else
block|{
name|np
operator|=
name|np
operator|->
name|drnext
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|np
operator|!=
name|np
operator|->
name|parent
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|_isoent_file_location
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
name|struct
name|isoent
modifier|*
name|isoent
parameter_list|,
name|int
modifier|*
name|symlocation
parameter_list|)
block|{
name|struct
name|isoent
modifier|*
modifier|*
name|children
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|isoent
operator|->
name|children
operator|.
name|cnt
operator|==
literal|0
condition|)
return|return;
name|children
operator|=
name|isoent
operator|->
name|children_sorted
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|isoent
operator|->
name|children
operator|.
name|cnt
condition|;
name|n
operator|++
control|)
block|{
name|struct
name|isoent
modifier|*
name|np
decl_stmt|;
name|struct
name|isofile
modifier|*
name|file
decl_stmt|;
name|np
operator|=
name|children
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|dir
condition|)
continue|continue;
if|if
condition|(
name|np
operator|==
name|iso9660
operator|->
name|el_torito
operator|.
name|boot
condition|)
continue|continue;
name|file
operator|=
name|np
operator|->
name|file
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|boot
operator|||
name|file
operator|->
name|hardlink_target
operator|!=
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|archive_entry_filetype
argument_list|(
name|file
operator|->
name|entry
argument_list|)
operator|==
name|AE_IFLNK
operator|||
name|file
operator|->
name|content
operator|.
name|size
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Do not point a valid location. 			 * Make sure entry is not hardlink file. 			 */
name|file
operator|->
name|content
operator|.
name|location
operator|=
operator|(
operator|*
name|symlocation
operator|)
operator|--
expr_stmt|;
continue|continue;
block|}
name|file
operator|->
name|write_content
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Setup file locations.  */
end_comment

begin_function
specifier|static
name|void
name|isoent_setup_file_location
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
name|int
name|location
parameter_list|)
block|{
name|struct
name|isoent
modifier|*
name|isoent
decl_stmt|;
name|struct
name|isoent
modifier|*
name|np
decl_stmt|;
name|struct
name|isofile
modifier|*
name|file
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|block
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|int
name|joliet
decl_stmt|;
name|int
name|symlocation
decl_stmt|;
name|int
name|total_block
decl_stmt|;
name|iso9660
operator|->
name|total_file_block
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|isoent
operator|=
name|iso9660
operator|->
name|el_torito
operator|.
name|catalog
operator|)
operator|!=
name|NULL
condition|)
block|{
name|isoent
operator|->
name|file
operator|->
name|content
operator|.
name|location
operator|=
name|location
expr_stmt|;
name|block
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|archive_entry_size
argument_list|(
name|isoent
operator|->
name|file
operator|->
name|entry
argument_list|)
operator|+
name|LOGICAL_BLOCK_SIZE
operator|-
literal|1
operator|)
operator|>>
name|LOGICAL_BLOCK_BITS
argument_list|)
expr_stmt|;
name|location
operator|+=
name|block
expr_stmt|;
name|iso9660
operator|->
name|total_file_block
operator|+=
name|block
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|isoent
operator|=
name|iso9660
operator|->
name|el_torito
operator|.
name|boot
operator|)
operator|!=
name|NULL
condition|)
block|{
name|isoent
operator|->
name|file
operator|->
name|content
operator|.
name|location
operator|=
name|location
expr_stmt|;
name|size
operator|=
name|fd_boot_image_size
argument_list|(
name|iso9660
operator|->
name|el_torito
operator|.
name|media_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
operator|(
name|size_t
operator|)
name|archive_entry_size
argument_list|(
name|isoent
operator|->
name|file
operator|->
name|entry
argument_list|)
expr_stmt|;
name|block
operator|=
operator|(
operator|(
name|int
operator|)
name|size
operator|+
name|LOGICAL_BLOCK_SIZE
operator|-
literal|1
operator|)
operator|>>
name|LOGICAL_BLOCK_BITS
expr_stmt|;
name|location
operator|+=
name|block
expr_stmt|;
name|iso9660
operator|->
name|total_file_block
operator|+=
name|block
expr_stmt|;
name|isoent
operator|->
name|file
operator|->
name|content
operator|.
name|blocks
operator|=
name|block
expr_stmt|;
block|}
name|depth
operator|=
literal|0
expr_stmt|;
name|symlocation
operator|=
operator|-
literal|16
expr_stmt|;
if|if
condition|(
operator|!
name|iso9660
operator|->
name|opt
operator|.
name|rr
operator|&&
name|iso9660
operator|->
name|opt
operator|.
name|joliet
condition|)
block|{
name|joliet
operator|=
literal|1
expr_stmt|;
name|np
operator|=
name|iso9660
operator|->
name|joliet
operator|.
name|rootent
expr_stmt|;
block|}
else|else
block|{
name|joliet
operator|=
literal|0
expr_stmt|;
name|np
operator|=
name|iso9660
operator|->
name|primary
operator|.
name|rootent
expr_stmt|;
block|}
do|do
block|{
name|_isoent_file_location
argument_list|(
name|iso9660
argument_list|,
name|np
argument_list|,
operator|&
name|symlocation
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|subdirs
operator|.
name|first
operator|!=
name|NULL
operator|&&
operator|(
name|joliet
operator|||
operator|(
operator|(
name|iso9660
operator|->
name|opt
operator|.
name|rr
operator|==
name|OPT_RR_DISABLED
operator|&&
name|depth
operator|+
literal|2
operator|<
name|iso9660
operator|->
name|primary
operator|.
name|max_depth
operator|)
operator|||
operator|(
name|iso9660
operator|->
name|opt
operator|.
name|rr
operator|&&
name|depth
operator|+
literal|1
operator|<
name|iso9660
operator|->
name|primary
operator|.
name|max_depth
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Enter to sub directories. */
name|np
operator|=
name|np
operator|->
name|subdirs
operator|.
name|first
expr_stmt|;
name|depth
operator|++
expr_stmt|;
continue|continue;
block|}
while|while
condition|(
name|np
operator|!=
name|np
operator|->
name|parent
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|drnext
operator|==
name|NULL
condition|)
block|{
comment|/* Return to the parent directory. */
name|np
operator|=
name|np
operator|->
name|parent
expr_stmt|;
name|depth
operator|--
expr_stmt|;
block|}
else|else
block|{
name|np
operator|=
name|np
operator|->
name|drnext
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|np
operator|!=
name|np
operator|->
name|parent
condition|)
do|;
name|total_block
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|file
operator|=
name|iso9660
operator|->
name|data_file_list
operator|.
name|first
init|;
name|file
operator|!=
name|NULL
condition|;
name|file
operator|=
name|file
operator|->
name|datanext
control|)
block|{
if|if
condition|(
operator|!
name|file
operator|->
name|write_content
condition|)
continue|continue;
name|file
operator|->
name|cur_content
operator|=
operator|&
operator|(
name|file
operator|->
name|content
operator|)
expr_stmt|;
do|do
block|{
name|file
operator|->
name|cur_content
operator|->
name|location
operator|=
name|location
expr_stmt|;
name|location
operator|+=
name|file
operator|->
name|cur_content
operator|->
name|blocks
expr_stmt|;
name|total_block
operator|+=
name|file
operator|->
name|cur_content
operator|->
name|blocks
expr_stmt|;
comment|/* Next fragument */
name|file
operator|->
name|cur_content
operator|=
name|file
operator|->
name|cur_content
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|file
operator|->
name|cur_content
operator|!=
name|NULL
condition|)
do|;
block|}
name|iso9660
operator|->
name|total_file_block
operator|+=
name|total_block
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_path_component
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|l
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|fn
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|l
operator|=
name|strlen
argument_list|(
name|fn
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
name|l
operator|=
name|p
operator|-
name|fn
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|n
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|memcpy
argument_list|(
name|name
argument_list|,
name|fn
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|name
index|[
name|l
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|l
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a new entry into the tree.  */
end_comment

begin_function
specifier|static
name|int
name|isoent_tree
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|isoent
modifier|*
modifier|*
name|isoentpp
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
name|char
name|name
index|[
name|_MAX_FNAME
index|]
decl_stmt|;
comment|/* Included null terminator size. */
elif|#
directive|elif
name|defined
argument_list|(
name|NAME_MAX
argument_list|)
operator|&&
name|NAME_MAX
operator|>=
literal|255
name|char
name|name
index|[
name|NAME_MAX
operator|+
literal|1
index|]
decl_stmt|;
else|#
directive|else
name|char
name|name
index|[
literal|256
index|]
decl_stmt|;
endif|#
directive|endif
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|struct
name|isoent
modifier|*
name|dent
decl_stmt|,
modifier|*
name|isoent
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|struct
name|isofile
modifier|*
name|f1
decl_stmt|,
modifier|*
name|f2
decl_stmt|;
specifier|const
name|char
modifier|*
name|fn
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|l
decl_stmt|;
name|isoent
operator|=
operator|*
name|isoentpp
expr_stmt|;
name|dent
operator|=
name|iso9660
operator|->
name|primary
operator|.
name|rootent
expr_stmt|;
if|if
condition|(
name|isoent
operator|->
name|file
operator|->
name|parentdir
operator|.
name|length
operator|>
literal|0
condition|)
name|fn
operator|=
name|p
operator|=
name|isoent
operator|->
name|file
operator|->
name|parentdir
operator|.
name|s
expr_stmt|;
else|else
name|fn
operator|=
name|p
operator|=
literal|""
expr_stmt|;
comment|/* 	 * If the path of the parent directory of `isoent' entry is 	 * the same as the path of `cur_dirent', add isoent to 	 * `cur_dirent'. 	 */
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|cur_dirstr
operator|)
argument_list|)
operator|==
name|archive_strlen
argument_list|(
operator|&
operator|(
name|isoent
operator|->
name|file
operator|->
name|parentdir
operator|)
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|iso9660
operator|->
name|cur_dirstr
operator|.
name|s
argument_list|,
name|fn
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|isoent_add_child_tail
argument_list|(
name|iso9660
operator|->
name|cur_dirent
argument_list|,
name|isoent
argument_list|)
condition|)
block|{
name|np
operator|=
operator|(
expr|struct
name|isoent
operator|*
operator|)
name|__archive_rb_tree_find_node
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|cur_dirent
operator|->
name|rbtree
operator|)
argument_list|,
name|isoent
operator|->
name|file
operator|->
name|basename
operator|.
name|s
argument_list|)
expr_stmt|;
goto|goto
name|same_entry
goto|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|l
operator|=
name|get_path_component
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
block|{
name|np
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|l
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"A name buffer is too small"
argument_list|)
expr_stmt|;
name|_isoent_free
argument_list|(
name|isoent
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|np
operator|=
name|isoent_find_child
argument_list|(
name|dent
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
operator|||
name|fn
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
break|break;
comment|/* Find next subdirectory. */
if|if
condition|(
operator|!
name|np
operator|->
name|dir
condition|)
block|{
comment|/* NOT Directory! */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"`%s' is not directory, we cannot insert `%s' "
argument_list|,
name|archive_entry_pathname
argument_list|(
name|np
operator|->
name|file
operator|->
name|entry
argument_list|)
argument_list|,
name|archive_entry_pathname
argument_list|(
name|isoent
operator|->
name|file
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|_isoent_free
argument_list|(
name|isoent
argument_list|)
expr_stmt|;
operator|*
name|isoentpp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|fn
operator|+=
name|l
expr_stmt|;
if|if
condition|(
name|fn
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|fn
operator|++
expr_stmt|;
name|dent
operator|=
name|np
expr_stmt|;
block|}
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Create virtual parent directories. 		 */
while|while
condition|(
name|fn
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|struct
name|isoent
modifier|*
name|vp
decl_stmt|;
name|struct
name|archive_string
name|as
decl_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|as
argument_list|)
expr_stmt|;
name|archive_strncat
argument_list|(
operator|&
name|as
argument_list|,
name|p
argument_list|,
name|fn
operator|-
name|p
operator|+
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|as
operator|.
name|s
index|[
name|as
operator|.
name|length
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|as
operator|.
name|s
index|[
name|as
operator|.
name|length
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|as
operator|.
name|length
operator|--
expr_stmt|;
block|}
name|vp
operator|=
name|isoent_create_virtual_dir
argument_list|(
name|a
argument_list|,
name|iso9660
argument_list|,
name|as
operator|.
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|archive_string_free
argument_list|(
operator|&
name|as
argument_list|)
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
name|_isoent_free
argument_list|(
name|isoent
argument_list|)
expr_stmt|;
operator|*
name|isoentpp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_string_free
argument_list|(
operator|&
name|as
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|file
operator|->
name|dircnt
operator|>
name|iso9660
operator|->
name|dircnt_max
condition|)
name|iso9660
operator|->
name|dircnt_max
operator|=
name|vp
operator|->
name|file
operator|->
name|dircnt
expr_stmt|;
name|isoent_add_child_tail
argument_list|(
name|dent
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|np
operator|=
name|vp
expr_stmt|;
name|fn
operator|+=
name|l
expr_stmt|;
if|if
condition|(
name|fn
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|fn
operator|++
expr_stmt|;
name|l
operator|=
name|get_path_component
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|<
literal|0
condition|)
block|{
name|archive_string_free
argument_list|(
operator|&
name|as
argument_list|)
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"A name buffer is too small"
argument_list|)
expr_stmt|;
name|_isoent_free
argument_list|(
name|isoent
argument_list|)
expr_stmt|;
operator|*
name|isoentpp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|dent
operator|=
name|np
expr_stmt|;
block|}
comment|/* Found out the parent directory where isoent can be 		 * inserted. */
name|iso9660
operator|->
name|cur_dirent
operator|=
name|dent
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|cur_dirstr
operator|)
argument_list|)
expr_stmt|;
name|archive_string_ensure
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|cur_dirstr
operator|)
argument_list|,
name|archive_strlen
argument_list|(
operator|&
operator|(
name|dent
operator|->
name|file
operator|->
name|parentdir
operator|)
argument_list|)
operator|+
name|archive_strlen
argument_list|(
operator|&
operator|(
name|dent
operator|->
name|file
operator|->
name|basename
operator|)
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
operator|(
name|dent
operator|->
name|file
operator|->
name|parentdir
operator|)
argument_list|)
operator|+
name|archive_strlen
argument_list|(
operator|&
operator|(
name|dent
operator|->
name|file
operator|->
name|basename
operator|)
argument_list|)
operator|==
literal|0
condition|)
name|iso9660
operator|->
name|cur_dirstr
operator|.
name|s
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
operator|(
name|dent
operator|->
name|file
operator|->
name|parentdir
operator|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|archive_string_copy
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|cur_dirstr
operator|)
argument_list|,
operator|&
operator|(
name|dent
operator|->
name|file
operator|->
name|parentdir
operator|)
argument_list|)
expr_stmt|;
name|archive_strappend_char
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|cur_dirstr
operator|)
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
block|}
name|archive_string_concat
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|cur_dirstr
operator|)
argument_list|,
operator|&
operator|(
name|dent
operator|->
name|file
operator|->
name|basename
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isoent_add_child_tail
argument_list|(
name|dent
argument_list|,
name|isoent
argument_list|)
condition|)
block|{
name|np
operator|=
operator|(
expr|struct
name|isoent
operator|*
operator|)
name|__archive_rb_tree_find_node
argument_list|(
operator|&
operator|(
name|dent
operator|->
name|rbtree
operator|)
argument_list|,
name|isoent
operator|->
name|file
operator|->
name|basename
operator|.
name|s
argument_list|)
expr_stmt|;
goto|goto
name|same_entry
goto|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
name|same_entry
label|:
comment|/* 	 * We have already has the entry the filename of which is 	 * the same. 	 */
name|f1
operator|=
name|np
operator|->
name|file
expr_stmt|;
name|f2
operator|=
name|isoent
operator|->
name|file
expr_stmt|;
comment|/* If the file type of entries is different, 	 * we cannot handle it. */
if|if
condition|(
name|archive_entry_filetype
argument_list|(
name|f1
operator|->
name|entry
argument_list|)
operator|!=
name|archive_entry_filetype
argument_list|(
name|f2
operator|->
name|entry
argument_list|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Found duplicate entries `%s' and its file type is "
literal|"different"
argument_list|,
name|archive_entry_pathname
argument_list|(
name|f1
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|_isoent_free
argument_list|(
name|isoent
argument_list|)
expr_stmt|;
operator|*
name|isoentpp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
comment|/* Swap file entries. */
name|np
operator|->
name|file
operator|=
name|f2
expr_stmt|;
name|isoent
operator|->
name|file
operator|=
name|f1
expr_stmt|;
name|np
operator|->
name|virtual
operator|=
literal|0
expr_stmt|;
name|_isoent_free
argument_list|(
name|isoent
argument_list|)
expr_stmt|;
operator|*
name|isoentpp
operator|=
name|np
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find a entry from `isoent'  */
end_comment

begin_function
specifier|static
name|struct
name|isoent
modifier|*
name|isoent_find_child
parameter_list|(
name|struct
name|isoent
modifier|*
name|isoent
parameter_list|,
specifier|const
name|char
modifier|*
name|child_name
parameter_list|)
block|{
name|struct
name|isoent
modifier|*
name|np
decl_stmt|;
name|np
operator|=
operator|(
expr|struct
name|isoent
operator|*
operator|)
name|__archive_rb_tree_find_node
argument_list|(
operator|&
operator|(
name|isoent
operator|->
name|rbtree
operator|)
argument_list|,
name|child_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|np
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find a entry full-path of which is specified by `fn' parameter,  * in the tree.  */
end_comment

begin_function
specifier|static
name|struct
name|isoent
modifier|*
name|isoent_find_entry
parameter_list|(
name|struct
name|isoent
modifier|*
name|rootent
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
name|char
name|name
index|[
name|_MAX_FNAME
index|]
decl_stmt|;
comment|/* Included null terminator size. */
elif|#
directive|elif
name|defined
argument_list|(
name|NAME_MAX
argument_list|)
operator|&&
name|NAME_MAX
operator|>=
literal|255
name|char
name|name
index|[
name|NAME_MAX
operator|+
literal|1
index|]
decl_stmt|;
else|#
directive|else
name|char
name|name
index|[
literal|256
index|]
decl_stmt|;
endif|#
directive|endif
name|struct
name|isoent
modifier|*
name|isoent
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|int
name|l
decl_stmt|;
name|isoent
operator|=
name|rootent
expr_stmt|;
name|np
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|l
operator|=
name|get_path_component
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
break|break;
name|fn
operator|+=
name|l
expr_stmt|;
if|if
condition|(
name|fn
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|fn
operator|++
expr_stmt|;
name|np
operator|=
name|isoent_find_child
argument_list|(
name|isoent
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|fn
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
break|break;
comment|/* We found out the entry */
comment|/* Try sub directory. */
name|isoent
operator|=
name|np
expr_stmt|;
name|np
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|isoent
operator|->
name|dir
condition|)
break|break;
comment|/* Not directory */
block|}
return|return
operator|(
name|np
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Following idr_* functions are used for resolving duplicated filenames  * and unreceivable filenames to generate ISO9660/Joliet Identifiers.  */
end_comment

begin_function
specifier|static
name|void
name|idr_relaxed_filenames
parameter_list|(
name|char
modifier|*
name|map
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0x21
init|;
name|i
operator|<=
literal|0x2F
condition|;
name|i
operator|++
control|)
name|map
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0x3A
init|;
name|i
operator|<=
literal|0x41
condition|;
name|i
operator|++
control|)
name|map
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0x5B
init|;
name|i
operator|<=
literal|0x5E
condition|;
name|i
operator|++
control|)
name|map
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|map
index|[
literal|0x60
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0x7B
init|;
name|i
operator|<=
literal|0x7E
condition|;
name|i
operator|++
control|)
name|map
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|idr_init
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
name|struct
name|vdd
modifier|*
name|vdd
parameter_list|,
name|struct
name|idr
modifier|*
name|idr
parameter_list|)
block|{
name|idr
operator|->
name|idrent_pool
operator|=
name|NULL
expr_stmt|;
name|idr
operator|->
name|pool_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vdd
operator|->
name|vdd_type
operator|!=
name|VDD_JOLIET
condition|)
block|{
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|iso_level
operator|<=
literal|3
condition|)
block|{
name|memcpy
argument_list|(
name|idr
operator|->
name|char_map
argument_list|,
name|d_characters_map
argument_list|,
sizeof|sizeof
argument_list|(
name|idr
operator|->
name|char_map
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|idr
operator|->
name|char_map
argument_list|,
name|d1_characters_map
argument_list|,
sizeof|sizeof
argument_list|(
name|idr
operator|->
name|char_map
argument_list|)
argument_list|)
expr_stmt|;
name|idr_relaxed_filenames
argument_list|(
name|idr
operator|->
name|char_map
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|idr_cleanup
parameter_list|(
name|struct
name|idr
modifier|*
name|idr
parameter_list|)
block|{
name|free
argument_list|(
name|idr
operator|->
name|idrent_pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|idr_ensure_poolsize
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|idr
modifier|*
name|idr
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
if|if
condition|(
name|idr
operator|->
name|pool_size
operator|<
name|cnt
condition|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
specifier|const
name|int
name|bk
init|=
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|psize
decl_stmt|;
name|psize
operator|=
operator|(
name|cnt
operator|+
name|bk
operator|)
operator|&
operator|~
name|bk
expr_stmt|;
name|p
operator|=
name|realloc
argument_list|(
name|idr
operator|->
name|idrent_pool
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|idrent
argument_list|)
operator|*
name|psize
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|idr
operator|->
name|idrent_pool
operator|=
operator|(
expr|struct
name|idrent
operator|*
operator|)
name|p
expr_stmt|;
name|idr
operator|->
name|pool_size
operator|=
name|psize
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|idr_start
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|idr
modifier|*
name|idr
parameter_list|,
name|int
name|cnt
parameter_list|,
name|int
name|ffmax
parameter_list|,
name|int
name|num_size
parameter_list|,
name|int
name|null_size
parameter_list|,
specifier|const
name|struct
name|archive_rb_tree_ops
modifier|*
name|rbt_ops
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
operator|(
name|void
operator|)
name|ffmax
expr_stmt|;
comment|/* UNUSED */
name|r
operator|=
name|idr_ensure_poolsize
argument_list|(
name|a
argument_list|,
name|idr
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|__archive_rb_tree_init
argument_list|(
operator|&
operator|(
name|idr
operator|->
name|rbtree
operator|)
argument_list|,
name|rbt_ops
argument_list|)
expr_stmt|;
name|idr
operator|->
name|wait_list
operator|.
name|first
operator|=
name|NULL
expr_stmt|;
name|idr
operator|->
name|wait_list
operator|.
name|last
operator|=
operator|&
operator|(
name|idr
operator|->
name|wait_list
operator|.
name|first
operator|)
expr_stmt|;
name|idr
operator|->
name|pool_idx
operator|=
literal|0
expr_stmt|;
name|idr
operator|->
name|num_size
operator|=
name|num_size
expr_stmt|;
name|idr
operator|->
name|null_size
operator|=
name|null_size
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|idr_register
parameter_list|(
name|struct
name|idr
modifier|*
name|idr
parameter_list|,
name|struct
name|isoent
modifier|*
name|isoent
parameter_list|,
name|int
name|weight
parameter_list|,
name|int
name|noff
parameter_list|)
block|{
name|struct
name|idrent
modifier|*
name|idrent
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|idrent
operator|=
operator|&
operator|(
name|idr
operator|->
name|idrent_pool
index|[
name|idr
operator|->
name|pool_idx
operator|++
index|]
operator|)
expr_stmt|;
name|idrent
operator|->
name|wnext
operator|=
name|idrent
operator|->
name|avail
operator|=
name|NULL
expr_stmt|;
name|idrent
operator|->
name|isoent
operator|=
name|isoent
expr_stmt|;
name|idrent
operator|->
name|weight
operator|=
name|weight
expr_stmt|;
name|idrent
operator|->
name|noff
operator|=
name|noff
expr_stmt|;
name|idrent
operator|->
name|rename_num
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|__archive_rb_tree_insert_node
argument_list|(
operator|&
operator|(
name|idr
operator|->
name|rbtree
operator|)
argument_list|,
operator|&
operator|(
name|idrent
operator|->
name|rbnode
operator|)
argument_list|)
condition|)
block|{
name|n
operator|=
operator|(
expr|struct
name|idrent
operator|*
operator|)
name|__archive_rb_tree_find_node
argument_list|(
operator|&
operator|(
name|idr
operator|->
name|rbtree
operator|)
argument_list|,
name|idrent
operator|->
name|isoent
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
block|{
comment|/* this `idrent' needs to rename. */
name|idrent
operator|->
name|avail
operator|=
name|n
expr_stmt|;
operator|*
name|idr
operator|->
name|wait_list
operator|.
name|last
operator|=
name|idrent
expr_stmt|;
name|idr
operator|->
name|wait_list
operator|.
name|last
operator|=
operator|&
operator|(
name|idrent
operator|->
name|wnext
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|idr_extend_identifier
parameter_list|(
name|struct
name|idrent
modifier|*
name|wnp
parameter_list|,
name|int
name|numsize
parameter_list|,
name|int
name|nullsize
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|wnp_ext_off
decl_stmt|;
name|wnp_ext_off
operator|=
name|wnp
operator|->
name|isoent
operator|->
name|ext_off
expr_stmt|;
if|if
condition|(
name|wnp
operator|->
name|noff
operator|+
name|numsize
operator|!=
name|wnp_ext_off
condition|)
block|{
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|wnp
operator|->
name|isoent
operator|->
name|identifier
expr_stmt|;
comment|/* Extend the filename; foo.c --> foo___.c */
name|memmove
argument_list|(
name|p
operator|+
name|wnp
operator|->
name|noff
operator|+
name|numsize
argument_list|,
name|p
operator|+
name|wnp_ext_off
argument_list|,
name|wnp
operator|->
name|isoent
operator|->
name|ext_len
operator|+
name|nullsize
argument_list|)
expr_stmt|;
name|wnp
operator|->
name|isoent
operator|->
name|ext_off
operator|=
name|wnp_ext_off
operator|=
name|wnp
operator|->
name|noff
operator|+
name|numsize
expr_stmt|;
name|wnp
operator|->
name|isoent
operator|->
name|id_len
operator|=
name|wnp_ext_off
operator|+
name|wnp
operator|->
name|isoent
operator|->
name|ext_len
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|idr_resolve
parameter_list|(
name|struct
name|idr
modifier|*
name|idr
parameter_list|,
name|void
function_decl|(
modifier|*
name|fsetnum
function_decl|)
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|int
name|num
parameter_list|)
parameter_list|)
block|{
name|struct
name|idrent
modifier|*
name|n
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|n
operator|=
name|idr
operator|->
name|wait_list
operator|.
name|first
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|wnext
control|)
block|{
name|idr_extend_identifier
argument_list|(
name|n
argument_list|,
name|idr
operator|->
name|num_size
argument_list|,
name|idr
operator|->
name|null_size
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|n
operator|->
name|isoent
operator|->
name|identifier
operator|+
name|n
operator|->
name|noff
expr_stmt|;
do|do
block|{
name|fsetnum
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|avail
operator|->
name|rename_num
operator|++
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|__archive_rb_tree_insert_node
argument_list|(
operator|&
operator|(
name|idr
operator|->
name|rbtree
operator|)
argument_list|,
operator|&
operator|(
name|n
operator|->
name|rbnode
operator|)
argument_list|)
condition|)
do|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|idr_set_num
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|int
name|num
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|xdig
index|[]
init|=
block|{
literal|'0'
block|,
literal|'1'
block|,
literal|'2'
block|,
literal|'3'
block|,
literal|'4'
block|,
literal|'5'
block|,
literal|'6'
block|,
literal|'7'
block|,
literal|'8'
block|,
literal|'9'
block|,
literal|'A'
block|,
literal|'B'
block|,
literal|'C'
block|,
literal|'D'
block|,
literal|'E'
block|,
literal|'F'
block|,
literal|'G'
block|,
literal|'H'
block|,
literal|'I'
block|,
literal|'J'
block|,
literal|'K'
block|,
literal|'L'
block|,
literal|'M'
block|,
literal|'N'
block|,
literal|'O'
block|,
literal|'P'
block|,
literal|'Q'
block|,
literal|'R'
block|,
literal|'S'
block|,
literal|'T'
block|,
literal|'U'
block|,
literal|'V'
block|,
literal|'W'
block|,
literal|'X'
block|,
literal|'Y'
block|,
literal|'Z'
block|}
decl_stmt|;
name|num
operator|%=
sizeof|sizeof
argument_list|(
name|xdig
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|xdig
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|xdig
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|xdig
index|[
operator|(
name|num
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|xdig
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|xdig
argument_list|)
operator|)
operator|)
index|]
expr_stmt|;
name|num
operator|%=
sizeof|sizeof
argument_list|(
name|xdig
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|xdig
argument_list|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|xdig
index|[
operator|(
name|num
operator|/
sizeof|sizeof
argument_list|(
name|xdig
argument_list|)
operator|)
index|]
expr_stmt|;
name|num
operator|%=
sizeof|sizeof
argument_list|(
name|xdig
argument_list|)
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
name|xdig
index|[
name|num
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|idr_set_num_beutf16
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|int
name|num
parameter_list|)
block|{
specifier|static
specifier|const
name|uint16_t
name|xdig
index|[]
init|=
block|{
literal|0x0030
block|,
literal|0x0031
block|,
literal|0x0032
block|,
literal|0x0033
block|,
literal|0x0034
block|,
literal|0x0035
block|,
literal|0x0036
block|,
literal|0x0037
block|,
literal|0x0038
block|,
literal|0x0039
block|,
literal|0x0041
block|,
literal|0x0042
block|,
literal|0x0043
block|,
literal|0x0044
block|,
literal|0x0045
block|,
literal|0x0046
block|,
literal|0x0047
block|,
literal|0x0048
block|,
literal|0x0049
block|,
literal|0x004A
block|,
literal|0x004B
block|,
literal|0x004C
block|,
literal|0x004D
block|,
literal|0x004E
block|,
literal|0x004F
block|,
literal|0x0050
block|,
literal|0x0051
block|,
literal|0x0052
block|,
literal|0x0053
block|,
literal|0x0054
block|,
literal|0x0055
block|,
literal|0x0056
block|,
literal|0x0057
block|,
literal|0x0058
block|,
literal|0x0059
block|,
literal|0x005A
block|}
decl_stmt|;
define|#
directive|define
name|XDIG_CNT
value|(sizeof(xdig)/sizeof(xdig[0]))
name|num
operator|%=
name|XDIG_CNT
operator|*
name|XDIG_CNT
operator|*
name|XDIG_CNT
expr_stmt|;
name|archive_be16enc
argument_list|(
name|p
argument_list|,
name|xdig
index|[
operator|(
name|num
operator|/
operator|(
name|XDIG_CNT
operator|*
name|XDIG_CNT
operator|)
operator|)
index|]
argument_list|)
expr_stmt|;
name|num
operator|%=
name|XDIG_CNT
operator|*
name|XDIG_CNT
expr_stmt|;
name|archive_be16enc
argument_list|(
name|p
operator|+
literal|2
argument_list|,
name|xdig
index|[
operator|(
name|num
operator|/
name|XDIG_CNT
operator|)
index|]
argument_list|)
expr_stmt|;
name|num
operator|%=
name|XDIG_CNT
expr_stmt|;
name|archive_be16enc
argument_list|(
name|p
operator|+
literal|4
argument_list|,
name|xdig
index|[
name|num
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate ISO9660 Identifier.  */
end_comment

begin_function
specifier|static
name|int
name|isoent_gen_iso9660_identifier
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|isoent
modifier|*
name|isoent
parameter_list|,
name|struct
name|idr
modifier|*
name|idr
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
decl_stmt|;
name|struct
name|isoent
modifier|*
name|np
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|l
decl_stmt|,
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|char_map
decl_stmt|;
name|char
name|allow_ldots
decl_stmt|,
name|allow_multidot
decl_stmt|,
name|allow_period
decl_stmt|,
name|allow_vernum
decl_stmt|;
name|int
name|fnmax
decl_stmt|,
name|ffmax
decl_stmt|,
name|dnmax
decl_stmt|;
specifier|static
specifier|const
name|struct
name|archive_rb_tree_ops
name|rb_ops
init|=
block|{
name|isoent_cmp_node_iso9660
block|,
name|isoent_cmp_key_iso9660
block|}
decl_stmt|;
if|if
condition|(
name|isoent
operator|->
name|children
operator|.
name|cnt
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|iso9660
operator|=
name|a
operator|->
name|format_data
expr_stmt|;
name|char_map
operator|=
name|idr
operator|->
name|char_map
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|iso_level
operator|<=
literal|3
condition|)
block|{
name|allow_ldots
operator|=
literal|0
expr_stmt|;
name|allow_multidot
operator|=
literal|0
expr_stmt|;
name|allow_period
operator|=
literal|1
expr_stmt|;
name|allow_vernum
operator|=
name|iso9660
operator|->
name|opt
operator|.
name|allow_vernum
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|iso_level
operator|==
literal|1
condition|)
block|{
name|fnmax
operator|=
literal|8
expr_stmt|;
name|ffmax
operator|=
literal|12
expr_stmt|;
comment|/* fnmax + '.' + 3 */
name|dnmax
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|fnmax
operator|=
literal|30
expr_stmt|;
name|ffmax
operator|=
literal|31
expr_stmt|;
name|dnmax
operator|=
literal|31
expr_stmt|;
block|}
block|}
else|else
block|{
name|allow_ldots
operator|=
name|allow_multidot
operator|=
literal|1
expr_stmt|;
name|allow_period
operator|=
name|allow_vernum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|rr
condition|)
comment|/* 			 * MDR : The maximum size of Directory Record(254). 			 * DRL : A Directory Record Length(33). 			 * CE  : A size of SUSP CE System Use Entry(28). 			 * MDR - DRL - CE = 254 - 33 - 28 = 193. 			 */
name|fnmax
operator|=
name|ffmax
operator|=
name|dnmax
operator|=
literal|193
expr_stmt|;
else|else
comment|/* 			 * XA  : CD-ROM XA System Use Extension 			 *       Information(14). 			 * MDR - DRL - XA = 254 - 33 -14 = 207. 			 */
name|fnmax
operator|=
name|ffmax
operator|=
name|dnmax
operator|=
literal|207
expr_stmt|;
block|}
name|r
operator|=
name|idr_start
argument_list|(
name|a
argument_list|,
name|idr
argument_list|,
name|isoent
operator|->
name|children
operator|.
name|cnt
argument_list|,
name|ffmax
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
operator|&
name|rb_ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
for|for
control|(
name|np
operator|=
name|isoent
operator|->
name|children
operator|.
name|first
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|chnext
control|)
block|{
name|char
modifier|*
name|dot
decl_stmt|,
modifier|*
name|xdot
decl_stmt|;
name|int
name|ext_off
decl_stmt|,
name|noff
decl_stmt|,
name|weight
decl_stmt|;
name|l
operator|=
operator|(
name|int
operator|)
name|np
operator|->
name|file
operator|->
name|basename
operator|.
name|length
expr_stmt|;
name|p
operator|=
name|malloc
argument_list|(
name|l
operator|+
literal|31
operator|+
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|p
argument_list|,
name|np
operator|->
name|file
operator|->
name|basename
operator|.
name|s
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|p
index|[
name|l
index|]
operator|=
literal|'\0'
expr_stmt|;
name|np
operator|->
name|identifier
operator|=
name|p
expr_stmt|;
name|dot
operator|=
name|xdot
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|allow_ldots
condition|)
block|{
comment|/* 			 * If there is a '.' character at the first byte, 			 * it has to be replaced by '_' character. 			 */
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
operator|*
name|p
operator|++
operator|=
literal|'_'
expr_stmt|;
block|}
for|for
control|(
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|&
literal|0x80
condition|)
block|{
operator|*
name|p
operator|=
literal|'_'
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|char_map
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
index|]
condition|)
block|{
comment|/* if iso-level is '4', a character '.' is 				 * allowed by char_map. */
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
block|{
name|xdot
operator|=
name|dot
expr_stmt|;
name|dot
operator|=
name|p
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|*
name|p
operator|>=
literal|'a'
operator|&&
operator|*
name|p
operator|<=
literal|'z'
condition|)
block|{
operator|*
name|p
operator|-=
literal|'a'
operator|-
literal|'A'
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
block|{
name|xdot
operator|=
name|dot
expr_stmt|;
name|dot
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|allow_multidot
condition|)
continue|continue;
block|}
operator|*
name|p
operator|=
literal|'_'
expr_stmt|;
block|}
name|p
operator|=
name|np
operator|->
name|identifier
expr_stmt|;
name|weight
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dot
operator|==
name|NULL
condition|)
block|{
name|int
name|nammax
decl_stmt|;
if|if
condition|(
name|np
operator|->
name|dir
condition|)
name|nammax
operator|=
name|dnmax
expr_stmt|;
else|else
name|nammax
operator|=
name|fnmax
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|nammax
condition|)
block|{
name|p
index|[
name|nammax
index|]
operator|=
literal|'\0'
expr_stmt|;
name|weight
operator|=
name|nammax
expr_stmt|;
name|ext_off
operator|=
name|nammax
expr_stmt|;
block|}
else|else
name|ext_off
operator|=
name|l
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dot
operator|=
literal|'.'
expr_stmt|;
name|ext_off
operator|=
call|(
name|int
call|)
argument_list|(
name|dot
operator|-
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|iso_level
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|dot
operator|-
name|p
operator|<=
literal|8
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|dot
argument_list|)
operator|>
literal|4
condition|)
block|{
comment|/* A length of a file extension 						 * must be less than 4 */
name|dot
index|[
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
name|weight
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|p
index|[
literal|8
index|]
operator|=
name|dot
index|[
literal|0
index|]
expr_stmt|;
name|p
index|[
literal|9
index|]
operator|=
name|dot
index|[
literal|1
index|]
expr_stmt|;
name|p
index|[
literal|10
index|]
operator|=
name|dot
index|[
literal|2
index|]
expr_stmt|;
name|p
index|[
literal|11
index|]
operator|=
name|dot
index|[
literal|3
index|]
expr_stmt|;
name|p
index|[
literal|12
index|]
operator|=
literal|'\0'
expr_stmt|;
name|weight
operator|=
literal|8
expr_stmt|;
name|ext_off
operator|=
literal|8
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|np
operator|->
name|dir
condition|)
block|{
if|if
condition|(
name|l
operator|>
name|dnmax
condition|)
block|{
name|p
index|[
name|dnmax
index|]
operator|=
literal|'\0'
expr_stmt|;
name|weight
operator|=
name|dnmax
expr_stmt|;
if|if
condition|(
name|ext_off
operator|>
name|dnmax
condition|)
name|ext_off
operator|=
name|dnmax
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|l
operator|>
name|ffmax
condition|)
block|{
name|int
name|extlen
init|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|dot
argument_list|)
decl_stmt|;
name|int
name|xdoff
decl_stmt|;
if|if
condition|(
name|xdot
operator|!=
name|NULL
condition|)
name|xdoff
operator|=
call|(
name|int
call|)
argument_list|(
name|xdot
operator|-
name|p
argument_list|)
expr_stmt|;
else|else
name|xdoff
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|extlen
operator|>
literal|1
operator|&&
name|xdoff
operator|<
name|fnmax
operator|-
literal|1
condition|)
block|{
name|int
name|off
decl_stmt|;
if|if
condition|(
name|extlen
operator|>
name|ffmax
condition|)
name|extlen
operator|=
name|ffmax
expr_stmt|;
name|off
operator|=
name|ffmax
operator|-
name|extlen
expr_stmt|;
if|if
condition|(
name|off
operator|==
literal|0
condition|)
block|{
comment|/* A dot('.')  character 						 * does't place to the first 						 * byte of identifier. */
name|off
operator|++
expr_stmt|;
name|extlen
operator|--
expr_stmt|;
block|}
name|memmove
argument_list|(
name|p
operator|+
name|off
argument_list|,
name|dot
argument_list|,
name|extlen
argument_list|)
expr_stmt|;
name|p
index|[
name|ffmax
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ext_off
operator|=
name|off
expr_stmt|;
name|weight
operator|=
name|off
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_MKISOFS
block|}
elseif|else
if|if
condition|(
name|xdoff
operator|>=
name|fnmax
operator|-
literal|1
condition|)
block|{
comment|/* Simulate a bug(?) of mkisofs. */
name|p
index|[
name|fnmax
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ext_off
operator|=
name|fnmax
operator|-
literal|1
expr_stmt|;
name|weight
operator|=
name|fnmax
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|p
index|[
name|fnmax
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ext_off
operator|=
name|fnmax
expr_stmt|;
name|weight
operator|=
name|fnmax
expr_stmt|;
block|}
block|}
block|}
comment|/* Save an offset of a file name extension to sort files. */
name|np
operator|->
name|ext_off
operator|=
name|ext_off
expr_stmt|;
name|np
operator|->
name|ext_len
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
operator|&
name|p
index|[
name|ext_off
index|]
argument_list|)
expr_stmt|;
name|np
operator|->
name|id_len
operator|=
name|l
operator|=
name|ext_off
operator|+
name|np
operator|->
name|ext_len
expr_stmt|;
comment|/* Make an offset of the number which is used to be set 		 * hexadecimal number to avoid duplicate identififier. */
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|iso_level
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|ext_off
operator|>=
literal|5
condition|)
name|noff
operator|=
literal|5
expr_stmt|;
else|else
name|noff
operator|=
name|ext_off
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|l
operator|==
name|ffmax
condition|)
name|noff
operator|=
name|ext_off
operator|-
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|l
operator|==
name|ffmax
operator|-
literal|1
condition|)
name|noff
operator|=
name|ext_off
operator|-
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|l
operator|==
name|ffmax
operator|-
literal|2
condition|)
name|noff
operator|=
name|ext_off
operator|-
literal|1
expr_stmt|;
else|else
name|noff
operator|=
name|ext_off
expr_stmt|;
block|}
comment|/* Register entry to the identifier resolver. */
name|idr_register
argument_list|(
name|idr
argument_list|,
name|np
argument_list|,
name|weight
argument_list|,
name|noff
argument_list|)
expr_stmt|;
block|}
comment|/* Resolve duplicate identifier. */
name|idr_resolve
argument_list|(
name|idr
argument_list|,
name|idr_set_num
argument_list|)
expr_stmt|;
comment|/* Add a period and a version number to identifiers. */
for|for
control|(
name|np
operator|=
name|isoent
operator|->
name|children
operator|.
name|first
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|chnext
control|)
block|{
if|if
condition|(
operator|!
name|np
operator|->
name|dir
operator|&&
name|np
operator|->
name|rr_child
operator|==
name|NULL
condition|)
block|{
name|p
operator|=
name|np
operator|->
name|identifier
operator|+
name|np
operator|->
name|ext_off
operator|+
name|np
operator|->
name|ext_len
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|ext_len
operator|==
literal|0
operator|&&
name|allow_period
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'.'
expr_stmt|;
name|np
operator|->
name|ext_len
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|np
operator|->
name|ext_len
operator|==
literal|1
operator|&&
operator|!
name|allow_period
condition|)
block|{
operator|*
operator|--
name|p
operator|=
literal|'\0'
expr_stmt|;
name|np
operator|->
name|ext_len
operator|=
literal|0
expr_stmt|;
block|}
name|np
operator|->
name|id_len
operator|=
name|np
operator|->
name|ext_off
operator|+
name|np
operator|->
name|ext_len
expr_stmt|;
if|if
condition|(
name|allow_vernum
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|';'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'1'
expr_stmt|;
name|np
operator|->
name|id_len
operator|+=
literal|2
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|np
operator|->
name|id_len
operator|=
name|np
operator|->
name|ext_off
operator|+
name|np
operator|->
name|ext_len
expr_stmt|;
name|np
operator|->
name|mb_len
operator|=
name|np
operator|->
name|id_len
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate Joliet Identifier.  */
end_comment

begin_function
specifier|static
name|int
name|isoent_gen_joliet_identifier
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|isoent
modifier|*
name|isoent
parameter_list|,
name|struct
name|idr
modifier|*
name|idr
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
decl_stmt|;
name|struct
name|isoent
modifier|*
name|np
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|l
decl_stmt|;
name|int
name|r
decl_stmt|;
name|int
name|ffmax
decl_stmt|,
name|parent_len
decl_stmt|;
specifier|static
specifier|const
name|struct
name|archive_rb_tree_ops
name|rb_ops
init|=
block|{
name|isoent_cmp_node_joliet
block|,
name|isoent_cmp_key_joliet
block|}
decl_stmt|;
if|if
condition|(
name|isoent
operator|->
name|children
operator|.
name|cnt
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|iso9660
operator|=
name|a
operator|->
name|format_data
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|joliet
operator|==
name|OPT_JOLIET_LONGNAME
condition|)
name|ffmax
operator|=
literal|206
expr_stmt|;
else|else
name|ffmax
operator|=
literal|128
expr_stmt|;
name|r
operator|=
name|idr_start
argument_list|(
name|a
argument_list|,
name|idr
argument_list|,
name|isoent
operator|->
name|children
operator|.
name|cnt
argument_list|,
name|ffmax
argument_list|,
literal|6
argument_list|,
literal|2
argument_list|,
operator|&
name|rb_ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|parent_len
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|np
operator|=
name|isoent
init|;
name|np
operator|->
name|parent
operator|!=
name|np
condition|;
name|np
operator|=
name|np
operator|->
name|parent
control|)
name|parent_len
operator|+=
name|np
operator|->
name|mb_len
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|np
operator|=
name|isoent
operator|->
name|children
operator|.
name|first
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|chnext
control|)
block|{
name|unsigned
name|char
modifier|*
name|dot
decl_stmt|;
name|int
name|ext_off
decl_stmt|,
name|noff
decl_stmt|,
name|weight
decl_stmt|;
name|size_t
name|lt
decl_stmt|;
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|l
operator|=
name|np
operator|->
name|file
operator|->
name|basename_utf16
operator|.
name|length
argument_list|)
operator|>
name|ffmax
condition|)
name|l
operator|=
name|ffmax
expr_stmt|;
name|p
operator|=
name|malloc
argument_list|(
operator|(
name|l
operator|+
literal|1
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|p
argument_list|,
name|np
operator|->
name|file
operator|->
name|basename_utf16
operator|.
name|s
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|p
index|[
name|l
index|]
operator|=
literal|0
expr_stmt|;
name|p
index|[
name|l
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|identifier
operator|=
operator|(
name|char
operator|*
operator|)
name|p
expr_stmt|;
name|lt
operator|=
name|l
expr_stmt|;
name|dot
operator|=
name|p
operator|+
name|l
expr_stmt|;
name|weight
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|lt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|joliet_allowed_char
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|)
condition|)
name|archive_be16enc
argument_list|(
name|p
argument_list|,
literal|0x005F
argument_list|)
expr_stmt|;
comment|/* '_' */
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|0x2E
condition|)
comment|/* '.' */
name|dot
operator|=
name|p
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
name|lt
operator|-=
literal|2
expr_stmt|;
block|}
name|ext_off
operator|=
call|(
name|int
call|)
argument_list|(
name|dot
operator|-
operator|(
name|unsigned
name|char
operator|*
operator|)
name|np
operator|->
name|identifier
argument_list|)
expr_stmt|;
name|np
operator|->
name|ext_off
operator|=
name|ext_off
expr_stmt|;
name|np
operator|->
name|ext_len
operator|=
operator|(
name|int
operator|)
name|l
operator|-
name|ext_off
expr_stmt|;
name|np
operator|->
name|id_len
operator|=
operator|(
name|int
operator|)
name|l
expr_stmt|;
comment|/* 		 * Get a length of MBS of a full-pathname. 		 */
if|if
condition|(
operator|(
name|int
operator|)
name|np
operator|->
name|file
operator|->
name|basename_utf16
operator|.
name|length
operator|>
name|ffmax
condition|)
block|{
if|if
condition|(
name|archive_strncpy_l
argument_list|(
operator|&
name|iso9660
operator|->
name|mbs
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|np
operator|->
name|identifier
argument_list|,
name|l
argument_list|,
name|iso9660
operator|->
name|sconv_from_utf16be
argument_list|)
operator|!=
literal|0
operator|&&
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"No memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|np
operator|->
name|mb_len
operator|=
operator|(
name|int
operator|)
name|iso9660
operator|->
name|mbs
operator|.
name|length
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|mb_len
operator|!=
operator|(
name|int
operator|)
name|np
operator|->
name|file
operator|->
name|basename
operator|.
name|length
condition|)
name|weight
operator|=
name|np
operator|->
name|mb_len
expr_stmt|;
block|}
else|else
name|np
operator|->
name|mb_len
operator|=
operator|(
name|int
operator|)
name|np
operator|->
name|file
operator|->
name|basename
operator|.
name|length
expr_stmt|;
comment|/* If a length of full-pathname is longer than 240 bytes, 		 * it violates Joliet extensions regulation. */
if|if
condition|(
name|parent_len
operator|+
name|np
operator|->
name|mb_len
operator|>
literal|240
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"The regulation of Joliet extensions;"
literal|" A length of a full-pathname of `%s' is "
literal|"longer than 240 bytes, (p=%d, b=%d)"
argument_list|,
name|archive_entry_pathname
argument_list|(
name|np
operator|->
name|file
operator|->
name|entry
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|parent_len
argument_list|,
operator|(
name|int
operator|)
name|np
operator|->
name|mb_len
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Make an offset of the number which is used to be set 		 * hexadecimal number to avoid duplicate identifier. */
if|if
condition|(
operator|(
name|int
operator|)
name|l
operator|==
name|ffmax
condition|)
name|noff
operator|=
name|ext_off
operator|-
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|int
operator|)
name|l
operator|==
name|ffmax
operator|-
literal|2
condition|)
name|noff
operator|=
name|ext_off
operator|-
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|int
operator|)
name|l
operator|==
name|ffmax
operator|-
literal|4
condition|)
name|noff
operator|=
name|ext_off
operator|-
literal|2
expr_stmt|;
else|else
name|noff
operator|=
name|ext_off
expr_stmt|;
comment|/* Register entry to the identifier resolver. */
name|idr_register
argument_list|(
name|idr
argument_list|,
name|np
argument_list|,
name|weight
argument_list|,
name|noff
argument_list|)
expr_stmt|;
block|}
comment|/* Resolve duplicate identifier with Joliet Volume. */
name|idr_resolve
argument_list|(
name|idr
argument_list|,
name|idr_set_num_beutf16
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This comparing rule is according to ISO9660 Standard 9.3  */
end_comment

begin_function
specifier|static
name|int
name|isoent_cmp_iso9660_identifier
parameter_list|(
specifier|const
name|struct
name|isoent
modifier|*
name|p1
parameter_list|,
specifier|const
name|struct
name|isoent
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|int
name|cmp
decl_stmt|;
name|int
name|l
decl_stmt|;
name|s1
operator|=
name|p1
operator|->
name|identifier
expr_stmt|;
name|s2
operator|=
name|p2
operator|->
name|identifier
expr_stmt|;
comment|/* Compare File Name */
name|l
operator|=
name|p1
operator|->
name|ext_off
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|p2
operator|->
name|ext_off
condition|)
name|l
operator|=
name|p2
operator|->
name|ext_off
expr_stmt|;
name|cmp
operator|=
name|memcmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
return|return
operator|(
name|cmp
operator|)
return|;
if|if
condition|(
name|p1
operator|->
name|ext_off
operator|<
name|p2
operator|->
name|ext_off
condition|)
block|{
name|s2
operator|+=
name|l
expr_stmt|;
name|l
operator|=
name|p2
operator|->
name|ext_off
operator|-
name|p1
operator|->
name|ext_off
expr_stmt|;
while|while
condition|(
name|l
operator|--
condition|)
if|if
condition|(
literal|0x20
operator|!=
operator|*
name|s2
operator|++
condition|)
return|return
operator|(
literal|0x20
operator|-
operator|*
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|(
name|s2
operator|-
literal|1
operator|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|p1
operator|->
name|ext_off
operator|>
name|p2
operator|->
name|ext_off
condition|)
block|{
name|s1
operator|+=
name|l
expr_stmt|;
name|l
operator|=
name|p1
operator|->
name|ext_off
operator|-
name|p2
operator|->
name|ext_off
expr_stmt|;
while|while
condition|(
name|l
operator|--
condition|)
if|if
condition|(
literal|0x20
operator|!=
operator|*
name|s1
operator|++
condition|)
return|return
operator|(
operator|*
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|(
name|s1
operator|-
literal|1
operator|)
operator|-
literal|0x20
operator|)
return|;
block|}
comment|/* Compare File Name Extension */
if|if
condition|(
name|p1
operator|->
name|ext_len
operator|==
literal|0
operator|&&
name|p2
operator|->
name|ext_len
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|p1
operator|->
name|ext_len
operator|==
literal|1
operator|&&
name|p2
operator|->
name|ext_len
operator|==
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|p1
operator|->
name|ext_len
operator|<=
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|p2
operator|->
name|ext_len
operator|<=
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|l
operator|=
name|p1
operator|->
name|ext_len
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|p2
operator|->
name|ext_len
condition|)
name|l
operator|=
name|p2
operator|->
name|ext_len
expr_stmt|;
name|s1
operator|=
name|p1
operator|->
name|identifier
operator|+
name|p1
operator|->
name|ext_off
expr_stmt|;
name|s2
operator|=
name|p2
operator|->
name|identifier
operator|+
name|p2
operator|->
name|ext_off
expr_stmt|;
if|if
condition|(
name|l
operator|>
literal|1
condition|)
block|{
name|cmp
operator|=
name|memcmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
return|return
operator|(
name|cmp
operator|)
return|;
block|}
if|if
condition|(
name|p1
operator|->
name|ext_len
operator|<
name|p2
operator|->
name|ext_len
condition|)
block|{
name|s2
operator|+=
name|l
expr_stmt|;
name|l
operator|=
name|p2
operator|->
name|ext_len
operator|-
name|p1
operator|->
name|ext_len
expr_stmt|;
while|while
condition|(
name|l
operator|--
condition|)
if|if
condition|(
literal|0x20
operator|!=
operator|*
name|s2
operator|++
condition|)
return|return
operator|(
literal|0x20
operator|-
operator|*
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|(
name|s2
operator|-
literal|1
operator|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|p1
operator|->
name|ext_len
operator|>
name|p2
operator|->
name|ext_len
condition|)
block|{
name|s1
operator|+=
name|l
expr_stmt|;
name|l
operator|=
name|p1
operator|->
name|ext_len
operator|-
name|p2
operator|->
name|ext_len
expr_stmt|;
while|while
condition|(
name|l
operator|--
condition|)
if|if
condition|(
literal|0x20
operator|!=
operator|*
name|s1
operator|++
condition|)
return|return
operator|(
operator|*
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|(
name|s1
operator|-
literal|1
operator|)
operator|-
literal|0x20
operator|)
return|;
block|}
comment|/* Compare File Version Number */
comment|/* No operation. The File Version Number is always one. */
return|return
operator|(
name|cmp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isoent_cmp_node_iso9660
parameter_list|(
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|n1
parameter_list|,
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|n2
parameter_list|)
block|{
specifier|const
name|struct
name|idrent
modifier|*
name|e1
init|=
operator|(
specifier|const
expr|struct
name|idrent
operator|*
operator|)
name|n1
decl_stmt|;
specifier|const
name|struct
name|idrent
modifier|*
name|e2
init|=
operator|(
specifier|const
expr|struct
name|idrent
operator|*
operator|)
name|n2
decl_stmt|;
return|return
operator|(
name|isoent_cmp_iso9660_identifier
argument_list|(
name|e2
operator|->
name|isoent
argument_list|,
name|e1
operator|->
name|isoent
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isoent_cmp_key_iso9660
parameter_list|(
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|node
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|)
block|{
specifier|const
name|struct
name|isoent
modifier|*
name|isoent
init|=
operator|(
specifier|const
expr|struct
name|isoent
operator|*
operator|)
name|key
decl_stmt|;
specifier|const
name|struct
name|idrent
modifier|*
name|idrent
init|=
operator|(
specifier|const
expr|struct
name|idrent
operator|*
operator|)
name|node
decl_stmt|;
return|return
operator|(
name|isoent_cmp_iso9660_identifier
argument_list|(
name|isoent
argument_list|,
name|idrent
operator|->
name|isoent
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isoent_cmp_joliet_identifier
parameter_list|(
specifier|const
name|struct
name|isoent
modifier|*
name|p1
parameter_list|,
specifier|const
name|struct
name|isoent
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|int
name|cmp
decl_stmt|;
name|int
name|l
decl_stmt|;
name|s1
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|p1
operator|->
name|identifier
expr_stmt|;
name|s2
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|p2
operator|->
name|identifier
expr_stmt|;
comment|/* Compare File Name */
name|l
operator|=
name|p1
operator|->
name|ext_off
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|p2
operator|->
name|ext_off
condition|)
name|l
operator|=
name|p2
operator|->
name|ext_off
expr_stmt|;
name|cmp
operator|=
name|memcmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
return|return
operator|(
name|cmp
operator|)
return|;
if|if
condition|(
name|p1
operator|->
name|ext_off
operator|<
name|p2
operator|->
name|ext_off
condition|)
block|{
name|s2
operator|+=
name|l
expr_stmt|;
name|l
operator|=
name|p2
operator|->
name|ext_off
operator|-
name|p1
operator|->
name|ext_off
expr_stmt|;
while|while
condition|(
name|l
operator|--
condition|)
if|if
condition|(
literal|0
operator|!=
operator|*
name|s2
operator|++
condition|)
return|return
operator|(
operator|-
operator|*
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|(
name|s2
operator|-
literal|1
operator|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|p1
operator|->
name|ext_off
operator|>
name|p2
operator|->
name|ext_off
condition|)
block|{
name|s1
operator|+=
name|l
expr_stmt|;
name|l
operator|=
name|p1
operator|->
name|ext_off
operator|-
name|p2
operator|->
name|ext_off
expr_stmt|;
while|while
condition|(
name|l
operator|--
condition|)
if|if
condition|(
literal|0
operator|!=
operator|*
name|s1
operator|++
condition|)
return|return
operator|(
operator|*
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|(
name|s1
operator|-
literal|1
operator|)
operator|)
return|;
block|}
comment|/* Compare File Name Extension */
if|if
condition|(
name|p1
operator|->
name|ext_len
operator|==
literal|0
operator|&&
name|p2
operator|->
name|ext_len
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|p1
operator|->
name|ext_len
operator|==
literal|2
operator|&&
name|p2
operator|->
name|ext_len
operator|==
literal|2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|p1
operator|->
name|ext_len
operator|<=
literal|2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|p2
operator|->
name|ext_len
operator|<=
literal|2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|l
operator|=
name|p1
operator|->
name|ext_len
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|p2
operator|->
name|ext_len
condition|)
name|l
operator|=
name|p2
operator|->
name|ext_len
expr_stmt|;
name|s1
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|p1
operator|->
name|identifier
operator|+
name|p1
operator|->
name|ext_off
operator|)
expr_stmt|;
name|s2
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|p2
operator|->
name|identifier
operator|+
name|p2
operator|->
name|ext_off
operator|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
literal|1
condition|)
block|{
name|cmp
operator|=
name|memcmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
return|return
operator|(
name|cmp
operator|)
return|;
block|}
if|if
condition|(
name|p1
operator|->
name|ext_len
operator|<
name|p2
operator|->
name|ext_len
condition|)
block|{
name|s2
operator|+=
name|l
expr_stmt|;
name|l
operator|=
name|p2
operator|->
name|ext_len
operator|-
name|p1
operator|->
name|ext_len
expr_stmt|;
while|while
condition|(
name|l
operator|--
condition|)
if|if
condition|(
literal|0
operator|!=
operator|*
name|s2
operator|++
condition|)
return|return
operator|(
operator|-
operator|*
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|(
name|s2
operator|-
literal|1
operator|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|p1
operator|->
name|ext_len
operator|>
name|p2
operator|->
name|ext_len
condition|)
block|{
name|s1
operator|+=
name|l
expr_stmt|;
name|l
operator|=
name|p1
operator|->
name|ext_len
operator|-
name|p2
operator|->
name|ext_len
expr_stmt|;
while|while
condition|(
name|l
operator|--
condition|)
if|if
condition|(
literal|0
operator|!=
operator|*
name|s1
operator|++
condition|)
return|return
operator|(
operator|*
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|(
name|s1
operator|-
literal|1
operator|)
operator|)
return|;
block|}
comment|/* Compare File Version Number */
comment|/* No operation. The File Version Number is always one. */
return|return
operator|(
name|cmp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isoent_cmp_node_joliet
parameter_list|(
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|n1
parameter_list|,
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|n2
parameter_list|)
block|{
specifier|const
name|struct
name|idrent
modifier|*
name|e1
init|=
operator|(
specifier|const
expr|struct
name|idrent
operator|*
operator|)
name|n1
decl_stmt|;
specifier|const
name|struct
name|idrent
modifier|*
name|e2
init|=
operator|(
specifier|const
expr|struct
name|idrent
operator|*
operator|)
name|n2
decl_stmt|;
return|return
operator|(
name|isoent_cmp_joliet_identifier
argument_list|(
name|e2
operator|->
name|isoent
argument_list|,
name|e1
operator|->
name|isoent
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isoent_cmp_key_joliet
parameter_list|(
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|node
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|)
block|{
specifier|const
name|struct
name|isoent
modifier|*
name|isoent
init|=
operator|(
specifier|const
expr|struct
name|isoent
operator|*
operator|)
name|key
decl_stmt|;
specifier|const
name|struct
name|idrent
modifier|*
name|idrent
init|=
operator|(
specifier|const
expr|struct
name|idrent
operator|*
operator|)
name|node
decl_stmt|;
return|return
operator|(
name|isoent_cmp_joliet_identifier
argument_list|(
name|isoent
argument_list|,
name|idrent
operator|->
name|isoent
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isoent_make_sorted_files
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|isoent
modifier|*
name|isoent
parameter_list|,
name|struct
name|idr
modifier|*
name|idr
parameter_list|)
block|{
name|struct
name|archive_rb_node
modifier|*
name|rn
decl_stmt|;
name|struct
name|isoent
modifier|*
modifier|*
name|children
decl_stmt|;
name|children
operator|=
name|malloc
argument_list|(
name|isoent
operator|->
name|children
operator|.
name|cnt
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|isoent
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|children
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|isoent
operator|->
name|children_sorted
operator|=
name|children
expr_stmt|;
name|ARCHIVE_RB_TREE_FOREACH
argument_list|(
argument|rn
argument_list|,
argument|&(idr->rbtree)
argument_list|)
block|{
name|struct
name|idrent
modifier|*
name|idrent
init|=
operator|(
expr|struct
name|idrent
operator|*
operator|)
name|rn
decl_stmt|;
operator|*
name|children
operator|++
operator|=
name|idrent
operator|->
name|isoent
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * - Generate ISO9660 and Joliet identifiers from basenames.  * - Sort files by each directory.  */
end_comment

begin_function
specifier|static
name|int
name|isoent_traverse_tree
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|vdd
modifier|*
name|vdd
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|struct
name|isoent
modifier|*
name|np
decl_stmt|;
name|struct
name|idr
name|idr
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|int
name|r
decl_stmt|;
name|int
function_decl|(
modifier|*
name|genid
function_decl|)
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|isoent
modifier|*
parameter_list|,
name|struct
name|idr
modifier|*
parameter_list|)
function_decl|;
name|idr_init
argument_list|(
name|iso9660
argument_list|,
name|vdd
argument_list|,
operator|&
name|idr
argument_list|)
expr_stmt|;
name|np
operator|=
name|vdd
operator|->
name|rootent
expr_stmt|;
name|depth
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vdd
operator|->
name|vdd_type
operator|==
name|VDD_JOLIET
condition|)
name|genid
operator|=
name|isoent_gen_joliet_identifier
expr_stmt|;
else|else
name|genid
operator|=
name|isoent_gen_iso9660_identifier
expr_stmt|;
do|do
block|{
if|if
condition|(
name|np
operator|->
name|virtual
operator|&&
operator|!
name|archive_entry_mtime_is_set
argument_list|(
name|np
operator|->
name|file
operator|->
name|entry
argument_list|)
condition|)
block|{
comment|/* Set properly times to virtual directory */
name|archive_entry_set_mtime
argument_list|(
name|np
operator|->
name|file
operator|->
name|entry
argument_list|,
name|iso9660
operator|->
name|birth_time
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|archive_entry_set_atime
argument_list|(
name|np
operator|->
name|file
operator|->
name|entry
argument_list|,
name|iso9660
operator|->
name|birth_time
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|archive_entry_set_ctime
argument_list|(
name|np
operator|->
name|file
operator|->
name|entry
argument_list|,
name|iso9660
operator|->
name|birth_time
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|np
operator|->
name|children
operator|.
name|first
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|vdd
operator|->
name|vdd_type
operator|!=
name|VDD_JOLIET
operator|&&
operator|!
name|iso9660
operator|->
name|opt
operator|.
name|rr
operator|&&
name|depth
operator|+
literal|1
operator|>=
name|vdd
operator|->
name|max_depth
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|children
operator|.
name|cnt
operator|>
literal|0
condition|)
name|iso9660
operator|->
name|directories_too_deep
operator|=
name|np
expr_stmt|;
block|}
else|else
block|{
comment|/* Generate Identifier */
name|r
operator|=
name|genid
argument_list|(
name|a
argument_list|,
name|np
argument_list|,
operator|&
name|idr
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
goto|goto
name|exit_traverse_tree
goto|;
name|r
operator|=
name|isoent_make_sorted_files
argument_list|(
name|a
argument_list|,
name|np
argument_list|,
operator|&
name|idr
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
goto|goto
name|exit_traverse_tree
goto|;
if|if
condition|(
name|np
operator|->
name|subdirs
operator|.
name|first
operator|!=
name|NULL
operator|&&
name|depth
operator|+
literal|1
operator|<
name|vdd
operator|->
name|max_depth
condition|)
block|{
comment|/* Enter to sub directories. */
name|np
operator|=
name|np
operator|->
name|subdirs
operator|.
name|first
expr_stmt|;
name|depth
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
block|}
while|while
condition|(
name|np
operator|!=
name|np
operator|->
name|parent
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|drnext
operator|==
name|NULL
condition|)
block|{
comment|/* Return to the parent directory. */
name|np
operator|=
name|np
operator|->
name|parent
expr_stmt|;
name|depth
operator|--
expr_stmt|;
block|}
else|else
block|{
name|np
operator|=
name|np
operator|->
name|drnext
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|np
operator|!=
name|np
operator|->
name|parent
condition|)
do|;
name|r
operator|=
name|ARCHIVE_OK
expr_stmt|;
name|exit_traverse_tree
label|:
name|idr_cleanup
argument_list|(
operator|&
name|idr
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Collect directory entries into path_table by a directory depth.  */
end_comment

begin_function
specifier|static
name|int
name|isoent_collect_dirs
parameter_list|(
name|struct
name|vdd
modifier|*
name|vdd
parameter_list|,
name|struct
name|isoent
modifier|*
name|rootent
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|struct
name|isoent
modifier|*
name|np
decl_stmt|;
if|if
condition|(
name|rootent
operator|==
name|NULL
condition|)
name|rootent
operator|=
name|vdd
operator|->
name|rootent
expr_stmt|;
name|np
operator|=
name|rootent
expr_stmt|;
do|do
block|{
comment|/* Register current directory to pathtable. */
name|path_table_add_entry
argument_list|(
operator|&
operator|(
name|vdd
operator|->
name|pathtbl
index|[
name|depth
index|]
operator|)
argument_list|,
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|subdirs
operator|.
name|first
operator|!=
name|NULL
operator|&&
name|depth
operator|+
literal|1
operator|<
name|vdd
operator|->
name|max_depth
condition|)
block|{
comment|/* Enter to sub directories. */
name|np
operator|=
name|np
operator|->
name|subdirs
operator|.
name|first
expr_stmt|;
name|depth
operator|++
expr_stmt|;
continue|continue;
block|}
while|while
condition|(
name|np
operator|!=
name|rootent
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|drnext
operator|==
name|NULL
condition|)
block|{
comment|/* Return to the parent directory. */
name|np
operator|=
name|np
operator|->
name|parent
expr_stmt|;
name|depth
operator|--
expr_stmt|;
block|}
else|else
block|{
name|np
operator|=
name|np
operator|->
name|drnext
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|np
operator|!=
name|rootent
condition|)
do|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The entry whose number of levels in a directory hierarchy is  * large than eight relocate to rr_move directory.  */
end_comment

begin_function
specifier|static
name|int
name|isoent_rr_move_dir
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|isoent
modifier|*
modifier|*
name|rr_moved
parameter_list|,
name|struct
name|isoent
modifier|*
name|curent
parameter_list|,
name|struct
name|isoent
modifier|*
modifier|*
name|newent
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|struct
name|isoent
modifier|*
name|rrmoved
decl_stmt|,
modifier|*
name|mvent
decl_stmt|,
modifier|*
name|np
decl_stmt|;
if|if
condition|(
operator|(
name|rrmoved
operator|=
operator|*
name|rr_moved
operator|)
operator|==
name|NULL
condition|)
block|{
name|struct
name|isoent
modifier|*
name|rootent
init|=
name|iso9660
operator|->
name|primary
operator|.
name|rootent
decl_stmt|;
comment|/* There isn't rr_move entry. 		 * Create rr_move entry and insert it into the root entry. 		 */
name|rrmoved
operator|=
name|isoent_create_virtual_dir
argument_list|(
name|a
argument_list|,
name|iso9660
argument_list|,
literal|"rr_moved"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrmoved
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Add "rr_moved" entry to the root entry. */
name|isoent_add_child_head
argument_list|(
name|rootent
argument_list|,
name|rrmoved
argument_list|)
expr_stmt|;
name|archive_entry_set_nlink
argument_list|(
name|rootent
operator|->
name|file
operator|->
name|entry
argument_list|,
name|archive_entry_nlink
argument_list|(
name|rootent
operator|->
name|file
operator|->
name|entry
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Register "rr_moved" entry to second level pathtable. */
name|path_table_add_entry
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|primary
operator|.
name|pathtbl
index|[
literal|1
index|]
operator|)
argument_list|,
name|rrmoved
argument_list|)
expr_stmt|;
comment|/* Save rr_moved. */
operator|*
name|rr_moved
operator|=
name|rrmoved
expr_stmt|;
block|}
comment|/* 	 * Make a clone of curent which is going to be relocated 	 * to rr_moved. 	 */
name|mvent
operator|=
name|isoent_clone
argument_list|(
name|curent
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvent
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* linking..  and use for creating "CL", "PL" and "RE" */
name|mvent
operator|->
name|rr_parent
operator|=
name|curent
operator|->
name|parent
expr_stmt|;
name|curent
operator|->
name|rr_child
operator|=
name|mvent
expr_stmt|;
comment|/* 	 * Move subdirectories from the curent to mvent 	 */
if|if
condition|(
name|curent
operator|->
name|children
operator|.
name|first
operator|!=
name|NULL
condition|)
block|{
operator|*
name|mvent
operator|->
name|children
operator|.
name|last
operator|=
name|curent
operator|->
name|children
operator|.
name|first
expr_stmt|;
name|mvent
operator|->
name|children
operator|.
name|last
operator|=
name|curent
operator|->
name|children
operator|.
name|last
expr_stmt|;
block|}
for|for
control|(
name|np
operator|=
name|mvent
operator|->
name|children
operator|.
name|first
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|chnext
control|)
name|np
operator|->
name|parent
operator|=
name|mvent
expr_stmt|;
name|mvent
operator|->
name|children
operator|.
name|cnt
operator|=
name|curent
operator|->
name|children
operator|.
name|cnt
expr_stmt|;
name|curent
operator|->
name|children
operator|.
name|cnt
operator|=
literal|0
expr_stmt|;
name|curent
operator|->
name|children
operator|.
name|first
operator|=
name|NULL
expr_stmt|;
name|curent
operator|->
name|children
operator|.
name|last
operator|=
operator|&
name|curent
operator|->
name|children
operator|.
name|first
expr_stmt|;
if|if
condition|(
name|curent
operator|->
name|subdirs
operator|.
name|first
operator|!=
name|NULL
condition|)
block|{
operator|*
name|mvent
operator|->
name|subdirs
operator|.
name|last
operator|=
name|curent
operator|->
name|subdirs
operator|.
name|first
expr_stmt|;
name|mvent
operator|->
name|subdirs
operator|.
name|last
operator|=
name|curent
operator|->
name|subdirs
operator|.
name|last
expr_stmt|;
block|}
name|mvent
operator|->
name|subdirs
operator|.
name|cnt
operator|=
name|curent
operator|->
name|subdirs
operator|.
name|cnt
expr_stmt|;
name|curent
operator|->
name|subdirs
operator|.
name|cnt
operator|=
literal|0
expr_stmt|;
name|curent
operator|->
name|subdirs
operator|.
name|first
operator|=
name|NULL
expr_stmt|;
name|curent
operator|->
name|subdirs
operator|.
name|last
operator|=
operator|&
name|curent
operator|->
name|subdirs
operator|.
name|first
expr_stmt|;
comment|/* 	 * The mvent becomes a child of the rr_moved entry. 	 */
name|isoent_add_child_tail
argument_list|(
name|rrmoved
argument_list|,
name|mvent
argument_list|)
expr_stmt|;
name|archive_entry_set_nlink
argument_list|(
name|rrmoved
operator|->
name|file
operator|->
name|entry
argument_list|,
name|archive_entry_nlink
argument_list|(
name|rrmoved
operator|->
name|file
operator|->
name|entry
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * This entry which relocated to the rr_moved directory 	 * has to set the flag as a file. 	 * See also RRIP 4.1.5.1 Description of the "CL" System Use Entry. 	 */
name|curent
operator|->
name|dir
operator|=
literal|0
expr_stmt|;
operator|*
name|newent
operator|=
name|mvent
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isoent_rr_move
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|struct
name|path_table
modifier|*
name|pt
decl_stmt|;
name|struct
name|isoent
modifier|*
name|rootent
decl_stmt|,
modifier|*
name|rr_moved
decl_stmt|;
name|struct
name|isoent
modifier|*
name|np
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|int
name|r
decl_stmt|;
name|pt
operator|=
operator|&
operator|(
name|iso9660
operator|->
name|primary
operator|.
name|pathtbl
index|[
name|MAX_DEPTH
operator|-
literal|1
index|]
operator|)
expr_stmt|;
comment|/* Theare aren't level 8 directories reaching a deepr level. */
if|if
condition|(
name|pt
operator|->
name|cnt
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
name|rootent
operator|=
name|iso9660
operator|->
name|primary
operator|.
name|rootent
expr_stmt|;
comment|/* If "rr_moved" directory is already existing, 	 * we have to use it. */
name|rr_moved
operator|=
name|isoent_find_child
argument_list|(
name|rootent
argument_list|,
literal|"rr_moved"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rr_moved
operator|!=
name|NULL
operator|&&
name|rr_moved
operator|!=
name|rootent
operator|->
name|children
operator|.
name|first
condition|)
block|{
comment|/* 		 * It's necessary that rr_move is the first entry 		 * of the root. 		 */
comment|/* Remove "rr_moved" entry from children chain. */
name|isoent_remove_child
argument_list|(
name|rootent
argument_list|,
name|rr_moved
argument_list|)
expr_stmt|;
comment|/* Add "rr_moved" entry into the head of children chain. */
name|isoent_add_child_head
argument_list|(
name|rootent
argument_list|,
name|rr_moved
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check level 8 path_table. 	 * If find out sub directory entries, that entries move to rr_move. 	 */
name|np
operator|=
name|pt
operator|->
name|first
expr_stmt|;
while|while
condition|(
name|np
operator|!=
name|NULL
condition|)
block|{
name|last
operator|=
name|path_table_last_entry
argument_list|(
name|pt
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|ptnext
control|)
block|{
name|struct
name|isoent
modifier|*
name|mvent
decl_stmt|;
name|struct
name|isoent
modifier|*
name|newent
decl_stmt|;
if|if
condition|(
operator|!
name|np
operator|->
name|dir
condition|)
continue|continue;
for|for
control|(
name|mvent
operator|=
name|np
operator|->
name|subdirs
operator|.
name|first
init|;
name|mvent
operator|!=
name|NULL
condition|;
name|mvent
operator|=
name|mvent
operator|->
name|drnext
control|)
block|{
name|r
operator|=
name|isoent_rr_move_dir
argument_list|(
name|a
argument_list|,
operator|&
name|rr_moved
argument_list|,
name|mvent
argument_list|,
operator|&
name|newent
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|isoent_collect_dirs
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|primary
operator|)
argument_list|,
name|newent
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If new entries are added to level 8 path_talbe, 		 * its sub directory entries move to rr_move too. 		 */
name|np
operator|=
name|last
operator|->
name|ptnext
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This comparing rule is according to ISO9660 Standard 6.9.1  */
end_comment

begin_function
specifier|static
name|int
name|_compare_path_table
parameter_list|(
specifier|const
name|void
modifier|*
name|v1
parameter_list|,
specifier|const
name|void
modifier|*
name|v2
parameter_list|)
block|{
specifier|const
name|struct
name|isoent
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|const
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|int
name|cmp
decl_stmt|,
name|l
decl_stmt|;
name|p1
operator|=
operator|*
operator|(
operator|(
specifier|const
expr|struct
name|isoent
operator|*
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|v1
operator|)
expr_stmt|;
name|p2
operator|=
operator|*
operator|(
operator|(
specifier|const
expr|struct
name|isoent
operator|*
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|v2
operator|)
expr_stmt|;
comment|/* Compare parent directory number */
name|cmp
operator|=
name|p1
operator|->
name|parent
operator|->
name|dir_number
operator|-
name|p2
operator|->
name|parent
operator|->
name|dir_number
expr_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
return|return
operator|(
name|cmp
operator|)
return|;
comment|/* Compare indetifier */
name|s1
operator|=
name|p1
operator|->
name|identifier
expr_stmt|;
name|s2
operator|=
name|p2
operator|->
name|identifier
expr_stmt|;
name|l
operator|=
name|p1
operator|->
name|ext_off
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|p2
operator|->
name|ext_off
condition|)
name|l
operator|=
name|p2
operator|->
name|ext_off
expr_stmt|;
name|cmp
operator|=
name|strncmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
return|return
operator|(
name|cmp
operator|)
return|;
if|if
condition|(
name|p1
operator|->
name|ext_off
operator|<
name|p2
operator|->
name|ext_off
condition|)
block|{
name|s2
operator|+=
name|l
expr_stmt|;
name|l
operator|=
name|p2
operator|->
name|ext_off
operator|-
name|p1
operator|->
name|ext_off
expr_stmt|;
while|while
condition|(
name|l
operator|--
condition|)
if|if
condition|(
literal|0x20
operator|!=
operator|*
name|s2
operator|++
condition|)
return|return
operator|(
literal|0x20
operator|-
operator|*
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|(
name|s2
operator|-
literal|1
operator|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|p1
operator|->
name|ext_off
operator|>
name|p2
operator|->
name|ext_off
condition|)
block|{
name|s1
operator|+=
name|l
expr_stmt|;
name|l
operator|=
name|p1
operator|->
name|ext_off
operator|-
name|p2
operator|->
name|ext_off
expr_stmt|;
while|while
condition|(
name|l
operator|--
condition|)
if|if
condition|(
literal|0x20
operator|!=
operator|*
name|s1
operator|++
condition|)
return|return
operator|(
operator|*
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|(
name|s1
operator|-
literal|1
operator|)
operator|-
literal|0x20
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_compare_path_table_joliet
parameter_list|(
specifier|const
name|void
modifier|*
name|v1
parameter_list|,
specifier|const
name|void
modifier|*
name|v2
parameter_list|)
block|{
specifier|const
name|struct
name|isoent
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|int
name|cmp
decl_stmt|,
name|l
decl_stmt|;
name|p1
operator|=
operator|*
operator|(
operator|(
specifier|const
expr|struct
name|isoent
operator|*
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|v1
operator|)
expr_stmt|;
name|p2
operator|=
operator|*
operator|(
operator|(
specifier|const
expr|struct
name|isoent
operator|*
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|v2
operator|)
expr_stmt|;
comment|/* Compare parent directory number */
name|cmp
operator|=
name|p1
operator|->
name|parent
operator|->
name|dir_number
operator|-
name|p2
operator|->
name|parent
operator|->
name|dir_number
expr_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
return|return
operator|(
name|cmp
operator|)
return|;
comment|/* Compare indetifier */
name|s1
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|p1
operator|->
name|identifier
expr_stmt|;
name|s2
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|p2
operator|->
name|identifier
expr_stmt|;
name|l
operator|=
name|p1
operator|->
name|ext_off
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|p2
operator|->
name|ext_off
condition|)
name|l
operator|=
name|p2
operator|->
name|ext_off
expr_stmt|;
name|cmp
operator|=
name|memcmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
return|return
operator|(
name|cmp
operator|)
return|;
if|if
condition|(
name|p1
operator|->
name|ext_off
operator|<
name|p2
operator|->
name|ext_off
condition|)
block|{
name|s2
operator|+=
name|l
expr_stmt|;
name|l
operator|=
name|p2
operator|->
name|ext_off
operator|-
name|p1
operator|->
name|ext_off
expr_stmt|;
while|while
condition|(
name|l
operator|--
condition|)
if|if
condition|(
literal|0
operator|!=
operator|*
name|s2
operator|++
condition|)
return|return
operator|(
operator|-
operator|*
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|(
name|s2
operator|-
literal|1
operator|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|p1
operator|->
name|ext_off
operator|>
name|p2
operator|->
name|ext_off
condition|)
block|{
name|s1
operator|+=
name|l
expr_stmt|;
name|l
operator|=
name|p1
operator|->
name|ext_off
operator|-
name|p2
operator|->
name|ext_off
expr_stmt|;
while|while
condition|(
name|l
operator|--
condition|)
if|if
condition|(
literal|0
operator|!=
operator|*
name|s1
operator|++
condition|)
return|return
operator|(
operator|*
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|(
name|s1
operator|-
literal|1
operator|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|path_table_add_entry
parameter_list|(
name|struct
name|path_table
modifier|*
name|pathtbl
parameter_list|,
name|struct
name|isoent
modifier|*
name|ent
parameter_list|)
block|{
name|ent
operator|->
name|ptnext
operator|=
name|NULL
expr_stmt|;
operator|*
name|pathtbl
operator|->
name|last
operator|=
name|ent
expr_stmt|;
name|pathtbl
operator|->
name|last
operator|=
operator|&
operator|(
name|ent
operator|->
name|ptnext
operator|)
expr_stmt|;
name|pathtbl
operator|->
name|cnt
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|isoent
modifier|*
name|path_table_last_entry
parameter_list|(
name|struct
name|path_table
modifier|*
name|pathtbl
parameter_list|)
block|{
if|if
condition|(
name|pathtbl
operator|->
name|first
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
operator|(
operator|(
expr|struct
name|isoent
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|pathtbl
operator|->
name|last
operator|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|isoent
argument_list|,
name|ptnext
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sort directory entries in path_table  * and assign directory number to each entries.  */
end_comment

begin_function
specifier|static
name|int
name|isoent_make_path_table_2
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|vdd
modifier|*
name|vdd
parameter_list|,
name|int
name|depth
parameter_list|,
name|int
modifier|*
name|dir_number
parameter_list|)
block|{
name|struct
name|isoent
modifier|*
name|np
decl_stmt|;
name|struct
name|isoent
modifier|*
modifier|*
name|enttbl
decl_stmt|;
name|struct
name|path_table
modifier|*
name|pt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pt
operator|=
operator|&
name|vdd
operator|->
name|pathtbl
index|[
name|depth
index|]
expr_stmt|;
if|if
condition|(
name|pt
operator|->
name|cnt
operator|==
literal|0
condition|)
block|{
name|pt
operator|->
name|sorted
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
name|enttbl
operator|=
name|malloc
argument_list|(
name|pt
operator|->
name|cnt
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|isoent
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|enttbl
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|pt
operator|->
name|sorted
operator|=
name|enttbl
expr_stmt|;
for|for
control|(
name|np
operator|=
name|pt
operator|->
name|first
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|ptnext
control|)
operator|*
name|enttbl
operator|++
operator|=
name|np
expr_stmt|;
name|enttbl
operator|=
name|pt
operator|->
name|sorted
expr_stmt|;
switch|switch
condition|(
name|vdd
operator|->
name|vdd_type
condition|)
block|{
case|case
name|VDD_PRIMARY
case|:
case|case
name|VDD_ENHANCED
case|:
ifdef|#
directive|ifdef
name|__COMPAR_FN_T
name|qsort
argument_list|(
name|enttbl
argument_list|,
name|pt
operator|->
name|cnt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|isoent
operator|*
argument_list|)
argument_list|,
operator|(
name|__compar_fn_t
operator|)
name|_compare_path_table
argument_list|)
expr_stmt|;
else|#
directive|else
name|qsort
argument_list|(
name|enttbl
argument_list|,
name|pt
operator|->
name|cnt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|isoent
operator|*
argument_list|)
argument_list|,
name|_compare_path_table
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|VDD_JOLIET
case|:
ifdef|#
directive|ifdef
name|__COMPAR_FN_T
name|qsort
argument_list|(
name|enttbl
argument_list|,
name|pt
operator|->
name|cnt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|isoent
operator|*
argument_list|)
argument_list|,
operator|(
name|__compar_fn_t
operator|)
name|_compare_path_table_joliet
argument_list|)
expr_stmt|;
else|#
directive|else
name|qsort
argument_list|(
name|enttbl
argument_list|,
name|pt
operator|->
name|cnt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|isoent
operator|*
argument_list|)
argument_list|,
name|_compare_path_table_joliet
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pt
operator|->
name|cnt
condition|;
name|i
operator|++
control|)
name|enttbl
index|[
name|i
index|]
operator|->
name|dir_number
operator|=
operator|(
operator|*
name|dir_number
operator|)
operator|++
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isoent_alloc_path_table
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|vdd
modifier|*
name|vdd
parameter_list|,
name|int
name|max_depth
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|vdd
operator|->
name|max_depth
operator|=
name|max_depth
expr_stmt|;
name|vdd
operator|->
name|pathtbl
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vdd
operator|->
name|pathtbl
argument_list|)
operator|*
name|vdd
operator|->
name|max_depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdd
operator|->
name|pathtbl
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vdd
operator|->
name|max_depth
condition|;
name|i
operator|++
control|)
block|{
name|vdd
operator|->
name|pathtbl
index|[
name|i
index|]
operator|.
name|first
operator|=
name|NULL
expr_stmt|;
name|vdd
operator|->
name|pathtbl
index|[
name|i
index|]
operator|.
name|last
operator|=
operator|&
operator|(
name|vdd
operator|->
name|pathtbl
index|[
name|i
index|]
operator|.
name|first
operator|)
expr_stmt|;
name|vdd
operator|->
name|pathtbl
index|[
name|i
index|]
operator|.
name|sorted
operator|=
name|NULL
expr_stmt|;
name|vdd
operator|->
name|pathtbl
index|[
name|i
index|]
operator|.
name|cnt
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make Path Tables  */
end_comment

begin_function
specifier|static
name|int
name|isoent_make_path_table
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|int
name|depth
decl_stmt|,
name|r
decl_stmt|;
name|int
name|dir_number
decl_stmt|;
comment|/* 	 * Init Path Table. 	 */
if|if
condition|(
name|iso9660
operator|->
name|dircnt_max
operator|>=
name|MAX_DEPTH
operator|&&
operator|(
operator|!
name|iso9660
operator|->
name|opt
operator|.
name|limit_depth
operator|||
name|iso9660
operator|->
name|opt
operator|.
name|iso_level
operator|==
literal|4
operator|)
condition|)
name|r
operator|=
name|isoent_alloc_path_table
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|primary
operator|)
argument_list|,
name|iso9660
operator|->
name|dircnt_max
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
comment|/* The number of levels in the hierarchy cannot exceed 		 * eight. */
name|r
operator|=
name|isoent_alloc_path_table
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|primary
operator|)
argument_list|,
name|MAX_DEPTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|joliet
condition|)
block|{
name|r
operator|=
name|isoent_alloc_path_table
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|joliet
operator|)
argument_list|,
name|iso9660
operator|->
name|dircnt_max
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
comment|/* Step 0. 	 * - Collect directories for primary and joliet. 	 */
name|isoent_collect_dirs
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|primary
operator|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|joliet
condition|)
name|isoent_collect_dirs
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|joliet
operator|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Rockridge; move deeper depth directories to rr_moved. 	 */
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|rr
condition|)
block|{
name|r
operator|=
name|isoent_rr_move
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
comment|/* Update nlink. */
name|isofile_connect_hardlink_files
argument_list|(
name|iso9660
argument_list|)
expr_stmt|;
comment|/* Step 1. 	 * - Renew a value of the depth of that directories. 	 * - Resolve hardlinks.  	 * - Convert pathnames to ISO9660 name or UCS2(joliet). 	 * - Sort files by each directory. 	 */
name|r
operator|=
name|isoent_traverse_tree
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|primary
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|joliet
condition|)
block|{
name|r
operator|=
name|isoent_traverse_tree
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|joliet
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
comment|/* Step 2. 	 * - Sort directories. 	 * - Assign all directory number. 	 */
name|dir_number
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|depth
operator|=
literal|0
init|;
name|depth
operator|<
name|iso9660
operator|->
name|primary
operator|.
name|max_depth
condition|;
name|depth
operator|++
control|)
block|{
name|r
operator|=
name|isoent_make_path_table_2
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|primary
operator|)
argument_list|,
name|depth
argument_list|,
operator|&
name|dir_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|joliet
condition|)
block|{
name|dir_number
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|depth
operator|=
literal|0
init|;
name|depth
operator|<
name|iso9660
operator|->
name|joliet
operator|.
name|max_depth
condition|;
name|depth
operator|++
control|)
block|{
name|r
operator|=
name|isoent_make_path_table_2
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|joliet
operator|)
argument_list|,
name|depth
argument_list|,
operator|&
name|dir_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
block|}
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|limit_dirs
operator|&&
name|dir_number
operator|>
literal|0xffff
condition|)
block|{
comment|/* 		 * Maximum number of directories is 65535(0xffff) 		 * doe to size(16bit) of Parent Directory Number of 		 * the Path Table. 		 * See also ISO9660 Standard 9.4. 		 */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Too many directories(%d) over 65535."
argument_list|,
name|dir_number
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Get the size of the Path Table. */
name|calculate_path_table_size
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|primary
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|joliet
condition|)
name|calculate_path_table_size
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|joliet
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isoent_find_out_boot_file
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|isoent
modifier|*
name|rootent
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
name|a
operator|->
name|format_data
decl_stmt|;
comment|/* Find a isoent of the boot file. */
name|iso9660
operator|->
name|el_torito
operator|.
name|boot
operator|=
name|isoent_find_entry
argument_list|(
name|rootent
argument_list|,
name|iso9660
operator|->
name|el_torito
operator|.
name|boot_filename
operator|.
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|el_torito
operator|.
name|boot
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Can't find the boot image file ``%s''"
argument_list|,
name|iso9660
operator|->
name|el_torito
operator|.
name|boot_filename
operator|.
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|iso9660
operator|->
name|el_torito
operator|.
name|boot
operator|->
name|file
operator|->
name|boot
operator|=
name|BOOT_IMAGE
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isoent_create_boot_catalog
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|isoent
modifier|*
name|rootent
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|struct
name|isofile
modifier|*
name|file
decl_stmt|;
name|struct
name|isoent
modifier|*
name|isoent
decl_stmt|;
name|struct
name|archive_entry
modifier|*
name|entry
decl_stmt|;
operator|(
name|void
operator|)
name|rootent
expr_stmt|;
comment|/* UNUSED */
comment|/* 	 * Create the entry which is the "boot.catalog" file. 	 */
name|file
operator|=
name|isofile_new
argument_list|(
name|a
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_entry_set_pathname
argument_list|(
name|file
operator|->
name|entry
argument_list|,
name|iso9660
operator|->
name|el_torito
operator|.
name|catalog_filename
operator|.
name|s
argument_list|)
expr_stmt|;
name|archive_entry_set_size
argument_list|(
name|file
operator|->
name|entry
argument_list|,
name|LOGICAL_BLOCK_SIZE
argument_list|)
expr_stmt|;
name|archive_entry_set_mtime
argument_list|(
name|file
operator|->
name|entry
argument_list|,
name|iso9660
operator|->
name|birth_time
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|archive_entry_set_atime
argument_list|(
name|file
operator|->
name|entry
argument_list|,
name|iso9660
operator|->
name|birth_time
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|archive_entry_set_ctime
argument_list|(
name|file
operator|->
name|entry
argument_list|,
name|iso9660
operator|->
name|birth_time
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|archive_entry_set_uid
argument_list|(
name|file
operator|->
name|entry
argument_list|,
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|archive_entry_set_gid
argument_list|(
name|file
operator|->
name|entry
argument_list|,
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
name|archive_entry_set_mode
argument_list|(
name|file
operator|->
name|entry
argument_list|,
name|AE_IFREG
operator||
literal|0444
argument_list|)
expr_stmt|;
name|archive_entry_set_nlink
argument_list|(
name|file
operator|->
name|entry
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|isofile_gen_utility_names
argument_list|(
name|a
argument_list|,
name|file
argument_list|)
operator|<
name|ARCHIVE_WARN
condition|)
block|{
name|isofile_free
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|file
operator|->
name|boot
operator|=
name|BOOT_CATALOG
expr_stmt|;
name|file
operator|->
name|content
operator|.
name|size
operator|=
name|LOGICAL_BLOCK_SIZE
expr_stmt|;
name|isofile_add_entry
argument_list|(
name|iso9660
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|isoent
operator|=
name|isoent_new
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|isoent
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|isoent
operator|->
name|virtual
operator|=
literal|1
expr_stmt|;
comment|/* Add the "boot.catalog" entry into tree */
if|if
condition|(
name|isoent_tree
argument_list|(
name|a
argument_list|,
operator|&
name|isoent
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|iso9660
operator|->
name|el_torito
operator|.
name|catalog
operator|=
name|isoent
expr_stmt|;
comment|/* 	 * Get a boot medai type. 	 */
switch|switch
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|boot_type
condition|)
block|{
default|default:
case|case
name|OPT_BOOT_TYPE_AUTO
case|:
comment|/* Try detecting a media type of the boot image. */
name|entry
operator|=
name|iso9660
operator|->
name|el_torito
operator|.
name|boot
operator|->
name|file
operator|->
name|entry
expr_stmt|;
if|if
condition|(
name|archive_entry_size
argument_list|(
name|entry
argument_list|)
operator|==
name|FD_1_2M_SIZE
condition|)
name|iso9660
operator|->
name|el_torito
operator|.
name|media_type
operator|=
name|BOOT_MEDIA_1_2M_DISKETTE
expr_stmt|;
elseif|else
if|if
condition|(
name|archive_entry_size
argument_list|(
name|entry
argument_list|)
operator|==
name|FD_1_44M_SIZE
condition|)
name|iso9660
operator|->
name|el_torito
operator|.
name|media_type
operator|=
name|BOOT_MEDIA_1_44M_DISKETTE
expr_stmt|;
elseif|else
if|if
condition|(
name|archive_entry_size
argument_list|(
name|entry
argument_list|)
operator|==
name|FD_2_88M_SIZE
condition|)
name|iso9660
operator|->
name|el_torito
operator|.
name|media_type
operator|=
name|BOOT_MEDIA_2_88M_DISKETTE
expr_stmt|;
else|else
comment|/* We cannot decide whether the boot image is 			 * hard-disk. */
name|iso9660
operator|->
name|el_torito
operator|.
name|media_type
operator|=
name|BOOT_MEDIA_NO_EMULATION
expr_stmt|;
break|break;
case|case
name|OPT_BOOT_TYPE_NO_EMU
case|:
name|iso9660
operator|->
name|el_torito
operator|.
name|media_type
operator|=
name|BOOT_MEDIA_NO_EMULATION
expr_stmt|;
break|break;
case|case
name|OPT_BOOT_TYPE_HARD_DISK
case|:
name|iso9660
operator|->
name|el_torito
operator|.
name|media_type
operator|=
name|BOOT_MEDIA_HARD_DISK
expr_stmt|;
break|break;
case|case
name|OPT_BOOT_TYPE_FD
case|:
name|entry
operator|=
name|iso9660
operator|->
name|el_torito
operator|.
name|boot
operator|->
name|file
operator|->
name|entry
expr_stmt|;
if|if
condition|(
name|archive_entry_size
argument_list|(
name|entry
argument_list|)
operator|<=
name|FD_1_2M_SIZE
condition|)
name|iso9660
operator|->
name|el_torito
operator|.
name|media_type
operator|=
name|BOOT_MEDIA_1_2M_DISKETTE
expr_stmt|;
elseif|else
if|if
condition|(
name|archive_entry_size
argument_list|(
name|entry
argument_list|)
operator|<=
name|FD_1_44M_SIZE
condition|)
name|iso9660
operator|->
name|el_torito
operator|.
name|media_type
operator|=
name|BOOT_MEDIA_1_44M_DISKETTE
expr_stmt|;
elseif|else
if|if
condition|(
name|archive_entry_size
argument_list|(
name|entry
argument_list|)
operator|<=
name|FD_2_88M_SIZE
condition|)
name|iso9660
operator|->
name|el_torito
operator|.
name|media_type
operator|=
name|BOOT_MEDIA_2_88M_DISKETTE
expr_stmt|;
else|else
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Boot image file(``%s'') size is too big "
literal|"for fd type."
argument_list|,
name|iso9660
operator|->
name|el_torito
operator|.
name|boot_filename
operator|.
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
break|break;
block|}
comment|/* 	 * Get a system type. 	 * TODO: `El Torito' specification says "A copy of byte 5 from the 	 *       Partition Table found in the boot image". 	 */
name|iso9660
operator|->
name|el_torito
operator|.
name|system_type
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Get an ID. 	 */
if|if
condition|(
name|iso9660
operator|->
name|opt
operator|.
name|publisher
condition|)
name|archive_string_copy
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|el_torito
operator|.
name|id
operator|)
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|publisher_identifier
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If a media type is floppy, return its image size.  * otherwise return 0.  */
end_comment

begin_function
specifier|static
name|size_t
name|fd_boot_image_size
parameter_list|(
name|int
name|media_type
parameter_list|)
block|{
switch|switch
condition|(
name|media_type
condition|)
block|{
case|case
name|BOOT_MEDIA_1_2M_DISKETTE
case|:
return|return
operator|(
name|FD_1_2M_SIZE
operator|)
return|;
case|case
name|BOOT_MEDIA_1_44M_DISKETTE
case|:
return|return
operator|(
name|FD_1_44M_SIZE
operator|)
return|;
case|case
name|BOOT_MEDIA_2_88M_DISKETTE
case|:
return|return
operator|(
name|FD_2_88M_SIZE
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Make a boot catalog image data.  */
end_comment

begin_function
specifier|static
name|int
name|make_boot_catalog
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|unsigned
name|char
modifier|*
name|block
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|uint16_t
name|sum
decl_stmt|,
modifier|*
name|wp
decl_stmt|;
name|block
operator|=
name|wb_buffptr
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|block
argument_list|,
literal|0
argument_list|,
name|LOGICAL_BLOCK_SIZE
argument_list|)
expr_stmt|;
name|p
operator|=
name|block
expr_stmt|;
comment|/* 	 * Validation Entry 	 */
comment|/* Header ID */
name|p
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Platform ID */
name|p
index|[
literal|1
index|]
operator|=
name|iso9660
operator|->
name|el_torito
operator|.
name|platform_id
expr_stmt|;
comment|/* Reserved */
name|p
index|[
literal|2
index|]
operator|=
name|p
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* ID */
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|el_torito
operator|.
name|id
operator|)
argument_list|)
operator|>
literal|0
condition|)
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|+
literal|4
argument_list|,
name|iso9660
operator|->
name|el_torito
operator|.
name|id
operator|.
name|s
argument_list|,
literal|23
argument_list|)
expr_stmt|;
name|p
index|[
literal|27
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Checksum */
name|p
index|[
literal|28
index|]
operator|=
name|p
index|[
literal|29
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Key */
name|p
index|[
literal|30
index|]
operator|=
literal|0x55
expr_stmt|;
name|p
index|[
literal|31
index|]
operator|=
literal|0xAA
expr_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
name|wp
operator|=
operator|(
name|uint16_t
operator|*
operator|)
name|block
expr_stmt|;
while|while
condition|(
name|wp
operator|<
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|block
index|[
literal|32
index|]
condition|)
name|sum
operator|+=
name|archive_le16dec
argument_list|(
name|wp
operator|++
argument_list|)
expr_stmt|;
name|set_num_721
argument_list|(
operator|&
name|block
index|[
literal|28
index|]
argument_list|,
operator|(
operator|~
name|sum
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Initial/Default Entry 	 */
name|p
operator|=
operator|&
name|block
index|[
literal|32
index|]
expr_stmt|;
comment|/* Boot Indicator */
name|p
index|[
literal|0
index|]
operator|=
literal|0x88
expr_stmt|;
comment|/* Boot media type */
name|p
index|[
literal|1
index|]
operator|=
name|iso9660
operator|->
name|el_torito
operator|.
name|media_type
expr_stmt|;
comment|/* Load Segment */
if|if
condition|(
name|iso9660
operator|->
name|el_torito
operator|.
name|media_type
operator|==
name|BOOT_MEDIA_NO_EMULATION
condition|)
name|set_num_721
argument_list|(
operator|&
name|p
index|[
literal|2
index|]
argument_list|,
name|iso9660
operator|->
name|el_torito
operator|.
name|boot_load_seg
argument_list|)
expr_stmt|;
else|else
name|set_num_721
argument_list|(
operator|&
name|p
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* System Type */
name|p
index|[
literal|4
index|]
operator|=
name|iso9660
operator|->
name|el_torito
operator|.
name|system_type
expr_stmt|;
comment|/* Unused */
name|p
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Sector Count */
if|if
condition|(
name|iso9660
operator|->
name|el_torito
operator|.
name|media_type
operator|==
name|BOOT_MEDIA_NO_EMULATION
condition|)
name|set_num_721
argument_list|(
operator|&
name|p
index|[
literal|6
index|]
argument_list|,
name|iso9660
operator|->
name|el_torito
operator|.
name|boot_load_size
argument_list|)
expr_stmt|;
else|else
name|set_num_721
argument_list|(
operator|&
name|p
index|[
literal|6
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Load RBA */
name|set_num_731
argument_list|(
operator|&
name|p
index|[
literal|8
index|]
argument_list|,
name|iso9660
operator|->
name|el_torito
operator|.
name|boot
operator|->
name|file
operator|->
name|content
operator|.
name|location
argument_list|)
expr_stmt|;
comment|/* Unused */
name|memset
argument_list|(
operator|&
name|p
index|[
literal|12
index|]
argument_list|,
literal|0
argument_list|,
literal|20
argument_list|)
expr_stmt|;
return|return
operator|(
name|wb_consume
argument_list|(
name|a
argument_list|,
name|LOGICAL_BLOCK_SIZE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setup_boot_information
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|struct
name|isoent
modifier|*
name|np
decl_stmt|;
name|int64_t
name|size
decl_stmt|;
name|uint32_t
name|sum
decl_stmt|;
name|unsigned
name|char
name|buff
index|[
literal|4096
index|]
decl_stmt|;
name|np
operator|=
name|iso9660
operator|->
name|el_torito
operator|.
name|boot
expr_stmt|;
name|lseek
argument_list|(
name|iso9660
operator|->
name|temp_fd
argument_list|,
name|np
operator|->
name|file
operator|->
name|content
operator|.
name|offset_of_temp
operator|+
literal|64
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|size
operator|=
name|archive_entry_size
argument_list|(
name|np
operator|->
name|file
operator|->
name|entry
argument_list|)
operator|-
literal|64
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Boot file(%jd) is too small"
argument_list|,
operator|(
name|intmax_t
operator|)
name|size
operator|+
literal|64
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|sum
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|size_t
name|rsize
decl_stmt|;
name|ssize_t
name|i
decl_stmt|,
name|rs
decl_stmt|;
if|if
condition|(
name|size
operator|>
operator|(
name|int64_t
operator|)
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
condition|)
name|rsize
operator|=
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
expr_stmt|;
else|else
name|rsize
operator|=
operator|(
name|size_t
operator|)
name|size
expr_stmt|;
name|rs
operator|=
name|read
argument_list|(
name|iso9660
operator|->
name|temp_fd
argument_list|,
name|buff
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|<=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Can't read temporary file(%jd)"
argument_list|,
operator|(
name|intmax_t
operator|)
name|rs
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rs
condition|;
name|i
operator|+=
literal|4
control|)
name|sum
operator|+=
name|archive_le32dec
argument_list|(
name|buff
operator|+
name|i
argument_list|)
expr_stmt|;
name|size
operator|-=
name|rs
expr_stmt|;
block|}
comment|/* Set the location of Primary Volume Descriptor. */
name|set_num_731
argument_list|(
name|buff
argument_list|,
name|SYSTEM_AREA_BLOCK
argument_list|)
expr_stmt|;
comment|/* Set the location of the boot file. */
name|set_num_731
argument_list|(
name|buff
operator|+
literal|4
argument_list|,
name|np
operator|->
name|file
operator|->
name|content
operator|.
name|location
argument_list|)
expr_stmt|;
comment|/* Set the size of the boot file. */
name|size
operator|=
name|fd_boot_image_size
argument_list|(
name|iso9660
operator|->
name|el_torito
operator|.
name|media_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
name|archive_entry_size
argument_list|(
name|np
operator|->
name|file
operator|->
name|entry
argument_list|)
expr_stmt|;
name|set_num_731
argument_list|(
name|buff
operator|+
literal|8
argument_list|,
operator|(
name|uint32_t
operator|)
name|size
argument_list|)
expr_stmt|;
comment|/* Set the sum of the boot file. */
name|set_num_731
argument_list|(
name|buff
operator|+
literal|12
argument_list|,
name|sum
argument_list|)
expr_stmt|;
comment|/* Clear reserved bytes. */
name|memset
argument_list|(
name|buff
operator|+
literal|16
argument_list|,
literal|0
argument_list|,
literal|40
argument_list|)
expr_stmt|;
comment|/* Overwrite the boot file. */
name|lseek
argument_list|(
name|iso9660
operator|->
name|temp_fd
argument_list|,
name|np
operator|->
name|file
operator|->
name|content
operator|.
name|offset_of_temp
operator|+
literal|8
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
return|return
operator|(
name|write_to_temp
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
literal|56
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
end_ifdef

begin_function
specifier|static
name|int
name|zisofs_init_zstream
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|int
name|r
decl_stmt|;
name|iso9660
operator|->
name|zisofs
operator|.
name|stream
operator|.
name|next_in
operator|=
name|NULL
expr_stmt|;
name|iso9660
operator|->
name|zisofs
operator|.
name|stream
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|iso9660
operator|->
name|zisofs
operator|.
name|stream
operator|.
name|total_in
operator|=
literal|0
expr_stmt|;
name|iso9660
operator|->
name|zisofs
operator|.
name|stream
operator|.
name|total_out
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|zisofs
operator|.
name|stream_valid
condition|)
name|r
operator|=
name|deflateReset
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|zisofs
operator|.
name|stream
operator|)
argument_list|)
expr_stmt|;
else|else
block|{
name|r
operator|=
name|deflateInit
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|zisofs
operator|.
name|stream
operator|)
argument_list|,
name|iso9660
operator|->
name|zisofs
operator|.
name|compression_level
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|zisofs
operator|.
name|stream_valid
operator|=
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|Z_OK
case|:
break|break;
default|default:
case|case
name|Z_STREAM_ERROR
case|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Internal error initializing "
literal|"compression library: invalid setup parameter"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
case|case
name|Z_MEM_ERROR
case|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Internal error initializing "
literal|"compression library"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
case|case
name|Z_VERSION_ERROR
case|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Internal error initializing "
literal|"compression library: invalid library version"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_ZLIB_H */
end_comment

begin_function
specifier|static
name|int
name|zisofs_init
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|isofile
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
name|a
operator|->
name|format_data
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
name|uint64_t
name|tsize
decl_stmt|;
name|size_t
name|_ceil
decl_stmt|,
name|bpsize
decl_stmt|;
name|int
name|r
decl_stmt|;
endif|#
directive|endif
name|iso9660
operator|->
name|zisofs
operator|.
name|detect_magic
operator|=
literal|0
expr_stmt|;
name|iso9660
operator|->
name|zisofs
operator|.
name|making
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|iso9660
operator|->
name|opt
operator|.
name|rr
operator|||
operator|!
name|iso9660
operator|->
name|opt
operator|.
name|zisofs
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
if|if
condition|(
name|archive_entry_size
argument_list|(
name|file
operator|->
name|entry
argument_list|)
operator|>=
literal|24
operator|&&
name|archive_entry_size
argument_list|(
name|file
operator|->
name|entry
argument_list|)
operator|<
name|MULTI_EXTENT_SIZE
condition|)
block|{
comment|/* Acceptable file size for zisofs. */
name|iso9660
operator|->
name|zisofs
operator|.
name|detect_magic
operator|=
literal|1
expr_stmt|;
name|iso9660
operator|->
name|zisofs
operator|.
name|magic_cnt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|iso9660
operator|->
name|zisofs
operator|.
name|detect_magic
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
comment|/* The number of Logical Blocks which uncompressed data 	 * will use in iso-image file is the same as the number of 	 * Logical Blocks which zisofs(compressed) data will use 	 * in ISO-image file. It won't reduce iso-image file size. */
if|if
condition|(
name|archive_entry_size
argument_list|(
name|file
operator|->
name|entry
argument_list|)
operator|<=
name|LOGICAL_BLOCK_SIZE
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
comment|/* Initialize compression library */
name|r
operator|=
name|zisofs_init_zstream
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
comment|/* Mark file->zisofs to create RRIP 'ZF' Use Entry. */
name|file
operator|->
name|zisofs
operator|.
name|header_size
operator|=
name|ZF_HEADER_SIZE
operator|>>
literal|2
expr_stmt|;
name|file
operator|->
name|zisofs
operator|.
name|log2_bs
operator|=
name|ZF_LOG2_BS
expr_stmt|;
name|file
operator|->
name|zisofs
operator|.
name|uncompressed_size
operator|=
operator|(
name|uint32_t
operator|)
name|archive_entry_size
argument_list|(
name|file
operator|->
name|entry
argument_list|)
expr_stmt|;
comment|/* Calculate a size of Block Pointers of zisofs. */
name|_ceil
operator|=
operator|(
name|file
operator|->
name|zisofs
operator|.
name|uncompressed_size
operator|+
name|ZF_BLOCK_SIZE
operator|-
literal|1
operator|)
operator|>>
name|file
operator|->
name|zisofs
operator|.
name|log2_bs
expr_stmt|;
name|iso9660
operator|->
name|zisofs
operator|.
name|block_pointers_cnt
operator|=
operator|(
name|int
operator|)
name|_ceil
operator|+
literal|1
expr_stmt|;
name|iso9660
operator|->
name|zisofs
operator|.
name|block_pointers_idx
operator|=
literal|0
expr_stmt|;
comment|/* Ensure a buffer size used for Block Pointers */
name|bpsize
operator|=
name|iso9660
operator|->
name|zisofs
operator|.
name|block_pointers_cnt
operator|*
sizeof|sizeof
argument_list|(
name|iso9660
operator|->
name|zisofs
operator|.
name|block_pointers
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|zisofs
operator|.
name|block_pointers_allocated
operator|<
name|bpsize
condition|)
block|{
name|free
argument_list|(
name|iso9660
operator|->
name|zisofs
operator|.
name|block_pointers
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|zisofs
operator|.
name|block_pointers
operator|=
name|malloc
argument_list|(
name|bpsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|zisofs
operator|.
name|block_pointers
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|iso9660
operator|->
name|zisofs
operator|.
name|block_pointers_allocated
operator|=
name|bpsize
expr_stmt|;
block|}
comment|/* 	 * Skip zisofs header and Block Pointers, which we will write 	 * after all compressed data of a file written to the temporary 	 * file. 	 */
name|tsize
operator|=
name|ZF_HEADER_SIZE
operator|+
name|bpsize
expr_stmt|;
if|if
condition|(
name|write_null
argument_list|(
name|a
argument_list|,
operator|(
name|size_t
operator|)
name|tsize
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
comment|/* 	 * Initialize some variables to make zisofs. 	 */
name|archive_le32enc
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|zisofs
operator|.
name|block_pointers
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|uint32_t
operator|)
name|tsize
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|zisofs
operator|.
name|remaining
operator|=
name|file
operator|->
name|zisofs
operator|.
name|uncompressed_size
expr_stmt|;
name|iso9660
operator|->
name|zisofs
operator|.
name|making
operator|=
literal|1
expr_stmt|;
name|iso9660
operator|->
name|zisofs
operator|.
name|allzero
operator|=
literal|1
expr_stmt|;
name|iso9660
operator|->
name|zisofs
operator|.
name|block_offset
operator|=
name|tsize
expr_stmt|;
name|iso9660
operator|->
name|zisofs
operator|.
name|total_size
operator|=
name|tsize
expr_stmt|;
name|iso9660
operator|->
name|cur_file
operator|->
name|cur_content
operator|->
name|size
operator|=
name|tsize
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zisofs_detect_magic
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|struct
name|isofile
modifier|*
name|file
init|=
name|iso9660
operator|->
name|cur_file
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|magic_buff
decl_stmt|;
name|uint32_t
name|uncompressed_size
decl_stmt|;
name|unsigned
name|char
name|header_size
decl_stmt|;
name|unsigned
name|char
name|log2_bs
decl_stmt|;
name|size_t
name|_ceil
decl_stmt|,
name|doff
decl_stmt|;
name|uint32_t
name|bst
decl_stmt|,
name|bed
decl_stmt|;
name|int
name|magic_max
decl_stmt|;
name|int64_t
name|entry_size
decl_stmt|;
name|entry_size
operator|=
name|archive_entry_size
argument_list|(
name|file
operator|->
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int64_t
operator|)
sizeof|sizeof
argument_list|(
name|iso9660
operator|->
name|zisofs
operator|.
name|magic_buffer
argument_list|)
operator|>
name|entry_size
condition|)
name|magic_max
operator|=
operator|(
name|int
operator|)
name|entry_size
expr_stmt|;
else|else
name|magic_max
operator|=
sizeof|sizeof
argument_list|(
name|iso9660
operator|->
name|zisofs
operator|.
name|magic_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|zisofs
operator|.
name|magic_cnt
operator|==
literal|0
operator|&&
name|s
operator|>=
operator|(
name|size_t
operator|)
name|magic_max
condition|)
comment|/* It's unnecessary we copy buffer. */
name|magic_buff
operator|=
name|buff
expr_stmt|;
else|else
block|{
if|if
condition|(
name|iso9660
operator|->
name|zisofs
operator|.
name|magic_cnt
operator|<
name|magic_max
condition|)
block|{
name|size_t
name|l
decl_stmt|;
name|l
operator|=
sizeof|sizeof
argument_list|(
name|iso9660
operator|->
name|zisofs
operator|.
name|magic_buffer
argument_list|)
operator|-
name|iso9660
operator|->
name|zisofs
operator|.
name|magic_cnt
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|s
condition|)
name|l
operator|=
name|s
expr_stmt|;
name|memcpy
argument_list|(
name|iso9660
operator|->
name|zisofs
operator|.
name|magic_buffer
operator|+
name|iso9660
operator|->
name|zisofs
operator|.
name|magic_cnt
argument_list|,
name|buff
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|zisofs
operator|.
name|magic_cnt
operator|+=
operator|(
name|int
operator|)
name|l
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|zisofs
operator|.
name|magic_cnt
operator|<
name|magic_max
condition|)
return|return;
block|}
name|magic_buff
operator|=
name|iso9660
operator|->
name|zisofs
operator|.
name|magic_buffer
expr_stmt|;
block|}
name|iso9660
operator|->
name|zisofs
operator|.
name|detect_magic
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|magic_buff
expr_stmt|;
comment|/* Check the magic code of zisofs. */
if|if
condition|(
name|memcmp
argument_list|(
name|p
argument_list|,
name|zisofs_magic
argument_list|,
sizeof|sizeof
argument_list|(
name|zisofs_magic
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
comment|/* This is not zisofs file which made by mkzftree. */
return|return;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|zisofs_magic
argument_list|)
expr_stmt|;
comment|/* Read a zisofs header. */
name|uncompressed_size
operator|=
name|archive_le32dec
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|header_size
operator|=
name|p
index|[
literal|4
index|]
expr_stmt|;
name|log2_bs
operator|=
name|p
index|[
literal|5
index|]
expr_stmt|;
if|if
condition|(
name|uncompressed_size
operator|<
literal|24
operator|||
name|header_size
operator|!=
literal|4
operator|||
name|log2_bs
operator|>
literal|30
operator|||
name|log2_bs
operator|<
literal|7
condition|)
return|return;
comment|/* Invalid or not supported header. */
comment|/* Calculate a size of Block Pointers of zisofs. */
name|_ceil
operator|=
operator|(
name|uncompressed_size
operator|+
operator|(
name|ARCHIVE_LITERAL_LL
argument_list|(
literal|1
argument_list|)
operator|<<
name|log2_bs
operator|)
operator|-
literal|1
operator|)
operator|>>
name|log2_bs
expr_stmt|;
name|doff
operator|=
operator|(
name|_ceil
operator|+
literal|1
operator|)
operator|*
literal|4
operator|+
literal|16
expr_stmt|;
if|if
condition|(
name|entry_size
operator|<
operator|(
name|int64_t
operator|)
name|doff
condition|)
return|return;
comment|/* Invalid data. */
comment|/* Check every Block Pointer has valid value. */
name|p
operator|=
name|magic_buff
operator|+
literal|16
expr_stmt|;
name|endp
operator|=
name|magic_buff
operator|+
name|magic_max
expr_stmt|;
while|while
condition|(
name|_ceil
operator|&&
name|p
operator|+
literal|8
operator|<=
name|endp
condition|)
block|{
name|bst
operator|=
name|archive_le32dec
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|bst
operator|!=
name|doff
condition|)
return|return;
comment|/* Invalid data. */
name|p
operator|+=
literal|4
expr_stmt|;
name|bed
operator|=
name|archive_le32dec
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|bed
operator|<
name|bst
operator|||
name|bed
operator|>
name|entry_size
condition|)
return|return;
comment|/* Invalid data. */
name|doff
operator|+=
name|bed
operator|-
name|bst
expr_stmt|;
name|_ceil
operator|--
expr_stmt|;
block|}
name|file
operator|->
name|zisofs
operator|.
name|uncompressed_size
operator|=
name|uncompressed_size
expr_stmt|;
name|file
operator|->
name|zisofs
operator|.
name|header_size
operator|=
name|header_size
expr_stmt|;
name|file
operator|->
name|zisofs
operator|.
name|log2_bs
operator|=
name|log2_bs
expr_stmt|;
comment|/* Disable making a zisofs image. */
name|iso9660
operator|->
name|zisofs
operator|.
name|making
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
end_ifdef

begin_comment
comment|/*  * Compress data and write it to a temporary file.  */
end_comment

begin_function
specifier|static
name|int
name|zisofs_write_to_temp
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|struct
name|isofile
modifier|*
name|file
init|=
name|iso9660
operator|->
name|cur_file
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|b
decl_stmt|;
name|z_stream
modifier|*
name|zstrm
decl_stmt|;
name|size_t
name|avail
decl_stmt|,
name|csize
decl_stmt|;
name|int
name|flush
decl_stmt|,
name|r
decl_stmt|;
name|zstrm
operator|=
operator|&
operator|(
name|iso9660
operator|->
name|zisofs
operator|.
name|stream
operator|)
expr_stmt|;
name|zstrm
operator|->
name|next_out
operator|=
name|wb_buffptr
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|zstrm
operator|->
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|wb_remaining
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|b
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|buff
expr_stmt|;
do|do
block|{
name|avail
operator|=
name|ZF_BLOCK_SIZE
operator|-
name|zstrm
operator|->
name|total_in
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|avail
condition|)
block|{
name|avail
operator|=
name|s
expr_stmt|;
name|flush
operator|=
name|Z_NO_FLUSH
expr_stmt|;
block|}
else|else
name|flush
operator|=
name|Z_FINISH
expr_stmt|;
name|iso9660
operator|->
name|zisofs
operator|.
name|remaining
operator|-=
name|avail
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|zisofs
operator|.
name|remaining
operator|<=
literal|0
condition|)
name|flush
operator|=
name|Z_FINISH
expr_stmt|;
name|zstrm
operator|->
name|next_in
operator|=
operator|(
name|Bytef
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|(
specifier|const
name|void
operator|*
operator|)
name|b
expr_stmt|;
name|zstrm
operator|->
name|avail_in
operator|=
operator|(
name|uInt
operator|)
name|avail
expr_stmt|;
comment|/* 		 * Check if current data block are all zero. 		 */
if|if
condition|(
name|iso9660
operator|->
name|zisofs
operator|.
name|allzero
condition|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|nonzero
init|=
name|b
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|nonzeroend
init|=
name|b
operator|+
name|avail
decl_stmt|;
while|while
condition|(
name|nonzero
operator|<
name|nonzeroend
condition|)
if|if
condition|(
operator|*
name|nonzero
operator|++
condition|)
block|{
name|iso9660
operator|->
name|zisofs
operator|.
name|allzero
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|b
operator|+=
name|avail
expr_stmt|;
name|s
operator|-=
name|avail
expr_stmt|;
comment|/* 		 * If current data block are all zero, we do not use 		 * compressed data. 		 */
if|if
condition|(
name|flush
operator|==
name|Z_FINISH
operator|&&
name|iso9660
operator|->
name|zisofs
operator|.
name|allzero
operator|&&
name|avail
operator|+
name|zstrm
operator|->
name|total_in
operator|==
name|ZF_BLOCK_SIZE
condition|)
block|{
if|if
condition|(
name|iso9660
operator|->
name|zisofs
operator|.
name|block_offset
operator|!=
name|file
operator|->
name|cur_content
operator|->
name|size
condition|)
block|{
name|int64_t
name|diff
decl_stmt|;
name|r
operator|=
name|wb_set_offset
argument_list|(
name|a
argument_list|,
name|file
operator|->
name|cur_content
operator|->
name|offset_of_temp
operator|+
name|iso9660
operator|->
name|zisofs
operator|.
name|block_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|diff
operator|=
name|file
operator|->
name|cur_content
operator|->
name|size
operator|-
name|iso9660
operator|->
name|zisofs
operator|.
name|block_offset
expr_stmt|;
name|file
operator|->
name|cur_content
operator|->
name|size
operator|-=
name|diff
expr_stmt|;
name|iso9660
operator|->
name|zisofs
operator|.
name|total_size
operator|-=
name|diff
expr_stmt|;
block|}
name|zstrm
operator|->
name|avail_in
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Compress file data. 		 */
while|while
condition|(
name|zstrm
operator|->
name|avail_in
operator|>
literal|0
condition|)
block|{
name|csize
operator|=
name|zstrm
operator|->
name|total_out
expr_stmt|;
name|r
operator|=
name|deflate
argument_list|(
name|zstrm
argument_list|,
name|flush
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|Z_OK
case|:
case|case
name|Z_STREAM_END
case|:
name|csize
operator|=
name|zstrm
operator|->
name|total_out
operator|-
name|csize
expr_stmt|;
if|if
condition|(
name|wb_consume
argument_list|(
name|a
argument_list|,
name|csize
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|iso9660
operator|->
name|zisofs
operator|.
name|total_size
operator|+=
name|csize
expr_stmt|;
name|iso9660
operator|->
name|cur_file
operator|->
name|cur_content
operator|->
name|size
operator|+=
name|csize
expr_stmt|;
name|zstrm
operator|->
name|next_out
operator|=
name|wb_buffptr
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|zstrm
operator|->
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|wb_remaining
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
default|default:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Compression failed:"
literal|" deflate() call returned status %d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|flush
operator|==
name|Z_FINISH
condition|)
block|{
comment|/* 			 * Save the information of one zisofs block. 			 */
name|iso9660
operator|->
name|zisofs
operator|.
name|block_pointers_idx
operator|++
expr_stmt|;
name|archive_le32enc
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|zisofs
operator|.
name|block_pointers
index|[
name|iso9660
operator|->
name|zisofs
operator|.
name|block_pointers_idx
index|]
operator|)
argument_list|,
operator|(
name|uint32_t
operator|)
name|iso9660
operator|->
name|zisofs
operator|.
name|total_size
argument_list|)
expr_stmt|;
name|r
operator|=
name|zisofs_init_zstream
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|iso9660
operator|->
name|zisofs
operator|.
name|allzero
operator|=
literal|1
expr_stmt|;
name|iso9660
operator|->
name|zisofs
operator|.
name|block_offset
operator|=
name|file
operator|->
name|cur_content
operator|->
name|size
expr_stmt|;
block|}
block|}
do|while
condition|(
name|s
condition|)
do|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zisofs_finish_entry
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|struct
name|isofile
modifier|*
name|file
init|=
name|iso9660
operator|->
name|cur_file
decl_stmt|;
name|unsigned
name|char
name|buff
index|[
literal|16
index|]
decl_stmt|;
name|size_t
name|s
decl_stmt|;
name|int64_t
name|tail
decl_stmt|;
comment|/* Direct temp file stream to zisofs temp file stream. */
name|archive_entry_set_size
argument_list|(
name|file
operator|->
name|entry
argument_list|,
name|iso9660
operator|->
name|zisofs
operator|.
name|total_size
argument_list|)
expr_stmt|;
comment|/* 	 * Save a file pointer which points the end of current zisofs data. 	 */
name|tail
operator|=
name|wb_offset
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|/* 	 * Make a header. 	 * 	 * +-----------------+----------------+-----------------+ 	 * | Header 16 bytes | Block Pointers | Compressed data | 	 * +-----------------+----------------+-----------------+ 	 * 0                16               +X 	 * Block Pointers : 	 *   4 * (((Uncompressed file size + block_size -1) / block_size) + 1) 	 * 	 * Write zisofs header. 	 *    Magic number 	 * +----+----+----+----+----+----+----+----+ 	 * | 37 | E4 | 53 | 96 | C9 | DB | D6 | 07 | 	 * +----+----+----+----+----+----+----+----+ 	 * 0    1    2    3    4    5    6    7    8 	 * 	 * +------------------------+------------------+ 	 * | Uncompressed file size | header_size>> 2 | 	 * +------------------------+------------------+ 	 * 8                       12                 13 	 * 	 * +-----------------+----------------+ 	 * | log2 block_size | Reserved(0000) | 	 * +-----------------+----------------+ 	 * 13               14               16 	 */
name|memcpy
argument_list|(
name|buff
argument_list|,
name|zisofs_magic
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|set_num_731
argument_list|(
name|buff
operator|+
literal|8
argument_list|,
name|file
operator|->
name|zisofs
operator|.
name|uncompressed_size
argument_list|)
expr_stmt|;
name|buff
index|[
literal|12
index|]
operator|=
name|file
operator|->
name|zisofs
operator|.
name|header_size
expr_stmt|;
name|buff
index|[
literal|13
index|]
operator|=
name|file
operator|->
name|zisofs
operator|.
name|log2_bs
expr_stmt|;
name|buff
index|[
literal|14
index|]
operator|=
name|buff
index|[
literal|15
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Reserved */
comment|/* Move to the right position to write the header. */
name|wb_set_offset
argument_list|(
name|a
argument_list|,
name|file
operator|->
name|content
operator|.
name|offset_of_temp
argument_list|)
expr_stmt|;
comment|/* Write the header. */
if|if
condition|(
name|wb_write_to_temp
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
literal|16
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
comment|/* 	 * Write zisofs Block Pointers. 	 */
name|s
operator|=
name|iso9660
operator|->
name|zisofs
operator|.
name|block_pointers_cnt
operator|*
sizeof|sizeof
argument_list|(
name|iso9660
operator|->
name|zisofs
operator|.
name|block_pointers
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|wb_write_to_temp
argument_list|(
name|a
argument_list|,
name|iso9660
operator|->
name|zisofs
operator|.
name|block_pointers
argument_list|,
name|s
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
comment|/* Set a file pointer back to the end of the temporary file. */
name|wb_set_offset
argument_list|(
name|a
argument_list|,
name|tail
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zisofs_free
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|int
name|ret
init|=
name|ARCHIVE_OK
decl_stmt|;
name|free
argument_list|(
name|iso9660
operator|->
name|zisofs
operator|.
name|block_pointers
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|zisofs
operator|.
name|stream_valid
operator|&&
name|deflateEnd
argument_list|(
operator|&
operator|(
name|iso9660
operator|->
name|zisofs
operator|.
name|stream
operator|)
argument_list|)
operator|!=
name|Z_OK
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Failed to clean up compressor"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
block|}
name|iso9660
operator|->
name|zisofs
operator|.
name|block_pointers
operator|=
name|NULL
expr_stmt|;
name|iso9660
operator|->
name|zisofs
operator|.
name|stream_valid
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|zisofs_extract
block|{
name|int
name|pz_log2_bs
decl_stmt|;
comment|/* Log2 of block size */
name|uint64_t
name|pz_uncompressed_size
decl_stmt|;
name|size_t
name|uncompressed_buffer_size
decl_stmt|;
name|int
name|initialized
range|:
literal|1
decl_stmt|;
name|int
name|header_passed
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pz_offset
decl_stmt|;
name|unsigned
name|char
modifier|*
name|block_pointers
decl_stmt|;
name|size_t
name|block_pointers_size
decl_stmt|;
name|size_t
name|block_pointers_avail
decl_stmt|;
name|size_t
name|block_off
decl_stmt|;
name|uint32_t
name|block_avail
decl_stmt|;
name|z_stream
name|stream
decl_stmt|;
name|int
name|stream_valid
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|ssize_t
name|zisofs_extract_init
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|zisofs_extract
modifier|*
name|zisofs
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|bytes
parameter_list|)
block|{
name|size_t
name|avail
init|=
name|bytes
decl_stmt|;
name|size_t
name|_ceil
decl_stmt|,
name|xsize
decl_stmt|;
comment|/* Allocate block pointers buffer. */
name|_ceil
operator|=
call|(
name|size_t
call|)
argument_list|(
operator|(
name|zisofs
operator|->
name|pz_uncompressed_size
operator|+
operator|(
operator|(
operator|(
name|int64_t
operator|)
literal|1
operator|)
operator|<<
name|zisofs
operator|->
name|pz_log2_bs
operator|)
operator|-
literal|1
operator|)
operator|>>
name|zisofs
operator|->
name|pz_log2_bs
argument_list|)
expr_stmt|;
name|xsize
operator|=
operator|(
name|_ceil
operator|+
literal|1
operator|)
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|zisofs
operator|->
name|block_pointers
operator|==
name|NULL
condition|)
block|{
name|size_t
name|alloc
init|=
operator|(
operator|(
name|xsize
operator|>>
literal|10
operator|)
operator|+
literal|1
operator|)
operator|<<
literal|10
decl_stmt|;
name|zisofs
operator|->
name|block_pointers
operator|=
name|malloc
argument_list|(
name|alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|zisofs
operator|->
name|block_pointers
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"No memory for zisofs decompression"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
name|zisofs
operator|->
name|block_pointers_size
operator|=
name|xsize
expr_stmt|;
comment|/* Allocate uncompressed data buffer. */
name|zisofs
operator|->
name|uncompressed_buffer_size
operator|=
operator|(
name|size_t
operator|)
literal|1UL
operator|<<
name|zisofs
operator|->
name|pz_log2_bs
expr_stmt|;
comment|/* 	 * Read the file header, and check the magic code of zisofs. 	 */
if|if
condition|(
operator|!
name|zisofs
operator|->
name|header_passed
condition|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|avail
operator|<
literal|16
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Illegal zisofs file body"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|p
argument_list|,
name|zisofs_magic
argument_list|,
sizeof|sizeof
argument_list|(
name|zisofs_magic
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|err
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|8
argument_list|)
operator|!=
name|zisofs
operator|->
name|pz_uncompressed_size
condition|)
name|err
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|12
index|]
operator|!=
literal|4
operator|||
name|p
index|[
literal|13
index|]
operator|!=
name|zisofs
operator|->
name|pz_log2_bs
condition|)
name|err
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Illegal zisofs file body"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|avail
operator|-=
literal|16
expr_stmt|;
name|p
operator|+=
literal|16
expr_stmt|;
name|zisofs
operator|->
name|header_passed
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Read block pointers. 	 */
if|if
condition|(
name|zisofs
operator|->
name|header_passed
operator|&&
name|zisofs
operator|->
name|block_pointers_avail
operator|<
name|zisofs
operator|->
name|block_pointers_size
condition|)
block|{
name|xsize
operator|=
name|zisofs
operator|->
name|block_pointers_size
operator|-
name|zisofs
operator|->
name|block_pointers_avail
expr_stmt|;
if|if
condition|(
name|avail
operator|<
name|xsize
condition|)
name|xsize
operator|=
name|avail
expr_stmt|;
name|memcpy
argument_list|(
name|zisofs
operator|->
name|block_pointers
operator|+
name|zisofs
operator|->
name|block_pointers_avail
argument_list|,
name|p
argument_list|,
name|xsize
argument_list|)
expr_stmt|;
name|zisofs
operator|->
name|block_pointers_avail
operator|+=
name|xsize
expr_stmt|;
name|avail
operator|-=
name|xsize
expr_stmt|;
if|if
condition|(
name|zisofs
operator|->
name|block_pointers_avail
operator|==
name|zisofs
operator|->
name|block_pointers_size
condition|)
block|{
comment|/* We've got all block pointers and initialize 			 * related variables.	*/
name|zisofs
operator|->
name|block_off
operator|=
literal|0
expr_stmt|;
name|zisofs
operator|->
name|block_avail
operator|=
literal|0
expr_stmt|;
comment|/* Complete a initialization */
name|zisofs
operator|->
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
operator|(
name|ssize_t
operator|)
name|avail
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|zisofs_extract
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|zisofs_extract
modifier|*
name|zisofs
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|bytes
parameter_list|)
block|{
name|size_t
name|avail
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|zisofs
operator|->
name|initialized
condition|)
block|{
name|ssize_t
name|rs
init|=
name|zisofs_extract_init
argument_list|(
name|a
argument_list|,
name|zisofs
argument_list|,
name|p
argument_list|,
name|bytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs
operator|<
literal|0
condition|)
return|return
operator|(
name|rs
operator|)
return|;
if|if
condition|(
operator|!
name|zisofs
operator|->
name|initialized
condition|)
block|{
comment|/* We need more data. */
name|zisofs
operator|->
name|pz_offset
operator|+=
operator|(
name|uint32_t
operator|)
name|bytes
expr_stmt|;
return|return
operator|(
name|bytes
operator|)
return|;
block|}
name|avail
operator|=
name|rs
expr_stmt|;
name|p
operator|+=
name|bytes
operator|-
name|avail
expr_stmt|;
block|}
else|else
name|avail
operator|=
name|bytes
expr_stmt|;
comment|/* 	 * Get block offsets from block pointers. 	 */
if|if
condition|(
name|zisofs
operator|->
name|block_avail
operator|==
literal|0
condition|)
block|{
name|uint32_t
name|bst
decl_stmt|,
name|bed
decl_stmt|;
if|if
condition|(
name|zisofs
operator|->
name|block_off
operator|+
literal|4
operator|>=
name|zisofs
operator|->
name|block_pointers_size
condition|)
block|{
comment|/* There isn't a pair of offsets. */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Illegal zisofs block pointers"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|bst
operator|=
name|archive_le32dec
argument_list|(
name|zisofs
operator|->
name|block_pointers
operator|+
name|zisofs
operator|->
name|block_off
argument_list|)
expr_stmt|;
if|if
condition|(
name|bst
operator|!=
name|zisofs
operator|->
name|pz_offset
operator|+
operator|(
name|bytes
operator|-
name|avail
operator|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Illegal zisofs block pointers(cannot seek)"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|bed
operator|=
name|archive_le32dec
argument_list|(
name|zisofs
operator|->
name|block_pointers
operator|+
name|zisofs
operator|->
name|block_off
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|bed
operator|<
name|bst
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Illegal zisofs block pointers"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|zisofs
operator|->
name|block_avail
operator|=
name|bed
operator|-
name|bst
expr_stmt|;
name|zisofs
operator|->
name|block_off
operator|+=
literal|4
expr_stmt|;
comment|/* Initialize compression library for new block. */
if|if
condition|(
name|zisofs
operator|->
name|stream_valid
condition|)
name|r
operator|=
name|inflateReset
argument_list|(
operator|&
name|zisofs
operator|->
name|stream
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|inflateInit
argument_list|(
operator|&
name|zisofs
operator|->
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|Z_OK
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Can't initialize zisofs decompression."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|zisofs
operator|->
name|stream_valid
operator|=
literal|1
expr_stmt|;
name|zisofs
operator|->
name|stream
operator|.
name|total_in
operator|=
literal|0
expr_stmt|;
name|zisofs
operator|->
name|stream
operator|.
name|total_out
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Make uncompressed data. 	 */
if|if
condition|(
name|zisofs
operator|->
name|block_avail
operator|==
literal|0
condition|)
block|{
comment|/* 		 * It's basically 32K bytes NUL data. 		 */
name|unsigned
name|char
modifier|*
name|wb
decl_stmt|;
name|size_t
name|size
decl_stmt|,
name|wsize
decl_stmt|;
name|size
operator|=
name|zisofs
operator|->
name|uncompressed_buffer_size
expr_stmt|;
while|while
condition|(
name|size
condition|)
block|{
name|wb
operator|=
name|wb_buffptr
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|wb_remaining
argument_list|(
name|a
argument_list|)
condition|)
name|wsize
operator|=
name|wb_remaining
argument_list|(
name|a
argument_list|)
expr_stmt|;
else|else
name|wsize
operator|=
name|size
expr_stmt|;
name|memset
argument_list|(
name|wb
argument_list|,
literal|0
argument_list|,
name|wsize
argument_list|)
expr_stmt|;
name|r
operator|=
name|wb_consume
argument_list|(
name|a
argument_list|,
name|wsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|size
operator|-=
name|wsize
expr_stmt|;
block|}
block|}
else|else
block|{
name|zisofs
operator|->
name|stream
operator|.
name|next_in
operator|=
operator|(
name|Bytef
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|(
specifier|const
name|void
operator|*
operator|)
name|p
expr_stmt|;
if|if
condition|(
name|avail
operator|>
name|zisofs
operator|->
name|block_avail
condition|)
name|zisofs
operator|->
name|stream
operator|.
name|avail_in
operator|=
name|zisofs
operator|->
name|block_avail
expr_stmt|;
else|else
name|zisofs
operator|->
name|stream
operator|.
name|avail_in
operator|=
operator|(
name|uInt
operator|)
name|avail
expr_stmt|;
name|zisofs
operator|->
name|stream
operator|.
name|next_out
operator|=
name|wb_buffptr
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|zisofs
operator|->
name|stream
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|wb_remaining
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|r
operator|=
name|inflate
argument_list|(
operator|&
name|zisofs
operator|->
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|Z_OK
case|:
comment|/* Decompressor made some progress.*/
case|case
name|Z_STREAM_END
case|:
comment|/* Found end of stream. */
break|break;
default|default:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"zisofs decompression failed (%d)"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|avail
operator|-=
name|zisofs
operator|->
name|stream
operator|.
name|next_in
operator|-
name|p
expr_stmt|;
name|zisofs
operator|->
name|block_avail
operator|-=
call|(
name|uint32_t
call|)
argument_list|(
name|zisofs
operator|->
name|stream
operator|.
name|next_in
operator|-
name|p
argument_list|)
expr_stmt|;
name|r
operator|=
name|wb_consume
argument_list|(
name|a
argument_list|,
name|wb_remaining
argument_list|(
name|a
argument_list|)
operator|-
name|zisofs
operator|->
name|stream
operator|.
name|avail_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
name|zisofs
operator|->
name|pz_offset
operator|+=
operator|(
name|uint32_t
operator|)
name|bytes
expr_stmt|;
return|return
operator|(
name|bytes
operator|-
name|avail
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zisofs_rewind_boot_file
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|struct
name|isofile
modifier|*
name|file
decl_stmt|;
name|unsigned
name|char
modifier|*
name|rbuff
decl_stmt|;
name|ssize_t
name|r
decl_stmt|;
name|size_t
name|remaining
decl_stmt|,
name|rbuff_size
decl_stmt|;
name|struct
name|zisofs_extract
name|zext
decl_stmt|;
name|int64_t
name|read_offset
decl_stmt|,
name|write_offset
decl_stmt|,
name|new_offset
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|ret
init|=
name|ARCHIVE_OK
decl_stmt|;
name|file
operator|=
name|iso9660
operator|->
name|el_torito
operator|.
name|boot
operator|->
name|file
expr_stmt|;
comment|/* 	 * There is nothing to do if this boot file does not have 	 * zisofs header. 	 */
if|if
condition|(
name|file
operator|->
name|zisofs
operator|.
name|header_size
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
comment|/* 	 * Uncompress the zisofs'ed file contents. 	 */
name|memset
argument_list|(
operator|&
name|zext
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|zext
argument_list|)
argument_list|)
expr_stmt|;
name|zext
operator|.
name|pz_uncompressed_size
operator|=
name|file
operator|->
name|zisofs
operator|.
name|uncompressed_size
expr_stmt|;
name|zext
operator|.
name|pz_log2_bs
operator|=
name|file
operator|->
name|zisofs
operator|.
name|log2_bs
expr_stmt|;
name|fd
operator|=
name|iso9660
operator|->
name|temp_fd
expr_stmt|;
name|new_offset
operator|=
name|wb_offset
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|read_offset
operator|=
name|file
operator|->
name|content
operator|.
name|offset_of_temp
expr_stmt|;
name|remaining
operator|=
operator|(
name|size_t
operator|)
name|file
operator|->
name|content
operator|.
name|size
expr_stmt|;
if|if
condition|(
name|remaining
operator|>
literal|1024
operator|*
literal|32
condition|)
name|rbuff_size
operator|=
literal|1024
operator|*
literal|32
expr_stmt|;
else|else
name|rbuff_size
operator|=
name|remaining
expr_stmt|;
name|rbuff
operator|=
name|malloc
argument_list|(
name|rbuff_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbuff
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
while|while
condition|(
name|remaining
condition|)
block|{
name|size_t
name|rsize
decl_stmt|;
name|ssize_t
name|rs
decl_stmt|;
comment|/* Get the current file pointer. */
name|write_offset
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
comment|/* Change the file pointer to read. */
name|lseek
argument_list|(
name|fd
argument_list|,
name|read_offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|rbuff_size
expr_stmt|;
if|if
condition|(
name|rsize
operator|>
name|remaining
condition|)
name|rsize
operator|=
name|remaining
expr_stmt|;
name|rs
operator|=
name|read
argument_list|(
name|iso9660
operator|->
name|temp_fd
argument_list|,
name|rbuff
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|<=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|errno
argument_list|,
literal|"Can't read temporary file(%jd)"
argument_list|,
operator|(
name|intmax_t
operator|)
name|rs
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
break|break;
block|}
name|remaining
operator|-=
name|rs
expr_stmt|;
name|read_offset
operator|+=
name|rs
expr_stmt|;
comment|/* Put the file pointer back to write. */
name|lseek
argument_list|(
name|fd
argument_list|,
name|write_offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|r
operator|=
name|zisofs_extract
argument_list|(
name|a
argument_list|,
operator|&
name|zext
argument_list|,
name|rbuff
argument_list|,
name|rs
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|ret
operator|=
operator|(
name|int
operator|)
name|r
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ret
operator|==
name|ARCHIVE_OK
condition|)
block|{
comment|/* 		 * Change the boot file content from zisofs'ed data 		 * to plain data. 		 */
name|file
operator|->
name|content
operator|.
name|offset_of_temp
operator|=
name|new_offset
expr_stmt|;
name|file
operator|->
name|content
operator|.
name|size
operator|=
name|file
operator|->
name|zisofs
operator|.
name|uncompressed_size
expr_stmt|;
name|archive_entry_set_size
argument_list|(
name|file
operator|->
name|entry
argument_list|,
name|file
operator|->
name|content
operator|.
name|size
argument_list|)
expr_stmt|;
comment|/* Set to be no zisofs. */
name|file
operator|->
name|zisofs
operator|.
name|header_size
operator|=
literal|0
expr_stmt|;
name|file
operator|->
name|zisofs
operator|.
name|log2_bs
operator|=
literal|0
expr_stmt|;
name|file
operator|->
name|zisofs
operator|.
name|uncompressed_size
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|wb_write_padding_to_temp
argument_list|(
name|a
argument_list|,
name|file
operator|->
name|content
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
name|ret
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
block|}
comment|/* 	 * Free the resource we used in this function only. 	 */
name|free
argument_list|(
name|rbuff
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zext
operator|.
name|block_pointers
argument_list|)
expr_stmt|;
if|if
condition|(
name|zext
operator|.
name|stream_valid
operator|&&
name|inflateEnd
argument_list|(
operator|&
operator|(
name|zext
operator|.
name|stream
operator|)
argument_list|)
operator|!=
name|Z_OK
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Failed to clean up compressor"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|zisofs_write_to_temp
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
operator|(
name|void
operator|)
name|buff
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|s
expr_stmt|;
comment|/* UNUSED */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Programing error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zisofs_rewind_boot_file
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
init|=
name|a
operator|->
name|format_data
decl_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|el_torito
operator|.
name|boot
operator|->
name|file
operator|->
name|zisofs
operator|.
name|header_size
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"We cannot extract the zisofs imaged boot file;"
literal|" this may not boot in being zisofs imaged"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zisofs_finish_entry
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
operator|(
name|void
operator|)
name|a
expr_stmt|;
comment|/* UNUSED */
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zisofs_free
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
operator|(
name|void
operator|)
name|a
expr_stmt|;
comment|/* UNUSED */
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_ZLIB_H */
end_comment

end_unit

