begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2007 Tim Kientzle  * Copyright (c) 2011 Andres Mejia  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"test.h"
end_include

begin_comment
comment|/* Sanity test of internal crypto functionality */
end_comment

begin_define
define|#
directive|define
name|__LIBARCHIVE_BUILD
value|1
end_define

begin_include
include|#
directive|include
file|"archive_crypto_private.h"
end_include

begin_macro
name|DEFINE_TEST
argument_list|(
argument|test_archive_md5
argument_list|)
end_macro

begin_block
block|{
name|archive_md5_ctx
name|ctx
decl_stmt|;
name|unsigned
name|char
name|buf
index|[]
init|=
literal|""
decl_stmt|;
name|unsigned
name|char
name|md
index|[
literal|16
index|]
decl_stmt|;
name|unsigned
name|char
name|actualmd
index|[]
init|=
literal|"\x93\xb8\x85\xad\xfe\x0d\xa0\x89"
literal|"\xcd\xf6\x34\x90\x4f\xd5\x9f\x71"
decl_stmt|;
if|if
condition|(
name|ARCHIVE_OK
operator|!=
name|archive_md5_init
argument_list|(
operator|&
name|ctx
argument_list|)
condition|)
block|{
name|skipping
argument_list|(
literal|"This platform does not support MD5"
argument_list|)
expr_stmt|;
return|return;
block|}
name|assertEqualInt
argument_list|(
name|ARCHIVE_OK
argument_list|,
name|archive_md5_update
argument_list|(
operator|&
name|ctx
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
name|ARCHIVE_OK
argument_list|,
name|archive_md5_final
argument_list|(
operator|&
name|ctx
argument_list|,
name|md
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualMem
argument_list|(
name|md
argument_list|,
name|actualmd
argument_list|,
sizeof|sizeof
argument_list|(
name|md
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DEFINE_TEST
argument_list|(
argument|test_archive_rmd160
argument_list|)
end_macro

begin_block
block|{
name|archive_rmd160_ctx
name|ctx
decl_stmt|;
name|unsigned
name|char
name|buf
index|[]
init|=
literal|""
decl_stmt|;
name|unsigned
name|char
name|md
index|[
literal|20
index|]
decl_stmt|;
name|unsigned
name|char
name|actualmd
index|[]
init|=
literal|"\xc8\x1b\x94\x93\x34\x20\x22\x1a\x7a\xc0"
literal|"\x04\xa9\x02\x42\xd8\xb1\xd3\xe5\x07\x0d"
decl_stmt|;
if|if
condition|(
name|ARCHIVE_OK
operator|!=
name|archive_rmd160_init
argument_list|(
operator|&
name|ctx
argument_list|)
condition|)
block|{
name|skipping
argument_list|(
literal|"This platform does not support RMD160"
argument_list|)
expr_stmt|;
return|return;
block|}
name|assertEqualInt
argument_list|(
name|ARCHIVE_OK
argument_list|,
name|archive_rmd160_update
argument_list|(
operator|&
name|ctx
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
name|ARCHIVE_OK
argument_list|,
name|archive_rmd160_final
argument_list|(
operator|&
name|ctx
argument_list|,
name|md
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualMem
argument_list|(
name|md
argument_list|,
name|actualmd
argument_list|,
sizeof|sizeof
argument_list|(
name|md
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DEFINE_TEST
argument_list|(
argument|test_archive_sha1
argument_list|)
end_macro

begin_block
block|{
name|archive_sha1_ctx
name|ctx
decl_stmt|;
name|unsigned
name|char
name|buf
index|[]
init|=
literal|""
decl_stmt|;
name|unsigned
name|char
name|md
index|[
literal|20
index|]
decl_stmt|;
name|unsigned
name|char
name|actualmd
index|[]
init|=
literal|"\x5b\xa9\x3c\x9d\xb0\xcf\xf9\x3f\x52\xb5"
literal|"\x21\xd7\x42\x0e\x43\xf6\xed\xa2\x78\x4f"
decl_stmt|;
if|if
condition|(
name|ARCHIVE_OK
operator|!=
name|archive_sha1_init
argument_list|(
operator|&
name|ctx
argument_list|)
condition|)
block|{
name|skipping
argument_list|(
literal|"This platform does not support SHA1"
argument_list|)
expr_stmt|;
return|return;
block|}
name|assertEqualInt
argument_list|(
name|ARCHIVE_OK
argument_list|,
name|archive_sha1_update
argument_list|(
operator|&
name|ctx
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
name|ARCHIVE_OK
argument_list|,
name|archive_sha1_final
argument_list|(
operator|&
name|ctx
argument_list|,
name|md
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualMem
argument_list|(
name|md
argument_list|,
name|actualmd
argument_list|,
sizeof|sizeof
argument_list|(
name|md
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DEFINE_TEST
argument_list|(
argument|test_archive_sha256
argument_list|)
end_macro

begin_block
block|{
name|archive_sha256_ctx
name|ctx
decl_stmt|;
name|unsigned
name|char
name|buf
index|[]
init|=
literal|""
decl_stmt|;
name|unsigned
name|char
name|md
index|[
literal|32
index|]
decl_stmt|;
name|unsigned
name|char
name|actualmd
index|[]
init|=
literal|"\x6e\x34\x0b\x9c\xff\xb3\x7a\x98"
literal|"\x9c\xa5\x44\xe6\xbb\x78\x0a\x2c"
literal|"\x78\x90\x1d\x3f\xb3\x37\x38\x76"
literal|"\x85\x11\xa3\x06\x17\xaf\xa0\x1d"
decl_stmt|;
if|if
condition|(
name|ARCHIVE_OK
operator|!=
name|archive_sha256_init
argument_list|(
operator|&
name|ctx
argument_list|)
condition|)
block|{
name|skipping
argument_list|(
literal|"This platform does not support SHA256"
argument_list|)
expr_stmt|;
return|return;
block|}
name|assertEqualInt
argument_list|(
name|ARCHIVE_OK
argument_list|,
name|archive_sha256_update
argument_list|(
operator|&
name|ctx
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
name|ARCHIVE_OK
argument_list|,
name|archive_sha256_final
argument_list|(
operator|&
name|ctx
argument_list|,
name|md
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualMem
argument_list|(
name|md
argument_list|,
name|actualmd
argument_list|,
sizeof|sizeof
argument_list|(
name|md
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DEFINE_TEST
argument_list|(
argument|test_archive_sha384
argument_list|)
end_macro

begin_block
block|{
name|archive_sha384_ctx
name|ctx
decl_stmt|;
name|unsigned
name|char
name|buf
index|[]
init|=
literal|""
decl_stmt|;
name|unsigned
name|char
name|md
index|[
literal|48
index|]
decl_stmt|;
name|unsigned
name|char
name|actualmd
index|[]
init|=
literal|"\xbe\xc0\x21\xb4\xf3\x68\xe3\x06"
literal|"\x91\x34\xe0\x12\xc2\xb4\x30\x70"
literal|"\x83\xd3\xa9\xbd\xd2\x06\xe2\x4e"
literal|"\x5f\x0d\x86\xe1\x3d\x66\x36\x65"
literal|"\x59\x33\xec\x2b\x41\x34\x65\x96"
literal|"\x68\x17\xa9\xc2\x08\xa1\x17\x17"
decl_stmt|;
if|if
condition|(
name|ARCHIVE_OK
operator|!=
name|archive_sha384_init
argument_list|(
operator|&
name|ctx
argument_list|)
condition|)
block|{
name|skipping
argument_list|(
literal|"This platform does not support SHA384"
argument_list|)
expr_stmt|;
return|return;
block|}
name|assertEqualInt
argument_list|(
name|ARCHIVE_OK
argument_list|,
name|archive_sha384_update
argument_list|(
operator|&
name|ctx
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
name|ARCHIVE_OK
argument_list|,
name|archive_sha384_final
argument_list|(
operator|&
name|ctx
argument_list|,
name|md
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualMem
argument_list|(
name|md
argument_list|,
name|actualmd
argument_list|,
sizeof|sizeof
argument_list|(
name|md
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DEFINE_TEST
argument_list|(
argument|test_archive_sha512
argument_list|)
end_macro

begin_block
block|{
name|archive_sha512_ctx
name|ctx
decl_stmt|;
name|unsigned
name|char
name|buf
index|[]
init|=
literal|""
decl_stmt|;
name|unsigned
name|char
name|md
index|[
literal|64
index|]
decl_stmt|;
name|unsigned
name|char
name|actualmd
index|[]
init|=
literal|"\xb8\x24\x4d\x02\x89\x81\xd6\x93"
literal|"\xaf\x7b\x45\x6a\xf8\xef\xa4\xca"
literal|"\xd6\x3d\x28\x2e\x19\xff\x14\x94"
literal|"\x2c\x24\x6e\x50\xd9\x35\x1d\x22"
literal|"\x70\x4a\x80\x2a\x71\xc3\x58\x0b"
literal|"\x63\x70\xde\x4c\xeb\x29\x3c\x32"
literal|"\x4a\x84\x23\x34\x25\x57\xd4\xe5"
literal|"\xc3\x84\x38\xf0\xe3\x69\x10\xee"
decl_stmt|;
if|if
condition|(
name|ARCHIVE_OK
operator|!=
name|archive_sha512_init
argument_list|(
operator|&
name|ctx
argument_list|)
condition|)
block|{
name|skipping
argument_list|(
literal|"This platform does not support SHA512"
argument_list|)
expr_stmt|;
return|return;
block|}
name|assertEqualInt
argument_list|(
name|ARCHIVE_OK
argument_list|,
name|archive_sha512_update
argument_list|(
operator|&
name|ctx
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
name|ARCHIVE_OK
argument_list|,
name|archive_sha512_final
argument_list|(
operator|&
name|ctx
argument_list|,
name|md
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualMem
argument_list|(
name|md
argument_list|,
name|actualmd
argument_list|,
sizeof|sizeof
argument_list|(
name|md
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

