begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Joerg Sonnenberger  * Copyright (c) 2009-2012 Michihiro NAKAJIMA  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"archive_platform.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TYPES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"archive.h"
end_include

begin_include
include|#
directive|include
file|"archive_crypto_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry.h"
end_include

begin_include
include|#
directive|include
file|"archive_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_rb.h"
end_include

begin_include
include|#
directive|include
file|"archive_string.h"
end_include

begin_include
include|#
directive|include
file|"archive_write_private.h"
end_include

begin_define
define|#
directive|define
name|INDENTNAMELEN
value|15
end_define

begin_define
define|#
directive|define
name|MAXLINELEN
value|80
end_define

begin_define
define|#
directive|define
name|SET_KEYS
define|\
value|(F_FLAGS | F_GID | F_GNAME | F_MODE | F_TYPE | F_UID | F_UNAME)
end_define

begin_struct
struct|struct
name|attr_counter
block|{
name|struct
name|attr_counter
modifier|*
name|prev
decl_stmt|;
name|struct
name|attr_counter
modifier|*
name|next
decl_stmt|;
name|struct
name|mtree_entry
modifier|*
name|m_entry
decl_stmt|;
name|int
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|att_counter_set
block|{
name|struct
name|attr_counter
modifier|*
name|uid_list
decl_stmt|;
name|struct
name|attr_counter
modifier|*
name|gid_list
decl_stmt|;
name|struct
name|attr_counter
modifier|*
name|mode_list
decl_stmt|;
name|struct
name|attr_counter
modifier|*
name|flags_list
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mtree_chain
block|{
name|struct
name|mtree_entry
modifier|*
name|first
decl_stmt|;
name|struct
name|mtree_entry
modifier|*
modifier|*
name|last
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * The Data only for a directory file.  */
end_comment

begin_struct
struct|struct
name|dir_info
block|{
name|struct
name|archive_rb_tree
name|rbtree
decl_stmt|;
name|struct
name|mtree_chain
name|children
decl_stmt|;
name|struct
name|mtree_entry
modifier|*
name|chnext
decl_stmt|;
name|int
name|virtual
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * The Data only for a regular file.  */
end_comment

begin_struct
struct|struct
name|reg_info
block|{
name|int
name|compute_sum
decl_stmt|;
name|uint32_t
name|crc
decl_stmt|;
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_MD5
name|unsigned
name|char
name|buf_md5
index|[
literal|16
index|]
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_RMD160
name|unsigned
name|char
name|buf_rmd160
index|[
literal|20
index|]
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA1
name|unsigned
name|char
name|buf_sha1
index|[
literal|20
index|]
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA256
name|unsigned
name|char
name|buf_sha256
index|[
literal|32
index|]
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA384
name|unsigned
name|char
name|buf_sha384
index|[
literal|48
index|]
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA512
name|unsigned
name|char
name|buf_sha512
index|[
literal|64
index|]
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mtree_entry
block|{
name|struct
name|archive_rb_node
name|rbnode
decl_stmt|;
name|struct
name|mtree_entry
modifier|*
name|next
decl_stmt|;
name|struct
name|mtree_entry
modifier|*
name|parent
decl_stmt|;
name|struct
name|dir_info
modifier|*
name|dir_info
decl_stmt|;
name|struct
name|reg_info
modifier|*
name|reg_info
decl_stmt|;
name|struct
name|archive_string
name|parentdir
decl_stmt|;
name|struct
name|archive_string
name|basename
decl_stmt|;
name|struct
name|archive_string
name|pathname
decl_stmt|;
name|struct
name|archive_string
name|symlink
decl_stmt|;
name|struct
name|archive_string
name|uname
decl_stmt|;
name|struct
name|archive_string
name|gname
decl_stmt|;
name|struct
name|archive_string
name|fflags_text
decl_stmt|;
name|unsigned
name|int
name|nlink
decl_stmt|;
name|mode_t
name|filetype
decl_stmt|;
name|mode_t
name|mode
decl_stmt|;
name|int64_t
name|size
decl_stmt|;
name|int64_t
name|uid
decl_stmt|;
name|int64_t
name|gid
decl_stmt|;
name|time_t
name|mtime
decl_stmt|;
name|long
name|mtime_nsec
decl_stmt|;
name|unsigned
name|long
name|fflags_set
decl_stmt|;
name|unsigned
name|long
name|fflags_clear
decl_stmt|;
name|dev_t
name|rdevmajor
decl_stmt|;
name|dev_t
name|rdevminor
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mtree_writer
block|{
name|struct
name|mtree_entry
modifier|*
name|mtree_entry
decl_stmt|;
name|struct
name|mtree_entry
modifier|*
name|root
decl_stmt|;
name|struct
name|mtree_entry
modifier|*
name|cur_dirent
decl_stmt|;
name|struct
name|archive_string
name|cur_dirstr
decl_stmt|;
name|struct
name|mtree_chain
name|file_list
decl_stmt|;
name|struct
name|archive_string
name|ebuf
decl_stmt|;
name|struct
name|archive_string
name|buf
decl_stmt|;
name|int
name|first
decl_stmt|;
name|uint64_t
name|entry_bytes_remaining
decl_stmt|;
comment|/* 	 * Set global value. 	 */
struct|struct
block|{
name|int
name|processing
decl_stmt|;
name|mode_t
name|type
decl_stmt|;
name|int
name|keys
decl_stmt|;
name|int64_t
name|uid
decl_stmt|;
name|int64_t
name|gid
decl_stmt|;
name|mode_t
name|mode
decl_stmt|;
name|unsigned
name|long
name|fflags_set
decl_stmt|;
name|unsigned
name|long
name|fflags_clear
decl_stmt|;
block|}
name|set
struct|;
name|struct
name|att_counter_set
name|acs
decl_stmt|;
name|int
name|classic
decl_stmt|;
name|int
name|depth
decl_stmt|;
comment|/* check sum */
name|int
name|compute_sum
decl_stmt|;
name|uint32_t
name|crc
decl_stmt|;
name|uint64_t
name|crc_len
decl_stmt|;
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_MD5
name|archive_md5_ctx
name|md5ctx
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_RMD160
name|archive_rmd160_ctx
name|rmd160ctx
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA1
name|archive_sha1_ctx
name|sha1ctx
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA256
name|archive_sha256_ctx
name|sha256ctx
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA384
name|archive_sha384_ctx
name|sha384ctx
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA512
name|archive_sha512_ctx
name|sha512ctx
decl_stmt|;
endif|#
directive|endif
comment|/* Keyword options */
name|int
name|keys
decl_stmt|;
define|#
directive|define
name|F_CKSUM
value|0x00000001
comment|/* check sum */
define|#
directive|define
name|F_DEV
value|0x00000002
comment|/* device type */
define|#
directive|define
name|F_DONE
value|0x00000004
comment|/* directory done */
define|#
directive|define
name|F_FLAGS
value|0x00000008
comment|/* file flags */
define|#
directive|define
name|F_GID
value|0x00000010
comment|/* gid */
define|#
directive|define
name|F_GNAME
value|0x00000020
comment|/* group name */
define|#
directive|define
name|F_IGN
value|0x00000040
comment|/* ignore */
define|#
directive|define
name|F_MAGIC
value|0x00000080
comment|/* name has magic chars */
define|#
directive|define
name|F_MD5
value|0x00000100
comment|/* MD5 digest */
define|#
directive|define
name|F_MODE
value|0x00000200
comment|/* mode */
define|#
directive|define
name|F_NLINK
value|0x00000400
comment|/* number of links */
define|#
directive|define
name|F_NOCHANGE
value|0x00000800
comment|/* If owner/mode "wrong", do 						 * not change */
define|#
directive|define
name|F_OPT
value|0x00001000
comment|/* existence optional */
define|#
directive|define
name|F_RMD160
value|0x00002000
comment|/* RIPEMD160 digest */
define|#
directive|define
name|F_SHA1
value|0x00004000
comment|/* SHA-1 digest */
define|#
directive|define
name|F_SIZE
value|0x00008000
comment|/* size */
define|#
directive|define
name|F_SLINK
value|0x00010000
comment|/* symbolic link */
define|#
directive|define
name|F_TAGS
value|0x00020000
comment|/* tags */
define|#
directive|define
name|F_TIME
value|0x00040000
comment|/* modification time */
define|#
directive|define
name|F_TYPE
value|0x00080000
comment|/* file type */
define|#
directive|define
name|F_UID
value|0x00100000
comment|/* uid */
define|#
directive|define
name|F_UNAME
value|0x00200000
comment|/* user name */
define|#
directive|define
name|F_VISIT
value|0x00400000
comment|/* file visited */
define|#
directive|define
name|F_SHA256
value|0x00800000
comment|/* SHA-256 digest */
define|#
directive|define
name|F_SHA384
value|0x01000000
comment|/* SHA-384 digest */
define|#
directive|define
name|F_SHA512
value|0x02000000
comment|/* SHA-512 digest */
comment|/* Options */
name|int
name|dironly
decl_stmt|;
comment|/* If it is set, ignore all files except 				 * directory files, like mtree(8) -d option. */
name|int
name|indent
decl_stmt|;
comment|/* If it is set, indent output data. */
name|int
name|output_global_set
decl_stmt|;
comment|/* If it is set, use /set keyword to set 				 * global values. When generating mtree 				 * classic format, it is set by default. */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DEFAULT_KEYS
value|(F_DEV | F_FLAGS | F_GID | F_GNAME | F_SLINK | F_MODE\ 			 | F_NLINK | F_SIZE | F_TIME | F_TYPE | F_UID\ 			 | F_UNAME)
end_define

begin_define
define|#
directive|define
name|attr_counter_set_reset
value|attr_counter_set_free
end_define

begin_function_decl
specifier|static
name|void
name|attr_counter_free
parameter_list|(
name|struct
name|attr_counter
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|attr_counter_inc
parameter_list|(
name|struct
name|attr_counter
modifier|*
modifier|*
parameter_list|,
name|struct
name|attr_counter
modifier|*
parameter_list|,
name|struct
name|attr_counter
modifier|*
parameter_list|,
name|struct
name|mtree_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|attr_counter
modifier|*
name|attr_counter_new
parameter_list|(
name|struct
name|mtree_entry
modifier|*
parameter_list|,
name|struct
name|attr_counter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|attr_counter_set_collect
parameter_list|(
name|struct
name|mtree_writer
modifier|*
parameter_list|,
name|struct
name|mtree_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|attr_counter_set_free
parameter_list|(
name|struct
name|mtree_writer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_global_set_keys
parameter_list|(
name|struct
name|mtree_writer
modifier|*
parameter_list|,
name|struct
name|mtree_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mtree_entry_add_child_tail
parameter_list|(
name|struct
name|mtree_entry
modifier|*
parameter_list|,
name|struct
name|mtree_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mtree_entry_create_virtual_dir
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|mtree_entry
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mtree_entry_cmp_node
parameter_list|(
specifier|const
name|struct
name|archive_rb_node
modifier|*
parameter_list|,
specifier|const
name|struct
name|archive_rb_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mtree_entry_cmp_key
parameter_list|(
specifier|const
name|struct
name|archive_rb_node
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mtree_entry_exchange_same_entry
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|mtree_entry
modifier|*
parameter_list|,
name|struct
name|mtree_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mtree_entry_free
parameter_list|(
name|struct
name|mtree_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mtree_entry_new
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|struct
name|mtree_entry
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mtree_entry_register_free
parameter_list|(
name|struct
name|mtree_writer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mtree_entry_register_init
parameter_list|(
name|struct
name|mtree_writer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mtree_entry_setup_filenames
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|mtree_entry
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mtree_entry_tree_add
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|mtree_entry
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sum_init
parameter_list|(
name|struct
name|mtree_writer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sum_update
parameter_list|(
name|struct
name|mtree_writer
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sum_final
parameter_list|(
name|struct
name|mtree_writer
modifier|*
parameter_list|,
name|struct
name|reg_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sum_write
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
name|struct
name|reg_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|write_mtree_entry
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|mtree_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|write_dot_dot_entry
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|mtree_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|COMPUTE_CRC
parameter_list|(
name|var
parameter_list|,
name|ch
parameter_list|)
value|(var) = (var)<< 8 ^ crctab[(var)>> 24 ^ (ch)]
end_define

begin_decl_stmt
specifier|static
specifier|const
name|uint32_t
name|crctab
index|[]
init|=
block|{
literal|0x0
block|,
literal|0x04c11db7
block|,
literal|0x09823b6e
block|,
literal|0x0d4326d9
block|,
literal|0x130476dc
block|,
literal|0x17c56b6b
block|,
literal|0x1a864db2
block|,
literal|0x1e475005
block|,
literal|0x2608edb8
block|,
literal|0x22c9f00f
block|,
literal|0x2f8ad6d6
block|,
literal|0x2b4bcb61
block|,
literal|0x350c9b64
block|,
literal|0x31cd86d3
block|,
literal|0x3c8ea00a
block|,
literal|0x384fbdbd
block|,
literal|0x4c11db70
block|,
literal|0x48d0c6c7
block|,
literal|0x4593e01e
block|,
literal|0x4152fda9
block|,
literal|0x5f15adac
block|,
literal|0x5bd4b01b
block|,
literal|0x569796c2
block|,
literal|0x52568b75
block|,
literal|0x6a1936c8
block|,
literal|0x6ed82b7f
block|,
literal|0x639b0da6
block|,
literal|0x675a1011
block|,
literal|0x791d4014
block|,
literal|0x7ddc5da3
block|,
literal|0x709f7b7a
block|,
literal|0x745e66cd
block|,
literal|0x9823b6e0
block|,
literal|0x9ce2ab57
block|,
literal|0x91a18d8e
block|,
literal|0x95609039
block|,
literal|0x8b27c03c
block|,
literal|0x8fe6dd8b
block|,
literal|0x82a5fb52
block|,
literal|0x8664e6e5
block|,
literal|0xbe2b5b58
block|,
literal|0xbaea46ef
block|,
literal|0xb7a96036
block|,
literal|0xb3687d81
block|,
literal|0xad2f2d84
block|,
literal|0xa9ee3033
block|,
literal|0xa4ad16ea
block|,
literal|0xa06c0b5d
block|,
literal|0xd4326d90
block|,
literal|0xd0f37027
block|,
literal|0xddb056fe
block|,
literal|0xd9714b49
block|,
literal|0xc7361b4c
block|,
literal|0xc3f706fb
block|,
literal|0xceb42022
block|,
literal|0xca753d95
block|,
literal|0xf23a8028
block|,
literal|0xf6fb9d9f
block|,
literal|0xfbb8bb46
block|,
literal|0xff79a6f1
block|,
literal|0xe13ef6f4
block|,
literal|0xe5ffeb43
block|,
literal|0xe8bccd9a
block|,
literal|0xec7dd02d
block|,
literal|0x34867077
block|,
literal|0x30476dc0
block|,
literal|0x3d044b19
block|,
literal|0x39c556ae
block|,
literal|0x278206ab
block|,
literal|0x23431b1c
block|,
literal|0x2e003dc5
block|,
literal|0x2ac12072
block|,
literal|0x128e9dcf
block|,
literal|0x164f8078
block|,
literal|0x1b0ca6a1
block|,
literal|0x1fcdbb16
block|,
literal|0x018aeb13
block|,
literal|0x054bf6a4
block|,
literal|0x0808d07d
block|,
literal|0x0cc9cdca
block|,
literal|0x7897ab07
block|,
literal|0x7c56b6b0
block|,
literal|0x71159069
block|,
literal|0x75d48dde
block|,
literal|0x6b93dddb
block|,
literal|0x6f52c06c
block|,
literal|0x6211e6b5
block|,
literal|0x66d0fb02
block|,
literal|0x5e9f46bf
block|,
literal|0x5a5e5b08
block|,
literal|0x571d7dd1
block|,
literal|0x53dc6066
block|,
literal|0x4d9b3063
block|,
literal|0x495a2dd4
block|,
literal|0x44190b0d
block|,
literal|0x40d816ba
block|,
literal|0xaca5c697
block|,
literal|0xa864db20
block|,
literal|0xa527fdf9
block|,
literal|0xa1e6e04e
block|,
literal|0xbfa1b04b
block|,
literal|0xbb60adfc
block|,
literal|0xb6238b25
block|,
literal|0xb2e29692
block|,
literal|0x8aad2b2f
block|,
literal|0x8e6c3698
block|,
literal|0x832f1041
block|,
literal|0x87ee0df6
block|,
literal|0x99a95df3
block|,
literal|0x9d684044
block|,
literal|0x902b669d
block|,
literal|0x94ea7b2a
block|,
literal|0xe0b41de7
block|,
literal|0xe4750050
block|,
literal|0xe9362689
block|,
literal|0xedf73b3e
block|,
literal|0xf3b06b3b
block|,
literal|0xf771768c
block|,
literal|0xfa325055
block|,
literal|0xfef34de2
block|,
literal|0xc6bcf05f
block|,
literal|0xc27dede8
block|,
literal|0xcf3ecb31
block|,
literal|0xcbffd686
block|,
literal|0xd5b88683
block|,
literal|0xd1799b34
block|,
literal|0xdc3abded
block|,
literal|0xd8fba05a
block|,
literal|0x690ce0ee
block|,
literal|0x6dcdfd59
block|,
literal|0x608edb80
block|,
literal|0x644fc637
block|,
literal|0x7a089632
block|,
literal|0x7ec98b85
block|,
literal|0x738aad5c
block|,
literal|0x774bb0eb
block|,
literal|0x4f040d56
block|,
literal|0x4bc510e1
block|,
literal|0x46863638
block|,
literal|0x42472b8f
block|,
literal|0x5c007b8a
block|,
literal|0x58c1663d
block|,
literal|0x558240e4
block|,
literal|0x51435d53
block|,
literal|0x251d3b9e
block|,
literal|0x21dc2629
block|,
literal|0x2c9f00f0
block|,
literal|0x285e1d47
block|,
literal|0x36194d42
block|,
literal|0x32d850f5
block|,
literal|0x3f9b762c
block|,
literal|0x3b5a6b9b
block|,
literal|0x0315d626
block|,
literal|0x07d4cb91
block|,
literal|0x0a97ed48
block|,
literal|0x0e56f0ff
block|,
literal|0x1011a0fa
block|,
literal|0x14d0bd4d
block|,
literal|0x19939b94
block|,
literal|0x1d528623
block|,
literal|0xf12f560e
block|,
literal|0xf5ee4bb9
block|,
literal|0xf8ad6d60
block|,
literal|0xfc6c70d7
block|,
literal|0xe22b20d2
block|,
literal|0xe6ea3d65
block|,
literal|0xeba91bbc
block|,
literal|0xef68060b
block|,
literal|0xd727bbb6
block|,
literal|0xd3e6a601
block|,
literal|0xdea580d8
block|,
literal|0xda649d6f
block|,
literal|0xc423cd6a
block|,
literal|0xc0e2d0dd
block|,
literal|0xcda1f604
block|,
literal|0xc960ebb3
block|,
literal|0xbd3e8d7e
block|,
literal|0xb9ff90c9
block|,
literal|0xb4bcb610
block|,
literal|0xb07daba7
block|,
literal|0xae3afba2
block|,
literal|0xaafbe615
block|,
literal|0xa7b8c0cc
block|,
literal|0xa379dd7b
block|,
literal|0x9b3660c6
block|,
literal|0x9ff77d71
block|,
literal|0x92b45ba8
block|,
literal|0x9675461f
block|,
literal|0x8832161a
block|,
literal|0x8cf30bad
block|,
literal|0x81b02d74
block|,
literal|0x857130c3
block|,
literal|0x5d8a9099
block|,
literal|0x594b8d2e
block|,
literal|0x5408abf7
block|,
literal|0x50c9b640
block|,
literal|0x4e8ee645
block|,
literal|0x4a4ffbf2
block|,
literal|0x470cdd2b
block|,
literal|0x43cdc09c
block|,
literal|0x7b827d21
block|,
literal|0x7f436096
block|,
literal|0x7200464f
block|,
literal|0x76c15bf8
block|,
literal|0x68860bfd
block|,
literal|0x6c47164a
block|,
literal|0x61043093
block|,
literal|0x65c52d24
block|,
literal|0x119b4be9
block|,
literal|0x155a565e
block|,
literal|0x18197087
block|,
literal|0x1cd86d30
block|,
literal|0x029f3d35
block|,
literal|0x065e2082
block|,
literal|0x0b1d065b
block|,
literal|0x0fdc1bec
block|,
literal|0x3793a651
block|,
literal|0x3352bbe6
block|,
literal|0x3e119d3f
block|,
literal|0x3ad08088
block|,
literal|0x2497d08d
block|,
literal|0x2056cd3a
block|,
literal|0x2d15ebe3
block|,
literal|0x29d4f654
block|,
literal|0xc5a92679
block|,
literal|0xc1683bce
block|,
literal|0xcc2b1d17
block|,
literal|0xc8ea00a0
block|,
literal|0xd6ad50a5
block|,
literal|0xd26c4d12
block|,
literal|0xdf2f6bcb
block|,
literal|0xdbee767c
block|,
literal|0xe3a1cbc1
block|,
literal|0xe760d676
block|,
literal|0xea23f0af
block|,
literal|0xeee2ed18
block|,
literal|0xf0a5bd1d
block|,
literal|0xf464a0aa
block|,
literal|0xf9278673
block|,
literal|0xfde69bc4
block|,
literal|0x89b8fd09
block|,
literal|0x8d79e0be
block|,
literal|0x803ac667
block|,
literal|0x84fbdbd0
block|,
literal|0x9abc8bd5
block|,
literal|0x9e7d9662
block|,
literal|0x933eb0bb
block|,
literal|0x97ffad0c
block|,
literal|0xafb010b1
block|,
literal|0xab710d06
block|,
literal|0xa6322bdf
block|,
literal|0xa2f33668
block|,
literal|0xbcb4666d
block|,
literal|0xb8757bda
block|,
literal|0xb5365d03
block|,
literal|0xb1f740b4
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|safe_char
index|[
literal|256
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 00 - 0F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 10 - 1F */
comment|/* !"$%&'()*+,-./  EXCLUSION:0x20( ) 0x23(#) */
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 20 - 2F */
comment|/* 0123456789:;<>?  EXCLUSION:0x3d(=) */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
comment|/* 30 - 3F */
comment|/* @ABCDEFGHIJKLMNO */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 40 - 4F */
comment|/* PQRSTUVWXYZ[]^_ EXCLUSION:0x5c(\)  */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 50 - 5F */
comment|/* `abcdefghijklmno */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 60 - 6F */
comment|/* pqrstuvwxyz{|}~ */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
comment|/* 70 - 7F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 80 - 8F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 90 - 9F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* A0 - AF */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* B0 - BF */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* C0 - CF */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* D0 - DF */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* E0 - EF */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* F0 - FF */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|mtree_quote
parameter_list|(
name|struct
name|archive_string
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
for|for
control|(
name|start
operator|=
name|str
init|;
operator|*
name|str
operator|!=
literal|'\0'
condition|;
operator|++
name|str
control|)
block|{
if|if
condition|(
name|safe_char
index|[
operator|*
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|str
index|]
condition|)
continue|continue;
if|if
condition|(
name|start
operator|!=
name|str
condition|)
name|archive_strncat
argument_list|(
name|s
argument_list|,
name|start
argument_list|,
name|str
operator|-
name|start
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|str
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\\'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
operator|(
name|c
operator|/
literal|64
operator|)
operator|+
literal|'0'
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
operator|(
name|c
operator|/
literal|8
operator|%
literal|8
operator|)
operator|+
literal|'0'
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
operator|(
name|c
operator|%
literal|8
operator|)
operator|+
literal|'0'
expr_stmt|;
name|archive_strncat
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|start
operator|=
name|str
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|start
operator|!=
name|str
condition|)
name|archive_strncat
argument_list|(
name|s
argument_list|,
name|start
argument_list|,
name|str
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Indent a line as mtree utility to be readable for people.  */
end_comment

begin_function
specifier|static
name|void
name|mtree_indent
parameter_list|(
name|struct
name|mtree_writer
modifier|*
name|mtree
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|fn
decl_stmt|,
name|nd
decl_stmt|,
name|pd
decl_stmt|;
specifier|const
name|char
modifier|*
name|r
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|x
decl_stmt|;
if|if
condition|(
name|mtree
operator|->
name|classic
condition|)
block|{
if|if
condition|(
name|mtree
operator|->
name|indent
condition|)
block|{
name|nd
operator|=
literal|0
expr_stmt|;
name|pd
operator|=
name|mtree
operator|->
name|depth
operator|*
literal|4
expr_stmt|;
block|}
else|else
block|{
name|nd
operator|=
name|mtree
operator|->
name|depth
condition|?
literal|4
else|:
literal|0
expr_stmt|;
name|pd
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|nd
operator|=
name|pd
operator|=
literal|0
expr_stmt|;
name|fn
operator|=
literal|1
expr_stmt|;
name|s
operator|=
name|r
operator|=
name|mtree
operator|->
name|ebuf
operator|.
name|s
expr_stmt|;
name|x
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|*
name|r
operator|==
literal|' '
condition|)
name|r
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|strchr
argument_list|(
name|r
argument_list|,
literal|' '
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fn
condition|)
block|{
name|fn
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nd
operator|+
name|pd
condition|;
name|i
operator|++
control|)
name|archive_strappend_char
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|archive_strncat
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
name|s
argument_list|,
name|r
operator|-
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|+
operator|(
name|r
operator|-
name|s
operator|)
operator|>
name|INDENTNAMELEN
condition|)
block|{
name|archive_strncat
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
literal|" \\\n"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|INDENTNAMELEN
operator|+
literal|1
operator|+
name|pd
operator|)
condition|;
name|i
operator|++
control|)
name|archive_strappend_char
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
call|(
name|int
call|)
argument_list|(
name|r
operator|-
name|s
operator|+
name|nd
argument_list|)
init|;
name|i
operator|<
operator|(
name|INDENTNAMELEN
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
control|)
name|archive_strappend_char
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
operator|++
name|r
expr_stmt|;
name|x
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pd
operator|+
operator|(
name|r
operator|-
name|s
operator|)
operator|<=
name|MAXLINELEN
operator|-
literal|3
operator|-
name|INDENTNAMELEN
condition|)
name|x
operator|=
name|r
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|x
operator|==
name|NULL
condition|)
name|x
operator|=
name|r
expr_stmt|;
name|archive_strncat
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
name|s
argument_list|,
name|x
operator|-
name|s
argument_list|)
expr_stmt|;
name|archive_strncat
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
literal|" \\\n"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|INDENTNAMELEN
operator|+
literal|1
operator|+
name|pd
operator|)
condition|;
name|i
operator|++
control|)
name|archive_strappend_char
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|s
operator|=
name|r
operator|=
operator|++
name|x
expr_stmt|;
name|x
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fn
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nd
operator|+
name|pd
condition|;
name|i
operator|++
control|)
name|archive_strappend_char
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|archive_strcat
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|!=
name|NULL
operator|&&
name|pd
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|>
name|MAXLINELEN
operator|-
literal|3
operator|-
name|INDENTNAMELEN
condition|)
block|{
comment|/* Last keyword is longer. */
name|archive_strncat
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
name|s
argument_list|,
name|x
operator|-
name|s
argument_list|)
expr_stmt|;
name|archive_strncat
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
literal|" \\\n"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|INDENTNAMELEN
operator|+
literal|1
operator|+
name|pd
operator|)
condition|;
name|i
operator|++
control|)
name|archive_strappend_char
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|s
operator|=
operator|++
name|x
expr_stmt|;
block|}
name|archive_strcat
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
name|mtree
operator|->
name|ebuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write /set keyword.  * Set most used value of uid,gid,mode and fflags, which are  * collected by attr_counter_set_collect() function.  */
end_comment

begin_function
specifier|static
name|void
name|write_global
parameter_list|(
name|struct
name|mtree_writer
modifier|*
name|mtree
parameter_list|)
block|{
name|struct
name|archive_string
name|setstr
decl_stmt|;
name|struct
name|archive_string
name|unsetstr
decl_stmt|;
name|struct
name|att_counter_set
modifier|*
name|acs
decl_stmt|;
name|int
name|keys
decl_stmt|,
name|oldkeys
decl_stmt|,
name|effkeys
decl_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|setstr
argument_list|)
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|unsetstr
argument_list|)
expr_stmt|;
name|keys
operator|=
name|mtree
operator|->
name|keys
operator|&
name|SET_KEYS
expr_stmt|;
name|oldkeys
operator|=
name|mtree
operator|->
name|set
operator|.
name|keys
expr_stmt|;
name|effkeys
operator|=
name|keys
expr_stmt|;
name|acs
operator|=
operator|&
name|mtree
operator|->
name|acs
expr_stmt|;
if|if
condition|(
name|mtree
operator|->
name|set
operator|.
name|processing
condition|)
block|{
comment|/* 		 * Check if the global data needs updating. 		 */
name|effkeys
operator|&=
operator|~
name|F_TYPE
expr_stmt|;
if|if
condition|(
name|acs
operator|->
name|uid_list
operator|==
name|NULL
condition|)
name|effkeys
operator|&=
operator|~
operator|(
name|F_UNAME
operator||
name|F_UID
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|oldkeys
operator|&
operator|(
name|F_UNAME
operator||
name|F_UID
operator|)
condition|)
block|{
if|if
condition|(
name|acs
operator|->
name|uid_list
operator|->
name|count
operator|<
literal|2
operator|||
name|mtree
operator|->
name|set
operator|.
name|uid
operator|==
name|acs
operator|->
name|uid_list
operator|->
name|m_entry
operator|->
name|uid
condition|)
name|effkeys
operator|&=
operator|~
operator|(
name|F_UNAME
operator||
name|F_UID
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|acs
operator|->
name|gid_list
operator|==
name|NULL
condition|)
name|effkeys
operator|&=
operator|~
operator|(
name|F_GNAME
operator||
name|F_GID
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|oldkeys
operator|&
operator|(
name|F_GNAME
operator||
name|F_GID
operator|)
condition|)
block|{
if|if
condition|(
name|acs
operator|->
name|gid_list
operator|->
name|count
operator|<
literal|2
operator|||
name|mtree
operator|->
name|set
operator|.
name|gid
operator|==
name|acs
operator|->
name|gid_list
operator|->
name|m_entry
operator|->
name|gid
condition|)
name|effkeys
operator|&=
operator|~
operator|(
name|F_GNAME
operator||
name|F_GID
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|acs
operator|->
name|mode_list
operator|==
name|NULL
condition|)
name|effkeys
operator|&=
operator|~
name|F_MODE
expr_stmt|;
elseif|else
if|if
condition|(
name|oldkeys
operator|&
name|F_MODE
condition|)
block|{
if|if
condition|(
name|acs
operator|->
name|mode_list
operator|->
name|count
operator|<
literal|2
operator|||
name|mtree
operator|->
name|set
operator|.
name|mode
operator|==
name|acs
operator|->
name|mode_list
operator|->
name|m_entry
operator|->
name|mode
condition|)
name|effkeys
operator|&=
operator|~
name|F_MODE
expr_stmt|;
block|}
if|if
condition|(
name|acs
operator|->
name|flags_list
operator|==
name|NULL
condition|)
name|effkeys
operator|&=
operator|~
name|F_FLAGS
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|oldkeys
operator|&
name|F_FLAGS
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|acs
operator|->
name|flags_list
operator|->
name|count
operator|<
literal|2
operator|||
operator|(
name|acs
operator|->
name|flags_list
operator|->
name|m_entry
operator|->
name|fflags_set
operator|==
name|mtree
operator|->
name|set
operator|.
name|fflags_set
operator|&&
name|acs
operator|->
name|flags_list
operator|->
name|m_entry
operator|->
name|fflags_clear
operator|==
name|mtree
operator|->
name|set
operator|.
name|fflags_clear
operator|)
condition|)
name|effkeys
operator|&=
operator|~
name|F_FLAGS
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|acs
operator|->
name|uid_list
operator|==
name|NULL
condition|)
name|keys
operator|&=
operator|~
operator|(
name|F_UNAME
operator||
name|F_UID
operator|)
expr_stmt|;
if|if
condition|(
name|acs
operator|->
name|gid_list
operator|==
name|NULL
condition|)
name|keys
operator|&=
operator|~
operator|(
name|F_GNAME
operator||
name|F_GID
operator|)
expr_stmt|;
if|if
condition|(
name|acs
operator|->
name|mode_list
operator|==
name|NULL
condition|)
name|keys
operator|&=
operator|~
name|F_MODE
expr_stmt|;
if|if
condition|(
name|acs
operator|->
name|flags_list
operator|==
name|NULL
condition|)
name|keys
operator|&=
operator|~
name|F_FLAGS
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|keys
operator|&
name|effkeys
operator|&
name|F_TYPE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|mtree
operator|->
name|dironly
condition|)
block|{
name|archive_strcat
argument_list|(
operator|&
name|setstr
argument_list|,
literal|" type=dir"
argument_list|)
expr_stmt|;
name|mtree
operator|->
name|set
operator|.
name|type
operator|=
name|AE_IFDIR
expr_stmt|;
block|}
else|else
block|{
name|archive_strcat
argument_list|(
operator|&
name|setstr
argument_list|,
literal|" type=file"
argument_list|)
expr_stmt|;
name|mtree
operator|->
name|set
operator|.
name|type
operator|=
name|AE_IFREG
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|keys
operator|&
name|effkeys
operator|&
name|F_UNAME
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
operator|(
name|acs
operator|->
name|uid_list
operator|->
name|m_entry
operator|->
name|uname
operator|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|archive_strcat
argument_list|(
operator|&
name|setstr
argument_list|,
literal|" uname="
argument_list|)
expr_stmt|;
name|mtree_quote
argument_list|(
operator|&
name|setstr
argument_list|,
name|acs
operator|->
name|uid_list
operator|->
name|m_entry
operator|->
name|uname
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|keys
operator|&=
operator|~
name|F_UNAME
expr_stmt|;
if|if
condition|(
operator|(
name|oldkeys
operator|&
name|F_UNAME
operator|)
operator|!=
literal|0
condition|)
name|archive_strcat
argument_list|(
operator|&
name|unsetstr
argument_list|,
literal|" uname"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|keys
operator|&
name|effkeys
operator|&
name|F_UID
operator|)
operator|!=
literal|0
condition|)
block|{
name|mtree
operator|->
name|set
operator|.
name|uid
operator|=
name|acs
operator|->
name|uid_list
operator|->
name|m_entry
operator|->
name|uid
expr_stmt|;
name|archive_string_sprintf
argument_list|(
operator|&
name|setstr
argument_list|,
literal|" uid=%jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|mtree
operator|->
name|set
operator|.
name|uid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|keys
operator|&
name|effkeys
operator|&
name|F_GNAME
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
operator|(
name|acs
operator|->
name|gid_list
operator|->
name|m_entry
operator|->
name|gname
operator|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|archive_strcat
argument_list|(
operator|&
name|setstr
argument_list|,
literal|" gname="
argument_list|)
expr_stmt|;
name|mtree_quote
argument_list|(
operator|&
name|setstr
argument_list|,
name|acs
operator|->
name|gid_list
operator|->
name|m_entry
operator|->
name|gname
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|keys
operator|&=
operator|~
name|F_GNAME
expr_stmt|;
if|if
condition|(
operator|(
name|oldkeys
operator|&
name|F_GNAME
operator|)
operator|!=
literal|0
condition|)
name|archive_strcat
argument_list|(
operator|&
name|unsetstr
argument_list|,
literal|" gname"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|keys
operator|&
name|effkeys
operator|&
name|F_GID
operator|)
operator|!=
literal|0
condition|)
block|{
name|mtree
operator|->
name|set
operator|.
name|gid
operator|=
name|acs
operator|->
name|gid_list
operator|->
name|m_entry
operator|->
name|gid
expr_stmt|;
name|archive_string_sprintf
argument_list|(
operator|&
name|setstr
argument_list|,
literal|" gid=%jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|mtree
operator|->
name|set
operator|.
name|gid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|keys
operator|&
name|effkeys
operator|&
name|F_MODE
operator|)
operator|!=
literal|0
condition|)
block|{
name|mtree
operator|->
name|set
operator|.
name|mode
operator|=
name|acs
operator|->
name|mode_list
operator|->
name|m_entry
operator|->
name|mode
expr_stmt|;
name|archive_string_sprintf
argument_list|(
operator|&
name|setstr
argument_list|,
literal|" mode=%o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|mtree
operator|->
name|set
operator|.
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|keys
operator|&
name|effkeys
operator|&
name|F_FLAGS
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
operator|(
name|acs
operator|->
name|flags_list
operator|->
name|m_entry
operator|->
name|fflags_text
operator|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|archive_strcat
argument_list|(
operator|&
name|setstr
argument_list|,
literal|" flags="
argument_list|)
expr_stmt|;
name|mtree_quote
argument_list|(
operator|&
name|setstr
argument_list|,
name|acs
operator|->
name|flags_list
operator|->
name|m_entry
operator|->
name|fflags_text
operator|.
name|s
argument_list|)
expr_stmt|;
name|mtree
operator|->
name|set
operator|.
name|fflags_set
operator|=
name|acs
operator|->
name|flags_list
operator|->
name|m_entry
operator|->
name|fflags_set
expr_stmt|;
name|mtree
operator|->
name|set
operator|.
name|fflags_clear
operator|=
name|acs
operator|->
name|flags_list
operator|->
name|m_entry
operator|->
name|fflags_clear
expr_stmt|;
block|}
else|else
block|{
name|keys
operator|&=
operator|~
name|F_FLAGS
expr_stmt|;
if|if
condition|(
operator|(
name|oldkeys
operator|&
name|F_FLAGS
operator|)
operator|!=
literal|0
condition|)
name|archive_strcat
argument_list|(
operator|&
name|unsetstr
argument_list|,
literal|" flags"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|unsetstr
operator|.
name|length
operator|>
literal|0
condition|)
name|archive_string_sprintf
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
literal|"/unset%s\n"
argument_list|,
name|unsetstr
operator|.
name|s
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|unsetstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|setstr
operator|.
name|length
operator|>
literal|0
condition|)
name|archive_string_sprintf
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
literal|"/set%s\n"
argument_list|,
name|setstr
operator|.
name|s
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|setstr
argument_list|)
expr_stmt|;
name|mtree
operator|->
name|set
operator|.
name|keys
operator|=
name|keys
expr_stmt|;
name|mtree
operator|->
name|set
operator|.
name|processing
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|attr_counter
modifier|*
name|attr_counter_new
parameter_list|(
name|struct
name|mtree_entry
modifier|*
name|me
parameter_list|,
name|struct
name|attr_counter
modifier|*
name|prev
parameter_list|)
block|{
name|struct
name|attr_counter
modifier|*
name|ac
decl_stmt|;
name|ac
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ac
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|!=
name|NULL
condition|)
block|{
name|ac
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
name|ac
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|ac
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|ac
operator|->
name|m_entry
operator|=
name|me
expr_stmt|;
block|}
return|return
operator|(
name|ac
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|attr_counter_free
parameter_list|(
name|struct
name|attr_counter
modifier|*
modifier|*
name|top
parameter_list|)
block|{
name|struct
name|attr_counter
modifier|*
name|ac
decl_stmt|,
modifier|*
name|tac
decl_stmt|;
if|if
condition|(
operator|*
name|top
operator|==
name|NULL
condition|)
return|return;
name|ac
operator|=
operator|*
name|top
expr_stmt|;
while|while
condition|(
name|ac
operator|!=
name|NULL
condition|)
block|{
name|tac
operator|=
name|ac
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|ac
argument_list|)
expr_stmt|;
name|ac
operator|=
name|tac
expr_stmt|;
block|}
operator|*
name|top
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|attr_counter_inc
parameter_list|(
name|struct
name|attr_counter
modifier|*
modifier|*
name|top
parameter_list|,
name|struct
name|attr_counter
modifier|*
name|ac
parameter_list|,
name|struct
name|attr_counter
modifier|*
name|last
parameter_list|,
name|struct
name|mtree_entry
modifier|*
name|me
parameter_list|)
block|{
name|struct
name|attr_counter
modifier|*
name|pac
decl_stmt|;
if|if
condition|(
name|ac
operator|!=
name|NULL
condition|)
block|{
name|ac
operator|->
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|top
operator|==
name|ac
operator|||
name|ac
operator|->
name|prev
operator|->
name|count
operator|>=
name|ac
operator|->
name|count
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|pac
operator|=
name|ac
operator|->
name|prev
init|;
name|pac
condition|;
name|pac
operator|=
name|pac
operator|->
name|prev
control|)
block|{
if|if
condition|(
name|pac
operator|->
name|count
operator|>=
name|ac
operator|->
name|count
condition|)
break|break;
block|}
name|ac
operator|->
name|prev
operator|->
name|next
operator|=
name|ac
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ac
operator|->
name|next
operator|!=
name|NULL
condition|)
name|ac
operator|->
name|next
operator|->
name|prev
operator|=
name|ac
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|pac
operator|!=
name|NULL
condition|)
block|{
name|ac
operator|->
name|prev
operator|=
name|pac
expr_stmt|;
name|ac
operator|->
name|next
operator|=
name|pac
operator|->
name|next
expr_stmt|;
name|pac
operator|->
name|next
operator|=
name|ac
expr_stmt|;
if|if
condition|(
name|ac
operator|->
name|next
operator|!=
name|NULL
condition|)
name|ac
operator|->
name|next
operator|->
name|prev
operator|=
name|ac
expr_stmt|;
block|}
else|else
block|{
name|ac
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|ac
operator|->
name|next
operator|=
operator|*
name|top
expr_stmt|;
operator|*
name|top
operator|=
name|ac
expr_stmt|;
name|ac
operator|->
name|next
operator|->
name|prev
operator|=
name|ac
expr_stmt|;
block|}
block|}
else|else
block|{
name|ac
operator|=
name|attr_counter_new
argument_list|(
name|me
argument_list|,
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|last
operator|->
name|next
operator|=
name|ac
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Tabulate uid,gid,mode and fflags of a entry in order to be used for /set.  */
end_comment

begin_function
specifier|static
name|int
name|attr_counter_set_collect
parameter_list|(
name|struct
name|mtree_writer
modifier|*
name|mtree
parameter_list|,
name|struct
name|mtree_entry
modifier|*
name|me
parameter_list|)
block|{
name|struct
name|attr_counter
modifier|*
name|ac
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|struct
name|att_counter_set
modifier|*
name|acs
init|=
operator|&
name|mtree
operator|->
name|acs
decl_stmt|;
name|int
name|keys
init|=
name|mtree
operator|->
name|keys
decl_stmt|;
if|if
condition|(
name|keys
operator|&
operator|(
name|F_UNAME
operator||
name|F_UID
operator|)
condition|)
block|{
if|if
condition|(
name|acs
operator|->
name|uid_list
operator|==
name|NULL
condition|)
block|{
name|acs
operator|->
name|uid_list
operator|=
name|attr_counter_new
argument_list|(
name|me
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|acs
operator|->
name|uid_list
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
name|last
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ac
operator|=
name|acs
operator|->
name|uid_list
init|;
name|ac
condition|;
name|ac
operator|=
name|ac
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ac
operator|->
name|m_entry
operator|->
name|uid
operator|==
name|me
operator|->
name|uid
condition|)
break|break;
name|last
operator|=
name|ac
expr_stmt|;
block|}
if|if
condition|(
name|attr_counter_inc
argument_list|(
operator|&
name|acs
operator|->
name|uid_list
argument_list|,
name|ac
argument_list|,
name|last
argument_list|,
name|me
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|keys
operator|&
operator|(
name|F_GNAME
operator||
name|F_GID
operator|)
condition|)
block|{
if|if
condition|(
name|acs
operator|->
name|gid_list
operator|==
name|NULL
condition|)
block|{
name|acs
operator|->
name|gid_list
operator|=
name|attr_counter_new
argument_list|(
name|me
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|acs
operator|->
name|gid_list
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
name|last
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ac
operator|=
name|acs
operator|->
name|gid_list
init|;
name|ac
condition|;
name|ac
operator|=
name|ac
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ac
operator|->
name|m_entry
operator|->
name|gid
operator|==
name|me
operator|->
name|gid
condition|)
break|break;
name|last
operator|=
name|ac
expr_stmt|;
block|}
if|if
condition|(
name|attr_counter_inc
argument_list|(
operator|&
name|acs
operator|->
name|gid_list
argument_list|,
name|ac
argument_list|,
name|last
argument_list|,
name|me
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|keys
operator|&
name|F_MODE
condition|)
block|{
if|if
condition|(
name|acs
operator|->
name|mode_list
operator|==
name|NULL
condition|)
block|{
name|acs
operator|->
name|mode_list
operator|=
name|attr_counter_new
argument_list|(
name|me
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|acs
operator|->
name|mode_list
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
name|last
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ac
operator|=
name|acs
operator|->
name|mode_list
init|;
name|ac
condition|;
name|ac
operator|=
name|ac
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ac
operator|->
name|m_entry
operator|->
name|mode
operator|==
name|me
operator|->
name|mode
condition|)
break|break;
name|last
operator|=
name|ac
expr_stmt|;
block|}
if|if
condition|(
name|attr_counter_inc
argument_list|(
operator|&
name|acs
operator|->
name|mode_list
argument_list|,
name|ac
argument_list|,
name|last
argument_list|,
name|me
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|keys
operator|&
name|F_FLAGS
condition|)
block|{
if|if
condition|(
name|acs
operator|->
name|flags_list
operator|==
name|NULL
condition|)
block|{
name|acs
operator|->
name|flags_list
operator|=
name|attr_counter_new
argument_list|(
name|me
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|acs
operator|->
name|flags_list
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
name|last
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ac
operator|=
name|acs
operator|->
name|flags_list
init|;
name|ac
condition|;
name|ac
operator|=
name|ac
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ac
operator|->
name|m_entry
operator|->
name|fflags_set
operator|==
name|me
operator|->
name|fflags_set
operator|&&
name|ac
operator|->
name|m_entry
operator|->
name|fflags_clear
operator|==
name|me
operator|->
name|fflags_clear
condition|)
break|break;
name|last
operator|=
name|ac
expr_stmt|;
block|}
if|if
condition|(
name|attr_counter_inc
argument_list|(
operator|&
name|acs
operator|->
name|flags_list
argument_list|,
name|ac
argument_list|,
name|last
argument_list|,
name|me
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|attr_counter_set_free
parameter_list|(
name|struct
name|mtree_writer
modifier|*
name|mtree
parameter_list|)
block|{
name|struct
name|att_counter_set
modifier|*
name|acs
init|=
operator|&
name|mtree
operator|->
name|acs
decl_stmt|;
name|attr_counter_free
argument_list|(
operator|&
name|acs
operator|->
name|uid_list
argument_list|)
expr_stmt|;
name|attr_counter_free
argument_list|(
operator|&
name|acs
operator|->
name|gid_list
argument_list|)
expr_stmt|;
name|attr_counter_free
argument_list|(
operator|&
name|acs
operator|->
name|mode_list
argument_list|)
expr_stmt|;
name|attr_counter_free
argument_list|(
operator|&
name|acs
operator|->
name|flags_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_global_set_keys
parameter_list|(
name|struct
name|mtree_writer
modifier|*
name|mtree
parameter_list|,
name|struct
name|mtree_entry
modifier|*
name|me
parameter_list|)
block|{
name|int
name|keys
decl_stmt|;
name|keys
operator|=
name|mtree
operator|->
name|keys
expr_stmt|;
comment|/* 	 * If a keyword has been set by /set, we do not need to 	 * output it. 	 */
if|if
condition|(
name|mtree
operator|->
name|set
operator|.
name|keys
operator|==
literal|0
condition|)
return|return
operator|(
name|keys
operator|)
return|;
comment|/* /set is not used. */
if|if
condition|(
operator|(
name|mtree
operator|->
name|set
operator|.
name|keys
operator|&
operator|(
name|F_GNAME
operator||
name|F_GID
operator|)
operator|)
operator|!=
literal|0
operator|&&
name|mtree
operator|->
name|set
operator|.
name|gid
operator|==
name|me
operator|->
name|gid
condition|)
name|keys
operator|&=
operator|~
operator|(
name|F_GNAME
operator||
name|F_GID
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|mtree
operator|->
name|set
operator|.
name|keys
operator|&
operator|(
name|F_UNAME
operator||
name|F_UID
operator|)
operator|)
operator|!=
literal|0
operator|&&
name|mtree
operator|->
name|set
operator|.
name|uid
operator|==
name|me
operator|->
name|uid
condition|)
name|keys
operator|&=
operator|~
operator|(
name|F_UNAME
operator||
name|F_UID
operator|)
expr_stmt|;
if|if
condition|(
name|mtree
operator|->
name|set
operator|.
name|keys
operator|&
name|F_FLAGS
condition|)
block|{
if|if
condition|(
name|mtree
operator|->
name|set
operator|.
name|fflags_set
operator|==
name|me
operator|->
name|fflags_set
operator|&&
name|mtree
operator|->
name|set
operator|.
name|fflags_clear
operator|==
name|me
operator|->
name|fflags_clear
condition|)
name|keys
operator|&=
operator|~
name|F_FLAGS
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mtree
operator|->
name|set
operator|.
name|keys
operator|&
name|F_MODE
operator|)
operator|!=
literal|0
operator|&&
name|mtree
operator|->
name|set
operator|.
name|mode
operator|==
name|me
operator|->
name|mode
condition|)
name|keys
operator|&=
operator|~
name|F_MODE
expr_stmt|;
switch|switch
condition|(
name|me
operator|->
name|filetype
condition|)
block|{
case|case
name|AE_IFLNK
case|:
case|case
name|AE_IFSOCK
case|:
case|case
name|AE_IFCHR
case|:
case|case
name|AE_IFBLK
case|:
case|case
name|AE_IFIFO
case|:
break|break;
case|case
name|AE_IFDIR
case|:
if|if
condition|(
operator|(
name|mtree
operator|->
name|set
operator|.
name|keys
operator|&
name|F_TYPE
operator|)
operator|!=
literal|0
operator|&&
name|mtree
operator|->
name|set
operator|.
name|type
operator|==
name|AE_IFDIR
condition|)
name|keys
operator|&=
operator|~
name|F_TYPE
expr_stmt|;
break|break;
case|case
name|AE_IFREG
case|:
default|default:
comment|/* Handle unknown file types as regular files. */
if|if
condition|(
operator|(
name|mtree
operator|->
name|set
operator|.
name|keys
operator|&
name|F_TYPE
operator|)
operator|!=
literal|0
operator|&&
name|mtree
operator|->
name|set
operator|.
name|type
operator|==
name|AE_IFREG
condition|)
name|keys
operator|&=
operator|~
name|F_TYPE
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|keys
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mtree_entry_new
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|mtree_entry
modifier|*
modifier|*
name|m_entry
parameter_list|)
block|{
name|struct
name|mtree_entry
modifier|*
name|me
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|r
decl_stmt|;
specifier|static
specifier|const
name|struct
name|archive_rb_tree_ops
name|rb_ops
init|=
block|{
name|mtree_entry_cmp_node
block|,
name|mtree_entry_cmp_key
block|}
decl_stmt|;
name|me
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|me
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|me
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for a mtree entry"
argument_list|)
expr_stmt|;
operator|*
name|m_entry
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|r
operator|=
name|mtree_entry_setup_filenames
argument_list|(
name|a
argument_list|,
name|me
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|ARCHIVE_WARN
condition|)
block|{
name|mtree_entry_free
argument_list|(
name|me
argument_list|)
expr_stmt|;
operator|*
name|m_entry
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|s
operator|=
name|archive_entry_symlink
argument_list|(
name|entry
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|archive_strcpy
argument_list|(
operator|&
name|me
operator|->
name|symlink
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|me
operator|->
name|nlink
operator|=
name|archive_entry_nlink
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|me
operator|->
name|filetype
operator|=
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|me
operator|->
name|mode
operator|=
name|archive_entry_mode
argument_list|(
name|entry
argument_list|)
operator|&
literal|07777
expr_stmt|;
name|me
operator|->
name|uid
operator|=
name|archive_entry_uid
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|me
operator|->
name|gid
operator|=
name|archive_entry_gid
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|archive_entry_uname
argument_list|(
name|entry
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|archive_strcpy
argument_list|(
operator|&
name|me
operator|->
name|uname
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|archive_entry_gname
argument_list|(
name|entry
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|archive_strcpy
argument_list|(
operator|&
name|me
operator|->
name|gname
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|archive_entry_fflags_text
argument_list|(
name|entry
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|archive_strcpy
argument_list|(
operator|&
name|me
operator|->
name|fflags_text
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|archive_entry_fflags
argument_list|(
name|entry
argument_list|,
operator|&
name|me
operator|->
name|fflags_set
argument_list|,
operator|&
name|me
operator|->
name|fflags_clear
argument_list|)
expr_stmt|;
name|me
operator|->
name|mtime
operator|=
name|archive_entry_mtime
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|me
operator|->
name|mtime_nsec
operator|=
name|archive_entry_mtime_nsec
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|me
operator|->
name|rdevmajor
operator|=
name|archive_entry_rdevmajor
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|me
operator|->
name|rdevminor
operator|=
name|archive_entry_rdevminor
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|me
operator|->
name|size
operator|=
name|archive_entry_size
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|me
operator|->
name|filetype
operator|==
name|AE_IFDIR
condition|)
block|{
name|me
operator|->
name|dir_info
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|me
operator|->
name|dir_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|me
operator|->
name|dir_info
operator|==
name|NULL
condition|)
block|{
name|mtree_entry_free
argument_list|(
name|me
argument_list|)
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for a mtree entry"
argument_list|)
expr_stmt|;
operator|*
name|m_entry
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|__archive_rb_tree_init
argument_list|(
operator|&
name|me
operator|->
name|dir_info
operator|->
name|rbtree
argument_list|,
operator|&
name|rb_ops
argument_list|)
expr_stmt|;
name|me
operator|->
name|dir_info
operator|->
name|children
operator|.
name|first
operator|=
name|NULL
expr_stmt|;
name|me
operator|->
name|dir_info
operator|->
name|children
operator|.
name|last
operator|=
operator|&
operator|(
name|me
operator|->
name|dir_info
operator|->
name|children
operator|.
name|first
operator|)
expr_stmt|;
name|me
operator|->
name|dir_info
operator|->
name|chnext
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|me
operator|->
name|filetype
operator|==
name|AE_IFREG
condition|)
block|{
name|me
operator|->
name|reg_info
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|me
operator|->
name|reg_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|me
operator|->
name|reg_info
operator|==
name|NULL
condition|)
block|{
name|mtree_entry_free
argument_list|(
name|me
argument_list|)
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for a mtree entry"
argument_list|)
expr_stmt|;
operator|*
name|m_entry
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|me
operator|->
name|reg_info
operator|->
name|compute_sum
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|m_entry
operator|=
name|me
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mtree_entry_free
parameter_list|(
name|struct
name|mtree_entry
modifier|*
name|me
parameter_list|)
block|{
name|archive_string_free
argument_list|(
operator|&
name|me
operator|->
name|parentdir
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|me
operator|->
name|basename
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|me
operator|->
name|pathname
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|me
operator|->
name|symlink
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|me
operator|->
name|uname
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|me
operator|->
name|gname
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|me
operator|->
name|fflags_text
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|me
operator|->
name|dir_info
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|me
operator|->
name|reg_info
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|me
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_write_mtree_header
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|mtree_writer
modifier|*
name|mtree
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|struct
name|mtree_entry
modifier|*
name|mtree_entry
decl_stmt|;
name|int
name|r
decl_stmt|,
name|r2
decl_stmt|;
if|if
condition|(
name|mtree
operator|->
name|first
condition|)
block|{
name|mtree
operator|->
name|first
operator|=
literal|0
expr_stmt|;
name|archive_strcat
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
literal|"#mtree\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mtree
operator|->
name|keys
operator|&
name|SET_KEYS
operator|)
operator|==
literal|0
condition|)
name|mtree
operator|->
name|output_global_set
operator|=
literal|0
expr_stmt|;
comment|/* Disalbed. */
block|}
name|mtree
operator|->
name|entry_bytes_remaining
operator|=
name|archive_entry_size
argument_list|(
name|entry
argument_list|)
expr_stmt|;
comment|/* While directory only mode, we do not handle non directory files. */
if|if
condition|(
name|mtree
operator|->
name|dironly
operator|&&
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
operator|!=
name|AE_IFDIR
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
name|r2
operator|=
name|mtree_entry_new
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
operator|&
name|mtree_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|r2
operator|<
name|ARCHIVE_WARN
condition|)
return|return
operator|(
name|r2
operator|)
return|;
name|r
operator|=
name|mtree_entry_tree_add
argument_list|(
name|a
argument_list|,
operator|&
name|mtree_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|ARCHIVE_WARN
condition|)
block|{
name|mtree_entry_free
argument_list|(
name|mtree_entry
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
name|mtree
operator|->
name|mtree_entry
operator|=
name|mtree_entry
expr_stmt|;
comment|/* If the current file is a regular file, we have to 	 * compute the sum of its content. 	 * Initialize a bunch of sum check context. */
if|if
condition|(
name|mtree_entry
operator|->
name|reg_info
condition|)
name|sum_init
argument_list|(
name|mtree
argument_list|)
expr_stmt|;
return|return
operator|(
name|r2
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|write_mtree_entry
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|mtree_entry
modifier|*
name|me
parameter_list|)
block|{
name|struct
name|mtree_writer
modifier|*
name|mtree
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|struct
name|archive_string
modifier|*
name|str
decl_stmt|;
name|int
name|keys
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
name|me
operator|->
name|dir_info
condition|)
block|{
if|if
condition|(
name|mtree
operator|->
name|classic
condition|)
block|{
comment|/* 			 * Output a comment line to describe the full 			 * pathname of the entry as mtree utility does 			 * while generating classic format. 			 */
if|if
condition|(
operator|!
name|mtree
operator|->
name|dironly
condition|)
name|archive_strappend_char
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|me
operator|->
name|parentdir
operator|.
name|s
condition|)
name|archive_string_sprintf
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
literal|"# %s/%s\n"
argument_list|,
name|me
operator|->
name|parentdir
operator|.
name|s
argument_list|,
name|me
operator|->
name|basename
operator|.
name|s
argument_list|)
expr_stmt|;
else|else
name|archive_string_sprintf
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
literal|"# %s\n"
argument_list|,
name|me
operator|->
name|basename
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mtree
operator|->
name|output_global_set
condition|)
name|write_global
argument_list|(
name|mtree
argument_list|)
expr_stmt|;
block|}
name|archive_string_empty
argument_list|(
operator|&
name|mtree
operator|->
name|ebuf
argument_list|)
expr_stmt|;
name|str
operator|=
operator|(
name|mtree
operator|->
name|indent
operator|||
name|mtree
operator|->
name|classic
operator|)
condition|?
operator|&
name|mtree
operator|->
name|ebuf
else|:
operator|&
name|mtree
operator|->
name|buf
expr_stmt|;
if|if
condition|(
operator|!
name|mtree
operator|->
name|classic
operator|&&
name|me
operator|->
name|parentdir
operator|.
name|s
condition|)
block|{
comment|/* 		 * If generating format is not classic one(v1), output 		 * a full pathname. 		 */
name|mtree_quote
argument_list|(
name|str
argument_list|,
name|me
operator|->
name|parentdir
operator|.
name|s
argument_list|)
expr_stmt|;
name|archive_strappend_char
argument_list|(
name|str
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
block|}
name|mtree_quote
argument_list|(
name|str
argument_list|,
name|me
operator|->
name|basename
operator|.
name|s
argument_list|)
expr_stmt|;
name|keys
operator|=
name|get_global_set_keys
argument_list|(
name|mtree
argument_list|,
name|me
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|keys
operator|&
name|F_NLINK
operator|)
operator|!=
literal|0
operator|&&
name|me
operator|->
name|nlink
operator|!=
literal|1
operator|&&
name|me
operator|->
name|filetype
operator|!=
name|AE_IFDIR
condition|)
name|archive_string_sprintf
argument_list|(
name|str
argument_list|,
literal|" nlink=%u"
argument_list|,
name|me
operator|->
name|nlink
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|keys
operator|&
name|F_GNAME
operator|)
operator|!=
literal|0
operator|&&
name|archive_strlen
argument_list|(
operator|&
name|me
operator|->
name|gname
argument_list|)
operator|>
literal|0
condition|)
block|{
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" gname="
argument_list|)
expr_stmt|;
name|mtree_quote
argument_list|(
name|str
argument_list|,
name|me
operator|->
name|gname
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|keys
operator|&
name|F_UNAME
operator|)
operator|!=
literal|0
operator|&&
name|archive_strlen
argument_list|(
operator|&
name|me
operator|->
name|uname
argument_list|)
operator|>
literal|0
condition|)
block|{
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" uname="
argument_list|)
expr_stmt|;
name|mtree_quote
argument_list|(
name|str
argument_list|,
name|me
operator|->
name|uname
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|keys
operator|&
name|F_FLAGS
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
name|me
operator|->
name|fflags_text
argument_list|)
operator|>
literal|0
condition|)
block|{
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" flags="
argument_list|)
expr_stmt|;
name|mtree_quote
argument_list|(
name|str
argument_list|,
name|me
operator|->
name|fflags_text
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mtree
operator|->
name|set
operator|.
name|processing
operator|&&
operator|(
name|mtree
operator|->
name|set
operator|.
name|keys
operator|&
name|F_FLAGS
operator|)
operator|!=
literal|0
condition|)
comment|/* Overwrite the global parameter. */
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" flags=none"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|keys
operator|&
name|F_TIME
operator|)
operator|!=
literal|0
condition|)
name|archive_string_sprintf
argument_list|(
name|str
argument_list|,
literal|" time=%jd.%jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|me
operator|->
name|mtime
argument_list|,
operator|(
name|intmax_t
operator|)
name|me
operator|->
name|mtime_nsec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|keys
operator|&
name|F_MODE
operator|)
operator|!=
literal|0
condition|)
name|archive_string_sprintf
argument_list|(
name|str
argument_list|,
literal|" mode=%o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|me
operator|->
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|keys
operator|&
name|F_GID
operator|)
operator|!=
literal|0
condition|)
name|archive_string_sprintf
argument_list|(
name|str
argument_list|,
literal|" gid=%jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|me
operator|->
name|gid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|keys
operator|&
name|F_UID
operator|)
operator|!=
literal|0
condition|)
name|archive_string_sprintf
argument_list|(
name|str
argument_list|,
literal|" uid=%jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|me
operator|->
name|uid
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|me
operator|->
name|filetype
condition|)
block|{
case|case
name|AE_IFLNK
case|:
if|if
condition|(
operator|(
name|keys
operator|&
name|F_TYPE
operator|)
operator|!=
literal|0
condition|)
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" type=link"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|keys
operator|&
name|F_SLINK
operator|)
operator|!=
literal|0
condition|)
block|{
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" link="
argument_list|)
expr_stmt|;
name|mtree_quote
argument_list|(
name|str
argument_list|,
name|me
operator|->
name|symlink
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AE_IFSOCK
case|:
if|if
condition|(
operator|(
name|keys
operator|&
name|F_TYPE
operator|)
operator|!=
literal|0
condition|)
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" type=socket"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AE_IFCHR
case|:
if|if
condition|(
operator|(
name|keys
operator|&
name|F_TYPE
operator|)
operator|!=
literal|0
condition|)
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" type=char"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|keys
operator|&
name|F_DEV
operator|)
operator|!=
literal|0
condition|)
block|{
name|archive_string_sprintf
argument_list|(
name|str
argument_list|,
literal|" device=native,%ju,%ju"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|me
operator|->
name|rdevmajor
argument_list|,
operator|(
name|uintmax_t
operator|)
name|me
operator|->
name|rdevminor
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AE_IFBLK
case|:
if|if
condition|(
operator|(
name|keys
operator|&
name|F_TYPE
operator|)
operator|!=
literal|0
condition|)
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" type=block"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|keys
operator|&
name|F_DEV
operator|)
operator|!=
literal|0
condition|)
block|{
name|archive_string_sprintf
argument_list|(
name|str
argument_list|,
literal|" device=native,%ju,%ju"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|me
operator|->
name|rdevmajor
argument_list|,
operator|(
name|uintmax_t
operator|)
name|me
operator|->
name|rdevminor
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AE_IFDIR
case|:
if|if
condition|(
operator|(
name|keys
operator|&
name|F_TYPE
operator|)
operator|!=
literal|0
condition|)
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" type=dir"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AE_IFIFO
case|:
if|if
condition|(
operator|(
name|keys
operator|&
name|F_TYPE
operator|)
operator|!=
literal|0
condition|)
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" type=fifo"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AE_IFREG
case|:
default|default:
comment|/* Handle unknown file types as regular files. */
if|if
condition|(
operator|(
name|keys
operator|&
name|F_TYPE
operator|)
operator|!=
literal|0
condition|)
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" type=file"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|keys
operator|&
name|F_SIZE
operator|)
operator|!=
literal|0
condition|)
name|archive_string_sprintf
argument_list|(
name|str
argument_list|,
literal|" size=%jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|me
operator|->
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Write a bunch of sum. */
if|if
condition|(
name|me
operator|->
name|reg_info
condition|)
name|sum_write
argument_list|(
name|str
argument_list|,
name|me
operator|->
name|reg_info
argument_list|)
expr_stmt|;
name|archive_strappend_char
argument_list|(
name|str
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtree
operator|->
name|indent
operator|||
name|mtree
operator|->
name|classic
condition|)
name|mtree_indent
argument_list|(
name|mtree
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtree
operator|->
name|buf
operator|.
name|length
operator|>
literal|32768
condition|)
block|{
name|ret
operator|=
name|__archive_write_output
argument_list|(
name|a
argument_list|,
name|mtree
operator|->
name|buf
operator|.
name|s
argument_list|,
name|mtree
operator|->
name|buf
operator|.
name|length
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|ARCHIVE_OK
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|write_dot_dot_entry
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|mtree_entry
modifier|*
name|n
parameter_list|)
block|{
name|struct
name|mtree_writer
modifier|*
name|mtree
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|parentdir
operator|.
name|s
condition|)
block|{
if|if
condition|(
name|mtree
operator|->
name|indent
condition|)
block|{
name|int
name|i
decl_stmt|,
name|pd
init|=
name|mtree
operator|->
name|depth
operator|*
literal|4
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pd
condition|;
name|i
operator|++
control|)
name|archive_strappend_char
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
name|archive_string_sprintf
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
literal|"# %s/%s\n"
argument_list|,
name|n
operator|->
name|parentdir
operator|.
name|s
argument_list|,
name|n
operator|->
name|basename
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mtree
operator|->
name|indent
condition|)
block|{
name|archive_string_empty
argument_list|(
operator|&
name|mtree
operator|->
name|ebuf
argument_list|)
expr_stmt|;
name|archive_strncat
argument_list|(
operator|&
name|mtree
operator|->
name|ebuf
argument_list|,
literal|"..\n\n"
argument_list|,
operator|(
name|mtree
operator|->
name|dironly
operator|)
condition|?
literal|3
else|:
literal|4
argument_list|)
expr_stmt|;
name|mtree_indent
argument_list|(
name|mtree
argument_list|)
expr_stmt|;
block|}
else|else
name|archive_strncat
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
literal|"..\n\n"
argument_list|,
operator|(
name|mtree
operator|->
name|dironly
operator|)
condition|?
literal|3
else|:
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtree
operator|->
name|buf
operator|.
name|length
operator|>
literal|32768
condition|)
block|{
name|ret
operator|=
name|__archive_write_output
argument_list|(
name|a
argument_list|,
name|mtree
operator|->
name|buf
operator|.
name|s
argument_list|,
name|mtree
operator|->
name|buf
operator|.
name|length
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|ARCHIVE_OK
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write mtree entries saved at attr_counter_set_collect() function.  */
end_comment

begin_function
specifier|static
name|int
name|write_mtree_entry_tree
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|mtree_writer
modifier|*
name|mtree
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|struct
name|mtree_entry
modifier|*
name|np
init|=
name|mtree
operator|->
name|root
decl_stmt|;
name|struct
name|archive_rb_node
modifier|*
name|n
decl_stmt|;
name|int
name|ret
decl_stmt|;
do|do
block|{
if|if
condition|(
name|mtree
operator|->
name|output_global_set
condition|)
block|{
comment|/* 			 * Collect attribute infomation to know which value 			 * is frequently used among the children. 			 */
name|attr_counter_set_reset
argument_list|(
name|mtree
argument_list|)
expr_stmt|;
name|ARCHIVE_RB_TREE_FOREACH
argument_list|(
argument|n
argument_list|,
argument|&(np->dir_info->rbtree)
argument_list|)
block|{
name|struct
name|mtree_entry
modifier|*
name|e
init|=
operator|(
expr|struct
name|mtree_entry
operator|*
operator|)
name|n
decl_stmt|;
if|if
condition|(
name|attr_counter_set_collect
argument_list|(
name|mtree
argument_list|,
name|e
argument_list|)
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|np
operator|->
name|dir_info
operator|->
name|virtual
operator|||
name|mtree
operator|->
name|classic
condition|)
block|{
name|ret
operator|=
name|write_mtree_entry
argument_list|(
name|a
argument_list|,
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
else|else
block|{
comment|/* Whenever output_global_set is enabled 			 * output global value(/set keywords) 			 * even if the directory entry is not allowd 			 * to be written because the global values 			 * can be used for the children. */
if|if
condition|(
name|mtree
operator|->
name|output_global_set
condition|)
name|write_global
argument_list|(
name|mtree
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Output the attribute of all files except directory files. 		 */
name|mtree
operator|->
name|depth
operator|++
expr_stmt|;
name|ARCHIVE_RB_TREE_FOREACH
argument_list|(
argument|n
argument_list|,
argument|&(np->dir_info->rbtree)
argument_list|)
block|{
name|struct
name|mtree_entry
modifier|*
name|e
init|=
operator|(
expr|struct
name|mtree_entry
operator|*
operator|)
name|n
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|dir_info
condition|)
name|mtree_entry_add_child_tail
argument_list|(
name|np
argument_list|,
name|e
argument_list|)
expr_stmt|;
else|else
block|{
name|ret
operator|=
name|write_mtree_entry
argument_list|(
name|a
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
name|mtree
operator|->
name|depth
operator|--
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|dir_info
operator|->
name|children
operator|.
name|first
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Descend the tree. 			 */
name|np
operator|=
name|np
operator|->
name|dir_info
operator|->
name|children
operator|.
name|first
expr_stmt|;
if|if
condition|(
name|mtree
operator|->
name|indent
condition|)
name|mtree
operator|->
name|depth
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|mtree
operator|->
name|classic
condition|)
block|{
comment|/* 			 * While printing mtree classic, if there are not 			 * any directory files(except "." and "..") in the 			 * directory, output two dots ".." as returning 			 * the parent directory. 			 */
name|ret
operator|=
name|write_dot_dot_entry
argument_list|(
name|a
argument_list|,
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
while|while
condition|(
name|np
operator|!=
name|np
operator|->
name|parent
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|dir_info
operator|->
name|chnext
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * Ascend the tree; go back to the parent. 				 */
if|if
condition|(
name|mtree
operator|->
name|indent
condition|)
name|mtree
operator|->
name|depth
operator|--
expr_stmt|;
if|if
condition|(
name|mtree
operator|->
name|classic
condition|)
block|{
name|ret
operator|=
name|write_dot_dot_entry
argument_list|(
name|a
argument_list|,
name|np
operator|->
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|np
operator|=
name|np
operator|->
name|parent
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Switch to next mtree entry in the directory. 				 */
name|np
operator|=
name|np
operator|->
name|dir_info
operator|->
name|chnext
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|np
operator|!=
name|np
operator|->
name|parent
condition|)
do|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_write_mtree_finish_entry
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|mtree_writer
modifier|*
name|mtree
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|struct
name|mtree_entry
modifier|*
name|me
decl_stmt|;
if|if
condition|(
operator|(
name|me
operator|=
name|mtree
operator|->
name|mtree_entry
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
name|mtree
operator|->
name|mtree_entry
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|me
operator|->
name|reg_info
condition|)
name|sum_final
argument_list|(
name|mtree
argument_list|,
name|me
operator|->
name|reg_info
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_write_mtree_close
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|mtree_writer
modifier|*
name|mtree
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|mtree
operator|->
name|root
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|write_mtree_entry_tree
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_write_set_bytes_in_last_block
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|__archive_write_output
argument_list|(
name|a
argument_list|,
name|mtree
operator|->
name|buf
operator|.
name|s
argument_list|,
name|mtree
operator|->
name|buf
operator|.
name|length
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|archive_write_mtree_data
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|struct
name|mtree_writer
modifier|*
name|mtree
init|=
name|a
operator|->
name|format_data
decl_stmt|;
if|if
condition|(
name|n
operator|>
name|mtree
operator|->
name|entry_bytes_remaining
condition|)
name|n
operator|=
operator|(
name|size_t
operator|)
name|mtree
operator|->
name|entry_bytes_remaining
expr_stmt|;
name|mtree
operator|->
name|entry_bytes_remaining
operator|-=
name|n
expr_stmt|;
comment|/* We don't need to compute a regular file sum */
if|if
condition|(
name|mtree
operator|->
name|mtree_entry
operator|==
name|NULL
condition|)
return|return
operator|(
name|n
operator|)
return|;
if|if
condition|(
name|mtree
operator|->
name|mtree_entry
operator|->
name|filetype
operator|==
name|AE_IFREG
condition|)
name|sum_update
argument_list|(
name|mtree
argument_list|,
name|buff
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_write_mtree_free
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|mtree_writer
modifier|*
name|mtree
init|=
name|a
operator|->
name|format_data
decl_stmt|;
if|if
condition|(
name|mtree
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
comment|/* Make sure we dot not leave any entries. */
name|mtree_entry_register_free
argument_list|(
name|mtree
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|mtree
operator|->
name|cur_dirstr
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|mtree
operator|->
name|ebuf
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|)
expr_stmt|;
name|attr_counter_set_free
argument_list|(
name|mtree
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mtree
argument_list|)
expr_stmt|;
name|a
operator|->
name|format_data
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_write_mtree_options
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|mtree_writer
modifier|*
name|mtree
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|int
name|keybit
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|key
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'a'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"all"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
operator|~
literal|0
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"cksum"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_CKSUM
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"device"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_DEV
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"dironly"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mtree
operator|->
name|dironly
operator|=
operator|(
name|value
operator|!=
name|NULL
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"flags"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_FLAGS
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"gid"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_GID
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"gname"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_GNAME
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"indent"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mtree
operator|->
name|indent
operator|=
operator|(
name|value
operator|!=
name|NULL
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"link"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_SLINK
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"md5"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"md5digest"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_MD5
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"mode"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_MODE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"nlink"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_NLINK
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"ripemd160digest"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"rmd160"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"rmd160digest"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_RMD160
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"sha1"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"sha1digest"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_SHA1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"sha256"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"sha256digest"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_SHA256
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"sha384"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"sha384digest"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_SHA384
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"sha512"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"sha512digest"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_SHA512
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"size"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_SIZE
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"time"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_TIME
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"type"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_TYPE
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"uid"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_UID
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"uname"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_UNAME
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"use-set"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mtree
operator|->
name|output_global_set
operator|=
operator|(
name|value
operator|!=
name|NULL
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
break|break;
block|}
if|if
condition|(
name|keybit
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
name|mtree
operator|->
name|keys
operator||=
name|keybit
expr_stmt|;
else|else
name|mtree
operator|->
name|keys
operator|&=
operator|~
name|keybit
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
comment|/* Note: The "warn" return is just to inform the options 	 * supervisor that we didn't handle it.  It will generate 	 * a suitable error if no one used this option. */
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_write_set_format_mtree_default
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
name|struct
name|archive_write
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_write
operator|*
operator|)
name|_a
decl_stmt|;
name|struct
name|mtree_writer
modifier|*
name|mtree
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_WRITE_MAGIC
argument_list|,
name|ARCHIVE_STATE_NEW
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|format_free
operator|!=
name|NULL
condition|)
call|(
name|a
operator|->
name|format_free
call|)
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mtree
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mtree
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate mtree data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|mtree
operator|->
name|mtree_entry
operator|=
name|NULL
expr_stmt|;
name|mtree
operator|->
name|first
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
operator|(
name|mtree
operator|->
name|set
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mtree
operator|->
name|set
argument_list|)
argument_list|)
expr_stmt|;
name|mtree
operator|->
name|keys
operator|=
name|DEFAULT_KEYS
expr_stmt|;
name|mtree
operator|->
name|dironly
operator|=
literal|0
expr_stmt|;
name|mtree
operator|->
name|indent
operator|=
literal|0
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|mtree
operator|->
name|ebuf
argument_list|)
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|)
expr_stmt|;
name|mtree_entry_register_init
argument_list|(
name|mtree
argument_list|)
expr_stmt|;
name|a
operator|->
name|format_data
operator|=
name|mtree
expr_stmt|;
name|a
operator|->
name|format_free
operator|=
name|archive_write_mtree_free
expr_stmt|;
name|a
operator|->
name|format_name
operator|=
literal|"mtree"
expr_stmt|;
name|a
operator|->
name|format_options
operator|=
name|archive_write_mtree_options
expr_stmt|;
name|a
operator|->
name|format_write_header
operator|=
name|archive_write_mtree_header
expr_stmt|;
name|a
operator|->
name|format_close
operator|=
name|archive_write_mtree_close
expr_stmt|;
name|a
operator|->
name|format_write_data
operator|=
name|archive_write_mtree_data
expr_stmt|;
name|a
operator|->
name|format_finish_entry
operator|=
name|archive_write_mtree_finish_entry
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_MTREE
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"mtree"
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
name|int
name|archive_write_set_format_mtree
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
return|return
name|archive_write_set_format_mtree_default
argument_list|(
name|_a
argument_list|,
literal|"archive_write_set_format_mtree"
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|archive_write_set_format_mtree_classic
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
name|archive_write_set_format_mtree_default
argument_list|(
name|_a
argument_list|,
literal|"archive_write_set_format_mtree_classic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_OK
condition|)
block|{
name|struct
name|archive_write
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_write
operator|*
operator|)
name|_a
decl_stmt|;
name|struct
name|mtree_writer
modifier|*
name|mtree
decl_stmt|;
name|mtree
operator|=
operator|(
expr|struct
name|mtree_writer
operator|*
operator|)
name|a
operator|->
name|format_data
expr_stmt|;
comment|/* Set to output a mtree archive in classic format. */
name|mtree
operator|->
name|classic
operator|=
literal|1
expr_stmt|;
comment|/* Basically, mtree classic format uses '/set' global 		 * value. */
name|mtree
operator|->
name|output_global_set
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sum_init
parameter_list|(
name|struct
name|mtree_writer
modifier|*
name|mtree
parameter_list|)
block|{
name|mtree
operator|->
name|compute_sum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mtree
operator|->
name|keys
operator|&
name|F_CKSUM
condition|)
block|{
name|mtree
operator|->
name|compute_sum
operator||=
name|F_CKSUM
expr_stmt|;
name|mtree
operator|->
name|crc
operator|=
literal|0
expr_stmt|;
name|mtree
operator|->
name|crc_len
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_MD5
if|if
condition|(
name|mtree
operator|->
name|keys
operator|&
name|F_MD5
condition|)
block|{
if|if
condition|(
name|archive_md5_init
argument_list|(
operator|&
name|mtree
operator|->
name|md5ctx
argument_list|)
operator|==
name|ARCHIVE_OK
condition|)
name|mtree
operator|->
name|compute_sum
operator||=
name|F_MD5
expr_stmt|;
else|else
name|mtree
operator|->
name|keys
operator|&=
operator|~
name|F_MD5
expr_stmt|;
comment|/* Not supported. */
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_RMD160
if|if
condition|(
name|mtree
operator|->
name|keys
operator|&
name|F_RMD160
condition|)
block|{
if|if
condition|(
name|archive_rmd160_init
argument_list|(
operator|&
name|mtree
operator|->
name|rmd160ctx
argument_list|)
operator|==
name|ARCHIVE_OK
condition|)
name|mtree
operator|->
name|compute_sum
operator||=
name|F_RMD160
expr_stmt|;
else|else
name|mtree
operator|->
name|keys
operator|&=
operator|~
name|F_RMD160
expr_stmt|;
comment|/* Not supported. */
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA1
if|if
condition|(
name|mtree
operator|->
name|keys
operator|&
name|F_SHA1
condition|)
block|{
if|if
condition|(
name|archive_sha1_init
argument_list|(
operator|&
name|mtree
operator|->
name|sha1ctx
argument_list|)
operator|==
name|ARCHIVE_OK
condition|)
name|mtree
operator|->
name|compute_sum
operator||=
name|F_SHA1
expr_stmt|;
else|else
name|mtree
operator|->
name|keys
operator|&=
operator|~
name|F_SHA1
expr_stmt|;
comment|/* Not supported. */
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA256
if|if
condition|(
name|mtree
operator|->
name|keys
operator|&
name|F_SHA256
condition|)
block|{
if|if
condition|(
name|archive_sha256_init
argument_list|(
operator|&
name|mtree
operator|->
name|sha256ctx
argument_list|)
operator|==
name|ARCHIVE_OK
condition|)
name|mtree
operator|->
name|compute_sum
operator||=
name|F_SHA256
expr_stmt|;
else|else
name|mtree
operator|->
name|keys
operator|&=
operator|~
name|F_SHA256
expr_stmt|;
comment|/* Not supported. */
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA384
if|if
condition|(
name|mtree
operator|->
name|keys
operator|&
name|F_SHA384
condition|)
block|{
if|if
condition|(
name|archive_sha384_init
argument_list|(
operator|&
name|mtree
operator|->
name|sha384ctx
argument_list|)
operator|==
name|ARCHIVE_OK
condition|)
name|mtree
operator|->
name|compute_sum
operator||=
name|F_SHA384
expr_stmt|;
else|else
name|mtree
operator|->
name|keys
operator|&=
operator|~
name|F_SHA384
expr_stmt|;
comment|/* Not supported. */
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA512
if|if
condition|(
name|mtree
operator|->
name|keys
operator|&
name|F_SHA512
condition|)
block|{
if|if
condition|(
name|archive_sha512_init
argument_list|(
operator|&
name|mtree
operator|->
name|sha512ctx
argument_list|)
operator|==
name|ARCHIVE_OK
condition|)
name|mtree
operator|->
name|compute_sum
operator||=
name|F_SHA512
expr_stmt|;
else|else
name|mtree
operator|->
name|keys
operator|&=
operator|~
name|F_SHA512
expr_stmt|;
comment|/* Not supported. */
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|sum_update
parameter_list|(
name|struct
name|mtree_writer
modifier|*
name|mtree
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
if|if
condition|(
name|mtree
operator|->
name|compute_sum
operator|&
name|F_CKSUM
condition|)
block|{
comment|/* 		 * Compute a POSIX 1003.2 checksum 		 */
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|nn
decl_stmt|;
for|for
control|(
name|nn
operator|=
name|n
operator|,
name|p
operator|=
name|buff
init|;
name|nn
operator|--
condition|;
operator|++
name|p
control|)
name|COMPUTE_CRC
argument_list|(
name|mtree
operator|->
name|crc
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|mtree
operator|->
name|crc_len
operator|+=
name|n
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_MD5
if|if
condition|(
name|mtree
operator|->
name|compute_sum
operator|&
name|F_MD5
condition|)
name|archive_md5_update
argument_list|(
operator|&
name|mtree
operator|->
name|md5ctx
argument_list|,
name|buff
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_RMD160
if|if
condition|(
name|mtree
operator|->
name|compute_sum
operator|&
name|F_RMD160
condition|)
name|archive_rmd160_update
argument_list|(
operator|&
name|mtree
operator|->
name|rmd160ctx
argument_list|,
name|buff
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA1
if|if
condition|(
name|mtree
operator|->
name|compute_sum
operator|&
name|F_SHA1
condition|)
name|archive_sha1_update
argument_list|(
operator|&
name|mtree
operator|->
name|sha1ctx
argument_list|,
name|buff
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA256
if|if
condition|(
name|mtree
operator|->
name|compute_sum
operator|&
name|F_SHA256
condition|)
name|archive_sha256_update
argument_list|(
operator|&
name|mtree
operator|->
name|sha256ctx
argument_list|,
name|buff
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA384
if|if
condition|(
name|mtree
operator|->
name|compute_sum
operator|&
name|F_SHA384
condition|)
name|archive_sha384_update
argument_list|(
operator|&
name|mtree
operator|->
name|sha384ctx
argument_list|,
name|buff
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA512
if|if
condition|(
name|mtree
operator|->
name|compute_sum
operator|&
name|F_SHA512
condition|)
name|archive_sha512_update
argument_list|(
operator|&
name|mtree
operator|->
name|sha512ctx
argument_list|,
name|buff
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|sum_final
parameter_list|(
name|struct
name|mtree_writer
modifier|*
name|mtree
parameter_list|,
name|struct
name|reg_info
modifier|*
name|reg
parameter_list|)
block|{
if|if
condition|(
name|mtree
operator|->
name|compute_sum
operator|&
name|F_CKSUM
condition|)
block|{
name|uint64_t
name|len
decl_stmt|;
comment|/* Include the length of the file. */
for|for
control|(
name|len
operator|=
name|mtree
operator|->
name|crc_len
init|;
name|len
operator|!=
literal|0
condition|;
name|len
operator|>>=
literal|8
control|)
name|COMPUTE_CRC
argument_list|(
name|mtree
operator|->
name|crc
argument_list|,
name|len
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|reg
operator|->
name|crc
operator|=
operator|~
name|mtree
operator|->
name|crc
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_MD5
if|if
condition|(
name|mtree
operator|->
name|compute_sum
operator|&
name|F_MD5
condition|)
name|archive_md5_final
argument_list|(
operator|&
name|mtree
operator|->
name|md5ctx
argument_list|,
name|reg
operator|->
name|buf_md5
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_RMD160
if|if
condition|(
name|mtree
operator|->
name|compute_sum
operator|&
name|F_RMD160
condition|)
name|archive_rmd160_final
argument_list|(
operator|&
name|mtree
operator|->
name|rmd160ctx
argument_list|,
name|reg
operator|->
name|buf_rmd160
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA1
if|if
condition|(
name|mtree
operator|->
name|compute_sum
operator|&
name|F_SHA1
condition|)
name|archive_sha1_final
argument_list|(
operator|&
name|mtree
operator|->
name|sha1ctx
argument_list|,
name|reg
operator|->
name|buf_sha1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA256
if|if
condition|(
name|mtree
operator|->
name|compute_sum
operator|&
name|F_SHA256
condition|)
name|archive_sha256_final
argument_list|(
operator|&
name|mtree
operator|->
name|sha256ctx
argument_list|,
name|reg
operator|->
name|buf_sha256
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA384
if|if
condition|(
name|mtree
operator|->
name|compute_sum
operator|&
name|F_SHA384
condition|)
name|archive_sha384_final
argument_list|(
operator|&
name|mtree
operator|->
name|sha384ctx
argument_list|,
name|reg
operator|->
name|buf_sha384
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA512
if|if
condition|(
name|mtree
operator|->
name|compute_sum
operator|&
name|F_SHA512
condition|)
name|archive_sha512_final
argument_list|(
operator|&
name|mtree
operator|->
name|sha512ctx
argument_list|,
name|reg
operator|->
name|buf_sha512
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Save what types of sum are computed. */
name|reg
operator|->
name|compute_sum
operator|=
name|mtree
operator|->
name|compute_sum
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ARCHIVE_HAS_MD5
argument_list|)
operator|||
name|defined
argument_list|(
name|ARCHIVE_HAS_RMD160
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|ARCHIVE_HAS_SHA1
argument_list|)
operator|||
name|defined
argument_list|(
name|ARCHIVE_HAS_SHA256
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|ARCHIVE_HAS_SHA384
argument_list|)
operator|||
name|defined
argument_list|(
name|ARCHIVE_HAS_SHA512
argument_list|)
end_if

begin_function
specifier|static
name|void
name|strappend_bin
parameter_list|(
name|struct
name|archive_string
modifier|*
name|s
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|bin
parameter_list|,
name|int
name|n
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|hex
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|archive_strappend_char
argument_list|(
name|s
argument_list|,
name|hex
index|[
name|bin
index|[
name|i
index|]
operator|>>
literal|4
index|]
argument_list|)
expr_stmt|;
name|archive_strappend_char
argument_list|(
name|s
argument_list|,
name|hex
index|[
name|bin
index|[
name|i
index|]
operator|&
literal|0x0f
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|sum_write
parameter_list|(
name|struct
name|archive_string
modifier|*
name|str
parameter_list|,
name|struct
name|reg_info
modifier|*
name|reg
parameter_list|)
block|{
if|if
condition|(
name|reg
operator|->
name|compute_sum
operator|&
name|F_CKSUM
condition|)
block|{
name|archive_string_sprintf
argument_list|(
name|str
argument_list|,
literal|" cksum=%ju"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|reg
operator|->
name|crc
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_MD5
if|if
condition|(
name|reg
operator|->
name|compute_sum
operator|&
name|F_MD5
condition|)
block|{
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" md5digest="
argument_list|)
expr_stmt|;
name|strappend_bin
argument_list|(
name|str
argument_list|,
name|reg
operator|->
name|buf_md5
argument_list|,
sizeof|sizeof
argument_list|(
name|reg
operator|->
name|buf_md5
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_RMD160
if|if
condition|(
name|reg
operator|->
name|compute_sum
operator|&
name|F_RMD160
condition|)
block|{
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" rmd160digest="
argument_list|)
expr_stmt|;
name|strappend_bin
argument_list|(
name|str
argument_list|,
name|reg
operator|->
name|buf_rmd160
argument_list|,
sizeof|sizeof
argument_list|(
name|reg
operator|->
name|buf_rmd160
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA1
if|if
condition|(
name|reg
operator|->
name|compute_sum
operator|&
name|F_SHA1
condition|)
block|{
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" sha1digest="
argument_list|)
expr_stmt|;
name|strappend_bin
argument_list|(
name|str
argument_list|,
name|reg
operator|->
name|buf_sha1
argument_list|,
sizeof|sizeof
argument_list|(
name|reg
operator|->
name|buf_sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA256
if|if
condition|(
name|reg
operator|->
name|compute_sum
operator|&
name|F_SHA256
condition|)
block|{
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" sha256digest="
argument_list|)
expr_stmt|;
name|strappend_bin
argument_list|(
name|str
argument_list|,
name|reg
operator|->
name|buf_sha256
argument_list|,
sizeof|sizeof
argument_list|(
name|reg
operator|->
name|buf_sha256
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA384
if|if
condition|(
name|reg
operator|->
name|compute_sum
operator|&
name|F_SHA384
condition|)
block|{
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" sha384digest="
argument_list|)
expr_stmt|;
name|strappend_bin
argument_list|(
name|str
argument_list|,
name|reg
operator|->
name|buf_sha384
argument_list|,
sizeof|sizeof
argument_list|(
name|reg
operator|->
name|buf_sha384
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA512
if|if
condition|(
name|reg
operator|->
name|compute_sum
operator|&
name|F_SHA512
condition|)
block|{
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" sha512digest="
argument_list|)
expr_stmt|;
name|strappend_bin
argument_list|(
name|str
argument_list|,
name|reg
operator|->
name|buf_sha512
argument_list|,
sizeof|sizeof
argument_list|(
name|reg
operator|->
name|buf_sha512
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|mtree_entry_cmp_node
parameter_list|(
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|n1
parameter_list|,
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|n2
parameter_list|)
block|{
specifier|const
name|struct
name|mtree_entry
modifier|*
name|e1
init|=
operator|(
specifier|const
expr|struct
name|mtree_entry
operator|*
operator|)
name|n1
decl_stmt|;
specifier|const
name|struct
name|mtree_entry
modifier|*
name|e2
init|=
operator|(
specifier|const
expr|struct
name|mtree_entry
operator|*
operator|)
name|n2
decl_stmt|;
return|return
operator|(
name|strcmp
argument_list|(
name|e2
operator|->
name|basename
operator|.
name|s
argument_list|,
name|e1
operator|->
name|basename
operator|.
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mtree_entry_cmp_key
parameter_list|(
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|n
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|)
block|{
specifier|const
name|struct
name|mtree_entry
modifier|*
name|e
init|=
operator|(
specifier|const
expr|struct
name|mtree_entry
operator|*
operator|)
name|n
decl_stmt|;
return|return
operator|(
name|strcmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|key
argument_list|,
name|e
operator|->
name|basename
operator|.
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_function
specifier|static
name|int
name|cleanup_backslash_1
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
name|int
name|mb
decl_stmt|,
name|dos
decl_stmt|;
name|mb
operator|=
name|dos
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
operator|>
literal|127
condition|)
name|mb
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
comment|/* If we have not met any multi-byte characters, 			 * we can replace '\' with '/'. */
if|if
condition|(
operator|!
name|mb
condition|)
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
name|dos
operator|=
literal|1
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mb
operator|||
operator|!
name|dos
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cleanup_backslash_2
parameter_list|(
name|wchar_t
modifier|*
name|p
parameter_list|)
block|{
comment|/* Convert a path-separator from '\' to  '/' */
while|while
condition|(
operator|*
name|p
operator|!=
literal|L'
expr|\0'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|L'
expr|\\'
condition|)
operator|*
name|p
operator|=
literal|L'
expr|/'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Generate a parent directory name and a base name from a pathname.  */
end_comment

begin_function
specifier|static
name|int
name|mtree_entry_setup_filenames
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|mtree_entry
modifier|*
name|file
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|pathname
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|dirname
decl_stmt|,
modifier|*
name|slash
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|ret
init|=
name|ARCHIVE_OK
decl_stmt|;
name|archive_strcpy
argument_list|(
operator|&
name|file
operator|->
name|pathname
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
comment|/* 	 * Convert a path-separator from '\' to  '/' 	 */
if|if
condition|(
name|cleanup_backslash_1
argument_list|(
name|file
operator|->
name|pathname
operator|.
name|s
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|const
name|wchar_t
modifier|*
name|wp
init|=
name|archive_entry_pathname_w
argument_list|(
name|entry
argument_list|)
decl_stmt|;
name|struct
name|archive_wstring
name|ws
decl_stmt|;
if|if
condition|(
name|wp
operator|!=
name|NULL
condition|)
block|{
name|int
name|r
decl_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|ws
argument_list|)
expr_stmt|;
name|archive_wstrcpy
argument_list|(
operator|&
name|ws
argument_list|,
name|wp
argument_list|)
expr_stmt|;
name|cleanup_backslash_2
argument_list|(
name|ws
operator|.
name|s
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|file
operator|->
name|pathname
operator|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|archive_string_append_from_wcs
argument_list|(
operator|&
operator|(
name|file
operator|->
name|pathname
operator|)
argument_list|,
name|ws
operator|.
name|s
argument_list|,
name|ws
operator|.
name|length
argument_list|)
expr_stmt|;
name|archive_wstring_free
argument_list|(
operator|&
name|ws
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
operator|&&
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
block|}
else|#
directive|else
operator|(
name|void
operator|)
name|a
expr_stmt|;
comment|/* UNUSED */
endif|#
directive|endif
name|pathname
operator|=
name|file
operator|->
name|pathname
operator|.
name|s
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pathname
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|archive_strcpy
argument_list|(
operator|&
name|file
operator|->
name|basename
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
name|archive_strcpy
argument_list|(
operator|&
operator|(
name|file
operator|->
name|parentdir
operator|)
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|len
operator|=
name|file
operator|->
name|parentdir
operator|.
name|length
expr_stmt|;
name|p
operator|=
name|dirname
operator|=
name|file
operator|->
name|parentdir
operator|.
name|s
expr_stmt|;
comment|/* 	 * Remove leading '/' and '../' elements 	 */
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
break|break;
elseif|else
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'/'
condition|)
block|{
name|p
operator|+=
literal|3
expr_stmt|;
name|len
operator|-=
literal|3
expr_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|p
operator|!=
name|dirname
condition|)
block|{
name|memmove
argument_list|(
name|dirname
argument_list|,
name|p
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|dirname
expr_stmt|;
block|}
comment|/* 	 * Remove "/","/." and "/.." elements from tail. 	 */
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|size_t
name|ll
init|=
name|len
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|1
operator|&&
name|p
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'/'
operator|&&
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
name|p
index|[
name|len
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|2
operator|&&
name|p
index|[
name|len
operator|-
literal|3
index|]
operator|==
literal|'/'
operator|&&
name|p
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
name|p
index|[
name|len
operator|-
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|-=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|ll
operator|==
name|len
condition|)
break|break;
block|}
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
comment|/* Convert '//' --> '/' */
name|strcpy
argument_list|(
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'/'
condition|)
comment|/* Convert '/./' --> '/' */
name|strcpy
argument_list|(
name|p
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* Convert 'dir/dir1/../dir2/' 				 *     --> 'dir/dir2/' 				 */
name|char
modifier|*
name|rp
init|=
name|p
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|rp
operator|>=
name|dirname
condition|)
block|{
if|if
condition|(
operator|*
name|rp
operator|==
literal|'/'
condition|)
break|break;
operator|--
name|rp
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|>
name|dirname
condition|)
block|{
name|strcpy
argument_list|(
name|rp
argument_list|,
name|p
operator|+
literal|3
argument_list|)
expr_stmt|;
name|p
operator|=
name|rp
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|dirname
argument_list|,
name|p
operator|+
literal|4
argument_list|)
expr_stmt|;
name|p
operator|=
name|dirname
expr_stmt|;
block|}
block|}
else|else
name|p
operator|++
expr_stmt|;
block|}
else|else
name|p
operator|++
expr_stmt|;
block|}
name|p
operator|=
name|dirname
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * Add "./" prefiex. 	 * NOTE: If the pathname does not have a path separator, we have 	 * to add "./" to the head of the pathename because mtree reader 	 * will suppose that it is v1(a.k.a classic) mtree format and 	 * change the directory unexpectedly and so it will make a wrong 	 * path. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"./"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|archive_string
name|as
decl_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|as
argument_list|)
expr_stmt|;
name|archive_strcpy
argument_list|(
operator|&
name|as
argument_list|,
literal|"./"
argument_list|)
expr_stmt|;
name|archive_strncat
argument_list|(
operator|&
name|as
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
name|file
operator|->
name|parentdir
argument_list|)
expr_stmt|;
name|archive_string_concat
argument_list|(
operator|&
name|file
operator|->
name|parentdir
argument_list|,
operator|&
name|as
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|as
argument_list|)
expr_stmt|;
name|p
operator|=
name|file
operator|->
name|parentdir
operator|.
name|s
expr_stmt|;
name|len
operator|=
name|archive_strlen
argument_list|(
operator|&
name|file
operator|->
name|parentdir
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Find out the position which points the last position of 	 * path separator('/'). 	 */
name|slash
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
name|slash
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|slash
operator|==
name|NULL
condition|)
block|{
comment|/* The pathname doesn't have a parent directory. */
name|file
operator|->
name|parentdir
operator|.
name|length
operator|=
name|len
expr_stmt|;
name|archive_string_copy
argument_list|(
operator|&
operator|(
name|file
operator|->
name|basename
operator|)
argument_list|,
operator|&
operator|(
name|file
operator|->
name|parentdir
operator|)
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|file
operator|->
name|parentdir
operator|)
argument_list|)
expr_stmt|;
operator|*
name|file
operator|->
name|parentdir
operator|.
name|s
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* Make a basename from dirname and slash */
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
name|file
operator|->
name|parentdir
operator|.
name|length
operator|=
name|slash
operator|-
name|dirname
expr_stmt|;
name|archive_strcpy
argument_list|(
operator|&
operator|(
name|file
operator|->
name|basename
operator|)
argument_list|,
name|slash
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mtree_entry_create_virtual_dir
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|struct
name|mtree_entry
modifier|*
modifier|*
name|m_entry
parameter_list|)
block|{
name|struct
name|archive_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|mtree_entry
modifier|*
name|file
decl_stmt|;
name|int
name|r
decl_stmt|;
name|entry
operator|=
name|archive_entry_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
operator|*
name|m_entry
operator|=
name|NULL
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_entry_copy_pathname
argument_list|(
name|entry
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|archive_entry_set_mode
argument_list|(
name|entry
argument_list|,
name|AE_IFDIR
operator||
literal|0755
argument_list|)
expr_stmt|;
name|archive_entry_set_mtime
argument_list|(
name|entry
argument_list|,
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|=
name|mtree_entry_new
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
operator|&
name|file
argument_list|)
expr_stmt|;
name|archive_entry_free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|ARCHIVE_WARN
condition|)
block|{
operator|*
name|m_entry
operator|=
name|NULL
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|file
operator|->
name|dir_info
operator|->
name|virtual
operator|=
literal|1
expr_stmt|;
operator|*
name|m_entry
operator|=
name|file
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mtree_entry_register_add
parameter_list|(
name|struct
name|mtree_writer
modifier|*
name|mtree
parameter_list|,
name|struct
name|mtree_entry
modifier|*
name|file
parameter_list|)
block|{
name|file
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|mtree
operator|->
name|file_list
operator|.
name|last
operator|=
name|file
expr_stmt|;
name|mtree
operator|->
name|file_list
operator|.
name|last
operator|=
operator|&
operator|(
name|file
operator|->
name|next
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mtree_entry_register_init
parameter_list|(
name|struct
name|mtree_writer
modifier|*
name|mtree
parameter_list|)
block|{
name|mtree
operator|->
name|file_list
operator|.
name|first
operator|=
name|NULL
expr_stmt|;
name|mtree
operator|->
name|file_list
operator|.
name|last
operator|=
operator|&
operator|(
name|mtree
operator|->
name|file_list
operator|.
name|first
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mtree_entry_register_free
parameter_list|(
name|struct
name|mtree_writer
modifier|*
name|mtree
parameter_list|)
block|{
name|struct
name|mtree_entry
modifier|*
name|file
decl_stmt|,
modifier|*
name|file_next
decl_stmt|;
name|file
operator|=
name|mtree
operator|->
name|file_list
operator|.
name|first
expr_stmt|;
while|while
condition|(
name|file
operator|!=
name|NULL
condition|)
block|{
name|file_next
operator|=
name|file
operator|->
name|next
expr_stmt|;
name|mtree_entry_free
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|file
operator|=
name|file_next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mtree_entry_add_child_tail
parameter_list|(
name|struct
name|mtree_entry
modifier|*
name|parent
parameter_list|,
name|struct
name|mtree_entry
modifier|*
name|child
parameter_list|)
block|{
name|child
operator|->
name|dir_info
operator|->
name|chnext
operator|=
name|NULL
expr_stmt|;
operator|*
name|parent
operator|->
name|dir_info
operator|->
name|children
operator|.
name|last
operator|=
name|child
expr_stmt|;
name|parent
operator|->
name|dir_info
operator|->
name|children
operator|.
name|last
operator|=
operator|&
operator|(
name|child
operator|->
name|dir_info
operator|->
name|chnext
operator|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find a entry from a parent entry with the name.  */
end_comment

begin_function
specifier|static
name|struct
name|mtree_entry
modifier|*
name|mtree_entry_find_child
parameter_list|(
name|struct
name|mtree_entry
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|child_name
parameter_list|)
block|{
name|struct
name|mtree_entry
modifier|*
name|np
decl_stmt|;
if|if
condition|(
name|parent
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|np
operator|=
operator|(
expr|struct
name|mtree_entry
operator|*
operator|)
name|__archive_rb_tree_find_node
argument_list|(
operator|&
operator|(
name|parent
operator|->
name|dir_info
operator|->
name|rbtree
operator|)
argument_list|,
name|child_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|np
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_path_component
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|l
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|fn
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|l
operator|=
name|strlen
argument_list|(
name|fn
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
name|l
operator|=
name|p
operator|-
name|fn
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|n
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|memcpy
argument_list|(
name|name
argument_list|,
name|fn
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|name
index|[
name|l
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|l
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a new entry into the tree.  */
end_comment

begin_function
specifier|static
name|int
name|mtree_entry_tree_add
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|mtree_entry
modifier|*
modifier|*
name|filep
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
name|char
name|name
index|[
name|_MAX_FNAME
index|]
decl_stmt|;
comment|/* Included null terminator size. */
elif|#
directive|elif
name|defined
argument_list|(
name|NAME_MAX
argument_list|)
operator|&&
name|NAME_MAX
operator|>=
literal|255
name|char
name|name
index|[
name|NAME_MAX
operator|+
literal|1
index|]
decl_stmt|;
else|#
directive|else
name|char
name|name
index|[
literal|256
index|]
decl_stmt|;
endif|#
directive|endif
name|struct
name|mtree_writer
modifier|*
name|mtree
init|=
operator|(
expr|struct
name|mtree_writer
operator|*
operator|)
name|a
operator|->
name|format_data
decl_stmt|;
name|struct
name|mtree_entry
modifier|*
name|dent
decl_stmt|,
modifier|*
name|file
decl_stmt|,
modifier|*
name|np
decl_stmt|;
specifier|const
name|char
modifier|*
name|fn
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|l
decl_stmt|,
name|r
decl_stmt|;
name|file
operator|=
operator|*
name|filep
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|parentdir
operator|.
name|length
operator|==
literal|0
operator|&&
name|file
operator|->
name|basename
operator|.
name|length
operator|==
literal|1
operator|&&
name|file
operator|->
name|basename
operator|.
name|s
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
name|file
operator|->
name|parent
operator|=
name|file
expr_stmt|;
if|if
condition|(
name|mtree
operator|->
name|root
operator|!=
name|NULL
condition|)
block|{
name|np
operator|=
name|mtree
operator|->
name|root
expr_stmt|;
goto|goto
name|same_entry
goto|;
block|}
name|mtree
operator|->
name|root
operator|=
name|file
expr_stmt|;
name|mtree_entry_register_add
argument_list|(
name|mtree
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
if|if
condition|(
name|file
operator|->
name|parentdir
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Internal programing error "
literal|"in generating canonical name for %s"
argument_list|,
name|file
operator|->
name|pathname
operator|.
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|fn
operator|=
name|p
operator|=
name|file
operator|->
name|parentdir
operator|.
name|s
expr_stmt|;
comment|/* 	 * If the path of the parent directory of `file' entry is 	 * the same as the path of `cur_dirent', add `file' entry to 	 * `cur_dirent'. 	 */
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
operator|(
name|mtree
operator|->
name|cur_dirstr
operator|)
argument_list|)
operator|==
name|archive_strlen
argument_list|(
operator|&
operator|(
name|file
operator|->
name|parentdir
operator|)
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|mtree
operator|->
name|cur_dirstr
operator|.
name|s
argument_list|,
name|fn
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|__archive_rb_tree_insert_node
argument_list|(
operator|&
operator|(
name|mtree
operator|->
name|cur_dirent
operator|->
name|dir_info
operator|->
name|rbtree
operator|)
argument_list|,
operator|(
expr|struct
name|archive_rb_node
operator|*
operator|)
name|file
argument_list|)
condition|)
block|{
comment|/* There is the same name in the tree. */
name|np
operator|=
operator|(
expr|struct
name|mtree_entry
operator|*
operator|)
name|__archive_rb_tree_find_node
argument_list|(
operator|&
operator|(
name|mtree
operator|->
name|cur_dirent
operator|->
name|dir_info
operator|->
name|rbtree
operator|)
argument_list|,
name|file
operator|->
name|basename
operator|.
name|s
argument_list|)
expr_stmt|;
goto|goto
name|same_entry
goto|;
block|}
name|file
operator|->
name|parent
operator|=
name|mtree
operator|->
name|cur_dirent
expr_stmt|;
name|mtree_entry_register_add
argument_list|(
name|mtree
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
name|dent
operator|=
name|mtree
operator|->
name|root
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|l
operator|=
name|get_path_component
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
block|{
name|np
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|l
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"A name buffer is too small"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|l
operator|==
literal|1
operator|&&
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|dent
operator|!=
name|NULL
operator|&&
name|dent
operator|==
name|mtree
operator|->
name|root
condition|)
block|{
name|fn
operator|+=
name|l
expr_stmt|;
if|if
condition|(
name|fn
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|fn
operator|++
expr_stmt|;
continue|continue;
block|}
name|np
operator|=
name|mtree_entry_find_child
argument_list|(
name|dent
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
operator|||
name|fn
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
break|break;
comment|/* Find next sub directory. */
if|if
condition|(
operator|!
name|np
operator|->
name|dir_info
condition|)
block|{
comment|/* NOT Directory! */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"`%s' is not directory, we cannot insert `%s' "
argument_list|,
name|np
operator|->
name|pathname
operator|.
name|s
argument_list|,
name|file
operator|->
name|pathname
operator|.
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|fn
operator|+=
name|l
expr_stmt|;
if|if
condition|(
name|fn
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|fn
operator|++
expr_stmt|;
name|dent
operator|=
name|np
expr_stmt|;
block|}
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Create virtual parent directories. 		 */
while|while
condition|(
name|fn
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|struct
name|mtree_entry
modifier|*
name|vp
decl_stmt|;
name|struct
name|archive_string
name|as
decl_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|as
argument_list|)
expr_stmt|;
name|archive_strncat
argument_list|(
operator|&
name|as
argument_list|,
name|p
argument_list|,
name|fn
operator|-
name|p
operator|+
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|as
operator|.
name|s
index|[
name|as
operator|.
name|length
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|as
operator|.
name|s
index|[
name|as
operator|.
name|length
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|as
operator|.
name|length
operator|--
expr_stmt|;
block|}
name|r
operator|=
name|mtree_entry_create_virtual_dir
argument_list|(
name|a
argument_list|,
name|as
operator|.
name|s
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|as
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|ARCHIVE_WARN
condition|)
return|return
operator|(
name|r
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|vp
operator|->
name|pathname
operator|.
name|s
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vp
operator|->
name|parent
operator|=
name|vp
expr_stmt|;
name|mtree
operator|->
name|root
operator|=
name|vp
expr_stmt|;
block|}
else|else
block|{
name|__archive_rb_tree_insert_node
argument_list|(
operator|&
operator|(
name|dent
operator|->
name|dir_info
operator|->
name|rbtree
operator|)
argument_list|,
operator|(
expr|struct
name|archive_rb_node
operator|*
operator|)
name|vp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|parent
operator|=
name|dent
expr_stmt|;
block|}
name|mtree_entry_register_add
argument_list|(
name|mtree
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|np
operator|=
name|vp
expr_stmt|;
name|fn
operator|+=
name|l
expr_stmt|;
if|if
condition|(
name|fn
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|fn
operator|++
expr_stmt|;
name|l
operator|=
name|get_path_component
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|<
literal|0
condition|)
block|{
name|archive_string_free
argument_list|(
operator|&
name|as
argument_list|)
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"A name buffer is too small"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|dent
operator|=
name|np
expr_stmt|;
block|}
comment|/* Found out the parent directory where `file' can be 		 * inserted. */
name|mtree
operator|->
name|cur_dirent
operator|=
name|dent
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|mtree
operator|->
name|cur_dirstr
operator|)
argument_list|)
expr_stmt|;
name|archive_string_ensure
argument_list|(
operator|&
operator|(
name|mtree
operator|->
name|cur_dirstr
operator|)
argument_list|,
name|archive_strlen
argument_list|(
operator|&
operator|(
name|dent
operator|->
name|parentdir
operator|)
argument_list|)
operator|+
name|archive_strlen
argument_list|(
operator|&
operator|(
name|dent
operator|->
name|basename
operator|)
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
operator|(
name|dent
operator|->
name|parentdir
operator|)
argument_list|)
operator|+
name|archive_strlen
argument_list|(
operator|&
operator|(
name|dent
operator|->
name|basename
operator|)
argument_list|)
operator|==
literal|0
condition|)
name|mtree
operator|->
name|cur_dirstr
operator|.
name|s
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
operator|(
name|dent
operator|->
name|parentdir
operator|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|archive_string_copy
argument_list|(
operator|&
operator|(
name|mtree
operator|->
name|cur_dirstr
operator|)
argument_list|,
operator|&
operator|(
name|dent
operator|->
name|parentdir
operator|)
argument_list|)
expr_stmt|;
name|archive_strappend_char
argument_list|(
operator|&
operator|(
name|mtree
operator|->
name|cur_dirstr
operator|)
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
block|}
name|archive_string_concat
argument_list|(
operator|&
operator|(
name|mtree
operator|->
name|cur_dirstr
operator|)
argument_list|,
operator|&
operator|(
name|dent
operator|->
name|basename
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|__archive_rb_tree_insert_node
argument_list|(
operator|&
operator|(
name|dent
operator|->
name|dir_info
operator|->
name|rbtree
operator|)
argument_list|,
operator|(
expr|struct
name|archive_rb_node
operator|*
operator|)
name|file
argument_list|)
condition|)
block|{
name|np
operator|=
operator|(
expr|struct
name|mtree_entry
operator|*
operator|)
name|__archive_rb_tree_find_node
argument_list|(
operator|&
operator|(
name|dent
operator|->
name|dir_info
operator|->
name|rbtree
operator|)
argument_list|,
name|file
operator|->
name|basename
operator|.
name|s
argument_list|)
expr_stmt|;
goto|goto
name|same_entry
goto|;
block|}
name|file
operator|->
name|parent
operator|=
name|dent
expr_stmt|;
name|mtree_entry_register_add
argument_list|(
name|mtree
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
name|same_entry
label|:
comment|/* 	 * We have already has the entry the filename of which is 	 * the same. 	 */
name|r
operator|=
name|mtree_entry_exchange_same_entry
argument_list|(
name|a
argument_list|,
name|np
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|ARCHIVE_WARN
condition|)
return|return
operator|(
name|r
operator|)
return|;
if|if
condition|(
name|np
operator|->
name|dir_info
condition|)
name|np
operator|->
name|dir_info
operator|->
name|virtual
operator|=
literal|0
expr_stmt|;
operator|*
name|filep
operator|=
name|np
expr_stmt|;
name|mtree_entry_free
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mtree_entry_exchange_same_entry
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|mtree_entry
modifier|*
name|np
parameter_list|,
name|struct
name|mtree_entry
modifier|*
name|file
parameter_list|)
block|{
if|if
condition|(
operator|(
name|np
operator|->
name|mode
operator|&
name|AE_IFMT
operator|)
operator|!=
operator|(
name|file
operator|->
name|mode
operator|&
name|AE_IFMT
operator|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Found duplicate entries `%s' and its file type is "
literal|"different"
argument_list|,
name|np
operator|->
name|pathname
operator|.
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
comment|/* Update the existent mtree entry's attributes by the new one's. */
name|archive_string_empty
argument_list|(
operator|&
name|np
operator|->
name|symlink
argument_list|)
expr_stmt|;
name|archive_string_concat
argument_list|(
operator|&
name|np
operator|->
name|symlink
argument_list|,
operator|&
name|file
operator|->
name|symlink
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
name|np
operator|->
name|uname
argument_list|)
expr_stmt|;
name|archive_string_concat
argument_list|(
operator|&
name|np
operator|->
name|uname
argument_list|,
operator|&
name|file
operator|->
name|uname
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
name|np
operator|->
name|gname
argument_list|)
expr_stmt|;
name|archive_string_concat
argument_list|(
operator|&
name|np
operator|->
name|gname
argument_list|,
operator|&
name|file
operator|->
name|gname
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
name|np
operator|->
name|fflags_text
argument_list|)
expr_stmt|;
name|archive_string_concat
argument_list|(
operator|&
name|np
operator|->
name|fflags_text
argument_list|,
operator|&
name|file
operator|->
name|fflags_text
argument_list|)
expr_stmt|;
name|np
operator|->
name|nlink
operator|=
name|file
operator|->
name|nlink
expr_stmt|;
name|np
operator|->
name|filetype
operator|=
name|file
operator|->
name|filetype
expr_stmt|;
name|np
operator|->
name|mode
operator|=
name|file
operator|->
name|mode
expr_stmt|;
name|np
operator|->
name|size
operator|=
name|file
operator|->
name|size
expr_stmt|;
name|np
operator|->
name|uid
operator|=
name|file
operator|->
name|uid
expr_stmt|;
name|np
operator|->
name|gid
operator|=
name|file
operator|->
name|gid
expr_stmt|;
name|np
operator|->
name|fflags_set
operator|=
name|file
operator|->
name|fflags_set
expr_stmt|;
name|np
operator|->
name|fflags_clear
operator|=
name|file
operator|->
name|fflags_clear
expr_stmt|;
name|np
operator|->
name|mtime
operator|=
name|file
operator|->
name|mtime
expr_stmt|;
name|np
operator|->
name|mtime_nsec
operator|=
name|file
operator|->
name|mtime_nsec
expr_stmt|;
name|np
operator|->
name|rdevmajor
operator|=
name|file
operator|->
name|rdevmajor
expr_stmt|;
name|np
operator|->
name|rdevminor
operator|=
name|file
operator|->
name|rdevminor
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
end_function

end_unit

