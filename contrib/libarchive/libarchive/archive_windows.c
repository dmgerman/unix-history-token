begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009 Michihiro NAKAJIMA  * Copyright (c) 2003-2007 Kees Zeelenberg  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * A set of compatibility glue for building libarchive on Windows platforms.  *  * Originally created as "libarchive-nonposix.c" by Kees Zeelenberg  * for the GnuWin32 project, trimmed significantly by Tim Kientzle.  *  * Much of the original file was unnecessary for libarchive, because  * many of the features it emulated were not strictly necessary for  * libarchive.  I hope for this to shrink further as libarchive  * internals are gradually reworked to sit more naturally on both  * POSIX and Windows.  Any ideas for this are greatly appreciated.  *  * The biggest remaining issue is the dev/ino emulation; libarchive  * has a couple of public APIs that rely on dev/ino uniquely  * identifying a file.  This doesn't match well with Windows.  I'm  * considering alternative APIs.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_include
include|#
directive|include
file|"archive_platform.h"
end_include

begin_include
include|#
directive|include
file|"archive_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_hash.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_UTIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/utime.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_define
define|#
directive|define
name|EPOC_TIME
value|ARCHIVE_LITERAL_ULL(116444736000000000)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|<
literal|1300
end_if

begin_comment
comment|/* VS 6 does not provide SetFilePointerEx, so define it here.  */
end_comment

begin_function
specifier|static
name|BOOL
name|SetFilePointerEx
parameter_list|(
name|HANDLE
name|hFile
parameter_list|,
name|LARGE_INTEGER
name|liDistanceToMove
parameter_list|,
name|PLARGE_INTEGER
name|lpNewFilePointer
parameter_list|,
name|DWORD
name|dwMoveMethod
parameter_list|)
block|{
name|LARGE_INTEGER
name|li
decl_stmt|;
name|li
operator|.
name|QuadPart
operator|=
name|liDistanceToMove
operator|.
name|QuadPart
expr_stmt|;
name|li
operator|.
name|LowPart
operator|=
name|SetFilePointer
argument_list|(
name|hFile
argument_list|,
name|li
operator|.
name|LowPart
argument_list|,
operator|&
name|li
operator|.
name|HighPart
argument_list|,
name|dwMoveMethod
argument_list|)
expr_stmt|;
if|if
condition|(
name|lpNewFilePointer
condition|)
block|{
name|lpNewFilePointer
operator|->
name|QuadPart
operator|=
name|li
operator|.
name|QuadPart
expr_stmt|;
block|}
return|return
name|li
operator|.
name|LowPart
operator|!=
operator|-
literal|1
operator|||
name|GetLastError
argument_list|()
operator|==
name|NO_ERROR
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|ustat
block|{
name|int64_t
name|st_atime
decl_stmt|;
name|uint32_t
name|st_atime_nsec
decl_stmt|;
name|int64_t
name|st_ctime
decl_stmt|;
name|uint32_t
name|st_ctime_nsec
decl_stmt|;
name|int64_t
name|st_mtime
decl_stmt|;
name|uint32_t
name|st_mtime_nsec
decl_stmt|;
name|gid_t
name|st_gid
decl_stmt|;
comment|/* 64bits ino */
name|int64_t
name|st_ino
decl_stmt|;
name|mode_t
name|st_mode
decl_stmt|;
name|uint32_t
name|st_nlink
decl_stmt|;
name|uint64_t
name|st_size
decl_stmt|;
name|uid_t
name|st_uid
decl_stmt|;
name|dev_t
name|st_dev
decl_stmt|;
name|dev_t
name|st_rdev
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Local replacement for undocumented Windows CRT function. */
end_comment

begin_function_decl
specifier|static
name|void
name|la_dosmaperr
parameter_list|(
name|unsigned
name|long
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Transform 64-bits ino into 32-bits by hashing.  * You do not forget that really unique number size is 64-bits.  */
end_comment

begin_define
define|#
directive|define
name|INOSIZE
value|(8*sizeof(ino_t))
end_define

begin_comment
comment|/* 32 */
end_comment

begin_function
specifier|static
name|__inline
name|ino_t
name|getino
parameter_list|(
name|struct
name|ustat
modifier|*
name|ub
parameter_list|)
block|{
name|ULARGE_INTEGER
name|ino64
decl_stmt|;
name|ino64
operator|.
name|QuadPart
operator|=
name|ub
operator|->
name|st_ino
expr_stmt|;
comment|/* I don't know this hashing is correct way */
return|return
operator|(
name|ino64
operator|.
name|LowPart
operator|^
operator|(
name|ino64
operator|.
name|LowPart
operator|>>
name|INOSIZE
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Prepend "\\?\" to the path name and convert it to unicode to permit  * an extended-length path for a maximum total path length of 32767  * characters.  * see also http://msdn.microsoft.com/en-us/library/aa365247.aspx  */
end_comment

begin_function
specifier|static
name|wchar_t
modifier|*
name|permissive_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|wchar_t
modifier|*
name|wn
decl_stmt|,
modifier|*
name|wnp
decl_stmt|;
name|wchar_t
modifier|*
name|ws
decl_stmt|,
modifier|*
name|wsp
decl_stmt|;
name|DWORD
name|l
decl_stmt|,
name|len
decl_stmt|,
name|slen
decl_stmt|;
name|int
name|unc
decl_stmt|;
name|len
operator|=
operator|(
name|DWORD
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|wn
operator|=
name|malloc
argument_list|(
operator|(
name|len
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wn
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|l
operator|=
name|MultiByteToWideChar
argument_list|(
name|CP_ACP
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
name|wn
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|wn
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|wn
index|[
name|l
index|]
operator|=
literal|L'
expr|\0'
expr_stmt|;
comment|/* Get a full path names */
name|l
operator|=
name|GetFullPathNameW
argument_list|(
name|wn
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|wn
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|wnp
operator|=
name|malloc
argument_list|(
name|l
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wnp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|wn
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|len
operator|=
name|GetFullPathNameW
argument_list|(
name|wn
argument_list|,
name|l
argument_list|,
name|wnp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wn
argument_list|)
expr_stmt|;
name|wn
operator|=
name|wnp
expr_stmt|;
if|if
condition|(
name|wnp
index|[
literal|0
index|]
operator|==
literal|L'
expr|\\'
operator|&&
name|wnp
index|[
literal|1
index|]
operator|==
literal|L'
expr|\\'
operator|&&
name|wnp
index|[
literal|2
index|]
operator|==
literal|L'
expr|?'
operator|&&
name|wnp
index|[
literal|3
index|]
operator|==
literal|L'
expr|\\'
condition|)
comment|/* We have already permissive names. */
return|return
operator|(
name|wn
operator|)
return|;
if|if
condition|(
name|wnp
index|[
literal|0
index|]
operator|==
literal|L'
expr|\\'
operator|&&
name|wnp
index|[
literal|1
index|]
operator|==
literal|L'
expr|\\'
operator|&&
name|wnp
index|[
literal|2
index|]
operator|==
literal|L'
expr|.'
operator|&&
name|wnp
index|[
literal|3
index|]
operator|==
literal|L'
expr|\\'
condition|)
block|{
comment|/* Device names */
if|if
condition|(
operator|(
operator|(
name|wnp
index|[
literal|4
index|]
operator|>=
literal|L'
expr|a'
operator|&&
name|wnp
index|[
literal|4
index|]
operator|<=
literal|L'
expr|z'
operator|)
operator|||
operator|(
name|wnp
index|[
literal|4
index|]
operator|>=
literal|L'
expr|A'
operator|&&
name|wnp
index|[
literal|4
index|]
operator|<=
literal|L'
expr|Z'
operator|)
operator|)
operator|&&
name|wnp
index|[
literal|5
index|]
operator|==
literal|L'
expr|:'
operator|&&
name|wnp
index|[
literal|6
index|]
operator|==
literal|L'
expr|\\'
condition|)
name|wnp
index|[
literal|2
index|]
operator|=
literal|L'
expr|?'
expr_stmt|;
comment|/* Not device names. */
return|return
operator|(
name|wn
operator|)
return|;
block|}
name|unc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wnp
index|[
literal|0
index|]
operator|==
literal|L'
expr|\\'
operator|&&
name|wnp
index|[
literal|1
index|]
operator|==
literal|L'
expr|\\'
operator|&&
name|wnp
index|[
literal|2
index|]
operator|!=
literal|L'
expr|\\'
condition|)
block|{
name|wchar_t
modifier|*
name|p
init|=
operator|&
name|wnp
index|[
literal|2
index|]
decl_stmt|;
comment|/* Skip server-name letters. */
while|while
condition|(
operator|*
name|p
operator|!=
literal|L'
expr|\\'
operator|&&
operator|*
name|p
operator|!=
literal|L'
expr|\0'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|L'
expr|\\'
condition|)
block|{
name|wchar_t
modifier|*
name|rp
init|=
operator|++
name|p
decl_stmt|;
comment|/* Skip share-name letters. */
while|while
condition|(
operator|*
name|p
operator|!=
literal|L'
expr|\\'
operator|&&
operator|*
name|p
operator|!=
literal|L'
expr|\0'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|L'
expr|\\'
operator|&&
name|p
operator|!=
name|rp
condition|)
block|{
comment|/* Now, match patterns such as 				 * "\\server-name\share-name\" */
name|wnp
operator|+=
literal|2
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
name|unc
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|slen
operator|=
literal|4
operator|+
operator|(
name|unc
operator|*
literal|4
operator|)
operator|+
name|len
operator|+
literal|1
expr_stmt|;
name|ws
operator|=
name|wsp
operator|=
name|malloc
argument_list|(
name|slen
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ws
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|wn
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* prepend "\\?\" */
name|wcsncpy
argument_list|(
name|wsp
argument_list|,
literal|L"\\\\?\\"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|wsp
operator|+=
literal|4
expr_stmt|;
name|slen
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|unc
condition|)
block|{
comment|/* append "UNC\" ---> "\\?\UNC\" */
name|wcsncpy
argument_list|(
name|wsp
argument_list|,
literal|L"UNC\\"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|wsp
operator|+=
literal|4
expr_stmt|;
name|slen
operator|-=
literal|4
expr_stmt|;
block|}
name|wcsncpy
argument_list|(
name|wsp
argument_list|,
name|wnp
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|wsp
index|[
name|slen
operator|-
literal|1
index|]
operator|=
literal|L'
expr|\0'
expr_stmt|;
comment|/* Ensure null termination. */
name|free
argument_list|(
name|wn
argument_list|)
expr_stmt|;
return|return
operator|(
name|ws
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|HANDLE
name|la_CreateFile
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|DWORD
name|dwDesiredAccess
parameter_list|,
name|DWORD
name|dwShareMode
parameter_list|,
name|LPSECURITY_ATTRIBUTES
name|lpSecurityAttributes
parameter_list|,
name|DWORD
name|dwCreationDisposition
parameter_list|,
name|DWORD
name|dwFlagsAndAttributes
parameter_list|,
name|HANDLE
name|hTemplateFile
parameter_list|)
block|{
name|wchar_t
modifier|*
name|wpath
decl_stmt|;
name|HANDLE
name|handle
decl_stmt|;
name|handle
operator|=
name|CreateFileA
argument_list|(
name|path
argument_list|,
name|dwDesiredAccess
argument_list|,
name|dwShareMode
argument_list|,
name|lpSecurityAttributes
argument_list|,
name|dwCreationDisposition
argument_list|,
name|dwFlagsAndAttributes
argument_list|,
name|hTemplateFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|!=
name|INVALID_HANDLE_VALUE
condition|)
return|return
operator|(
name|handle
operator|)
return|;
if|if
condition|(
name|GetLastError
argument_list|()
operator|!=
name|ERROR_PATH_NOT_FOUND
condition|)
return|return
operator|(
name|handle
operator|)
return|;
name|wpath
operator|=
name|permissive_name
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpath
operator|==
name|NULL
condition|)
return|return
operator|(
name|handle
operator|)
return|;
name|handle
operator|=
name|CreateFileW
argument_list|(
name|wpath
argument_list|,
name|dwDesiredAccess
argument_list|,
name|dwShareMode
argument_list|,
name|lpSecurityAttributes
argument_list|,
name|dwCreationDisposition
argument_list|,
name|dwFlagsAndAttributes
argument_list|,
name|hTemplateFile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wpath
argument_list|)
expr_stmt|;
return|return
operator|(
name|handle
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|la_GetFunctionKernel32
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|static
name|HINSTANCE
name|lib
decl_stmt|;
specifier|static
name|int
name|set
decl_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
block|{
name|set
operator|=
literal|1
expr_stmt|;
name|lib
operator|=
name|LoadLibrary
argument_list|(
literal|"kernel32.dll"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lib
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't load kernel32.dll?!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|void
operator|*
operator|)
name|GetProcAddress
argument_list|(
name|lib
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|la_CreateHardLinkW
parameter_list|(
name|wchar_t
modifier|*
name|linkname
parameter_list|,
name|wchar_t
modifier|*
name|target
parameter_list|)
block|{
specifier|static
name|BOOLEAN
function_decl|(
name|WINAPI
modifier|*
name|f
function_decl|)
parameter_list|(
name|LPWSTR
parameter_list|,
name|LPWSTR
parameter_list|,
name|LPSECURITY_ATTRIBUTES
parameter_list|)
function_decl|;
specifier|static
name|int
name|set
decl_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
block|{
name|set
operator|=
literal|1
expr_stmt|;
name|f
operator|=
name|la_GetFunctionKernel32
argument_list|(
literal|"CreateHardLinkW"
argument_list|)
expr_stmt|;
block|}
return|return
name|f
operator|==
name|NULL
condition|?
literal|0
else|:
call|(
modifier|*
name|f
call|)
argument_list|(
name|linkname
argument_list|,
name|target
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make a link to src called dst.  */
end_comment

begin_function
specifier|static
name|int
name|__link
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
specifier|const
name|char
modifier|*
name|dst
parameter_list|)
block|{
name|wchar_t
modifier|*
name|wsrc
decl_stmt|,
modifier|*
name|wdst
decl_stmt|;
name|int
name|res
decl_stmt|,
name|retval
decl_stmt|;
name|DWORD
name|attr
decl_stmt|;
if|if
condition|(
name|src
operator|==
name|NULL
operator|||
name|dst
operator|==
name|NULL
condition|)
block|{
name|set_errno
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|wsrc
operator|=
name|permissive_name
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|wdst
operator|=
name|permissive_name
argument_list|(
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|wsrc
operator|==
name|NULL
operator|||
name|wdst
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|wsrc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wdst
argument_list|)
expr_stmt|;
name|set_errno
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|attr
operator|=
name|GetFileAttributesW
argument_list|(
name|wsrc
argument_list|)
operator|)
operator|!=
operator|(
name|DWORD
operator|)
operator|-
literal|1
condition|)
block|{
name|res
operator|=
name|la_CreateHardLinkW
argument_list|(
name|wdst
argument_list|,
name|wsrc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* wsrc does not exist; try src prepend it with the dirname of wdst */
name|wchar_t
modifier|*
name|wnewsrc
decl_stmt|,
modifier|*
name|slash
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|slen
decl_stmt|,
name|wlen
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|src
argument_list|)
operator|>=
literal|3
operator|&&
name|isalpha
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|0
index|]
argument_list|)
operator|&&
name|src
index|[
literal|1
index|]
operator|==
literal|':'
operator|&&
name|src
index|[
literal|2
index|]
operator|==
literal|'\\'
condition|)
block|{
comment|/* Original src name is already full-path */
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'\\'
condition|)
block|{
comment|/* Original src name is almost full-path 			 * (maybe src name is without drive) */
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
name|wnewsrc
operator|=
name|malloc
argument_list|(
operator|(
name|wcslen
argument_list|(
name|wsrc
argument_list|)
operator|+
name|wcslen
argument_list|(
name|wdst
argument_list|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wnewsrc
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
comment|/* Copying a dirname of wdst */
name|wcscpy
argument_list|(
name|wnewsrc
argument_list|,
name|wdst
argument_list|)
expr_stmt|;
name|slash
operator|=
name|wcsrchr
argument_list|(
name|wnewsrc
argument_list|,
literal|L'
expr|\\'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
operator|!=
name|NULL
condition|)
operator|*
operator|++
name|slash
operator|=
literal|L'
expr|\0'
expr_stmt|;
else|else
name|wcscat
argument_list|(
name|wnewsrc
argument_list|,
literal|L"\\"
argument_list|)
expr_stmt|;
comment|/* Converting multi-byte src to wide-char src */
name|wlen
operator|=
operator|(
name|int
operator|)
name|wcslen
argument_list|(
name|wsrc
argument_list|)
expr_stmt|;
name|slen
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|n
operator|=
name|MultiByteToWideChar
argument_list|(
name|CP_ACP
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|slen
argument_list|,
name|wsrc
argument_list|,
name|wlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|wnewsrc
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|wsrc
index|[
name|i
index|]
operator|==
literal|L'
expr|/'
condition|)
name|wsrc
index|[
name|i
index|]
operator|=
literal|L'
expr|\\'
expr_stmt|;
name|wcsncat
argument_list|(
name|wnewsrc
argument_list|,
name|wsrc
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* Check again */
name|attr
operator|=
name|GetFileAttributesW
argument_list|(
name|wnewsrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|==
operator|(
name|DWORD
operator|)
operator|-
literal|1
operator|||
operator|(
name|attr
operator|&
name|FILE_ATTRIBUTE_DIRECTORY
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|attr
operator|==
operator|(
name|DWORD
operator|)
operator|-
literal|1
condition|)
name|la_dosmaperr
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|errno
operator|=
name|EPERM
expr_stmt|;
name|free
argument_list|(
name|wnewsrc
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
name|res
operator|=
name|la_CreateHardLinkW
argument_list|(
name|wdst
argument_list|,
name|wnewsrc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wnewsrc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|==
literal|0
condition|)
block|{
name|la_dosmaperr
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|retval
operator|=
literal|0
expr_stmt|;
name|exit
label|:
name|free
argument_list|(
name|wsrc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wdst
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Make a hard link to src called dst.  */
end_comment

begin_function
name|int
name|__la_link
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
specifier|const
name|char
modifier|*
name|dst
parameter_list|)
block|{
return|return
name|__link
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|__la_ftruncate
parameter_list|(
name|int
name|fd
parameter_list|,
name|off_t
name|length
parameter_list|)
block|{
name|LARGE_INTEGER
name|distance
decl_stmt|;
name|HANDLE
name|handle
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|handle
operator|=
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|GetFileType
argument_list|(
name|handle
argument_list|)
operator|!=
name|FILE_TYPE_DISK
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|distance
operator|.
name|QuadPart
operator|=
name|length
expr_stmt|;
if|if
condition|(
operator|!
name|SetFilePointerEx
argument_list|(
name|handle
argument_list|,
name|distance
argument_list|,
name|NULL
argument_list|,
name|FILE_BEGIN
argument_list|)
condition|)
block|{
name|la_dosmaperr
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|SetEndOfFile
argument_list|(
name|handle
argument_list|)
condition|)
block|{
name|la_dosmaperr
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|WINTIME
parameter_list|(
name|sec
parameter_list|,
name|usec
parameter_list|)
value|((Int32x32To64(sec, 10000000) + EPOC_TIME) + (usec * 10))
end_define

begin_function
specifier|static
name|int
name|__hutimes
parameter_list|(
name|HANDLE
name|handle
parameter_list|,
specifier|const
name|struct
name|__timeval
modifier|*
name|times
parameter_list|)
block|{
name|ULARGE_INTEGER
name|wintm
decl_stmt|;
name|FILETIME
name|fatime
decl_stmt|,
name|fmtime
decl_stmt|;
name|wintm
operator|.
name|QuadPart
operator|=
name|WINTIME
argument_list|(
name|times
index|[
literal|0
index|]
operator|.
name|tv_sec
argument_list|,
name|times
index|[
literal|0
index|]
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
name|fatime
operator|.
name|dwLowDateTime
operator|=
name|wintm
operator|.
name|LowPart
expr_stmt|;
name|fatime
operator|.
name|dwHighDateTime
operator|=
name|wintm
operator|.
name|HighPart
expr_stmt|;
name|wintm
operator|.
name|QuadPart
operator|=
name|WINTIME
argument_list|(
name|times
index|[
literal|1
index|]
operator|.
name|tv_sec
argument_list|,
name|times
index|[
literal|1
index|]
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
name|fmtime
operator|.
name|dwLowDateTime
operator|=
name|wintm
operator|.
name|LowPart
expr_stmt|;
name|fmtime
operator|.
name|dwHighDateTime
operator|=
name|wintm
operator|.
name|HighPart
expr_stmt|;
if|if
condition|(
name|SetFileTime
argument_list|(
name|handle
argument_list|,
name|NULL
argument_list|,
operator|&
name|fatime
argument_list|,
operator|&
name|fmtime
argument_list|)
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|__la_futimes
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|struct
name|__timeval
modifier|*
name|times
parameter_list|)
block|{
return|return
operator|(
name|__hutimes
argument_list|(
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|fd
argument_list|)
argument_list|,
name|times
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|__la_utimes
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|struct
name|__timeval
modifier|*
name|times
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|HANDLE
name|handle
decl_stmt|;
name|handle
operator|=
name|la_CreateFile
argument_list|(
name|name
argument_list|,
name|GENERIC_READ
operator||
name|GENERIC_WRITE
argument_list|,
name|FILE_SHARE_READ
operator||
name|FILE_SHARE_WRITE
argument_list|,
name|NULL
argument_list|,
name|OPEN_EXISTING
argument_list|,
name|FILE_FLAG_BACKUP_SEMANTICS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|==
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|la_dosmaperr
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ret
operator|=
name|__hutimes
argument_list|(
name|handle
argument_list|,
name|times
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|handle
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|__la_chdir
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|wchar_t
modifier|*
name|ws
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|SetCurrentDirectoryA
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|GetLastError
argument_list|()
operator|!=
name|ERROR_FILE_NOT_FOUND
condition|)
block|{
name|la_dosmaperr
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
name|ws
operator|=
name|permissive_name
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|ws
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|r
operator|=
name|SetCurrentDirectoryW
argument_list|(
name|ws
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ws
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|la_dosmaperr
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|__la_chmod
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|mode_t
name|mode
parameter_list|)
block|{
name|wchar_t
modifier|*
name|ws
decl_stmt|;
name|DWORD
name|attr
decl_stmt|;
name|BOOL
name|r
decl_stmt|;
name|ws
operator|=
name|NULL
expr_stmt|;
name|attr
operator|=
name|GetFileAttributesA
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|==
operator|(
name|DWORD
operator|)
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|GetLastError
argument_list|()
operator|!=
name|ERROR_FILE_NOT_FOUND
condition|)
block|{
name|la_dosmaperr
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ws
operator|=
name|permissive_name
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|ws
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|attr
operator|=
name|GetFileAttributesW
argument_list|(
name|ws
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|==
operator|(
name|DWORD
operator|)
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|ws
argument_list|)
expr_stmt|;
name|la_dosmaperr
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|mode
operator|&
name|_S_IWRITE
condition|)
name|attr
operator|&=
operator|~
name|FILE_ATTRIBUTE_READONLY
expr_stmt|;
else|else
name|attr
operator||=
name|FILE_ATTRIBUTE_READONLY
expr_stmt|;
if|if
condition|(
name|ws
operator|==
name|NULL
condition|)
name|r
operator|=
name|SetFileAttributesA
argument_list|(
name|path
argument_list|,
name|attr
argument_list|)
expr_stmt|;
else|else
block|{
name|r
operator|=
name|SetFileAttributesW
argument_list|(
name|ws
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ws
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|la_dosmaperr
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This fcntl is limited implemention.  */
end_comment

begin_function
name|int
name|__la_fcntl
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|cmd
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|HANDLE
name|handle
decl_stmt|;
name|handle
operator|=
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|GetFileType
argument_list|(
name|handle
argument_list|)
operator|==
name|FILE_TYPE_PIPE
condition|)
block|{
if|if
condition|(
name|cmd
operator|==
name|F_SETFL
operator|&&
name|val
operator|==
literal|0
condition|)
block|{
name|DWORD
name|mode
init|=
name|PIPE_WAIT
decl_stmt|;
if|if
condition|(
name|SetNamedPipeHandleState
argument_list|(
name|handle
argument_list|,
operator|&
name|mode
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|__int64
name|__la_lseek
parameter_list|(
name|int
name|fd
parameter_list|,
name|__int64
name|offset
parameter_list|,
name|int
name|whence
parameter_list|)
block|{
name|LARGE_INTEGER
name|distance
decl_stmt|;
name|LARGE_INTEGER
name|newpointer
decl_stmt|;
name|HANDLE
name|handle
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|handle
operator|=
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|GetFileType
argument_list|(
name|handle
argument_list|)
operator|!=
name|FILE_TYPE_DISK
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|distance
operator|.
name|QuadPart
operator|=
name|offset
expr_stmt|;
if|if
condition|(
operator|!
name|SetFilePointerEx
argument_list|(
name|handle
argument_list|,
name|distance
argument_list|,
operator|&
name|newpointer
argument_list|,
name|whence
argument_list|)
condition|)
block|{
name|DWORD
name|lasterr
decl_stmt|;
name|lasterr
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
if|if
condition|(
name|lasterr
operator|==
name|ERROR_BROKEN_PIPE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|lasterr
operator|==
name|ERROR_ACCESS_DENIED
condition|)
name|errno
operator|=
name|EBADF
expr_stmt|;
else|else
name|la_dosmaperr
argument_list|(
name|lasterr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|newpointer
operator|.
name|QuadPart
operator|)
return|;
block|}
end_function

begin_function
name|int
name|__la_mkdir
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|mode_t
name|mode
parameter_list|)
block|{
name|wchar_t
modifier|*
name|ws
decl_stmt|;
name|int
name|r
decl_stmt|;
operator|(
name|void
operator|)
name|mode
expr_stmt|;
comment|/* UNUSED */
name|r
operator|=
name|CreateDirectoryA
argument_list|(
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|DWORD
name|lasterr
init|=
name|GetLastError
argument_list|()
decl_stmt|;
if|if
condition|(
name|lasterr
operator|!=
name|ERROR_FILENAME_EXCED_RANGE
operator|&&
name|lasterr
operator|!=
name|ERROR_PATH_NOT_FOUND
condition|)
block|{
name|la_dosmaperr
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
name|ws
operator|=
name|permissive_name
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|ws
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|r
operator|=
name|CreateDirectoryW
argument_list|(
name|ws
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ws
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|la_dosmaperr
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Windows' mbstowcs is differrent error handling from other unix mbstowcs.  * That one is using MultiByteToWideChar function with MB_PRECOMPOSED and  * MB_ERR_INVALID_CHARS flags.  * This implements for only to pass libarchive_test.  */
end_comment

begin_function
name|size_t
name|__la_mbstowcs
parameter_list|(
name|wchar_t
modifier|*
name|wcstr
parameter_list|,
specifier|const
name|char
modifier|*
name|mbstr
parameter_list|,
name|size_t
name|nwchars
parameter_list|)
block|{
return|return
operator|(
name|MultiByteToWideChar
argument_list|(
name|CP_ACP
argument_list|,
name|MB_ERR_INVALID_CHARS
argument_list|,
name|mbstr
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|mbstr
argument_list|)
argument_list|,
name|wcstr
argument_list|,
operator|(
name|int
operator|)
name|nwchars
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|__la_open
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|wchar_t
modifier|*
name|ws
decl_stmt|;
name|int
name|r
decl_stmt|,
name|pmode
decl_stmt|;
name|DWORD
name|attr
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pmode
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|ws
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|~
name|O_BINARY
operator|)
operator|==
name|O_RDONLY
condition|)
block|{
comment|/* 		 * When we open a directory, _open function returns  		 * "Permission denied" error. 		 */
name|attr
operator|=
name|GetFileAttributesA
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|==
operator|(
name|DWORD
operator|)
operator|-
literal|1
operator|&&
name|GetLastError
argument_list|()
operator|==
name|ERROR_PATH_NOT_FOUND
condition|)
block|{
name|ws
operator|=
name|permissive_name
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|ws
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|attr
operator|=
name|GetFileAttributesW
argument_list|(
name|ws
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attr
operator|==
operator|(
name|DWORD
operator|)
operator|-
literal|1
condition|)
block|{
name|la_dosmaperr
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ws
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|attr
operator|&
name|FILE_ATTRIBUTE_DIRECTORY
condition|)
block|{
name|HANDLE
name|handle
decl_stmt|;
if|if
condition|(
name|ws
operator|!=
name|NULL
condition|)
name|handle
operator|=
name|CreateFileW
argument_list|(
name|ws
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|OPEN_EXISTING
argument_list|,
name|FILE_FLAG_BACKUP_SEMANTICS
operator||
name|FILE_ATTRIBUTE_READONLY
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|handle
operator|=
name|CreateFileA
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|OPEN_EXISTING
argument_list|,
name|FILE_FLAG_BACKUP_SEMANTICS
operator||
name|FILE_ATTRIBUTE_READONLY
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ws
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|==
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|la_dosmaperr
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|r
operator|=
name|_open_osfhandle
argument_list|(
operator|(
name|intptr_t
operator|)
name|handle
argument_list|,
name|_O_RDONLY
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
block|}
if|if
condition|(
name|ws
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
comment|/* Borland has no mode argument. 		   TODO: Fix mode of new file.  */
name|r
operator|=
name|_open
argument_list|(
name|path
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|#
directive|else
name|r
operator|=
name|_open
argument_list|(
name|path
argument_list|,
name|flags
argument_list|,
name|pmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|r
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EACCES
operator|&&
operator|(
name|flags
operator|&
name|O_CREAT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* simular other POSIX system action to pass a test */
name|attr
operator|=
name|GetFileAttributesA
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|==
operator|(
name|DWORD
operator|)
operator|-
literal|1
condition|)
name|la_dosmaperr
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|attr
operator|&
name|FILE_ATTRIBUTE_DIRECTORY
condition|)
name|errno
operator|=
name|EISDIR
expr_stmt|;
else|else
name|errno
operator|=
name|EACCES
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|r
operator|>=
literal|0
operator|||
name|errno
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|ws
operator|=
name|permissive_name
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|ws
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|r
operator|=
name|_wopen
argument_list|(
name|ws
argument_list|,
name|flags
argument_list|,
name|pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EACCES
operator|&&
operator|(
name|flags
operator|&
name|O_CREAT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* simular other POSIX system action to pass a test */
name|attr
operator|=
name|GetFileAttributesW
argument_list|(
name|ws
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|==
operator|(
name|DWORD
operator|)
operator|-
literal|1
condition|)
name|la_dosmaperr
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|attr
operator|&
name|FILE_ATTRIBUTE_DIRECTORY
condition|)
name|errno
operator|=
name|EISDIR
expr_stmt|;
else|else
name|errno
operator|=
name|EACCES
expr_stmt|;
block|}
name|free
argument_list|(
name|ws
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
name|ssize_t
name|__la_read
parameter_list|(
name|int
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
block|{
name|HANDLE
name|handle
decl_stmt|;
name|DWORD
name|bytes_read
decl_stmt|,
name|lasterr
decl_stmt|;
name|int
name|r
decl_stmt|;
ifdef|#
directive|ifdef
name|_WIN64
if|if
condition|(
name|nbytes
operator|>
name|UINT32_MAX
condition|)
name|nbytes
operator|=
name|UINT32_MAX
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|handle
operator|=
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|GetFileType
argument_list|(
name|handle
argument_list|)
operator|==
name|FILE_TYPE_PIPE
condition|)
block|{
name|DWORD
name|sta
decl_stmt|;
if|if
condition|(
name|GetNamedPipeHandleState
argument_list|(
name|handle
argument_list|,
operator|&
name|sta
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|sta
operator|&
name|PIPE_NOWAIT
operator|)
operator|==
literal|0
condition|)
block|{
name|DWORD
name|avail
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|cnt
init|=
literal|3
decl_stmt|;
while|while
condition|(
name|PeekNamedPipe
argument_list|(
name|handle
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|avail
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
operator|&&
name|avail
operator|==
literal|0
operator|&&
operator|--
name|cnt
condition|)
name|Sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|avail
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|r
operator|=
name|ReadFile
argument_list|(
name|handle
argument_list|,
name|buf
argument_list|,
operator|(
name|uint32_t
operator|)
name|nbytes
argument_list|,
operator|&
name|bytes_read
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|lasterr
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
if|if
condition|(
name|lasterr
operator|==
name|ERROR_NO_DATA
condition|)
block|{
name|errno
operator|=
name|EAGAIN
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|lasterr
operator|==
name|ERROR_BROKEN_PIPE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|lasterr
operator|==
name|ERROR_ACCESS_DENIED
condition|)
name|errno
operator|=
name|EBADF
expr_stmt|;
else|else
name|la_dosmaperr
argument_list|(
name|lasterr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|ssize_t
operator|)
name|bytes_read
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Remove directory */
end_comment

begin_function
name|int
name|__la_rmdir
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|wchar_t
modifier|*
name|ws
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|_rmdir
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>=
literal|0
operator|||
name|errno
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|ws
operator|=
name|permissive_name
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|ws
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|r
operator|=
name|_wrmdir
argument_list|(
name|ws
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ws
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert Windows FILETIME to UTC */
end_comment

begin_function
name|__inline
specifier|static
name|void
name|fileTimeToUTC
parameter_list|(
specifier|const
name|FILETIME
modifier|*
name|filetime
parameter_list|,
name|time_t
modifier|*
name|time
parameter_list|,
name|long
modifier|*
name|ns
parameter_list|)
block|{
name|ULARGE_INTEGER
name|utc
decl_stmt|;
name|utc
operator|.
name|HighPart
operator|=
name|filetime
operator|->
name|dwHighDateTime
expr_stmt|;
name|utc
operator|.
name|LowPart
operator|=
name|filetime
operator|->
name|dwLowDateTime
expr_stmt|;
if|if
condition|(
name|utc
operator|.
name|QuadPart
operator|>=
name|EPOC_TIME
condition|)
block|{
name|utc
operator|.
name|QuadPart
operator|-=
name|EPOC_TIME
expr_stmt|;
operator|*
name|time
operator|=
call|(
name|time_t
call|)
argument_list|(
name|utc
operator|.
name|QuadPart
operator|/
literal|10000000
argument_list|)
expr_stmt|;
comment|/* milli seconds base */
operator|*
name|ns
operator|=
call|(
name|long
call|)
argument_list|(
name|utc
operator|.
name|QuadPart
operator|%
literal|10000000
argument_list|)
operator|*
literal|100
expr_stmt|;
comment|/* nano seconds base */
block|}
else|else
block|{
operator|*
name|time
operator|=
literal|0
expr_stmt|;
operator|*
name|ns
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Stat by handle  * Windows' stat() does not accept path which is added "\\?\" especially "?"  * character.  * It means we cannot access a long name path(which is longer than MAX_PATH).  * So I've implemented simular Windows' stat() to access the long name path.  * And I've added some feature.  * 1. set st_ino by nFileIndexHigh and nFileIndexLow of  *    BY_HANDLE_FILE_INFORMATION.  * 2. set st_nlink by nNumberOfLinks of BY_HANDLE_FILE_INFORMATION.  * 3. set st_dev by dwVolumeSerialNumber by BY_HANDLE_FILE_INFORMATION.  */
end_comment

begin_function
specifier|static
name|int
name|__hstat
parameter_list|(
name|HANDLE
name|handle
parameter_list|,
name|struct
name|ustat
modifier|*
name|st
parameter_list|)
block|{
name|BY_HANDLE_FILE_INFORMATION
name|info
decl_stmt|;
name|ULARGE_INTEGER
name|ino64
decl_stmt|;
name|DWORD
name|ftype
decl_stmt|;
name|mode_t
name|mode
decl_stmt|;
name|time_t
name|time
decl_stmt|;
name|long
name|ns
decl_stmt|;
switch|switch
condition|(
name|ftype
operator|=
name|GetFileType
argument_list|(
name|handle
argument_list|)
condition|)
block|{
case|case
name|FILE_TYPE_UNKNOWN
case|:
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|FILE_TYPE_CHAR
case|:
case|case
name|FILE_TYPE_PIPE
case|:
if|if
condition|(
name|ftype
operator|==
name|FILE_TYPE_CHAR
condition|)
block|{
name|st
operator|->
name|st_mode
operator|=
name|S_IFCHR
expr_stmt|;
name|st
operator|->
name|st_size
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|DWORD
name|avail
decl_stmt|;
name|st
operator|->
name|st_mode
operator|=
name|S_IFIFO
expr_stmt|;
if|if
condition|(
name|PeekNamedPipe
argument_list|(
name|handle
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|avail
argument_list|,
name|NULL
argument_list|)
condition|)
name|st
operator|->
name|st_size
operator|=
name|avail
expr_stmt|;
else|else
name|st
operator|->
name|st_size
operator|=
literal|0
expr_stmt|;
block|}
name|st
operator|->
name|st_atime
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|st_atime_nsec
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|st_mtime
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|st_mtime_nsec
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|st_ctime
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|st_ctime_nsec
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|st_ino
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|st_nlink
operator|=
literal|1
expr_stmt|;
name|st
operator|->
name|st_uid
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|st_gid
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|st_rdev
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|st_dev
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FILE_TYPE_DISK
case|:
break|break;
default|default:
comment|/* This ftype is undocumented type. */
name|la_dosmaperr
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ZeroMemory
argument_list|(
operator|&
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GetFileInformationByHandle
argument_list|(
name|handle
argument_list|,
operator|&
name|info
argument_list|)
condition|)
block|{
name|la_dosmaperr
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mode
operator|=
name|S_IRUSR
operator||
name|S_IRGRP
operator||
name|S_IROTH
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|.
name|dwFileAttributes
operator|&
name|FILE_ATTRIBUTE_READONLY
operator|)
operator|==
literal|0
condition|)
name|mode
operator||=
name|S_IWUSR
operator||
name|S_IWGRP
operator||
name|S_IWOTH
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|dwFileAttributes
operator|&
name|FILE_ATTRIBUTE_DIRECTORY
condition|)
name|mode
operator||=
name|S_IFDIR
operator||
name|S_IXUSR
operator||
name|S_IXGRP
operator||
name|S_IXOTH
expr_stmt|;
else|else
name|mode
operator||=
name|S_IFREG
expr_stmt|;
name|st
operator|->
name|st_mode
operator|=
name|mode
expr_stmt|;
name|fileTimeToUTC
argument_list|(
operator|&
name|info
operator|.
name|ftLastAccessTime
argument_list|,
operator|&
name|time
argument_list|,
operator|&
name|ns
argument_list|)
expr_stmt|;
name|st
operator|->
name|st_atime
operator|=
name|time
expr_stmt|;
name|st
operator|->
name|st_atime_nsec
operator|=
name|ns
expr_stmt|;
name|fileTimeToUTC
argument_list|(
operator|&
name|info
operator|.
name|ftLastWriteTime
argument_list|,
operator|&
name|time
argument_list|,
operator|&
name|ns
argument_list|)
expr_stmt|;
name|st
operator|->
name|st_mtime
operator|=
name|time
expr_stmt|;
name|st
operator|->
name|st_mtime_nsec
operator|=
name|ns
expr_stmt|;
name|fileTimeToUTC
argument_list|(
operator|&
name|info
operator|.
name|ftCreationTime
argument_list|,
operator|&
name|time
argument_list|,
operator|&
name|ns
argument_list|)
expr_stmt|;
name|st
operator|->
name|st_ctime
operator|=
name|time
expr_stmt|;
name|st
operator|->
name|st_ctime_nsec
operator|=
name|ns
expr_stmt|;
name|st
operator|->
name|st_size
operator|=
operator|(
call|(
name|int64_t
call|)
argument_list|(
name|info
operator|.
name|nFileSizeHigh
argument_list|)
operator|*
operator|(
operator|(
name|int64_t
operator|)
name|MAXDWORD
operator|+
literal|1
operator|)
operator|)
operator|+
call|(
name|int64_t
call|)
argument_list|(
name|info
operator|.
name|nFileSizeLow
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIMULATE_WIN_STAT
name|st
operator|->
name|st_ino
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|st_nlink
operator|=
literal|1
expr_stmt|;
name|st
operator|->
name|st_dev
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* Getting FileIndex as i-node. We have to remove a sequence which 	 * is high-16-bits of nFileIndexHigh. */
name|ino64
operator|.
name|HighPart
operator|=
name|info
operator|.
name|nFileIndexHigh
operator|&
literal|0x0000FFFFUL
expr_stmt|;
name|ino64
operator|.
name|LowPart
operator|=
name|info
operator|.
name|nFileIndexLow
expr_stmt|;
name|st
operator|->
name|st_ino
operator|=
name|ino64
operator|.
name|QuadPart
expr_stmt|;
name|st
operator|->
name|st_nlink
operator|=
name|info
operator|.
name|nNumberOfLinks
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|dwFileAttributes
operator|&
name|FILE_ATTRIBUTE_DIRECTORY
condition|)
operator|++
name|st
operator|->
name|st_nlink
expr_stmt|;
comment|/* Add parent directory. */
name|st
operator|->
name|st_dev
operator|=
name|info
operator|.
name|dwVolumeSerialNumber
expr_stmt|;
endif|#
directive|endif
name|st
operator|->
name|st_uid
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|st_gid
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|st_rdev
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|copy_stat
parameter_list|(
name|struct
name|stat
modifier|*
name|st
parameter_list|,
name|struct
name|ustat
modifier|*
name|us
parameter_list|)
block|{
name|st
operator|->
name|st_atime
operator|=
name|us
operator|->
name|st_atime
expr_stmt|;
name|st
operator|->
name|st_ctime
operator|=
name|us
operator|->
name|st_ctime
expr_stmt|;
name|st
operator|->
name|st_mtime
operator|=
name|us
operator|->
name|st_mtime
expr_stmt|;
name|st
operator|->
name|st_gid
operator|=
name|us
operator|->
name|st_gid
expr_stmt|;
name|st
operator|->
name|st_ino
operator|=
name|getino
argument_list|(
name|us
argument_list|)
expr_stmt|;
name|st
operator|->
name|st_mode
operator|=
name|us
operator|->
name|st_mode
expr_stmt|;
name|st
operator|->
name|st_nlink
operator|=
name|us
operator|->
name|st_nlink
expr_stmt|;
name|st
operator|->
name|st_size
operator|=
name|us
operator|->
name|st_size
expr_stmt|;
name|st
operator|->
name|st_uid
operator|=
name|us
operator|->
name|st_uid
expr_stmt|;
name|st
operator|->
name|st_dev
operator|=
name|us
operator|->
name|st_dev
expr_stmt|;
name|st
operator|->
name|st_rdev
operator|=
name|us
operator|->
name|st_rdev
expr_stmt|;
block|}
end_function

begin_function
name|int
name|__la_fstat
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|stat
modifier|*
name|st
parameter_list|)
block|{
name|struct
name|ustat
name|u
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ret
operator|=
name|__hstat
argument_list|(
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|fd
argument_list|)
argument_list|,
operator|&
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
name|copy_stat
argument_list|(
name|st
argument_list|,
operator|&
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|st_mode
operator|&
operator|(
name|S_IFCHR
operator||
name|S_IFIFO
operator|)
condition|)
block|{
name|st
operator|->
name|st_dev
operator|=
name|fd
expr_stmt|;
name|st
operator|->
name|st_rdev
operator|=
name|fd
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|__la_stat
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|stat
modifier|*
name|st
parameter_list|)
block|{
name|HANDLE
name|handle
decl_stmt|;
name|struct
name|ustat
name|u
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|handle
operator|=
name|la_CreateFile
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|OPEN_EXISTING
argument_list|,
name|FILE_FLAG_BACKUP_SEMANTICS
operator||
name|FILE_ATTRIBUTE_READONLY
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|==
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|la_dosmaperr
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ret
operator|=
name|__hstat
argument_list|(
name|handle
argument_list|,
operator|&
name|u
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|copy_stat
argument_list|(
name|st
argument_list|,
operator|&
name|u
argument_list|)
expr_stmt|;
name|p
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|strlen
argument_list|(
name|p
argument_list|)
operator|==
literal|4
condition|)
block|{
name|char
name|exttype
index|[
literal|4
index|]
decl_stmt|;
operator|++
name|p
expr_stmt|;
name|exttype
index|[
literal|0
index|]
operator|=
name|toupper
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|exttype
index|[
literal|1
index|]
operator|=
name|toupper
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|exttype
index|[
literal|2
index|]
operator|=
name|toupper
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|exttype
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|exttype
argument_list|,
literal|"EXE"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|exttype
argument_list|,
literal|"CMD"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|exttype
argument_list|,
literal|"BAT"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|exttype
argument_list|,
literal|"COM"
argument_list|)
condition|)
name|st
operator|->
name|st_mode
operator||=
name|S_IXUSR
operator||
name|S_IXGRP
operator||
name|S_IXOTH
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|__la_unlink
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|wchar_t
modifier|*
name|ws
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|_unlink
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>=
literal|0
operator|||
name|errno
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|ws
operator|=
name|permissive_name
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|ws
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|r
operator|=
name|_wunlink
argument_list|(
name|ws
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ws
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This waitpid is limited implemention.  */
end_comment

begin_function
name|pid_t
name|__la_waitpid
parameter_list|(
name|pid_t
name|wpid
parameter_list|,
name|int
modifier|*
name|status
parameter_list|,
name|int
name|option
parameter_list|)
block|{
name|HANDLE
name|child
decl_stmt|;
name|DWORD
name|cs
decl_stmt|,
name|ret
decl_stmt|;
operator|(
name|void
operator|)
name|option
expr_stmt|;
comment|/* UNUSED */
name|child
operator|=
name|OpenProcess
argument_list|(
name|PROCESS_QUERY_INFORMATION
operator||
name|SYNCHRONIZE
argument_list|,
name|FALSE
argument_list|,
name|wpid
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
block|{
name|la_dosmaperr
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ret
operator|=
name|WaitForSingleObject
argument_list|(
name|child
argument_list|,
name|INFINITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|WAIT_FAILED
condition|)
block|{
name|CloseHandle
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|la_dosmaperr
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|GetExitCodeProcess
argument_list|(
name|child
argument_list|,
operator|&
name|cs
argument_list|)
operator|==
literal|0
condition|)
block|{
name|CloseHandle
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|la_dosmaperr
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|cs
operator|==
name|STILL_ACTIVE
condition|)
operator|*
name|status
operator|=
literal|0x100
expr_stmt|;
else|else
operator|*
name|status
operator|=
call|(
name|int
call|)
argument_list|(
name|cs
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|wpid
operator|)
return|;
block|}
end_function

begin_function
name|ssize_t
name|__la_write
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
block|{
name|DWORD
name|bytes_written
decl_stmt|;
ifdef|#
directive|ifdef
name|_WIN64
if|if
condition|(
name|nbytes
operator|>
name|UINT32_MAX
condition|)
name|nbytes
operator|=
name|UINT32_MAX
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|WriteFile
argument_list|(
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|fd
argument_list|)
argument_list|,
name|buf
argument_list|,
operator|(
name|uint32_t
operator|)
name|nbytes
argument_list|,
operator|&
name|bytes_written
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|DWORD
name|lasterr
decl_stmt|;
name|lasterr
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
if|if
condition|(
name|lasterr
operator|==
name|ERROR_ACCESS_DENIED
condition|)
name|errno
operator|=
name|EBADF
expr_stmt|;
else|else
name|la_dosmaperr
argument_list|(
name|lasterr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|bytes_written
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The following function was modified from PostgreSQL sources and is  * subject to the copyright below.  */
end_comment

begin_comment
comment|/*-------------------------------------------------------------------------  *  * win32error.c  *	  Map win32 error codes to errno values  *  * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group  *  * IDENTIFICATION  *	  $PostgreSQL: pgsql/src/port/win32error.c,v 1.4 2008/01/01 19:46:00 momjian Exp $  *  *-------------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* PostgreSQL Database Management System (formerly known as Postgres, then as Postgres95)  Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group  Portions Copyright (c) 1994, The Regents of the University of California  Permission to use, copy, modify, and distribute this software and its documentation for any purpose, without fee, and without a written agreement is hereby granted, provided that the above copyright notice and this paragraph and the following two paragraphs appear in all copies.  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|DWORD
name|winerr
decl_stmt|;
name|int
name|doserr
decl_stmt|;
block|}
name|doserrors
index|[]
init|=
block|{
block|{
name|ERROR_INVALID_FUNCTION
block|,
name|EINVAL
block|}
block|,
block|{
name|ERROR_FILE_NOT_FOUND
block|,
name|ENOENT
block|}
block|,
block|{
name|ERROR_PATH_NOT_FOUND
block|,
name|ENOENT
block|}
block|,
block|{
name|ERROR_TOO_MANY_OPEN_FILES
block|,
name|EMFILE
block|}
block|,
block|{
name|ERROR_ACCESS_DENIED
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_INVALID_HANDLE
block|,
name|EBADF
block|}
block|,
block|{
name|ERROR_ARENA_TRASHED
block|,
name|ENOMEM
block|}
block|,
block|{
name|ERROR_NOT_ENOUGH_MEMORY
block|,
name|ENOMEM
block|}
block|,
block|{
name|ERROR_INVALID_BLOCK
block|,
name|ENOMEM
block|}
block|,
block|{
name|ERROR_BAD_ENVIRONMENT
block|,
name|E2BIG
block|}
block|,
block|{
name|ERROR_BAD_FORMAT
block|,
name|ENOEXEC
block|}
block|,
block|{
name|ERROR_INVALID_ACCESS
block|,
name|EINVAL
block|}
block|,
block|{
name|ERROR_INVALID_DATA
block|,
name|EINVAL
block|}
block|,
block|{
name|ERROR_INVALID_DRIVE
block|,
name|ENOENT
block|}
block|,
block|{
name|ERROR_CURRENT_DIRECTORY
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_NOT_SAME_DEVICE
block|,
name|EXDEV
block|}
block|,
block|{
name|ERROR_NO_MORE_FILES
block|,
name|ENOENT
block|}
block|,
block|{
name|ERROR_LOCK_VIOLATION
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_SHARING_VIOLATION
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_BAD_NETPATH
block|,
name|ENOENT
block|}
block|,
block|{
name|ERROR_NETWORK_ACCESS_DENIED
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_BAD_NET_NAME
block|,
name|ENOENT
block|}
block|,
block|{
name|ERROR_FILE_EXISTS
block|,
name|EEXIST
block|}
block|,
block|{
name|ERROR_CANNOT_MAKE
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_FAIL_I24
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_INVALID_PARAMETER
block|,
name|EINVAL
block|}
block|,
block|{
name|ERROR_NO_PROC_SLOTS
block|,
name|EAGAIN
block|}
block|,
block|{
name|ERROR_DRIVE_LOCKED
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_BROKEN_PIPE
block|,
name|EPIPE
block|}
block|,
block|{
name|ERROR_DISK_FULL
block|,
name|ENOSPC
block|}
block|,
block|{
name|ERROR_INVALID_TARGET_HANDLE
block|,
name|EBADF
block|}
block|,
block|{
name|ERROR_INVALID_HANDLE
block|,
name|EINVAL
block|}
block|,
block|{
name|ERROR_WAIT_NO_CHILDREN
block|,
name|ECHILD
block|}
block|,
block|{
name|ERROR_CHILD_NOT_COMPLETE
block|,
name|ECHILD
block|}
block|,
block|{
name|ERROR_DIRECT_ACCESS_HANDLE
block|,
name|EBADF
block|}
block|,
block|{
name|ERROR_NEGATIVE_SEEK
block|,
name|EINVAL
block|}
block|,
block|{
name|ERROR_SEEK_ON_DEVICE
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_DIR_NOT_EMPTY
block|,
name|ENOTEMPTY
block|}
block|,
block|{
name|ERROR_NOT_LOCKED
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_BAD_PATHNAME
block|,
name|ENOENT
block|}
block|,
block|{
name|ERROR_MAX_THRDS_REACHED
block|,
name|EAGAIN
block|}
block|,
block|{
name|ERROR_LOCK_FAILED
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_ALREADY_EXISTS
block|,
name|EEXIST
block|}
block|,
block|{
name|ERROR_FILENAME_EXCED_RANGE
block|,
name|ENOENT
block|}
block|,
block|{
name|ERROR_NESTING_NOT_ALLOWED
block|,
name|EAGAIN
block|}
block|,
block|{
name|ERROR_NOT_ENOUGH_QUOTA
block|,
name|ENOMEM
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|la_dosmaperr
parameter_list|(
name|unsigned
name|long
name|e
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|doserrors
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|doserrors
index|[
name|i
index|]
operator|.
name|winerr
operator|==
name|e
condition|)
block|{
name|errno
operator|=
name|doserrors
index|[
name|i
index|]
operator|.
name|doserr
expr_stmt|;
return|return;
block|}
block|}
comment|/* fprintf(stderr, "unrecognized win32 error code: %lu", e); */
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ARCHIVE_HASH_MD5_WIN
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|ARCHIVE_HASH_SHA1_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|ARCHIVE_HASH_SHA256_WIN
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|ARCHIVE_HASH_SHA384_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|ARCHIVE_HASH_SHA512_WIN
argument_list|)
end_if

begin_comment
comment|/*  * Message digest functions.  */
end_comment

begin_function
name|void
name|__la_hash_Init
parameter_list|(
name|Digest_CTX
modifier|*
name|ctx
parameter_list|,
name|ALG_ID
name|algId
parameter_list|)
block|{
name|ctx
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|CryptAcquireContext
argument_list|(
operator|&
name|ctx
operator|->
name|cryptProv
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|PROV_RSA_FULL
argument_list|,
name|CRYPT_VERIFYCONTEXT
argument_list|)
condition|)
block|{
if|if
condition|(
name|GetLastError
argument_list|()
operator|!=
operator|(
name|DWORD
operator|)
name|NTE_BAD_KEYSET
condition|)
return|return;
if|if
condition|(
operator|!
name|CryptAcquireContext
argument_list|(
operator|&
name|ctx
operator|->
name|cryptProv
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|PROV_RSA_FULL
argument_list|,
name|CRYPT_NEWKEYSET
argument_list|)
condition|)
return|return;
block|}
if|if
condition|(
operator|!
name|CryptCreateHash
argument_list|(
name|ctx
operator|->
name|cryptProv
argument_list|,
name|algId
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|ctx
operator|->
name|hash
argument_list|)
condition|)
block|{
name|CryptReleaseContext
argument_list|(
name|ctx
operator|->
name|cryptProv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|ctx
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__la_hash_Update
parameter_list|(
name|Digest_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ctx
operator|->
name|valid
condition|)
return|return;
name|CryptHashData
argument_list|(
name|ctx
operator|->
name|hash
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|buf
argument_list|,
operator|(
name|DWORD
operator|)
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__la_hash_Final
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bufsize
parameter_list|,
name|Digest_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|DWORD
name|siglen
init|=
name|bufsize
decl_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|valid
condition|)
return|return;
name|CryptGetHashParam
argument_list|(
name|ctx
operator|->
name|hash
argument_list|,
name|HP_HASHVAL
argument_list|,
name|buf
argument_list|,
operator|&
name|siglen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CryptDestroyHash
argument_list|(
name|ctx
operator|->
name|hash
argument_list|)
expr_stmt|;
name|CryptReleaseContext
argument_list|(
name|ctx
operator|->
name|cryptProv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(ARCHIVE_HASH_*_WIN) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _WIN32&& !__CYGWIN__ */
end_comment

end_unit

