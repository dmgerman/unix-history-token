begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2007 Tim Kientzle  * Copyright (c) 2009 Andreas Henriksson<andreas@fatal.se>  * Copyright (c) 2009-2011 Michihiro NAKAJIMA  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"archive_platform.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ERRNO_H
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #include<stdint.h> */
end_comment

begin_comment
comment|/* See archive_platform.h */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"archive.h"
end_include

begin_include
include|#
directive|include
file|"archive_endian.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry_locale.h"
end_include

begin_include
include|#
directive|include
file|"archive_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_read_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_string.h"
end_include

begin_comment
comment|/*  * An overview of ISO 9660 format:  *  * Each disk is laid out as follows:  *   * 32k reserved for private use  *   * Volume descriptor table.  Each volume descriptor  *     is 2k and specifies basic format information.  *     The "Primary Volume Descriptor" (PVD) is defined by the  *     standard and should always be present; other volume  *     descriptors include various vendor-specific extensions.  *   * Files and directories.  Each file/dir is specified by  *     an "extent" (starting sector and length in bytes).  *     Dirs are just files with directory records packed one  *     after another.  The PVD contains a single dir entry  *     specifying the location of the root directory.  Everything  *     else follows from there.  *  * This module works by first reading the volume descriptors, then  * building a list of directory entries, sorted by starting  * sector.  At each step, I look for the earliest dir entry that  * hasn't yet been read, seek forward to that location and read  * that entry.  If it's a dir, I slurp in the new dir entries and  * add them to the heap; if it's a regular file, I return the  * corresponding archive_entry and wait for the client to request  * the file body.  This strategy allows us to read most compliant  * CDs with a single pass through the data, as required by libarchive.  */
end_comment

begin_define
define|#
directive|define
name|LOGICAL_BLOCK_SIZE
value|2048
end_define

begin_define
define|#
directive|define
name|SYSTEM_AREA_BLOCK
value|16
end_define

begin_comment
comment|/* Structure of on-disk primary volume descriptor. */
end_comment

begin_define
define|#
directive|define
name|PVD_type_offset
value|0
end_define

begin_define
define|#
directive|define
name|PVD_type_size
value|1
end_define

begin_define
define|#
directive|define
name|PVD_id_offset
value|(PVD_type_offset + PVD_type_size)
end_define

begin_define
define|#
directive|define
name|PVD_id_size
value|5
end_define

begin_define
define|#
directive|define
name|PVD_version_offset
value|(PVD_id_offset + PVD_id_size)
end_define

begin_define
define|#
directive|define
name|PVD_version_size
value|1
end_define

begin_define
define|#
directive|define
name|PVD_reserved1_offset
value|(PVD_version_offset + PVD_version_size)
end_define

begin_define
define|#
directive|define
name|PVD_reserved1_size
value|1
end_define

begin_define
define|#
directive|define
name|PVD_system_id_offset
value|(PVD_reserved1_offset + PVD_reserved1_size)
end_define

begin_define
define|#
directive|define
name|PVD_system_id_size
value|32
end_define

begin_define
define|#
directive|define
name|PVD_volume_id_offset
value|(PVD_system_id_offset + PVD_system_id_size)
end_define

begin_define
define|#
directive|define
name|PVD_volume_id_size
value|32
end_define

begin_define
define|#
directive|define
name|PVD_reserved2_offset
value|(PVD_volume_id_offset + PVD_volume_id_size)
end_define

begin_define
define|#
directive|define
name|PVD_reserved2_size
value|8
end_define

begin_define
define|#
directive|define
name|PVD_volume_space_size_offset
value|(PVD_reserved2_offset + PVD_reserved2_size)
end_define

begin_define
define|#
directive|define
name|PVD_volume_space_size_size
value|8
end_define

begin_define
define|#
directive|define
name|PVD_reserved3_offset
value|(PVD_volume_space_size_offset + PVD_volume_space_size_size)
end_define

begin_define
define|#
directive|define
name|PVD_reserved3_size
value|32
end_define

begin_define
define|#
directive|define
name|PVD_volume_set_size_offset
value|(PVD_reserved3_offset + PVD_reserved3_size)
end_define

begin_define
define|#
directive|define
name|PVD_volume_set_size_size
value|4
end_define

begin_define
define|#
directive|define
name|PVD_volume_sequence_number_offset
value|(PVD_volume_set_size_offset + PVD_volume_set_size_size)
end_define

begin_define
define|#
directive|define
name|PVD_volume_sequence_number_size
value|4
end_define

begin_define
define|#
directive|define
name|PVD_logical_block_size_offset
value|(PVD_volume_sequence_number_offset + PVD_volume_sequence_number_size)
end_define

begin_define
define|#
directive|define
name|PVD_logical_block_size_size
value|4
end_define

begin_define
define|#
directive|define
name|PVD_path_table_size_offset
value|(PVD_logical_block_size_offset + PVD_logical_block_size_size)
end_define

begin_define
define|#
directive|define
name|PVD_path_table_size_size
value|8
end_define

begin_define
define|#
directive|define
name|PVD_type_1_path_table_offset
value|(PVD_path_table_size_offset + PVD_path_table_size_size)
end_define

begin_define
define|#
directive|define
name|PVD_type_1_path_table_size
value|4
end_define

begin_define
define|#
directive|define
name|PVD_opt_type_1_path_table_offset
value|(PVD_type_1_path_table_offset + PVD_type_1_path_table_size)
end_define

begin_define
define|#
directive|define
name|PVD_opt_type_1_path_table_size
value|4
end_define

begin_define
define|#
directive|define
name|PVD_type_m_path_table_offset
value|(PVD_opt_type_1_path_table_offset + PVD_opt_type_1_path_table_size)
end_define

begin_define
define|#
directive|define
name|PVD_type_m_path_table_size
value|4
end_define

begin_define
define|#
directive|define
name|PVD_opt_type_m_path_table_offset
value|(PVD_type_m_path_table_offset + PVD_type_m_path_table_size)
end_define

begin_define
define|#
directive|define
name|PVD_opt_type_m_path_table_size
value|4
end_define

begin_define
define|#
directive|define
name|PVD_root_directory_record_offset
value|(PVD_opt_type_m_path_table_offset + PVD_opt_type_m_path_table_size)
end_define

begin_define
define|#
directive|define
name|PVD_root_directory_record_size
value|34
end_define

begin_define
define|#
directive|define
name|PVD_volume_set_id_offset
value|(PVD_root_directory_record_offset + PVD_root_directory_record_size)
end_define

begin_define
define|#
directive|define
name|PVD_volume_set_id_size
value|128
end_define

begin_define
define|#
directive|define
name|PVD_publisher_id_offset
value|(PVD_volume_set_id_offset + PVD_volume_set_id_size)
end_define

begin_define
define|#
directive|define
name|PVD_publisher_id_size
value|128
end_define

begin_define
define|#
directive|define
name|PVD_preparer_id_offset
value|(PVD_publisher_id_offset + PVD_publisher_id_size)
end_define

begin_define
define|#
directive|define
name|PVD_preparer_id_size
value|128
end_define

begin_define
define|#
directive|define
name|PVD_application_id_offset
value|(PVD_preparer_id_offset + PVD_preparer_id_size)
end_define

begin_define
define|#
directive|define
name|PVD_application_id_size
value|128
end_define

begin_define
define|#
directive|define
name|PVD_copyright_file_id_offset
value|(PVD_application_id_offset + PVD_application_id_size)
end_define

begin_define
define|#
directive|define
name|PVD_copyright_file_id_size
value|37
end_define

begin_define
define|#
directive|define
name|PVD_abstract_file_id_offset
value|(PVD_copyright_file_id_offset + PVD_copyright_file_id_size)
end_define

begin_define
define|#
directive|define
name|PVD_abstract_file_id_size
value|37
end_define

begin_define
define|#
directive|define
name|PVD_bibliographic_file_id_offset
value|(PVD_abstract_file_id_offset + PVD_abstract_file_id_size)
end_define

begin_define
define|#
directive|define
name|PVD_bibliographic_file_id_size
value|37
end_define

begin_define
define|#
directive|define
name|PVD_creation_date_offset
value|(PVD_bibliographic_file_id_offset + PVD_bibliographic_file_id_size)
end_define

begin_define
define|#
directive|define
name|PVD_creation_date_size
value|17
end_define

begin_define
define|#
directive|define
name|PVD_modification_date_offset
value|(PVD_creation_date_offset + PVD_creation_date_size)
end_define

begin_define
define|#
directive|define
name|PVD_modification_date_size
value|17
end_define

begin_define
define|#
directive|define
name|PVD_expiration_date_offset
value|(PVD_modification_date_offset + PVD_modification_date_size)
end_define

begin_define
define|#
directive|define
name|PVD_expiration_date_size
value|17
end_define

begin_define
define|#
directive|define
name|PVD_effective_date_offset
value|(PVD_expiration_date_offset + PVD_expiration_date_size)
end_define

begin_define
define|#
directive|define
name|PVD_effective_date_size
value|17
end_define

begin_define
define|#
directive|define
name|PVD_file_structure_version_offset
value|(PVD_effective_date_offset + PVD_effective_date_size)
end_define

begin_define
define|#
directive|define
name|PVD_file_structure_version_size
value|1
end_define

begin_define
define|#
directive|define
name|PVD_reserved4_offset
value|(PVD_file_structure_version_offset + PVD_file_structure_version_size)
end_define

begin_define
define|#
directive|define
name|PVD_reserved4_size
value|1
end_define

begin_define
define|#
directive|define
name|PVD_application_data_offset
value|(PVD_reserved4_offset + PVD_reserved4_size)
end_define

begin_define
define|#
directive|define
name|PVD_application_data_size
value|512
end_define

begin_define
define|#
directive|define
name|PVD_reserved5_offset
value|(PVD_application_data_offset + PVD_application_data_size)
end_define

begin_define
define|#
directive|define
name|PVD_reserved5_size
value|(2048 - PVD_reserved5_offset)
end_define

begin_comment
comment|/* TODO: It would make future maintenance easier to just hardcode the  * above values.  In particular, ECMA119 states the offsets as part of  * the standard.  That would eliminate the need for the following check.*/
end_comment

begin_if
if|#
directive|if
name|PVD_reserved5_offset
operator|!=
literal|1395
end_if

begin_error
error|#
directive|error
error|PVD offset and size definitions are wrong.
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Structure of optional on-disk supplementary volume descriptor. */
end_comment

begin_define
define|#
directive|define
name|SVD_type_offset
value|0
end_define

begin_define
define|#
directive|define
name|SVD_type_size
value|1
end_define

begin_define
define|#
directive|define
name|SVD_id_offset
value|(SVD_type_offset + SVD_type_size)
end_define

begin_define
define|#
directive|define
name|SVD_id_size
value|5
end_define

begin_define
define|#
directive|define
name|SVD_version_offset
value|(SVD_id_offset + SVD_id_size)
end_define

begin_define
define|#
directive|define
name|SVD_version_size
value|1
end_define

begin_comment
comment|/* ... */
end_comment

begin_define
define|#
directive|define
name|SVD_reserved1_offset
value|72
end_define

begin_define
define|#
directive|define
name|SVD_reserved1_size
value|8
end_define

begin_define
define|#
directive|define
name|SVD_volume_space_size_offset
value|80
end_define

begin_define
define|#
directive|define
name|SVD_volume_space_size_size
value|8
end_define

begin_define
define|#
directive|define
name|SVD_escape_sequences_offset
value|(SVD_volume_space_size_offset + SVD_volume_space_size_size)
end_define

begin_define
define|#
directive|define
name|SVD_escape_sequences_size
value|32
end_define

begin_comment
comment|/* ... */
end_comment

begin_define
define|#
directive|define
name|SVD_logical_block_size_offset
value|128
end_define

begin_define
define|#
directive|define
name|SVD_logical_block_size_size
value|4
end_define

begin_define
define|#
directive|define
name|SVD_type_L_path_table_offset
value|140
end_define

begin_define
define|#
directive|define
name|SVD_type_M_path_table_offset
value|148
end_define

begin_comment
comment|/* ... */
end_comment

begin_define
define|#
directive|define
name|SVD_root_directory_record_offset
value|156
end_define

begin_define
define|#
directive|define
name|SVD_root_directory_record_size
value|34
end_define

begin_define
define|#
directive|define
name|SVD_file_structure_version_offset
value|881
end_define

begin_define
define|#
directive|define
name|SVD_reserved2_offset
value|882
end_define

begin_define
define|#
directive|define
name|SVD_reserved2_size
value|1
end_define

begin_define
define|#
directive|define
name|SVD_reserved3_offset
value|1395
end_define

begin_define
define|#
directive|define
name|SVD_reserved3_size
value|653
end_define

begin_comment
comment|/* ... */
end_comment

begin_comment
comment|/* FIXME: validate correctness of last SVD entry offset. */
end_comment

begin_comment
comment|/* Structure of an on-disk directory record. */
end_comment

begin_comment
comment|/* Note:  ISO9660 stores each multi-byte integer twice, once in  * each byte order.  The sizes here are the size of just one  * of the two integers.  (This is why the offset of a field isn't  * the same as the offset+size of the previous field.) */
end_comment

begin_define
define|#
directive|define
name|DR_length_offset
value|0
end_define

begin_define
define|#
directive|define
name|DR_length_size
value|1
end_define

begin_define
define|#
directive|define
name|DR_ext_attr_length_offset
value|1
end_define

begin_define
define|#
directive|define
name|DR_ext_attr_length_size
value|1
end_define

begin_define
define|#
directive|define
name|DR_extent_offset
value|2
end_define

begin_define
define|#
directive|define
name|DR_extent_size
value|4
end_define

begin_define
define|#
directive|define
name|DR_size_offset
value|10
end_define

begin_define
define|#
directive|define
name|DR_size_size
value|4
end_define

begin_define
define|#
directive|define
name|DR_date_offset
value|18
end_define

begin_define
define|#
directive|define
name|DR_date_size
value|7
end_define

begin_define
define|#
directive|define
name|DR_flags_offset
value|25
end_define

begin_define
define|#
directive|define
name|DR_flags_size
value|1
end_define

begin_define
define|#
directive|define
name|DR_file_unit_size_offset
value|26
end_define

begin_define
define|#
directive|define
name|DR_file_unit_size_size
value|1
end_define

begin_define
define|#
directive|define
name|DR_interleave_offset
value|27
end_define

begin_define
define|#
directive|define
name|DR_interleave_size
value|1
end_define

begin_define
define|#
directive|define
name|DR_volume_sequence_number_offset
value|28
end_define

begin_define
define|#
directive|define
name|DR_volume_sequence_number_size
value|2
end_define

begin_define
define|#
directive|define
name|DR_name_len_offset
value|32
end_define

begin_define
define|#
directive|define
name|DR_name_len_size
value|1
end_define

begin_define
define|#
directive|define
name|DR_name_offset
value|33
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|zisofs_magic
index|[
literal|8
index|]
init|=
block|{
literal|0x37
block|,
literal|0xE4
block|,
literal|0x53
block|,
literal|0x96
block|,
literal|0xC9
block|,
literal|0xDB
block|,
literal|0xD6
block|,
literal|0x07
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|zisofs
block|{
comment|/* Set 1 if this file compressed by paged zlib */
name|int
name|pz
decl_stmt|;
name|int
name|pz_log2_bs
decl_stmt|;
comment|/* Log2 of block size */
name|uint64_t
name|pz_uncompressed_size
decl_stmt|;
name|int
name|initialized
decl_stmt|;
name|unsigned
name|char
modifier|*
name|uncompressed_buffer
decl_stmt|;
name|size_t
name|uncompressed_buffer_size
decl_stmt|;
name|uint32_t
name|pz_offset
decl_stmt|;
name|unsigned
name|char
name|header
index|[
literal|16
index|]
decl_stmt|;
name|size_t
name|header_avail
decl_stmt|;
name|int
name|header_passed
decl_stmt|;
name|unsigned
name|char
modifier|*
name|block_pointers
decl_stmt|;
name|size_t
name|block_pointers_alloc
decl_stmt|;
name|size_t
name|block_pointers_size
decl_stmt|;
name|size_t
name|block_pointers_avail
decl_stmt|;
name|size_t
name|block_off
decl_stmt|;
name|uint32_t
name|block_avail
decl_stmt|;
name|z_stream
name|stream
decl_stmt|;
name|int
name|stream_valid
decl_stmt|;
block|}
struct|;
end_struct

begin_else
else|#
directive|else
end_else

begin_struct
struct|struct
name|zisofs
block|{
comment|/* Set 1 if this file compressed by paged zlib */
name|int
name|pz
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|content
block|{
name|uint64_t
name|offset
decl_stmt|;
comment|/* Offset on disk.		*/
name|uint64_t
name|size
decl_stmt|;
comment|/* File size in bytes.		*/
name|struct
name|content
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* In-memory storage for a directory record. */
end_comment

begin_struct
struct|struct
name|file_info
block|{
name|struct
name|file_info
modifier|*
name|use_next
decl_stmt|;
name|struct
name|file_info
modifier|*
name|parent
decl_stmt|;
name|struct
name|file_info
modifier|*
name|next
decl_stmt|;
name|struct
name|file_info
modifier|*
name|re_next
decl_stmt|;
name|int
name|subdirs
decl_stmt|;
name|uint64_t
name|key
decl_stmt|;
comment|/* Heap Key.			*/
name|uint64_t
name|offset
decl_stmt|;
comment|/* Offset on disk.		*/
name|uint64_t
name|size
decl_stmt|;
comment|/* File size in bytes.		*/
name|uint32_t
name|ce_offset
decl_stmt|;
comment|/* Offset of CE.		*/
name|uint32_t
name|ce_size
decl_stmt|;
comment|/* Size of CE.			*/
name|char
name|rr_moved
decl_stmt|;
comment|/* Flag to rr_moved.		*/
name|char
name|rr_moved_has_re_only
decl_stmt|;
name|char
name|re
decl_stmt|;
comment|/* Having RRIP "RE" extension.	*/
name|char
name|re_descendant
decl_stmt|;
name|uint64_t
name|cl_offset
decl_stmt|;
comment|/* Having RRIP "CL" extension.	*/
name|int
name|birthtime_is_set
decl_stmt|;
name|time_t
name|birthtime
decl_stmt|;
comment|/* File created time.		*/
name|time_t
name|mtime
decl_stmt|;
comment|/* File last modified time.	*/
name|time_t
name|atime
decl_stmt|;
comment|/* File last accessed time.	*/
name|time_t
name|ctime
decl_stmt|;
comment|/* File attribute change time.	*/
name|uint64_t
name|rdev
decl_stmt|;
comment|/* Device number.		*/
name|mode_t
name|mode
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
name|int64_t
name|number
decl_stmt|;
name|int
name|nlinks
decl_stmt|;
name|struct
name|archive_string
name|name
decl_stmt|;
comment|/* Pathname */
name|unsigned
name|char
modifier|*
name|utf16be_name
decl_stmt|;
name|size_t
name|utf16be_bytes
decl_stmt|;
name|char
name|name_continues
decl_stmt|;
comment|/* Non-zero if name continues */
name|struct
name|archive_string
name|symlink
decl_stmt|;
name|char
name|symlink_continues
decl_stmt|;
comment|/* Non-zero if link continues */
comment|/* Set 1 if this file compressed by paged zlib(zisofs) */
name|int
name|pz
decl_stmt|;
name|int
name|pz_log2_bs
decl_stmt|;
comment|/* Log2 of block size */
name|uint64_t
name|pz_uncompressed_size
decl_stmt|;
comment|/* Set 1 if this file is multi extent. */
name|int
name|multi_extent
decl_stmt|;
struct|struct
block|{
name|struct
name|content
modifier|*
name|first
decl_stmt|;
name|struct
name|content
modifier|*
modifier|*
name|last
decl_stmt|;
block|}
name|contents
struct|;
struct|struct
block|{
name|struct
name|file_info
modifier|*
name|first
decl_stmt|;
name|struct
name|file_info
modifier|*
modifier|*
name|last
decl_stmt|;
block|}
name|rede_files
struct|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|heap_queue
block|{
name|struct
name|file_info
modifier|*
modifier|*
name|files
decl_stmt|;
name|int
name|allocated
decl_stmt|;
name|int
name|used
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|iso9660
block|{
name|int
name|magic
decl_stmt|;
define|#
directive|define
name|ISO9660_MAGIC
value|0x96609660
name|int
name|opt_support_joliet
decl_stmt|;
name|int
name|opt_support_rockridge
decl_stmt|;
name|struct
name|archive_string
name|pathname
decl_stmt|;
name|char
name|seenRockridge
decl_stmt|;
comment|/* Set true if RR extensions are used. */
name|char
name|seenSUSP
decl_stmt|;
comment|/* Set true if SUSP is beging used. */
name|char
name|seenJoliet
decl_stmt|;
name|unsigned
name|char
name|suspOffset
decl_stmt|;
name|struct
name|file_info
modifier|*
name|rr_moved
decl_stmt|;
struct|struct
name|read_ce_queue
block|{
struct|struct
name|read_ce_req
block|{
name|uint64_t
name|offset
decl_stmt|;
comment|/* Offset of CE on disk. */
name|struct
name|file_info
modifier|*
name|file
decl_stmt|;
block|}
modifier|*
name|reqs
struct|;
name|int
name|cnt
decl_stmt|;
name|int
name|allocated
decl_stmt|;
block|}
name|read_ce_req
struct|;
name|int64_t
name|previous_number
decl_stmt|;
name|struct
name|archive_string
name|previous_pathname
decl_stmt|;
name|struct
name|file_info
modifier|*
name|use_files
decl_stmt|;
name|struct
name|heap_queue
name|pending_files
decl_stmt|;
struct|struct
block|{
name|struct
name|file_info
modifier|*
name|first
decl_stmt|;
name|struct
name|file_info
modifier|*
modifier|*
name|last
decl_stmt|;
block|}
name|cache_files
struct|;
struct|struct
block|{
name|struct
name|file_info
modifier|*
name|first
decl_stmt|;
name|struct
name|file_info
modifier|*
modifier|*
name|last
decl_stmt|;
block|}
name|re_files
struct|;
name|uint64_t
name|current_position
decl_stmt|;
name|ssize_t
name|logical_block_size
decl_stmt|;
name|uint64_t
name|volume_size
decl_stmt|;
comment|/* Total size of volume in bytes. */
name|int32_t
name|volume_block
decl_stmt|;
comment|/* Total size of volume in logical blocks. */
struct|struct
name|vd
block|{
name|int
name|location
decl_stmt|;
comment|/* Location of Extent.	*/
name|uint32_t
name|size
decl_stmt|;
block|}
name|primary
struct|,
name|joliet
struct|;
name|int64_t
name|entry_sparse_offset
decl_stmt|;
name|int64_t
name|entry_bytes_remaining
decl_stmt|;
name|size_t
name|entry_bytes_unconsumed
decl_stmt|;
name|struct
name|zisofs
name|entry_zisofs
decl_stmt|;
name|struct
name|content
modifier|*
name|entry_content
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|sconv_utf16be
decl_stmt|;
comment|/* 	 * Buffers for a full pathname in UTF-16BE in Joliet extensions. 	 */
define|#
directive|define
name|UTF16_NAME_MAX
value|1024
name|unsigned
name|char
modifier|*
name|utf16be_path
decl_stmt|;
name|size_t
name|utf16be_path_len
decl_stmt|;
name|unsigned
name|char
modifier|*
name|utf16be_previous_path
decl_stmt|;
name|size_t
name|utf16be_previous_path_len
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|archive_read_format_iso9660_bid
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_iso9660_options
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_iso9660_cleanup
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_iso9660_read_data
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|int64_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_iso9660_read_data_skip
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_iso9660_read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|build_pathname
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
name|struct
name|file_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|build_pathname_utf16be
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|struct
name|file_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|DEBUG
end_if

begin_function_decl
specifier|static
name|void
name|dump_isodirrec
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|isodirrec
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|time_t
name|time_from_tm
parameter_list|(
name|struct
name|tm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|time_t
name|isodate17
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|time_t
name|isodate7
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isBootRecord
parameter_list|(
name|struct
name|iso9660
modifier|*
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isVolumePartition
parameter_list|(
name|struct
name|iso9660
modifier|*
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isVDSetTerminator
parameter_list|(
name|struct
name|iso9660
modifier|*
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isJolietSVD
parameter_list|(
name|struct
name|iso9660
modifier|*
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isSVD
parameter_list|(
name|struct
name|iso9660
modifier|*
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isEVD
parameter_list|(
name|struct
name|iso9660
modifier|*
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isPVD
parameter_list|(
name|struct
name|iso9660
modifier|*
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|next_cache_entry
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|iso9660
modifier|*
parameter_list|,
name|struct
name|file_info
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|next_entry_seek
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|iso9660
modifier|*
parameter_list|,
name|struct
name|file_info
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|file_info
modifier|*
name|parse_file_info
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|file_info
modifier|*
name|parent
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|isodirrec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_rockridge
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|file_info
modifier|*
name|file
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|start
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|register_CE
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|int32_t
name|location
parameter_list|,
name|struct
name|file_info
modifier|*
name|file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_CE
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_rockridge_NM1
parameter_list|(
name|struct
name|file_info
modifier|*
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_rockridge_SL1
parameter_list|(
name|struct
name|file_info
modifier|*
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_rockridge_TF1
parameter_list|(
name|struct
name|file_info
modifier|*
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_rockridge_ZF1
parameter_list|(
name|struct
name|file_info
modifier|*
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|register_file
parameter_list|(
name|struct
name|iso9660
modifier|*
parameter_list|,
name|struct
name|file_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|release_files
parameter_list|(
name|struct
name|iso9660
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|toi
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|re_add_entry
parameter_list|(
name|struct
name|iso9660
modifier|*
parameter_list|,
name|struct
name|file_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|struct
name|file_info
modifier|*
name|re_get_entry
parameter_list|(
name|struct
name|iso9660
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|rede_add_entry
parameter_list|(
name|struct
name|file_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|struct
name|file_info
modifier|*
name|rede_get_entry
parameter_list|(
name|struct
name|file_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|cache_add_entry
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
name|struct
name|file_info
modifier|*
name|file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|struct
name|file_info
modifier|*
name|cache_get_entry
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|heap_add_entry
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|heap_queue
modifier|*
name|heap
parameter_list|,
name|struct
name|file_info
modifier|*
name|file
parameter_list|,
name|uint64_t
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|file_info
modifier|*
name|heap_get_entry
parameter_list|(
name|struct
name|heap_queue
modifier|*
name|heap
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|add_entry
parameter_list|(
name|arch
parameter_list|,
name|iso9660
parameter_list|,
name|file
parameter_list|)
define|\
value|heap_add_entry(arch,&((iso9660)->pending_files), file, file->offset)
end_define

begin_define
define|#
directive|define
name|next_entry
parameter_list|(
name|iso9660
parameter_list|)
define|\
value|heap_get_entry(&((iso9660)->pending_files))
end_define

begin_function
name|int
name|archive_read_support_format_iso9660
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|struct
name|iso9660
modifier|*
name|iso9660
decl_stmt|;
name|int
name|r
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_READ_MAGIC
argument_list|,
name|ARCHIVE_STATE_NEW
argument_list|,
literal|"archive_read_support_format_iso9660"
argument_list|)
expr_stmt|;
name|iso9660
operator|=
operator|(
expr|struct
name|iso9660
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|iso9660
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate iso9660 data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|iso9660
operator|->
name|magic
operator|=
name|ISO9660_MAGIC
expr_stmt|;
name|iso9660
operator|->
name|cache_files
operator|.
name|first
operator|=
name|NULL
expr_stmt|;
name|iso9660
operator|->
name|cache_files
operator|.
name|last
operator|=
operator|&
operator|(
name|iso9660
operator|->
name|cache_files
operator|.
name|first
operator|)
expr_stmt|;
name|iso9660
operator|->
name|re_files
operator|.
name|first
operator|=
name|NULL
expr_stmt|;
name|iso9660
operator|->
name|re_files
operator|.
name|last
operator|=
operator|&
operator|(
name|iso9660
operator|->
name|re_files
operator|.
name|first
operator|)
expr_stmt|;
comment|/* Enable to support Joliet extensions by default.	*/
name|iso9660
operator|->
name|opt_support_joliet
operator|=
literal|1
expr_stmt|;
comment|/* Enable to support Rock Ridge extensions by default.	*/
name|iso9660
operator|->
name|opt_support_rockridge
operator|=
literal|1
expr_stmt|;
name|r
operator|=
name|__archive_read_register_format
argument_list|(
name|a
argument_list|,
name|iso9660
argument_list|,
literal|"iso9660"
argument_list|,
name|archive_read_format_iso9660_bid
argument_list|,
name|archive_read_format_iso9660_options
argument_list|,
name|archive_read_format_iso9660_read_header
argument_list|,
name|archive_read_format_iso9660_read_data
argument_list|,
name|archive_read_format_iso9660_read_data_skip
argument_list|,
name|archive_read_format_iso9660_cleanup
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|free
argument_list|(
name|iso9660
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_iso9660_bid
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|int
name|best_bid
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
decl_stmt|;
name|ssize_t
name|bytes_read
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|seenTerminator
decl_stmt|;
comment|/* If there's already a better bid than we can ever 	   make, don't bother testing. */
if|if
condition|(
name|best_bid
operator|>
literal|48
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|iso9660
operator|=
operator|(
expr|struct
name|iso9660
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
comment|/* 	 * Skip the first 32k (reserved area) and get the first 	 * 8 sectors of the volume descriptor table.  Of course, 	 * if the I/O layer gives us more, we'll take it. 	 */
define|#
directive|define
name|RESERVED_AREA
value|(SYSTEM_AREA_BLOCK * LOGICAL_BLOCK_SIZE)
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|RESERVED_AREA
operator|+
literal|8
operator|*
name|LOGICAL_BLOCK_SIZE
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Skip the reserved area. */
name|bytes_read
operator|-=
name|RESERVED_AREA
expr_stmt|;
name|p
operator|+=
name|RESERVED_AREA
expr_stmt|;
comment|/* Check each volume descriptor. */
name|seenTerminator
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|bytes_read
operator|>
name|LOGICAL_BLOCK_SIZE
condition|;
name|bytes_read
operator|-=
name|LOGICAL_BLOCK_SIZE
operator|,
name|p
operator|+=
name|LOGICAL_BLOCK_SIZE
control|)
block|{
comment|/* Do not handle undefined Volume Descriptor Type. */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|>=
literal|4
operator|&&
name|p
index|[
literal|0
index|]
operator|<=
literal|254
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Standard Identifier must be "CD001" */
if|if
condition|(
name|memcmp
argument_list|(
name|p
operator|+
literal|1
argument_list|,
literal|"CD001"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|isPVD
argument_list|(
name|iso9660
argument_list|,
name|p
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|iso9660
operator|->
name|joliet
operator|.
name|location
condition|)
block|{
if|if
condition|(
name|isJolietSVD
argument_list|(
name|iso9660
argument_list|,
name|p
argument_list|)
condition|)
continue|continue;
block|}
if|if
condition|(
name|isBootRecord
argument_list|(
name|iso9660
argument_list|,
name|p
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|isEVD
argument_list|(
name|iso9660
argument_list|,
name|p
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|isSVD
argument_list|(
name|iso9660
argument_list|,
name|p
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|isVolumePartition
argument_list|(
name|iso9660
argument_list|,
name|p
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|isVDSetTerminator
argument_list|(
name|iso9660
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|seenTerminator
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * ISO 9660 format must have Primary Volume Descriptor and 	 * Volume Descriptor Set Terminator. 	 */
if|if
condition|(
name|seenTerminator
operator|&&
name|iso9660
operator|->
name|primary
operator|.
name|location
operator|>
literal|16
condition|)
return|return
operator|(
literal|48
operator|)
return|;
comment|/* We didn't find a valid PVD; return a bid of zero. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_iso9660_options
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
decl_stmt|;
name|iso9660
operator|=
operator|(
expr|struct
name|iso9660
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"joliet"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|val
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"ignore"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"disable"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"0"
argument_list|)
operator|==
literal|0
condition|)
name|iso9660
operator|->
name|opt_support_joliet
operator|=
literal|0
expr_stmt|;
else|else
name|iso9660
operator|->
name|opt_support_joliet
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"rockridge"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"Rockridge"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|iso9660
operator|->
name|opt_support_rockridge
operator|=
name|val
operator|!=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
comment|/* Note: The "warn" return is just to inform the options 	 * supervisor that we didn't handle it.  It will generate 	 * a suitable error if no one used this option. */
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isBootRecord
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|h
parameter_list|)
block|{
operator|(
name|void
operator|)
name|iso9660
expr_stmt|;
comment|/* UNUSED */
comment|/* Type of the Volume Descriptor Boot Record must be 0. */
if|if
condition|(
name|h
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Volume Descriptor Version must be 1. */
if|if
condition|(
name|h
index|[
literal|6
index|]
operator|!=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isVolumePartition
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|h
parameter_list|)
block|{
name|int32_t
name|location
decl_stmt|;
comment|/* Type of the Volume Partition Descriptor must be 3. */
if|if
condition|(
name|h
index|[
literal|0
index|]
operator|!=
literal|3
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Volume Descriptor Version must be 1. */
if|if
condition|(
name|h
index|[
literal|6
index|]
operator|!=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Unused Field */
if|if
condition|(
name|h
index|[
literal|7
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|location
operator|=
name|archive_le32dec
argument_list|(
name|h
operator|+
literal|72
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|<=
name|SYSTEM_AREA_BLOCK
operator|||
name|location
operator|>=
name|iso9660
operator|->
name|volume_block
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|uint32_t
operator|)
name|location
operator|!=
name|archive_be32dec
argument_list|(
name|h
operator|+
literal|76
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isVDSetTerminator
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|h
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|iso9660
expr_stmt|;
comment|/* UNUSED */
comment|/* Type of the Volume Descriptor Set Terminator must be 255. */
if|if
condition|(
name|h
index|[
literal|0
index|]
operator|!=
literal|255
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Volume Descriptor Version must be 1. */
if|if
condition|(
name|h
index|[
literal|6
index|]
operator|!=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Reserved field must be 0. */
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|<
literal|2048
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|h
index|[
name|i
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isJolietSVD
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|h
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|ssize_t
name|logical_block_size
decl_stmt|;
name|int32_t
name|volume_block
decl_stmt|;
comment|/* Check if current sector is a kind of Supplementary Volume 	 * Descriptor. */
if|if
condition|(
operator|!
name|isSVD
argument_list|(
name|iso9660
argument_list|,
name|h
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* FIXME: do more validations according to joliet spec. */
comment|/* check if this SVD contains joliet extension! */
name|p
operator|=
name|h
operator|+
name|SVD_escape_sequences_offset
expr_stmt|;
comment|/* N.B. Joliet spec says p[1] == '\\', but.... */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'%'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|int
name|level
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|'@'
condition|)
name|level
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|'C'
condition|)
name|level
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|'E'
condition|)
name|level
operator|=
literal|3
expr_stmt|;
else|else
comment|/* not joliet */
return|return
operator|(
literal|0
operator|)
return|;
name|iso9660
operator|->
name|seenJoliet
operator|=
name|level
expr_stmt|;
block|}
else|else
comment|/* not joliet */
return|return
operator|(
literal|0
operator|)
return|;
name|logical_block_size
operator|=
name|archive_le16dec
argument_list|(
name|h
operator|+
name|SVD_logical_block_size_offset
argument_list|)
expr_stmt|;
name|volume_block
operator|=
name|archive_le32dec
argument_list|(
name|h
operator|+
name|SVD_volume_space_size_offset
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|logical_block_size
operator|=
name|logical_block_size
expr_stmt|;
name|iso9660
operator|->
name|volume_block
operator|=
name|volume_block
expr_stmt|;
name|iso9660
operator|->
name|volume_size
operator|=
name|logical_block_size
operator|*
operator|(
name|uint64_t
operator|)
name|volume_block
expr_stmt|;
comment|/* Read Root Directory Record in Volume Descriptor. */
name|p
operator|=
name|h
operator|+
name|SVD_root_directory_record_offset
expr_stmt|;
name|iso9660
operator|->
name|joliet
operator|.
name|location
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|DR_extent_offset
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|joliet
operator|.
name|size
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|DR_size_offset
argument_list|)
expr_stmt|;
return|return
operator|(
literal|48
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isSVD
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|h
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|ssize_t
name|logical_block_size
decl_stmt|;
name|int32_t
name|volume_block
decl_stmt|;
name|int32_t
name|location
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|iso9660
expr_stmt|;
comment|/* UNUSED */
comment|/* Type 2 means it's a SVD. */
if|if
condition|(
name|h
index|[
name|SVD_type_offset
index|]
operator|!=
literal|2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Reserved field must be 0. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SVD_reserved1_size
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|h
index|[
name|SVD_reserved1_offset
operator|+
name|i
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SVD_reserved2_size
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|h
index|[
name|SVD_reserved2_offset
operator|+
name|i
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SVD_reserved3_size
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|h
index|[
name|SVD_reserved3_offset
operator|+
name|i
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* File structure version must be 1 for ISO9660/ECMA119. */
if|if
condition|(
name|h
index|[
name|SVD_file_structure_version_offset
index|]
operator|!=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|logical_block_size
operator|=
name|archive_le16dec
argument_list|(
name|h
operator|+
name|SVD_logical_block_size_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|logical_block_size
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|volume_block
operator|=
name|archive_le32dec
argument_list|(
name|h
operator|+
name|SVD_volume_space_size_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|volume_block
operator|<=
name|SYSTEM_AREA_BLOCK
operator|+
literal|4
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Location of Occurrence of Type L Path Table must be 	 * available location, 	 *>= SYSTEM_AREA_BLOCK(16) + 2 and< Volume Space Size. */
name|location
operator|=
name|archive_le32dec
argument_list|(
name|h
operator|+
name|SVD_type_L_path_table_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|<
name|SYSTEM_AREA_BLOCK
operator|+
literal|2
operator|||
name|location
operator|>=
name|volume_block
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* The Type M Path Table must be at a valid location (WinISO 	 * and probably other programs omit this, so we allow zero) 	 * 	 *>= SYSTEM_AREA_BLOCK(16) + 2 and< Volume Space Size. */
name|location
operator|=
name|archive_be32dec
argument_list|(
name|h
operator|+
name|SVD_type_M_path_table_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|location
operator|>
literal|0
operator|&&
name|location
operator|<
name|SYSTEM_AREA_BLOCK
operator|+
literal|2
operator|)
operator|||
name|location
operator|>=
name|volume_block
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Read Root Directory Record in Volume Descriptor. */
name|p
operator|=
name|h
operator|+
name|SVD_root_directory_record_offset
expr_stmt|;
if|if
condition|(
name|p
index|[
name|DR_length_offset
index|]
operator|!=
literal|34
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|48
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isEVD
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|h
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|ssize_t
name|logical_block_size
decl_stmt|;
name|int32_t
name|volume_block
decl_stmt|;
name|int32_t
name|location
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|iso9660
expr_stmt|;
comment|/* UNUSED */
comment|/* Type of the Enhanced Volume Descriptor must be 2. */
if|if
condition|(
name|h
index|[
name|PVD_type_offset
index|]
operator|!=
literal|2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* EVD version must be 2. */
if|if
condition|(
name|h
index|[
name|PVD_version_offset
index|]
operator|!=
literal|2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Reserved field must be 0. */
if|if
condition|(
name|h
index|[
name|PVD_reserved1_offset
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Reserved field must be 0. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PVD_reserved2_size
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|h
index|[
name|PVD_reserved2_offset
operator|+
name|i
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Reserved field must be 0. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PVD_reserved3_size
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|h
index|[
name|PVD_reserved3_offset
operator|+
name|i
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Logical block size must be> 0. */
comment|/* I've looked at Ecma 119 and can't find any stronger 	 * restriction on this field. */
name|logical_block_size
operator|=
name|archive_le16dec
argument_list|(
name|h
operator|+
name|PVD_logical_block_size_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|logical_block_size
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|volume_block
operator|=
name|archive_le32dec
argument_list|(
name|h
operator|+
name|PVD_volume_space_size_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|volume_block
operator|<=
name|SYSTEM_AREA_BLOCK
operator|+
literal|4
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* File structure version must be 2 for ISO9660:1999. */
if|if
condition|(
name|h
index|[
name|PVD_file_structure_version_offset
index|]
operator|!=
literal|2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Location of Occurrence of Type L Path Table must be 	 * available location, 	 *>= SYSTEM_AREA_BLOCK(16) + 2 and< Volume Space Size. */
name|location
operator|=
name|archive_le32dec
argument_list|(
name|h
operator|+
name|PVD_type_1_path_table_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|<
name|SYSTEM_AREA_BLOCK
operator|+
literal|2
operator|||
name|location
operator|>=
name|volume_block
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Location of Occurrence of Type M Path Table must be 	 * available location, 	 *>= SYSTEM_AREA_BLOCK(16) + 2 and< Volume Space Size. */
name|location
operator|=
name|archive_be32dec
argument_list|(
name|h
operator|+
name|PVD_type_m_path_table_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|location
operator|>
literal|0
operator|&&
name|location
operator|<
name|SYSTEM_AREA_BLOCK
operator|+
literal|2
operator|)
operator|||
name|location
operator|>=
name|volume_block
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Reserved field must be 0. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PVD_reserved4_size
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|h
index|[
name|PVD_reserved4_offset
operator|+
name|i
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Reserved field must be 0. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PVD_reserved5_size
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|h
index|[
name|PVD_reserved5_offset
operator|+
name|i
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Read Root Directory Record in Volume Descriptor. */
name|p
operator|=
name|h
operator|+
name|PVD_root_directory_record_offset
expr_stmt|;
if|if
condition|(
name|p
index|[
name|DR_length_offset
index|]
operator|!=
literal|34
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|48
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isPVD
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|h
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|ssize_t
name|logical_block_size
decl_stmt|;
name|int32_t
name|volume_block
decl_stmt|;
name|int32_t
name|location
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Type of the Primary Volume Descriptor must be 1. */
if|if
condition|(
name|h
index|[
name|PVD_type_offset
index|]
operator|!=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* PVD version must be 1. */
if|if
condition|(
name|h
index|[
name|PVD_version_offset
index|]
operator|!=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Reserved field must be 0. */
if|if
condition|(
name|h
index|[
name|PVD_reserved1_offset
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Reserved field must be 0. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PVD_reserved2_size
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|h
index|[
name|PVD_reserved2_offset
operator|+
name|i
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Reserved field must be 0. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PVD_reserved3_size
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|h
index|[
name|PVD_reserved3_offset
operator|+
name|i
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Logical block size must be> 0. */
comment|/* I've looked at Ecma 119 and can't find any stronger 	 * restriction on this field. */
name|logical_block_size
operator|=
name|archive_le16dec
argument_list|(
name|h
operator|+
name|PVD_logical_block_size_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|logical_block_size
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|volume_block
operator|=
name|archive_le32dec
argument_list|(
name|h
operator|+
name|PVD_volume_space_size_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|volume_block
operator|<=
name|SYSTEM_AREA_BLOCK
operator|+
literal|4
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* File structure version must be 1 for ISO9660/ECMA119. */
if|if
condition|(
name|h
index|[
name|PVD_file_structure_version_offset
index|]
operator|!=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Location of Occurrence of Type L Path Table must be 	 * available location, 	 *> SYSTEM_AREA_BLOCK(16) + 2 and< Volume Space Size. */
name|location
operator|=
name|archive_le32dec
argument_list|(
name|h
operator|+
name|PVD_type_1_path_table_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|<
name|SYSTEM_AREA_BLOCK
operator|+
literal|2
operator|||
name|location
operator|>=
name|volume_block
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* The Type M Path Table must also be at a valid location 	 * (although ECMA 119 requires a Type M Path Table, WinISO and 	 * probably other programs omit it, so we permit a zero here) 	 * 	 *>= SYSTEM_AREA_BLOCK(16) + 2 and< Volume Space Size. */
name|location
operator|=
name|archive_be32dec
argument_list|(
name|h
operator|+
name|PVD_type_m_path_table_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|location
operator|>
literal|0
operator|&&
name|location
operator|<
name|SYSTEM_AREA_BLOCK
operator|+
literal|2
operator|)
operator|||
name|location
operator|>=
name|volume_block
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Reserved field must be 0. */
comment|/* But accept NetBSD/FreeBSD "makefs" images with 0x20 here. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PVD_reserved4_size
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|h
index|[
name|PVD_reserved4_offset
operator|+
name|i
index|]
operator|!=
literal|0
operator|&&
name|h
index|[
name|PVD_reserved4_offset
operator|+
name|i
index|]
operator|!=
literal|0x20
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Reserved field must be 0. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PVD_reserved5_size
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|h
index|[
name|PVD_reserved5_offset
operator|+
name|i
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX TODO: Check other values for sanity; reject more 	 * malformed PVDs. XXX */
comment|/* Read Root Directory Record in Volume Descriptor. */
name|p
operator|=
name|h
operator|+
name|PVD_root_directory_record_offset
expr_stmt|;
if|if
condition|(
name|p
index|[
name|DR_length_offset
index|]
operator|!=
literal|34
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|iso9660
operator|->
name|primary
operator|.
name|location
condition|)
block|{
name|iso9660
operator|->
name|logical_block_size
operator|=
name|logical_block_size
expr_stmt|;
name|iso9660
operator|->
name|volume_block
operator|=
name|volume_block
expr_stmt|;
name|iso9660
operator|->
name|volume_size
operator|=
name|logical_block_size
operator|*
operator|(
name|uint64_t
operator|)
name|volume_block
expr_stmt|;
name|iso9660
operator|->
name|primary
operator|.
name|location
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|DR_extent_offset
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|primary
operator|.
name|size
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|DR_size_offset
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|48
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_children
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|file_info
modifier|*
name|parent
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|b
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|struct
name|file_info
modifier|*
name|multi
decl_stmt|;
name|size_t
name|step
decl_stmt|,
name|skip_size
decl_stmt|;
name|iso9660
operator|=
operator|(
expr|struct
name|iso9660
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|current_position
operator|>
name|parent
operator|->
name|offset
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Ignoring out-of-order directory (%s) %jd> %jd"
argument_list|,
name|parent
operator|->
name|name
operator|.
name|s
argument_list|,
operator|(
name|intmax_t
operator|)
name|iso9660
operator|->
name|current_position
argument_list|,
operator|(
name|intmax_t
operator|)
name|parent
operator|->
name|offset
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
if|if
condition|(
name|parent
operator|->
name|offset
operator|+
name|parent
operator|->
name|size
operator|>
name|iso9660
operator|->
name|volume_size
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Directory is beyond end-of-media: %s"
argument_list|,
name|parent
operator|->
name|name
operator|.
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
if|if
condition|(
name|iso9660
operator|->
name|current_position
operator|<
name|parent
operator|->
name|offset
condition|)
block|{
name|int64_t
name|skipsize
decl_stmt|;
name|skipsize
operator|=
name|parent
operator|->
name|offset
operator|-
name|iso9660
operator|->
name|current_position
expr_stmt|;
name|skipsize
operator|=
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|skipsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|skipsize
operator|<
literal|0
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|skipsize
operator|)
return|;
name|iso9660
operator|->
name|current_position
operator|=
name|parent
operator|->
name|offset
expr_stmt|;
block|}
name|step
operator|=
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
name|parent
operator|->
name|size
operator|+
name|iso9660
operator|->
name|logical_block_size
operator|-
literal|1
operator|)
operator|/
name|iso9660
operator|->
name|logical_block_size
operator|)
operator|*
name|iso9660
operator|->
name|logical_block_size
argument_list|)
expr_stmt|;
name|b
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|step
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Failed to read full block when scanning "
literal|"ISO9660 directory list"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|iso9660
operator|->
name|current_position
operator|+=
name|step
expr_stmt|;
name|multi
operator|=
name|NULL
expr_stmt|;
name|skip_size
operator|=
name|step
expr_stmt|;
while|while
condition|(
name|step
condition|)
block|{
name|p
operator|=
name|b
expr_stmt|;
name|b
operator|+=
name|iso9660
operator|->
name|logical_block_size
expr_stmt|;
name|step
operator|-=
name|iso9660
operator|->
name|logical_block_size
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|0
operator|&&
name|p
operator|<
name|b
operator|&&
name|p
operator|+
operator|*
name|p
operator|<=
name|b
condition|;
name|p
operator|+=
operator|*
name|p
control|)
block|{
name|struct
name|file_info
modifier|*
name|child
decl_stmt|;
comment|/* N.B.: these special directory identifiers 			 * are 8 bit "values" even on a 			 * Joliet CD with UCS-2 (16bit) encoding. 			 */
comment|/* Skip '.' entry. */
if|if
condition|(
operator|*
operator|(
name|p
operator|+
name|DR_name_len_offset
operator|)
operator|==
literal|1
operator|&&
operator|*
operator|(
name|p
operator|+
name|DR_name_offset
operator|)
operator|==
literal|'\0'
condition|)
continue|continue;
comment|/* Skip '..' entry. */
if|if
condition|(
operator|*
operator|(
name|p
operator|+
name|DR_name_len_offset
operator|)
operator|==
literal|1
operator|&&
operator|*
operator|(
name|p
operator|+
name|DR_name_offset
operator|)
operator|==
literal|'\001'
condition|)
continue|continue;
name|child
operator|=
name|parse_file_info
argument_list|(
name|a
argument_list|,
name|parent
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
block|{
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|skip_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|child
operator|->
name|cl_offset
operator|==
literal|0
operator|&&
operator|(
name|child
operator|->
name|multi_extent
operator|||
name|multi
operator|!=
name|NULL
operator|)
condition|)
block|{
name|struct
name|content
modifier|*
name|con
decl_stmt|;
if|if
condition|(
name|multi
operator|==
name|NULL
condition|)
block|{
name|multi
operator|=
name|child
expr_stmt|;
name|multi
operator|->
name|contents
operator|.
name|first
operator|=
name|NULL
expr_stmt|;
name|multi
operator|->
name|contents
operator|.
name|last
operator|=
operator|&
operator|(
name|multi
operator|->
name|contents
operator|.
name|first
operator|)
expr_stmt|;
block|}
name|con
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|content
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|con
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"No memory for multi extent"
argument_list|)
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|skip_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|con
operator|->
name|offset
operator|=
name|child
operator|->
name|offset
expr_stmt|;
name|con
operator|->
name|size
operator|=
name|child
operator|->
name|size
expr_stmt|;
name|con
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|multi
operator|->
name|contents
operator|.
name|last
operator|=
name|con
expr_stmt|;
name|multi
operator|->
name|contents
operator|.
name|last
operator|=
operator|&
operator|(
name|con
operator|->
name|next
operator|)
expr_stmt|;
if|if
condition|(
name|multi
operator|==
name|child
condition|)
block|{
if|if
condition|(
name|add_entry
argument_list|(
name|a
argument_list|,
name|iso9660
argument_list|,
name|child
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
else|else
block|{
name|multi
operator|->
name|size
operator|+=
name|child
operator|->
name|size
expr_stmt|;
if|if
condition|(
operator|!
name|child
operator|->
name|multi_extent
condition|)
name|multi
operator|=
name|NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|add_entry
argument_list|(
name|a
argument_list|,
name|iso9660
argument_list|,
name|child
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|skip_size
argument_list|)
expr_stmt|;
comment|/* Read data which recorded by RRIP "CE" extension. */
if|if
condition|(
name|read_CE
argument_list|(
name|a
argument_list|,
name|iso9660
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_iso9660_read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
decl_stmt|;
name|struct
name|file_info
modifier|*
name|file
decl_stmt|;
name|int
name|r
decl_stmt|,
name|rd_r
init|=
name|ARCHIVE_OK
decl_stmt|;
name|iso9660
operator|=
operator|(
expr|struct
name|iso9660
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|a
operator|->
name|archive
operator|.
name|archive_format
condition|)
block|{
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_ISO9660
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"ISO9660"
expr_stmt|;
block|}
if|if
condition|(
name|iso9660
operator|->
name|current_position
operator|==
literal|0
condition|)
block|{
name|int64_t
name|skipsize
decl_stmt|;
name|struct
name|vd
modifier|*
name|vd
decl_stmt|;
specifier|const
name|void
modifier|*
name|block
decl_stmt|;
name|char
name|seenJoliet
decl_stmt|;
name|vd
operator|=
operator|&
operator|(
name|iso9660
operator|->
name|primary
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|iso9660
operator|->
name|opt_support_joliet
condition|)
name|iso9660
operator|->
name|seenJoliet
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|seenJoliet
operator|&&
name|vd
operator|->
name|location
operator|>
name|iso9660
operator|->
name|joliet
operator|.
name|location
condition|)
comment|/* This condition is unlikely; by way of caution. */
name|vd
operator|=
operator|&
operator|(
name|iso9660
operator|->
name|joliet
operator|)
expr_stmt|;
name|skipsize
operator|=
name|LOGICAL_BLOCK_SIZE
operator|*
name|vd
operator|->
name|location
expr_stmt|;
name|skipsize
operator|=
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|skipsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|skipsize
operator|<
literal|0
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|skipsize
operator|)
return|;
name|iso9660
operator|->
name|current_position
operator|=
name|skipsize
expr_stmt|;
name|block
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|vd
operator|->
name|size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Failed to read full block when scanning "
literal|"ISO9660 directory list"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* 		 * While reading Root Directory, flag seenJoliet 		 * must be zero to avoid converting special name 		 * 0x00(Current Directory) and next byte to UCS2. 		 */
name|seenJoliet
operator|=
name|iso9660
operator|->
name|seenJoliet
expr_stmt|;
comment|/* Save flag. */
name|iso9660
operator|->
name|seenJoliet
operator|=
literal|0
expr_stmt|;
name|file
operator|=
name|parse_file_info
argument_list|(
name|a
argument_list|,
name|NULL
argument_list|,
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|iso9660
operator|->
name|seenJoliet
operator|=
name|seenJoliet
expr_stmt|;
if|if
condition|(
name|vd
operator|==
operator|&
operator|(
name|iso9660
operator|->
name|primary
operator|)
operator|&&
name|iso9660
operator|->
name|seenRockridge
operator|&&
name|iso9660
operator|->
name|seenJoliet
condition|)
comment|/* 			 * If iso image has RockRidge and Joliet, 			 * we use RockRidge Extensions. 			 */
name|iso9660
operator|->
name|seenJoliet
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vd
operator|==
operator|&
operator|(
name|iso9660
operator|->
name|primary
operator|)
operator|&&
operator|!
name|iso9660
operator|->
name|seenRockridge
operator|&&
name|iso9660
operator|->
name|seenJoliet
condition|)
block|{
comment|/* Switch reading data from primary to joliet. */
name|vd
operator|=
operator|&
operator|(
name|iso9660
operator|->
name|joliet
operator|)
expr_stmt|;
name|skipsize
operator|=
name|LOGICAL_BLOCK_SIZE
operator|*
name|vd
operator|->
name|location
expr_stmt|;
name|skipsize
operator|-=
name|iso9660
operator|->
name|current_position
expr_stmt|;
name|skipsize
operator|=
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|skipsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|skipsize
operator|<
literal|0
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|skipsize
operator|)
return|;
name|iso9660
operator|->
name|current_position
operator|+=
name|skipsize
expr_stmt|;
name|block
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|vd
operator|->
name|size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Failed to read full block when scanning "
literal|"ISO9660 directory list"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|iso9660
operator|->
name|seenJoliet
operator|=
literal|0
expr_stmt|;
name|file
operator|=
name|parse_file_info
argument_list|(
name|a
argument_list|,
name|NULL
argument_list|,
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|iso9660
operator|->
name|seenJoliet
operator|=
name|seenJoliet
expr_stmt|;
block|}
comment|/* Store the root directory in the pending list. */
if|if
condition|(
name|add_entry
argument_list|(
name|a
argument_list|,
name|iso9660
argument_list|,
name|file
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
if|if
condition|(
name|iso9660
operator|->
name|seenRockridge
condition|)
block|{
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_ISO9660_ROCKRIDGE
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"ISO9660 with Rockridge extensions"
expr_stmt|;
block|}
block|}
name|file
operator|=
name|NULL
expr_stmt|;
comment|/* Eliminate a warning. */
comment|/* Get the next entry that appears after the current offset. */
name|r
operator|=
name|next_entry_seek
argument_list|(
name|a
argument_list|,
name|iso9660
argument_list|,
operator|&
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
if|if
condition|(
name|iso9660
operator|->
name|seenJoliet
condition|)
block|{
comment|/* 		 * Convert UTF-16BE of a filename to local locale MBS 		 * and store the result into a filename field. 		 */
if|if
condition|(
name|iso9660
operator|->
name|sconv_utf16be
operator|==
name|NULL
condition|)
block|{
name|iso9660
operator|->
name|sconv_utf16be
operator|=
name|archive_string_conversion_from_charset
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
literal|"UTF-16BE"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|sconv_utf16be
operator|==
name|NULL
condition|)
comment|/* Coundn't allocate memory */
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|iso9660
operator|->
name|utf16be_path
operator|==
name|NULL
condition|)
block|{
name|iso9660
operator|->
name|utf16be_path
operator|=
name|malloc
argument_list|(
name|UTF16_NAME_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|utf16be_path
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"No memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|iso9660
operator|->
name|utf16be_previous_path
operator|==
name|NULL
condition|)
block|{
name|iso9660
operator|->
name|utf16be_previous_path
operator|=
name|malloc
argument_list|(
name|UTF16_NAME_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|utf16be_previous_path
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"No memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
name|iso9660
operator|->
name|utf16be_path_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|build_pathname_utf16be
argument_list|(
name|iso9660
operator|->
name|utf16be_path
argument_list|,
name|UTF16_NAME_MAX
argument_list|,
operator|&
operator|(
name|iso9660
operator|->
name|utf16be_path_len
operator|)
argument_list|,
name|file
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Pathname is too long"
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|archive_entry_copy_pathname_l
argument_list|(
name|entry
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|iso9660
operator|->
name|utf16be_path
argument_list|,
name|iso9660
operator|->
name|utf16be_path_len
argument_list|,
name|iso9660
operator|->
name|sconv_utf16be
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"No memory for Pathname"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Pathname cannot be converted "
literal|"from %s to current locale."
argument_list|,
name|archive_string_conversion_charset_name
argument_list|(
name|iso9660
operator|->
name|sconv_utf16be
argument_list|)
argument_list|)
expr_stmt|;
name|rd_r
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
block|}
else|else
block|{
name|archive_string_empty
argument_list|(
operator|&
name|iso9660
operator|->
name|pathname
argument_list|)
expr_stmt|;
name|archive_entry_set_pathname
argument_list|(
name|entry
argument_list|,
name|build_pathname
argument_list|(
operator|&
name|iso9660
operator|->
name|pathname
argument_list|,
name|file
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|iso9660
operator|->
name|entry_bytes_remaining
operator|=
name|file
operator|->
name|size
expr_stmt|;
name|iso9660
operator|->
name|entry_sparse_offset
operator|=
literal|0
expr_stmt|;
comment|/* Offset for sparse-file-aware clients. */
if|if
condition|(
name|file
operator|->
name|offset
operator|+
name|file
operator|->
name|size
operator|>
name|iso9660
operator|->
name|volume_size
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"File is beyond end-of-media: %s"
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|entry_bytes_remaining
operator|=
literal|0
expr_stmt|;
name|iso9660
operator|->
name|entry_sparse_offset
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* Set up the entry structure with information about this entry. */
name|archive_entry_set_mode
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|mode
argument_list|)
expr_stmt|;
name|archive_entry_set_uid
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|uid
argument_list|)
expr_stmt|;
name|archive_entry_set_gid
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|gid
argument_list|)
expr_stmt|;
name|archive_entry_set_nlink
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|nlinks
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|birthtime_is_set
condition|)
name|archive_entry_set_birthtime
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|birthtime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|archive_entry_unset_birthtime
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|archive_entry_set_mtime
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|mtime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|archive_entry_set_ctime
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|ctime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|archive_entry_set_atime
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|atime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* N.B.: Rock Ridge supports 64-bit device numbers. */
name|archive_entry_set_rdev
argument_list|(
name|entry
argument_list|,
operator|(
name|dev_t
operator|)
name|file
operator|->
name|rdev
argument_list|)
expr_stmt|;
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
name|iso9660
operator|->
name|entry_bytes_remaining
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|symlink
operator|.
name|s
operator|!=
name|NULL
condition|)
name|archive_entry_copy_symlink
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|symlink
operator|.
name|s
argument_list|)
expr_stmt|;
comment|/* Note: If the input isn't seekable, we can't rewind to 	 * return the same body again, so if the next entry refers to 	 * the same data, we have to return it as a hardlink to the 	 * original entry. */
if|if
condition|(
name|file
operator|->
name|number
operator|!=
operator|-
literal|1
operator|&&
name|file
operator|->
name|number
operator|==
name|iso9660
operator|->
name|previous_number
condition|)
block|{
if|if
condition|(
name|iso9660
operator|->
name|seenJoliet
condition|)
block|{
name|r
operator|=
name|archive_entry_copy_hardlink_l
argument_list|(
name|entry
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|iso9660
operator|->
name|utf16be_previous_path
argument_list|,
name|iso9660
operator|->
name|utf16be_previous_path_len
argument_list|,
name|iso9660
operator|->
name|sconv_utf16be
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"No memory for Linkname"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Linkname cannot be converted "
literal|"from %s to current locale."
argument_list|,
name|archive_string_conversion_charset_name
argument_list|(
name|iso9660
operator|->
name|sconv_utf16be
argument_list|)
argument_list|)
expr_stmt|;
name|rd_r
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
block|}
else|else
name|archive_entry_set_hardlink
argument_list|(
name|entry
argument_list|,
name|iso9660
operator|->
name|previous_pathname
operator|.
name|s
argument_list|)
expr_stmt|;
name|archive_entry_unset_size
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|entry_bytes_remaining
operator|=
literal|0
expr_stmt|;
name|iso9660
operator|->
name|entry_sparse_offset
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|rd_r
operator|)
return|;
block|}
comment|/* Except for the hardlink case above, if the offset of the 	 * next entry is before our current position, we can't seek 	 * backwards to extract it, so issue a warning.  Note that 	 * this can only happen if this entry was added to the heap 	 * after we passed this offset, that is, only if the directory 	 * mentioning this entry is later than the body of the entry. 	 * Such layouts are very unusual; most ISO9660 writers lay out 	 * and record all directory information first, then store 	 * all file bodies. */
comment|/* TODO: Someday, libarchive's I/O core will support optional 	 * seeking.  When that day comes, this code should attempt to 	 * seek and only return the error if the seek fails.  That 	 * will give us support for whacky ISO images that require 	 * seeking while retaining the ability to read almost all ISO 	 * images in a streaming fashion. */
if|if
condition|(
operator|(
name|file
operator|->
name|mode
operator|&
name|AE_IFMT
operator|)
operator|!=
name|AE_IFDIR
operator|&&
name|file
operator|->
name|offset
operator|<
name|iso9660
operator|->
name|current_position
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Ignoring out-of-order file @%jx (%s) %jd< %jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|file
operator|->
name|number
argument_list|,
name|iso9660
operator|->
name|pathname
operator|.
name|s
argument_list|,
operator|(
name|intmax_t
operator|)
name|file
operator|->
name|offset
argument_list|,
operator|(
name|intmax_t
operator|)
name|iso9660
operator|->
name|current_position
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|entry_bytes_remaining
operator|=
literal|0
expr_stmt|;
name|iso9660
operator|->
name|entry_sparse_offset
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* Initialize zisofs variables. */
name|iso9660
operator|->
name|entry_zisofs
operator|.
name|pz
operator|=
name|file
operator|->
name|pz
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|pz
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
name|struct
name|zisofs
modifier|*
name|zisofs
decl_stmt|;
name|zisofs
operator|=
operator|&
name|iso9660
operator|->
name|entry_zisofs
expr_stmt|;
name|zisofs
operator|->
name|initialized
operator|=
literal|0
expr_stmt|;
name|zisofs
operator|->
name|pz_log2_bs
operator|=
name|file
operator|->
name|pz_log2_bs
expr_stmt|;
name|zisofs
operator|->
name|pz_uncompressed_size
operator|=
name|file
operator|->
name|pz_uncompressed_size
expr_stmt|;
name|zisofs
operator|->
name|pz_offset
operator|=
literal|0
expr_stmt|;
name|zisofs
operator|->
name|header_avail
operator|=
literal|0
expr_stmt|;
name|zisofs
operator|->
name|header_passed
operator|=
literal|0
expr_stmt|;
name|zisofs
operator|->
name|block_pointers_avail
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|pz_uncompressed_size
argument_list|)
expr_stmt|;
block|}
name|iso9660
operator|->
name|previous_number
operator|=
name|file
operator|->
name|number
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|seenJoliet
condition|)
block|{
name|memcpy
argument_list|(
name|iso9660
operator|->
name|utf16be_previous_path
argument_list|,
name|iso9660
operator|->
name|utf16be_path
argument_list|,
name|iso9660
operator|->
name|utf16be_path_len
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|utf16be_previous_path_len
operator|=
name|iso9660
operator|->
name|utf16be_path_len
expr_stmt|;
block|}
else|else
name|archive_strcpy
argument_list|(
operator|&
name|iso9660
operator|->
name|previous_pathname
argument_list|,
name|iso9660
operator|->
name|pathname
operator|.
name|s
argument_list|)
expr_stmt|;
comment|/* Reset entry_bytes_remaining if the file is multi extent. */
name|iso9660
operator|->
name|entry_content
operator|=
name|file
operator|->
name|contents
operator|.
name|first
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|entry_content
operator|!=
name|NULL
condition|)
name|iso9660
operator|->
name|entry_bytes_remaining
operator|=
name|iso9660
operator|->
name|entry_content
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
operator|==
name|AE_IFDIR
condition|)
block|{
comment|/* Overwrite nlinks by proper link number which is 		 * calculated from number of sub directories. */
name|archive_entry_set_nlink
argument_list|(
name|entry
argument_list|,
literal|2
operator|+
name|file
operator|->
name|subdirs
argument_list|)
expr_stmt|;
comment|/* Directory data has been read completely. */
name|iso9660
operator|->
name|entry_bytes_remaining
operator|=
literal|0
expr_stmt|;
name|iso9660
operator|->
name|entry_sparse_offset
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rd_r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|rd_r
operator|)
return|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_iso9660_read_data_skip
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
comment|/* Because read_next_header always does an explicit skip 	 * to the next entry, we don't need to do anything here. */
operator|(
name|void
operator|)
name|a
expr_stmt|;
comment|/* UNUSED */
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
end_ifdef

begin_function
specifier|static
name|int
name|zisofs_read_data
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|int64_t
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
decl_stmt|;
name|struct
name|zisofs
modifier|*
name|zisofs
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|avail
decl_stmt|;
name|ssize_t
name|bytes_read
decl_stmt|;
name|size_t
name|uncompressed_size
decl_stmt|;
name|int
name|r
decl_stmt|;
name|iso9660
operator|=
operator|(
expr|struct
name|iso9660
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
name|zisofs
operator|=
operator|&
name|iso9660
operator|->
name|entry_zisofs
expr_stmt|;
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|<=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated zisofs file body"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|bytes_read
operator|>
name|iso9660
operator|->
name|entry_bytes_remaining
condition|)
name|bytes_read
operator|=
operator|(
name|ssize_t
operator|)
name|iso9660
operator|->
name|entry_bytes_remaining
expr_stmt|;
name|avail
operator|=
name|bytes_read
expr_stmt|;
name|uncompressed_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|zisofs
operator|->
name|initialized
condition|)
block|{
name|size_t
name|ceil
decl_stmt|,
name|xsize
decl_stmt|;
comment|/* Allocate block pointers buffer. */
name|ceil
operator|=
call|(
name|size_t
call|)
argument_list|(
operator|(
name|zisofs
operator|->
name|pz_uncompressed_size
operator|+
operator|(
operator|(
operator|(
name|int64_t
operator|)
literal|1
operator|)
operator|<<
name|zisofs
operator|->
name|pz_log2_bs
operator|)
operator|-
literal|1
operator|)
operator|>>
name|zisofs
operator|->
name|pz_log2_bs
argument_list|)
expr_stmt|;
name|xsize
operator|=
operator|(
name|ceil
operator|+
literal|1
operator|)
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|zisofs
operator|->
name|block_pointers_alloc
operator|<
name|xsize
condition|)
block|{
name|size_t
name|alloc
decl_stmt|;
if|if
condition|(
name|zisofs
operator|->
name|block_pointers
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|zisofs
operator|->
name|block_pointers
argument_list|)
expr_stmt|;
name|alloc
operator|=
operator|(
operator|(
name|xsize
operator|>>
literal|10
operator|)
operator|+
literal|1
operator|)
operator|<<
literal|10
expr_stmt|;
name|zisofs
operator|->
name|block_pointers
operator|=
name|malloc
argument_list|(
name|alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|zisofs
operator|->
name|block_pointers
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"No memory for zisofs decompression"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|zisofs
operator|->
name|block_pointers_alloc
operator|=
name|alloc
expr_stmt|;
block|}
name|zisofs
operator|->
name|block_pointers_size
operator|=
name|xsize
expr_stmt|;
comment|/* Allocate uncompressed data buffer. */
name|xsize
operator|=
literal|1UL
operator|<<
name|zisofs
operator|->
name|pz_log2_bs
expr_stmt|;
if|if
condition|(
name|zisofs
operator|->
name|uncompressed_buffer_size
operator|<
name|xsize
condition|)
block|{
if|if
condition|(
name|zisofs
operator|->
name|uncompressed_buffer
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|zisofs
operator|->
name|uncompressed_buffer
argument_list|)
expr_stmt|;
name|zisofs
operator|->
name|uncompressed_buffer
operator|=
name|malloc
argument_list|(
name|xsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|zisofs
operator|->
name|uncompressed_buffer
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"No memory for zisofs decompression"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
name|zisofs
operator|->
name|uncompressed_buffer_size
operator|=
name|xsize
expr_stmt|;
comment|/* 		 * Read the file header, and check the magic code of zisofs. 		 */
if|if
condition|(
name|zisofs
operator|->
name|header_avail
operator|<
sizeof|sizeof
argument_list|(
name|zisofs
operator|->
name|header
argument_list|)
condition|)
block|{
name|xsize
operator|=
sizeof|sizeof
argument_list|(
name|zisofs
operator|->
name|header
argument_list|)
operator|-
name|zisofs
operator|->
name|header_avail
expr_stmt|;
if|if
condition|(
name|avail
operator|<
name|xsize
condition|)
name|xsize
operator|=
name|avail
expr_stmt|;
name|memcpy
argument_list|(
name|zisofs
operator|->
name|header
operator|+
name|zisofs
operator|->
name|header_avail
argument_list|,
name|p
argument_list|,
name|xsize
argument_list|)
expr_stmt|;
name|zisofs
operator|->
name|header_avail
operator|+=
name|xsize
expr_stmt|;
name|avail
operator|-=
name|xsize
expr_stmt|;
name|p
operator|+=
name|xsize
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|zisofs
operator|->
name|header_passed
operator|&&
name|zisofs
operator|->
name|header_avail
operator|==
sizeof|sizeof
argument_list|(
name|zisofs
operator|->
name|header
argument_list|)
condition|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|zisofs
operator|->
name|header
argument_list|,
name|zisofs_magic
argument_list|,
sizeof|sizeof
argument_list|(
name|zisofs_magic
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|err
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|archive_le32dec
argument_list|(
name|zisofs
operator|->
name|header
operator|+
literal|8
argument_list|)
operator|!=
name|zisofs
operator|->
name|pz_uncompressed_size
condition|)
name|err
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|zisofs
operator|->
name|header
index|[
literal|12
index|]
operator|!=
literal|4
condition|)
name|err
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|zisofs
operator|->
name|header
index|[
literal|13
index|]
operator|!=
name|zisofs
operator|->
name|pz_log2_bs
condition|)
name|err
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Illegal zisofs file body"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|zisofs
operator|->
name|header_passed
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * Read block pointers. 		 */
if|if
condition|(
name|zisofs
operator|->
name|header_passed
operator|&&
name|zisofs
operator|->
name|block_pointers_avail
operator|<
name|zisofs
operator|->
name|block_pointers_size
condition|)
block|{
name|xsize
operator|=
name|zisofs
operator|->
name|block_pointers_size
operator|-
name|zisofs
operator|->
name|block_pointers_avail
expr_stmt|;
if|if
condition|(
name|avail
operator|<
name|xsize
condition|)
name|xsize
operator|=
name|avail
expr_stmt|;
name|memcpy
argument_list|(
name|zisofs
operator|->
name|block_pointers
operator|+
name|zisofs
operator|->
name|block_pointers_avail
argument_list|,
name|p
argument_list|,
name|xsize
argument_list|)
expr_stmt|;
name|zisofs
operator|->
name|block_pointers_avail
operator|+=
name|xsize
expr_stmt|;
name|avail
operator|-=
name|xsize
expr_stmt|;
name|p
operator|+=
name|xsize
expr_stmt|;
if|if
condition|(
name|zisofs
operator|->
name|block_pointers_avail
operator|==
name|zisofs
operator|->
name|block_pointers_size
condition|)
block|{
comment|/* We've got all block pointers and initialize 				 * related variables.	*/
name|zisofs
operator|->
name|block_off
operator|=
literal|0
expr_stmt|;
name|zisofs
operator|->
name|block_avail
operator|=
literal|0
expr_stmt|;
comment|/* Complete a initialization */
name|zisofs
operator|->
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|zisofs
operator|->
name|initialized
condition|)
goto|goto
name|next_data
goto|;
comment|/* We need more data. */
block|}
comment|/* 	 * Get block offsets from block pointers. 	 */
if|if
condition|(
name|zisofs
operator|->
name|block_avail
operator|==
literal|0
condition|)
block|{
name|uint32_t
name|bst
decl_stmt|,
name|bed
decl_stmt|;
if|if
condition|(
name|zisofs
operator|->
name|block_off
operator|+
literal|4
operator|>=
name|zisofs
operator|->
name|block_pointers_size
condition|)
block|{
comment|/* There isn't a pair of offsets. */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Illegal zisofs block pointers"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|bst
operator|=
name|archive_le32dec
argument_list|(
name|zisofs
operator|->
name|block_pointers
operator|+
name|zisofs
operator|->
name|block_off
argument_list|)
expr_stmt|;
if|if
condition|(
name|bst
operator|!=
name|zisofs
operator|->
name|pz_offset
operator|+
operator|(
name|bytes_read
operator|-
name|avail
operator|)
condition|)
block|{
comment|/* TODO: Should we seek offset of current file 			 * by bst ? */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Illegal zisofs block pointers(cannot seek)"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|bed
operator|=
name|archive_le32dec
argument_list|(
name|zisofs
operator|->
name|block_pointers
operator|+
name|zisofs
operator|->
name|block_off
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|bed
operator|<
name|bst
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Illegal zisofs block pointers"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|zisofs
operator|->
name|block_avail
operator|=
name|bed
operator|-
name|bst
expr_stmt|;
name|zisofs
operator|->
name|block_off
operator|+=
literal|4
expr_stmt|;
comment|/* Initialize compression library for new block. */
if|if
condition|(
name|zisofs
operator|->
name|stream_valid
condition|)
name|r
operator|=
name|inflateReset
argument_list|(
operator|&
name|zisofs
operator|->
name|stream
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|inflateInit
argument_list|(
operator|&
name|zisofs
operator|->
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|Z_OK
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Can't initialize zisofs decompression."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|zisofs
operator|->
name|stream_valid
operator|=
literal|1
expr_stmt|;
name|zisofs
operator|->
name|stream
operator|.
name|total_in
operator|=
literal|0
expr_stmt|;
name|zisofs
operator|->
name|stream
operator|.
name|total_out
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Make uncompressed data. 	 */
if|if
condition|(
name|zisofs
operator|->
name|block_avail
operator|==
literal|0
condition|)
block|{
name|memset
argument_list|(
name|zisofs
operator|->
name|uncompressed_buffer
argument_list|,
literal|0
argument_list|,
name|zisofs
operator|->
name|uncompressed_buffer_size
argument_list|)
expr_stmt|;
name|uncompressed_size
operator|=
name|zisofs
operator|->
name|uncompressed_buffer_size
expr_stmt|;
block|}
else|else
block|{
name|zisofs
operator|->
name|stream
operator|.
name|next_in
operator|=
operator|(
name|Bytef
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|(
specifier|const
name|void
operator|*
operator|)
name|p
expr_stmt|;
if|if
condition|(
name|avail
operator|>
name|zisofs
operator|->
name|block_avail
condition|)
name|zisofs
operator|->
name|stream
operator|.
name|avail_in
operator|=
name|zisofs
operator|->
name|block_avail
expr_stmt|;
else|else
name|zisofs
operator|->
name|stream
operator|.
name|avail_in
operator|=
name|avail
expr_stmt|;
name|zisofs
operator|->
name|stream
operator|.
name|next_out
operator|=
name|zisofs
operator|->
name|uncompressed_buffer
expr_stmt|;
name|zisofs
operator|->
name|stream
operator|.
name|avail_out
operator|=
name|zisofs
operator|->
name|uncompressed_buffer_size
expr_stmt|;
name|r
operator|=
name|inflate
argument_list|(
operator|&
name|zisofs
operator|->
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|Z_OK
case|:
comment|/* Decompressor made some progress.*/
case|case
name|Z_STREAM_END
case|:
comment|/* Found end of stream. */
break|break;
default|default:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"zisofs decompression failed (%d)"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|uncompressed_size
operator|=
name|zisofs
operator|->
name|uncompressed_buffer_size
operator|-
name|zisofs
operator|->
name|stream
operator|.
name|avail_out
expr_stmt|;
name|avail
operator|-=
name|zisofs
operator|->
name|stream
operator|.
name|next_in
operator|-
name|p
expr_stmt|;
name|zisofs
operator|->
name|block_avail
operator|-=
name|zisofs
operator|->
name|stream
operator|.
name|next_in
operator|-
name|p
expr_stmt|;
block|}
name|next_data
label|:
name|bytes_read
operator|-=
name|avail
expr_stmt|;
operator|*
name|buff
operator|=
name|zisofs
operator|->
name|uncompressed_buffer
expr_stmt|;
operator|*
name|size
operator|=
name|uncompressed_size
expr_stmt|;
operator|*
name|offset
operator|=
name|iso9660
operator|->
name|entry_sparse_offset
expr_stmt|;
name|iso9660
operator|->
name|entry_sparse_offset
operator|+=
name|uncompressed_size
expr_stmt|;
name|iso9660
operator|->
name|entry_bytes_remaining
operator|-=
name|bytes_read
expr_stmt|;
name|iso9660
operator|->
name|current_position
operator|+=
name|bytes_read
expr_stmt|;
name|zisofs
operator|->
name|pz_offset
operator|+=
name|bytes_read
expr_stmt|;
name|iso9660
operator|->
name|entry_bytes_unconsumed
operator|+=
name|bytes_read
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* HAVE_ZLIB_H */
end_comment

begin_function
specifier|static
name|int
name|zisofs_read_data
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|int64_t
modifier|*
name|offset
parameter_list|)
block|{
operator|(
name|void
operator|)
name|buff
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|size
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|offset
expr_stmt|;
comment|/* UNUSED */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"zisofs is not supported on this platform."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_ZLIB_H */
end_comment

begin_function
specifier|static
name|int
name|archive_read_format_iso9660_read_data
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|int64_t
modifier|*
name|offset
parameter_list|)
block|{
name|ssize_t
name|bytes_read
decl_stmt|;
name|struct
name|iso9660
modifier|*
name|iso9660
decl_stmt|;
name|iso9660
operator|=
operator|(
expr|struct
name|iso9660
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|entry_bytes_unconsumed
condition|)
block|{
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|iso9660
operator|->
name|entry_bytes_unconsumed
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|entry_bytes_unconsumed
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|iso9660
operator|->
name|entry_bytes_remaining
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|iso9660
operator|->
name|entry_content
operator|!=
name|NULL
condition|)
name|iso9660
operator|->
name|entry_content
operator|=
name|iso9660
operator|->
name|entry_content
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|entry_content
operator|==
name|NULL
condition|)
block|{
operator|*
name|buff
operator|=
name|NULL
expr_stmt|;
operator|*
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|offset
operator|=
name|iso9660
operator|->
name|entry_sparse_offset
expr_stmt|;
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
block|}
comment|/* Seek forward to the start of the entry. */
if|if
condition|(
name|iso9660
operator|->
name|current_position
operator|<
name|iso9660
operator|->
name|entry_content
operator|->
name|offset
condition|)
block|{
name|int64_t
name|step
decl_stmt|;
name|step
operator|=
name|iso9660
operator|->
name|entry_content
operator|->
name|offset
operator|-
name|iso9660
operator|->
name|current_position
expr_stmt|;
name|step
operator|=
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|step
argument_list|)
expr_stmt|;
if|if
condition|(
name|step
operator|<
literal|0
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|step
operator|)
return|;
name|iso9660
operator|->
name|current_position
operator|=
name|iso9660
operator|->
name|entry_content
operator|->
name|offset
expr_stmt|;
block|}
if|if
condition|(
name|iso9660
operator|->
name|entry_content
operator|->
name|offset
operator|<
name|iso9660
operator|->
name|current_position
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Ignoring out-of-order file (%s) %jd< %jd"
argument_list|,
name|iso9660
operator|->
name|pathname
operator|.
name|s
argument_list|,
operator|(
name|intmax_t
operator|)
name|iso9660
operator|->
name|entry_content
operator|->
name|offset
argument_list|,
operator|(
name|intmax_t
operator|)
name|iso9660
operator|->
name|current_position
argument_list|)
expr_stmt|;
operator|*
name|buff
operator|=
name|NULL
expr_stmt|;
operator|*
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|offset
operator|=
name|iso9660
operator|->
name|entry_sparse_offset
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
name|iso9660
operator|->
name|entry_bytes_remaining
operator|=
name|iso9660
operator|->
name|entry_content
operator|->
name|size
expr_stmt|;
block|}
if|if
condition|(
name|iso9660
operator|->
name|entry_zisofs
operator|.
name|pz
condition|)
return|return
operator|(
name|zisofs_read_data
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|size
argument_list|,
name|offset
argument_list|)
operator|)
return|;
operator|*
name|buff
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|==
literal|0
condition|)
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Truncated input file"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buff
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
if|if
condition|(
name|bytes_read
operator|>
name|iso9660
operator|->
name|entry_bytes_remaining
condition|)
name|bytes_read
operator|=
operator|(
name|ssize_t
operator|)
name|iso9660
operator|->
name|entry_bytes_remaining
expr_stmt|;
operator|*
name|size
operator|=
name|bytes_read
expr_stmt|;
operator|*
name|offset
operator|=
name|iso9660
operator|->
name|entry_sparse_offset
expr_stmt|;
name|iso9660
operator|->
name|entry_sparse_offset
operator|+=
name|bytes_read
expr_stmt|;
name|iso9660
operator|->
name|entry_bytes_remaining
operator|-=
name|bytes_read
expr_stmt|;
name|iso9660
operator|->
name|entry_bytes_unconsumed
operator|=
name|bytes_read
expr_stmt|;
name|iso9660
operator|->
name|current_position
operator|+=
name|bytes_read
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_iso9660_cleanup
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
decl_stmt|;
name|int
name|r
init|=
name|ARCHIVE_OK
decl_stmt|;
name|iso9660
operator|=
operator|(
expr|struct
name|iso9660
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
name|release_files
argument_list|(
name|iso9660
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|iso9660
operator|->
name|read_ce_req
operator|.
name|reqs
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|iso9660
operator|->
name|pathname
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|iso9660
operator|->
name|previous_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|pending_files
operator|.
name|files
condition|)
name|free
argument_list|(
name|iso9660
operator|->
name|pending_files
operator|.
name|files
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
name|free
argument_list|(
name|iso9660
operator|->
name|entry_zisofs
operator|.
name|uncompressed_buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|iso9660
operator|->
name|entry_zisofs
operator|.
name|block_pointers
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|entry_zisofs
operator|.
name|stream_valid
condition|)
block|{
if|if
condition|(
name|inflateEnd
argument_list|(
operator|&
name|iso9660
operator|->
name|entry_zisofs
operator|.
name|stream
argument_list|)
operator|!=
name|Z_OK
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Failed to clean up zlib decompressor"
argument_list|)
expr_stmt|;
name|r
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|free
argument_list|(
name|iso9660
operator|->
name|utf16be_path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|iso9660
operator|->
name|utf16be_previous_path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|iso9660
argument_list|)
expr_stmt|;
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This routine parses a single ISO directory record, makes sense  * of any extensions, and stores the result in memory.  */
end_comment

begin_function
specifier|static
name|struct
name|file_info
modifier|*
name|parse_file_info
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|file_info
modifier|*
name|parent
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|isodirrec
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
decl_stmt|;
name|struct
name|file_info
modifier|*
name|file
decl_stmt|;
name|size_t
name|name_len
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|rr_start
decl_stmt|,
modifier|*
name|rr_end
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|dr_len
decl_stmt|;
name|uint64_t
name|fsize
decl_stmt|;
name|int32_t
name|location
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|iso9660
operator|=
operator|(
expr|struct
name|iso9660
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
name|dr_len
operator|=
operator|(
name|size_t
operator|)
name|isodirrec
index|[
name|DR_length_offset
index|]
expr_stmt|;
name|name_len
operator|=
operator|(
name|size_t
operator|)
name|isodirrec
index|[
name|DR_name_len_offset
index|]
expr_stmt|;
name|location
operator|=
name|archive_le32dec
argument_list|(
name|isodirrec
operator|+
name|DR_extent_offset
argument_list|)
expr_stmt|;
name|fsize
operator|=
name|toi
argument_list|(
name|isodirrec
operator|+
name|DR_size_offset
argument_list|,
name|DR_size_size
argument_list|)
expr_stmt|;
comment|/* Sanity check that dr_len needs at least 34. */
if|if
condition|(
name|dr_len
operator|<
literal|34
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Invalid length of directory record"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Sanity check that name_len doesn't exceed dr_len. */
if|if
condition|(
name|dr_len
operator|-
literal|33
operator|<
name|name_len
operator|||
name|name_len
operator|==
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Invalid length of file identifier"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Sanity check that location doesn't exceed volume block. 	 * Don't check lower limit of location; it's possibility 	 * the location has negative value when file type is symbolic 	 * link or file size is zero. As far as I know latest mkisofs 	 * do that. 	 */
if|if
condition|(
name|location
operator|>
literal|0
operator|&&
operator|(
name|location
operator|+
operator|(
operator|(
name|fsize
operator|+
name|iso9660
operator|->
name|logical_block_size
operator|-
literal|1
operator|)
operator|/
name|iso9660
operator|->
name|logical_block_size
operator|)
operator|)
operator|>
operator|(
name|uint32_t
operator|)
name|iso9660
operator|->
name|volume_block
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Invalid location of extent of file"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Sanity check that location doesn't have a negative value 	 * when the file is not empty. it's too large. */
if|if
condition|(
name|fsize
operator|!=
literal|0
operator|&&
name|location
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Invalid location of extent of file"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Create a new file entry and copy data from the ISO dir record. */
name|file
operator|=
operator|(
expr|struct
name|file_info
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|file
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"No memory for file entry"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|file
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|file
operator|->
name|offset
operator|=
name|iso9660
operator|->
name|logical_block_size
operator|*
operator|(
name|uint64_t
operator|)
name|location
expr_stmt|;
name|file
operator|->
name|size
operator|=
name|fsize
expr_stmt|;
name|file
operator|->
name|mtime
operator|=
name|isodate7
argument_list|(
name|isodirrec
operator|+
name|DR_date_offset
argument_list|)
expr_stmt|;
name|file
operator|->
name|ctime
operator|=
name|file
operator|->
name|atime
operator|=
name|file
operator|->
name|mtime
expr_stmt|;
name|file
operator|->
name|rede_files
operator|.
name|first
operator|=
name|NULL
expr_stmt|;
name|file
operator|->
name|rede_files
operator|.
name|last
operator|=
operator|&
operator|(
name|file
operator|->
name|rede_files
operator|.
name|first
operator|)
expr_stmt|;
name|p
operator|=
name|isodirrec
operator|+
name|DR_name_offset
expr_stmt|;
comment|/* Rockridge extensions (if any) follow name.  Compute this 	 * before fidgeting the name_len below. */
name|rr_start
operator|=
name|p
operator|+
name|name_len
operator|+
operator|(
name|name_len
operator|&
literal|1
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
name|rr_end
operator|=
name|isodirrec
operator|+
name|dr_len
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|seenJoliet
condition|)
block|{
comment|/* Joliet names are max 64 chars (128 bytes) according to spec, 		 * but genisoimage/mkisofs allows recording longer Joliet 		 * names which are 103 UCS2 characters(206 bytes) by their 		 * option '-joliet-long'. 		 */
if|if
condition|(
name|name_len
operator|>
literal|206
condition|)
name|name_len
operator|=
literal|206
expr_stmt|;
name|name_len
operator|&=
operator|~
literal|1
expr_stmt|;
comment|/* trim trailing first version and dot from filename. 		 * 		 * Remember we were in UTF-16BE land! 		 * SEPARATOR 1 (.) and SEPARATOR 2 (;) are both 		 * 16 bits big endian characters on Joliet. 		 * 		 * TODO: sanitize filename? 		 *       Joliet allows any UCS-2 char except: 		 *       *, /, :, ;, ? and \. 		 */
comment|/* Chop off trailing ';1' from files. */
if|if
condition|(
name|name_len
operator|>
literal|4
operator|&&
name|p
index|[
name|name_len
operator|-
literal|4
index|]
operator|==
literal|0
operator|&&
name|p
index|[
name|name_len
operator|-
literal|3
index|]
operator|==
literal|';'
operator|&&
name|p
index|[
name|name_len
operator|-
literal|2
index|]
operator|==
literal|0
operator|&&
name|p
index|[
name|name_len
operator|-
literal|1
index|]
operator|==
literal|'1'
condition|)
name|name_len
operator|-=
literal|4
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX: this somehow manages to strip of single-character file extensions, like '.c'. */
comment|/* Chop off trailing '.' from filenames. */
block|if (name_len> 2&& p[name_len-2] == 0&& p[name_len-1] == '.') 			name_len -= 2;
endif|#
directive|endif
if|if
condition|(
operator|(
name|file
operator|->
name|utf16be_name
operator|=
name|malloc
argument_list|(
name|name_len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"No memory for file name"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|file
operator|->
name|utf16be_name
argument_list|,
name|p
argument_list|,
name|name_len
argument_list|)
expr_stmt|;
name|file
operator|->
name|utf16be_bytes
operator|=
name|name_len
expr_stmt|;
block|}
else|else
block|{
comment|/* Chop off trailing ';1' from files. */
if|if
condition|(
name|name_len
operator|>
literal|2
operator|&&
name|p
index|[
name|name_len
operator|-
literal|2
index|]
operator|==
literal|';'
operator|&&
name|p
index|[
name|name_len
operator|-
literal|1
index|]
operator|==
literal|'1'
condition|)
name|name_len
operator|-=
literal|2
expr_stmt|;
comment|/* Chop off trailing '.' from filenames. */
if|if
condition|(
name|name_len
operator|>
literal|1
operator|&&
name|p
index|[
name|name_len
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
operator|--
name|name_len
expr_stmt|;
name|archive_strncpy
argument_list|(
operator|&
name|file
operator|->
name|name
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
argument_list|,
name|name_len
argument_list|)
expr_stmt|;
block|}
name|flags
operator|=
name|isodirrec
index|[
name|DR_flags_offset
index|]
expr_stmt|;
if|if
condition|(
name|flags
operator|&
literal|0x02
condition|)
name|file
operator|->
name|mode
operator|=
name|AE_IFDIR
operator||
literal|0700
expr_stmt|;
else|else
name|file
operator|->
name|mode
operator|=
name|AE_IFREG
operator||
literal|0400
expr_stmt|;
if|if
condition|(
name|flags
operator|&
literal|0x80
condition|)
name|file
operator|->
name|multi_extent
operator|=
literal|1
expr_stmt|;
else|else
name|file
operator|->
name|multi_extent
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Use a location for the file number, which is treated as an inode 	 * number to find out hardlink target. If Rockridge extensions is 	 * being used, the file number will be overwritten by FILE SERIAL 	 * NUMBER of RRIP "PX" extension. 	 * Note: Old mkisofs did not record that FILE SERIAL NUMBER 	 * in ISO images. 	 * Note2: xorriso set 0 to the location of a symlink file.  	 */
if|if
condition|(
name|file
operator|->
name|size
operator|==
literal|0
operator|&&
name|location
operator|>=
literal|0
condition|)
block|{
comment|/* If file->size is zero, its location points wrong place, 		 * and so we should not use it for the file number. 		 * When the location has negative value, it can be used 		 * for the file number. 		 */
name|file
operator|->
name|number
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Do not appear before any directory entries. */
name|file
operator|->
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|file
operator|->
name|number
operator|=
operator|(
name|int64_t
operator|)
operator|(
name|uint32_t
operator|)
name|location
expr_stmt|;
comment|/* Rockridge extensions overwrite information from above. */
if|if
condition|(
name|iso9660
operator|->
name|opt_support_rockridge
condition|)
block|{
if|if
condition|(
name|parent
operator|==
name|NULL
operator|&&
name|rr_end
operator|-
name|rr_start
operator|>=
literal|7
condition|)
block|{
name|p
operator|=
name|rr_start
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'S'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'P'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|7
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|1
operator|&&
name|p
index|[
literal|4
index|]
operator|==
literal|0xBE
operator|&&
name|p
index|[
literal|5
index|]
operator|==
literal|0xEF
condition|)
block|{
comment|/* 				 * SP extension stores the suspOffset 				 * (Number of bytes to skip between 				 * filename and SUSP records.) 				 * It is mandatory by the SUSP standard 				 * (IEEE 1281). 				 * 				 * It allows SUSP to coexist with 				 * non-SUSP uses of the System 				 * Use Area by placing non-SUSP data 				 * before SUSP data. 				 * 				 * SP extension must be in the root 				 * directory entry, disable all SUSP 				 * processing if not found. 				 */
name|iso9660
operator|->
name|suspOffset
operator|=
name|p
index|[
literal|6
index|]
expr_stmt|;
name|iso9660
operator|->
name|seenSUSP
operator|=
literal|1
expr_stmt|;
name|rr_start
operator|+=
literal|7
expr_stmt|;
block|}
block|}
if|if
condition|(
name|iso9660
operator|->
name|seenSUSP
condition|)
block|{
name|int
name|r
decl_stmt|;
name|file
operator|->
name|name_continues
operator|=
literal|0
expr_stmt|;
name|file
operator|->
name|symlink_continues
operator|=
literal|0
expr_stmt|;
name|rr_start
operator|+=
name|iso9660
operator|->
name|suspOffset
expr_stmt|;
name|r
operator|=
name|parse_rockridge
argument_list|(
name|a
argument_list|,
name|file
argument_list|,
name|rr_start
argument_list|,
name|rr_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 			 * A file size of symbolic link files in ISO images 			 * made by makefs is not zero and its location is 			 * the same as those of next regular file. That is 			 * the same as hard like file and it causes unexpected 			 * error.  			 */
if|if
condition|(
name|file
operator|->
name|size
operator|>
literal|0
operator|&&
operator|(
name|file
operator|->
name|mode
operator|&
name|AE_IFMT
operator|)
operator|==
name|AE_IFLNK
condition|)
block|{
name|file
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|file
operator|->
name|number
operator|=
operator|-
literal|1
expr_stmt|;
name|file
operator|->
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
comment|/* If there isn't SUSP, disable parsing 			 * rock ridge extensions. */
name|iso9660
operator|->
name|opt_support_rockridge
operator|=
literal|0
expr_stmt|;
block|}
name|file
operator|->
name|nlinks
operator|=
literal|1
expr_stmt|;
comment|/* Reset nlink. we'll calculate it later. */
comment|/* Tell file's parent how many children that parent has. */
if|if
condition|(
name|parent
operator|!=
name|NULL
operator|&&
operator|(
name|flags
operator|&
literal|0x02
operator|)
condition|)
name|parent
operator|->
name|subdirs
operator|++
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|seenRockridge
condition|)
block|{
if|if
condition|(
name|parent
operator|!=
name|NULL
operator|&&
name|parent
operator|->
name|parent
operator|==
name|NULL
operator|&&
operator|(
name|flags
operator|&
literal|0x02
operator|)
operator|&&
name|iso9660
operator|->
name|rr_moved
operator|==
name|NULL
operator|&&
operator|(
name|strcmp
argument_list|(
name|file
operator|->
name|name
operator|.
name|s
argument_list|,
literal|"rr_moved"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|file
operator|->
name|name
operator|.
name|s
argument_list|,
literal|".rr_moved"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|iso9660
operator|->
name|rr_moved
operator|=
name|file
expr_stmt|;
name|file
operator|->
name|rr_moved
operator|=
literal|1
expr_stmt|;
name|file
operator|->
name|rr_moved_has_re_only
operator|=
literal|1
expr_stmt|;
name|file
operator|->
name|re
operator|=
literal|0
expr_stmt|;
name|parent
operator|->
name|subdirs
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|file
operator|->
name|re
condition|)
block|{
comment|/* 			 * Sanity check: file's parent is rr_moved. 			 */
if|if
condition|(
name|parent
operator|==
name|NULL
operator|||
name|parent
operator|->
name|rr_moved
operator|==
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Invalid Rockridge RE"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 			 * Sanity check: file does not have "CL" extension. 			 */
if|if
condition|(
name|file
operator|->
name|cl_offset
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Invalid Rockridge RE and CL"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 			 * Sanity check: The file type must be a directory. 			 */
if|if
condition|(
operator|(
name|flags
operator|&
literal|0x02
operator|)
operator|==
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Invalid Rockridge RE"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|parent
operator|!=
name|NULL
operator|&&
name|parent
operator|->
name|rr_moved
condition|)
name|file
operator|->
name|rr_moved_has_re_only
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|parent
operator|!=
name|NULL
operator|&&
operator|(
name|flags
operator|&
literal|0x02
operator|)
operator|&&
operator|(
name|parent
operator|->
name|re
operator|||
name|parent
operator|->
name|re_descendant
operator|)
condition|)
name|file
operator|->
name|re_descendant
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|cl_offset
condition|)
block|{
name|struct
name|file_info
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|parent
operator|==
name|NULL
operator|||
name|parent
operator|->
name|parent
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Invalid Rockridge CL"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 			 * Sanity check: The file type must be a regular file. 			 */
if|if
condition|(
operator|(
name|flags
operator|&
literal|0x02
operator|)
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Invalid Rockridge CL"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|parent
operator|->
name|subdirs
operator|++
expr_stmt|;
comment|/* Overwrite an offset and a number of this "CL" entry 			 * to appear before other dirs. "+1" to those is to 			 * make sure to appear after "RE" entry which this 			 * "CL" entry should be connected with. */
name|file
operator|->
name|offset
operator|=
name|file
operator|->
name|number
operator|=
name|file
operator|->
name|cl_offset
operator|+
literal|1
expr_stmt|;
comment|/* 			 * Sanity check: cl_offset does not point at its 			 * the parents or itself. 			 */
for|for
control|(
name|r
operator|=
name|parent
init|;
name|r
condition|;
name|r
operator|=
name|r
operator|->
name|parent
control|)
block|{
if|if
condition|(
name|r
operator|->
name|offset
operator|==
name|file
operator|->
name|cl_offset
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Invalid Rockridge CL"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|file
operator|->
name|cl_offset
operator|==
name|file
operator|->
name|offset
operator|||
name|parent
operator|->
name|rr_moved
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Invalid Rockridge CL"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
block|}
if|#
directive|if
name|DEBUG
comment|/* DEBUGGING: Warn about attributes I don't yet fully support. */
if|if
condition|(
operator|(
name|flags
operator|&
operator|~
literal|0x02
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n ** Unrecognized flag: "
argument_list|)
expr_stmt|;
name|dump_isodirrec
argument_list|(
name|stderr
argument_list|,
name|isodirrec
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toi
argument_list|(
name|isodirrec
operator|+
name|DR_volume_sequence_number_offset
argument_list|,
literal|2
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n ** Unrecognized sequence number: "
argument_list|)
expr_stmt|;
name|dump_isodirrec
argument_list|(
name|stderr
argument_list|,
name|isodirrec
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|isodirrec
operator|+
name|DR_file_unit_size_offset
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n ** Unexpected file unit size: "
argument_list|)
expr_stmt|;
name|dump_isodirrec
argument_list|(
name|stderr
argument_list|,
name|isodirrec
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|isodirrec
operator|+
name|DR_interleave_offset
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n ** Unexpected interleave: "
argument_list|)
expr_stmt|;
name|dump_isodirrec
argument_list|(
name|stderr
argument_list|,
name|isodirrec
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|isodirrec
operator|+
name|DR_ext_attr_length_offset
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n ** Unexpected extended attribute length: "
argument_list|)
expr_stmt|;
name|dump_isodirrec
argument_list|(
name|stderr
argument_list|,
name|isodirrec
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|register_file
argument_list|(
name|iso9660
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|file
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_rockridge
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|file_info
modifier|*
name|file
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|end
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
decl_stmt|;
name|iso9660
operator|=
operator|(
expr|struct
name|iso9660
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
while|while
condition|(
name|p
operator|+
literal|4
operator|<=
name|end
comment|/* Enough space for another entry. */
operator|&&
name|p
index|[
literal|0
index|]
operator|>=
literal|'A'
operator|&&
name|p
index|[
literal|0
index|]
operator|<=
literal|'Z'
comment|/* Sanity-check 1st char of name. */
operator|&&
name|p
index|[
literal|1
index|]
operator|>=
literal|'A'
operator|&&
name|p
index|[
literal|1
index|]
operator|<=
literal|'Z'
comment|/* Sanity-check 2nd char of name. */
operator|&&
name|p
index|[
literal|2
index|]
operator|>=
literal|4
comment|/* Sanity-check length. */
operator|&&
name|p
operator|+
name|p
index|[
literal|2
index|]
operator|<=
name|end
condition|)
block|{
comment|/* Sanity-check length. */
specifier|const
name|unsigned
name|char
modifier|*
name|data
init|=
name|p
operator|+
literal|4
decl_stmt|;
name|int
name|data_length
init|=
name|p
index|[
literal|2
index|]
operator|-
literal|4
decl_stmt|;
name|int
name|version
init|=
name|p
index|[
literal|3
index|]
decl_stmt|;
comment|/* 		 * Yes, each 'if' here does test p[0] again. 		 * Otherwise, the fall-through handling to catch 		 * unsupported extensions doesn't work. 		 */
switch|switch
condition|(
name|p
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'C'
case|:
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'C'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'E'
condition|)
block|{
if|if
condition|(
name|version
operator|==
literal|1
operator|&&
name|data_length
operator|==
literal|24
condition|)
block|{
comment|/* 					 * CE extension comprises: 					 *   8 byte sector containing extension 					 *   8 byte offset w/in above sector 					 *   8 byte length of continuation 					 */
name|int32_t
name|location
init|=
name|archive_le32dec
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|file
operator|->
name|ce_offset
operator|=
name|archive_le32dec
argument_list|(
name|data
operator|+
literal|8
argument_list|)
expr_stmt|;
name|file
operator|->
name|ce_size
operator|=
name|archive_le32dec
argument_list|(
name|data
operator|+
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|register_CE
argument_list|(
name|a
argument_list|,
name|location
argument_list|,
name|file
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
break|break;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'C'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'L'
condition|)
block|{
if|if
condition|(
name|version
operator|==
literal|1
operator|&&
name|data_length
operator|==
literal|8
condition|)
block|{
name|file
operator|->
name|cl_offset
operator|=
operator|(
name|uint64_t
operator|)
name|iso9660
operator|->
name|logical_block_size
operator|*
operator|(
name|uint64_t
operator|)
name|archive_le32dec
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|seenRockridge
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
literal|'N'
case|:
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'N'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'M'
condition|)
block|{
if|if
condition|(
name|version
operator|==
literal|1
condition|)
block|{
name|parse_rockridge_NM1
argument_list|(
name|file
argument_list|,
name|data
argument_list|,
name|data_length
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|seenRockridge
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
literal|'P'
case|:
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'P'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'D'
condition|)
block|{
comment|/* 				 * PD extension is padding; 				 * contents are always ignored. 				 */
break|break;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'P'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'L'
condition|)
block|{
comment|/* 				 * PL extension won't appear; 				 * contents are always ignored. 				 */
break|break;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'P'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'N'
condition|)
block|{
if|if
condition|(
name|version
operator|==
literal|1
operator|&&
name|data_length
operator|==
literal|16
condition|)
block|{
name|file
operator|->
name|rdev
operator|=
name|toi
argument_list|(
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|file
operator|->
name|rdev
operator|<<=
literal|32
expr_stmt|;
name|file
operator|->
name|rdev
operator||=
name|toi
argument_list|(
name|data
operator|+
literal|8
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|seenRockridge
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'P'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'X'
condition|)
block|{
comment|/* 				 * PX extension comprises: 				 *   8 bytes for mode, 				 *   8 bytes for nlinks, 				 *   8 bytes for uid, 				 *   8 bytes for gid, 				 *   8 bytes for inode. 				 */
if|if
condition|(
name|version
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|data_length
operator|>=
literal|8
condition|)
name|file
operator|->
name|mode
operator|=
name|toi
argument_list|(
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_length
operator|>=
literal|16
condition|)
name|file
operator|->
name|nlinks
operator|=
name|toi
argument_list|(
name|data
operator|+
literal|8
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_length
operator|>=
literal|24
condition|)
name|file
operator|->
name|uid
operator|=
name|toi
argument_list|(
name|data
operator|+
literal|16
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_length
operator|>=
literal|32
condition|)
name|file
operator|->
name|gid
operator|=
name|toi
argument_list|(
name|data
operator|+
literal|24
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_length
operator|>=
literal|40
condition|)
name|file
operator|->
name|number
operator|=
name|toi
argument_list|(
name|data
operator|+
literal|32
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|seenRockridge
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
literal|'R'
case|:
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'R'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'E'
operator|&&
name|version
operator|==
literal|1
condition|)
block|{
name|file
operator|->
name|re
operator|=
literal|1
expr_stmt|;
name|iso9660
operator|->
name|seenRockridge
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'R'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'R'
operator|&&
name|version
operator|==
literal|1
condition|)
block|{
comment|/* 				 * RR extension comprises: 				 *    one byte flag value 				 * This extension is obsolete, 				 * so contents are always ignored. 				 */
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
literal|'S'
case|:
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'S'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'L'
condition|)
block|{
if|if
condition|(
name|version
operator|==
literal|1
condition|)
block|{
name|parse_rockridge_SL1
argument_list|(
name|file
argument_list|,
name|data
argument_list|,
name|data_length
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|seenRockridge
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'S'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'T'
operator|&&
name|data_length
operator|==
literal|0
operator|&&
name|version
operator|==
literal|1
condition|)
block|{
comment|/* 				 * ST extension marks end of this 				 * block of SUSP entries. 				 * 				 * It allows SUSP to coexist with 				 * non-SUSP uses of the System 				 * Use Area by placing non-SUSP data 				 * after SUSP data. 				 */
name|iso9660
operator|->
name|seenSUSP
operator|=
literal|0
expr_stmt|;
name|iso9660
operator|->
name|seenRockridge
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
case|case
literal|'T'
case|:
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'T'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'F'
condition|)
block|{
if|if
condition|(
name|version
operator|==
literal|1
condition|)
block|{
name|parse_rockridge_TF1
argument_list|(
name|file
argument_list|,
name|data
argument_list|,
name|data_length
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|seenRockridge
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
literal|'Z'
case|:
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'Z'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'F'
condition|)
block|{
if|if
condition|(
name|version
operator|==
literal|1
condition|)
name|parse_rockridge_ZF1
argument_list|(
name|file
argument_list|,
name|data
argument_list|,
name|data_length
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
default|default:
comment|/* The FALLTHROUGHs above leave us here for 			 * any unsupported extension. */
break|break;
block|}
name|p
operator|+=
name|p
index|[
literal|2
index|]
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|register_CE
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|int32_t
name|location
parameter_list|,
name|struct
name|file_info
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
decl_stmt|;
name|struct
name|read_ce_queue
modifier|*
name|heap
decl_stmt|;
name|struct
name|read_ce_req
modifier|*
name|p
decl_stmt|;
name|uint64_t
name|offset
decl_stmt|,
name|parent_offset
decl_stmt|;
name|int
name|hole
decl_stmt|,
name|parent
decl_stmt|;
name|iso9660
operator|=
operator|(
expr|struct
name|iso9660
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
name|offset
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|location
operator|)
operator|*
operator|(
name|uint64_t
operator|)
name|iso9660
operator|->
name|logical_block_size
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|file
operator|->
name|mode
operator|&
name|AE_IFMT
operator|)
operator|==
name|AE_IFREG
operator|&&
name|offset
operator|>=
name|file
operator|->
name|offset
operator|)
operator|||
name|offset
operator|<
name|iso9660
operator|->
name|current_position
operator|||
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|file
operator|->
name|ce_offset
operator|)
operator|+
name|file
operator|->
name|ce_size
operator|)
operator|>
operator|(
name|uint64_t
operator|)
name|iso9660
operator|->
name|logical_block_size
operator|||
name|offset
operator|+
name|file
operator|->
name|ce_offset
operator|+
name|file
operator|->
name|ce_size
operator|>
name|iso9660
operator|->
name|volume_size
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Invalid parameter in SUSP \"CE\" extension"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Expand our CE list as necessary. */
name|heap
operator|=
operator|&
operator|(
name|iso9660
operator|->
name|read_ce_req
operator|)
expr_stmt|;
if|if
condition|(
name|heap
operator|->
name|cnt
operator|>=
name|heap
operator|->
name|allocated
condition|)
block|{
name|int
name|new_size
decl_stmt|;
if|if
condition|(
name|heap
operator|->
name|allocated
operator|<
literal|16
condition|)
name|new_size
operator|=
literal|16
expr_stmt|;
else|else
name|new_size
operator|=
name|heap
operator|->
name|allocated
operator|*
literal|2
expr_stmt|;
comment|/* Overflow might keep us from growing the list. */
if|if
condition|(
name|new_size
operator|<=
name|heap
operator|->
name|allocated
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|p
operator|=
name|calloc
argument_list|(
name|new_size
argument_list|,
sizeof|sizeof
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|heap
operator|->
name|reqs
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|p
argument_list|,
name|heap
operator|->
name|reqs
argument_list|,
name|heap
operator|->
name|cnt
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|heap
operator|->
name|reqs
argument_list|)
expr_stmt|;
block|}
name|heap
operator|->
name|reqs
operator|=
name|p
expr_stmt|;
name|heap
operator|->
name|allocated
operator|=
name|new_size
expr_stmt|;
block|}
comment|/* 	 * Start with hole at end, walk it up tree to find insertion point. 	 */
name|hole
operator|=
name|heap
operator|->
name|cnt
operator|++
expr_stmt|;
while|while
condition|(
name|hole
operator|>
literal|0
condition|)
block|{
name|parent
operator|=
operator|(
name|hole
operator|-
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|parent_offset
operator|=
name|heap
operator|->
name|reqs
index|[
name|parent
index|]
operator|.
name|offset
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|parent_offset
condition|)
block|{
name|heap
operator|->
name|reqs
index|[
name|hole
index|]
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|heap
operator|->
name|reqs
index|[
name|hole
index|]
operator|.
name|file
operator|=
name|file
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
comment|/* Move parent into hole<==> move hole up tree. */
name|heap
operator|->
name|reqs
index|[
name|hole
index|]
operator|=
name|heap
operator|->
name|reqs
index|[
name|parent
index|]
expr_stmt|;
name|hole
operator|=
name|parent
expr_stmt|;
block|}
name|heap
operator|->
name|reqs
index|[
literal|0
index|]
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|heap
operator|->
name|reqs
index|[
literal|0
index|]
operator|.
name|file
operator|=
name|file
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|next_CE
parameter_list|(
name|struct
name|read_ce_queue
modifier|*
name|heap
parameter_list|)
block|{
name|uint64_t
name|a_offset
decl_stmt|,
name|b_offset
decl_stmt|,
name|c_offset
decl_stmt|;
name|int
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|;
name|struct
name|read_ce_req
name|tmp
decl_stmt|;
if|if
condition|(
name|heap
operator|->
name|cnt
operator|<
literal|1
condition|)
return|return;
comment|/* 	 * Move the last item in the heap to the root of the tree 	 */
name|heap
operator|->
name|reqs
index|[
literal|0
index|]
operator|=
name|heap
operator|->
name|reqs
index|[
operator|--
operator|(
name|heap
operator|->
name|cnt
operator|)
index|]
expr_stmt|;
comment|/* 	 * Rebalance the heap. 	 */
name|a
operator|=
literal|0
expr_stmt|;
comment|/* Starting element and its offset */
name|a_offset
operator|=
name|heap
operator|->
name|reqs
index|[
name|a
index|]
operator|.
name|offset
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|b
operator|=
name|a
operator|+
name|a
operator|+
literal|1
expr_stmt|;
comment|/* First child */
if|if
condition|(
name|b
operator|>=
name|heap
operator|->
name|cnt
condition|)
return|return;
name|b_offset
operator|=
name|heap
operator|->
name|reqs
index|[
name|b
index|]
operator|.
name|offset
expr_stmt|;
name|c
operator|=
name|b
operator|+
literal|1
expr_stmt|;
comment|/* Use second child if it is smaller. */
if|if
condition|(
name|c
operator|<
name|heap
operator|->
name|cnt
condition|)
block|{
name|c_offset
operator|=
name|heap
operator|->
name|reqs
index|[
name|c
index|]
operator|.
name|offset
expr_stmt|;
if|if
condition|(
name|c_offset
operator|<
name|b_offset
condition|)
block|{
name|b
operator|=
name|c
expr_stmt|;
name|b_offset
operator|=
name|c_offset
expr_stmt|;
block|}
block|}
if|if
condition|(
name|a_offset
operator|<=
name|b_offset
condition|)
return|return;
name|tmp
operator|=
name|heap
operator|->
name|reqs
index|[
name|a
index|]
expr_stmt|;
name|heap
operator|->
name|reqs
index|[
name|a
index|]
operator|=
name|heap
operator|->
name|reqs
index|[
name|b
index|]
expr_stmt|;
name|heap
operator|->
name|reqs
index|[
name|b
index|]
operator|=
name|tmp
expr_stmt|;
name|a
operator|=
name|b
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|read_CE
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|)
block|{
name|struct
name|read_ce_queue
modifier|*
name|heap
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|b
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|struct
name|file_info
modifier|*
name|file
decl_stmt|;
name|size_t
name|step
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* Read data which RRIP "CE" extension points. */
name|heap
operator|=
operator|&
operator|(
name|iso9660
operator|->
name|read_ce_req
operator|)
expr_stmt|;
name|step
operator|=
name|iso9660
operator|->
name|logical_block_size
expr_stmt|;
while|while
condition|(
name|heap
operator|->
name|cnt
operator|&&
name|heap
operator|->
name|reqs
index|[
literal|0
index|]
operator|.
name|offset
operator|==
name|iso9660
operator|->
name|current_position
condition|)
block|{
name|b
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|step
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Failed to read full block when scanning "
literal|"ISO9660 directory list"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
do|do
block|{
name|file
operator|=
name|heap
operator|->
name|reqs
index|[
literal|0
index|]
operator|.
name|file
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|ce_offset
operator|+
name|file
operator|->
name|ce_size
operator|>
name|step
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Malformed CE information"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|p
operator|=
name|b
operator|+
name|file
operator|->
name|ce_offset
expr_stmt|;
name|end
operator|=
name|p
operator|+
name|file
operator|->
name|ce_size
expr_stmt|;
name|next_CE
argument_list|(
name|heap
argument_list|)
expr_stmt|;
name|r
operator|=
name|parse_rockridge
argument_list|(
name|a
argument_list|,
name|file
argument_list|,
name|p
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
do|while
condition|(
name|heap
operator|->
name|cnt
operator|&&
name|heap
operator|->
name|reqs
index|[
literal|0
index|]
operator|.
name|offset
operator|==
name|iso9660
operator|->
name|current_position
condition|)
do|;
comment|/* NOTE: Do not move this consume's code to fron of 		 * do-while loop. Registration of nested CE extension 		 * might cause error because of current position. */
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|current_position
operator|+=
name|step
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_rockridge_NM1
parameter_list|(
name|struct
name|file_info
modifier|*
name|file
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|data_length
parameter_list|)
block|{
if|if
condition|(
operator|!
name|file
operator|->
name|name_continues
condition|)
name|archive_string_empty
argument_list|(
operator|&
name|file
operator|->
name|name
argument_list|)
expr_stmt|;
name|file
operator|->
name|name_continues
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|data_length
operator|<
literal|1
condition|)
return|return;
comment|/* 	 * NM version 1 extension comprises: 	 *   1 byte flag, value is one of: 	 *     = 0: remainder is name 	 *     = 1: remainder is name, next NM entry continues name 	 *     = 2: "." 	 *     = 4: ".." 	 *     = 32: Implementation specific 	 *     All other values are reserved. 	 */
switch|switch
condition|(
name|data
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|data_length
operator|<
literal|2
condition|)
return|return;
name|archive_strncat
argument_list|(
operator|&
name|file
operator|->
name|name
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|data
operator|+
literal|1
argument_list|,
name|data_length
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|data_length
operator|<
literal|2
condition|)
return|return;
name|archive_strncat
argument_list|(
operator|&
name|file
operator|->
name|name
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|data
operator|+
literal|1
argument_list|,
name|data_length
operator|-
literal|1
argument_list|)
expr_stmt|;
name|file
operator|->
name|name_continues
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|archive_strcat
argument_list|(
operator|&
name|file
operator|->
name|name
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|archive_strcat
argument_list|(
operator|&
name|file
operator|->
name|name
argument_list|,
literal|".."
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|parse_rockridge_TF1
parameter_list|(
name|struct
name|file_info
modifier|*
name|file
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|data_length
parameter_list|)
block|{
name|char
name|flag
decl_stmt|;
comment|/* 	 * TF extension comprises: 	 *   one byte flag 	 *   create time (optional) 	 *   modify time (optional) 	 *   access time (optional) 	 *   attribute time (optional) 	 *  Time format and presence of fields 	 *  is controlled by flag bits. 	 */
if|if
condition|(
name|data_length
operator|<
literal|1
condition|)
return|return;
name|flag
operator|=
name|data
index|[
literal|0
index|]
expr_stmt|;
operator|++
name|data
expr_stmt|;
operator|--
name|data_length
expr_stmt|;
if|if
condition|(
name|flag
operator|&
literal|0x80
condition|)
block|{
comment|/* Use 17-byte time format. */
if|if
condition|(
operator|(
name|flag
operator|&
literal|1
operator|)
operator|&&
name|data_length
operator|>=
literal|17
condition|)
block|{
comment|/* Create time. */
name|file
operator|->
name|birthtime_is_set
operator|=
literal|1
expr_stmt|;
name|file
operator|->
name|birthtime
operator|=
name|isodate17
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|17
expr_stmt|;
name|data_length
operator|-=
literal|17
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flag
operator|&
literal|2
operator|)
operator|&&
name|data_length
operator|>=
literal|17
condition|)
block|{
comment|/* Modify time. */
name|file
operator|->
name|mtime
operator|=
name|isodate17
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|17
expr_stmt|;
name|data_length
operator|-=
literal|17
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flag
operator|&
literal|4
operator|)
operator|&&
name|data_length
operator|>=
literal|17
condition|)
block|{
comment|/* Access time. */
name|file
operator|->
name|atime
operator|=
name|isodate17
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|17
expr_stmt|;
name|data_length
operator|-=
literal|17
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flag
operator|&
literal|8
operator|)
operator|&&
name|data_length
operator|>=
literal|17
condition|)
block|{
comment|/* Attribute change time. */
name|file
operator|->
name|ctime
operator|=
name|isodate17
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Use 7-byte time format. */
if|if
condition|(
operator|(
name|flag
operator|&
literal|1
operator|)
operator|&&
name|data_length
operator|>=
literal|7
condition|)
block|{
comment|/* Create time. */
name|file
operator|->
name|birthtime_is_set
operator|=
literal|1
expr_stmt|;
name|file
operator|->
name|birthtime
operator|=
name|isodate7
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|7
expr_stmt|;
name|data_length
operator|-=
literal|7
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flag
operator|&
literal|2
operator|)
operator|&&
name|data_length
operator|>=
literal|7
condition|)
block|{
comment|/* Modify time. */
name|file
operator|->
name|mtime
operator|=
name|isodate7
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|7
expr_stmt|;
name|data_length
operator|-=
literal|7
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flag
operator|&
literal|4
operator|)
operator|&&
name|data_length
operator|>=
literal|7
condition|)
block|{
comment|/* Access time. */
name|file
operator|->
name|atime
operator|=
name|isodate7
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|7
expr_stmt|;
name|data_length
operator|-=
literal|7
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flag
operator|&
literal|8
operator|)
operator|&&
name|data_length
operator|>=
literal|7
condition|)
block|{
comment|/* Attribute change time. */
name|file
operator|->
name|ctime
operator|=
name|isodate7
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|parse_rockridge_SL1
parameter_list|(
name|struct
name|file_info
modifier|*
name|file
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|data_length
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|separator
init|=
literal|""
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|->
name|symlink_continues
operator|||
name|file
operator|->
name|symlink
operator|.
name|length
operator|<
literal|1
condition|)
name|archive_string_empty
argument_list|(
operator|&
name|file
operator|->
name|symlink
argument_list|)
expr_stmt|;
name|file
operator|->
name|symlink_continues
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Defined flag values: 	 *  0: This is the last SL record for this symbolic link 	 *  1: this symbolic link field continues in next SL entry 	 *  All other values are reserved. 	 */
if|if
condition|(
name|data_length
operator|<
literal|1
condition|)
return|return;
switch|switch
condition|(
operator|*
name|data
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
name|file
operator|->
name|symlink_continues
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return;
block|}
operator|++
name|data
expr_stmt|;
comment|/* Skip flag byte. */
operator|--
name|data_length
expr_stmt|;
comment|/* 	 * SL extension body stores "components". 	 * Basically, this is a complicated way of storing 	 * a POSIX path.  It also interferes with using 	 * symlinks for storing non-path data.<sigh> 	 * 	 * Each component is 2 bytes (flag and length) 	 * possibly followed by name data. 	 */
while|while
condition|(
name|data_length
operator|>=
literal|2
condition|)
block|{
name|unsigned
name|char
name|flag
init|=
operator|*
name|data
operator|++
decl_stmt|;
name|unsigned
name|char
name|nlen
init|=
operator|*
name|data
operator|++
decl_stmt|;
name|data_length
operator|-=
literal|2
expr_stmt|;
name|archive_strcat
argument_list|(
operator|&
name|file
operator|->
name|symlink
argument_list|,
name|separator
argument_list|)
expr_stmt|;
name|separator
operator|=
literal|"/"
expr_stmt|;
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
literal|0
case|:
comment|/* Usual case, this is text. */
if|if
condition|(
name|data_length
operator|<
name|nlen
condition|)
return|return;
name|archive_strncat
argument_list|(
operator|&
name|file
operator|->
name|symlink
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|data
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x01
case|:
comment|/* Text continues in next component. */
if|if
condition|(
name|data_length
operator|<
name|nlen
condition|)
return|return;
name|archive_strncat
argument_list|(
operator|&
name|file
operator|->
name|symlink
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|data
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|separator
operator|=
literal|""
expr_stmt|;
break|break;
case|case
literal|0x02
case|:
comment|/* Current dir. */
name|archive_strcat
argument_list|(
operator|&
name|file
operator|->
name|symlink
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x04
case|:
comment|/* Parent dir. */
name|archive_strcat
argument_list|(
operator|&
name|file
operator|->
name|symlink
argument_list|,
literal|".."
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x08
case|:
comment|/* Root of filesystem. */
name|archive_strcat
argument_list|(
operator|&
name|file
operator|->
name|symlink
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|separator
operator|=
literal|""
expr_stmt|;
break|break;
case|case
literal|0x10
case|:
comment|/* Undefined (historically "volume root" */
name|archive_string_empty
argument_list|(
operator|&
name|file
operator|->
name|symlink
argument_list|)
expr_stmt|;
name|archive_strcat
argument_list|(
operator|&
name|file
operator|->
name|symlink
argument_list|,
literal|"ROOT"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x20
case|:
comment|/* Undefined (historically "hostname") */
name|archive_strcat
argument_list|(
operator|&
name|file
operator|->
name|symlink
argument_list|,
literal|"hostname"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* TODO: issue a warning ? */
return|return;
block|}
name|data
operator|+=
name|nlen
expr_stmt|;
name|data_length
operator|-=
name|nlen
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|parse_rockridge_ZF1
parameter_list|(
name|struct
name|file_info
modifier|*
name|file
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|data_length
parameter_list|)
block|{
if|if
condition|(
name|data
index|[
literal|0
index|]
operator|==
literal|0x70
operator|&&
name|data
index|[
literal|1
index|]
operator|==
literal|0x7a
operator|&&
name|data_length
operator|==
literal|12
condition|)
block|{
comment|/* paged zlib */
name|file
operator|->
name|pz
operator|=
literal|1
expr_stmt|;
name|file
operator|->
name|pz_log2_bs
operator|=
name|data
index|[
literal|3
index|]
expr_stmt|;
name|file
operator|->
name|pz_uncompressed_size
operator|=
name|archive_le32dec
argument_list|(
operator|&
name|data
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|register_file
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
name|struct
name|file_info
modifier|*
name|file
parameter_list|)
block|{
name|file
operator|->
name|use_next
operator|=
name|iso9660
operator|->
name|use_files
expr_stmt|;
name|iso9660
operator|->
name|use_files
operator|=
name|file
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|release_files
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|)
block|{
name|struct
name|content
modifier|*
name|con
decl_stmt|,
modifier|*
name|connext
decl_stmt|;
name|struct
name|file_info
modifier|*
name|file
decl_stmt|;
name|file
operator|=
name|iso9660
operator|->
name|use_files
expr_stmt|;
while|while
condition|(
name|file
operator|!=
name|NULL
condition|)
block|{
name|struct
name|file_info
modifier|*
name|next
init|=
name|file
operator|->
name|use_next
decl_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|file
operator|->
name|name
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|file
operator|->
name|symlink
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file
operator|->
name|utf16be_name
argument_list|)
expr_stmt|;
name|con
operator|=
name|file
operator|->
name|contents
operator|.
name|first
expr_stmt|;
while|while
condition|(
name|con
operator|!=
name|NULL
condition|)
block|{
name|connext
operator|=
name|con
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|con
argument_list|)
expr_stmt|;
name|con
operator|=
name|connext
expr_stmt|;
block|}
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|file
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|next_entry_seek
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
name|struct
name|file_info
modifier|*
modifier|*
name|pfile
parameter_list|)
block|{
name|struct
name|file_info
modifier|*
name|file
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|next_cache_entry
argument_list|(
name|a
argument_list|,
name|iso9660
argument_list|,
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|file
operator|=
operator|*
name|pfile
expr_stmt|;
comment|/* Don't waste time seeking for zero-length bodies. */
if|if
condition|(
name|file
operator|->
name|size
operator|==
literal|0
condition|)
name|file
operator|->
name|offset
operator|=
name|iso9660
operator|->
name|current_position
expr_stmt|;
comment|/* flush any remaining bytes from the last round to ensure 	 * we're positioned */
if|if
condition|(
name|iso9660
operator|->
name|entry_bytes_unconsumed
condition|)
block|{
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|iso9660
operator|->
name|entry_bytes_unconsumed
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|entry_bytes_unconsumed
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Seek forward to the start of the entry. */
if|if
condition|(
name|iso9660
operator|->
name|current_position
operator|<
name|file
operator|->
name|offset
condition|)
block|{
name|int64_t
name|step
decl_stmt|;
name|step
operator|=
name|file
operator|->
name|offset
operator|-
name|iso9660
operator|->
name|current_position
expr_stmt|;
name|step
operator|=
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|step
argument_list|)
expr_stmt|;
if|if
condition|(
name|step
operator|<
literal|0
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|step
operator|)
return|;
name|iso9660
operator|->
name|current_position
operator|=
name|file
operator|->
name|offset
expr_stmt|;
block|}
comment|/* We found body of file; handle it now. */
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|next_cache_entry
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
name|struct
name|file_info
modifier|*
modifier|*
name|pfile
parameter_list|)
block|{
name|struct
name|file_info
modifier|*
name|file
decl_stmt|;
struct|struct
block|{
name|struct
name|file_info
modifier|*
name|first
decl_stmt|;
name|struct
name|file_info
modifier|*
modifier|*
name|last
decl_stmt|;
block|}
name|empty_files
struct|;
name|int64_t
name|number
decl_stmt|;
name|int
name|count
decl_stmt|;
name|file
operator|=
name|cache_get_entry
argument_list|(
name|iso9660
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|!=
name|NULL
condition|)
block|{
operator|*
name|pfile
operator|=
name|file
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|file_info
modifier|*
name|re
decl_stmt|,
modifier|*
name|d
decl_stmt|;
operator|*
name|pfile
operator|=
name|file
operator|=
name|next_entry
argument_list|(
name|iso9660
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * If directory entries all which are descendant of 			 * rr_moved are stil remaning, expose their.  			 */
if|if
condition|(
name|iso9660
operator|->
name|re_files
operator|.
name|first
operator|!=
name|NULL
operator|&&
name|iso9660
operator|->
name|rr_moved
operator|!=
name|NULL
operator|&&
name|iso9660
operator|->
name|rr_moved
operator|->
name|rr_moved_has_re_only
condition|)
comment|/* Expose "rr_moved" entry. */
name|cache_add_entry
argument_list|(
name|iso9660
argument_list|,
name|iso9660
operator|->
name|rr_moved
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|re
operator|=
name|re_get_entry
argument_list|(
name|iso9660
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Expose its descendant dirs. */
while|while
condition|(
operator|(
name|d
operator|=
name|rede_get_entry
argument_list|(
name|re
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cache_add_entry
argument_list|(
name|iso9660
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iso9660
operator|->
name|cache_files
operator|.
name|first
operator|!=
name|NULL
condition|)
return|return
operator|(
name|next_cache_entry
argument_list|(
name|a
argument_list|,
name|iso9660
argument_list|,
name|pfile
argument_list|)
operator|)
return|;
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
block|}
if|if
condition|(
name|file
operator|->
name|cl_offset
condition|)
block|{
name|struct
name|file_info
modifier|*
name|first_re
init|=
name|NULL
decl_stmt|;
name|int
name|nexted_re
init|=
literal|0
decl_stmt|;
comment|/* 			 * Find "RE" dir for the current file, which 			 * has "CL" flag. 			 */
while|while
condition|(
operator|(
name|re
operator|=
name|re_get_entry
argument_list|(
name|iso9660
argument_list|)
operator|)
operator|!=
name|first_re
condition|)
block|{
if|if
condition|(
name|first_re
operator|==
name|NULL
condition|)
name|first_re
operator|=
name|re
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|offset
operator|==
name|file
operator|->
name|cl_offset
condition|)
block|{
name|re
operator|->
name|parent
operator|->
name|subdirs
operator|--
expr_stmt|;
name|re
operator|->
name|parent
operator|=
name|file
operator|->
name|parent
expr_stmt|;
name|re
operator|->
name|re
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|parent
operator|->
name|re_descendant
condition|)
block|{
name|nexted_re
operator|=
literal|1
expr_stmt|;
name|re
operator|->
name|re_descendant
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rede_add_entry
argument_list|(
name|re
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|fatal_rr
goto|;
comment|/* Move a list of descendants 						 * to a new ancestor. */
while|while
condition|(
operator|(
name|d
operator|=
name|rede_get_entry
argument_list|(
name|re
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|rede_add_entry
argument_list|(
name|d
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|fatal_rr
goto|;
break|break;
block|}
comment|/* Replace the current file 					 * with "RE" dir */
operator|*
name|pfile
operator|=
name|file
operator|=
name|re
expr_stmt|;
comment|/* Expose its descendant */
while|while
condition|(
operator|(
name|d
operator|=
name|rede_get_entry
argument_list|(
name|file
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cache_add_entry
argument_list|(
name|iso9660
argument_list|,
name|d
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|re_add_entry
argument_list|(
name|iso9660
argument_list|,
name|re
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nexted_re
condition|)
block|{
comment|/* 				 * Do not expose this at this time 				 * because we have not gotten its full-path 				 * name yet. 				 */
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|file
operator|->
name|mode
operator|&
name|AE_IFMT
operator|)
operator|==
name|AE_IFDIR
condition|)
block|{
name|int
name|r
decl_stmt|;
comment|/* Read file entries in this dir. */
name|r
operator|=
name|read_children
argument_list|(
name|a
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
comment|/* 			 * Handle a special dir of Rockridge extensions, 			 * "rr_moved". 			 */
if|if
condition|(
name|file
operator|->
name|rr_moved
condition|)
block|{
comment|/* 				 * If this has only the subdirectories which 				 * have "RE" flags, do not expose at this time. 				 */
if|if
condition|(
name|file
operator|->
name|rr_moved_has_re_only
condition|)
continue|continue;
comment|/* Otherwise expose "rr_moved" entry. */
block|}
elseif|else
if|if
condition|(
name|file
operator|->
name|re
condition|)
block|{
comment|/* 				 * Do not expose this at this time 				 * because we have not gotten its full-path 				 * name yet. 				 */
name|re_add_entry
argument_list|(
name|iso9660
argument_list|,
name|file
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|file
operator|->
name|re_descendant
condition|)
block|{
comment|/* 				 * If the top level "RE" entry of this entry 				 * is not exposed, we, accordingly, should not 				 * expose this entry at this time because 				 * we cannot make its proper full-path name. 				 */
if|if
condition|(
name|rede_add_entry
argument_list|(
name|file
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Otherwise we can expose this entry because 				 * it seems its top level "RE" has already been 				 * exposed. */
block|}
block|}
break|break;
block|}
if|if
condition|(
operator|(
name|file
operator|->
name|mode
operator|&
name|AE_IFMT
operator|)
operator|!=
name|AE_IFREG
operator|||
name|file
operator|->
name|number
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
name|count
operator|=
literal|0
expr_stmt|;
name|number
operator|=
name|file
operator|->
name|number
expr_stmt|;
name|iso9660
operator|->
name|cache_files
operator|.
name|first
operator|=
name|NULL
expr_stmt|;
name|iso9660
operator|->
name|cache_files
operator|.
name|last
operator|=
operator|&
operator|(
name|iso9660
operator|->
name|cache_files
operator|.
name|first
operator|)
expr_stmt|;
name|empty_files
operator|.
name|first
operator|=
name|NULL
expr_stmt|;
name|empty_files
operator|.
name|last
operator|=
operator|&
name|empty_files
operator|.
name|first
expr_stmt|;
comment|/* Collect files which has the same file serial number. 	 * Peek pending_files so that file which number is different 	 * is not put bak. */
while|while
condition|(
name|iso9660
operator|->
name|pending_files
operator|.
name|used
operator|>
literal|0
operator|&&
operator|(
name|iso9660
operator|->
name|pending_files
operator|.
name|files
index|[
literal|0
index|]
operator|->
name|number
operator|==
operator|-
literal|1
operator|||
name|iso9660
operator|->
name|pending_files
operator|.
name|files
index|[
literal|0
index|]
operator|->
name|number
operator|==
name|number
operator|)
condition|)
block|{
if|if
condition|(
name|file
operator|->
name|number
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* This file has the same offset 			 * but it's wrong offset which empty files 			 * and symlink files have. 			 * NOTE: This wrong offse was recorded by 			 * old mkisofs utility. If ISO images is 			 * created by latest mkisofs, this does not 			 * happen. 			 */
name|file
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|empty_files
operator|.
name|last
operator|=
name|file
expr_stmt|;
name|empty_files
operator|.
name|last
operator|=
operator|&
operator|(
name|file
operator|->
name|next
operator|)
expr_stmt|;
block|}
else|else
block|{
name|count
operator|++
expr_stmt|;
name|cache_add_entry
argument_list|(
name|iso9660
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|file
operator|=
name|next_entry
argument_list|(
name|iso9660
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
operator|*
name|pfile
operator|=
name|file
expr_stmt|;
return|return
operator|(
operator|(
name|file
operator|==
name|NULL
operator|)
condition|?
name|ARCHIVE_EOF
else|:
name|ARCHIVE_OK
operator|)
return|;
block|}
if|if
condition|(
name|file
operator|->
name|number
operator|==
operator|-
literal|1
condition|)
block|{
name|file
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|empty_files
operator|.
name|last
operator|=
name|file
expr_stmt|;
name|empty_files
operator|.
name|last
operator|=
operator|&
operator|(
name|file
operator|->
name|next
operator|)
expr_stmt|;
block|}
else|else
block|{
name|count
operator|++
expr_stmt|;
name|cache_add_entry
argument_list|(
name|iso9660
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
comment|/* The count is the same as number of hardlink, 		 * so much so that each nlinks of files in cache_file 		 * is overwritten by value of the count. 		 */
for|for
control|(
name|file
operator|=
name|iso9660
operator|->
name|cache_files
operator|.
name|first
init|;
name|file
operator|!=
name|NULL
condition|;
name|file
operator|=
name|file
operator|->
name|next
control|)
name|file
operator|->
name|nlinks
operator|=
name|count
expr_stmt|;
block|}
comment|/* If there are empty files, that files are added 	 * to the tail of the cache_files. */
if|if
condition|(
name|empty_files
operator|.
name|first
operator|!=
name|NULL
condition|)
block|{
operator|*
name|iso9660
operator|->
name|cache_files
operator|.
name|last
operator|=
name|empty_files
operator|.
name|first
expr_stmt|;
name|iso9660
operator|->
name|cache_files
operator|.
name|last
operator|=
name|empty_files
operator|.
name|last
expr_stmt|;
block|}
operator|*
name|pfile
operator|=
name|cache_get_entry
argument_list|(
name|iso9660
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|pfile
operator|==
name|NULL
operator|)
condition|?
name|ARCHIVE_EOF
else|:
name|ARCHIVE_OK
operator|)
return|;
name|fatal_rr
label|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Failed to connect 'CL' pointer to 'RE' rr_moved pointer of"
literal|"Rockridge extensions"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|re_add_entry
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
name|struct
name|file_info
modifier|*
name|file
parameter_list|)
block|{
name|file
operator|->
name|re_next
operator|=
name|NULL
expr_stmt|;
operator|*
name|iso9660
operator|->
name|re_files
operator|.
name|last
operator|=
name|file
expr_stmt|;
name|iso9660
operator|->
name|re_files
operator|.
name|last
operator|=
operator|&
operator|(
name|file
operator|->
name|re_next
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|file_info
modifier|*
name|re_get_entry
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|)
block|{
name|struct
name|file_info
modifier|*
name|file
decl_stmt|;
if|if
condition|(
operator|(
name|file
operator|=
name|iso9660
operator|->
name|re_files
operator|.
name|first
operator|)
operator|!=
name|NULL
condition|)
block|{
name|iso9660
operator|->
name|re_files
operator|.
name|first
operator|=
name|file
operator|->
name|re_next
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|re_files
operator|.
name|first
operator|==
name|NULL
condition|)
name|iso9660
operator|->
name|re_files
operator|.
name|last
operator|=
operator|&
operator|(
name|iso9660
operator|->
name|re_files
operator|.
name|first
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|file
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|rede_add_entry
parameter_list|(
name|struct
name|file_info
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|file_info
modifier|*
name|re
decl_stmt|;
comment|/* 	 * Find "RE" entry. 	 */
name|re
operator|=
name|file
operator|->
name|parent
expr_stmt|;
while|while
condition|(
name|re
operator|!=
name|NULL
operator|&&
operator|!
name|re
operator|->
name|re
condition|)
name|re
operator|=
name|re
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|re
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|file
operator|->
name|re_next
operator|=
name|NULL
expr_stmt|;
operator|*
name|re
operator|->
name|rede_files
operator|.
name|last
operator|=
name|file
expr_stmt|;
name|re
operator|->
name|rede_files
operator|.
name|last
operator|=
operator|&
operator|(
name|file
operator|->
name|re_next
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|file_info
modifier|*
name|rede_get_entry
parameter_list|(
name|struct
name|file_info
modifier|*
name|re
parameter_list|)
block|{
name|struct
name|file_info
modifier|*
name|file
decl_stmt|;
if|if
condition|(
operator|(
name|file
operator|=
name|re
operator|->
name|rede_files
operator|.
name|first
operator|)
operator|!=
name|NULL
condition|)
block|{
name|re
operator|->
name|rede_files
operator|.
name|first
operator|=
name|file
operator|->
name|re_next
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|rede_files
operator|.
name|first
operator|==
name|NULL
condition|)
name|re
operator|->
name|rede_files
operator|.
name|last
operator|=
operator|&
operator|(
name|re
operator|->
name|rede_files
operator|.
name|first
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|file
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|cache_add_entry
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
name|struct
name|file_info
modifier|*
name|file
parameter_list|)
block|{
name|file
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|iso9660
operator|->
name|cache_files
operator|.
name|last
operator|=
name|file
expr_stmt|;
name|iso9660
operator|->
name|cache_files
operator|.
name|last
operator|=
operator|&
operator|(
name|file
operator|->
name|next
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|file_info
modifier|*
name|cache_get_entry
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|)
block|{
name|struct
name|file_info
modifier|*
name|file
decl_stmt|;
if|if
condition|(
operator|(
name|file
operator|=
name|iso9660
operator|->
name|cache_files
operator|.
name|first
operator|)
operator|!=
name|NULL
condition|)
block|{
name|iso9660
operator|->
name|cache_files
operator|.
name|first
operator|=
name|file
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|cache_files
operator|.
name|first
operator|==
name|NULL
condition|)
name|iso9660
operator|->
name|cache_files
operator|.
name|last
operator|=
operator|&
operator|(
name|iso9660
operator|->
name|cache_files
operator|.
name|first
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|file
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|heap_add_entry
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|heap_queue
modifier|*
name|heap
parameter_list|,
name|struct
name|file_info
modifier|*
name|file
parameter_list|,
name|uint64_t
name|key
parameter_list|)
block|{
name|uint64_t
name|file_key
decl_stmt|,
name|parent_key
decl_stmt|;
name|int
name|hole
decl_stmt|,
name|parent
decl_stmt|;
comment|/* Expand our pending files list as necessary. */
if|if
condition|(
name|heap
operator|->
name|used
operator|>=
name|heap
operator|->
name|allocated
condition|)
block|{
name|struct
name|file_info
modifier|*
modifier|*
name|new_pending_files
decl_stmt|;
name|int
name|new_size
init|=
name|heap
operator|->
name|allocated
operator|*
literal|2
decl_stmt|;
if|if
condition|(
name|heap
operator|->
name|allocated
operator|<
literal|1024
condition|)
name|new_size
operator|=
literal|1024
expr_stmt|;
comment|/* Overflow might keep us from growing the list. */
if|if
condition|(
name|new_size
operator|<=
name|heap
operator|->
name|allocated
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|new_pending_files
operator|=
operator|(
expr|struct
name|file_info
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|new_size
operator|*
sizeof|sizeof
argument_list|(
name|new_pending_files
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_pending_files
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|new_pending_files
argument_list|,
name|heap
operator|->
name|files
argument_list|,
name|heap
operator|->
name|allocated
operator|*
sizeof|sizeof
argument_list|(
name|new_pending_files
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|heap
operator|->
name|files
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|heap
operator|->
name|files
argument_list|)
expr_stmt|;
name|heap
operator|->
name|files
operator|=
name|new_pending_files
expr_stmt|;
name|heap
operator|->
name|allocated
operator|=
name|new_size
expr_stmt|;
block|}
name|file_key
operator|=
name|file
operator|->
name|key
operator|=
name|key
expr_stmt|;
comment|/* 	 * Start with hole at end, walk it up tree to find insertion point. 	 */
name|hole
operator|=
name|heap
operator|->
name|used
operator|++
expr_stmt|;
while|while
condition|(
name|hole
operator|>
literal|0
condition|)
block|{
name|parent
operator|=
operator|(
name|hole
operator|-
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|parent_key
operator|=
name|heap
operator|->
name|files
index|[
name|parent
index|]
operator|->
name|key
expr_stmt|;
if|if
condition|(
name|file_key
operator|>=
name|parent_key
condition|)
block|{
name|heap
operator|->
name|files
index|[
name|hole
index|]
operator|=
name|file
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
comment|/* Move parent into hole<==> move hole up tree. */
name|heap
operator|->
name|files
index|[
name|hole
index|]
operator|=
name|heap
operator|->
name|files
index|[
name|parent
index|]
expr_stmt|;
name|hole
operator|=
name|parent
expr_stmt|;
block|}
name|heap
operator|->
name|files
index|[
literal|0
index|]
operator|=
name|file
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|file_info
modifier|*
name|heap_get_entry
parameter_list|(
name|struct
name|heap_queue
modifier|*
name|heap
parameter_list|)
block|{
name|uint64_t
name|a_key
decl_stmt|,
name|b_key
decl_stmt|,
name|c_key
decl_stmt|;
name|int
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|;
name|struct
name|file_info
modifier|*
name|r
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|heap
operator|->
name|used
operator|<
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * The first file in the list is the earliest; we'll return this. 	 */
name|r
operator|=
name|heap
operator|->
name|files
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * Move the last item in the heap to the root of the tree 	 */
name|heap
operator|->
name|files
index|[
literal|0
index|]
operator|=
name|heap
operator|->
name|files
index|[
operator|--
operator|(
name|heap
operator|->
name|used
operator|)
index|]
expr_stmt|;
comment|/* 	 * Rebalance the heap. 	 */
name|a
operator|=
literal|0
expr_stmt|;
comment|/* Starting element and its heap key */
name|a_key
operator|=
name|heap
operator|->
name|files
index|[
name|a
index|]
operator|->
name|key
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|b
operator|=
name|a
operator|+
name|a
operator|+
literal|1
expr_stmt|;
comment|/* First child */
if|if
condition|(
name|b
operator|>=
name|heap
operator|->
name|used
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|b_key
operator|=
name|heap
operator|->
name|files
index|[
name|b
index|]
operator|->
name|key
expr_stmt|;
name|c
operator|=
name|b
operator|+
literal|1
expr_stmt|;
comment|/* Use second child if it is smaller. */
if|if
condition|(
name|c
operator|<
name|heap
operator|->
name|used
condition|)
block|{
name|c_key
operator|=
name|heap
operator|->
name|files
index|[
name|c
index|]
operator|->
name|key
expr_stmt|;
if|if
condition|(
name|c_key
operator|<
name|b_key
condition|)
block|{
name|b
operator|=
name|c
expr_stmt|;
name|b_key
operator|=
name|c_key
expr_stmt|;
block|}
block|}
if|if
condition|(
name|a_key
operator|<=
name|b_key
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|tmp
operator|=
name|heap
operator|->
name|files
index|[
name|a
index|]
expr_stmt|;
name|heap
operator|->
name|files
index|[
name|a
index|]
operator|=
name|heap
operator|->
name|files
index|[
name|b
index|]
expr_stmt|;
name|heap
operator|->
name|files
index|[
name|b
index|]
operator|=
name|tmp
expr_stmt|;
name|a
operator|=
name|b
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|toi
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|,
name|int
name|n
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|v
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|p
decl_stmt|;
if|if
condition|(
name|n
operator|>
literal|1
condition|)
return|return
name|v
index|[
literal|0
index|]
operator|+
literal|256
operator|*
name|toi
argument_list|(
name|v
operator|+
literal|1
argument_list|,
name|n
operator|-
literal|1
argument_list|)
return|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
return|return
name|v
index|[
literal|0
index|]
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|time_t
name|isodate7
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|tm
name|tm
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|memset
argument_list|(
operator|&
name|tm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tm
argument_list|)
argument_list|)
expr_stmt|;
name|tm
operator|.
name|tm_year
operator|=
name|v
index|[
literal|0
index|]
expr_stmt|;
name|tm
operator|.
name|tm_mon
operator|=
name|v
index|[
literal|1
index|]
operator|-
literal|1
expr_stmt|;
name|tm
operator|.
name|tm_mday
operator|=
name|v
index|[
literal|2
index|]
expr_stmt|;
name|tm
operator|.
name|tm_hour
operator|=
name|v
index|[
literal|3
index|]
expr_stmt|;
name|tm
operator|.
name|tm_min
operator|=
name|v
index|[
literal|4
index|]
expr_stmt|;
name|tm
operator|.
name|tm_sec
operator|=
name|v
index|[
literal|5
index|]
expr_stmt|;
comment|/* v[6] is the signed timezone offset, in 1/4-hour increments. */
name|offset
operator|=
operator|(
operator|(
specifier|const
name|signed
name|char
operator|*
operator|)
name|v
operator|)
index|[
literal|6
index|]
expr_stmt|;
if|if
condition|(
name|offset
operator|>
operator|-
literal|48
operator|&&
name|offset
operator|<
literal|52
condition|)
block|{
name|tm
operator|.
name|tm_hour
operator|-=
name|offset
operator|/
literal|4
expr_stmt|;
name|tm
operator|.
name|tm_min
operator|-=
operator|(
name|offset
operator|%
literal|4
operator|)
operator|*
literal|15
expr_stmt|;
block|}
name|t
operator|=
name|time_from_tm
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
return|return
operator|(
operator|(
name|time_t
operator|)
literal|0
operator|)
return|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|time_t
name|isodate17
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|tm
name|tm
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|memset
argument_list|(
operator|&
name|tm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tm
argument_list|)
argument_list|)
expr_stmt|;
name|tm
operator|.
name|tm_year
operator|=
operator|(
name|v
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|1000
operator|+
operator|(
name|v
index|[
literal|1
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|100
operator|+
operator|(
name|v
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
operator|(
name|v
index|[
literal|3
index|]
operator|-
literal|'0'
operator|)
operator|-
literal|1900
expr_stmt|;
name|tm
operator|.
name|tm_mon
operator|=
operator|(
name|v
index|[
literal|4
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
operator|(
name|v
index|[
literal|5
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|tm
operator|.
name|tm_mday
operator|=
operator|(
name|v
index|[
literal|6
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
operator|(
name|v
index|[
literal|7
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|tm
operator|.
name|tm_hour
operator|=
operator|(
name|v
index|[
literal|8
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
operator|(
name|v
index|[
literal|9
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|tm
operator|.
name|tm_min
operator|=
operator|(
name|v
index|[
literal|10
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
operator|(
name|v
index|[
literal|11
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|tm
operator|.
name|tm_sec
operator|=
operator|(
name|v
index|[
literal|12
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
operator|(
name|v
index|[
literal|13
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
comment|/* v[16] is the signed timezone offset, in 1/4-hour increments. */
name|offset
operator|=
operator|(
operator|(
specifier|const
name|signed
name|char
operator|*
operator|)
name|v
operator|)
index|[
literal|16
index|]
expr_stmt|;
if|if
condition|(
name|offset
operator|>
operator|-
literal|48
operator|&&
name|offset
operator|<
literal|52
condition|)
block|{
name|tm
operator|.
name|tm_hour
operator|-=
name|offset
operator|/
literal|4
expr_stmt|;
name|tm
operator|.
name|tm_min
operator|-=
operator|(
name|offset
operator|%
literal|4
operator|)
operator|*
literal|15
expr_stmt|;
block|}
name|t
operator|=
name|time_from_tm
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
return|return
operator|(
operator|(
name|time_t
operator|)
literal|0
operator|)
return|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|time_t
name|time_from_tm
parameter_list|(
name|struct
name|tm
modifier|*
name|t
parameter_list|)
block|{
if|#
directive|if
name|HAVE_TIMEGM
comment|/* Use platform timegm() if available. */
return|return
operator|(
name|timegm
argument_list|(
name|t
argument_list|)
operator|)
return|;
elif|#
directive|elif
name|HAVE__MKGMTIME64
return|return
operator|(
name|_mkgmtime64
argument_list|(
name|t
argument_list|)
operator|)
return|;
else|#
directive|else
comment|/* Else use direct calculation using POSIX assumptions. */
comment|/* First, fix up tm_yday based on the year/month/day. */
if|if
condition|(
name|mktime
argument_list|(
name|t
argument_list|)
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
return|return
operator|(
operator|(
name|time_t
operator|)
operator|-
literal|1
operator|)
return|;
comment|/* Then we can compute timegm() from first principles. */
return|return
operator|(
name|t
operator|->
name|tm_sec
operator|+
name|t
operator|->
name|tm_min
operator|*
literal|60
operator|+
name|t
operator|->
name|tm_hour
operator|*
literal|3600
operator|+
name|t
operator|->
name|tm_yday
operator|*
literal|86400
operator|+
operator|(
name|t
operator|->
name|tm_year
operator|-
literal|70
operator|)
operator|*
literal|31536000
operator|+
operator|(
operator|(
name|t
operator|->
name|tm_year
operator|-
literal|69
operator|)
operator|/
literal|4
operator|)
operator|*
literal|86400
operator|-
operator|(
operator|(
name|t
operator|->
name|tm_year
operator|-
literal|1
operator|)
operator|/
literal|100
operator|)
operator|*
literal|86400
operator|+
operator|(
operator|(
name|t
operator|->
name|tm_year
operator|+
literal|299
operator|)
operator|/
literal|400
operator|)
operator|*
literal|86400
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|build_pathname
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
name|struct
name|file_info
modifier|*
name|file
parameter_list|)
block|{
if|if
condition|(
name|file
operator|->
name|parent
operator|!=
name|NULL
operator|&&
name|archive_strlen
argument_list|(
operator|&
name|file
operator|->
name|parent
operator|->
name|name
argument_list|)
operator|>
literal|0
condition|)
block|{
name|build_pathname
argument_list|(
name|as
argument_list|,
name|file
operator|->
name|parent
argument_list|)
expr_stmt|;
name|archive_strcat
argument_list|(
name|as
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
name|file
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
name|archive_strcat
argument_list|(
name|as
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
else|else
name|archive_string_concat
argument_list|(
name|as
argument_list|,
operator|&
name|file
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|as
operator|->
name|s
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|build_pathname_utf16be
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|max
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
name|struct
name|file_info
modifier|*
name|file
parameter_list|)
block|{
if|if
condition|(
name|file
operator|->
name|parent
operator|!=
name|NULL
operator|&&
name|file
operator|->
name|parent
operator|->
name|utf16be_bytes
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|build_pathname_utf16be
argument_list|(
name|p
argument_list|,
name|max
argument_list|,
name|len
argument_list|,
name|file
operator|->
name|parent
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|p
index|[
operator|*
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|p
index|[
operator|*
name|len
operator|+
literal|1
index|]
operator|=
literal|'/'
expr_stmt|;
operator|*
name|len
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|file
operator|->
name|utf16be_bytes
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|len
operator|+
literal|2
operator|>
name|max
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Path is too long! */
name|p
index|[
operator|*
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|p
index|[
operator|*
name|len
operator|+
literal|1
index|]
operator|=
literal|'.'
expr_stmt|;
operator|*
name|len
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|len
operator|+
name|file
operator|->
name|utf16be_bytes
operator|>
name|max
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Path is too long! */
name|memcpy
argument_list|(
name|p
operator|+
operator|*
name|len
argument_list|,
name|file
operator|->
name|utf16be_name
argument_list|,
name|file
operator|->
name|utf16be_bytes
argument_list|)
expr_stmt|;
operator|*
name|len
operator|+=
name|file
operator|->
name|utf16be_bytes
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|DEBUG
end_if

begin_function
specifier|static
name|void
name|dump_isodirrec
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|isodirrec
parameter_list|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" l %d,"
argument_list|,
name|toi
argument_list|(
name|isodirrec
operator|+
name|DR_length_offset
argument_list|,
name|DR_length_size
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" a %d,"
argument_list|,
name|toi
argument_list|(
name|isodirrec
operator|+
name|DR_ext_attr_length_offset
argument_list|,
name|DR_ext_attr_length_size
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" ext 0x%x,"
argument_list|,
name|toi
argument_list|(
name|isodirrec
operator|+
name|DR_extent_offset
argument_list|,
name|DR_extent_size
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" s %d,"
argument_list|,
name|toi
argument_list|(
name|isodirrec
operator|+
name|DR_size_offset
argument_list|,
name|DR_extent_size
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" f 0x%x,"
argument_list|,
name|toi
argument_list|(
name|isodirrec
operator|+
name|DR_flags_offset
argument_list|,
name|DR_flags_size
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" u %d,"
argument_list|,
name|toi
argument_list|(
name|isodirrec
operator|+
name|DR_file_unit_size_offset
argument_list|,
name|DR_file_unit_size_size
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" ilv %d,"
argument_list|,
name|toi
argument_list|(
name|isodirrec
operator|+
name|DR_interleave_offset
argument_list|,
name|DR_interleave_size
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" seq %d,"
argument_list|,
name|toi
argument_list|(
name|isodirrec
operator|+
name|DR_volume_sequence_number_offset
argument_list|,
name|DR_volume_sequence_number_size
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" nl %d:"
argument_list|,
name|toi
argument_list|(
name|isodirrec
operator|+
name|DR_name_len_offset
argument_list|,
name|DR_name_len_size
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" `%.*s'"
argument_list|,
name|toi
argument_list|(
name|isodirrec
operator|+
name|DR_name_len_offset
argument_list|,
name|DR_name_len_size
argument_list|)
argument_list|,
name|isodirrec
operator|+
name|DR_name_offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

