begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Anselm Strauss  * Copyright (c) 2009 Joerg Sonnenberger  * Copyright (c) 2011-2012,2014 Michihiro NAKAJIMA  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Development supported by Google Summer of Code 2008.  */
end_comment

begin_include
include|#
directive|include
file|"archive_platform.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ERRNO_H
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LANGINFO_H
end_ifdef

begin_include
include|#
directive|include
file|<langinfo.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"archive.h"
end_include

begin_include
include|#
directive|include
file|"archive_cryptor_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_endian.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry_locale.h"
end_include

begin_include
include|#
directive|include
file|"archive_hmac_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_random_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_write_private.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_ZLIB_H
end_ifndef

begin_include
include|#
directive|include
file|"archive_crc32.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ZIP_ENTRY_FLAG_ENCRYPTED
value|(1<<0)
end_define

begin_define
define|#
directive|define
name|ZIP_ENTRY_FLAG_LENGTH_AT_END
value|(1<<3)
end_define

begin_define
define|#
directive|define
name|ZIP_ENTRY_FLAG_UTF8_NAME
value|(1<< 11)
end_define

begin_define
define|#
directive|define
name|ZIP_4GB_MAX
value|ARCHIVE_LITERAL_LL(0xffffffff)
end_define

begin_define
define|#
directive|define
name|ZIP_4GB_MAX_UNCOMPRESSED
value|ARCHIVE_LITERAL_LL(0xff000000)
end_define

begin_enum
enum|enum
name|compression
block|{
name|COMPRESSION_UNSPECIFIED
init|=
operator|-
literal|1
block|,
name|COMPRESSION_STORE
init|=
literal|0
block|,
name|COMPRESSION_DEFLATE
init|=
literal|8
block|}
enum|;
end_enum

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
end_ifdef

begin_define
define|#
directive|define
name|COMPRESSION_DEFAULT
value|COMPRESSION_DEFLATE
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|COMPRESSION_DEFAULT
value|COMPRESSION_STORE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_enum
enum|enum
name|encryption
block|{
name|ENCRYPTION_NONE
init|=
literal|0
block|,
name|ENCRYPTION_TRADITIONAL
block|,
comment|/* Traditional PKWARE encryption. */
name|ENCRYPTION_WINZIP_AES128
block|,
comment|/* WinZIP AES-128 encryption. */
name|ENCRYPTION_WINZIP_AES256
block|,
comment|/* WinZIP AES-256 encryption. */
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|TRAD_HEADER_SIZE
value|12
end_define

begin_comment
comment|/*  * See "WinZip - AES Encryption Information"  *     http://www.winzip.com/aes_info.htm  */
end_comment

begin_comment
comment|/* Value used in compression method. */
end_comment

begin_define
define|#
directive|define
name|WINZIP_AES_ENCRYPTION
value|99
end_define

begin_comment
comment|/* A WinZip AES header size which is stored at the beginning of  * file contents. */
end_comment

begin_define
define|#
directive|define
name|WINZIP_AES128_HEADER_SIZE
value|(8 + 2)
end_define

begin_define
define|#
directive|define
name|WINZIP_AES256_HEADER_SIZE
value|(16 + 2)
end_define

begin_comment
comment|/* AES vendor version. */
end_comment

begin_define
define|#
directive|define
name|AES_VENDOR_AE_1
value|0x0001
end_define

begin_define
define|#
directive|define
name|AES_VENDOR_AE_2
value|0x0002
end_define

begin_comment
comment|/* Authentication code size. */
end_comment

begin_define
define|#
directive|define
name|AUTH_CODE_SIZE
value|10
end_define

begin_comment
comment|/**/
end_comment

begin_define
define|#
directive|define
name|MAX_DERIVED_KEY_BUF_SIZE
value|(AES_MAX_KEY_SIZE * 2 + 2)
end_define

begin_struct
struct|struct
name|cd_segment
block|{
name|struct
name|cd_segment
modifier|*
name|next
decl_stmt|;
name|size_t
name|buff_size
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buff
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|trad_enc_ctx
block|{
name|uint32_t
name|keys
index|[
literal|3
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|zip
block|{
name|int64_t
name|entry_offset
decl_stmt|;
name|int64_t
name|entry_compressed_size
decl_stmt|;
name|int64_t
name|entry_uncompressed_size
decl_stmt|;
name|int64_t
name|entry_compressed_written
decl_stmt|;
name|int64_t
name|entry_uncompressed_written
decl_stmt|;
name|int64_t
name|entry_uncompressed_limit
decl_stmt|;
name|struct
name|archive_entry
modifier|*
name|entry
decl_stmt|;
name|uint32_t
name|entry_crc32
decl_stmt|;
name|enum
name|compression
name|entry_compression
decl_stmt|;
name|enum
name|encryption
name|entry_encryption
decl_stmt|;
name|int
name|entry_flags
decl_stmt|;
name|int
name|entry_uses_zip64
decl_stmt|;
name|int
name|experiments
decl_stmt|;
name|struct
name|trad_enc_ctx
name|tctx
decl_stmt|;
name|char
name|tctx_valid
decl_stmt|;
name|unsigned
name|char
name|trad_chkdat
decl_stmt|;
name|unsigned
name|aes_vendor
decl_stmt|;
name|archive_crypto_ctx
name|cctx
decl_stmt|;
name|char
name|cctx_valid
decl_stmt|;
name|archive_hmac_sha1_ctx
name|hctx
decl_stmt|;
name|char
name|hctx_valid
decl_stmt|;
name|unsigned
name|char
modifier|*
name|file_header
decl_stmt|;
name|size_t
name|file_header_extra_offset
decl_stmt|;
name|unsigned
name|long
function_decl|(
modifier|*
name|crc32func
function_decl|)
parameter_list|(
name|unsigned
name|long
name|crc
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
name|struct
name|cd_segment
modifier|*
name|central_directory
decl_stmt|;
name|struct
name|cd_segment
modifier|*
name|central_directory_last
decl_stmt|;
name|size_t
name|central_directory_bytes
decl_stmt|;
name|size_t
name|central_directory_entries
decl_stmt|;
name|int64_t
name|written_bytes
decl_stmt|;
comment|/* Overall position in file. */
name|struct
name|archive_string_conv
modifier|*
name|opt_sconv
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|sconv_default
decl_stmt|;
name|enum
name|compression
name|requested_compression
decl_stmt|;
name|int
name|deflate_compression_level
decl_stmt|;
name|int
name|init_default_conversion
decl_stmt|;
name|enum
name|encryption
name|encryption_type
decl_stmt|;
define|#
directive|define
name|ZIP_FLAG_AVOID_ZIP64
value|1
define|#
directive|define
name|ZIP_FLAG_FORCE_ZIP64
value|2
define|#
directive|define
name|ZIP_FLAG_EXPERIMENT_xl
value|4
name|int
name|flags
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
name|z_stream
name|stream
decl_stmt|;
endif|#
directive|endif
name|size_t
name|len_buf
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Don't call this min or MIN, since those are already defined    on lots of platforms (but not all). */
end_comment

begin_define
define|#
directive|define
name|zipmin
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (b) : (a))
end_define

begin_function_decl
specifier|static
name|ssize_t
name|archive_write_zip_data
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_write_zip_close
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_write_zip_free
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_write_zip_finish_entry
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_write_zip_header
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_write_zip_options
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|dos_time
parameter_list|(
specifier|const
name|time_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|path_length
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|write_path
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|copy_path
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|archive_string_conv
modifier|*
name|get_sconv
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|zip
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trad_enc_init
parameter_list|(
name|struct
name|trad_enc_ctx
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|trad_enc_encrypt_update
parameter_list|(
name|struct
name|trad_enc_ctx
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|init_traditional_pkware_encryption
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_traditional_pkware_encryption_supported
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|init_winzip_aes_encryption
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_winzip_aes_encryption_supported
parameter_list|(
name|int
name|encryption
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|cd_alloc
parameter_list|(
name|struct
name|zip
modifier|*
name|zip
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|zip
operator|->
name|central_directory
operator|==
name|NULL
operator|||
operator|(
name|zip
operator|->
name|central_directory_last
operator|->
name|p
operator|+
name|length
operator|>
name|zip
operator|->
name|central_directory_last
operator|->
name|buff
operator|+
name|zip
operator|->
name|central_directory_last
operator|->
name|buff_size
operator|)
condition|)
block|{
name|struct
name|cd_segment
modifier|*
name|segment
init|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|segment
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|segment
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|segment
operator|->
name|buff_size
operator|=
literal|64
operator|*
literal|1024
expr_stmt|;
name|segment
operator|->
name|buff
operator|=
name|malloc
argument_list|(
name|segment
operator|->
name|buff_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|segment
operator|->
name|buff
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|segment
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|segment
operator|->
name|p
operator|=
name|segment
operator|->
name|buff
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|central_directory
operator|==
name|NULL
condition|)
block|{
name|zip
operator|->
name|central_directory
operator|=
name|zip
operator|->
name|central_directory_last
operator|=
name|segment
expr_stmt|;
block|}
else|else
block|{
name|zip
operator|->
name|central_directory_last
operator|->
name|next
operator|=
name|segment
expr_stmt|;
name|zip
operator|->
name|central_directory_last
operator|=
name|segment
expr_stmt|;
block|}
block|}
name|p
operator|=
name|zip
operator|->
name|central_directory_last
operator|->
name|p
expr_stmt|;
name|zip
operator|->
name|central_directory_last
operator|->
name|p
operator|+=
name|length
expr_stmt|;
name|zip
operator|->
name|central_directory_bytes
operator|+=
name|length
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|real_crc32
parameter_list|(
name|unsigned
name|long
name|crc
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
name|crc32
argument_list|(
name|crc
argument_list|,
name|buff
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|fake_crc32
parameter_list|(
name|unsigned
name|long
name|crc
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
operator|(
name|void
operator|)
name|crc
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|buff
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|len
expr_stmt|;
comment|/* UNUSED */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_write_zip_options
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|int
name|ret
init|=
name|ARCHIVE_FAILED
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"compression"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Set compression to use on all future entries. 		 * This only affects regular files. 		 */
if|if
condition|(
name|val
operator|==
name|NULL
operator|||
name|val
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"%s: compression option needs a compression name"
argument_list|,
name|a
operator|->
name|format_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"deflate"
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
name|zip
operator|->
name|requested_compression
operator|=
name|COMPRESSION_DEFLATE
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_OK
expr_stmt|;
else|#
directive|else
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"deflate compression not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"store"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zip
operator|->
name|requested_compression
operator|=
name|COMPRESSION_STORE
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_OK
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"compression-level"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|val
operator|==
name|NULL
operator|||
operator|!
operator|(
name|val
index|[
literal|0
index|]
operator|>=
literal|'0'
operator|&&
name|val
index|[
literal|0
index|]
operator|<=
literal|'9'
operator|)
operator|||
name|val
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
return|return
name|ARCHIVE_WARN
return|;
block|}
if|if
condition|(
name|val
index|[
literal|0
index|]
operator|==
literal|'0'
condition|)
block|{
name|zip
operator|->
name|requested_compression
operator|=
name|COMPRESSION_STORE
expr_stmt|;
return|return
name|ARCHIVE_OK
return|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
name|zip
operator|->
name|requested_compression
operator|=
name|COMPRESSION_DEFLATE
expr_stmt|;
name|zip
operator|->
name|deflate_compression_level
operator|=
name|val
index|[
literal|0
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
name|ARCHIVE_OK
return|;
else|#
directive|else
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"deflate compression not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"encryption"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
block|{
name|zip
operator|->
name|encryption_type
operator|=
name|ENCRYPTION_NONE
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_OK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
index|[
literal|0
index|]
operator|==
literal|'1'
operator|||
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"traditional"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"zipcrypt"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"ZipCrypt"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|is_traditional_pkware_encryption_supported
argument_list|()
condition|)
block|{
name|zip
operator|->
name|encryption_type
operator|=
name|ENCRYPTION_TRADITIONAL
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_OK
expr_stmt|;
block|}
else|else
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"encryption not supported"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"aes128"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|is_winzip_aes_encryption_supported
argument_list|(
name|ENCRYPTION_WINZIP_AES128
argument_list|)
condition|)
block|{
name|zip
operator|->
name|encryption_type
operator|=
name|ENCRYPTION_WINZIP_AES128
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_OK
expr_stmt|;
block|}
else|else
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"encryption not supported"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"aes256"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|is_winzip_aes_encryption_supported
argument_list|(
name|ENCRYPTION_WINZIP_AES256
argument_list|)
condition|)
block|{
name|zip
operator|->
name|encryption_type
operator|=
name|ENCRYPTION_WINZIP_AES256
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_OK
expr_stmt|;
block|}
else|else
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"encryption not supported"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"%s: unknown encryption '%s'"
argument_list|,
name|a
operator|->
name|format_name
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"experimental"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|val
operator|==
name|NULL
operator|||
name|val
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|zip
operator|->
name|flags
operator|&=
operator|~
name|ZIP_FLAG_EXPERIMENT_xl
expr_stmt|;
block|}
else|else
block|{
name|zip
operator|->
name|flags
operator||=
name|ZIP_FLAG_EXPERIMENT_xl
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"fakecrc32"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * FOR TESTING ONLY:  disable CRC calculation to speed up 		 * certain complex tests. 		 */
if|if
condition|(
name|val
operator|==
name|NULL
operator|||
name|val
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|zip
operator|->
name|crc32func
operator|=
name|real_crc32
expr_stmt|;
block|}
else|else
block|{
name|zip
operator|->
name|crc32func
operator|=
name|fake_crc32
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"hdrcharset"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Set the character set used in translating filenames. 		 */
if|if
condition|(
name|val
operator|==
name|NULL
operator|||
name|val
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"%s: hdrcharset option needs a character-set name"
argument_list|,
name|a
operator|->
name|format_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zip
operator|->
name|opt_sconv
operator|=
name|archive_string_conversion_to_charset
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|opt_sconv
operator|!=
name|NULL
condition|)
name|ret
operator|=
name|ARCHIVE_OK
expr_stmt|;
else|else
name|ret
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"zip64"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Bias decisions about Zip64: force them to be 		 * generated in certain cases where they are not 		 * forbidden or avoid them in certain cases where they 		 * are not strictly required. 		 */
if|if
condition|(
name|val
operator|!=
name|NULL
operator|&&
operator|*
name|val
operator|!=
literal|'\0'
condition|)
block|{
name|zip
operator|->
name|flags
operator||=
name|ZIP_FLAG_FORCE_ZIP64
expr_stmt|;
name|zip
operator|->
name|flags
operator|&=
operator|~
name|ZIP_FLAG_AVOID_ZIP64
expr_stmt|;
block|}
else|else
block|{
name|zip
operator|->
name|flags
operator|&=
operator|~
name|ZIP_FLAG_FORCE_ZIP64
expr_stmt|;
name|zip
operator|->
name|flags
operator||=
name|ZIP_FLAG_AVOID_ZIP64
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
comment|/* Note: The "warn" return is just to inform the options 	 * supervisor that we didn't handle it.  It will generate 	 * a suitable error if no one used this option. */
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
end_function

begin_function
name|int
name|archive_write_zip_set_compression_deflate
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_write
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_write
operator|*
operator|)
name|_a
decl_stmt|;
name|int
name|ret
init|=
name|ARCHIVE_FAILED
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_WRITE_MAGIC
argument_list|,
name|ARCHIVE_STATE_NEW
operator||
name|ARCHIVE_STATE_HEADER
operator||
name|ARCHIVE_STATE_DATA
argument_list|,
literal|"archive_write_zip_set_compression_deflate"
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|!=
name|ARCHIVE_FORMAT_ZIP
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Can only use archive_write_zip_set_compression_deflate"
literal|" with zip format"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
name|struct
name|zip
modifier|*
name|zip
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|zip
operator|->
name|requested_compression
operator|=
name|COMPRESSION_DEFLATE
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_OK
expr_stmt|;
else|#
directive|else
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"deflate compression not supported"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_FAILED
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|archive_write_zip_set_compression_store
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_write
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_write
operator|*
operator|)
name|_a
decl_stmt|;
name|struct
name|zip
modifier|*
name|zip
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|int
name|ret
init|=
name|ARCHIVE_FAILED
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_WRITE_MAGIC
argument_list|,
name|ARCHIVE_STATE_NEW
operator||
name|ARCHIVE_STATE_HEADER
operator||
name|ARCHIVE_STATE_DATA
argument_list|,
literal|"archive_write_zip_set_compression_deflate"
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|!=
name|ARCHIVE_FORMAT_ZIP
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Can only use archive_write_zip_set_compression_store"
literal|" with zip format"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
block|}
else|else
block|{
name|zip
operator|->
name|requested_compression
operator|=
name|COMPRESSION_STORE
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_OK
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|archive_write_set_format_zip
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_write
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_write
operator|*
operator|)
name|_a
decl_stmt|;
name|struct
name|zip
modifier|*
name|zip
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_WRITE_MAGIC
argument_list|,
name|ARCHIVE_STATE_NEW
argument_list|,
literal|"archive_write_set_format_zip"
argument_list|)
expr_stmt|;
comment|/* If another format was already registered, unregister it. */
if|if
condition|(
name|a
operator|->
name|format_free
operator|!=
name|NULL
condition|)
call|(
name|a
operator|->
name|format_free
call|)
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|zip
operator|=
operator|(
expr|struct
name|zip
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate zip data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* "Unspecified" lets us choose the appropriate compression. */
name|zip
operator|->
name|requested_compression
operator|=
name|COMPRESSION_UNSPECIFIED
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
name|zip
operator|->
name|deflate_compression_level
operator|=
name|Z_DEFAULT_COMPRESSION
expr_stmt|;
endif|#
directive|endif
name|zip
operator|->
name|crc32func
operator|=
name|real_crc32
expr_stmt|;
comment|/* A buffer used for both compression and encryption. */
name|zip
operator|->
name|len_buf
operator|=
literal|65536
expr_stmt|;
name|zip
operator|->
name|buf
operator|=
name|malloc
argument_list|(
name|zip
operator|->
name|len_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|buf
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|zip
argument_list|)
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate compression buffer"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|a
operator|->
name|format_data
operator|=
name|zip
expr_stmt|;
name|a
operator|->
name|format_name
operator|=
literal|"zip"
expr_stmt|;
name|a
operator|->
name|format_options
operator|=
name|archive_write_zip_options
expr_stmt|;
name|a
operator|->
name|format_write_header
operator|=
name|archive_write_zip_header
expr_stmt|;
name|a
operator|->
name|format_write_data
operator|=
name|archive_write_zip_data
expr_stmt|;
name|a
operator|->
name|format_finish_entry
operator|=
name|archive_write_zip_finish_entry
expr_stmt|;
name|a
operator|->
name|format_close
operator|=
name|archive_write_zip_close
expr_stmt|;
name|a
operator|->
name|format_free
operator|=
name|archive_write_zip_free
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_ZIP
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"ZIP"
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_all_ascii
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|pp
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|p
decl_stmt|;
while|while
condition|(
operator|*
name|pp
condition|)
block|{
if|if
condition|(
operator|*
name|pp
operator|++
operator|>
literal|127
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_write_zip_header
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|unsigned
name|char
name|local_header
index|[
literal|32
index|]
decl_stmt|;
name|unsigned
name|char
name|local_extra
index|[
literal|144
index|]
decl_stmt|;
name|struct
name|zip
modifier|*
name|zip
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|unsigned
name|char
modifier|*
name|e
decl_stmt|;
name|unsigned
name|char
modifier|*
name|cd_extra
decl_stmt|;
name|size_t
name|filename_length
decl_stmt|;
specifier|const
name|char
modifier|*
name|slink
init|=
name|NULL
decl_stmt|;
name|size_t
name|slink_size
init|=
literal|0
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|sconv
init|=
name|get_sconv
argument_list|(
name|a
argument_list|,
name|zip
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|ret2
init|=
name|ARCHIVE_OK
decl_stmt|;
name|mode_t
name|type
decl_stmt|;
name|int
name|version_needed
init|=
literal|10
decl_stmt|;
comment|/* Ignore types of entries that we don't support. */
name|type
operator|=
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|AE_IFREG
operator|&&
name|type
operator|!=
name|AE_IFDIR
operator|&&
name|type
operator|!=
name|AE_IFLNK
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Filetype not supported"
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_FAILED
return|;
block|}
empty_stmt|;
comment|/* If we're not using Zip64, reject large files. */
if|if
condition|(
name|zip
operator|->
name|flags
operator|&
name|ZIP_FLAG_AVOID_ZIP64
condition|)
block|{
comment|/* Reject entries over 4GB. */
if|if
condition|(
name|archive_entry_size_is_set
argument_list|(
name|entry
argument_list|)
operator|&&
operator|(
name|archive_entry_size
argument_list|(
name|entry
argument_list|)
operator|>
name|ZIP_4GB_MAX
operator|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Files> 4GB require Zip64 extensions"
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_FAILED
return|;
block|}
comment|/* Reject entries if archive is> 4GB. */
if|if
condition|(
name|zip
operator|->
name|written_bytes
operator|>
name|ZIP_4GB_MAX
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Archives> 4GB require Zip64 extensions"
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_FAILED
return|;
block|}
block|}
comment|/* Only regular files can have size> 0. */
if|if
condition|(
name|type
operator|!=
name|AE_IFREG
condition|)
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset information from last entry. */
name|zip
operator|->
name|entry_offset
operator|=
name|zip
operator|->
name|written_bytes
expr_stmt|;
name|zip
operator|->
name|entry_uncompressed_limit
operator|=
name|INT64_MAX
expr_stmt|;
name|zip
operator|->
name|entry_compressed_size
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|entry_uncompressed_size
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|entry_compressed_written
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|entry_uncompressed_written
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|entry_flags
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|entry_uses_zip64
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|entry_crc32
operator|=
name|zip
operator|->
name|crc32func
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zip
operator|->
name|entry_encryption
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|entry
operator|!=
name|NULL
condition|)
block|{
name|archive_entry_free
argument_list|(
name|zip
operator|->
name|entry
argument_list|)
expr_stmt|;
name|zip
operator|->
name|entry
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|zip
operator|->
name|cctx_valid
condition|)
name|archive_encrypto_aes_ctr_release
argument_list|(
operator|&
name|zip
operator|->
name|cctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|hctx_valid
condition|)
name|archive_hmac_sha1_cleanup
argument_list|(
operator|&
name|zip
operator|->
name|hctx
argument_list|)
expr_stmt|;
name|zip
operator|->
name|tctx_valid
operator|=
name|zip
operator|->
name|cctx_valid
operator|=
name|zip
operator|->
name|hctx_valid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|AE_IFREG
operator|&&
operator|(
operator|!
name|archive_entry_size_is_set
argument_list|(
name|entry
argument_list|)
operator|||
name|archive_entry_size
argument_list|(
name|entry
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
switch|switch
condition|(
name|zip
operator|->
name|encryption_type
condition|)
block|{
case|case
name|ENCRYPTION_TRADITIONAL
case|:
case|case
name|ENCRYPTION_WINZIP_AES128
case|:
case|case
name|ENCRYPTION_WINZIP_AES256
case|:
name|zip
operator|->
name|entry_flags
operator||=
name|ZIP_ENTRY_FLAG_ENCRYPTED
expr_stmt|;
name|zip
operator|->
name|entry_encryption
operator|=
name|zip
operator|->
name|encryption_type
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
comment|/* Make sure the path separators in pahtname, hardlink and symlink 	 * are all slash '/', not the Windows path separator '\'. */
name|zip
operator|->
name|entry
operator|=
name|__la_win_entry_in_posix_pathseparator
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|entry
operator|==
name|entry
condition|)
name|zip
operator|->
name|entry
operator|=
name|archive_entry_clone
argument_list|(
name|entry
argument_list|)
expr_stmt|;
else|#
directive|else
name|zip
operator|->
name|entry
operator|=
name|archive_entry_clone
argument_list|(
name|entry
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|zip
operator|->
name|entry
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate zip header data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|sconv
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|archive_entry_pathname_l
argument_list|(
name|entry
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|,
name|sconv
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for Pathname"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Can't translate Pathname '%s' to %s"
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|archive_string_conversion_charset_name
argument_list|(
name|sconv
argument_list|)
argument_list|)
expr_stmt|;
name|ret2
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|archive_entry_set_pathname
argument_list|(
name|zip
operator|->
name|entry
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* 		 * There is no standard for symlink handling; we convert 		 * it using the same character-set translation that we use 		 * for filename. 		 */
if|if
condition|(
name|type
operator|==
name|AE_IFLNK
condition|)
block|{
if|if
condition|(
name|archive_entry_symlink_l
argument_list|(
name|entry
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|,
name|sconv
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory "
literal|" for Symlink"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* No error if we can't convert. */
block|}
elseif|else
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|archive_entry_set_symlink
argument_list|(
name|zip
operator|->
name|entry
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If filename isn't ASCII and we can use UTF-8, set the UTF-8 flag. */
if|if
condition|(
operator|!
name|is_all_ascii
argument_list|(
name|archive_entry_pathname
argument_list|(
name|zip
operator|->
name|entry
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|zip
operator|->
name|opt_sconv
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|archive_string_conversion_charset_name
argument_list|(
name|zip
operator|->
name|opt_sconv
argument_list|)
argument_list|,
literal|"UTF-8"
argument_list|)
operator|==
literal|0
condition|)
name|zip
operator|->
name|entry_flags
operator||=
name|ZIP_ENTRY_FLAG_UTF8_NAME
expr_stmt|;
if|#
directive|if
name|HAVE_NL_LANGINFO
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|nl_langinfo
argument_list|(
name|CODESET
argument_list|)
argument_list|,
literal|"UTF-8"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zip
operator|->
name|entry_flags
operator||=
name|ZIP_ENTRY_FLAG_UTF8_NAME
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|filename_length
operator|=
name|path_length
argument_list|(
name|zip
operator|->
name|entry
argument_list|)
expr_stmt|;
comment|/* Determine appropriate compression and size for this entry. */
if|if
condition|(
name|type
operator|==
name|AE_IFLNK
condition|)
block|{
name|slink
operator|=
name|archive_entry_symlink
argument_list|(
name|zip
operator|->
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|slink
operator|!=
name|NULL
condition|)
name|slink_size
operator|=
name|strlen
argument_list|(
name|slink
argument_list|)
expr_stmt|;
else|else
name|slink_size
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|entry_uncompressed_limit
operator|=
name|slink_size
expr_stmt|;
name|zip
operator|->
name|entry_compressed_size
operator|=
name|slink_size
expr_stmt|;
name|zip
operator|->
name|entry_uncompressed_size
operator|=
name|slink_size
expr_stmt|;
name|zip
operator|->
name|entry_crc32
operator|=
name|zip
operator|->
name|crc32func
argument_list|(
name|zip
operator|->
name|entry_crc32
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|slink
argument_list|,
name|slink_size
argument_list|)
expr_stmt|;
name|zip
operator|->
name|entry_compression
operator|=
name|COMPRESSION_STORE
expr_stmt|;
name|version_needed
operator|=
literal|20
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|AE_IFREG
condition|)
block|{
name|zip
operator|->
name|entry_compression
operator|=
name|COMPRESSION_STORE
expr_stmt|;
name|zip
operator|->
name|entry_uncompressed_limit
operator|=
literal|0
expr_stmt|;
name|version_needed
operator|=
literal|20
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|archive_entry_size_is_set
argument_list|(
name|zip
operator|->
name|entry
argument_list|)
condition|)
block|{
name|int64_t
name|size
init|=
name|archive_entry_size
argument_list|(
name|zip
operator|->
name|entry
argument_list|)
decl_stmt|;
name|int64_t
name|additional_size
init|=
literal|0
decl_stmt|;
name|zip
operator|->
name|entry_uncompressed_limit
operator|=
name|size
expr_stmt|;
name|zip
operator|->
name|entry_compression
operator|=
name|zip
operator|->
name|requested_compression
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|entry_compression
operator|==
name|COMPRESSION_UNSPECIFIED
condition|)
block|{
name|zip
operator|->
name|entry_compression
operator|=
name|COMPRESSION_DEFAULT
expr_stmt|;
block|}
if|if
condition|(
name|zip
operator|->
name|entry_compression
operator|==
name|COMPRESSION_STORE
condition|)
block|{
name|zip
operator|->
name|entry_compressed_size
operator|=
name|size
expr_stmt|;
name|zip
operator|->
name|entry_uncompressed_size
operator|=
name|size
expr_stmt|;
name|version_needed
operator|=
literal|10
expr_stmt|;
block|}
else|else
block|{
name|zip
operator|->
name|entry_uncompressed_size
operator|=
name|size
expr_stmt|;
name|version_needed
operator|=
literal|20
expr_stmt|;
block|}
if|if
condition|(
name|zip
operator|->
name|entry_flags
operator|&
name|ZIP_ENTRY_FLAG_ENCRYPTED
condition|)
block|{
switch|switch
condition|(
name|zip
operator|->
name|entry_encryption
condition|)
block|{
case|case
name|ENCRYPTION_TRADITIONAL
case|:
name|additional_size
operator|=
name|TRAD_HEADER_SIZE
expr_stmt|;
name|version_needed
operator|=
literal|20
expr_stmt|;
break|break;
case|case
name|ENCRYPTION_WINZIP_AES128
case|:
name|additional_size
operator|=
name|WINZIP_AES128_HEADER_SIZE
operator|+
name|AUTH_CODE_SIZE
expr_stmt|;
name|version_needed
operator|=
literal|20
expr_stmt|;
break|break;
case|case
name|ENCRYPTION_WINZIP_AES256
case|:
name|additional_size
operator|=
name|WINZIP_AES256_HEADER_SIZE
operator|+
name|AUTH_CODE_SIZE
expr_stmt|;
name|version_needed
operator|=
literal|20
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|zip
operator|->
name|entry_compression
operator|==
name|COMPRESSION_STORE
condition|)
name|zip
operator|->
name|entry_compressed_size
operator|+=
name|additional_size
expr_stmt|;
block|}
comment|/* 		 * Set Zip64 extension in any of the following cases 		 * (this was suggested by discussion on info-zip-dev 		 * mailing list): 		 *  = Zip64 is being forced by user 		 *  = File is over 4GiB uncompressed 		 *    (including encryption header, if any) 		 *  = File is close to 4GiB and is being compressed 		 *    (compression might make file larger) 		 */
if|if
condition|(
operator|(
name|zip
operator|->
name|flags
operator|&
name|ZIP_FLAG_FORCE_ZIP64
operator|)
operator|||
operator|(
name|zip
operator|->
name|entry_uncompressed_size
operator|+
name|additional_size
operator|>
name|ZIP_4GB_MAX
operator|)
operator|||
operator|(
name|zip
operator|->
name|entry_uncompressed_size
operator|>
name|ZIP_4GB_MAX_UNCOMPRESSED
operator|&&
name|zip
operator|->
name|entry_compression
operator|!=
name|COMPRESSION_STORE
operator|)
condition|)
block|{
name|zip
operator|->
name|entry_uses_zip64
operator|=
literal|1
expr_stmt|;
name|version_needed
operator|=
literal|45
expr_stmt|;
block|}
comment|/* We may know the size, but never the CRC. */
name|zip
operator|->
name|entry_flags
operator||=
name|ZIP_ENTRY_FLAG_LENGTH_AT_END
expr_stmt|;
block|}
else|else
block|{
comment|/* We don't know the size.  In this case, we prefer 		 * deflate (it has a clear end-of-data marker which 		 * makes length-at-end more reliable) and will 		 * enable Zip64 extensions unless we're told not to. 		 */
name|zip
operator|->
name|entry_compression
operator|=
name|COMPRESSION_DEFAULT
expr_stmt|;
name|zip
operator|->
name|entry_flags
operator||=
name|ZIP_ENTRY_FLAG_LENGTH_AT_END
expr_stmt|;
if|if
condition|(
operator|(
name|zip
operator|->
name|flags
operator|&
name|ZIP_FLAG_AVOID_ZIP64
operator|)
operator|==
literal|0
condition|)
block|{
name|zip
operator|->
name|entry_uses_zip64
operator|=
literal|1
expr_stmt|;
name|version_needed
operator|=
literal|45
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zip
operator|->
name|entry_compression
operator|==
name|COMPRESSION_STORE
condition|)
block|{
name|version_needed
operator|=
literal|10
expr_stmt|;
block|}
else|else
block|{
name|version_needed
operator|=
literal|20
expr_stmt|;
block|}
if|if
condition|(
name|zip
operator|->
name|entry_flags
operator|&
name|ZIP_ENTRY_FLAG_ENCRYPTED
condition|)
block|{
switch|switch
condition|(
name|zip
operator|->
name|entry_encryption
condition|)
block|{
case|case
name|ENCRYPTION_TRADITIONAL
case|:
case|case
name|ENCRYPTION_WINZIP_AES128
case|:
case|case
name|ENCRYPTION_WINZIP_AES256
case|:
if|if
condition|(
name|version_needed
operator|<
literal|20
condition|)
name|version_needed
operator|=
literal|20
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
comment|/* Format the local header. */
name|memset
argument_list|(
name|local_header
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|local_header
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|local_header
argument_list|,
literal|"PK\003\004"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|archive_le16enc
argument_list|(
name|local_header
operator|+
literal|4
argument_list|,
name|version_needed
argument_list|)
expr_stmt|;
name|archive_le16enc
argument_list|(
name|local_header
operator|+
literal|6
argument_list|,
name|zip
operator|->
name|entry_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|entry_encryption
operator|==
name|ENCRYPTION_WINZIP_AES128
operator|||
name|zip
operator|->
name|entry_encryption
operator|==
name|ENCRYPTION_WINZIP_AES256
condition|)
name|archive_le16enc
argument_list|(
name|local_header
operator|+
literal|8
argument_list|,
name|WINZIP_AES_ENCRYPTION
argument_list|)
expr_stmt|;
else|else
name|archive_le16enc
argument_list|(
name|local_header
operator|+
literal|8
argument_list|,
name|zip
operator|->
name|entry_compression
argument_list|)
expr_stmt|;
name|archive_le32enc
argument_list|(
name|local_header
operator|+
literal|10
argument_list|,
name|dos_time
argument_list|(
name|archive_entry_mtime
argument_list|(
name|zip
operator|->
name|entry
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|archive_le32enc
argument_list|(
name|local_header
operator|+
literal|14
argument_list|,
name|zip
operator|->
name|entry_crc32
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|entry_uses_zip64
condition|)
block|{
comment|/* Zip64 data in the local header "must" include both 		 * compressed and uncompressed sizes AND those fields 		 * are included only if these are 0xffffffff; 		 * THEREFORE these must be set this way, even if we 		 * know one of them is smaller. */
name|archive_le32enc
argument_list|(
name|local_header
operator|+
literal|18
argument_list|,
name|ZIP_4GB_MAX
argument_list|)
expr_stmt|;
name|archive_le32enc
argument_list|(
name|local_header
operator|+
literal|22
argument_list|,
name|ZIP_4GB_MAX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|archive_le32enc
argument_list|(
name|local_header
operator|+
literal|18
argument_list|,
operator|(
name|uint32_t
operator|)
name|zip
operator|->
name|entry_compressed_size
argument_list|)
expr_stmt|;
name|archive_le32enc
argument_list|(
name|local_header
operator|+
literal|22
argument_list|,
operator|(
name|uint32_t
operator|)
name|zip
operator|->
name|entry_uncompressed_size
argument_list|)
expr_stmt|;
block|}
name|archive_le16enc
argument_list|(
name|local_header
operator|+
literal|26
argument_list|,
operator|(
name|uint16_t
operator|)
name|filename_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|entry_encryption
operator|==
name|ENCRYPTION_TRADITIONAL
condition|)
block|{
if|if
condition|(
name|zip
operator|->
name|entry_flags
operator|&
name|ZIP_ENTRY_FLAG_LENGTH_AT_END
condition|)
name|zip
operator|->
name|trad_chkdat
operator|=
name|local_header
index|[
literal|11
index|]
expr_stmt|;
else|else
name|zip
operator|->
name|trad_chkdat
operator|=
name|local_header
index|[
literal|17
index|]
expr_stmt|;
block|}
comment|/* Format as much of central directory file header as we can: */
name|zip
operator|->
name|file_header
operator|=
name|cd_alloc
argument_list|(
name|zip
argument_list|,
literal|46
argument_list|)
expr_stmt|;
comment|/* If (zip->file_header == NULL) XXXX */
operator|++
name|zip
operator|->
name|central_directory_entries
expr_stmt|;
name|memset
argument_list|(
name|zip
operator|->
name|file_header
argument_list|,
literal|0
argument_list|,
literal|46
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|zip
operator|->
name|file_header
argument_list|,
literal|"PK\001\002"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* "Made by PKZip 2.0 on Unix." */
name|archive_le16enc
argument_list|(
name|zip
operator|->
name|file_header
operator|+
literal|4
argument_list|,
literal|3
operator|*
literal|256
operator|+
name|version_needed
argument_list|)
expr_stmt|;
name|archive_le16enc
argument_list|(
name|zip
operator|->
name|file_header
operator|+
literal|6
argument_list|,
name|version_needed
argument_list|)
expr_stmt|;
name|archive_le16enc
argument_list|(
name|zip
operator|->
name|file_header
operator|+
literal|8
argument_list|,
name|zip
operator|->
name|entry_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|entry_encryption
operator|==
name|ENCRYPTION_WINZIP_AES128
operator|||
name|zip
operator|->
name|entry_encryption
operator|==
name|ENCRYPTION_WINZIP_AES256
condition|)
name|archive_le16enc
argument_list|(
name|zip
operator|->
name|file_header
operator|+
literal|10
argument_list|,
name|WINZIP_AES_ENCRYPTION
argument_list|)
expr_stmt|;
else|else
name|archive_le16enc
argument_list|(
name|zip
operator|->
name|file_header
operator|+
literal|10
argument_list|,
name|zip
operator|->
name|entry_compression
argument_list|)
expr_stmt|;
name|archive_le32enc
argument_list|(
name|zip
operator|->
name|file_header
operator|+
literal|12
argument_list|,
name|dos_time
argument_list|(
name|archive_entry_mtime
argument_list|(
name|zip
operator|->
name|entry
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|archive_le16enc
argument_list|(
name|zip
operator|->
name|file_header
operator|+
literal|28
argument_list|,
operator|(
name|uint16_t
operator|)
name|filename_length
argument_list|)
expr_stmt|;
comment|/* Following Info-Zip, store mode in the "external attributes" field. */
name|archive_le32enc
argument_list|(
name|zip
operator|->
name|file_header
operator|+
literal|38
argument_list|,
operator|(
operator|(
name|uint32_t
operator|)
name|archive_entry_mode
argument_list|(
name|zip
operator|->
name|entry
argument_list|)
operator|)
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|e
operator|=
name|cd_alloc
argument_list|(
name|zip
argument_list|,
name|filename_length
argument_list|)
expr_stmt|;
comment|/* If (e == NULL) XXXX */
name|copy_path
argument_list|(
name|zip
operator|->
name|entry
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* Format extra data. */
name|memset
argument_list|(
name|local_extra
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|local_extra
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|=
name|local_extra
expr_stmt|;
comment|/* First, extra blocks that are the same between 	 * the local file header and the central directory. 	 * We format them once and then duplicate them. */
comment|/* UT timestamp, length depends on what timestamps are set. */
name|memcpy
argument_list|(
name|e
argument_list|,
literal|"UT"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|archive_le16enc
argument_list|(
name|e
operator|+
literal|2
argument_list|,
literal|1
operator|+
operator|(
name|archive_entry_mtime_is_set
argument_list|(
name|entry
argument_list|)
condition|?
literal|4
else|:
literal|0
operator|)
operator|+
operator|(
name|archive_entry_atime_is_set
argument_list|(
name|entry
argument_list|)
condition|?
literal|4
else|:
literal|0
operator|)
operator|+
operator|(
name|archive_entry_ctime_is_set
argument_list|(
name|entry
argument_list|)
condition|?
literal|4
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|e
operator|+=
literal|4
expr_stmt|;
operator|*
name|e
operator|++
operator|=
operator|(
name|archive_entry_mtime_is_set
argument_list|(
name|entry
argument_list|)
condition|?
literal|1
else|:
literal|0
operator|)
operator||
operator|(
name|archive_entry_atime_is_set
argument_list|(
name|entry
argument_list|)
condition|?
literal|2
else|:
literal|0
operator|)
operator||
operator|(
name|archive_entry_ctime_is_set
argument_list|(
name|entry
argument_list|)
condition|?
literal|4
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|archive_entry_mtime_is_set
argument_list|(
name|entry
argument_list|)
condition|)
block|{
name|archive_le32enc
argument_list|(
name|e
argument_list|,
operator|(
name|uint32_t
operator|)
name|archive_entry_mtime
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|archive_entry_atime_is_set
argument_list|(
name|entry
argument_list|)
condition|)
block|{
name|archive_le32enc
argument_list|(
name|e
argument_list|,
operator|(
name|uint32_t
operator|)
name|archive_entry_atime
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|archive_entry_ctime_is_set
argument_list|(
name|entry
argument_list|)
condition|)
block|{
name|archive_le32enc
argument_list|(
name|e
argument_list|,
operator|(
name|uint32_t
operator|)
name|archive_entry_ctime
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* ux Unix extra data, length 11, version 1 */
comment|/* TODO: If uid< 64k, use 2 bytes, ditto for gid. */
name|memcpy
argument_list|(
name|e
argument_list|,
literal|"ux\013\000\001"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|e
operator|+=
literal|5
expr_stmt|;
operator|*
name|e
operator|++
operator|=
literal|4
expr_stmt|;
comment|/* Length of following UID */
name|archive_le32enc
argument_list|(
name|e
argument_list|,
operator|(
name|uint32_t
operator|)
name|archive_entry_uid
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|+=
literal|4
expr_stmt|;
operator|*
name|e
operator|++
operator|=
literal|4
expr_stmt|;
comment|/* Length of following GID */
name|archive_le32enc
argument_list|(
name|e
argument_list|,
operator|(
name|uint32_t
operator|)
name|archive_entry_gid
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|+=
literal|4
expr_stmt|;
comment|/* AES extra data field: WinZIP AES information, ID=0x9901 */
if|if
condition|(
operator|(
name|zip
operator|->
name|entry_flags
operator|&
name|ZIP_ENTRY_FLAG_ENCRYPTED
operator|)
operator|&&
operator|(
name|zip
operator|->
name|entry_encryption
operator|==
name|ENCRYPTION_WINZIP_AES128
operator|||
name|zip
operator|->
name|entry_encryption
operator|==
name|ENCRYPTION_WINZIP_AES256
operator|)
condition|)
block|{
name|memcpy
argument_list|(
name|e
argument_list|,
literal|"\001\231\007\000\001\000AE"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* AES vendoer version AE-2 does not store a CRC. 		 * WinZip 11 uses AE-1, which does store the CRC, 		 * but it does not store the CRC when the file size 		 * is less than 20 bytes. So we simulate what 		 * WinZip 11 does. 		 * NOTE: WinZip 9.0 and 10.0 uses AE-2 by default. */
if|if
condition|(
name|archive_entry_size_is_set
argument_list|(
name|zip
operator|->
name|entry
argument_list|)
operator|&&
name|archive_entry_size
argument_list|(
name|zip
operator|->
name|entry
argument_list|)
operator|<
literal|20
condition|)
block|{
name|archive_le16enc
argument_list|(
name|e
operator|+
literal|4
argument_list|,
name|AES_VENDOR_AE_2
argument_list|)
expr_stmt|;
name|zip
operator|->
name|aes_vendor
operator|=
name|AES_VENDOR_AE_2
expr_stmt|;
comment|/* no CRC. */
block|}
else|else
name|zip
operator|->
name|aes_vendor
operator|=
name|AES_VENDOR_AE_1
expr_stmt|;
name|e
operator|+=
literal|8
expr_stmt|;
comment|/* AES encryption strength. */
operator|*
name|e
operator|++
operator|=
operator|(
name|zip
operator|->
name|entry_encryption
operator|==
name|ENCRYPTION_WINZIP_AES128
operator|)
condition|?
literal|1
else|:
literal|3
expr_stmt|;
comment|/* Actual compression method. */
name|archive_le16enc
argument_list|(
name|e
argument_list|,
name|zip
operator|->
name|entry_compression
argument_list|)
expr_stmt|;
name|e
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Copy UT ,ux, and AES-extra into central directory as well. */
name|zip
operator|->
name|file_header_extra_offset
operator|=
name|zip
operator|->
name|central_directory_bytes
expr_stmt|;
name|cd_extra
operator|=
name|cd_alloc
argument_list|(
name|zip
argument_list|,
name|e
operator|-
name|local_extra
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cd_extra
argument_list|,
name|local_extra
argument_list|,
name|e
operator|-
name|local_extra
argument_list|)
expr_stmt|;
comment|/* 	 * Following extra blocks vary between local header and 	 * central directory. These are the local header versions. 	 * Central directory versions get formatted in 	 * archive_write_zip_finish_entry() below. 	 */
comment|/* "[Zip64 entry] in the local header MUST include BOTH 	 * original [uncompressed] and compressed size fields." */
if|if
condition|(
name|zip
operator|->
name|entry_uses_zip64
condition|)
block|{
name|unsigned
name|char
modifier|*
name|zip64_start
init|=
name|e
decl_stmt|;
name|memcpy
argument_list|(
name|e
argument_list|,
literal|"\001\000\020\000"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|e
operator|+=
literal|4
expr_stmt|;
name|archive_le64enc
argument_list|(
name|e
argument_list|,
name|zip
operator|->
name|entry_uncompressed_size
argument_list|)
expr_stmt|;
name|e
operator|+=
literal|8
expr_stmt|;
name|archive_le64enc
argument_list|(
name|e
argument_list|,
name|zip
operator|->
name|entry_compressed_size
argument_list|)
expr_stmt|;
name|e
operator|+=
literal|8
expr_stmt|;
name|archive_le16enc
argument_list|(
name|zip64_start
operator|+
literal|2
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|e
operator|-
operator|(
name|zip64_start
operator|+
literal|4
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zip
operator|->
name|flags
operator|&
name|ZIP_FLAG_EXPERIMENT_xl
condition|)
block|{
comment|/* Experimental 'xl' extension to improve streaming. */
name|unsigned
name|char
modifier|*
name|external_info
init|=
name|e
decl_stmt|;
name|int
name|included
init|=
literal|7
decl_stmt|;
name|memcpy
argument_list|(
name|e
argument_list|,
literal|"xl\000\000"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|// 0x6c65 + 2-byte length
name|e
operator|+=
literal|4
expr_stmt|;
name|e
index|[
literal|0
index|]
operator|=
name|included
expr_stmt|;
comment|/* bitmap of included fields */
name|e
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|included
operator|&
literal|1
condition|)
block|{
name|archive_le16enc
argument_list|(
name|e
argument_list|,
comment|/* "Version created by" */
literal|3
operator|*
literal|256
operator|+
name|version_needed
argument_list|)
expr_stmt|;
name|e
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|included
operator|&
literal|2
condition|)
block|{
name|archive_le16enc
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* internal file attributes */
name|e
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|included
operator|&
literal|4
condition|)
block|{
name|archive_le32enc
argument_list|(
name|e
argument_list|,
comment|/* external file attributes */
operator|(
operator|(
name|uint32_t
operator|)
name|archive_entry_mode
argument_list|(
name|zip
operator|->
name|entry
argument_list|)
operator|)
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|e
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|included
operator|&
literal|8
condition|)
block|{
comment|// Libarchive does not currently support file comments.
block|}
name|archive_le16enc
argument_list|(
name|external_info
operator|+
literal|2
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|e
operator|-
operator|(
name|external_info
operator|+
literal|4
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Update local header with size of extra data and write it all out: */
name|archive_le16enc
argument_list|(
name|local_header
operator|+
literal|28
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|e
operator|-
name|local_extra
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|__archive_write_output
argument_list|(
name|a
argument_list|,
name|local_header
argument_list|,
literal|30
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|zip
operator|->
name|written_bytes
operator|+=
literal|30
expr_stmt|;
name|ret
operator|=
name|write_path
argument_list|(
name|zip
operator|->
name|entry
argument_list|,
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|zip
operator|->
name|written_bytes
operator|+=
name|ret
expr_stmt|;
name|ret
operator|=
name|__archive_write_output
argument_list|(
name|a
argument_list|,
name|local_extra
argument_list|,
name|e
operator|-
name|local_extra
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|zip
operator|->
name|written_bytes
operator|+=
name|e
operator|-
name|local_extra
expr_stmt|;
comment|/* For symlinks, write the body now. */
if|if
condition|(
name|slink
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|__archive_write_output
argument_list|(
name|a
argument_list|,
name|slink
argument_list|,
name|slink_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|zip
operator|->
name|entry_compressed_written
operator|+=
name|slink_size
expr_stmt|;
name|zip
operator|->
name|entry_uncompressed_written
operator|+=
name|slink_size
expr_stmt|;
name|zip
operator|->
name|written_bytes
operator|+=
name|slink_size
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
if|if
condition|(
name|zip
operator|->
name|entry_compression
operator|==
name|COMPRESSION_DEFLATE
condition|)
block|{
name|zip
operator|->
name|stream
operator|.
name|zalloc
operator|=
name|Z_NULL
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|zfree
operator|=
name|Z_NULL
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|opaque
operator|=
name|Z_NULL
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|next_out
operator|=
name|zip
operator|->
name|buf
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|zip
operator|->
name|len_buf
expr_stmt|;
if|if
condition|(
name|deflateInit2
argument_list|(
operator|&
name|zip
operator|->
name|stream
argument_list|,
name|zip
operator|->
name|deflate_compression_level
argument_list|,
name|Z_DEFLATED
argument_list|,
operator|-
literal|15
argument_list|,
literal|8
argument_list|,
name|Z_DEFAULT_STRATEGY
argument_list|)
operator|!=
name|Z_OK
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't init deflate compressor"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
endif|#
directive|endif
return|return
operator|(
name|ret2
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|archive_write_zip_data
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|zip
modifier|*
name|zip
init|=
name|a
operator|->
name|format_data
decl_stmt|;
if|if
condition|(
operator|(
name|int64_t
operator|)
name|s
operator|>
name|zip
operator|->
name|entry_uncompressed_limit
condition|)
name|s
operator|=
operator|(
name|size_t
operator|)
name|zip
operator|->
name|entry_uncompressed_limit
expr_stmt|;
name|zip
operator|->
name|entry_uncompressed_written
operator|+=
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|zip
operator|->
name|entry_flags
operator|&
name|ZIP_ENTRY_FLAG_ENCRYPTED
condition|)
block|{
switch|switch
condition|(
name|zip
operator|->
name|entry_encryption
condition|)
block|{
case|case
name|ENCRYPTION_TRADITIONAL
case|:
comment|/* Initialize traditoinal PKWARE encryption context. */
if|if
condition|(
operator|!
name|zip
operator|->
name|tctx_valid
condition|)
block|{
name|ret
operator|=
name|init_traditional_pkware_encryption
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|zip
operator|->
name|tctx_valid
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|ENCRYPTION_WINZIP_AES128
case|:
case|case
name|ENCRYPTION_WINZIP_AES256
case|:
if|if
condition|(
operator|!
name|zip
operator|->
name|cctx_valid
condition|)
block|{
name|ret
operator|=
name|init_winzip_aes_encryption
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|zip
operator|->
name|cctx_valid
operator|=
name|zip
operator|->
name|hctx_valid
operator|=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
switch|switch
condition|(
name|zip
operator|->
name|entry_compression
condition|)
block|{
case|case
name|COMPRESSION_STORE
case|:
if|if
condition|(
name|zip
operator|->
name|tctx_valid
operator|||
name|zip
operator|->
name|cctx_valid
condition|)
block|{
specifier|const
name|uint8_t
modifier|*
name|rb
init|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|buff
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
specifier|const
name|re
init|=
name|rb
operator|+
name|s
decl_stmt|;
while|while
condition|(
name|rb
operator|<
name|re
condition|)
block|{
name|size_t
name|l
decl_stmt|;
if|if
condition|(
name|zip
operator|->
name|tctx_valid
condition|)
block|{
name|l
operator|=
name|trad_enc_encrypt_update
argument_list|(
operator|&
name|zip
operator|->
name|tctx
argument_list|,
name|rb
argument_list|,
name|re
operator|-
name|rb
argument_list|,
name|zip
operator|->
name|buf
argument_list|,
name|zip
operator|->
name|len_buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|l
operator|=
name|zip
operator|->
name|len_buf
expr_stmt|;
name|ret
operator|=
name|archive_encrypto_aes_ctr_update
argument_list|(
operator|&
name|zip
operator|->
name|cctx
argument_list|,
name|rb
argument_list|,
name|re
operator|-
name|rb
argument_list|,
name|zip
operator|->
name|buf
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Failed to encrypt file"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|archive_hmac_sha1_update
argument_list|(
operator|&
name|zip
operator|->
name|hctx
argument_list|,
name|zip
operator|->
name|buf
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|__archive_write_output
argument_list|(
name|a
argument_list|,
name|zip
operator|->
name|buf
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|zip
operator|->
name|entry_compressed_written
operator|+=
name|l
expr_stmt|;
name|zip
operator|->
name|written_bytes
operator|+=
name|l
expr_stmt|;
name|rb
operator|+=
name|l
expr_stmt|;
block|}
block|}
else|else
block|{
name|ret
operator|=
name|__archive_write_output
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|zip
operator|->
name|written_bytes
operator|+=
name|s
expr_stmt|;
name|zip
operator|->
name|entry_compressed_written
operator|+=
name|s
expr_stmt|;
block|}
break|break;
if|#
directive|if
name|HAVE_ZLIB_H
case|case
name|COMPRESSION_DEFLATE
case|:
name|zip
operator|->
name|stream
operator|.
name|next_in
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|buff
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|avail_in
operator|=
operator|(
name|uInt
operator|)
name|s
expr_stmt|;
do|do
block|{
name|ret
operator|=
name|deflate
argument_list|(
operator|&
name|zip
operator|->
name|stream
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Z_STREAM_ERROR
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
if|if
condition|(
name|zip
operator|->
name|stream
operator|.
name|avail_out
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|zip
operator|->
name|tctx_valid
condition|)
block|{
name|trad_enc_encrypt_update
argument_list|(
operator|&
name|zip
operator|->
name|tctx
argument_list|,
name|zip
operator|->
name|buf
argument_list|,
name|zip
operator|->
name|len_buf
argument_list|,
name|zip
operator|->
name|buf
argument_list|,
name|zip
operator|->
name|len_buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zip
operator|->
name|cctx_valid
condition|)
block|{
name|size_t
name|outl
init|=
name|zip
operator|->
name|len_buf
decl_stmt|;
name|ret
operator|=
name|archive_encrypto_aes_ctr_update
argument_list|(
operator|&
name|zip
operator|->
name|cctx
argument_list|,
name|zip
operator|->
name|buf
argument_list|,
name|zip
operator|->
name|len_buf
argument_list|,
name|zip
operator|->
name|buf
argument_list|,
operator|&
name|outl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Failed to encrypt file"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|archive_hmac_sha1_update
argument_list|(
operator|&
name|zip
operator|->
name|hctx
argument_list|,
name|zip
operator|->
name|buf
argument_list|,
name|zip
operator|->
name|len_buf
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|__archive_write_output
argument_list|(
name|a
argument_list|,
name|zip
operator|->
name|buf
argument_list|,
name|zip
operator|->
name|len_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|zip
operator|->
name|entry_compressed_written
operator|+=
name|zip
operator|->
name|len_buf
expr_stmt|;
name|zip
operator|->
name|written_bytes
operator|+=
name|zip
operator|->
name|len_buf
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|next_out
operator|=
name|zip
operator|->
name|buf
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|zip
operator|->
name|len_buf
expr_stmt|;
block|}
block|}
do|while
condition|(
name|zip
operator|->
name|stream
operator|.
name|avail_in
operator|!=
literal|0
condition|)
do|;
break|break;
endif|#
directive|endif
default|default:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Invalid ZIP compression type"
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_FATAL
return|;
block|}
name|zip
operator|->
name|entry_uncompressed_limit
operator|-=
name|s
expr_stmt|;
if|if
condition|(
operator|!
name|zip
operator|->
name|cctx_valid
operator|||
name|zip
operator|->
name|aes_vendor
operator|!=
name|AES_VENDOR_AE_2
condition|)
name|zip
operator|->
name|entry_crc32
operator|=
name|zip
operator|->
name|crc32func
argument_list|(
name|zip
operator|->
name|entry_crc32
argument_list|,
name|buff
argument_list|,
operator|(
name|unsigned
operator|)
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_write_zip_finish_entry
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|#
directive|if
name|HAVE_ZLIB_H
if|if
condition|(
name|zip
operator|->
name|entry_compression
operator|==
name|COMPRESSION_DEFLATE
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|size_t
name|remainder
decl_stmt|;
name|ret
operator|=
name|deflate
argument_list|(
operator|&
name|zip
operator|->
name|stream
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Z_STREAM_ERROR
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|remainder
operator|=
name|zip
operator|->
name|len_buf
operator|-
name|zip
operator|->
name|stream
operator|.
name|avail_out
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|tctx_valid
condition|)
block|{
name|trad_enc_encrypt_update
argument_list|(
operator|&
name|zip
operator|->
name|tctx
argument_list|,
name|zip
operator|->
name|buf
argument_list|,
name|remainder
argument_list|,
name|zip
operator|->
name|buf
argument_list|,
name|remainder
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zip
operator|->
name|cctx_valid
condition|)
block|{
name|size_t
name|outl
init|=
name|remainder
decl_stmt|;
name|ret
operator|=
name|archive_encrypto_aes_ctr_update
argument_list|(
operator|&
name|zip
operator|->
name|cctx
argument_list|,
name|zip
operator|->
name|buf
argument_list|,
name|remainder
argument_list|,
name|zip
operator|->
name|buf
argument_list|,
operator|&
name|outl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Failed to encrypt file"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|archive_hmac_sha1_update
argument_list|(
operator|&
name|zip
operator|->
name|hctx
argument_list|,
name|zip
operator|->
name|buf
argument_list|,
name|remainder
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|__archive_write_output
argument_list|(
name|a
argument_list|,
name|zip
operator|->
name|buf
argument_list|,
name|remainder
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|zip
operator|->
name|entry_compressed_written
operator|+=
name|remainder
expr_stmt|;
name|zip
operator|->
name|written_bytes
operator|+=
name|remainder
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|next_out
operator|=
name|zip
operator|->
name|buf
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|stream
operator|.
name|avail_out
operator|!=
literal|0
condition|)
break|break;
name|zip
operator|->
name|stream
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|zip
operator|->
name|len_buf
expr_stmt|;
block|}
name|deflateEnd
argument_list|(
operator|&
name|zip
operator|->
name|stream
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|zip
operator|->
name|hctx_valid
condition|)
block|{
name|uint8_t
name|hmac
index|[
literal|20
index|]
decl_stmt|;
name|size_t
name|hmac_len
init|=
literal|20
decl_stmt|;
name|archive_hmac_sha1_final
argument_list|(
operator|&
name|zip
operator|->
name|hctx
argument_list|,
name|hmac
argument_list|,
operator|&
name|hmac_len
argument_list|)
expr_stmt|;
name|ret
operator|=
name|__archive_write_output
argument_list|(
name|a
argument_list|,
name|hmac
argument_list|,
name|AUTH_CODE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|zip
operator|->
name|entry_compressed_written
operator|+=
name|AUTH_CODE_SIZE
expr_stmt|;
name|zip
operator|->
name|written_bytes
operator|+=
name|AUTH_CODE_SIZE
expr_stmt|;
block|}
comment|/* Write trailing data descriptor. */
if|if
condition|(
operator|(
name|zip
operator|->
name|entry_flags
operator|&
name|ZIP_ENTRY_FLAG_LENGTH_AT_END
operator|)
operator|!=
literal|0
condition|)
block|{
name|char
name|d
index|[
literal|24
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|d
argument_list|,
literal|"PK\007\010"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|cctx_valid
operator|&&
name|zip
operator|->
name|aes_vendor
operator|==
name|AES_VENDOR_AE_2
condition|)
name|archive_le32enc
argument_list|(
name|d
operator|+
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* no CRC.*/
else|else
name|archive_le32enc
argument_list|(
name|d
operator|+
literal|4
argument_list|,
name|zip
operator|->
name|entry_crc32
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|entry_uses_zip64
condition|)
block|{
name|archive_le64enc
argument_list|(
name|d
operator|+
literal|8
argument_list|,
operator|(
name|uint64_t
operator|)
name|zip
operator|->
name|entry_compressed_written
argument_list|)
expr_stmt|;
name|archive_le64enc
argument_list|(
name|d
operator|+
literal|16
argument_list|,
operator|(
name|uint64_t
operator|)
name|zip
operator|->
name|entry_uncompressed_written
argument_list|)
expr_stmt|;
name|ret
operator|=
name|__archive_write_output
argument_list|(
name|a
argument_list|,
name|d
argument_list|,
literal|24
argument_list|)
expr_stmt|;
name|zip
operator|->
name|written_bytes
operator|+=
literal|24
expr_stmt|;
block|}
else|else
block|{
name|archive_le32enc
argument_list|(
name|d
operator|+
literal|8
argument_list|,
operator|(
name|uint32_t
operator|)
name|zip
operator|->
name|entry_compressed_written
argument_list|)
expr_stmt|;
name|archive_le32enc
argument_list|(
name|d
operator|+
literal|12
argument_list|,
operator|(
name|uint32_t
operator|)
name|zip
operator|->
name|entry_uncompressed_written
argument_list|)
expr_stmt|;
name|ret
operator|=
name|__archive_write_output
argument_list|(
name|a
argument_list|,
name|d
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|zip
operator|->
name|written_bytes
operator|+=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Append Zip64 extra data to central directory information. */
if|if
condition|(
name|zip
operator|->
name|entry_compressed_written
operator|>
name|ZIP_4GB_MAX
operator|||
name|zip
operator|->
name|entry_uncompressed_written
operator|>
name|ZIP_4GB_MAX
operator|||
name|zip
operator|->
name|entry_offset
operator|>
name|ZIP_4GB_MAX
condition|)
block|{
name|unsigned
name|char
name|zip64
index|[
literal|32
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|z
init|=
name|zip64
decl_stmt|,
modifier|*
name|zd
decl_stmt|;
name|memcpy
argument_list|(
name|z
argument_list|,
literal|"\001\000\000\000"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|z
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|entry_uncompressed_written
operator|>=
name|ZIP_4GB_MAX
condition|)
block|{
name|archive_le64enc
argument_list|(
name|z
argument_list|,
name|zip
operator|->
name|entry_uncompressed_written
argument_list|)
expr_stmt|;
name|z
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|zip
operator|->
name|entry_compressed_written
operator|>=
name|ZIP_4GB_MAX
condition|)
block|{
name|archive_le64enc
argument_list|(
name|z
argument_list|,
name|zip
operator|->
name|entry_compressed_written
argument_list|)
expr_stmt|;
name|z
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|zip
operator|->
name|entry_offset
operator|>=
name|ZIP_4GB_MAX
condition|)
block|{
name|archive_le64enc
argument_list|(
name|z
argument_list|,
name|zip
operator|->
name|entry_offset
argument_list|)
expr_stmt|;
name|z
operator|+=
literal|8
expr_stmt|;
block|}
name|archive_le16enc
argument_list|(
name|zip64
operator|+
literal|2
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|z
operator|-
operator|(
name|zip64
operator|+
literal|4
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|zd
operator|=
name|cd_alloc
argument_list|(
name|zip
argument_list|,
name|z
operator|-
name|zip64
argument_list|)
expr_stmt|;
if|if
condition|(
name|zd
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate zip data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|zd
argument_list|,
name|zip64
argument_list|,
name|z
operator|-
name|zip64
argument_list|)
expr_stmt|;
comment|/* Zip64 means version needs to be set to at least 4.5 */
if|if
condition|(
name|archive_le16dec
argument_list|(
name|zip
operator|->
name|file_header
operator|+
literal|6
argument_list|)
operator|<
literal|45
condition|)
name|archive_le16enc
argument_list|(
name|zip
operator|->
name|file_header
operator|+
literal|6
argument_list|,
literal|45
argument_list|)
expr_stmt|;
block|}
comment|/* Fix up central directory file header. */
if|if
condition|(
name|zip
operator|->
name|cctx_valid
operator|&&
name|zip
operator|->
name|aes_vendor
operator|==
name|AES_VENDOR_AE_2
condition|)
name|archive_le32enc
argument_list|(
name|zip
operator|->
name|file_header
operator|+
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* no CRC.*/
else|else
name|archive_le32enc
argument_list|(
name|zip
operator|->
name|file_header
operator|+
literal|16
argument_list|,
name|zip
operator|->
name|entry_crc32
argument_list|)
expr_stmt|;
name|archive_le32enc
argument_list|(
name|zip
operator|->
name|file_header
operator|+
literal|20
argument_list|,
operator|(
name|uint32_t
operator|)
name|zipmin
argument_list|(
name|zip
operator|->
name|entry_compressed_written
argument_list|,
name|ZIP_4GB_MAX
argument_list|)
argument_list|)
expr_stmt|;
name|archive_le32enc
argument_list|(
name|zip
operator|->
name|file_header
operator|+
literal|24
argument_list|,
operator|(
name|uint32_t
operator|)
name|zipmin
argument_list|(
name|zip
operator|->
name|entry_uncompressed_written
argument_list|,
name|ZIP_4GB_MAX
argument_list|)
argument_list|)
expr_stmt|;
name|archive_le16enc
argument_list|(
name|zip
operator|->
name|file_header
operator|+
literal|30
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|zip
operator|->
name|central_directory_bytes
operator|-
name|zip
operator|->
name|file_header_extra_offset
argument_list|)
argument_list|)
expr_stmt|;
name|archive_le32enc
argument_list|(
name|zip
operator|->
name|file_header
operator|+
literal|42
argument_list|,
operator|(
name|uint32_t
operator|)
name|zipmin
argument_list|(
name|zip
operator|->
name|entry_offset
argument_list|,
name|ZIP_4GB_MAX
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_write_zip_close
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|uint8_t
name|buff
index|[
literal|64
index|]
decl_stmt|;
name|int64_t
name|offset_start
decl_stmt|,
name|offset_end
decl_stmt|;
name|struct
name|zip
modifier|*
name|zip
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|struct
name|cd_segment
modifier|*
name|segment
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|offset_start
operator|=
name|zip
operator|->
name|written_bytes
expr_stmt|;
name|segment
operator|=
name|zip
operator|->
name|central_directory
expr_stmt|;
while|while
condition|(
name|segment
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|__archive_write_output
argument_list|(
name|a
argument_list|,
name|segment
operator|->
name|buff
argument_list|,
name|segment
operator|->
name|p
operator|-
name|segment
operator|->
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|zip
operator|->
name|written_bytes
operator|+=
name|segment
operator|->
name|p
operator|-
name|segment
operator|->
name|buff
expr_stmt|;
name|segment
operator|=
name|segment
operator|->
name|next
expr_stmt|;
block|}
name|offset_end
operator|=
name|zip
operator|->
name|written_bytes
expr_stmt|;
comment|/* If central dir info is too large, write Zip64 end-of-cd */
if|if
condition|(
name|offset_end
operator|-
name|offset_start
operator|>
name|ZIP_4GB_MAX
operator|||
name|offset_start
operator|>
name|ZIP_4GB_MAX
operator|||
name|zip
operator|->
name|central_directory_entries
operator|>
literal|0xffffUL
operator|||
operator|(
name|zip
operator|->
name|flags
operator|&
name|ZIP_FLAG_FORCE_ZIP64
operator|)
condition|)
block|{
comment|/* Zip64 end-of-cd record */
name|memset
argument_list|(
name|buff
argument_list|,
literal|0
argument_list|,
literal|56
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buff
argument_list|,
literal|"PK\006\006"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|archive_le64enc
argument_list|(
name|buff
operator|+
literal|4
argument_list|,
literal|44
argument_list|)
expr_stmt|;
name|archive_le16enc
argument_list|(
name|buff
operator|+
literal|12
argument_list|,
literal|45
argument_list|)
expr_stmt|;
name|archive_le16enc
argument_list|(
name|buff
operator|+
literal|14
argument_list|,
literal|45
argument_list|)
expr_stmt|;
comment|/* This is disk 0 of 0. */
name|archive_le64enc
argument_list|(
name|buff
operator|+
literal|24
argument_list|,
name|zip
operator|->
name|central_directory_entries
argument_list|)
expr_stmt|;
name|archive_le64enc
argument_list|(
name|buff
operator|+
literal|32
argument_list|,
name|zip
operator|->
name|central_directory_entries
argument_list|)
expr_stmt|;
name|archive_le64enc
argument_list|(
name|buff
operator|+
literal|40
argument_list|,
name|offset_end
operator|-
name|offset_start
argument_list|)
expr_stmt|;
name|archive_le64enc
argument_list|(
name|buff
operator|+
literal|48
argument_list|,
name|offset_start
argument_list|)
expr_stmt|;
name|ret
operator|=
name|__archive_write_output
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
literal|56
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|zip
operator|->
name|written_bytes
operator|+=
literal|56
expr_stmt|;
comment|/* Zip64 end-of-cd locator record. */
name|memset
argument_list|(
name|buff
argument_list|,
literal|0
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buff
argument_list|,
literal|"PK\006\007"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|archive_le32enc
argument_list|(
name|buff
operator|+
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|archive_le64enc
argument_list|(
name|buff
operator|+
literal|8
argument_list|,
name|offset_end
argument_list|)
expr_stmt|;
name|archive_le32enc
argument_list|(
name|buff
operator|+
literal|16
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|__archive_write_output
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|zip
operator|->
name|written_bytes
operator|+=
literal|20
expr_stmt|;
block|}
comment|/* Format and write end of central directory. */
name|memset
argument_list|(
name|buff
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buff
argument_list|,
literal|"PK\005\006"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|archive_le16enc
argument_list|(
name|buff
operator|+
literal|8
argument_list|,
operator|(
name|uint16_t
operator|)
name|zipmin
argument_list|(
literal|0xffffU
argument_list|,
name|zip
operator|->
name|central_directory_entries
argument_list|)
argument_list|)
expr_stmt|;
name|archive_le16enc
argument_list|(
name|buff
operator|+
literal|10
argument_list|,
operator|(
name|uint16_t
operator|)
name|zipmin
argument_list|(
literal|0xffffU
argument_list|,
name|zip
operator|->
name|central_directory_entries
argument_list|)
argument_list|)
expr_stmt|;
name|archive_le32enc
argument_list|(
name|buff
operator|+
literal|12
argument_list|,
operator|(
name|uint32_t
operator|)
name|zipmin
argument_list|(
name|ZIP_4GB_MAX
argument_list|,
operator|(
name|offset_end
operator|-
name|offset_start
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|archive_le32enc
argument_list|(
name|buff
operator|+
literal|16
argument_list|,
operator|(
name|uint32_t
operator|)
name|zipmin
argument_list|(
name|ZIP_4GB_MAX
argument_list|,
name|offset_start
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|__archive_write_output
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
literal|22
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|zip
operator|->
name|written_bytes
operator|+=
literal|22
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_write_zip_free
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
decl_stmt|;
name|struct
name|cd_segment
modifier|*
name|segment
decl_stmt|;
name|zip
operator|=
name|a
operator|->
name|format_data
expr_stmt|;
while|while
condition|(
name|zip
operator|->
name|central_directory
operator|!=
name|NULL
condition|)
block|{
name|segment
operator|=
name|zip
operator|->
name|central_directory
expr_stmt|;
name|zip
operator|->
name|central_directory
operator|=
name|segment
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|segment
operator|->
name|buff
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|segment
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|zip
operator|->
name|buf
argument_list|)
expr_stmt|;
name|archive_entry_free
argument_list|(
name|zip
operator|->
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|cctx_valid
condition|)
name|archive_encrypto_aes_ctr_release
argument_list|(
operator|&
name|zip
operator|->
name|cctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|hctx_valid
condition|)
name|archive_hmac_sha1_cleanup
argument_list|(
operator|&
name|zip
operator|->
name|hctx
argument_list|)
expr_stmt|;
comment|/* TODO: Free opt_sconv, sconv_default */
name|free
argument_list|(
name|zip
argument_list|)
expr_stmt|;
name|a
operator|->
name|format_data
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert into MSDOS-style date/time. */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|dos_time
parameter_list|(
specifier|const
name|time_t
name|unix_time
parameter_list|)
block|{
name|struct
name|tm
modifier|*
name|t
decl_stmt|;
name|unsigned
name|int
name|dt
decl_stmt|;
comment|/* This will not preserve time when creating/extracting the archive 	 * on two systems with different time zones. */
name|t
operator|=
name|localtime
argument_list|(
operator|&
name|unix_time
argument_list|)
expr_stmt|;
comment|/* MSDOS-style date/time is only between 1980-01-01 and 2107-12-31 */
if|if
condition|(
name|t
operator|->
name|tm_year
operator|<
literal|1980
operator|-
literal|1900
condition|)
comment|/* Set minimum date/time '1980-01-01 00:00:00'. */
name|dt
operator|=
literal|0x00210000U
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|tm_year
operator|>
literal|2107
operator|-
literal|1900
condition|)
comment|/* Set maximum date/time '2107-12-31 23:59:58'. */
name|dt
operator|=
literal|0xff9fbf7dU
expr_stmt|;
else|else
block|{
name|dt
operator|=
literal|0
expr_stmt|;
name|dt
operator|+=
operator|(
operator|(
name|t
operator|->
name|tm_year
operator|-
literal|80
operator|)
operator|&
literal|0x7f
operator|)
operator|<<
literal|9
expr_stmt|;
name|dt
operator|+=
operator|(
operator|(
name|t
operator|->
name|tm_mon
operator|+
literal|1
operator|)
operator|&
literal|0x0f
operator|)
operator|<<
literal|5
expr_stmt|;
name|dt
operator|+=
operator|(
name|t
operator|->
name|tm_mday
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|dt
operator|<<=
literal|16
expr_stmt|;
name|dt
operator|+=
operator|(
name|t
operator|->
name|tm_hour
operator|&
literal|0x1f
operator|)
operator|<<
literal|11
expr_stmt|;
name|dt
operator|+=
operator|(
name|t
operator|->
name|tm_min
operator|&
literal|0x3f
operator|)
operator|<<
literal|5
expr_stmt|;
name|dt
operator|+=
operator|(
name|t
operator|->
name|tm_sec
operator|&
literal|0x3e
operator|)
operator|>>
literal|1
expr_stmt|;
comment|/* Only counting every 2 seconds. */
block|}
return|return
name|dt
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|path_length
parameter_list|(
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|mode_t
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|type
operator|=
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|path
operator|=
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|type
operator|==
name|AE_IFDIR
operator|&&
operator|(
name|path
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|path
index|[
name|strlen
argument_list|(
name|path
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|)
condition|)
block|{
return|return
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
return|;
block|}
else|else
block|{
return|return
name|strlen
argument_list|(
name|path
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|write_path
parameter_list|(
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|archive_write
modifier|*
name|archive
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|mode_t
name|type
decl_stmt|;
name|size_t
name|written_bytes
decl_stmt|;
name|path
operator|=
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|type
operator|=
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|written_bytes
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|__archive_write_output
argument_list|(
name|archive
argument_list|,
name|path
argument_list|,
name|strlen
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|written_bytes
operator|+=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
comment|/* Folders are recognized by a trailing slash. */
if|if
condition|(
operator|(
name|type
operator|==
name|AE_IFDIR
operator|)
operator|&
operator|(
name|path
index|[
name|strlen
argument_list|(
name|path
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|)
condition|)
block|{
name|ret
operator|=
name|__archive_write_output
argument_list|(
name|archive
argument_list|,
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|written_bytes
operator|+=
literal|1
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|int
operator|)
name|written_bytes
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|copy_path
parameter_list|(
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|unsigned
name|char
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|size_t
name|pathlen
decl_stmt|;
name|mode_t
name|type
decl_stmt|;
name|path
operator|=
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|pathlen
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|type
operator|=
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|path
argument_list|,
name|pathlen
argument_list|)
expr_stmt|;
comment|/* Folders are recognized by a trailing slash. */
if|if
condition|(
operator|(
name|type
operator|==
name|AE_IFDIR
operator|)
operator|&
operator|(
name|path
index|[
name|pathlen
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|)
condition|)
block|{
name|p
index|[
name|pathlen
index|]
operator|=
literal|'/'
expr_stmt|;
name|p
index|[
name|pathlen
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|archive_string_conv
modifier|*
name|get_sconv
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|zip
modifier|*
name|zip
parameter_list|)
block|{
if|if
condition|(
name|zip
operator|->
name|opt_sconv
operator|!=
name|NULL
condition|)
return|return
operator|(
name|zip
operator|->
name|opt_sconv
operator|)
return|;
if|if
condition|(
operator|!
name|zip
operator|->
name|init_default_conversion
condition|)
block|{
name|zip
operator|->
name|sconv_default
operator|=
name|archive_string_default_conversion_for_write
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|)
expr_stmt|;
name|zip
operator|->
name|init_default_conversion
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|zip
operator|->
name|sconv_default
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   Traditional PKWARE Decryption functions.  */
end_comment

begin_function
specifier|static
name|void
name|trad_enc_update_keys
parameter_list|(
name|struct
name|trad_enc_ctx
modifier|*
name|ctx
parameter_list|,
name|uint8_t
name|c
parameter_list|)
block|{
name|uint8_t
name|t
decl_stmt|;
define|#
directive|define
name|CRC32
parameter_list|(
name|c
parameter_list|,
name|b
parameter_list|)
value|(crc32(c ^ 0xffffffffUL,&b, 1) ^ 0xffffffffUL)
name|ctx
operator|->
name|keys
index|[
literal|0
index|]
operator|=
name|CRC32
argument_list|(
name|ctx
operator|->
name|keys
index|[
literal|0
index|]
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|keys
index|[
literal|1
index|]
operator|=
operator|(
name|ctx
operator|->
name|keys
index|[
literal|1
index|]
operator|+
operator|(
name|ctx
operator|->
name|keys
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|)
operator|*
literal|134775813L
operator|+
literal|1
expr_stmt|;
name|t
operator|=
operator|(
name|ctx
operator|->
name|keys
index|[
literal|1
index|]
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|ctx
operator|->
name|keys
index|[
literal|2
index|]
operator|=
name|CRC32
argument_list|(
name|ctx
operator|->
name|keys
index|[
literal|2
index|]
argument_list|,
name|t
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|CRC32
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|trad_enc_decypt_byte
parameter_list|(
name|struct
name|trad_enc_ctx
modifier|*
name|ctx
parameter_list|)
block|{
name|unsigned
name|temp
init|=
name|ctx
operator|->
name|keys
index|[
literal|2
index|]
operator||
literal|2
decl_stmt|;
return|return
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|temp
operator|*
operator|(
name|temp
operator|^
literal|1
operator|)
operator|)
operator|>>
literal|8
argument_list|)
operator|&
literal|0xff
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|trad_enc_encrypt_update
parameter_list|(
name|struct
name|trad_enc_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|in
parameter_list|,
name|size_t
name|in_len
parameter_list|,
name|uint8_t
modifier|*
name|out
parameter_list|,
name|size_t
name|out_len
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|max
decl_stmt|;
name|max
operator|=
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|in_len
operator|<
name|out_len
operator|)
condition|?
name|in_len
else|:
name|out_len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|uint8_t
name|t
init|=
name|in
index|[
name|i
index|]
decl_stmt|;
name|out
index|[
name|i
index|]
operator|=
name|t
operator|^
name|trad_enc_decypt_byte
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|trad_enc_update_keys
argument_list|(
name|ctx
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|trad_enc_init
parameter_list|(
name|struct
name|trad_enc_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|pw
parameter_list|,
name|size_t
name|pw_len
parameter_list|)
block|{
name|ctx
operator|->
name|keys
index|[
literal|0
index|]
operator|=
literal|305419896L
expr_stmt|;
name|ctx
operator|->
name|keys
index|[
literal|1
index|]
operator|=
literal|591751049L
expr_stmt|;
name|ctx
operator|->
name|keys
index|[
literal|2
index|]
operator|=
literal|878082192L
expr_stmt|;
for|for
control|(
init|;
name|pw_len
condition|;
operator|--
name|pw_len
control|)
name|trad_enc_update_keys
argument_list|(
name|ctx
argument_list|,
operator|*
name|pw
operator|++
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_traditional_pkware_encryption_supported
parameter_list|(
name|void
parameter_list|)
block|{
name|uint8_t
name|key
index|[
name|TRAD_HEADER_SIZE
index|]
decl_stmt|;
if|if
condition|(
name|archive_random
argument_list|(
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
operator|-
literal|1
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_traditional_pkware_encryption
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
init|=
name|a
operator|->
name|format_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|passphrase
decl_stmt|;
name|uint8_t
name|key
index|[
name|TRAD_HEADER_SIZE
index|]
decl_stmt|;
name|uint8_t
name|key_encrypted
index|[
name|TRAD_HEADER_SIZE
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|passphrase
operator|=
name|__archive_write_get_passphrase
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|passphrase
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Encryption needs passphrase"
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_FAILED
return|;
block|}
if|if
condition|(
name|archive_random
argument_list|(
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
operator|-
literal|1
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Can't generate random number for encryption"
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_FATAL
return|;
block|}
name|trad_enc_init
argument_list|(
operator|&
name|zip
operator|->
name|tctx
argument_list|,
name|passphrase
argument_list|,
name|strlen
argument_list|(
name|passphrase
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the last key code which will be used as a check code 	 * for verifying passphrase in decryption. */
name|key
index|[
name|TRAD_HEADER_SIZE
operator|-
literal|1
index|]
operator|=
name|zip
operator|->
name|trad_chkdat
expr_stmt|;
name|trad_enc_encrypt_update
argument_list|(
operator|&
name|zip
operator|->
name|tctx
argument_list|,
name|key
argument_list|,
name|TRAD_HEADER_SIZE
argument_list|,
name|key_encrypted
argument_list|,
name|TRAD_HEADER_SIZE
argument_list|)
expr_stmt|;
comment|/* Write encrypted keys in the top of the file content. */
name|ret
operator|=
name|__archive_write_output
argument_list|(
name|a
argument_list|,
name|key_encrypted
argument_list|,
name|TRAD_HEADER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|zip
operator|->
name|written_bytes
operator|+=
name|TRAD_HEADER_SIZE
expr_stmt|;
name|zip
operator|->
name|entry_compressed_written
operator|+=
name|TRAD_HEADER_SIZE
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_winzip_aes_encryption
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
init|=
name|a
operator|->
name|format_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|passphrase
decl_stmt|;
name|size_t
name|key_len
decl_stmt|,
name|salt_len
decl_stmt|;
name|uint8_t
name|salt
index|[
literal|16
operator|+
literal|2
index|]
decl_stmt|;
name|uint8_t
name|derived_key
index|[
name|MAX_DERIVED_KEY_BUF_SIZE
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|passphrase
operator|=
name|__archive_write_get_passphrase
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|passphrase
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Encryption needs passphrase"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
if|if
condition|(
name|zip
operator|->
name|entry_encryption
operator|==
name|ENCRYPTION_WINZIP_AES128
condition|)
block|{
name|salt_len
operator|=
literal|8
expr_stmt|;
name|key_len
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
comment|/* AES 256 */
name|salt_len
operator|=
literal|16
expr_stmt|;
name|key_len
operator|=
literal|32
expr_stmt|;
block|}
if|if
condition|(
name|archive_random
argument_list|(
name|salt
argument_list|,
name|salt_len
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Can't generate random number for encryption"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_pbkdf2_sha1
argument_list|(
name|passphrase
argument_list|,
name|strlen
argument_list|(
name|passphrase
argument_list|)
argument_list|,
name|salt
argument_list|,
name|salt_len
argument_list|,
literal|1000
argument_list|,
name|derived_key
argument_list|,
name|key_len
operator|*
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
name|ret
operator|=
name|archive_encrypto_aes_ctr_init
argument_list|(
operator|&
name|zip
operator|->
name|cctx
argument_list|,
name|derived_key
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Decryption is unsupported due to lack of crypto library"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|ret
operator|=
name|archive_hmac_sha1_init
argument_list|(
operator|&
name|zip
operator|->
name|hctx
argument_list|,
name|derived_key
operator|+
name|key_len
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|archive_encrypto_aes_ctr_release
argument_list|(
operator|&
name|zip
operator|->
name|cctx
argument_list|)
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Failed to initialize HMAC-SHA1"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
comment|/* Set a passowrd verification value after the 'salt'. */
name|salt
index|[
name|salt_len
index|]
operator|=
name|derived_key
index|[
name|key_len
operator|*
literal|2
index|]
expr_stmt|;
name|salt
index|[
name|salt_len
operator|+
literal|1
index|]
operator|=
name|derived_key
index|[
name|key_len
operator|*
literal|2
operator|+
literal|1
index|]
expr_stmt|;
comment|/* Write encrypted keys in the top of the file content. */
name|ret
operator|=
name|__archive_write_output
argument_list|(
name|a
argument_list|,
name|salt
argument_list|,
name|salt_len
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|zip
operator|->
name|written_bytes
operator|+=
name|salt_len
operator|+
literal|2
expr_stmt|;
name|zip
operator|->
name|entry_compressed_written
operator|+=
name|salt_len
operator|+
literal|2
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_winzip_aes_encryption_supported
parameter_list|(
name|int
name|encryption
parameter_list|)
block|{
name|size_t
name|key_len
decl_stmt|,
name|salt_len
decl_stmt|;
name|uint8_t
name|salt
index|[
literal|16
operator|+
literal|2
index|]
decl_stmt|;
name|uint8_t
name|derived_key
index|[
name|MAX_DERIVED_KEY_BUF_SIZE
index|]
decl_stmt|;
name|archive_crypto_ctx
name|cctx
decl_stmt|;
name|archive_hmac_sha1_ctx
name|hctx
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|encryption
operator|==
name|ENCRYPTION_WINZIP_AES128
condition|)
block|{
name|salt_len
operator|=
literal|8
expr_stmt|;
name|key_len
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
comment|/* AES 256 */
name|salt_len
operator|=
literal|16
expr_stmt|;
name|key_len
operator|=
literal|32
expr_stmt|;
block|}
if|if
condition|(
name|archive_random
argument_list|(
name|salt
argument_list|,
name|salt_len
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ret
operator|=
name|archive_pbkdf2_sha1
argument_list|(
literal|"p"
argument_list|,
literal|1
argument_list|,
name|salt
argument_list|,
name|salt_len
argument_list|,
literal|1000
argument_list|,
name|derived_key
argument_list|,
name|key_len
operator|*
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ret
operator|=
name|archive_encrypto_aes_ctr_init
argument_list|(
operator|&
name|cctx
argument_list|,
name|derived_key
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ret
operator|=
name|archive_hmac_sha1_init
argument_list|(
operator|&
name|hctx
argument_list|,
name|derived_key
operator|+
name|key_len
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
name|archive_encrypto_aes_ctr_release
argument_list|(
operator|&
name|cctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|archive_hmac_sha1_cleanup
argument_list|(
operator|&
name|hctx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

