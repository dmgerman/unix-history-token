begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*- * Copyright (c) 2003-2007 Tim Kientzle * Copyright (c) 2011 Andres Mejia * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in the *    documentation and/or other materials provided with the distribution. * * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT, * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
end_comment

begin_include
include|#
directive|include
file|"archive_platform.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ERRNO_H
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_comment
comment|/* crc32 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"archive.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_ZLIB_H
end_ifndef

begin_include
include|#
directive|include
file|"archive_crc32.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"archive_endian.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry_locale.h"
end_include

begin_include
include|#
directive|include
file|"archive_ppmd7_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_read_private.h"
end_include

begin_comment
comment|/* RAR signature, also known as the mark header */
end_comment

begin_define
define|#
directive|define
name|RAR_SIGNATURE
value|"\x52\x61\x72\x21\x1A\x07\x00"
end_define

begin_comment
comment|/* Header types */
end_comment

begin_define
define|#
directive|define
name|MARK_HEAD
value|0x72
end_define

begin_define
define|#
directive|define
name|MAIN_HEAD
value|0x73
end_define

begin_define
define|#
directive|define
name|FILE_HEAD
value|0x74
end_define

begin_define
define|#
directive|define
name|COMM_HEAD
value|0x75
end_define

begin_define
define|#
directive|define
name|AV_HEAD
value|0x76
end_define

begin_define
define|#
directive|define
name|SUB_HEAD
value|0x77
end_define

begin_define
define|#
directive|define
name|PROTECT_HEAD
value|0x78
end_define

begin_define
define|#
directive|define
name|SIGN_HEAD
value|0x79
end_define

begin_define
define|#
directive|define
name|NEWSUB_HEAD
value|0x7a
end_define

begin_define
define|#
directive|define
name|ENDARC_HEAD
value|0x7b
end_define

begin_comment
comment|/* Main Header Flags */
end_comment

begin_define
define|#
directive|define
name|MHD_VOLUME
value|0x0001
end_define

begin_define
define|#
directive|define
name|MHD_COMMENT
value|0x0002
end_define

begin_define
define|#
directive|define
name|MHD_LOCK
value|0x0004
end_define

begin_define
define|#
directive|define
name|MHD_SOLID
value|0x0008
end_define

begin_define
define|#
directive|define
name|MHD_NEWNUMBERING
value|0x0010
end_define

begin_define
define|#
directive|define
name|MHD_AV
value|0x0020
end_define

begin_define
define|#
directive|define
name|MHD_PROTECT
value|0x0040
end_define

begin_define
define|#
directive|define
name|MHD_PASSWORD
value|0x0080
end_define

begin_define
define|#
directive|define
name|MHD_FIRSTVOLUME
value|0x0100
end_define

begin_define
define|#
directive|define
name|MHD_ENCRYPTVER
value|0x0200
end_define

begin_comment
comment|/* Flags common to all headers */
end_comment

begin_define
define|#
directive|define
name|HD_MARKDELETION
value|0x4000
end_define

begin_define
define|#
directive|define
name|HD_ADD_SIZE_PRESENT
value|0x8000
end_define

begin_comment
comment|/* File Header Flags */
end_comment

begin_define
define|#
directive|define
name|FHD_SPLIT_BEFORE
value|0x0001
end_define

begin_define
define|#
directive|define
name|FHD_SPLIT_AFTER
value|0x0002
end_define

begin_define
define|#
directive|define
name|FHD_PASSWORD
value|0x0004
end_define

begin_define
define|#
directive|define
name|FHD_COMMENT
value|0x0008
end_define

begin_define
define|#
directive|define
name|FHD_SOLID
value|0x0010
end_define

begin_define
define|#
directive|define
name|FHD_LARGE
value|0x0100
end_define

begin_define
define|#
directive|define
name|FHD_UNICODE
value|0x0200
end_define

begin_define
define|#
directive|define
name|FHD_SALT
value|0x0400
end_define

begin_define
define|#
directive|define
name|FHD_VERSION
value|0x0800
end_define

begin_define
define|#
directive|define
name|FHD_EXTTIME
value|0x1000
end_define

begin_define
define|#
directive|define
name|FHD_EXTFLAGS
value|0x2000
end_define

begin_comment
comment|/* File dictionary sizes */
end_comment

begin_define
define|#
directive|define
name|DICTIONARY_SIZE_64
value|0x00
end_define

begin_define
define|#
directive|define
name|DICTIONARY_SIZE_128
value|0x20
end_define

begin_define
define|#
directive|define
name|DICTIONARY_SIZE_256
value|0x40
end_define

begin_define
define|#
directive|define
name|DICTIONARY_SIZE_512
value|0x60
end_define

begin_define
define|#
directive|define
name|DICTIONARY_SIZE_1024
value|0x80
end_define

begin_define
define|#
directive|define
name|DICTIONARY_SIZE_2048
value|0xA0
end_define

begin_define
define|#
directive|define
name|DICTIONARY_SIZE_4096
value|0xC0
end_define

begin_define
define|#
directive|define
name|FILE_IS_DIRECTORY
value|0xE0
end_define

begin_define
define|#
directive|define
name|DICTIONARY_MASK
value|FILE_IS_DIRECTORY
end_define

begin_comment
comment|/* OS Flags */
end_comment

begin_define
define|#
directive|define
name|OS_MSDOS
value|0
end_define

begin_define
define|#
directive|define
name|OS_OS2
value|1
end_define

begin_define
define|#
directive|define
name|OS_WIN32
value|2
end_define

begin_define
define|#
directive|define
name|OS_UNIX
value|3
end_define

begin_define
define|#
directive|define
name|OS_MAC_OS
value|4
end_define

begin_define
define|#
directive|define
name|OS_BEOS
value|5
end_define

begin_comment
comment|/* Compression Methods */
end_comment

begin_define
define|#
directive|define
name|COMPRESS_METHOD_STORE
value|0x30
end_define

begin_comment
comment|/* LZSS */
end_comment

begin_define
define|#
directive|define
name|COMPRESS_METHOD_FASTEST
value|0x31
end_define

begin_define
define|#
directive|define
name|COMPRESS_METHOD_FAST
value|0x32
end_define

begin_define
define|#
directive|define
name|COMPRESS_METHOD_NORMAL
value|0x33
end_define

begin_comment
comment|/* PPMd Variant H */
end_comment

begin_define
define|#
directive|define
name|COMPRESS_METHOD_GOOD
value|0x34
end_define

begin_define
define|#
directive|define
name|COMPRESS_METHOD_BEST
value|0x35
end_define

begin_define
define|#
directive|define
name|CRC_POLYNOMIAL
value|0xEDB88320
end_define

begin_define
define|#
directive|define
name|NS_UNIT
value|10000000
end_define

begin_define
define|#
directive|define
name|DICTIONARY_MAX_SIZE
value|0x400000
end_define

begin_define
define|#
directive|define
name|MAINCODE_SIZE
value|299
end_define

begin_define
define|#
directive|define
name|OFFSETCODE_SIZE
value|60
end_define

begin_define
define|#
directive|define
name|LOWOFFSETCODE_SIZE
value|17
end_define

begin_define
define|#
directive|define
name|LENGTHCODE_SIZE
value|28
end_define

begin_define
define|#
directive|define
name|HUFFMAN_TABLE_SIZE
define|\
value|MAINCODE_SIZE + OFFSETCODE_SIZE + LOWOFFSETCODE_SIZE + LENGTHCODE_SIZE
end_define

begin_define
define|#
directive|define
name|MAX_SYMBOL_LENGTH
value|0xF
end_define

begin_define
define|#
directive|define
name|MAX_SYMBOLS
value|20
end_define

begin_comment
comment|/*  * Considering L1,L2 cache miss and a calling of write system-call,  * the best size of the output buffer(uncompressed buffer) is 128K.  * If the structure of extracting process is changed, this value  * might be researched again.  */
end_comment

begin_define
define|#
directive|define
name|UNP_BUFFER_SIZE
value|(128 * 1024)
end_define

begin_comment
comment|/* Define this here for non-Windows platforms */
end_comment

begin_if
if|#
directive|if
operator|!
operator|(
operator|(
name|defined
argument_list|(
name|__WIN32__
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__WIN32
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|FILE_ATTRIBUTE_DIRECTORY
value|0x10
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Fields common to all headers */
end_comment

begin_struct
struct|struct
name|rar_header
block|{
name|char
name|crc
index|[
literal|2
index|]
decl_stmt|;
name|char
name|type
decl_stmt|;
name|char
name|flags
index|[
literal|2
index|]
decl_stmt|;
name|char
name|size
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Fields common to all file headers */
end_comment

begin_struct
struct|struct
name|rar_file_header
block|{
name|char
name|pack_size
index|[
literal|4
index|]
decl_stmt|;
name|char
name|unp_size
index|[
literal|4
index|]
decl_stmt|;
name|char
name|host_os
decl_stmt|;
name|char
name|file_crc
index|[
literal|4
index|]
decl_stmt|;
name|char
name|file_time
index|[
literal|4
index|]
decl_stmt|;
name|char
name|unp_ver
decl_stmt|;
name|char
name|method
decl_stmt|;
name|char
name|name_size
index|[
literal|2
index|]
decl_stmt|;
name|char
name|file_attr
index|[
literal|4
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|huffman_tree_node
block|{
name|int
name|branches
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|huffman_table_entry
block|{
name|unsigned
name|int
name|length
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|huffman_code
block|{
name|struct
name|huffman_tree_node
modifier|*
name|tree
decl_stmt|;
name|int
name|numentries
decl_stmt|;
name|int
name|numallocatedentries
decl_stmt|;
name|int
name|minlength
decl_stmt|;
name|int
name|maxlength
decl_stmt|;
name|int
name|tablesize
decl_stmt|;
name|struct
name|huffman_table_entry
modifier|*
name|table
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|lzss
block|{
name|unsigned
name|char
modifier|*
name|window
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|int64_t
name|position
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|data_block_offsets
block|{
name|int64_t
name|header_size
decl_stmt|;
name|int64_t
name|start_offset
decl_stmt|;
name|int64_t
name|end_offset
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|rar
block|{
comment|/* Entries from main RAR header */
name|unsigned
name|main_flags
decl_stmt|;
name|unsigned
name|long
name|file_crc
decl_stmt|;
name|char
name|reserved1
index|[
literal|2
index|]
decl_stmt|;
name|char
name|reserved2
index|[
literal|4
index|]
decl_stmt|;
name|char
name|encryptver
decl_stmt|;
comment|/* File header entries */
name|char
name|compression_method
decl_stmt|;
name|unsigned
name|file_flags
decl_stmt|;
name|int64_t
name|packed_size
decl_stmt|;
name|int64_t
name|unp_size
decl_stmt|;
name|time_t
name|mtime
decl_stmt|;
name|long
name|mnsec
decl_stmt|;
name|mode_t
name|mode
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|filename_save
decl_stmt|;
name|size_t
name|filename_save_size
decl_stmt|;
name|size_t
name|filename_allocated
decl_stmt|;
comment|/* File header optional entries */
name|char
name|salt
index|[
literal|8
index|]
decl_stmt|;
name|time_t
name|atime
decl_stmt|;
name|long
name|ansec
decl_stmt|;
name|time_t
name|ctime
decl_stmt|;
name|long
name|cnsec
decl_stmt|;
name|time_t
name|arctime
decl_stmt|;
name|long
name|arcnsec
decl_stmt|;
comment|/* Fields to help with tracking decompression of files. */
name|int64_t
name|bytes_unconsumed
decl_stmt|;
name|int64_t
name|bytes_remaining
decl_stmt|;
name|int64_t
name|bytes_uncopied
decl_stmt|;
name|int64_t
name|offset
decl_stmt|;
name|int64_t
name|offset_outgoing
decl_stmt|;
name|int64_t
name|offset_seek
decl_stmt|;
name|char
name|valid
decl_stmt|;
name|unsigned
name|int
name|unp_offset
decl_stmt|;
name|unsigned
name|int
name|unp_buffer_size
decl_stmt|;
name|unsigned
name|char
modifier|*
name|unp_buffer
decl_stmt|;
name|unsigned
name|int
name|dictionary_size
decl_stmt|;
name|char
name|start_new_block
decl_stmt|;
name|char
name|entry_eof
decl_stmt|;
name|unsigned
name|long
name|crc_calculated
decl_stmt|;
name|int
name|found_first_header
decl_stmt|;
name|char
name|has_endarc_header
decl_stmt|;
name|struct
name|data_block_offsets
modifier|*
name|dbo
decl_stmt|;
name|unsigned
name|int
name|cursor
decl_stmt|;
name|unsigned
name|int
name|nodes
decl_stmt|;
comment|/* LZSS members */
name|struct
name|huffman_code
name|maincode
decl_stmt|;
name|struct
name|huffman_code
name|offsetcode
decl_stmt|;
name|struct
name|huffman_code
name|lowoffsetcode
decl_stmt|;
name|struct
name|huffman_code
name|lengthcode
decl_stmt|;
name|unsigned
name|char
name|lengthtable
index|[
name|HUFFMAN_TABLE_SIZE
index|]
decl_stmt|;
name|struct
name|lzss
name|lzss
decl_stmt|;
name|char
name|output_last_match
decl_stmt|;
name|unsigned
name|int
name|lastlength
decl_stmt|;
name|unsigned
name|int
name|lastoffset
decl_stmt|;
name|unsigned
name|int
name|oldoffset
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|int
name|lastlowoffset
decl_stmt|;
name|unsigned
name|int
name|numlowoffsetrepeats
decl_stmt|;
name|int64_t
name|filterstart
decl_stmt|;
name|char
name|start_new_table
decl_stmt|;
comment|/* PPMd Variant H members */
name|char
name|ppmd_valid
decl_stmt|;
name|char
name|ppmd_eod
decl_stmt|;
name|char
name|is_ppmd_block
decl_stmt|;
name|int
name|ppmd_escape
decl_stmt|;
name|CPpmd7
name|ppmd7_context
decl_stmt|;
name|CPpmd7z_RangeDec
name|range_dec
decl_stmt|;
name|IByteIn
name|bytein
decl_stmt|;
comment|/*    * String conversion object.    */
name|int
name|init_default_conversion
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|sconv_default
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|opt_sconv
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|sconv_utf8
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|sconv_utf16be
decl_stmt|;
comment|/*    * Bit stream reader.    */
struct|struct
name|rar_br
block|{
define|#
directive|define
name|CACHE_TYPE
value|uint64_t
define|#
directive|define
name|CACHE_BITS
value|(8 * sizeof(CACHE_TYPE))
comment|/* Cache buffer. */
name|CACHE_TYPE
name|cache_buffer
decl_stmt|;
comment|/* Indicates how many bits avail in cache_buffer. */
name|int
name|cache_avail
decl_stmt|;
name|ssize_t
name|avail_in
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|next_in
decl_stmt|;
block|}
name|br
struct|;
comment|/*    * Custom field to denote that this archive contains encrypted entries    */
name|int
name|has_encrypted_entries
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|archive_read_support_format_rar_capabilities
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_rar_has_encrypted_entries
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_rar_bid
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_rar_options
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_rar_read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_rar_read_data
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|int64_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_rar_read_data_skip
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|archive_read_format_rar_seek_data
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|int64_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_rar_cleanup
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Support functions */
end_comment

begin_function_decl
specifier|static
name|int
name|read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|time_t
name|get_time
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_exttime
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|rar
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_symlink_stored
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_data_stored
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|int64_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_data_compressed
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|int64_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rar_br_preparation
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|rar_br
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_codes
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_codes
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_next_symbol
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|huffman_code
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|create_code
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|huffman_code
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_value
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|huffman_code
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|new_node
parameter_list|(
name|struct
name|huffman_code
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|make_table
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|huffman_code
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|make_table_recurse
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|huffman_code
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|huffman_table_entry
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|expand
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|copy_from_lzss_window
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
parameter_list|,
name|int64_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|void
modifier|*
name|rar_read_ahead
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|ssize_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Bit stream reader.  */
end_comment

begin_comment
comment|/* Check that the cache buffer has enough bits. */
end_comment

begin_define
define|#
directive|define
name|rar_br_has
parameter_list|(
name|br
parameter_list|,
name|n
parameter_list|)
value|((br)->cache_avail>= n)
end_define

begin_comment
comment|/* Get compressed data by bit. */
end_comment

begin_define
define|#
directive|define
name|rar_br_bits
parameter_list|(
name|br
parameter_list|,
name|n
parameter_list|)
define|\
value|(((uint32_t)((br)->cache_buffer>>    \     ((br)->cache_avail - (n))))& cache_masks[n])
end_define

begin_define
define|#
directive|define
name|rar_br_bits_forced
parameter_list|(
name|br
parameter_list|,
name|n
parameter_list|)
define|\
value|(((uint32_t)((br)->cache_buffer<<    \     ((n) - (br)->cache_avail)))& cache_masks[n])
end_define

begin_comment
comment|/* Read ahead to make sure the cache buffer has enough compressed data we  * will use.  *  True  : completed, there is enough data in the cache buffer.  *  False : there is no data in the stream. */
end_comment

begin_define
define|#
directive|define
name|rar_br_read_ahead
parameter_list|(
name|a
parameter_list|,
name|br
parameter_list|,
name|n
parameter_list|)
define|\
value|((rar_br_has(br, (n)) || rar_br_fillup(a, br)) || rar_br_has(br, (n)))
end_define

begin_comment
comment|/* Notify how many bits we consumed. */
end_comment

begin_define
define|#
directive|define
name|rar_br_consume
parameter_list|(
name|br
parameter_list|,
name|n
parameter_list|)
value|((br)->cache_avail -= (n))
end_define

begin_define
define|#
directive|define
name|rar_br_consume_unalined_bits
parameter_list|(
name|br
parameter_list|)
value|((br)->cache_avail&= ~7)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|uint32_t
name|cache_masks
index|[]
init|=
block|{
literal|0x00000000
block|,
literal|0x00000001
block|,
literal|0x00000003
block|,
literal|0x00000007
block|,
literal|0x0000000F
block|,
literal|0x0000001F
block|,
literal|0x0000003F
block|,
literal|0x0000007F
block|,
literal|0x000000FF
block|,
literal|0x000001FF
block|,
literal|0x000003FF
block|,
literal|0x000007FF
block|,
literal|0x00000FFF
block|,
literal|0x00001FFF
block|,
literal|0x00003FFF
block|,
literal|0x00007FFF
block|,
literal|0x0000FFFF
block|,
literal|0x0001FFFF
block|,
literal|0x0003FFFF
block|,
literal|0x0007FFFF
block|,
literal|0x000FFFFF
block|,
literal|0x001FFFFF
block|,
literal|0x003FFFFF
block|,
literal|0x007FFFFF
block|,
literal|0x00FFFFFF
block|,
literal|0x01FFFFFF
block|,
literal|0x03FFFFFF
block|,
literal|0x07FFFFFF
block|,
literal|0x0FFFFFFF
block|,
literal|0x1FFFFFFF
block|,
literal|0x3FFFFFFF
block|,
literal|0x7FFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Shift away used bits in the cache data and fill it up with following bits.  * Call this when cache buffer does not have enough bits you need.  *  * Returns 1 if the cache buffer is full.  * Returns 0 if the cache buffer is not full; input buffer is empty.  */
end_comment

begin_function
specifier|static
name|int
name|rar_br_fillup
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|rar_br
modifier|*
name|br
parameter_list|)
block|{
name|struct
name|rar
modifier|*
name|rar
init|=
operator|(
expr|struct
name|rar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
name|int
name|n
init|=
name|CACHE_BITS
operator|-
name|br
operator|->
name|cache_avail
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|n
operator|>>
literal|3
condition|)
block|{
case|case
literal|8
case|:
if|if
condition|(
name|br
operator|->
name|avail_in
operator|>=
literal|8
condition|)
block|{
name|br
operator|->
name|cache_buffer
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|br
operator|->
name|next_in
index|[
literal|0
index|]
operator|)
operator|<<
literal|56
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|br
operator|->
name|next_in
index|[
literal|1
index|]
operator|)
operator|<<
literal|48
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|br
operator|->
name|next_in
index|[
literal|2
index|]
operator|)
operator|<<
literal|40
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|br
operator|->
name|next_in
index|[
literal|3
index|]
operator|)
operator|<<
literal|32
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|br
operator|->
name|next_in
index|[
literal|4
index|]
operator|)
operator|<<
literal|24
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|br
operator|->
name|next_in
index|[
literal|5
index|]
operator|)
operator|<<
literal|16
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|br
operator|->
name|next_in
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator||
operator|(
name|uint32_t
operator|)
name|br
operator|->
name|next_in
index|[
literal|7
index|]
expr_stmt|;
name|br
operator|->
name|next_in
operator|+=
literal|8
expr_stmt|;
name|br
operator|->
name|avail_in
operator|-=
literal|8
expr_stmt|;
name|br
operator|->
name|cache_avail
operator|+=
literal|8
operator|*
literal|8
expr_stmt|;
name|rar
operator|->
name|bytes_unconsumed
operator|+=
literal|8
expr_stmt|;
name|rar
operator|->
name|bytes_remaining
operator|-=
literal|8
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|br
operator|->
name|avail_in
operator|>=
literal|7
condition|)
block|{
name|br
operator|->
name|cache_buffer
operator|=
operator|(
name|br
operator|->
name|cache_buffer
operator|<<
literal|56
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|br
operator|->
name|next_in
index|[
literal|0
index|]
operator|)
operator|<<
literal|48
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|br
operator|->
name|next_in
index|[
literal|1
index|]
operator|)
operator|<<
literal|40
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|br
operator|->
name|next_in
index|[
literal|2
index|]
operator|)
operator|<<
literal|32
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|br
operator|->
name|next_in
index|[
literal|3
index|]
operator|)
operator|<<
literal|24
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|br
operator|->
name|next_in
index|[
literal|4
index|]
operator|)
operator|<<
literal|16
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|br
operator|->
name|next_in
index|[
literal|5
index|]
operator|)
operator|<<
literal|8
operator||
operator|(
name|uint32_t
operator|)
name|br
operator|->
name|next_in
index|[
literal|6
index|]
expr_stmt|;
name|br
operator|->
name|next_in
operator|+=
literal|7
expr_stmt|;
name|br
operator|->
name|avail_in
operator|-=
literal|7
expr_stmt|;
name|br
operator|->
name|cache_avail
operator|+=
literal|7
operator|*
literal|8
expr_stmt|;
name|rar
operator|->
name|bytes_unconsumed
operator|+=
literal|7
expr_stmt|;
name|rar
operator|->
name|bytes_remaining
operator|-=
literal|7
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|br
operator|->
name|avail_in
operator|>=
literal|6
condition|)
block|{
name|br
operator|->
name|cache_buffer
operator|=
operator|(
name|br
operator|->
name|cache_buffer
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|br
operator|->
name|next_in
index|[
literal|0
index|]
operator|)
operator|<<
literal|40
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|br
operator|->
name|next_in
index|[
literal|1
index|]
operator|)
operator|<<
literal|32
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|br
operator|->
name|next_in
index|[
literal|2
index|]
operator|)
operator|<<
literal|24
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|br
operator|->
name|next_in
index|[
literal|3
index|]
operator|)
operator|<<
literal|16
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|br
operator|->
name|next_in
index|[
literal|4
index|]
operator|)
operator|<<
literal|8
operator||
operator|(
name|uint32_t
operator|)
name|br
operator|->
name|next_in
index|[
literal|5
index|]
expr_stmt|;
name|br
operator|->
name|next_in
operator|+=
literal|6
expr_stmt|;
name|br
operator|->
name|avail_in
operator|-=
literal|6
expr_stmt|;
name|br
operator|->
name|cache_avail
operator|+=
literal|6
operator|*
literal|8
expr_stmt|;
name|rar
operator|->
name|bytes_unconsumed
operator|+=
literal|6
expr_stmt|;
name|rar
operator|->
name|bytes_remaining
operator|-=
literal|6
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
literal|0
case|:
comment|/* We have enough compressed data in        * the cache buffer.*/
return|return
operator|(
literal|1
operator|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|br
operator|->
name|avail_in
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|rar
operator|->
name|bytes_unconsumed
operator|>
literal|0
condition|)
block|{
comment|/* Consume as much as the decompressor          * actually used. */
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|rar
operator|->
name|bytes_unconsumed
argument_list|)
expr_stmt|;
name|rar
operator|->
name|bytes_unconsumed
operator|=
literal|0
expr_stmt|;
block|}
name|br
operator|->
name|next_in
operator|=
name|rar_read_ahead
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
operator|&
operator|(
name|br
operator|->
name|avail_in
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|br
operator|->
name|next_in
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|br
operator|->
name|avail_in
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|br
operator|->
name|cache_buffer
operator|=
operator|(
name|br
operator|->
name|cache_buffer
operator|<<
literal|8
operator|)
operator||
operator|*
name|br
operator|->
name|next_in
operator|++
expr_stmt|;
name|br
operator|->
name|avail_in
operator|--
expr_stmt|;
name|br
operator|->
name|cache_avail
operator|+=
literal|8
expr_stmt|;
name|n
operator|-=
literal|8
expr_stmt|;
name|rar
operator|->
name|bytes_unconsumed
operator|++
expr_stmt|;
name|rar
operator|->
name|bytes_remaining
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|rar_br_preparation
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|rar_br
modifier|*
name|br
parameter_list|)
block|{
name|struct
name|rar
modifier|*
name|rar
init|=
operator|(
expr|struct
name|rar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
if|if
condition|(
name|rar
operator|->
name|bytes_remaining
operator|>
literal|0
condition|)
block|{
name|br
operator|->
name|next_in
operator|=
name|rar_read_ahead
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
operator|&
operator|(
name|br
operator|->
name|avail_in
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|br
operator|->
name|next_in
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated RAR file data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|br
operator|->
name|cache_avail
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|rar_br_fillup
argument_list|(
name|a
argument_list|,
name|br
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find last bit set */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|rar_fls
parameter_list|(
name|unsigned
name|int
name|word
parameter_list|)
block|{
name|word
operator||=
operator|(
name|word
operator|>>
literal|1
operator|)
expr_stmt|;
name|word
operator||=
operator|(
name|word
operator|>>
literal|2
operator|)
expr_stmt|;
name|word
operator||=
operator|(
name|word
operator|>>
literal|4
operator|)
expr_stmt|;
name|word
operator||=
operator|(
name|word
operator|>>
literal|8
operator|)
expr_stmt|;
name|word
operator||=
operator|(
name|word
operator|>>
literal|16
operator|)
expr_stmt|;
return|return
name|word
operator|-
operator|(
name|word
operator|>>
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* LZSS functions */
end_comment

begin_function
specifier|static
specifier|inline
name|int64_t
name|lzss_position
parameter_list|(
name|struct
name|lzss
modifier|*
name|lzss
parameter_list|)
block|{
return|return
name|lzss
operator|->
name|position
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|lzss_mask
parameter_list|(
name|struct
name|lzss
modifier|*
name|lzss
parameter_list|)
block|{
return|return
name|lzss
operator|->
name|mask
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|lzss_size
parameter_list|(
name|struct
name|lzss
modifier|*
name|lzss
parameter_list|)
block|{
return|return
name|lzss
operator|->
name|mask
operator|+
literal|1
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|lzss_offset_for_position
parameter_list|(
name|struct
name|lzss
modifier|*
name|lzss
parameter_list|,
name|int64_t
name|pos
parameter_list|)
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|pos
operator|&
name|lzss
operator|->
name|mask
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|char
modifier|*
name|lzss_pointer_for_position
parameter_list|(
name|struct
name|lzss
modifier|*
name|lzss
parameter_list|,
name|int64_t
name|pos
parameter_list|)
block|{
return|return
operator|&
name|lzss
operator|->
name|window
index|[
name|lzss_offset_for_position
argument_list|(
name|lzss
argument_list|,
name|pos
argument_list|)
index|]
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|lzss_current_offset
parameter_list|(
name|struct
name|lzss
modifier|*
name|lzss
parameter_list|)
block|{
return|return
name|lzss_offset_for_position
argument_list|(
name|lzss
argument_list|,
name|lzss
operator|->
name|position
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint8_t
modifier|*
name|lzss_current_pointer
parameter_list|(
name|struct
name|lzss
modifier|*
name|lzss
parameter_list|)
block|{
return|return
name|lzss_pointer_for_position
argument_list|(
name|lzss
argument_list|,
name|lzss
operator|->
name|position
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|lzss_emit_literal
parameter_list|(
name|struct
name|rar
modifier|*
name|rar
parameter_list|,
name|uint8_t
name|literal
parameter_list|)
block|{
operator|*
name|lzss_current_pointer
argument_list|(
operator|&
name|rar
operator|->
name|lzss
argument_list|)
operator|=
name|literal
expr_stmt|;
name|rar
operator|->
name|lzss
operator|.
name|position
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|lzss_emit_match
parameter_list|(
name|struct
name|rar
modifier|*
name|rar
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|dstoffs
init|=
name|lzss_current_offset
argument_list|(
operator|&
name|rar
operator|->
name|lzss
argument_list|)
decl_stmt|;
name|int
name|srcoffs
init|=
operator|(
name|dstoffs
operator|-
name|offset
operator|)
operator|&
name|lzss_mask
argument_list|(
operator|&
name|rar
operator|->
name|lzss
argument_list|)
decl_stmt|;
name|int
name|l
decl_stmt|,
name|li
decl_stmt|,
name|remaining
decl_stmt|;
name|unsigned
name|char
modifier|*
name|d
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|remaining
operator|=
name|length
expr_stmt|;
while|while
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
name|l
operator|=
name|remaining
expr_stmt|;
if|if
condition|(
name|dstoffs
operator|>
name|srcoffs
condition|)
block|{
if|if
condition|(
name|l
operator|>
name|lzss_size
argument_list|(
operator|&
name|rar
operator|->
name|lzss
argument_list|)
operator|-
name|dstoffs
condition|)
name|l
operator|=
name|lzss_size
argument_list|(
operator|&
name|rar
operator|->
name|lzss
argument_list|)
operator|-
name|dstoffs
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|l
operator|>
name|lzss_size
argument_list|(
operator|&
name|rar
operator|->
name|lzss
argument_list|)
operator|-
name|srcoffs
condition|)
name|l
operator|=
name|lzss_size
argument_list|(
operator|&
name|rar
operator|->
name|lzss
argument_list|)
operator|-
name|srcoffs
expr_stmt|;
block|}
name|d
operator|=
operator|&
operator|(
name|rar
operator|->
name|lzss
operator|.
name|window
index|[
name|dstoffs
index|]
operator|)
expr_stmt|;
name|s
operator|=
operator|&
operator|(
name|rar
operator|->
name|lzss
operator|.
name|window
index|[
name|srcoffs
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|dstoffs
operator|+
name|l
operator|<
name|srcoffs
operator|)
operator|||
operator|(
name|srcoffs
operator|+
name|l
operator|<
name|dstoffs
operator|)
condition|)
name|memcpy
argument_list|(
name|d
argument_list|,
name|s
argument_list|,
name|l
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|li
operator|=
literal|0
init|;
name|li
operator|<
name|l
condition|;
name|li
operator|++
control|)
name|d
index|[
name|li
index|]
operator|=
name|s
index|[
name|li
index|]
expr_stmt|;
block|}
name|remaining
operator|-=
name|l
expr_stmt|;
name|dstoffs
operator|=
operator|(
name|dstoffs
operator|+
name|l
operator|)
operator|&
name|lzss_mask
argument_list|(
operator|&
operator|(
name|rar
operator|->
name|lzss
operator|)
argument_list|)
expr_stmt|;
name|srcoffs
operator|=
operator|(
name|srcoffs
operator|+
name|l
operator|)
operator|&
name|lzss_mask
argument_list|(
operator|&
operator|(
name|rar
operator|->
name|lzss
operator|)
argument_list|)
expr_stmt|;
block|}
name|rar
operator|->
name|lzss
operator|.
name|position
operator|+=
name|length
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|ppmd_alloc
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
operator|(
name|void
operator|)
name|p
expr_stmt|;
return|return
name|malloc
argument_list|(
name|size
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppmd_free
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|address
parameter_list|)
block|{
operator|(
name|void
operator|)
name|p
expr_stmt|;
name|free
argument_list|(
name|address
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|ISzAlloc
name|g_szalloc
init|=
block|{
name|ppmd_alloc
block|,
name|ppmd_free
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Byte
name|ppmd_read
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
operator|(
name|IByteIn
operator|*
operator|)
name|p
operator|)
operator|->
name|a
decl_stmt|;
name|struct
name|rar
modifier|*
name|rar
init|=
operator|(
expr|struct
name|rar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
name|struct
name|rar_br
modifier|*
name|br
init|=
operator|&
operator|(
name|rar
operator|->
name|br
operator|)
decl_stmt|;
name|Byte
name|b
decl_stmt|;
if|if
condition|(
operator|!
name|rar_br_read_ahead
argument_list|(
name|a
argument_list|,
name|br
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated RAR file data"
argument_list|)
expr_stmt|;
name|rar
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|b
operator|=
name|rar_br_bits
argument_list|(
name|br
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|rar_br_consume
argument_list|(
name|br
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_function
name|int
name|archive_read_support_format_rar
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|struct
name|rar
modifier|*
name|rar
decl_stmt|;
name|int
name|r
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_READ_MAGIC
argument_list|,
name|ARCHIVE_STATE_NEW
argument_list|,
literal|"archive_read_support_format_rar"
argument_list|)
expr_stmt|;
name|rar
operator|=
operator|(
expr|struct
name|rar
operator|*
operator|)
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rar
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rar
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate rar data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* 	 * Until enough data has been read, we cannot tell about 	 * any encrypted entries yet. 	 */
name|rar
operator|->
name|has_encrypted_entries
operator|=
name|ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW
expr_stmt|;
name|r
operator|=
name|__archive_read_register_format
argument_list|(
name|a
argument_list|,
name|rar
argument_list|,
literal|"rar"
argument_list|,
name|archive_read_format_rar_bid
argument_list|,
name|archive_read_format_rar_options
argument_list|,
name|archive_read_format_rar_read_header
argument_list|,
name|archive_read_format_rar_read_data
argument_list|,
name|archive_read_format_rar_read_data_skip
argument_list|,
name|archive_read_format_rar_seek_data
argument_list|,
name|archive_read_format_rar_cleanup
argument_list|,
name|archive_read_support_format_rar_capabilities
argument_list|,
name|archive_read_format_rar_has_encrypted_entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|free
argument_list|(
name|rar
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_support_format_rar_capabilities
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
operator|(
name|void
operator|)
name|a
expr_stmt|;
comment|/* UNUSED */
return|return
operator|(
name|ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_DATA
operator||
name|ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_METADATA
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_rar_has_encrypted_entries
parameter_list|(
name|struct
name|archive_read
modifier|*
name|_a
parameter_list|)
block|{
if|if
condition|(
name|_a
operator|&&
name|_a
operator|->
name|format
condition|)
block|{
name|struct
name|rar
modifier|*
name|rar
init|=
operator|(
expr|struct
name|rar
operator|*
operator|)
name|_a
operator|->
name|format
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|rar
condition|)
block|{
return|return
name|rar
operator|->
name|has_encrypted_entries
return|;
block|}
block|}
return|return
name|ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_rar_bid
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|int
name|best_bid
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
comment|/* If there's already a bid> 30, we'll never win. */
if|if
condition|(
name|best_bid
operator|>
literal|30
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|7
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|p
argument_list|,
name|RAR_SIGNATURE
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|30
operator|)
return|;
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'M'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'Z'
operator|)
operator|||
name|memcmp
argument_list|(
name|p
argument_list|,
literal|"\x7F\x45LF"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This is a PE file */
name|ssize_t
name|offset
init|=
literal|0x10000
decl_stmt|;
name|ssize_t
name|window
init|=
literal|4096
decl_stmt|;
name|ssize_t
name|bytes_avail
decl_stmt|;
while|while
condition|(
name|offset
operator|+
name|window
operator|<=
operator|(
literal|1024
operator|*
literal|128
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|buff
init|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|offset
operator|+
name|window
argument_list|,
operator|&
name|bytes_avail
argument_list|)
decl_stmt|;
if|if
condition|(
name|buff
operator|==
name|NULL
condition|)
block|{
comment|/* Remaining bytes are less than window. */
name|window
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|window
operator|<
literal|0x40
condition|)
return|return
operator|(
literal|0
operator|)
return|;
continue|continue;
block|}
name|p
operator|=
name|buff
operator|+
name|offset
expr_stmt|;
while|while
condition|(
name|p
operator|+
literal|7
operator|<
name|buff
operator|+
name|bytes_avail
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|p
argument_list|,
name|RAR_SIGNATURE
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|30
operator|)
return|;
name|p
operator|+=
literal|0x10
expr_stmt|;
block|}
name|offset
operator|=
name|p
operator|-
name|buff
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|skip_sfx
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|h
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|size_t
name|skip
decl_stmt|,
name|total
decl_stmt|;
name|ssize_t
name|bytes
decl_stmt|,
name|window
decl_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
name|window
operator|=
literal|4096
expr_stmt|;
while|while
condition|(
name|total
operator|+
name|window
operator|<=
operator|(
literal|1024
operator|*
literal|128
operator|)
condition|)
block|{
name|h
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|window
argument_list|,
operator|&
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
comment|/* Remaining bytes are less than window. */
name|window
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|window
operator|<
literal|0x40
condition|)
goto|goto
name|fatal
goto|;
continue|continue;
block|}
if|if
condition|(
name|bytes
operator|<
literal|0x40
condition|)
goto|goto
name|fatal
goto|;
name|p
operator|=
name|h
expr_stmt|;
name|q
operator|=
name|p
operator|+
name|bytes
expr_stmt|;
comment|/*      * Scan ahead until we find something that looks      * like the RAR header.      */
while|while
condition|(
name|p
operator|+
literal|7
operator|<
name|q
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|p
argument_list|,
name|RAR_SIGNATURE
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|skip
operator|=
name|p
operator|-
operator|(
specifier|const
name|char
operator|*
operator|)
name|h
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|skip
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
name|p
operator|+=
literal|0x10
expr_stmt|;
block|}
name|skip
operator|=
name|p
operator|-
operator|(
specifier|const
name|char
operator|*
operator|)
name|h
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|skip
argument_list|)
expr_stmt|;
name|total
operator|+=
name|skip
expr_stmt|;
block|}
name|fatal
label|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Couldn't find out RAR header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_rar_options
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|rar
modifier|*
name|rar
decl_stmt|;
name|int
name|ret
init|=
name|ARCHIVE_FAILED
decl_stmt|;
name|rar
operator|=
operator|(
expr|struct
name|rar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"hdrcharset"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|val
operator|==
name|NULL
operator|||
name|val
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"rar: hdrcharset option needs a character-set name"
argument_list|)
expr_stmt|;
else|else
block|{
name|rar
operator|->
name|opt_sconv
operator|=
name|archive_string_conversion_from_charset
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rar
operator|->
name|opt_sconv
operator|!=
name|NULL
condition|)
name|ret
operator|=
name|ARCHIVE_OK
expr_stmt|;
else|else
name|ret
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* Note: The "warn" return is just to inform the options    * supervisor that we didn't handle it.  It will generate    * a suitable error if no one used this option. */
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_rar_read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|h
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|rar
modifier|*
name|rar
decl_stmt|;
name|size_t
name|skip
decl_stmt|;
name|char
name|head_type
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|unsigned
name|flags
decl_stmt|;
name|unsigned
name|long
name|crc32_expected
decl_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_RAR
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|==
name|NULL
condition|)
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"RAR"
expr_stmt|;
name|rar
operator|=
operator|(
expr|struct
name|rar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
comment|/*    * It should be sufficient to call archive_read_next_header() for    * a reader to determine if an entry is encrypted or not. If the    * encryption of an entry is only detectable when calling    * archive_read_data(), so be it. We'll do the same check there    * as well.    */
if|if
condition|(
name|rar
operator|->
name|has_encrypted_entries
operator|==
name|ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW
condition|)
block|{
name|rar
operator|->
name|has_encrypted_entries
operator|=
literal|0
expr_stmt|;
block|}
comment|/* RAR files can be generated without EOF headers, so return ARCHIVE_EOF if   * this fails.   */
if|if
condition|(
operator|(
name|h
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|7
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
name|p
operator|=
name|h
expr_stmt|;
if|if
condition|(
name|rar
operator|->
name|found_first_header
operator|==
literal|0
operator|&&
operator|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'M'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'Z'
operator|)
operator|||
name|memcmp
argument_list|(
name|p
argument_list|,
literal|"\x7F\x45LF"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* This is an executable ? Must be self-extracting... */
name|ret
operator|=
name|skip_sfx
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
name|ARCHIVE_WARN
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|rar
operator|->
name|found_first_header
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|unsigned
name|long
name|crc32_val
decl_stmt|;
if|if
condition|(
operator|(
name|h
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|7
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|p
operator|=
name|h
expr_stmt|;
name|head_type
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
switch|switch
condition|(
name|head_type
condition|)
block|{
case|case
name|MARK_HEAD
case|:
if|if
condition|(
name|memcmp
argument_list|(
name|p
argument_list|,
name|RAR_SIGNATURE
argument_list|,
literal|7
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid marker header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
literal|7
argument_list|)
expr_stmt|;
break|break;
case|case
name|MAIN_HEAD
case|:
name|rar
operator|->
name|main_flags
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|3
argument_list|)
expr_stmt|;
name|skip
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
operator|<
literal|7
operator|+
sizeof|sizeof
argument_list|(
name|rar
operator|->
name|reserved1
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|rar
operator|->
name|reserved2
argument_list|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid header size"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|h
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|skip
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|p
operator|=
name|h
expr_stmt|;
name|memcpy
argument_list|(
name|rar
operator|->
name|reserved1
argument_list|,
name|p
operator|+
literal|7
argument_list|,
sizeof|sizeof
argument_list|(
name|rar
operator|->
name|reserved1
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rar
operator|->
name|reserved2
argument_list|,
name|p
operator|+
literal|7
operator|+
sizeof|sizeof
argument_list|(
name|rar
operator|->
name|reserved1
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|rar
operator|->
name|reserved2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rar
operator|->
name|main_flags
operator|&
name|MHD_ENCRYPTVER
condition|)
block|{
if|if
condition|(
name|skip
operator|<
literal|7
operator|+
sizeof|sizeof
argument_list|(
name|rar
operator|->
name|reserved1
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|rar
operator|->
name|reserved2
argument_list|)
operator|+
literal|1
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid header size"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|rar
operator|->
name|encryptver
operator|=
operator|*
operator|(
name|p
operator|+
literal|7
operator|+
sizeof|sizeof
argument_list|(
name|rar
operator|->
name|reserved1
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|rar
operator|->
name|reserved2
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* Main header is password encrypted, so we cannot read any          file names or any other info about files from the header. */
if|if
condition|(
name|rar
operator|->
name|main_flags
operator|&
name|MHD_PASSWORD
condition|)
block|{
name|archive_entry_set_is_metadata_encrypted
argument_list|(
name|entry
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|archive_entry_set_is_data_encrypted
argument_list|(
name|entry
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rar
operator|->
name|has_encrypted_entries
operator|=
literal|1
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"RAR encryption support unavailable."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|crc32_val
operator|=
name|crc32
argument_list|(
literal|0
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|p
operator|+
literal|2
argument_list|,
operator|(
name|unsigned
operator|)
name|skip
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|crc32_val
operator|&
literal|0xffff
operator|)
operator|!=
name|archive_le16dec
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Header CRC error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|skip
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_HEAD
case|:
return|return
name|read_header
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|head_type
argument_list|)
return|;
case|case
name|COMM_HEAD
case|:
case|case
name|AV_HEAD
case|:
case|case
name|SUB_HEAD
case|:
case|case
name|PROTECT_HEAD
case|:
case|case
name|SIGN_HEAD
case|:
case|case
name|ENDARC_HEAD
case|:
name|flags
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|3
argument_list|)
expr_stmt|;
name|skip
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
operator|<
literal|7
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid header size too small"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|HD_ADD_SIZE_PRESENT
condition|)
block|{
if|if
condition|(
name|skip
operator|<
literal|7
operator|+
literal|4
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid header size too small"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|h
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|skip
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|p
operator|=
name|h
expr_stmt|;
name|skip
operator|+=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|7
argument_list|)
expr_stmt|;
block|}
comment|/* Skip over the 2-byte CRC at the beginning of the header. */
name|crc32_expected
operator|=
name|archive_le16dec
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|skip
operator|-=
literal|2
expr_stmt|;
comment|/* Skim the entire header and compute the CRC. */
name|crc32_val
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|skip
operator|>
literal|0
condition|)
block|{
name|size_t
name|to_read
init|=
name|skip
decl_stmt|;
name|ssize_t
name|did_read
decl_stmt|;
if|if
condition|(
name|to_read
operator|>
literal|32
operator|*
literal|1024
condition|)
block|{
name|to_read
operator|=
literal|32
operator|*
literal|1024
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|h
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|to_read
argument_list|,
operator|&
name|did_read
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|p
operator|=
name|h
expr_stmt|;
name|crc32_val
operator|=
name|crc32
argument_list|(
name|crc32_val
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|p
argument_list|,
operator|(
name|unsigned
operator|)
name|did_read
argument_list|)
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|did_read
argument_list|)
expr_stmt|;
name|skip
operator|-=
name|did_read
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|crc32_val
operator|&
literal|0xffff
operator|)
operator|!=
name|crc32_expected
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Header CRC error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|head_type
operator|==
name|ENDARC_HEAD
condition|)
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
break|break;
case|case
name|NEWSUB_HEAD
case|:
if|if
condition|(
operator|(
name|ret
operator|=
name|read_header
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|head_type
argument_list|)
operator|)
operator|<
name|ARCHIVE_WARN
condition|)
return|return
name|ret
return|;
break|break;
default|default:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Bad RAR file"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_rar_read_data
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|int64_t
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|rar
modifier|*
name|rar
init|=
operator|(
expr|struct
name|rar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|rar
operator|->
name|has_encrypted_entries
operator|==
name|ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW
condition|)
block|{
name|rar
operator|->
name|has_encrypted_entries
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rar
operator|->
name|bytes_unconsumed
operator|>
literal|0
condition|)
block|{
comment|/* Consume as much as the decompressor actually used. */
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|rar
operator|->
name|bytes_unconsumed
argument_list|)
expr_stmt|;
name|rar
operator|->
name|bytes_unconsumed
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|buff
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rar
operator|->
name|entry_eof
operator|||
name|rar
operator|->
name|offset_seek
operator|>=
name|rar
operator|->
name|unp_size
condition|)
block|{
operator|*
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|offset
operator|=
name|rar
operator|->
name|offset
expr_stmt|;
if|if
condition|(
operator|*
name|offset
operator|<
name|rar
operator|->
name|unp_size
condition|)
operator|*
name|offset
operator|=
name|rar
operator|->
name|unp_size
expr_stmt|;
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
block|}
switch|switch
condition|(
name|rar
operator|->
name|compression_method
condition|)
block|{
case|case
name|COMPRESS_METHOD_STORE
case|:
name|ret
operator|=
name|read_data_stored
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|size
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPRESS_METHOD_FASTEST
case|:
case|case
name|COMPRESS_METHOD_FAST
case|:
case|case
name|COMPRESS_METHOD_NORMAL
case|:
case|case
name|COMPRESS_METHOD_GOOD
case|:
case|case
name|COMPRESS_METHOD_BEST
case|:
name|ret
operator|=
name|read_data_compressed
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|size
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
operator|&&
name|ret
operator|!=
name|ARCHIVE_WARN
condition|)
name|__archive_ppmd7_functions
operator|.
name|Ppmd7_Free
argument_list|(
operator|&
name|rar
operator|->
name|ppmd7_context
argument_list|,
operator|&
name|g_szalloc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Unsupported compression method for RAR file."
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_rar_read_data_skip
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|rar
modifier|*
name|rar
decl_stmt|;
name|int64_t
name|bytes_skipped
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|rar
operator|=
operator|(
expr|struct
name|rar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|rar
operator|->
name|bytes_unconsumed
operator|>
literal|0
condition|)
block|{
comment|/* Consume as much as the decompressor actually used. */
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|rar
operator|->
name|bytes_unconsumed
argument_list|)
expr_stmt|;
name|rar
operator|->
name|bytes_unconsumed
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rar
operator|->
name|bytes_remaining
operator|>
literal|0
condition|)
block|{
name|bytes_skipped
operator|=
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|rar
operator|->
name|bytes_remaining
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_skipped
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Compressed data to skip must be read from each header in a multivolume    * archive.    */
if|if
condition|(
name|rar
operator|->
name|main_flags
operator|&
name|MHD_VOLUME
operator|&&
name|rar
operator|->
name|file_flags
operator|&
name|FHD_SPLIT_AFTER
condition|)
block|{
name|ret
operator|=
name|archive_read_format_rar_read_header
argument_list|(
name|a
argument_list|,
name|a
operator|->
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
name|ARCHIVE_EOF
operator|)
condition|)
name|ret
operator|=
name|archive_read_format_rar_read_header
argument_list|(
name|a
argument_list|,
name|a
operator|->
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|(
name|ARCHIVE_OK
operator|)
condition|)
return|return
name|ret
return|;
return|return
name|archive_read_format_rar_read_data_skip
argument_list|(
name|a
argument_list|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int64_t
name|archive_read_format_rar_seek_data
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|int64_t
name|offset
parameter_list|,
name|int
name|whence
parameter_list|)
block|{
name|int64_t
name|client_offset
decl_stmt|,
name|ret
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|rar
modifier|*
name|rar
init|=
operator|(
expr|struct
name|rar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
if|if
condition|(
name|rar
operator|->
name|compression_method
operator|==
name|COMPRESS_METHOD_STORE
condition|)
block|{
comment|/* Modify the offset for use with SEEK_SET */
switch|switch
condition|(
name|whence
condition|)
block|{
case|case
name|SEEK_CUR
case|:
name|client_offset
operator|=
name|rar
operator|->
name|offset_seek
expr_stmt|;
break|break;
case|case
name|SEEK_END
case|:
name|client_offset
operator|=
name|rar
operator|->
name|unp_size
expr_stmt|;
break|break;
case|case
name|SEEK_SET
case|:
default|default:
name|client_offset
operator|=
literal|0
expr_stmt|;
block|}
name|client_offset
operator|+=
name|offset
expr_stmt|;
if|if
condition|(
name|client_offset
operator|<
literal|0
condition|)
block|{
comment|/* Can't seek past beginning of data block */
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|client_offset
operator|>
name|rar
operator|->
name|unp_size
condition|)
block|{
comment|/*        * Set the returned offset but only seek to the end of        * the data block.        */
name|rar
operator|->
name|offset_seek
operator|=
name|client_offset
expr_stmt|;
name|client_offset
operator|=
name|rar
operator|->
name|unp_size
expr_stmt|;
block|}
name|client_offset
operator|+=
name|rar
operator|->
name|dbo
index|[
literal|0
index|]
operator|.
name|start_offset
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|rar
operator|->
name|cursor
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|client_offset
operator|+=
name|rar
operator|->
name|dbo
index|[
name|i
index|]
operator|.
name|start_offset
operator|-
name|rar
operator|->
name|dbo
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|end_offset
expr_stmt|;
block|}
if|if
condition|(
name|rar
operator|->
name|main_flags
operator|&
name|MHD_VOLUME
condition|)
block|{
comment|/* Find the appropriate offset among the multivolume archive */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|client_offset
operator|<
name|rar
operator|->
name|dbo
index|[
name|rar
operator|->
name|cursor
index|]
operator|.
name|start_offset
operator|&&
name|rar
operator|->
name|file_flags
operator|&
name|FHD_SPLIT_BEFORE
condition|)
block|{
comment|/* Search backwards for the correct data block */
if|if
condition|(
name|rar
operator|->
name|cursor
operator|==
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Attempt to seek past beginning of RAR data block"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|rar
operator|->
name|cursor
operator|--
expr_stmt|;
name|client_offset
operator|-=
name|rar
operator|->
name|dbo
index|[
name|rar
operator|->
name|cursor
operator|+
literal|1
index|]
operator|.
name|start_offset
operator|-
name|rar
operator|->
name|dbo
index|[
name|rar
operator|->
name|cursor
index|]
operator|.
name|end_offset
expr_stmt|;
if|if
condition|(
name|client_offset
operator|<
name|rar
operator|->
name|dbo
index|[
name|rar
operator|->
name|cursor
index|]
operator|.
name|start_offset
condition|)
continue|continue;
name|ret
operator|=
name|__archive_read_seek
argument_list|(
name|a
argument_list|,
name|rar
operator|->
name|dbo
index|[
name|rar
operator|->
name|cursor
index|]
operator|.
name|start_offset
operator|-
name|rar
operator|->
name|dbo
index|[
name|rar
operator|->
name|cursor
index|]
operator|.
name|header_size
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
operator|(
name|ARCHIVE_OK
operator|)
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|archive_read_format_rar_read_header
argument_list|(
name|a
argument_list|,
name|a
operator|->
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|(
name|ARCHIVE_OK
operator|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Error during seek of RAR file"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|rar
operator|->
name|cursor
operator|--
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|client_offset
operator|>
name|rar
operator|->
name|dbo
index|[
name|rar
operator|->
name|cursor
index|]
operator|.
name|end_offset
operator|&&
name|rar
operator|->
name|file_flags
operator|&
name|FHD_SPLIT_AFTER
condition|)
block|{
comment|/* Search forward for the correct data block */
name|rar
operator|->
name|cursor
operator|++
expr_stmt|;
if|if
condition|(
name|rar
operator|->
name|cursor
operator|<
name|rar
operator|->
name|nodes
operator|&&
name|client_offset
operator|>
name|rar
operator|->
name|dbo
index|[
name|rar
operator|->
name|cursor
index|]
operator|.
name|end_offset
condition|)
block|{
name|client_offset
operator|+=
name|rar
operator|->
name|dbo
index|[
name|rar
operator|->
name|cursor
index|]
operator|.
name|start_offset
operator|-
name|rar
operator|->
name|dbo
index|[
name|rar
operator|->
name|cursor
operator|-
literal|1
index|]
operator|.
name|end_offset
expr_stmt|;
continue|continue;
block|}
name|rar
operator|->
name|cursor
operator|--
expr_stmt|;
name|ret
operator|=
name|__archive_read_seek
argument_list|(
name|a
argument_list|,
name|rar
operator|->
name|dbo
index|[
name|rar
operator|->
name|cursor
index|]
operator|.
name|end_offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
operator|(
name|ARCHIVE_OK
operator|)
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|archive_read_format_rar_read_header
argument_list|(
name|a
argument_list|,
name|a
operator|->
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
name|ARCHIVE_EOF
operator|)
condition|)
block|{
name|rar
operator|->
name|has_endarc_header
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|archive_read_format_rar_read_header
argument_list|(
name|a
argument_list|,
name|a
operator|->
name|entry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|!=
operator|(
name|ARCHIVE_OK
operator|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Error during seek of RAR file"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|client_offset
operator|+=
name|rar
operator|->
name|dbo
index|[
name|rar
operator|->
name|cursor
index|]
operator|.
name|start_offset
operator|-
name|rar
operator|->
name|dbo
index|[
name|rar
operator|->
name|cursor
operator|-
literal|1
index|]
operator|.
name|end_offset
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
block|}
name|ret
operator|=
name|__archive_read_seek
argument_list|(
name|a
argument_list|,
name|client_offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
operator|(
name|ARCHIVE_OK
operator|)
condition|)
return|return
name|ret
return|;
name|rar
operator|->
name|bytes_remaining
operator|=
name|rar
operator|->
name|dbo
index|[
name|rar
operator|->
name|cursor
index|]
operator|.
name|end_offset
operator|-
name|ret
expr_stmt|;
name|i
operator|=
name|rar
operator|->
name|cursor
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|i
operator|--
expr_stmt|;
name|ret
operator|-=
name|rar
operator|->
name|dbo
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|start_offset
operator|-
name|rar
operator|->
name|dbo
index|[
name|i
index|]
operator|.
name|end_offset
expr_stmt|;
block|}
name|ret
operator|-=
name|rar
operator|->
name|dbo
index|[
literal|0
index|]
operator|.
name|start_offset
expr_stmt|;
comment|/* Always restart reading the file after a seek */
name|__archive_reset_read_data
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|)
expr_stmt|;
name|rar
operator|->
name|bytes_unconsumed
operator|=
literal|0
expr_stmt|;
name|rar
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
comment|/*      * If a seek past the end of file was requested, return the requested      * offset.      */
if|if
condition|(
name|ret
operator|==
name|rar
operator|->
name|unp_size
operator|&&
name|rar
operator|->
name|offset_seek
operator|>
name|rar
operator|->
name|unp_size
condition|)
return|return
name|rar
operator|->
name|offset_seek
return|;
comment|/* Return the new offset */
name|rar
operator|->
name|offset_seek
operator|=
name|ret
expr_stmt|;
return|return
name|rar
operator|->
name|offset_seek
return|;
block|}
else|else
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Seeking of compressed RAR files is unsupported"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_rar_cleanup
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|rar
modifier|*
name|rar
decl_stmt|;
name|rar
operator|=
operator|(
expr|struct
name|rar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
name|free_codes
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rar
operator|->
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rar
operator|->
name|filename_save
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rar
operator|->
name|dbo
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rar
operator|->
name|unp_buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rar
operator|->
name|lzss
operator|.
name|window
argument_list|)
expr_stmt|;
name|__archive_ppmd7_functions
operator|.
name|Ppmd7_Free
argument_list|(
operator|&
name|rar
operator|->
name|ppmd7_context
argument_list|,
operator|&
name|g_szalloc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rar
argument_list|)
expr_stmt|;
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|char
name|head_type
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|h
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|struct
name|rar
modifier|*
name|rar
decl_stmt|;
name|struct
name|rar_header
name|rar_header
decl_stmt|;
name|struct
name|rar_file_header
name|file_header
decl_stmt|;
name|int64_t
name|header_size
decl_stmt|;
name|unsigned
name|filename_size
decl_stmt|,
name|end
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|strp
decl_stmt|;
name|char
name|packed_size
index|[
literal|8
index|]
decl_stmt|;
name|char
name|unp_size
index|[
literal|8
index|]
decl_stmt|;
name|int
name|ttime
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|sconv
decl_stmt|,
modifier|*
name|fn_sconv
decl_stmt|;
name|unsigned
name|long
name|crc32_val
decl_stmt|;
name|int
name|ret
init|=
operator|(
name|ARCHIVE_OK
operator|)
decl_stmt|,
name|ret2
decl_stmt|;
name|rar
operator|=
operator|(
expr|struct
name|rar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
comment|/* Setup a string conversion object for non-rar-unicode filenames. */
name|sconv
operator|=
name|rar
operator|->
name|opt_sconv
expr_stmt|;
if|if
condition|(
name|sconv
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|rar
operator|->
name|init_default_conversion
condition|)
block|{
name|rar
operator|->
name|sconv_default
operator|=
name|archive_string_default_conversion_for_read
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|)
expr_stmt|;
name|rar
operator|->
name|init_default_conversion
operator|=
literal|1
expr_stmt|;
block|}
name|sconv
operator|=
name|rar
operator|->
name|sconv_default
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|h
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|7
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|p
operator|=
name|h
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|rar_header
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|rar_header
argument_list|)
argument_list|)
expr_stmt|;
name|rar
operator|->
name|file_flags
operator|=
name|archive_le16dec
argument_list|(
name|rar_header
operator|.
name|flags
argument_list|)
expr_stmt|;
name|header_size
operator|=
name|archive_le16dec
argument_list|(
name|rar_header
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|header_size
operator|<
operator|(
name|int64_t
operator|)
sizeof|sizeof
argument_list|(
name|file_header
argument_list|)
operator|+
literal|7
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid header size"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|crc32_val
operator|=
name|crc32
argument_list|(
literal|0
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|p
operator|+
literal|2
argument_list|,
literal|7
operator|-
literal|2
argument_list|)
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
literal|7
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rar
operator|->
name|file_flags
operator|&
name|FHD_SOLID
operator|)
condition|)
block|{
name|rar
operator|->
name|compression_method
operator|=
literal|0
expr_stmt|;
name|rar
operator|->
name|packed_size
operator|=
literal|0
expr_stmt|;
name|rar
operator|->
name|unp_size
operator|=
literal|0
expr_stmt|;
name|rar
operator|->
name|mtime
operator|=
literal|0
expr_stmt|;
name|rar
operator|->
name|ctime
operator|=
literal|0
expr_stmt|;
name|rar
operator|->
name|atime
operator|=
literal|0
expr_stmt|;
name|rar
operator|->
name|arctime
operator|=
literal|0
expr_stmt|;
name|rar
operator|->
name|mode
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|rar
operator|->
name|salt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rar
operator|->
name|salt
argument_list|)
argument_list|)
expr_stmt|;
name|rar
operator|->
name|atime
operator|=
literal|0
expr_stmt|;
name|rar
operator|->
name|ansec
operator|=
literal|0
expr_stmt|;
name|rar
operator|->
name|ctime
operator|=
literal|0
expr_stmt|;
name|rar
operator|->
name|cnsec
operator|=
literal|0
expr_stmt|;
name|rar
operator|->
name|mtime
operator|=
literal|0
expr_stmt|;
name|rar
operator|->
name|mnsec
operator|=
literal|0
expr_stmt|;
name|rar
operator|->
name|arctime
operator|=
literal|0
expr_stmt|;
name|rar
operator|->
name|arcnsec
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"RAR solid archive support unavailable."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|h
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
operator|(
name|size_t
operator|)
name|header_size
operator|-
literal|7
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
comment|/* File Header CRC check. */
name|crc32_val
operator|=
name|crc32
argument_list|(
name|crc32_val
argument_list|,
name|h
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|header_size
operator|-
literal|7
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|crc32_val
operator|&
literal|0xffff
operator|)
operator|!=
name|archive_le16dec
argument_list|(
name|rar_header
operator|.
name|crc
argument_list|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Header CRC error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* If no CRC error, Go on parsing File Header. */
name|p
operator|=
name|h
expr_stmt|;
name|endp
operator|=
name|p
operator|+
name|header_size
operator|-
literal|7
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|file_header
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|file_header
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|file_header
argument_list|)
expr_stmt|;
name|rar
operator|->
name|compression_method
operator|=
name|file_header
operator|.
name|method
expr_stmt|;
name|ttime
operator|=
name|archive_le32dec
argument_list|(
name|file_header
operator|.
name|file_time
argument_list|)
expr_stmt|;
name|rar
operator|->
name|mtime
operator|=
name|get_time
argument_list|(
name|ttime
argument_list|)
expr_stmt|;
name|rar
operator|->
name|file_crc
operator|=
name|archive_le32dec
argument_list|(
name|file_header
operator|.
name|file_crc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rar
operator|->
name|file_flags
operator|&
name|FHD_PASSWORD
condition|)
block|{
name|archive_entry_set_is_data_encrypted
argument_list|(
name|entry
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rar
operator|->
name|has_encrypted_entries
operator|=
literal|1
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"RAR encryption support unavailable."
argument_list|)
expr_stmt|;
comment|/* Since it is only the data part itself that is encrypted we can at least        extract information about the currently processed entry and don't need        to return ARCHIVE_FATAL here. */
comment|/*return (ARCHIVE_FATAL);*/
block|}
if|if
condition|(
name|rar
operator|->
name|file_flags
operator|&
name|FHD_LARGE
condition|)
block|{
name|memcpy
argument_list|(
name|packed_size
argument_list|,
name|file_header
operator|.
name|pack_size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|packed_size
operator|+
literal|4
argument_list|,
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* High pack size */
name|p
operator|+=
literal|4
expr_stmt|;
name|memcpy
argument_list|(
name|unp_size
argument_list|,
name|file_header
operator|.
name|unp_size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|unp_size
operator|+
literal|4
argument_list|,
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* High unpack size */
name|p
operator|+=
literal|4
expr_stmt|;
name|rar
operator|->
name|packed_size
operator|=
name|archive_le64dec
argument_list|(
operator|&
name|packed_size
argument_list|)
expr_stmt|;
name|rar
operator|->
name|unp_size
operator|=
name|archive_le64dec
argument_list|(
operator|&
name|unp_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rar
operator|->
name|packed_size
operator|=
name|archive_le32dec
argument_list|(
name|file_header
operator|.
name|pack_size
argument_list|)
expr_stmt|;
name|rar
operator|->
name|unp_size
operator|=
name|archive_le32dec
argument_list|(
name|file_header
operator|.
name|unp_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rar
operator|->
name|packed_size
operator|<
literal|0
operator|||
name|rar
operator|->
name|unp_size
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid sizes specified."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|rar
operator|->
name|bytes_remaining
operator|=
name|rar
operator|->
name|packed_size
expr_stmt|;
comment|/* TODO: RARv3 subblocks contain comments. For now the complete block is    * consumed at the end.    */
if|if
condition|(
name|head_type
operator|==
name|NEWSUB_HEAD
condition|)
block|{
name|size_t
name|distance
init|=
name|p
operator|-
operator|(
specifier|const
name|char
operator|*
operator|)
name|h
decl_stmt|;
name|header_size
operator|+=
name|rar
operator|->
name|packed_size
expr_stmt|;
comment|/* Make sure we have the extended data. */
if|if
condition|(
operator|(
name|h
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
operator|(
name|size_t
operator|)
name|header_size
operator|-
literal|7
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|p
operator|=
name|h
expr_stmt|;
name|endp
operator|=
name|p
operator|+
name|header_size
operator|-
literal|7
expr_stmt|;
name|p
operator|+=
name|distance
expr_stmt|;
block|}
name|filename_size
operator|=
name|archive_le16dec
argument_list|(
name|file_header
operator|.
name|name_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|+
name|filename_size
operator|>
name|endp
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid filename size"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|rar
operator|->
name|filename_allocated
operator|<
name|filename_size
operator|*
literal|2
operator|+
literal|2
condition|)
block|{
name|char
modifier|*
name|newptr
decl_stmt|;
name|size_t
name|newsize
init|=
name|filename_size
operator|*
literal|2
operator|+
literal|2
decl_stmt|;
name|newptr
operator|=
name|realloc
argument_list|(
name|rar
operator|->
name|filename
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|newptr
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Couldn't allocate memory."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|rar
operator|->
name|filename
operator|=
name|newptr
expr_stmt|;
name|rar
operator|->
name|filename_allocated
operator|=
name|newsize
expr_stmt|;
block|}
name|filename
operator|=
name|rar
operator|->
name|filename
expr_stmt|;
name|memcpy
argument_list|(
name|filename
argument_list|,
name|p
argument_list|,
name|filename_size
argument_list|)
expr_stmt|;
name|filename
index|[
name|filename_size
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|rar
operator|->
name|file_flags
operator|&
name|FHD_UNICODE
condition|)
block|{
if|if
condition|(
name|filename_size
operator|!=
name|strlen
argument_list|(
name|filename
argument_list|)
condition|)
block|{
name|unsigned
name|char
name|highbyte
decl_stmt|,
name|flagbits
decl_stmt|,
name|flagbyte
decl_stmt|;
name|unsigned
name|fn_end
decl_stmt|,
name|offset
decl_stmt|;
name|end
operator|=
name|filename_size
expr_stmt|;
name|fn_end
operator|=
name|filename_size
operator|*
literal|2
expr_stmt|;
name|filename_size
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
expr_stmt|;
name|highbyte
operator|=
operator|*
operator|(
name|p
operator|+
name|offset
operator|++
operator|)
expr_stmt|;
name|flagbits
operator|=
literal|0
expr_stmt|;
name|flagbyte
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|offset
operator|<
name|end
operator|&&
name|filename_size
operator|<
name|fn_end
condition|)
block|{
if|if
condition|(
operator|!
name|flagbits
condition|)
block|{
name|flagbyte
operator|=
operator|*
operator|(
name|p
operator|+
name|offset
operator|++
operator|)
expr_stmt|;
name|flagbits
operator|=
literal|8
expr_stmt|;
block|}
name|flagbits
operator|-=
literal|2
expr_stmt|;
switch|switch
condition|(
operator|(
name|flagbyte
operator|>>
name|flagbits
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|filename
index|[
name|filename_size
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
name|filename
index|[
name|filename_size
operator|++
index|]
operator|=
operator|*
operator|(
name|p
operator|+
name|offset
operator|++
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|filename
index|[
name|filename_size
operator|++
index|]
operator|=
name|highbyte
expr_stmt|;
name|filename
index|[
name|filename_size
operator|++
index|]
operator|=
operator|*
operator|(
name|p
operator|+
name|offset
operator|++
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|filename
index|[
name|filename_size
operator|++
index|]
operator|=
operator|*
operator|(
name|p
operator|+
name|offset
operator|+
literal|1
operator|)
expr_stmt|;
name|filename
index|[
name|filename_size
operator|++
index|]
operator|=
operator|*
operator|(
name|p
operator|+
name|offset
operator|)
expr_stmt|;
name|offset
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|3
case|:
block|{
name|char
name|extra
decl_stmt|,
name|high
decl_stmt|;
name|uint8_t
name|length
init|=
operator|*
operator|(
name|p
operator|+
name|offset
operator|++
operator|)
decl_stmt|;
if|if
condition|(
name|length
operator|&
literal|0x80
condition|)
block|{
name|extra
operator|=
operator|*
operator|(
name|p
operator|+
name|offset
operator|++
operator|)
expr_stmt|;
name|high
operator|=
operator|(
name|char
operator|)
name|highbyte
expr_stmt|;
block|}
else|else
name|extra
operator|=
name|high
operator|=
literal|0
expr_stmt|;
name|length
operator|=
operator|(
name|length
operator|&
literal|0x7f
operator|)
operator|+
literal|2
expr_stmt|;
while|while
condition|(
name|length
operator|&&
name|filename_size
operator|<
name|fn_end
condition|)
block|{
name|unsigned
name|cp
init|=
name|filename_size
operator|>>
literal|1
decl_stmt|;
name|filename
index|[
name|filename_size
operator|++
index|]
operator|=
name|high
expr_stmt|;
name|filename
index|[
name|filename_size
operator|++
index|]
operator|=
name|p
index|[
name|cp
index|]
operator|+
name|extra
expr_stmt|;
name|length
operator|--
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
if|if
condition|(
name|filename_size
operator|>
name|fn_end
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid filename"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|filename
index|[
name|filename_size
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
name|filename
index|[
name|filename_size
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Decoded unicode form is UTF-16BE, so we have to update a string        * conversion object for it. */
if|if
condition|(
name|rar
operator|->
name|sconv_utf16be
operator|==
name|NULL
condition|)
block|{
name|rar
operator|->
name|sconv_utf16be
operator|=
name|archive_string_conversion_from_charset
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
literal|"UTF-16BE"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rar
operator|->
name|sconv_utf16be
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|fn_sconv
operator|=
name|rar
operator|->
name|sconv_utf16be
expr_stmt|;
name|strp
operator|=
name|filename
expr_stmt|;
while|while
condition|(
name|memcmp
argument_list|(
name|strp
argument_list|,
literal|"\x00\x00"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|strp
argument_list|,
literal|"\x00\\"
argument_list|,
literal|2
argument_list|)
condition|)
operator|*
operator|(
name|strp
operator|+
literal|1
operator|)
operator|=
literal|'/'
expr_stmt|;
name|strp
operator|+=
literal|2
expr_stmt|;
block|}
name|p
operator|+=
name|offset
expr_stmt|;
block|}
else|else
block|{
comment|/*        * If FHD_UNICODE is set but no unicode data, this file name form        * is UTF-8, so we have to update a string conversion object for        * it accordingly.        */
if|if
condition|(
name|rar
operator|->
name|sconv_utf8
operator|==
name|NULL
condition|)
block|{
name|rar
operator|->
name|sconv_utf8
operator|=
name|archive_string_conversion_from_charset
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
literal|"UTF-8"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rar
operator|->
name|sconv_utf8
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|fn_sconv
operator|=
name|rar
operator|->
name|sconv_utf8
expr_stmt|;
while|while
condition|(
operator|(
name|strp
operator|=
name|strchr
argument_list|(
name|filename
argument_list|,
literal|'\\'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|strp
operator|=
literal|'/'
expr_stmt|;
name|p
operator|+=
name|filename_size
expr_stmt|;
block|}
block|}
else|else
block|{
name|fn_sconv
operator|=
name|sconv
expr_stmt|;
while|while
condition|(
operator|(
name|strp
operator|=
name|strchr
argument_list|(
name|filename
argument_list|,
literal|'\\'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|strp
operator|=
literal|'/'
expr_stmt|;
name|p
operator|+=
name|filename_size
expr_stmt|;
block|}
comment|/* Split file in multivolume RAR. No more need to process header. */
if|if
condition|(
name|rar
operator|->
name|filename_save
operator|&&
name|filename_size
operator|==
name|rar
operator|->
name|filename_save_size
operator|&&
operator|!
name|memcmp
argument_list|(
name|rar
operator|->
name|filename
argument_list|,
name|rar
operator|->
name|filename_save
argument_list|,
name|filename_size
operator|+
literal|1
argument_list|)
condition|)
block|{
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|header_size
operator|-
literal|7
argument_list|)
expr_stmt|;
name|rar
operator|->
name|cursor
operator|++
expr_stmt|;
if|if
condition|(
name|rar
operator|->
name|cursor
operator|>=
name|rar
operator|->
name|nodes
condition|)
block|{
name|rar
operator|->
name|nodes
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|rar
operator|->
name|dbo
operator|=
name|realloc
argument_list|(
name|rar
operator|->
name|dbo
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rar
operator|->
name|dbo
argument_list|)
operator|*
name|rar
operator|->
name|nodes
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Couldn't allocate memory."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|rar
operator|->
name|dbo
index|[
name|rar
operator|->
name|cursor
index|]
operator|.
name|header_size
operator|=
name|header_size
expr_stmt|;
name|rar
operator|->
name|dbo
index|[
name|rar
operator|->
name|cursor
index|]
operator|.
name|start_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|rar
operator|->
name|dbo
index|[
name|rar
operator|->
name|cursor
index|]
operator|.
name|end_offset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|rar
operator|->
name|dbo
index|[
name|rar
operator|->
name|cursor
index|]
operator|.
name|start_offset
operator|<
literal|0
condition|)
block|{
name|rar
operator|->
name|dbo
index|[
name|rar
operator|->
name|cursor
index|]
operator|.
name|start_offset
operator|=
name|a
operator|->
name|filter
operator|->
name|position
expr_stmt|;
name|rar
operator|->
name|dbo
index|[
name|rar
operator|->
name|cursor
index|]
operator|.
name|end_offset
operator|=
name|rar
operator|->
name|dbo
index|[
name|rar
operator|->
name|cursor
index|]
operator|.
name|start_offset
operator|+
name|rar
operator|->
name|packed_size
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
name|rar
operator|->
name|filename_save
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|rar
operator|->
name|filename_save
argument_list|,
name|filename_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rar
operator|->
name|filename_save
argument_list|,
name|rar
operator|->
name|filename
argument_list|,
name|filename_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|rar
operator|->
name|filename_save_size
operator|=
name|filename_size
expr_stmt|;
comment|/* Set info for seeking */
name|free
argument_list|(
name|rar
operator|->
name|dbo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rar
operator|->
name|dbo
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rar
operator|->
name|dbo
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Couldn't allocate memory."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|rar
operator|->
name|dbo
index|[
literal|0
index|]
operator|.
name|header_size
operator|=
name|header_size
expr_stmt|;
name|rar
operator|->
name|dbo
index|[
literal|0
index|]
operator|.
name|start_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|rar
operator|->
name|dbo
index|[
literal|0
index|]
operator|.
name|end_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|rar
operator|->
name|cursor
operator|=
literal|0
expr_stmt|;
name|rar
operator|->
name|nodes
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rar
operator|->
name|file_flags
operator|&
name|FHD_SALT
condition|)
block|{
if|if
condition|(
name|p
operator|+
literal|8
operator|>
name|endp
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid header size"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|rar
operator|->
name|salt
argument_list|,
name|p
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|rar
operator|->
name|file_flags
operator|&
name|FHD_EXTTIME
condition|)
block|{
if|if
condition|(
name|read_exttime
argument_list|(
name|p
argument_list|,
name|rar
argument_list|,
name|endp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid header size"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|header_size
operator|-
literal|7
argument_list|)
expr_stmt|;
name|rar
operator|->
name|dbo
index|[
literal|0
index|]
operator|.
name|start_offset
operator|=
name|a
operator|->
name|filter
operator|->
name|position
expr_stmt|;
name|rar
operator|->
name|dbo
index|[
literal|0
index|]
operator|.
name|end_offset
operator|=
name|rar
operator|->
name|dbo
index|[
literal|0
index|]
operator|.
name|start_offset
operator|+
name|rar
operator|->
name|packed_size
expr_stmt|;
switch|switch
condition|(
name|file_header
operator|.
name|host_os
condition|)
block|{
case|case
name|OS_MSDOS
case|:
case|case
name|OS_OS2
case|:
case|case
name|OS_WIN32
case|:
name|rar
operator|->
name|mode
operator|=
name|archive_le32dec
argument_list|(
name|file_header
operator|.
name|file_attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rar
operator|->
name|mode
operator|&
name|FILE_ATTRIBUTE_DIRECTORY
condition|)
name|rar
operator|->
name|mode
operator|=
name|AE_IFDIR
operator||
name|S_IXUSR
operator||
name|S_IXGRP
operator||
name|S_IXOTH
expr_stmt|;
else|else
name|rar
operator|->
name|mode
operator|=
name|AE_IFREG
expr_stmt|;
name|rar
operator|->
name|mode
operator||=
name|S_IRUSR
operator||
name|S_IWUSR
operator||
name|S_IRGRP
operator||
name|S_IROTH
expr_stmt|;
break|break;
case|case
name|OS_UNIX
case|:
case|case
name|OS_MAC_OS
case|:
case|case
name|OS_BEOS
case|:
name|rar
operator|->
name|mode
operator|=
name|archive_le32dec
argument_list|(
name|file_header
operator|.
name|file_attr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Unknown file attributes from RAR file's host OS"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|rar
operator|->
name|bytes_uncopied
operator|=
name|rar
operator|->
name|bytes_unconsumed
operator|=
literal|0
expr_stmt|;
name|rar
operator|->
name|lzss
operator|.
name|position
operator|=
name|rar
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|rar
operator|->
name|offset_seek
operator|=
literal|0
expr_stmt|;
name|rar
operator|->
name|dictionary_size
operator|=
literal|0
expr_stmt|;
name|rar
operator|->
name|offset_outgoing
operator|=
literal|0
expr_stmt|;
name|rar
operator|->
name|br
operator|.
name|cache_avail
operator|=
literal|0
expr_stmt|;
name|rar
operator|->
name|br
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|rar
operator|->
name|crc_calculated
operator|=
literal|0
expr_stmt|;
name|rar
operator|->
name|entry_eof
operator|=
literal|0
expr_stmt|;
name|rar
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
name|rar
operator|->
name|is_ppmd_block
operator|=
literal|0
expr_stmt|;
name|rar
operator|->
name|start_new_table
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|rar
operator|->
name|unp_buffer
argument_list|)
expr_stmt|;
name|rar
operator|->
name|unp_buffer
operator|=
name|NULL
expr_stmt|;
name|rar
operator|->
name|unp_offset
operator|=
literal|0
expr_stmt|;
name|rar
operator|->
name|unp_buffer_size
operator|=
name|UNP_BUFFER_SIZE
expr_stmt|;
name|memset
argument_list|(
name|rar
operator|->
name|lengthtable
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rar
operator|->
name|lengthtable
argument_list|)
argument_list|)
expr_stmt|;
name|__archive_ppmd7_functions
operator|.
name|Ppmd7_Free
argument_list|(
operator|&
name|rar
operator|->
name|ppmd7_context
argument_list|,
operator|&
name|g_szalloc
argument_list|)
expr_stmt|;
name|rar
operator|->
name|ppmd_valid
operator|=
name|rar
operator|->
name|ppmd_eod
operator|=
literal|0
expr_stmt|;
comment|/* Don't set any archive entries for non-file header types */
if|if
condition|(
name|head_type
operator|==
name|NEWSUB_HEAD
condition|)
return|return
name|ret
return|;
name|archive_entry_set_mtime
argument_list|(
name|entry
argument_list|,
name|rar
operator|->
name|mtime
argument_list|,
name|rar
operator|->
name|mnsec
argument_list|)
expr_stmt|;
name|archive_entry_set_ctime
argument_list|(
name|entry
argument_list|,
name|rar
operator|->
name|ctime
argument_list|,
name|rar
operator|->
name|cnsec
argument_list|)
expr_stmt|;
name|archive_entry_set_atime
argument_list|(
name|entry
argument_list|,
name|rar
operator|->
name|atime
argument_list|,
name|rar
operator|->
name|ansec
argument_list|)
expr_stmt|;
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
name|rar
operator|->
name|unp_size
argument_list|)
expr_stmt|;
name|archive_entry_set_mode
argument_list|(
name|entry
argument_list|,
name|rar
operator|->
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_entry_copy_pathname_l
argument_list|(
name|entry
argument_list|,
name|filename
argument_list|,
name|filename_size
argument_list|,
name|fn_sconv
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for Pathname"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Pathname cannot be converted from %s to current locale."
argument_list|,
name|archive_string_conversion_charset_name
argument_list|(
name|fn_sconv
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|ARCHIVE_WARN
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|rar
operator|->
name|mode
operator|)
operator|&
name|AE_IFMT
operator|)
operator|==
name|AE_IFLNK
condition|)
block|{
comment|/* Make sure a symbolic-link file does not have its body. */
name|rar
operator|->
name|bytes_remaining
operator|=
literal|0
expr_stmt|;
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Read a symbolic-link name. */
if|if
condition|(
operator|(
name|ret2
operator|=
name|read_symlink_stored
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|sconv
argument_list|)
operator|)
operator|<
operator|(
name|ARCHIVE_WARN
operator|)
condition|)
return|return
name|ret2
return|;
if|if
condition|(
name|ret
operator|>
name|ret2
condition|)
name|ret
operator|=
name|ret2
expr_stmt|;
block|}
if|if
condition|(
name|rar
operator|->
name|bytes_remaining
operator|==
literal|0
condition|)
name|rar
operator|->
name|entry_eof
operator|=
literal|1
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|time_t
name|get_time
parameter_list|(
name|int
name|ttime
parameter_list|)
block|{
name|struct
name|tm
name|tm
decl_stmt|;
name|tm
operator|.
name|tm_sec
operator|=
literal|2
operator|*
operator|(
name|ttime
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|tm
operator|.
name|tm_min
operator|=
operator|(
name|ttime
operator|>>
literal|5
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|tm
operator|.
name|tm_hour
operator|=
operator|(
name|ttime
operator|>>
literal|11
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|tm
operator|.
name|tm_mday
operator|=
operator|(
name|ttime
operator|>>
literal|16
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|tm
operator|.
name|tm_mon
operator|=
operator|(
operator|(
name|ttime
operator|>>
literal|21
operator|)
operator|&
literal|0x0f
operator|)
operator|-
literal|1
expr_stmt|;
name|tm
operator|.
name|tm_year
operator|=
operator|(
operator|(
name|ttime
operator|>>
literal|25
operator|)
operator|&
literal|0x7f
operator|)
operator|+
literal|80
expr_stmt|;
name|tm
operator|.
name|tm_isdst
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|mktime
argument_list|(
operator|&
name|tm
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_exttime
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|struct
name|rar
modifier|*
name|rar
parameter_list|,
specifier|const
name|char
modifier|*
name|endp
parameter_list|)
block|{
name|unsigned
name|rmode
decl_stmt|,
name|flags
decl_stmt|,
name|rem
decl_stmt|,
name|j
decl_stmt|,
name|count
decl_stmt|;
name|int
name|ttime
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|long
name|nsec
decl_stmt|;
if|if
condition|(
name|p
operator|+
literal|2
operator|>
name|endp
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|flags
operator|=
name|archive_le16dec
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|t
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|3
condition|)
name|t
operator|=
name|rar
operator|->
name|mtime
expr_stmt|;
name|rmode
operator|=
name|flags
operator|>>
name|i
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|rmode
operator|&
literal|8
condition|)
block|{
if|if
condition|(
operator|!
name|t
condition|)
block|{
if|if
condition|(
name|p
operator|+
literal|4
operator|>
name|endp
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ttime
operator|=
name|archive_le32dec
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|t
operator|=
name|get_time
argument_list|(
name|ttime
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
name|rem
operator|=
literal|0
expr_stmt|;
name|count
operator|=
name|rmode
operator|&
literal|3
expr_stmt|;
if|if
condition|(
name|p
operator|+
name|count
operator|>
name|endp
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|count
condition|;
name|j
operator|++
control|)
block|{
name|rem
operator|=
operator|(
operator|(
operator|(
name|unsigned
operator|)
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|rem
operator|>>
literal|8
operator|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|tm
operator|=
name|localtime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|nsec
operator|=
name|tm
operator|->
name|tm_sec
operator|+
name|rem
operator|/
name|NS_UNIT
expr_stmt|;
if|if
condition|(
name|rmode
operator|&
literal|4
condition|)
block|{
name|tm
operator|->
name|tm_sec
operator|++
expr_stmt|;
name|t
operator|=
name|mktime
argument_list|(
name|tm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|3
condition|)
block|{
name|rar
operator|->
name|mtime
operator|=
name|t
expr_stmt|;
name|rar
operator|->
name|mnsec
operator|=
name|nsec
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|2
condition|)
block|{
name|rar
operator|->
name|ctime
operator|=
name|t
expr_stmt|;
name|rar
operator|->
name|cnsec
operator|=
name|nsec
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
name|rar
operator|->
name|atime
operator|=
name|t
expr_stmt|;
name|rar
operator|->
name|ansec
operator|=
name|nsec
expr_stmt|;
block|}
else|else
block|{
name|rar
operator|->
name|arctime
operator|=
name|t
expr_stmt|;
name|rar
operator|->
name|arcnsec
operator|=
name|nsec
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_symlink_stored
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sconv
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|h
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|rar
modifier|*
name|rar
decl_stmt|;
name|int
name|ret
init|=
operator|(
name|ARCHIVE_OK
operator|)
decl_stmt|;
name|rar
operator|=
operator|(
expr|struct
name|rar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|=
name|rar_read_ahead
argument_list|(
name|a
argument_list|,
operator|(
name|size_t
operator|)
name|rar
operator|->
name|packed_size
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|p
operator|=
name|h
expr_stmt|;
if|if
condition|(
name|archive_entry_copy_symlink_l
argument_list|(
name|entry
argument_list|,
name|p
argument_list|,
operator|(
name|size_t
operator|)
name|rar
operator|->
name|packed_size
argument_list|,
name|sconv
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for link"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"link cannot be converted from %s to current locale."
argument_list|,
name|archive_string_conversion_charset_name
argument_list|(
name|sconv
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|ARCHIVE_WARN
operator|)
expr_stmt|;
block|}
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|rar
operator|->
name|packed_size
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_data_stored
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|int64_t
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|rar
modifier|*
name|rar
decl_stmt|;
name|ssize_t
name|bytes_avail
decl_stmt|;
name|rar
operator|=
operator|(
expr|struct
name|rar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|rar
operator|->
name|bytes_remaining
operator|==
literal|0
operator|&&
operator|!
operator|(
name|rar
operator|->
name|main_flags
operator|&
name|MHD_VOLUME
operator|&&
name|rar
operator|->
name|file_flags
operator|&
name|FHD_SPLIT_AFTER
operator|)
condition|)
block|{
operator|*
name|buff
operator|=
name|NULL
expr_stmt|;
operator|*
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|offset
operator|=
name|rar
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|rar
operator|->
name|file_crc
operator|!=
name|rar
operator|->
name|crc_calculated
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"File CRC error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|rar
operator|->
name|entry_eof
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
block|}
operator|*
name|buff
operator|=
name|rar_read_ahead
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
operator|&
name|bytes_avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_avail
operator|<=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated RAR file data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
operator|*
name|size
operator|=
name|bytes_avail
expr_stmt|;
operator|*
name|offset
operator|=
name|rar
operator|->
name|offset
expr_stmt|;
name|rar
operator|->
name|offset
operator|+=
name|bytes_avail
expr_stmt|;
name|rar
operator|->
name|offset_seek
operator|+=
name|bytes_avail
expr_stmt|;
name|rar
operator|->
name|bytes_remaining
operator|-=
name|bytes_avail
expr_stmt|;
name|rar
operator|->
name|bytes_unconsumed
operator|=
name|bytes_avail
expr_stmt|;
comment|/* Calculate File CRC. */
name|rar
operator|->
name|crc_calculated
operator|=
name|crc32
argument_list|(
name|rar
operator|->
name|crc_calculated
argument_list|,
operator|*
name|buff
argument_list|,
operator|(
name|unsigned
operator|)
name|bytes_avail
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_data_compressed
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|int64_t
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|rar
modifier|*
name|rar
decl_stmt|;
name|int64_t
name|start
decl_stmt|,
name|end
decl_stmt|,
name|actualend
decl_stmt|;
name|size_t
name|bs
decl_stmt|;
name|int
name|ret
init|=
operator|(
name|ARCHIVE_OK
operator|)
decl_stmt|,
name|sym
decl_stmt|,
name|code
decl_stmt|,
name|lzss_offset
decl_stmt|,
name|length
decl_stmt|,
name|i
decl_stmt|;
name|rar
operator|=
operator|(
expr|struct
name|rar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|rar
operator|->
name|valid
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
if|if
condition|(
name|rar
operator|->
name|ppmd_eod
operator|||
operator|(
name|rar
operator|->
name|dictionary_size
operator|&&
name|rar
operator|->
name|offset
operator|>=
name|rar
operator|->
name|unp_size
operator|)
condition|)
block|{
if|if
condition|(
name|rar
operator|->
name|unp_offset
operator|>
literal|0
condition|)
block|{
comment|/*          * We have unprocessed extracted data. write it out.          */
operator|*
name|buff
operator|=
name|rar
operator|->
name|unp_buffer
expr_stmt|;
operator|*
name|size
operator|=
name|rar
operator|->
name|unp_offset
expr_stmt|;
operator|*
name|offset
operator|=
name|rar
operator|->
name|offset_outgoing
expr_stmt|;
name|rar
operator|->
name|offset_outgoing
operator|+=
operator|*
name|size
expr_stmt|;
comment|/* Calculate File CRC. */
name|rar
operator|->
name|crc_calculated
operator|=
name|crc32
argument_list|(
name|rar
operator|->
name|crc_calculated
argument_list|,
operator|*
name|buff
argument_list|,
operator|(
name|unsigned
operator|)
operator|*
name|size
argument_list|)
expr_stmt|;
name|rar
operator|->
name|unp_offset
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
operator|*
name|buff
operator|=
name|NULL
expr_stmt|;
operator|*
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|offset
operator|=
name|rar
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|rar
operator|->
name|file_crc
operator|!=
name|rar
operator|->
name|crc_calculated
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"File CRC error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|rar
operator|->
name|entry_eof
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|rar
operator|->
name|is_ppmd_block
operator|&&
name|rar
operator|->
name|dictionary_size
operator|&&
name|rar
operator|->
name|bytes_uncopied
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|rar
operator|->
name|bytes_uncopied
operator|>
operator|(
name|rar
operator|->
name|unp_buffer_size
operator|-
name|rar
operator|->
name|unp_offset
operator|)
condition|)
name|bs
operator|=
name|rar
operator|->
name|unp_buffer_size
operator|-
name|rar
operator|->
name|unp_offset
expr_stmt|;
else|else
name|bs
operator|=
operator|(
name|size_t
operator|)
name|rar
operator|->
name|bytes_uncopied
expr_stmt|;
name|ret
operator|=
name|copy_from_lzss_window
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|rar
operator|->
name|offset
argument_list|,
operator|(
name|int
operator|)
name|bs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|rar
operator|->
name|offset
operator|+=
name|bs
expr_stmt|;
name|rar
operator|->
name|bytes_uncopied
operator|-=
name|bs
expr_stmt|;
if|if
condition|(
operator|*
name|buff
operator|!=
name|NULL
condition|)
block|{
name|rar
operator|->
name|unp_offset
operator|=
literal|0
expr_stmt|;
operator|*
name|size
operator|=
name|rar
operator|->
name|unp_buffer_size
expr_stmt|;
operator|*
name|offset
operator|=
name|rar
operator|->
name|offset_outgoing
expr_stmt|;
name|rar
operator|->
name|offset_outgoing
operator|+=
operator|*
name|size
expr_stmt|;
comment|/* Calculate File CRC. */
name|rar
operator|->
name|crc_calculated
operator|=
name|crc32
argument_list|(
name|rar
operator|->
name|crc_calculated
argument_list|,
operator|*
name|buff
argument_list|,
operator|(
name|unsigned
operator|)
operator|*
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|!
name|rar
operator|->
name|br
operator|.
name|next_in
operator|&&
operator|(
name|ret
operator|=
name|rar_br_preparation
argument_list|(
name|a
argument_list|,
operator|&
operator|(
name|rar
operator|->
name|br
operator|)
argument_list|)
operator|)
operator|<
name|ARCHIVE_WARN
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|rar
operator|->
name|start_new_table
operator|&&
operator|(
operator|(
name|ret
operator|=
name|parse_codes
argument_list|(
name|a
argument_list|)
operator|)
operator|<
operator|(
name|ARCHIVE_WARN
operator|)
operator|)
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|rar
operator|->
name|is_ppmd_block
condition|)
block|{
if|if
condition|(
operator|(
name|sym
operator|=
name|__archive_ppmd7_functions
operator|.
name|Ppmd7_DecodeSymbol
argument_list|(
operator|&
name|rar
operator|->
name|ppmd7_context
argument_list|,
operator|&
name|rar
operator|->
name|range_dec
operator|.
name|p
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid symbol"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|sym
operator|!=
name|rar
operator|->
name|ppmd_escape
condition|)
block|{
name|lzss_emit_literal
argument_list|(
name|rar
argument_list|,
name|sym
argument_list|)
expr_stmt|;
name|rar
operator|->
name|bytes_uncopied
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|code
operator|=
name|__archive_ppmd7_functions
operator|.
name|Ppmd7_DecodeSymbol
argument_list|(
operator|&
name|rar
operator|->
name|ppmd7_context
argument_list|,
operator|&
name|rar
operator|->
name|range_dec
operator|.
name|p
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid symbol"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|0
case|:
name|rar
operator|->
name|start_new_table
operator|=
literal|1
expr_stmt|;
return|return
name|read_data_compressed
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|size
argument_list|,
name|offset
argument_list|)
return|;
case|case
literal|2
case|:
name|rar
operator|->
name|ppmd_eod
operator|=
literal|1
expr_stmt|;
comment|/* End Of ppmd Data. */
continue|continue;
case|case
literal|3
case|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Parsing filters is unsupported."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
case|case
literal|4
case|:
name|lzss_offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|code
operator|=
name|__archive_ppmd7_functions
operator|.
name|Ppmd7_DecodeSymbol
argument_list|(
operator|&
name|rar
operator|->
name|ppmd7_context
argument_list|,
operator|&
name|rar
operator|->
name|range_dec
operator|.
name|p
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid symbol"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|lzss_offset
operator||=
name|code
operator|<<
operator|(
name|i
operator|*
literal|8
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|length
operator|=
name|__archive_ppmd7_functions
operator|.
name|Ppmd7_DecodeSymbol
argument_list|(
operator|&
name|rar
operator|->
name|ppmd7_context
argument_list|,
operator|&
name|rar
operator|->
name|range_dec
operator|.
name|p
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid symbol"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|lzss_emit_match
argument_list|(
name|rar
argument_list|,
name|lzss_offset
operator|+
literal|2
argument_list|,
name|length
operator|+
literal|32
argument_list|)
expr_stmt|;
name|rar
operator|->
name|bytes_uncopied
operator|+=
name|length
operator|+
literal|32
expr_stmt|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
operator|(
name|length
operator|=
name|__archive_ppmd7_functions
operator|.
name|Ppmd7_DecodeSymbol
argument_list|(
operator|&
name|rar
operator|->
name|ppmd7_context
argument_list|,
operator|&
name|rar
operator|->
name|range_dec
operator|.
name|p
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid symbol"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|lzss_emit_match
argument_list|(
name|rar
argument_list|,
literal|1
argument_list|,
name|length
operator|+
literal|4
argument_list|)
expr_stmt|;
name|rar
operator|->
name|bytes_uncopied
operator|+=
name|length
operator|+
literal|4
expr_stmt|;
break|break;
default|default:
name|lzss_emit_literal
argument_list|(
name|rar
argument_list|,
name|sym
argument_list|)
expr_stmt|;
name|rar
operator|->
name|bytes_uncopied
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|start
operator|=
name|rar
operator|->
name|offset
expr_stmt|;
name|end
operator|=
name|start
operator|+
name|rar
operator|->
name|dictionary_size
expr_stmt|;
name|rar
operator|->
name|filterstart
operator|=
name|INT64_MAX
expr_stmt|;
if|if
condition|(
operator|(
name|actualend
operator|=
name|expand
argument_list|(
name|a
argument_list|,
name|end
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|actualend
operator|)
return|;
name|rar
operator|->
name|bytes_uncopied
operator|=
name|actualend
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|rar
operator|->
name|bytes_uncopied
operator|==
literal|0
condition|)
block|{
comment|/* Broken RAR files cause this case.           * NOTE: If this case were possible on a normal RAR file           * we would find out where it was actually bad and           * what we would do to solve it. */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Internal error extracting RAR file"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|rar
operator|->
name|bytes_uncopied
operator|>
operator|(
name|rar
operator|->
name|unp_buffer_size
operator|-
name|rar
operator|->
name|unp_offset
operator|)
condition|)
name|bs
operator|=
name|rar
operator|->
name|unp_buffer_size
operator|-
name|rar
operator|->
name|unp_offset
expr_stmt|;
else|else
name|bs
operator|=
operator|(
name|size_t
operator|)
name|rar
operator|->
name|bytes_uncopied
expr_stmt|;
name|ret
operator|=
name|copy_from_lzss_window
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|rar
operator|->
name|offset
argument_list|,
operator|(
name|int
operator|)
name|bs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|rar
operator|->
name|offset
operator|+=
name|bs
expr_stmt|;
name|rar
operator|->
name|bytes_uncopied
operator|-=
name|bs
expr_stmt|;
comment|/*      * If *buff is NULL, it means unp_buffer is not full.      * So we have to continue extracting a RAR file.      */
block|}
do|while
condition|(
operator|*
name|buff
operator|==
name|NULL
condition|)
do|;
name|rar
operator|->
name|unp_offset
operator|=
literal|0
expr_stmt|;
operator|*
name|size
operator|=
name|rar
operator|->
name|unp_buffer_size
expr_stmt|;
operator|*
name|offset
operator|=
name|rar
operator|->
name|offset_outgoing
expr_stmt|;
name|rar
operator|->
name|offset_outgoing
operator|+=
operator|*
name|size
expr_stmt|;
comment|/* Calculate File CRC. */
name|rar
operator|->
name|crc_calculated
operator|=
name|crc32
argument_list|(
name|rar
operator|->
name|crc_calculated
argument_list|,
operator|*
name|buff
argument_list|,
operator|(
name|unsigned
operator|)
operator|*
name|size
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_codes
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|val
decl_stmt|,
name|n
decl_stmt|,
name|r
decl_stmt|;
name|unsigned
name|char
name|bitlengths
index|[
name|MAX_SYMBOLS
index|]
decl_stmt|,
name|zerocount
decl_stmt|,
name|ppmd_flags
decl_stmt|;
name|unsigned
name|int
name|maxorder
decl_stmt|;
name|struct
name|huffman_code
name|precode
decl_stmt|;
name|struct
name|rar
modifier|*
name|rar
init|=
operator|(
expr|struct
name|rar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
name|struct
name|rar_br
modifier|*
name|br
init|=
operator|&
operator|(
name|rar
operator|->
name|br
operator|)
decl_stmt|;
name|free_codes
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|/* Skip to the next byte */
name|rar_br_consume_unalined_bits
argument_list|(
name|br
argument_list|)
expr_stmt|;
comment|/* PPMd block flag */
if|if
condition|(
operator|!
name|rar_br_read_ahead
argument_list|(
name|a
argument_list|,
name|br
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|truncated_data
goto|;
if|if
condition|(
operator|(
name|rar
operator|->
name|is_ppmd_block
operator|=
name|rar_br_bits
argument_list|(
name|br
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|rar_br_consume
argument_list|(
name|br
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rar_br_read_ahead
argument_list|(
name|a
argument_list|,
name|br
argument_list|,
literal|7
argument_list|)
condition|)
goto|goto
name|truncated_data
goto|;
name|ppmd_flags
operator|=
name|rar_br_bits
argument_list|(
name|br
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|rar_br_consume
argument_list|(
name|br
argument_list|,
literal|7
argument_list|)
expr_stmt|;
comment|/* Memory is allocated in MB */
if|if
condition|(
name|ppmd_flags
operator|&
literal|0x20
condition|)
block|{
if|if
condition|(
operator|!
name|rar_br_read_ahead
argument_list|(
name|a
argument_list|,
name|br
argument_list|,
literal|8
argument_list|)
condition|)
goto|goto
name|truncated_data
goto|;
name|rar
operator|->
name|dictionary_size
operator|=
operator|(
name|rar_br_bits
argument_list|(
name|br
argument_list|,
literal|8
argument_list|)
operator|+
literal|1
operator|)
operator|<<
literal|20
expr_stmt|;
name|rar_br_consume
argument_list|(
name|br
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ppmd_flags
operator|&
literal|0x40
condition|)
block|{
if|if
condition|(
operator|!
name|rar_br_read_ahead
argument_list|(
name|a
argument_list|,
name|br
argument_list|,
literal|8
argument_list|)
condition|)
goto|goto
name|truncated_data
goto|;
name|rar
operator|->
name|ppmd_escape
operator|=
name|rar
operator|->
name|ppmd7_context
operator|.
name|InitEsc
operator|=
name|rar_br_bits
argument_list|(
name|br
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|rar_br_consume
argument_list|(
name|br
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
name|rar
operator|->
name|ppmd_escape
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|ppmd_flags
operator|&
literal|0x20
condition|)
block|{
name|maxorder
operator|=
operator|(
name|ppmd_flags
operator|&
literal|0x1F
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|maxorder
operator|>
literal|16
condition|)
name|maxorder
operator|=
literal|16
operator|+
operator|(
name|maxorder
operator|-
literal|16
operator|)
operator|*
literal|3
expr_stmt|;
if|if
condition|(
name|maxorder
operator|==
literal|1
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated RAR file data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Make sure ppmd7_contest is freed before Ppmd7_Construct        * because reading a broken file cause this abnormal sequence. */
name|__archive_ppmd7_functions
operator|.
name|Ppmd7_Free
argument_list|(
operator|&
name|rar
operator|->
name|ppmd7_context
argument_list|,
operator|&
name|g_szalloc
argument_list|)
expr_stmt|;
name|rar
operator|->
name|bytein
operator|.
name|a
operator|=
name|a
expr_stmt|;
name|rar
operator|->
name|bytein
operator|.
name|Read
operator|=
operator|&
name|ppmd_read
expr_stmt|;
name|__archive_ppmd7_functions
operator|.
name|PpmdRAR_RangeDec_CreateVTable
argument_list|(
operator|&
name|rar
operator|->
name|range_dec
argument_list|)
expr_stmt|;
name|rar
operator|->
name|range_dec
operator|.
name|Stream
operator|=
operator|&
name|rar
operator|->
name|bytein
expr_stmt|;
name|__archive_ppmd7_functions
operator|.
name|Ppmd7_Construct
argument_list|(
operator|&
name|rar
operator|->
name|ppmd7_context
argument_list|)
expr_stmt|;
if|if
condition|(
name|rar
operator|->
name|dictionary_size
operator|==
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid zero dictionary size"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|__archive_ppmd7_functions
operator|.
name|Ppmd7_Alloc
argument_list|(
operator|&
name|rar
operator|->
name|ppmd7_context
argument_list|,
name|rar
operator|->
name|dictionary_size
argument_list|,
operator|&
name|g_szalloc
argument_list|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|__archive_ppmd7_functions
operator|.
name|PpmdRAR_RangeDec_Init
argument_list|(
operator|&
name|rar
operator|->
name|range_dec
argument_list|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Unable to initialize PPMd range decoder"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|__archive_ppmd7_functions
operator|.
name|Ppmd7_Init
argument_list|(
operator|&
name|rar
operator|->
name|ppmd7_context
argument_list|,
name|maxorder
argument_list|)
expr_stmt|;
name|rar
operator|->
name|ppmd_valid
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rar
operator|->
name|ppmd_valid
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid PPMd sequence"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|__archive_ppmd7_functions
operator|.
name|PpmdRAR_RangeDec_Init
argument_list|(
operator|&
name|rar
operator|->
name|range_dec
argument_list|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Unable to initialize PPMd range decoder"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
name|rar_br_consume
argument_list|(
name|br
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Keep existing table flag */
if|if
condition|(
operator|!
name|rar_br_read_ahead
argument_list|(
name|a
argument_list|,
name|br
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|truncated_data
goto|;
if|if
condition|(
operator|!
name|rar_br_bits
argument_list|(
name|br
argument_list|,
literal|1
argument_list|)
condition|)
name|memset
argument_list|(
name|rar
operator|->
name|lengthtable
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rar
operator|->
name|lengthtable
argument_list|)
argument_list|)
expr_stmt|;
name|rar_br_consume
argument_list|(
name|br
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|bitlengths
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|bitlengths
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_SYMBOLS
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|rar_br_read_ahead
argument_list|(
name|a
argument_list|,
name|br
argument_list|,
literal|4
argument_list|)
condition|)
goto|goto
name|truncated_data
goto|;
name|bitlengths
index|[
name|i
operator|++
index|]
operator|=
name|rar_br_bits
argument_list|(
name|br
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|rar_br_consume
argument_list|(
name|br
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitlengths
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|0xF
condition|)
block|{
if|if
condition|(
operator|!
name|rar_br_read_ahead
argument_list|(
name|a
argument_list|,
name|br
argument_list|,
literal|4
argument_list|)
condition|)
goto|goto
name|truncated_data
goto|;
name|zerocount
operator|=
name|rar_br_bits
argument_list|(
name|br
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|rar_br_consume
argument_list|(
name|br
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|zerocount
condition|)
block|{
name|i
operator|--
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|zerocount
operator|+
literal|2
operator|&&
name|i
operator|<
name|MAX_SYMBOLS
condition|;
name|j
operator|++
control|)
name|bitlengths
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|memset
argument_list|(
operator|&
name|precode
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|precode
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|create_code
argument_list|(
name|a
argument_list|,
operator|&
name|precode
argument_list|,
name|bitlengths
argument_list|,
name|MAX_SYMBOLS
argument_list|,
name|MAX_SYMBOL_LENGTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|free
argument_list|(
name|precode
operator|.
name|tree
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|precode
operator|.
name|table
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HUFFMAN_TABLE_SIZE
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|val
operator|=
name|read_next_symbol
argument_list|(
name|a
argument_list|,
operator|&
name|precode
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|precode
operator|.
name|tree
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|precode
operator|.
name|table
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|val
operator|<
literal|16
condition|)
block|{
name|rar
operator|->
name|lengthtable
index|[
name|i
index|]
operator|=
operator|(
name|rar
operator|->
name|lengthtable
index|[
name|i
index|]
operator|+
name|val
operator|)
operator|&
literal|0xF
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|<
literal|18
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|precode
operator|.
name|tree
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|precode
operator|.
name|table
argument_list|)
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Internal error extracting RAR file."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|val
operator|==
literal|16
condition|)
block|{
if|if
condition|(
operator|!
name|rar_br_read_ahead
argument_list|(
name|a
argument_list|,
name|br
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|precode
operator|.
name|tree
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|precode
operator|.
name|table
argument_list|)
expr_stmt|;
goto|goto
name|truncated_data
goto|;
block|}
name|n
operator|=
name|rar_br_bits
argument_list|(
name|br
argument_list|,
literal|3
argument_list|)
operator|+
literal|3
expr_stmt|;
name|rar_br_consume
argument_list|(
name|br
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rar_br_read_ahead
argument_list|(
name|a
argument_list|,
name|br
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|precode
operator|.
name|tree
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|precode
operator|.
name|table
argument_list|)
expr_stmt|;
goto|goto
name|truncated_data
goto|;
block|}
name|n
operator|=
name|rar_br_bits
argument_list|(
name|br
argument_list|,
literal|7
argument_list|)
operator|+
literal|11
expr_stmt|;
name|rar_br_consume
argument_list|(
name|br
argument_list|,
literal|7
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
operator|&&
name|i
operator|<
name|HUFFMAN_TABLE_SIZE
condition|;
name|j
operator|++
control|)
block|{
name|rar
operator|->
name|lengthtable
index|[
name|i
index|]
operator|=
name|rar
operator|->
name|lengthtable
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|val
operator|==
literal|18
condition|)
block|{
if|if
condition|(
operator|!
name|rar_br_read_ahead
argument_list|(
name|a
argument_list|,
name|br
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|precode
operator|.
name|tree
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|precode
operator|.
name|table
argument_list|)
expr_stmt|;
goto|goto
name|truncated_data
goto|;
block|}
name|n
operator|=
name|rar_br_bits
argument_list|(
name|br
argument_list|,
literal|3
argument_list|)
operator|+
literal|3
expr_stmt|;
name|rar_br_consume
argument_list|(
name|br
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rar_br_read_ahead
argument_list|(
name|a
argument_list|,
name|br
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|precode
operator|.
name|tree
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|precode
operator|.
name|table
argument_list|)
expr_stmt|;
goto|goto
name|truncated_data
goto|;
block|}
name|n
operator|=
name|rar_br_bits
argument_list|(
name|br
argument_list|,
literal|7
argument_list|)
operator|+
literal|11
expr_stmt|;
name|rar_br_consume
argument_list|(
name|br
argument_list|,
literal|7
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
operator|&&
name|i
operator|<
name|HUFFMAN_TABLE_SIZE
condition|;
name|j
operator|++
control|)
name|rar
operator|->
name|lengthtable
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|precode
operator|.
name|tree
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|precode
operator|.
name|table
argument_list|)
expr_stmt|;
name|r
operator|=
name|create_code
argument_list|(
name|a
argument_list|,
operator|&
name|rar
operator|->
name|maincode
argument_list|,
operator|&
name|rar
operator|->
name|lengthtable
index|[
literal|0
index|]
argument_list|,
name|MAINCODE_SIZE
argument_list|,
name|MAX_SYMBOL_LENGTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|r
operator|=
name|create_code
argument_list|(
name|a
argument_list|,
operator|&
name|rar
operator|->
name|offsetcode
argument_list|,
operator|&
name|rar
operator|->
name|lengthtable
index|[
name|MAINCODE_SIZE
index|]
argument_list|,
name|OFFSETCODE_SIZE
argument_list|,
name|MAX_SYMBOL_LENGTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|r
operator|=
name|create_code
argument_list|(
name|a
argument_list|,
operator|&
name|rar
operator|->
name|lowoffsetcode
argument_list|,
operator|&
name|rar
operator|->
name|lengthtable
index|[
name|MAINCODE_SIZE
operator|+
name|OFFSETCODE_SIZE
index|]
argument_list|,
name|LOWOFFSETCODE_SIZE
argument_list|,
name|MAX_SYMBOL_LENGTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|r
operator|=
name|create_code
argument_list|(
name|a
argument_list|,
operator|&
name|rar
operator|->
name|lengthcode
argument_list|,
operator|&
name|rar
operator|->
name|lengthtable
index|[
name|MAINCODE_SIZE
operator|+
name|OFFSETCODE_SIZE
operator|+
name|LOWOFFSETCODE_SIZE
index|]
argument_list|,
name|LENGTHCODE_SIZE
argument_list|,
name|MAX_SYMBOL_LENGTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|rar
operator|->
name|dictionary_size
operator|||
operator|!
name|rar
operator|->
name|lzss
operator|.
name|window
condition|)
block|{
comment|/* Seems as though dictionary sizes are not used. Even so, minimize      * memory usage as much as possible.      */
name|void
modifier|*
name|new_window
decl_stmt|;
name|unsigned
name|int
name|new_size
decl_stmt|;
if|if
condition|(
name|rar
operator|->
name|unp_size
operator|>=
name|DICTIONARY_MAX_SIZE
condition|)
name|new_size
operator|=
name|DICTIONARY_MAX_SIZE
expr_stmt|;
else|else
name|new_size
operator|=
name|rar_fls
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|rar
operator|->
name|unp_size
argument_list|)
operator|<<
literal|1
expr_stmt|;
name|new_window
operator|=
name|realloc
argument_list|(
name|rar
operator|->
name|lzss
operator|.
name|window
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_window
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Unable to allocate memory for uncompressed data."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|rar
operator|->
name|lzss
operator|.
name|window
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|new_window
expr_stmt|;
name|rar
operator|->
name|dictionary_size
operator|=
name|new_size
expr_stmt|;
name|memset
argument_list|(
name|rar
operator|->
name|lzss
operator|.
name|window
argument_list|,
literal|0
argument_list|,
name|rar
operator|->
name|dictionary_size
argument_list|)
expr_stmt|;
name|rar
operator|->
name|lzss
operator|.
name|mask
operator|=
name|rar
operator|->
name|dictionary_size
operator|-
literal|1
expr_stmt|;
block|}
name|rar
operator|->
name|start_new_table
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
name|truncated_data
label|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated RAR file data"
argument_list|)
expr_stmt|;
name|rar
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_codes
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|rar
modifier|*
name|rar
init|=
operator|(
expr|struct
name|rar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
name|free
argument_list|(
name|rar
operator|->
name|maincode
operator|.
name|tree
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rar
operator|->
name|offsetcode
operator|.
name|tree
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rar
operator|->
name|lowoffsetcode
operator|.
name|tree
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rar
operator|->
name|lengthcode
operator|.
name|tree
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rar
operator|->
name|maincode
operator|.
name|table
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rar
operator|->
name|offsetcode
operator|.
name|table
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rar
operator|->
name|lowoffsetcode
operator|.
name|table
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rar
operator|->
name|lengthcode
operator|.
name|table
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|rar
operator|->
name|maincode
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rar
operator|->
name|maincode
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|rar
operator|->
name|offsetcode
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rar
operator|->
name|offsetcode
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|rar
operator|->
name|lowoffsetcode
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rar
operator|->
name|lowoffsetcode
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|rar
operator|->
name|lengthcode
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rar
operator|->
name|lengthcode
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_next_symbol
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|huffman_code
modifier|*
name|code
parameter_list|)
block|{
name|unsigned
name|char
name|bit
decl_stmt|;
name|unsigned
name|int
name|bits
decl_stmt|;
name|int
name|length
decl_stmt|,
name|value
decl_stmt|,
name|node
decl_stmt|;
name|struct
name|rar
modifier|*
name|rar
decl_stmt|;
name|struct
name|rar_br
modifier|*
name|br
decl_stmt|;
if|if
condition|(
operator|!
name|code
operator|->
name|table
condition|)
block|{
if|if
condition|(
name|make_table
argument_list|(
name|a
argument_list|,
name|code
argument_list|)
operator|!=
operator|(
name|ARCHIVE_OK
operator|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
name|rar
operator|=
operator|(
expr|struct
name|rar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
name|br
operator|=
operator|&
operator|(
name|rar
operator|->
name|br
operator|)
expr_stmt|;
comment|/* Look ahead (peek) at bits */
if|if
condition|(
operator|!
name|rar_br_read_ahead
argument_list|(
name|a
argument_list|,
name|br
argument_list|,
name|code
operator|->
name|tablesize
argument_list|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated RAR file data"
argument_list|)
expr_stmt|;
name|rar
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bits
operator|=
name|rar_br_bits
argument_list|(
name|br
argument_list|,
name|code
operator|->
name|tablesize
argument_list|)
expr_stmt|;
name|length
operator|=
name|code
operator|->
name|table
index|[
name|bits
index|]
operator|.
name|length
expr_stmt|;
name|value
operator|=
name|code
operator|->
name|table
index|[
name|bits
index|]
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid prefix code in bitstream"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|length
operator|<=
name|code
operator|->
name|tablesize
condition|)
block|{
comment|/* Skip length bits */
name|rar_br_consume
argument_list|(
name|br
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
comment|/* Skip tablesize bits */
name|rar_br_consume
argument_list|(
name|br
argument_list|,
name|code
operator|->
name|tablesize
argument_list|)
expr_stmt|;
name|node
operator|=
name|value
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|code
operator|->
name|tree
index|[
name|node
index|]
operator|.
name|branches
index|[
literal|0
index|]
operator|==
name|code
operator|->
name|tree
index|[
name|node
index|]
operator|.
name|branches
index|[
literal|1
index|]
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|rar_br_read_ahead
argument_list|(
name|a
argument_list|,
name|br
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated RAR file data"
argument_list|)
expr_stmt|;
name|rar
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bit
operator|=
name|rar_br_bits
argument_list|(
name|br
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rar_br_consume
argument_list|(
name|br
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|->
name|tree
index|[
name|node
index|]
operator|.
name|branches
index|[
name|bit
index|]
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid prefix code in bitstream"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|node
operator|=
name|code
operator|->
name|tree
index|[
name|node
index|]
operator|.
name|branches
index|[
name|bit
index|]
expr_stmt|;
block|}
return|return
name|code
operator|->
name|tree
index|[
name|node
index|]
operator|.
name|branches
index|[
literal|0
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|create_code
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|huffman_code
modifier|*
name|code
parameter_list|,
name|unsigned
name|char
modifier|*
name|lengths
parameter_list|,
name|int
name|numsymbols
parameter_list|,
name|char
name|maxlength
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|codebits
init|=
literal|0
decl_stmt|,
name|symbolsleft
init|=
name|numsymbols
decl_stmt|;
name|code
operator|->
name|numentries
operator|=
literal|0
expr_stmt|;
name|code
operator|->
name|numallocatedentries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|new_node
argument_list|(
name|code
argument_list|)
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Unable to allocate memory for node data."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|code
operator|->
name|numentries
operator|=
literal|1
expr_stmt|;
name|code
operator|->
name|minlength
operator|=
name|INT_MAX
expr_stmt|;
name|code
operator|->
name|maxlength
operator|=
name|INT_MIN
expr_stmt|;
name|codebits
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|maxlength
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numsymbols
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|lengths
index|[
name|j
index|]
operator|!=
name|i
condition|)
continue|continue;
if|if
condition|(
name|add_value
argument_list|(
name|a
argument_list|,
name|code
argument_list|,
name|j
argument_list|,
name|codebits
argument_list|,
name|i
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|codebits
operator|++
expr_stmt|;
if|if
condition|(
operator|--
name|symbolsleft
operator|<=
literal|0
condition|)
block|{
break|break;
break|break;
block|}
block|}
name|codebits
operator|<<=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_value
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|huffman_code
modifier|*
name|code
parameter_list|,
name|int
name|value
parameter_list|,
name|int
name|codebits
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|repeatpos
decl_stmt|,
name|lastnode
decl_stmt|,
name|bitpos
decl_stmt|,
name|bit
decl_stmt|,
name|repeatnode
decl_stmt|,
name|nextnode
decl_stmt|;
name|free
argument_list|(
name|code
operator|->
name|table
argument_list|)
expr_stmt|;
name|code
operator|->
name|table
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|length
operator|>
name|code
operator|->
name|maxlength
condition|)
name|code
operator|->
name|maxlength
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|length
operator|<
name|code
operator|->
name|minlength
condition|)
name|code
operator|->
name|minlength
operator|=
name|length
expr_stmt|;
name|repeatpos
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|repeatpos
operator|==
literal|0
operator|||
operator|(
name|repeatpos
operator|>=
literal|0
operator|&&
operator|(
operator|(
operator|(
name|codebits
operator|>>
operator|(
name|repeatpos
operator|-
literal|1
operator|)
operator|)
operator|&
literal|3
operator|)
operator|==
literal|0
operator|||
operator|(
operator|(
name|codebits
operator|>>
operator|(
name|repeatpos
operator|-
literal|1
operator|)
operator|)
operator|&
literal|3
operator|)
operator|==
literal|3
operator|)
operator|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid repeat position"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|lastnode
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bitpos
operator|=
name|length
operator|-
literal|1
init|;
name|bitpos
operator|>=
literal|0
condition|;
name|bitpos
operator|--
control|)
block|{
name|bit
operator|=
operator|(
name|codebits
operator|>>
name|bitpos
operator|)
operator|&
literal|1
expr_stmt|;
comment|/* Leaf node check */
if|if
condition|(
name|code
operator|->
name|tree
index|[
name|lastnode
index|]
operator|.
name|branches
index|[
literal|0
index|]
operator|==
name|code
operator|->
name|tree
index|[
name|lastnode
index|]
operator|.
name|branches
index|[
literal|1
index|]
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Prefix found"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|bitpos
operator|==
name|repeatpos
condition|)
block|{
comment|/* Open branch check */
if|if
condition|(
operator|!
operator|(
name|code
operator|->
name|tree
index|[
name|lastnode
index|]
operator|.
name|branches
index|[
name|bit
index|]
operator|<
literal|0
operator|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid repeating code"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|repeatnode
operator|=
name|new_node
argument_list|(
name|code
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Unable to allocate memory for node data."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|nextnode
operator|=
name|new_node
argument_list|(
name|code
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Unable to allocate memory for node data."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Set branches */
name|code
operator|->
name|tree
index|[
name|lastnode
index|]
operator|.
name|branches
index|[
name|bit
index|]
operator|=
name|repeatnode
expr_stmt|;
name|code
operator|->
name|tree
index|[
name|repeatnode
index|]
operator|.
name|branches
index|[
name|bit
index|]
operator|=
name|repeatnode
expr_stmt|;
name|code
operator|->
name|tree
index|[
name|repeatnode
index|]
operator|.
name|branches
index|[
name|bit
operator|^
literal|1
index|]
operator|=
name|nextnode
expr_stmt|;
name|lastnode
operator|=
name|nextnode
expr_stmt|;
name|bitpos
operator|++
expr_stmt|;
comment|/* terminating bit already handled, skip it */
block|}
else|else
block|{
comment|/* Open branch check */
if|if
condition|(
name|code
operator|->
name|tree
index|[
name|lastnode
index|]
operator|.
name|branches
index|[
name|bit
index|]
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|new_node
argument_list|(
name|code
argument_list|)
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Unable to allocate memory for node data."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|code
operator|->
name|tree
index|[
name|lastnode
index|]
operator|.
name|branches
index|[
name|bit
index|]
operator|=
name|code
operator|->
name|numentries
operator|++
expr_stmt|;
block|}
comment|/* set to branch */
name|lastnode
operator|=
name|code
operator|->
name|tree
index|[
name|lastnode
index|]
operator|.
name|branches
index|[
name|bit
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|code
operator|->
name|tree
index|[
name|lastnode
index|]
operator|.
name|branches
index|[
literal|0
index|]
operator|==
operator|-
literal|1
operator|&&
name|code
operator|->
name|tree
index|[
name|lastnode
index|]
operator|.
name|branches
index|[
literal|1
index|]
operator|==
operator|-
literal|2
operator|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Prefix found"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Set leaf value */
name|code
operator|->
name|tree
index|[
name|lastnode
index|]
operator|.
name|branches
index|[
literal|0
index|]
operator|=
name|value
expr_stmt|;
name|code
operator|->
name|tree
index|[
name|lastnode
index|]
operator|.
name|branches
index|[
literal|1
index|]
operator|=
name|value
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|new_node
parameter_list|(
name|struct
name|huffman_code
modifier|*
name|code
parameter_list|)
block|{
name|void
modifier|*
name|new_tree
decl_stmt|;
if|if
condition|(
name|code
operator|->
name|numallocatedentries
operator|==
name|code
operator|->
name|numentries
condition|)
block|{
name|int
name|new_num_entries
init|=
literal|256
decl_stmt|;
if|if
condition|(
name|code
operator|->
name|numentries
operator|>
literal|0
condition|)
block|{
name|new_num_entries
operator|=
name|code
operator|->
name|numentries
operator|*
literal|2
expr_stmt|;
block|}
name|new_tree
operator|=
name|realloc
argument_list|(
name|code
operator|->
name|tree
argument_list|,
name|new_num_entries
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|code
operator|->
name|tree
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_tree
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|code
operator|->
name|tree
operator|=
operator|(
expr|struct
name|huffman_tree_node
operator|*
operator|)
name|new_tree
expr_stmt|;
name|code
operator|->
name|numallocatedentries
operator|=
name|new_num_entries
expr_stmt|;
block|}
name|code
operator|->
name|tree
index|[
name|code
operator|->
name|numentries
index|]
operator|.
name|branches
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|code
operator|->
name|tree
index|[
name|code
operator|->
name|numentries
index|]
operator|.
name|branches
index|[
literal|1
index|]
operator|=
operator|-
literal|2
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|make_table
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|huffman_code
modifier|*
name|code
parameter_list|)
block|{
if|if
condition|(
name|code
operator|->
name|maxlength
operator|<
name|code
operator|->
name|minlength
operator|||
name|code
operator|->
name|maxlength
operator|>
literal|10
condition|)
name|code
operator|->
name|tablesize
operator|=
literal|10
expr_stmt|;
else|else
name|code
operator|->
name|tablesize
operator|=
name|code
operator|->
name|maxlength
expr_stmt|;
name|code
operator|->
name|table
operator|=
operator|(
expr|struct
name|huffman_table_entry
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|code
operator|->
name|table
argument_list|)
operator|*
operator|(
operator|(
name|size_t
operator|)
literal|1
operator|<<
name|code
operator|->
name|tablesize
operator|)
argument_list|)
expr_stmt|;
return|return
name|make_table_recurse
argument_list|(
name|a
argument_list|,
name|code
argument_list|,
literal|0
argument_list|,
name|code
operator|->
name|table
argument_list|,
literal|0
argument_list|,
name|code
operator|->
name|tablesize
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|make_table_recurse
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|huffman_code
modifier|*
name|code
parameter_list|,
name|int
name|node
parameter_list|,
name|struct
name|huffman_table_entry
modifier|*
name|table
parameter_list|,
name|int
name|depth
parameter_list|,
name|int
name|maxdepth
parameter_list|)
block|{
name|int
name|currtablesize
decl_stmt|,
name|i
decl_stmt|,
name|ret
init|=
operator|(
name|ARCHIVE_OK
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|code
operator|->
name|tree
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Huffman tree was not created."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|node
operator|<
literal|0
operator|||
name|node
operator|>=
name|code
operator|->
name|numentries
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid location to Huffman tree specified."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|currtablesize
operator|=
literal|1
operator|<<
operator|(
name|maxdepth
operator|-
name|depth
operator|)
expr_stmt|;
if|if
condition|(
name|code
operator|->
name|tree
index|[
name|node
index|]
operator|.
name|branches
index|[
literal|0
index|]
operator|==
name|code
operator|->
name|tree
index|[
name|node
index|]
operator|.
name|branches
index|[
literal|1
index|]
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|currtablesize
condition|;
name|i
operator|++
control|)
block|{
name|table
index|[
name|i
index|]
operator|.
name|length
operator|=
name|depth
expr_stmt|;
name|table
index|[
name|i
index|]
operator|.
name|value
operator|=
name|code
operator|->
name|tree
index|[
name|node
index|]
operator|.
name|branches
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|currtablesize
condition|;
name|i
operator|++
control|)
name|table
index|[
name|i
index|]
operator|.
name|length
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|depth
operator|==
name|maxdepth
condition|)
block|{
name|table
index|[
literal|0
index|]
operator|.
name|length
operator|=
name|maxdepth
operator|+
literal|1
expr_stmt|;
name|table
index|[
literal|0
index|]
operator|.
name|value
operator|=
name|node
expr_stmt|;
block|}
else|else
block|{
name|ret
operator||=
name|make_table_recurse
argument_list|(
name|a
argument_list|,
name|code
argument_list|,
name|code
operator|->
name|tree
index|[
name|node
index|]
operator|.
name|branches
index|[
literal|0
index|]
argument_list|,
name|table
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|maxdepth
argument_list|)
expr_stmt|;
name|ret
operator||=
name|make_table_recurse
argument_list|(
name|a
argument_list|,
name|code
argument_list|,
name|code
operator|->
name|tree
index|[
name|node
index|]
operator|.
name|branches
index|[
literal|1
index|]
argument_list|,
name|table
operator|+
name|currtablesize
operator|/
literal|2
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|maxdepth
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int64_t
name|expand
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|int64_t
name|end
parameter_list|)
block|{
specifier|static
specifier|const
name|unsigned
name|char
name|lengthbases
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|10
block|,
literal|12
block|,
literal|14
block|,
literal|16
block|,
literal|20
block|,
literal|24
block|,
literal|28
block|,
literal|32
block|,
literal|40
block|,
literal|48
block|,
literal|56
block|,
literal|64
block|,
literal|80
block|,
literal|96
block|,
literal|112
block|,
literal|128
block|,
literal|160
block|,
literal|192
block|,
literal|224
block|}
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|char
name|lengthbits
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|}
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|int
name|offsetbases
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|8
block|,
literal|12
block|,
literal|16
block|,
literal|24
block|,
literal|32
block|,
literal|48
block|,
literal|64
block|,
literal|96
block|,
literal|128
block|,
literal|192
block|,
literal|256
block|,
literal|384
block|,
literal|512
block|,
literal|768
block|,
literal|1024
block|,
literal|1536
block|,
literal|2048
block|,
literal|3072
block|,
literal|4096
block|,
literal|6144
block|,
literal|8192
block|,
literal|12288
block|,
literal|16384
block|,
literal|24576
block|,
literal|32768
block|,
literal|49152
block|,
literal|65536
block|,
literal|98304
block|,
literal|131072
block|,
literal|196608
block|,
literal|262144
block|,
literal|327680
block|,
literal|393216
block|,
literal|458752
block|,
literal|524288
block|,
literal|589824
block|,
literal|655360
block|,
literal|720896
block|,
literal|786432
block|,
literal|851968
block|,
literal|917504
block|,
literal|983040
block|,
literal|1048576
block|,
literal|1310720
block|,
literal|1572864
block|,
literal|1835008
block|,
literal|2097152
block|,
literal|2359296
block|,
literal|2621440
block|,
literal|2883584
block|,
literal|3145728
block|,
literal|3407872
block|,
literal|3670016
block|,
literal|3932160
block|}
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|char
name|offsetbits
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|8
block|,
literal|8
block|,
literal|9
block|,
literal|9
block|,
literal|10
block|,
literal|10
block|,
literal|11
block|,
literal|11
block|,
literal|12
block|,
literal|12
block|,
literal|13
block|,
literal|13
block|,
literal|14
block|,
literal|14
block|,
literal|15
block|,
literal|15
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|}
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|char
name|shortbases
index|[]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|8
block|,
literal|16
block|,
literal|32
block|,
literal|64
block|,
literal|128
block|,
literal|192
block|}
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|char
name|shortbits
index|[]
init|=
block|{
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|}
decl_stmt|;
name|int
name|symbol
decl_stmt|,
name|offs
decl_stmt|,
name|len
decl_stmt|,
name|offsindex
decl_stmt|,
name|lensymbol
decl_stmt|,
name|i
decl_stmt|,
name|offssymbol
decl_stmt|,
name|lowoffsetsymbol
decl_stmt|;
name|unsigned
name|char
name|newfile
decl_stmt|;
name|struct
name|rar
modifier|*
name|rar
init|=
operator|(
expr|struct
name|rar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
name|struct
name|rar_br
modifier|*
name|br
init|=
operator|&
operator|(
name|rar
operator|->
name|br
operator|)
decl_stmt|;
if|if
condition|(
name|rar
operator|->
name|filterstart
operator|<
name|end
condition|)
name|end
operator|=
name|rar
operator|->
name|filterstart
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|rar
operator|->
name|output_last_match
operator|&&
name|lzss_position
argument_list|(
operator|&
name|rar
operator|->
name|lzss
argument_list|)
operator|+
name|rar
operator|->
name|lastlength
operator|<=
name|end
condition|)
block|{
name|lzss_emit_match
argument_list|(
name|rar
argument_list|,
name|rar
operator|->
name|lastoffset
argument_list|,
name|rar
operator|->
name|lastlength
argument_list|)
expr_stmt|;
name|rar
operator|->
name|output_last_match
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rar
operator|->
name|is_ppmd_block
operator|||
name|rar
operator|->
name|output_last_match
operator|||
name|lzss_position
argument_list|(
operator|&
name|rar
operator|->
name|lzss
argument_list|)
operator|>=
name|end
condition|)
return|return
name|lzss_position
argument_list|(
operator|&
name|rar
operator|->
name|lzss
argument_list|)
return|;
if|if
condition|(
operator|(
name|symbol
operator|=
name|read_next_symbol
argument_list|(
name|a
argument_list|,
operator|&
name|rar
operator|->
name|maincode
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|rar
operator|->
name|output_last_match
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|symbol
operator|<
literal|256
condition|)
block|{
name|lzss_emit_literal
argument_list|(
name|rar
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|symbol
operator|==
literal|256
condition|)
block|{
if|if
condition|(
operator|!
name|rar_br_read_ahead
argument_list|(
name|a
argument_list|,
name|br
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|truncated_data
goto|;
name|newfile
operator|=
operator|!
name|rar_br_bits
argument_list|(
name|br
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rar_br_consume
argument_list|(
name|br
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfile
condition|)
block|{
name|rar
operator|->
name|start_new_block
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|rar_br_read_ahead
argument_list|(
name|a
argument_list|,
name|br
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|truncated_data
goto|;
name|rar
operator|->
name|start_new_table
operator|=
name|rar_br_bits
argument_list|(
name|br
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rar_br_consume
argument_list|(
name|br
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|lzss_position
argument_list|(
operator|&
name|rar
operator|->
name|lzss
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|parse_codes
argument_list|(
name|a
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|symbol
operator|==
literal|257
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Parsing filters is unsupported."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|symbol
operator|==
literal|258
condition|)
block|{
if|if
condition|(
name|rar
operator|->
name|lastlength
operator|==
literal|0
condition|)
continue|continue;
name|offs
operator|=
name|rar
operator|->
name|lastoffset
expr_stmt|;
name|len
operator|=
name|rar
operator|->
name|lastlength
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symbol
operator|<=
literal|262
condition|)
block|{
name|offsindex
operator|=
name|symbol
operator|-
literal|259
expr_stmt|;
name|offs
operator|=
name|rar
operator|->
name|oldoffset
index|[
name|offsindex
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|lensymbol
operator|=
name|read_next_symbol
argument_list|(
name|a
argument_list|,
operator|&
name|rar
operator|->
name|lengthcode
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|bad_data
goto|;
if|if
condition|(
name|lensymbol
operator|>
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|lengthbases
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|lengthbases
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
goto|goto
name|bad_data
goto|;
if|if
condition|(
name|lensymbol
operator|>
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|lengthbits
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|lengthbits
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
goto|goto
name|bad_data
goto|;
name|len
operator|=
name|lengthbases
index|[
name|lensymbol
index|]
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|lengthbits
index|[
name|lensymbol
index|]
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|rar_br_read_ahead
argument_list|(
name|a
argument_list|,
name|br
argument_list|,
name|lengthbits
index|[
name|lensymbol
index|]
argument_list|)
condition|)
goto|goto
name|truncated_data
goto|;
name|len
operator|+=
name|rar_br_bits
argument_list|(
name|br
argument_list|,
name|lengthbits
index|[
name|lensymbol
index|]
argument_list|)
expr_stmt|;
name|rar_br_consume
argument_list|(
name|br
argument_list|,
name|lengthbits
index|[
name|lensymbol
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|offsindex
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|rar
operator|->
name|oldoffset
index|[
name|i
index|]
operator|=
name|rar
operator|->
name|oldoffset
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|rar
operator|->
name|oldoffset
index|[
literal|0
index|]
operator|=
name|offs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symbol
operator|<=
literal|270
condition|)
block|{
name|offs
operator|=
name|shortbases
index|[
name|symbol
operator|-
literal|263
index|]
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|shortbits
index|[
name|symbol
operator|-
literal|263
index|]
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|rar_br_read_ahead
argument_list|(
name|a
argument_list|,
name|br
argument_list|,
name|shortbits
index|[
name|symbol
operator|-
literal|263
index|]
argument_list|)
condition|)
goto|goto
name|truncated_data
goto|;
name|offs
operator|+=
name|rar_br_bits
argument_list|(
name|br
argument_list|,
name|shortbits
index|[
name|symbol
operator|-
literal|263
index|]
argument_list|)
expr_stmt|;
name|rar_br_consume
argument_list|(
name|br
argument_list|,
name|shortbits
index|[
name|symbol
operator|-
literal|263
index|]
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|rar
operator|->
name|oldoffset
index|[
name|i
index|]
operator|=
name|rar
operator|->
name|oldoffset
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|rar
operator|->
name|oldoffset
index|[
literal|0
index|]
operator|=
name|offs
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|symbol
operator|-
literal|271
operator|>
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|lengthbases
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|lengthbases
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
goto|goto
name|bad_data
goto|;
if|if
condition|(
name|symbol
operator|-
literal|271
operator|>
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|lengthbits
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|lengthbits
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
goto|goto
name|bad_data
goto|;
name|len
operator|=
name|lengthbases
index|[
name|symbol
operator|-
literal|271
index|]
operator|+
literal|3
expr_stmt|;
if|if
condition|(
name|lengthbits
index|[
name|symbol
operator|-
literal|271
index|]
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|rar_br_read_ahead
argument_list|(
name|a
argument_list|,
name|br
argument_list|,
name|lengthbits
index|[
name|symbol
operator|-
literal|271
index|]
argument_list|)
condition|)
goto|goto
name|truncated_data
goto|;
name|len
operator|+=
name|rar_br_bits
argument_list|(
name|br
argument_list|,
name|lengthbits
index|[
name|symbol
operator|-
literal|271
index|]
argument_list|)
expr_stmt|;
name|rar_br_consume
argument_list|(
name|br
argument_list|,
name|lengthbits
index|[
name|symbol
operator|-
literal|271
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|offssymbol
operator|=
name|read_next_symbol
argument_list|(
name|a
argument_list|,
operator|&
name|rar
operator|->
name|offsetcode
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|bad_data
goto|;
if|if
condition|(
name|offssymbol
operator|>
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|offsetbases
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|offsetbases
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
goto|goto
name|bad_data
goto|;
if|if
condition|(
name|offssymbol
operator|>
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|offsetbits
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|offsetbits
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
goto|goto
name|bad_data
goto|;
name|offs
operator|=
name|offsetbases
index|[
name|offssymbol
index|]
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|offsetbits
index|[
name|offssymbol
index|]
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|offssymbol
operator|>
literal|9
condition|)
block|{
if|if
condition|(
name|offsetbits
index|[
name|offssymbol
index|]
operator|>
literal|4
condition|)
block|{
if|if
condition|(
operator|!
name|rar_br_read_ahead
argument_list|(
name|a
argument_list|,
name|br
argument_list|,
name|offsetbits
index|[
name|offssymbol
index|]
operator|-
literal|4
argument_list|)
condition|)
goto|goto
name|truncated_data
goto|;
name|offs
operator|+=
name|rar_br_bits
argument_list|(
name|br
argument_list|,
name|offsetbits
index|[
name|offssymbol
index|]
operator|-
literal|4
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|rar_br_consume
argument_list|(
name|br
argument_list|,
name|offsetbits
index|[
name|offssymbol
index|]
operator|-
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rar
operator|->
name|numlowoffsetrepeats
operator|>
literal|0
condition|)
block|{
name|rar
operator|->
name|numlowoffsetrepeats
operator|--
expr_stmt|;
name|offs
operator|+=
name|rar
operator|->
name|lastlowoffset
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|lowoffsetsymbol
operator|=
name|read_next_symbol
argument_list|(
name|a
argument_list|,
operator|&
name|rar
operator|->
name|lowoffsetcode
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
if|if
condition|(
name|lowoffsetsymbol
operator|==
literal|16
condition|)
block|{
name|rar
operator|->
name|numlowoffsetrepeats
operator|=
literal|15
expr_stmt|;
name|offs
operator|+=
name|rar
operator|->
name|lastlowoffset
expr_stmt|;
block|}
else|else
block|{
name|offs
operator|+=
name|lowoffsetsymbol
expr_stmt|;
name|rar
operator|->
name|lastlowoffset
operator|=
name|lowoffsetsymbol
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rar_br_read_ahead
argument_list|(
name|a
argument_list|,
name|br
argument_list|,
name|offsetbits
index|[
name|offssymbol
index|]
argument_list|)
condition|)
goto|goto
name|truncated_data
goto|;
name|offs
operator|+=
name|rar_br_bits
argument_list|(
name|br
argument_list|,
name|offsetbits
index|[
name|offssymbol
index|]
argument_list|)
expr_stmt|;
name|rar_br_consume
argument_list|(
name|br
argument_list|,
name|offsetbits
index|[
name|offssymbol
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|offs
operator|>=
literal|0x40000
condition|)
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|offs
operator|>=
literal|0x2000
condition|)
name|len
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|rar
operator|->
name|oldoffset
index|[
name|i
index|]
operator|=
name|rar
operator|->
name|oldoffset
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|rar
operator|->
name|oldoffset
index|[
literal|0
index|]
operator|=
name|offs
expr_stmt|;
block|}
name|rar
operator|->
name|lastoffset
operator|=
name|offs
expr_stmt|;
name|rar
operator|->
name|lastlength
operator|=
name|len
expr_stmt|;
name|rar
operator|->
name|output_last_match
operator|=
literal|1
expr_stmt|;
block|}
name|truncated_data
label|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated RAR file data"
argument_list|)
expr_stmt|;
name|rar
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|bad_data
label|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Bad RAR file data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|copy_from_lzss_window
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buffer
parameter_list|,
name|int64_t
name|startpos
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|windowoffs
decl_stmt|,
name|firstpart
decl_stmt|;
name|struct
name|rar
modifier|*
name|rar
init|=
operator|(
expr|struct
name|rar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|rar
operator|->
name|unp_buffer
condition|)
block|{
if|if
condition|(
operator|(
name|rar
operator|->
name|unp_buffer
operator|=
name|malloc
argument_list|(
name|rar
operator|->
name|unp_buffer_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Unable to allocate memory for uncompressed data."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
name|windowoffs
operator|=
name|lzss_offset_for_position
argument_list|(
operator|&
name|rar
operator|->
name|lzss
argument_list|,
name|startpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|windowoffs
operator|+
name|length
operator|<=
name|lzss_size
argument_list|(
operator|&
name|rar
operator|->
name|lzss
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|rar
operator|->
name|unp_buffer
index|[
name|rar
operator|->
name|unp_offset
index|]
argument_list|,
operator|&
name|rar
operator|->
name|lzss
operator|.
name|window
index|[
name|windowoffs
index|]
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|length
operator|<=
name|lzss_size
argument_list|(
operator|&
name|rar
operator|->
name|lzss
argument_list|)
condition|)
block|{
name|firstpart
operator|=
name|lzss_size
argument_list|(
operator|&
name|rar
operator|->
name|lzss
argument_list|)
operator|-
name|windowoffs
expr_stmt|;
if|if
condition|(
name|firstpart
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Bad RAR file data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|firstpart
operator|<
name|length
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|rar
operator|->
name|unp_buffer
index|[
name|rar
operator|->
name|unp_offset
index|]
argument_list|,
operator|&
name|rar
operator|->
name|lzss
operator|.
name|window
index|[
name|windowoffs
index|]
argument_list|,
name|firstpart
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|rar
operator|->
name|unp_buffer
index|[
name|rar
operator|->
name|unp_offset
operator|+
name|firstpart
index|]
argument_list|,
operator|&
name|rar
operator|->
name|lzss
operator|.
name|window
index|[
literal|0
index|]
argument_list|,
name|length
operator|-
name|firstpart
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
operator|&
name|rar
operator|->
name|unp_buffer
index|[
name|rar
operator|->
name|unp_offset
index|]
argument_list|,
operator|&
name|rar
operator|->
name|lzss
operator|.
name|window
index|[
name|windowoffs
index|]
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Bad RAR file data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|rar
operator|->
name|unp_offset
operator|+=
name|length
expr_stmt|;
if|if
condition|(
name|rar
operator|->
name|unp_offset
operator|>=
name|rar
operator|->
name|unp_buffer_size
condition|)
operator|*
name|buffer
operator|=
name|rar
operator|->
name|unp_buffer
expr_stmt|;
else|else
operator|*
name|buffer
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|void
modifier|*
name|rar_read_ahead
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|size_t
name|min
parameter_list|,
name|ssize_t
modifier|*
name|avail
parameter_list|)
block|{
name|struct
name|rar
modifier|*
name|rar
init|=
operator|(
expr|struct
name|rar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
specifier|const
name|void
modifier|*
name|h
init|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|min
argument_list|,
name|avail
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|avail
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|archive
operator|.
name|read_data_is_posix_read
operator|&&
operator|*
name|avail
operator|>
operator|(
name|ssize_t
operator|)
name|a
operator|->
name|archive
operator|.
name|read_data_requested
condition|)
operator|*
name|avail
operator|=
name|a
operator|->
name|archive
operator|.
name|read_data_requested
expr_stmt|;
if|if
condition|(
operator|*
name|avail
operator|>
name|rar
operator|->
name|bytes_remaining
condition|)
operator|*
name|avail
operator|=
operator|(
name|ssize_t
operator|)
name|rar
operator|->
name|bytes_remaining
expr_stmt|;
if|if
condition|(
operator|*
name|avail
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
elseif|else
if|if
condition|(
operator|*
name|avail
operator|==
literal|0
operator|&&
name|rar
operator|->
name|main_flags
operator|&
name|MHD_VOLUME
operator|&&
name|rar
operator|->
name|file_flags
operator|&
name|FHD_SPLIT_AFTER
condition|)
block|{
name|ret
operator|=
name|archive_read_format_rar_read_header
argument_list|(
name|a
argument_list|,
name|a
operator|->
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
name|ARCHIVE_EOF
operator|)
condition|)
block|{
name|rar
operator|->
name|has_endarc_header
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|archive_read_format_rar_read_header
argument_list|(
name|a
argument_list|,
name|a
operator|->
name|entry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|!=
operator|(
name|ARCHIVE_OK
operator|)
condition|)
return|return
name|NULL
return|;
return|return
name|rar_read_ahead
argument_list|(
name|a
argument_list|,
name|min
argument_list|,
name|avail
argument_list|)
return|;
block|}
block|}
return|return
name|h
return|;
block|}
end_function

end_unit

