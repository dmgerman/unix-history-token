begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010-2012 Michihiro NAKAJIMA  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"archive_platform.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ERRNO_H
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIMITS_H
end_ifdef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"archive.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry_locale.h"
end_include

begin_include
include|#
directive|include
file|"archive_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_read_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_endian.h"
end_include

begin_struct
struct|struct
name|lzx_dec
block|{
comment|/* Decoding status. */
name|int
name|state
decl_stmt|;
comment|/* 	 * Window to see last decoded data, from 32KBi to 2MBi. 	 */
name|int
name|w_size
decl_stmt|;
name|int
name|w_mask
decl_stmt|;
comment|/* Window buffer, which is a loop buffer. */
name|unsigned
name|char
modifier|*
name|w_buff
decl_stmt|;
comment|/* The insert position to the window. */
name|int
name|w_pos
decl_stmt|;
comment|/* The position where we can copy decoded code from the window. */
name|int
name|copy_pos
decl_stmt|;
comment|/* The length how many bytes we can copy decoded code from 	 * the window. */
name|int
name|copy_len
decl_stmt|;
comment|/* Translation reversal for x86 proccessor CALL byte sequence(E8). 	 * This is used for LZX only. */
name|uint32_t
name|translation_size
decl_stmt|;
name|char
name|translation
decl_stmt|;
name|char
name|block_type
decl_stmt|;
define|#
directive|define
name|VERBATIM_BLOCK
value|1
define|#
directive|define
name|ALIGNED_OFFSET_BLOCK
value|2
define|#
directive|define
name|UNCOMPRESSED_BLOCK
value|3
name|size_t
name|block_size
decl_stmt|;
name|size_t
name|block_bytes_avail
decl_stmt|;
comment|/* Repeated offset. */
name|int
name|r0
decl_stmt|,
name|r1
decl_stmt|,
name|r2
decl_stmt|;
name|unsigned
name|char
name|rbytes
index|[
literal|4
index|]
decl_stmt|;
name|int
name|rbytes_avail
decl_stmt|;
name|int
name|length_header
decl_stmt|;
name|int
name|position_slot
decl_stmt|;
name|int
name|offset_bits
decl_stmt|;
struct|struct
name|lzx_pos_tbl
block|{
name|int
name|base
decl_stmt|;
name|int
name|footer_bits
decl_stmt|;
block|}
modifier|*
name|pos_tbl
struct|;
comment|/* 	 * Bit stream reader. 	 */
struct|struct
name|lzx_br
block|{
define|#
directive|define
name|CACHE_TYPE
value|uint64_t
define|#
directive|define
name|CACHE_BITS
value|(8 * sizeof(CACHE_TYPE))
comment|/* Cache buffer. */
name|CACHE_TYPE
name|cache_buffer
decl_stmt|;
comment|/* Indicates how many bits avail in cache_buffer. */
name|int
name|cache_avail
decl_stmt|;
name|unsigned
name|char
name|odd
decl_stmt|;
name|char
name|have_odd
decl_stmt|;
block|}
name|br
struct|;
comment|/* 	 * Huffman coding. 	 */
struct|struct
name|huffman
block|{
name|int
name|len_size
decl_stmt|;
name|int
name|freq
index|[
literal|17
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bitlen
decl_stmt|;
comment|/* 		 * Use a index table. It's faster than searching a huffman 		 * coding tree, which is a binary tree. But a use of a large 		 * index table causes L1 cache read miss many times. 		 */
define|#
directive|define
name|HTBL_BITS
value|10
name|int
name|max_bits
decl_stmt|;
name|int
name|shift_bits
decl_stmt|;
name|int
name|tbl_bits
decl_stmt|;
name|int
name|tree_used
decl_stmt|;
name|int
name|tree_avail
decl_stmt|;
comment|/* Direct access table. */
name|uint16_t
modifier|*
name|tbl
decl_stmt|;
comment|/* Binary tree table for extra bits over the direct access. */
struct|struct
name|htree_t
block|{
name|uint16_t
name|left
decl_stmt|;
name|uint16_t
name|right
decl_stmt|;
block|}
modifier|*
name|tree
struct|;
block|}
name|at
struct|,
name|lt
struct|,
name|mt
struct|,
name|pt
struct|;
name|int
name|loop
decl_stmt|;
name|int
name|error
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|int
name|slots
index|[]
init|=
block|{
literal|30
block|,
literal|32
block|,
literal|34
block|,
literal|36
block|,
literal|38
block|,
literal|42
block|,
literal|50
block|,
literal|66
block|,
literal|98
block|,
literal|162
block|,
literal|290
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SLOT_BASE
value|15
end_define

begin_define
define|#
directive|define
name|SLOT_MAX
value|21
end_define

begin_comment
comment|/*->25*/
end_comment

begin_struct
struct|struct
name|lzx_stream
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|next_in
decl_stmt|;
name|int64_t
name|avail_in
decl_stmt|;
name|int64_t
name|total_in
decl_stmt|;
name|unsigned
name|char
modifier|*
name|next_out
decl_stmt|;
name|int64_t
name|avail_out
decl_stmt|;
name|int64_t
name|total_out
decl_stmt|;
name|struct
name|lzx_dec
modifier|*
name|ds
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Cabinet file definitions.  */
end_comment

begin_comment
comment|/* CFHEADER offset */
end_comment

begin_define
define|#
directive|define
name|CFHEADER_signature
value|0
end_define

begin_define
define|#
directive|define
name|CFHEADER_cbCabinet
value|8
end_define

begin_define
define|#
directive|define
name|CFHEADER_coffFiles
value|16
end_define

begin_define
define|#
directive|define
name|CFHEADER_versionMinor
value|24
end_define

begin_define
define|#
directive|define
name|CFHEADER_versionMajor
value|25
end_define

begin_define
define|#
directive|define
name|CFHEADER_cFolders
value|26
end_define

begin_define
define|#
directive|define
name|CFHEADER_cFiles
value|28
end_define

begin_define
define|#
directive|define
name|CFHEADER_flags
value|30
end_define

begin_define
define|#
directive|define
name|CFHEADER_setID
value|32
end_define

begin_define
define|#
directive|define
name|CFHEADER_iCabinet
value|34
end_define

begin_define
define|#
directive|define
name|CFHEADER_cbCFHeader
value|36
end_define

begin_define
define|#
directive|define
name|CFHEADER_cbCFFolder
value|38
end_define

begin_define
define|#
directive|define
name|CFHEADER_cbCFData
value|39
end_define

begin_comment
comment|/* CFFOLDER offset */
end_comment

begin_define
define|#
directive|define
name|CFFOLDER_coffCabStart
value|0
end_define

begin_define
define|#
directive|define
name|CFFOLDER_cCFData
value|4
end_define

begin_define
define|#
directive|define
name|CFFOLDER_typeCompress
value|6
end_define

begin_define
define|#
directive|define
name|CFFOLDER_abReserve
value|8
end_define

begin_comment
comment|/* CFFILE offset */
end_comment

begin_define
define|#
directive|define
name|CFFILE_cbFile
value|0
end_define

begin_define
define|#
directive|define
name|CFFILE_uoffFolderStart
value|4
end_define

begin_define
define|#
directive|define
name|CFFILE_iFolder
value|8
end_define

begin_define
define|#
directive|define
name|CFFILE_date_time
value|10
end_define

begin_define
define|#
directive|define
name|CFFILE_attribs
value|14
end_define

begin_comment
comment|/* CFDATA offset */
end_comment

begin_define
define|#
directive|define
name|CFDATA_csum
value|0
end_define

begin_define
define|#
directive|define
name|CFDATA_cbData
value|4
end_define

begin_define
define|#
directive|define
name|CFDATA_cbUncomp
value|6
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|compression_name
index|[]
init|=
block|{
literal|"NONE"
block|,
literal|"MSZIP"
block|,
literal|"Quantum"
block|,
literal|"LZX"
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|cfdata
block|{
comment|/* Sum value of this CFDATA. */
name|uint32_t
name|sum
decl_stmt|;
name|uint16_t
name|compressed_size
decl_stmt|;
name|uint16_t
name|compressed_bytes_remaining
decl_stmt|;
name|uint16_t
name|uncompressed_size
decl_stmt|;
name|uint16_t
name|uncompressed_bytes_remaining
decl_stmt|;
comment|/* To know how many bytes we have decompressed. */
name|uint16_t
name|uncompressed_avail
decl_stmt|;
comment|/* Offset from the beginning of compressed data of this CFDATA */
name|uint16_t
name|read_offset
decl_stmt|;
name|int64_t
name|unconsumed
decl_stmt|;
comment|/* To keep memory image of this CFDATA to compute the sum. */
name|size_t
name|memimage_size
decl_stmt|;
name|unsigned
name|char
modifier|*
name|memimage
decl_stmt|;
comment|/* Result of calculation of sum. */
name|uint32_t
name|sum_calculated
decl_stmt|;
name|unsigned
name|char
name|sum_extra
index|[
literal|4
index|]
decl_stmt|;
name|int
name|sum_extra_avail
decl_stmt|;
specifier|const
name|void
modifier|*
name|sum_ptr
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|cffolder
block|{
name|uint32_t
name|cfdata_offset_in_cab
decl_stmt|;
name|uint16_t
name|cfdata_count
decl_stmt|;
name|uint16_t
name|comptype
decl_stmt|;
define|#
directive|define
name|COMPTYPE_NONE
value|0x0000
define|#
directive|define
name|COMPTYPE_MSZIP
value|0x0001
define|#
directive|define
name|COMPTYPE_QUANTUM
value|0x0002
define|#
directive|define
name|COMPTYPE_LZX
value|0x0003
name|uint16_t
name|compdata
decl_stmt|;
specifier|const
name|char
modifier|*
name|compname
decl_stmt|;
comment|/* At the time reading CFDATA */
name|struct
name|cfdata
name|cfdata
decl_stmt|;
name|int
name|cfdata_index
decl_stmt|;
comment|/* Flags to mark progress of decompression. */
name|char
name|decompress_init
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|cffile
block|{
name|uint32_t
name|uncompressed_size
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|;
name|time_t
name|mtime
decl_stmt|;
name|uint16_t
name|folder
decl_stmt|;
define|#
directive|define
name|iFoldCONTINUED_FROM_PREV
value|0xFFFD
define|#
directive|define
name|iFoldCONTINUED_TO_NEXT
value|0xFFFE
define|#
directive|define
name|iFoldCONTINUED_PREV_AND_NEXT
value|0xFFFF
name|unsigned
name|char
name|attr
decl_stmt|;
define|#
directive|define
name|ATTR_RDONLY
value|0x01
define|#
directive|define
name|ATTR_NAME_IS_UTF
value|0x80
name|struct
name|archive_string
name|pathname
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|cfheader
block|{
comment|/* Total bytes of all file size in a Cabinet. */
name|uint32_t
name|total_bytes
decl_stmt|;
name|uint32_t
name|files_offset
decl_stmt|;
name|uint16_t
name|folder_count
decl_stmt|;
name|uint16_t
name|file_count
decl_stmt|;
name|uint16_t
name|flags
decl_stmt|;
define|#
directive|define
name|PREV_CABINET
value|0x0001
define|#
directive|define
name|NEXT_CABINET
value|0x0002
define|#
directive|define
name|RESERVE_PRESENT
value|0x0004
name|uint16_t
name|setid
decl_stmt|;
name|uint16_t
name|cabinet
decl_stmt|;
comment|/* Version number. */
name|unsigned
name|char
name|major
decl_stmt|;
name|unsigned
name|char
name|minor
decl_stmt|;
name|unsigned
name|char
name|cffolder
decl_stmt|;
name|unsigned
name|char
name|cfdata
decl_stmt|;
comment|/* All folders in a cabinet. */
name|struct
name|cffolder
modifier|*
name|folder_array
decl_stmt|;
comment|/* All files in a cabinet. */
name|struct
name|cffile
modifier|*
name|file_array
decl_stmt|;
name|int
name|file_index
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|cab
block|{
comment|/* entry_bytes_remaining is the number of bytes we expect.	    */
name|int64_t
name|entry_offset
decl_stmt|;
name|int64_t
name|entry_bytes_remaining
decl_stmt|;
name|int64_t
name|entry_unconsumed
decl_stmt|;
name|int64_t
name|entry_compressed_bytes_read
decl_stmt|;
name|int64_t
name|entry_uncompressed_bytes_read
decl_stmt|;
name|struct
name|cffolder
modifier|*
name|entry_cffolder
decl_stmt|;
name|struct
name|cffile
modifier|*
name|entry_cffile
decl_stmt|;
name|struct
name|cfdata
modifier|*
name|entry_cfdata
decl_stmt|;
comment|/* Offset from beginning of a cabinet file. */
name|int64_t
name|cab_offset
decl_stmt|;
name|struct
name|cfheader
name|cfheader
decl_stmt|;
name|struct
name|archive_wstring
name|ws
decl_stmt|;
comment|/* Flag to mark progress that an archive was read their first header.*/
name|char
name|found_header
decl_stmt|;
name|char
name|end_of_archive
decl_stmt|;
name|char
name|end_of_entry
decl_stmt|;
name|char
name|end_of_entry_cleanup
decl_stmt|;
name|char
name|read_data_invoked
decl_stmt|;
name|int64_t
name|bytes_skipped
decl_stmt|;
name|unsigned
name|char
modifier|*
name|uncompressed_buffer
decl_stmt|;
name|size_t
name|uncompressed_buffer_size
decl_stmt|;
name|int
name|init_default_conversion
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|sconv
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|sconv_default
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|sconv_utf8
decl_stmt|;
name|char
name|format_name
index|[
literal|64
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
name|z_stream
name|stream
decl_stmt|;
name|char
name|stream_valid
decl_stmt|;
endif|#
directive|endif
name|struct
name|lzx_stream
name|xstrm
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|archive_read_format_cab_bid
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_cab_options
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_cab_read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_cab_read_data
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|int64_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_cab_read_data_skip
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_cab_cleanup
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cab_skip_sfx
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|time_t
name|cab_dos_time
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cab_read_data
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|int64_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cab_read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|cab_checksum_cfdata_4
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
name|bytes
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|cab_checksum_cfdata
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
name|bytes
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cab_checksum_update
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cab_checksum_finish
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cab_next_cfdata
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|void
modifier|*
name|cab_read_ahead_cfdata
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|ssize_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|void
modifier|*
name|cab_read_ahead_cfdata_none
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|ssize_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|void
modifier|*
name|cab_read_ahead_cfdata_deflate
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|ssize_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|void
modifier|*
name|cab_read_ahead_cfdata_lzx
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|ssize_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|cab_consume_cfdata
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|cab_minimum_consume_cfdata
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lzx_decode_init
parameter_list|(
name|struct
name|lzx_stream
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lzx_read_blocks
parameter_list|(
name|struct
name|lzx_stream
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lzx_decode_blocks
parameter_list|(
name|struct
name|lzx_stream
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lzx_decode_free
parameter_list|(
name|struct
name|lzx_stream
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lzx_translation
parameter_list|(
name|struct
name|lzx_stream
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lzx_cleanup_bitstream
parameter_list|(
name|struct
name|lzx_stream
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lzx_decode
parameter_list|(
name|struct
name|lzx_stream
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lzx_read_pre_tree
parameter_list|(
name|struct
name|lzx_stream
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lzx_read_bitlen
parameter_list|(
name|struct
name|lzx_stream
modifier|*
parameter_list|,
name|struct
name|huffman
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lzx_huffman_init
parameter_list|(
name|struct
name|huffman
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lzx_huffman_free
parameter_list|(
name|struct
name|huffman
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lzx_make_huffman_table
parameter_list|(
name|struct
name|huffman
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|lzx_decode_huffman
parameter_list|(
name|struct
name|huffman
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lzx_decode_huffman_tree
parameter_list|(
name|struct
name|huffman
modifier|*
parameter_list|,
name|unsigned
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|archive_read_support_format_cab
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|struct
name|cab
modifier|*
name|cab
decl_stmt|;
name|int
name|r
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_READ_MAGIC
argument_list|,
name|ARCHIVE_STATE_NEW
argument_list|,
literal|"archive_read_support_format_cab"
argument_list|)
expr_stmt|;
name|cab
operator|=
operator|(
expr|struct
name|cab
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cab
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cab
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate CAB data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_string_init
argument_list|(
operator|&
name|cab
operator|->
name|ws
argument_list|)
expr_stmt|;
name|archive_wstring_ensure
argument_list|(
operator|&
name|cab
operator|->
name|ws
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|r
operator|=
name|__archive_read_register_format
argument_list|(
name|a
argument_list|,
name|cab
argument_list|,
literal|"cab"
argument_list|,
name|archive_read_format_cab_bid
argument_list|,
name|archive_read_format_cab_options
argument_list|,
name|archive_read_format_cab_read_header
argument_list|,
name|archive_read_format_cab_read_data
argument_list|,
name|archive_read_format_cab_read_data_skip
argument_list|,
name|NULL
argument_list|,
name|archive_read_format_cab_cleanup
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|free
argument_list|(
name|cab
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|find_cab_magic
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
switch|switch
condition|(
name|p
index|[
literal|4
index|]
condition|)
block|{
case|case
literal|0
case|:
comment|/* 		 * Note: Self-Extraction program has 'MSCF' string in their 		 * program. If we were finding 'MSCF' string only, we got 		 * wrong place for Cabinet header, thus, we have to check 		 * following four bytes which are reserved and must be set 		 * to zero. 		 */
if|if
condition|(
name|memcmp
argument_list|(
name|p
argument_list|,
literal|"MSCF\0\0\0\0"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|5
return|;
case|case
literal|'F'
case|:
return|return
literal|1
return|;
case|case
literal|'C'
case|:
return|return
literal|2
return|;
case|case
literal|'S'
case|:
return|return
literal|3
return|;
case|case
literal|'M'
case|:
return|return
literal|4
return|;
default|default:
return|return
literal|5
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_cab_bid
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|int
name|best_bid
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ssize_t
name|bytes_avail
decl_stmt|,
name|offset
decl_stmt|,
name|window
decl_stmt|;
comment|/* If there's already a better bid than we can ever 	   make, don't bother testing. */
if|if
condition|(
name|best_bid
operator|>
literal|64
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|8
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|p
argument_list|,
literal|"MSCF\0\0\0\0"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|64
operator|)
return|;
comment|/* 	 * Attempt to handle self-extracting archives 	 * by noting a PE header and searching forward 	 * up to 128k for a 'MSCF' marker. 	 */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'M'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'Z'
condition|)
block|{
name|offset
operator|=
literal|0
expr_stmt|;
name|window
operator|=
literal|4096
expr_stmt|;
while|while
condition|(
name|offset
operator|<
operator|(
literal|1024
operator|*
literal|128
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|h
init|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|offset
operator|+
name|window
argument_list|,
operator|&
name|bytes_avail
argument_list|)
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
comment|/* Remaining bytes are less than window. */
name|window
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|window
operator|<
literal|128
condition|)
return|return
operator|(
literal|0
operator|)
return|;
continue|continue;
block|}
name|p
operator|=
name|h
operator|+
name|offset
expr_stmt|;
while|while
condition|(
name|p
operator|+
literal|8
operator|<
name|h
operator|+
name|bytes_avail
condition|)
block|{
name|int
name|next
decl_stmt|;
if|if
condition|(
operator|(
name|next
operator|=
name|find_cab_magic
argument_list|(
name|p
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|64
operator|)
return|;
name|p
operator|+=
name|next
expr_stmt|;
block|}
name|offset
operator|=
name|p
operator|-
name|h
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_cab_options
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|cab
modifier|*
name|cab
decl_stmt|;
name|int
name|ret
init|=
name|ARCHIVE_FAILED
decl_stmt|;
name|cab
operator|=
operator|(
expr|struct
name|cab
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"hdrcharset"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|val
operator|==
name|NULL
operator|||
name|val
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"cab: hdrcharset option needs a character-set name"
argument_list|)
expr_stmt|;
else|else
block|{
name|cab
operator|->
name|sconv
operator|=
name|archive_string_conversion_from_charset
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cab
operator|->
name|sconv
operator|!=
name|NULL
condition|)
name|ret
operator|=
name|ARCHIVE_OK
expr_stmt|;
else|else
name|ret
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* Note: The "warn" return is just to inform the options 	 * supervisor that we didn't handle it.  It will generate 	 * a suitable error if no one used this option. */
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cab_skip_sfx
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|size_t
name|skip
decl_stmt|;
name|ssize_t
name|bytes
decl_stmt|,
name|window
decl_stmt|;
name|window
operator|=
literal|4096
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|h
init|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|window
argument_list|,
operator|&
name|bytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
comment|/* Remaining size are less than window. */
name|window
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|window
operator|<
literal|128
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Couldn't find out CAB header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
continue|continue;
block|}
name|p
operator|=
name|h
expr_stmt|;
name|q
operator|=
name|p
operator|+
name|bytes
expr_stmt|;
comment|/* 		 * Scan ahead until we find something that looks 		 * like the cab header. 		 */
while|while
condition|(
name|p
operator|+
literal|8
operator|<
name|q
condition|)
block|{
name|int
name|next
decl_stmt|;
if|if
condition|(
operator|(
name|next
operator|=
name|find_cab_magic
argument_list|(
name|p
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|skip
operator|=
name|p
operator|-
name|h
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|skip
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
name|p
operator|+=
name|next
expr_stmt|;
block|}
name|skip
operator|=
name|p
operator|-
name|h
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|skip
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|truncated_error
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated CAB header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|cab_strnlen
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|maxlen
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|maxlen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
name|i
index|]
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>
name|maxlen
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* invalid */
return|return
operator|(
operator|(
name|ssize_t
operator|)
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read bytes as much as remaining. */
end_comment

begin_function
specifier|static
specifier|const
name|void
modifier|*
name|cab_read_ahead_remaining
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|size_t
name|min
parameter_list|,
name|ssize_t
modifier|*
name|avail
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|p
decl_stmt|;
while|while
condition|(
name|min
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|min
argument_list|,
name|avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
return|return
operator|(
name|p
operator|)
return|;
name|min
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert a path separator '\' -> '/' */
end_comment

begin_function
specifier|static
name|int
name|cab_convert_path_separator_1
parameter_list|(
name|struct
name|archive_string
modifier|*
name|fn
parameter_list|,
name|unsigned
name|char
name|attr
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|int
name|mb
decl_stmt|;
comment|/* Easy check if we have '\' in multi-byte string. */
name|mb
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|archive_strlen
argument_list|(
name|fn
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fn
operator|->
name|s
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|mb
condition|)
block|{
comment|/* This may be second byte of multi-byte 				 * character. */
break|break;
block|}
name|fn
operator|->
name|s
index|[
name|i
index|]
operator|=
literal|'/'
expr_stmt|;
name|mb
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|fn
operator|->
name|s
index|[
name|i
index|]
operator|&
literal|0x80
operator|)
operator|&&
operator|!
operator|(
name|attr
operator|&
name|ATTR_NAME_IS_UTF
operator|)
condition|)
name|mb
operator|=
literal|1
expr_stmt|;
else|else
name|mb
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|archive_strlen
argument_list|(
name|fn
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Replace a character '\' with '/' in wide character.  */
end_comment

begin_function
specifier|static
name|void
name|cab_convert_path_separator_2
parameter_list|(
name|struct
name|cab
modifier|*
name|cab
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
specifier|const
name|wchar_t
modifier|*
name|wp
decl_stmt|;
name|size_t
name|i
decl_stmt|;
comment|/* If a conversion to wide character failed, force the replacement. */
if|if
condition|(
operator|(
name|wp
operator|=
name|archive_entry_pathname_w
argument_list|(
name|entry
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|archive_wstrcpy
argument_list|(
operator|&
operator|(
name|cab
operator|->
name|ws
operator|)
argument_list|,
name|wp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|archive_strlen
argument_list|(
operator|&
operator|(
name|cab
operator|->
name|ws
operator|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cab
operator|->
name|ws
operator|.
name|s
index|[
name|i
index|]
operator|==
literal|L'
expr|\\'
condition|)
name|cab
operator|->
name|ws
operator|.
name|s
index|[
name|i
index|]
operator|=
literal|L'
expr|/'
expr_stmt|;
block|}
name|archive_entry_copy_pathname_w
argument_list|(
name|entry
argument_list|,
name|cab
operator|->
name|ws
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Read CFHEADER, CFFOLDER and CFFILE.  */
end_comment

begin_function
specifier|static
name|int
name|cab_read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|cab
modifier|*
name|cab
decl_stmt|;
name|struct
name|cfheader
modifier|*
name|hd
decl_stmt|;
name|size_t
name|bytes
decl_stmt|,
name|used
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
name|int64_t
name|skip
decl_stmt|;
name|int
name|err
decl_stmt|,
name|i
decl_stmt|;
name|int
name|cur_folder
decl_stmt|,
name|prev_folder
decl_stmt|;
name|uint32_t
name|offset32
decl_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_CAB
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|==
name|NULL
condition|)
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"CAB"
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|42
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|truncated_error
argument_list|(
name|a
argument_list|)
operator|)
return|;
name|cab
operator|=
operator|(
expr|struct
name|cab
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|cab
operator|->
name|found_header
operator|==
literal|0
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'M'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'Z'
condition|)
block|{
comment|/* This is an executable?  Must be self-extracting... */
name|err
operator|=
name|cab_skip_sfx
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
name|ARCHIVE_WARN
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Re-read header after processing the SFX. */
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|42
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|truncated_error
argument_list|(
name|a
argument_list|)
operator|)
return|;
block|}
name|cab
operator|->
name|cab_offset
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Read CFHEADER. 	 */
name|hd
operator|=
operator|&
name|cab
operator|->
name|cfheader
expr_stmt|;
if|if
condition|(
name|p
index|[
name|CFHEADER_signature
operator|+
literal|0
index|]
operator|!=
literal|'M'
operator|||
name|p
index|[
name|CFHEADER_signature
operator|+
literal|1
index|]
operator|!=
literal|'S'
operator|||
name|p
index|[
name|CFHEADER_signature
operator|+
literal|2
index|]
operator|!=
literal|'C'
operator|||
name|p
index|[
name|CFHEADER_signature
operator|+
literal|3
index|]
operator|!=
literal|'F'
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Couldn't find out CAB header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|hd
operator|->
name|total_bytes
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|CFHEADER_cbCabinet
argument_list|)
expr_stmt|;
name|hd
operator|->
name|files_offset
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|CFHEADER_coffFiles
argument_list|)
expr_stmt|;
name|hd
operator|->
name|minor
operator|=
name|p
index|[
name|CFHEADER_versionMinor
index|]
expr_stmt|;
name|hd
operator|->
name|major
operator|=
name|p
index|[
name|CFHEADER_versionMajor
index|]
expr_stmt|;
name|hd
operator|->
name|folder_count
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|CFHEADER_cFolders
argument_list|)
expr_stmt|;
if|if
condition|(
name|hd
operator|->
name|folder_count
operator|==
literal|0
condition|)
goto|goto
name|invalid
goto|;
name|hd
operator|->
name|file_count
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|CFHEADER_cFiles
argument_list|)
expr_stmt|;
if|if
condition|(
name|hd
operator|->
name|file_count
operator|==
literal|0
condition|)
goto|goto
name|invalid
goto|;
name|hd
operator|->
name|flags
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|CFHEADER_flags
argument_list|)
expr_stmt|;
name|hd
operator|->
name|setid
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|CFHEADER_setID
argument_list|)
expr_stmt|;
name|hd
operator|->
name|cabinet
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|CFHEADER_iCabinet
argument_list|)
expr_stmt|;
name|used
operator|=
name|CFHEADER_iCabinet
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|hd
operator|->
name|flags
operator|&
name|RESERVE_PRESENT
condition|)
block|{
name|uint16_t
name|cfheader
decl_stmt|;
name|cfheader
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|CFHEADER_cbCFHeader
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfheader
operator|>
literal|60000U
condition|)
goto|goto
name|invalid
goto|;
name|hd
operator|->
name|cffolder
operator|=
name|p
index|[
name|CFHEADER_cbCFFolder
index|]
expr_stmt|;
name|hd
operator|->
name|cfdata
operator|=
name|p
index|[
name|CFHEADER_cbCFData
index|]
expr_stmt|;
name|used
operator|+=
literal|4
expr_stmt|;
comment|/* cbCFHeader, cbCFFolder and cbCFData */
name|used
operator|+=
name|cfheader
expr_stmt|;
comment|/* abReserve */
block|}
else|else
name|hd
operator|->
name|cffolder
operator|=
literal|0
expr_stmt|;
comment|/* Avoid compiling warning. */
if|if
condition|(
name|hd
operator|->
name|flags
operator|&
name|PREV_CABINET
condition|)
block|{
comment|/* How many bytes are used for szCabinetPrev. */
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|used
operator|+
literal|256
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|truncated_error
argument_list|(
name|a
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|len
operator|=
name|cab_strnlen
argument_list|(
name|p
operator|+
name|used
argument_list|,
literal|255
argument_list|)
operator|)
operator|<=
literal|0
condition|)
goto|goto
name|invalid
goto|;
name|used
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
comment|/* How many bytes are used for szDiskPrev. */
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|used
operator|+
literal|256
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|truncated_error
argument_list|(
name|a
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|len
operator|=
name|cab_strnlen
argument_list|(
name|p
operator|+
name|used
argument_list|,
literal|255
argument_list|)
operator|)
operator|<=
literal|0
condition|)
goto|goto
name|invalid
goto|;
name|used
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|hd
operator|->
name|flags
operator|&
name|NEXT_CABINET
condition|)
block|{
comment|/* How many bytes are used for szCabinetNext. */
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|used
operator|+
literal|256
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|truncated_error
argument_list|(
name|a
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|len
operator|=
name|cab_strnlen
argument_list|(
name|p
operator|+
name|used
argument_list|,
literal|255
argument_list|)
operator|)
operator|<=
literal|0
condition|)
goto|goto
name|invalid
goto|;
name|used
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
comment|/* How many bytes are used for szDiskNext. */
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|used
operator|+
literal|256
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|truncated_error
argument_list|(
name|a
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|len
operator|=
name|cab_strnlen
argument_list|(
name|p
operator|+
name|used
argument_list|,
literal|255
argument_list|)
operator|)
operator|<=
literal|0
condition|)
goto|goto
name|invalid
goto|;
name|used
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
block|}
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|cab
operator|->
name|cab_offset
operator|+=
name|used
expr_stmt|;
name|used
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Read CFFOLDER. 	 */
name|hd
operator|->
name|folder_array
operator|=
operator|(
expr|struct
name|cffolder
operator|*
operator|)
name|calloc
argument_list|(
name|hd
operator|->
name|folder_count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cffolder
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hd
operator|->
name|folder_array
operator|==
name|NULL
condition|)
goto|goto
name|nomem
goto|;
name|bytes
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|hd
operator|->
name|flags
operator|&
name|RESERVE_PRESENT
condition|)
name|bytes
operator|+=
name|hd
operator|->
name|cffolder
expr_stmt|;
name|bytes
operator|*=
name|hd
operator|->
name|folder_count
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|bytes
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|truncated_error
argument_list|(
name|a
argument_list|)
operator|)
return|;
name|offset32
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hd
operator|->
name|folder_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|cffolder
modifier|*
name|folder
init|=
operator|&
operator|(
name|hd
operator|->
name|folder_array
index|[
name|i
index|]
operator|)
decl_stmt|;
name|folder
operator|->
name|cfdata_offset_in_cab
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|CFFOLDER_coffCabStart
argument_list|)
expr_stmt|;
name|folder
operator|->
name|cfdata_count
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|CFFOLDER_cCFData
argument_list|)
expr_stmt|;
name|folder
operator|->
name|comptype
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|CFFOLDER_typeCompress
argument_list|)
operator|&
literal|0x0F
expr_stmt|;
name|folder
operator|->
name|compdata
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|CFFOLDER_typeCompress
argument_list|)
operator|>>
literal|8
expr_stmt|;
comment|/* Get a compression name. */
if|if
condition|(
name|folder
operator|->
name|comptype
operator|<
sizeof|sizeof
argument_list|(
name|compression_name
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|compression_name
index|[
literal|0
index|]
argument_list|)
condition|)
name|folder
operator|->
name|compname
operator|=
name|compression_name
index|[
name|folder
operator|->
name|comptype
index|]
expr_stmt|;
else|else
name|folder
operator|->
name|compname
operator|=
literal|"UNKNOWN"
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
name|used
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|hd
operator|->
name|flags
operator|&
name|RESERVE_PRESENT
condition|)
block|{
name|p
operator|+=
name|hd
operator|->
name|cffolder
expr_stmt|;
comment|/* abReserve */
name|used
operator|+=
name|hd
operator|->
name|cffolder
expr_stmt|;
block|}
comment|/* 		 * Sanity check if each data is acceptable. 		 */
if|if
condition|(
name|offset32
operator|>=
name|folder
operator|->
name|cfdata_offset_in_cab
condition|)
goto|goto
name|invalid
goto|;
name|offset32
operator|=
name|folder
operator|->
name|cfdata_offset_in_cab
expr_stmt|;
comment|/* Set a request to initialize zlib for the CFDATA of 		 * this folder. */
name|folder
operator|->
name|decompress_init
operator|=
literal|0
expr_stmt|;
block|}
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|cab
operator|->
name|cab_offset
operator|+=
name|used
expr_stmt|;
comment|/* 	 * Read CFFILE. 	 */
comment|/* Seek read pointer to the offset of CFFILE if needed. */
name|skip
operator|=
operator|(
name|int64_t
operator|)
name|hd
operator|->
name|files_offset
operator|-
name|cab
operator|->
name|cab_offset
expr_stmt|;
if|if
condition|(
name|skip
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Invalid offset of CFFILE %jd< %jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|hd
operator|->
name|files_offset
argument_list|,
operator|(
name|intmax_t
operator|)
name|cab
operator|->
name|cab_offset
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|skip
condition|)
block|{
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|skip
argument_list|)
expr_stmt|;
name|cab
operator|->
name|cab_offset
operator|+=
name|skip
expr_stmt|;
block|}
comment|/* Allocate memory for CFDATA */
name|hd
operator|->
name|file_array
operator|=
operator|(
expr|struct
name|cffile
operator|*
operator|)
name|calloc
argument_list|(
name|hd
operator|->
name|file_count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cffile
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hd
operator|->
name|file_array
operator|==
name|NULL
condition|)
goto|goto
name|nomem
goto|;
name|prev_folder
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hd
operator|->
name|file_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|cffile
modifier|*
name|file
init|=
operator|&
operator|(
name|hd
operator|->
name|file_array
index|[
name|i
index|]
operator|)
decl_stmt|;
name|ssize_t
name|avail
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|16
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|truncated_error
argument_list|(
name|a
argument_list|)
operator|)
return|;
name|file
operator|->
name|uncompressed_size
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|CFFILE_cbFile
argument_list|)
expr_stmt|;
name|file
operator|->
name|offset
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|CFFILE_uoffFolderStart
argument_list|)
expr_stmt|;
name|file
operator|->
name|folder
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|CFFILE_iFolder
argument_list|)
expr_stmt|;
name|file
operator|->
name|mtime
operator|=
name|cab_dos_time
argument_list|(
name|p
operator|+
name|CFFILE_date_time
argument_list|)
expr_stmt|;
name|file
operator|->
name|attr
operator|=
operator|(
name|uint8_t
operator|)
name|archive_le16dec
argument_list|(
name|p
operator|+
name|CFFILE_attribs
argument_list|)
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|cab
operator|->
name|cab_offset
operator|+=
literal|16
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|cab_read_ahead_remaining
argument_list|(
name|a
argument_list|,
literal|256
argument_list|,
operator|&
name|avail
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|truncated_error
argument_list|(
name|a
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|len
operator|=
name|cab_strnlen
argument_list|(
name|p
argument_list|,
name|avail
operator|-
literal|1
argument_list|)
operator|)
operator|<=
literal|0
condition|)
goto|goto
name|invalid
goto|;
comment|/* Copy a pathname.  */
name|archive_string_init
argument_list|(
operator|&
operator|(
name|file
operator|->
name|pathname
operator|)
argument_list|)
expr_stmt|;
name|archive_strncpy
argument_list|(
operator|&
operator|(
name|file
operator|->
name|pathname
operator|)
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cab
operator|->
name|cab_offset
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
comment|/* 		 * Sanity check if each data is acceptable. 		 */
if|if
condition|(
name|file
operator|->
name|uncompressed_size
operator|>
literal|0x7FFF8000
condition|)
goto|goto
name|invalid
goto|;
comment|/* Too large */
if|if
condition|(
operator|(
name|int64_t
operator|)
name|file
operator|->
name|offset
operator|+
operator|(
name|int64_t
operator|)
name|file
operator|->
name|uncompressed_size
operator|>
name|ARCHIVE_LITERAL_LL
argument_list|(
literal|0x7FFF8000
argument_list|)
condition|)
goto|goto
name|invalid
goto|;
comment|/* Too large */
switch|switch
condition|(
name|file
operator|->
name|folder
condition|)
block|{
case|case
name|iFoldCONTINUED_TO_NEXT
case|:
comment|/* This must be last file in a folder. */
if|if
condition|(
name|i
operator|!=
name|hd
operator|->
name|file_count
operator|-
literal|1
condition|)
goto|goto
name|invalid
goto|;
name|cur_folder
operator|=
name|hd
operator|->
name|folder_count
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|iFoldCONTINUED_PREV_AND_NEXT
case|:
comment|/* This must be only one file in a folder. */
if|if
condition|(
name|hd
operator|->
name|file_count
operator|!=
literal|1
condition|)
goto|goto
name|invalid
goto|;
comment|/* FALL THROUGH */
case|case
name|iFoldCONTINUED_FROM_PREV
case|:
comment|/* This must be first file in a folder. */
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
goto|goto
name|invalid
goto|;
name|prev_folder
operator|=
name|cur_folder
operator|=
literal|0
expr_stmt|;
name|offset32
operator|=
name|file
operator|->
name|offset
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|file
operator|->
name|folder
operator|>=
name|hd
operator|->
name|folder_count
condition|)
goto|goto
name|invalid
goto|;
name|cur_folder
operator|=
name|file
operator|->
name|folder
expr_stmt|;
break|break;
block|}
comment|/* Dot not back track. */
if|if
condition|(
name|cur_folder
operator|<
name|prev_folder
condition|)
goto|goto
name|invalid
goto|;
if|if
condition|(
name|cur_folder
operator|!=
name|prev_folder
condition|)
name|offset32
operator|=
literal|0
expr_stmt|;
name|prev_folder
operator|=
name|cur_folder
expr_stmt|;
comment|/* Make sure there are not any blanks from last file 		 * contents. */
if|if
condition|(
name|offset32
operator|!=
name|file
operator|->
name|offset
condition|)
goto|goto
name|invalid
goto|;
name|offset32
operator|+=
name|file
operator|->
name|uncompressed_size
expr_stmt|;
comment|/* CFDATA is available for file contents. */
if|if
condition|(
name|file
operator|->
name|uncompressed_size
operator|>
literal|0
operator|&&
name|hd
operator|->
name|folder_array
index|[
name|cur_folder
index|]
operator|.
name|cfdata_count
operator|==
literal|0
condition|)
goto|goto
name|invalid
goto|;
block|}
if|if
condition|(
name|hd
operator|->
name|cabinet
operator|!=
literal|0
operator|||
name|hd
operator|->
name|flags
operator|&
operator|(
name|PREV_CABINET
operator||
name|NEXT_CABINET
operator|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Multivolume cabinet file is unsupported"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
name|invalid
label|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid CAB header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|nomem
label|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for CAB data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_cab_read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|cab
modifier|*
name|cab
decl_stmt|;
name|struct
name|cfheader
modifier|*
name|hd
decl_stmt|;
name|struct
name|cffolder
modifier|*
name|prev_folder
decl_stmt|;
name|struct
name|cffile
modifier|*
name|file
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|sconv
decl_stmt|;
name|int
name|err
init|=
name|ARCHIVE_OK
decl_stmt|,
name|r
decl_stmt|;
name|cab
operator|=
operator|(
expr|struct
name|cab
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|cab
operator|->
name|found_header
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|cab_read_header
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
name|ARCHIVE_WARN
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* We've found the header. */
name|cab
operator|->
name|found_header
operator|=
literal|1
expr_stmt|;
block|}
name|hd
operator|=
operator|&
name|cab
operator|->
name|cfheader
expr_stmt|;
if|if
condition|(
name|hd
operator|->
name|file_index
operator|>=
name|hd
operator|->
name|file_count
condition|)
block|{
name|cab
operator|->
name|end_of_archive
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
block|}
name|file
operator|=
operator|&
name|hd
operator|->
name|file_array
index|[
name|hd
operator|->
name|file_index
operator|++
index|]
expr_stmt|;
name|cab
operator|->
name|end_of_entry
operator|=
literal|0
expr_stmt|;
name|cab
operator|->
name|end_of_entry_cleanup
operator|=
literal|0
expr_stmt|;
name|cab
operator|->
name|entry_compressed_bytes_read
operator|=
literal|0
expr_stmt|;
name|cab
operator|->
name|entry_uncompressed_bytes_read
operator|=
literal|0
expr_stmt|;
name|cab
operator|->
name|entry_unconsumed
operator|=
literal|0
expr_stmt|;
name|cab
operator|->
name|entry_cffile
operator|=
name|file
expr_stmt|;
comment|/* 	 * Choose a proper folder. 	 */
name|prev_folder
operator|=
name|cab
operator|->
name|entry_cffolder
expr_stmt|;
switch|switch
condition|(
name|file
operator|->
name|folder
condition|)
block|{
case|case
name|iFoldCONTINUED_FROM_PREV
case|:
case|case
name|iFoldCONTINUED_PREV_AND_NEXT
case|:
name|cab
operator|->
name|entry_cffolder
operator|=
operator|&
name|hd
operator|->
name|folder_array
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|iFoldCONTINUED_TO_NEXT
case|:
name|cab
operator|->
name|entry_cffolder
operator|=
operator|&
name|hd
operator|->
name|folder_array
index|[
name|hd
operator|->
name|folder_count
operator|-
literal|1
index|]
expr_stmt|;
break|break;
default|default:
name|cab
operator|->
name|entry_cffolder
operator|=
operator|&
name|hd
operator|->
name|folder_array
index|[
name|file
operator|->
name|folder
index|]
expr_stmt|;
break|break;
block|}
comment|/* If a cffolder of this file is changed, reset a cfdata to read 	 * file contents from next cfdata. */
if|if
condition|(
name|prev_folder
operator|!=
name|cab
operator|->
name|entry_cffolder
condition|)
name|cab
operator|->
name|entry_cfdata
operator|=
name|NULL
expr_stmt|;
comment|/* If a pathname is UTF-8, prepare a string conversion object 	 * for UTF-8 and use it. */
if|if
condition|(
name|file
operator|->
name|attr
operator|&
name|ATTR_NAME_IS_UTF
condition|)
block|{
if|if
condition|(
name|cab
operator|->
name|sconv_utf8
operator|==
name|NULL
condition|)
block|{
name|cab
operator|->
name|sconv_utf8
operator|=
name|archive_string_conversion_from_charset
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
literal|"UTF-8"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cab
operator|->
name|sconv_utf8
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|sconv
operator|=
name|cab
operator|->
name|sconv_utf8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cab
operator|->
name|sconv
operator|!=
name|NULL
condition|)
block|{
comment|/* Choose the conversion specified by the option. */
name|sconv
operator|=
name|cab
operator|->
name|sconv
expr_stmt|;
block|}
else|else
block|{
comment|/* Choose the default conversion. */
if|if
condition|(
operator|!
name|cab
operator|->
name|init_default_conversion
condition|)
block|{
name|cab
operator|->
name|sconv_default
operator|=
name|archive_string_default_conversion_for_read
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|)
expr_stmt|;
name|cab
operator|->
name|init_default_conversion
operator|=
literal|1
expr_stmt|;
block|}
name|sconv
operator|=
name|cab
operator|->
name|sconv_default
expr_stmt|;
block|}
comment|/* 	 * Set a default value and common data 	 */
name|r
operator|=
name|cab_convert_path_separator_1
argument_list|(
operator|&
operator|(
name|file
operator|->
name|pathname
operator|)
argument_list|,
name|file
operator|->
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_entry_copy_pathname_l
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|pathname
operator|.
name|s
argument_list|,
name|archive_strlen
argument_list|(
operator|&
operator|(
name|file
operator|->
name|pathname
operator|)
argument_list|)
argument_list|,
name|sconv
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for Pathname"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Pathname cannot be converted "
literal|"from %s to current locale."
argument_list|,
name|archive_string_conversion_charset_name
argument_list|(
name|sconv
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
comment|/* Convert a path separator '\' -> '/' */
name|cab_convert_path_separator_2
argument_list|(
name|cab
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|uncompressed_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|attr
operator|&
name|ATTR_RDONLY
condition|)
name|archive_entry_set_mode
argument_list|(
name|entry
argument_list|,
name|AE_IFREG
operator||
literal|0555
argument_list|)
expr_stmt|;
else|else
name|archive_entry_set_mode
argument_list|(
name|entry
argument_list|,
name|AE_IFREG
operator||
literal|0666
argument_list|)
expr_stmt|;
name|archive_entry_set_mtime
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|mtime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cab
operator|->
name|entry_bytes_remaining
operator|=
name|file
operator|->
name|uncompressed_size
expr_stmt|;
name|cab
operator|->
name|entry_offset
operator|=
literal|0
expr_stmt|;
comment|/* We don't need compress data. */
if|if
condition|(
name|file
operator|->
name|uncompressed_size
operator|==
literal|0
condition|)
name|cab
operator|->
name|end_of_entry_cleanup
operator|=
name|cab
operator|->
name|end_of_entry
operator|=
literal|1
expr_stmt|;
comment|/* Set up a more descriptive format name. */
name|sprintf
argument_list|(
name|cab
operator|->
name|format_name
argument_list|,
literal|"CAB %d.%d (%s)"
argument_list|,
name|hd
operator|->
name|major
argument_list|,
name|hd
operator|->
name|minor
argument_list|,
name|cab
operator|->
name|entry_cffolder
operator|->
name|compname
argument_list|)
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
name|cab
operator|->
name|format_name
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_cab_read_data
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|int64_t
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|cab
modifier|*
name|cab
init|=
operator|(
expr|struct
name|cab
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
name|int
name|r
decl_stmt|;
switch|switch
condition|(
name|cab
operator|->
name|entry_cffile
operator|->
name|folder
condition|)
block|{
case|case
name|iFoldCONTINUED_FROM_PREV
case|:
case|case
name|iFoldCONTINUED_TO_NEXT
case|:
case|case
name|iFoldCONTINUED_PREV_AND_NEXT
case|:
operator|*
name|buff
operator|=
name|NULL
expr_stmt|;
operator|*
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|offset
operator|=
literal|0
expr_stmt|;
name|archive_clear_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|)
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Cannot restore this file split in multivolume."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|cab
operator|->
name|read_data_invoked
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cab
operator|->
name|bytes_skipped
condition|)
block|{
if|if
condition|(
name|cab
operator|->
name|entry_cfdata
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|cab_next_cfdata
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
if|if
condition|(
name|cab_consume_cfdata
argument_list|(
name|a
argument_list|,
name|cab
operator|->
name|bytes_skipped
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|cab
operator|->
name|bytes_skipped
operator|=
literal|0
expr_stmt|;
block|}
name|cab
operator|->
name|read_data_invoked
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cab
operator|->
name|entry_unconsumed
condition|)
block|{
comment|/* Consume as much as the compressor actually used. */
name|r
operator|=
operator|(
name|int
operator|)
name|cab_consume_cfdata
argument_list|(
name|a
argument_list|,
name|cab
operator|->
name|entry_unconsumed
argument_list|)
expr_stmt|;
name|cab
operator|->
name|entry_unconsumed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
if|if
condition|(
name|cab
operator|->
name|end_of_archive
operator|||
name|cab
operator|->
name|end_of_entry
condition|)
block|{
if|if
condition|(
operator|!
name|cab
operator|->
name|end_of_entry_cleanup
condition|)
block|{
comment|/* End-of-entry cleanup done. */
name|cab
operator|->
name|end_of_entry_cleanup
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|offset
operator|=
name|cab
operator|->
name|entry_offset
expr_stmt|;
operator|*
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|buff
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
block|}
return|return
operator|(
name|cab_read_data
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|size
argument_list|,
name|offset
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|cab_checksum_cfdata_4
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|bytes
parameter_list|,
name|uint32_t
name|seed
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|b
decl_stmt|;
name|unsigned
name|u32num
decl_stmt|;
name|uint32_t
name|sum
decl_stmt|;
name|u32num
operator|=
operator|(
name|unsigned
operator|)
name|bytes
operator|/
literal|4
expr_stmt|;
name|sum
operator|=
name|seed
expr_stmt|;
name|b
operator|=
name|p
expr_stmt|;
for|for
control|(
init|;
name|u32num
operator|>
literal|0
condition|;
operator|--
name|u32num
control|)
block|{
name|sum
operator|^=
name|archive_le32dec
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|+=
literal|4
expr_stmt|;
block|}
return|return
operator|(
name|sum
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|cab_checksum_cfdata
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|bytes
parameter_list|,
name|uint32_t
name|seed
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|b
decl_stmt|;
name|uint32_t
name|sum
decl_stmt|;
name|uint32_t
name|t
decl_stmt|;
name|sum
operator|=
name|cab_checksum_cfdata_4
argument_list|(
name|p
argument_list|,
name|bytes
argument_list|,
name|seed
argument_list|)
expr_stmt|;
name|b
operator|=
name|p
expr_stmt|;
name|b
operator|+=
name|bytes
operator|&
operator|~
literal|3
expr_stmt|;
name|t
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|bytes
operator|&
literal|3
condition|)
block|{
case|case
literal|3
case|:
name|t
operator||=
operator|(
call|(
name|uint32_t
call|)
argument_list|(
operator|*
name|b
operator|++
argument_list|)
operator|)
operator|<<
literal|16
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|2
case|:
name|t
operator||=
operator|(
call|(
name|uint32_t
call|)
argument_list|(
operator|*
name|b
operator|++
argument_list|)
operator|)
operator|<<
literal|8
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|1
case|:
name|t
operator||=
operator|*
name|b
expr_stmt|;
comment|/* FALL THROUGH */
default|default:
break|break;
block|}
name|sum
operator|^=
name|t
expr_stmt|;
return|return
operator|(
name|sum
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cab_checksum_update
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|size_t
name|bytes
parameter_list|)
block|{
name|struct
name|cab
modifier|*
name|cab
init|=
operator|(
expr|struct
name|cab
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
name|struct
name|cfdata
modifier|*
name|cfdata
init|=
name|cab
operator|->
name|entry_cfdata
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|sumbytes
decl_stmt|;
if|if
condition|(
name|cfdata
operator|->
name|sum
operator|==
literal|0
operator|||
name|cfdata
operator|->
name|sum_ptr
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Calculate the sum of this CFDATA. 	 * Make sure CFDATA must be calculated in four bytes. 	 */
name|p
operator|=
name|cfdata
operator|->
name|sum_ptr
expr_stmt|;
name|sumbytes
operator|=
name|bytes
expr_stmt|;
if|if
condition|(
name|cfdata
operator|->
name|sum_extra_avail
condition|)
block|{
while|while
condition|(
name|cfdata
operator|->
name|sum_extra_avail
operator|<
literal|4
operator|&&
name|sumbytes
operator|>
literal|0
condition|)
block|{
name|cfdata
operator|->
name|sum_extra
index|[
name|cfdata
operator|->
name|sum_extra_avail
operator|++
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|sumbytes
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|cfdata
operator|->
name|sum_extra_avail
operator|==
literal|4
condition|)
block|{
name|cfdata
operator|->
name|sum_calculated
operator|=
name|cab_checksum_cfdata_4
argument_list|(
name|cfdata
operator|->
name|sum_extra
argument_list|,
literal|4
argument_list|,
name|cfdata
operator|->
name|sum_calculated
argument_list|)
expr_stmt|;
name|cfdata
operator|->
name|sum_extra_avail
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sumbytes
condition|)
block|{
name|int
name|odd
init|=
name|sumbytes
operator|&
literal|3
decl_stmt|;
if|if
condition|(
name|sumbytes
operator|-
name|odd
operator|>
literal|0
condition|)
name|cfdata
operator|->
name|sum_calculated
operator|=
name|cab_checksum_cfdata_4
argument_list|(
name|p
argument_list|,
name|sumbytes
operator|-
name|odd
argument_list|,
name|cfdata
operator|->
name|sum_calculated
argument_list|)
expr_stmt|;
if|if
condition|(
name|odd
condition|)
name|memcpy
argument_list|(
name|cfdata
operator|->
name|sum_extra
argument_list|,
name|p
operator|+
name|sumbytes
operator|-
name|odd
argument_list|,
name|odd
argument_list|)
expr_stmt|;
name|cfdata
operator|->
name|sum_extra_avail
operator|=
name|odd
expr_stmt|;
block|}
name|cfdata
operator|->
name|sum_ptr
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cab_checksum_finish
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|cab
modifier|*
name|cab
init|=
operator|(
expr|struct
name|cab
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
name|struct
name|cfdata
modifier|*
name|cfdata
init|=
name|cab
operator|->
name|entry_cfdata
decl_stmt|;
name|int
name|l
decl_stmt|;
comment|/* Do not need to compute a sum. */
if|if
condition|(
name|cfdata
operator|->
name|sum
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
comment|/* 	 * Calculate the sum of remaining CFDATA. 	 */
if|if
condition|(
name|cfdata
operator|->
name|sum_extra_avail
condition|)
block|{
name|cfdata
operator|->
name|sum_calculated
operator|=
name|cab_checksum_cfdata
argument_list|(
name|cfdata
operator|->
name|sum_extra
argument_list|,
name|cfdata
operator|->
name|sum_extra_avail
argument_list|,
name|cfdata
operator|->
name|sum_calculated
argument_list|)
expr_stmt|;
name|cfdata
operator|->
name|sum_extra_avail
operator|=
literal|0
expr_stmt|;
block|}
name|l
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|cab
operator|->
name|cfheader
operator|.
name|flags
operator|&
name|RESERVE_PRESENT
condition|)
name|l
operator|+=
name|cab
operator|->
name|cfheader
operator|.
name|cfdata
expr_stmt|;
name|cfdata
operator|->
name|sum_calculated
operator|=
name|cab_checksum_cfdata
argument_list|(
name|cfdata
operator|->
name|memimage
operator|+
name|CFDATA_cbData
argument_list|,
name|l
argument_list|,
name|cfdata
operator|->
name|sum_calculated
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfdata
operator|->
name|sum_calculated
operator|!=
name|cfdata
operator|->
name|sum
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Checksum error CFDATA[%d] %x:%x in %d bytes"
argument_list|,
name|cab
operator|->
name|entry_cffolder
operator|->
name|cfdata_index
operator|-
literal|1
argument_list|,
name|cfdata
operator|->
name|sum
argument_list|,
name|cfdata
operator|->
name|sum_calculated
argument_list|,
name|cfdata
operator|->
name|compressed_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read CFDATA if needed.  */
end_comment

begin_function
specifier|static
name|int
name|cab_next_cfdata
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|cab
modifier|*
name|cab
init|=
operator|(
expr|struct
name|cab
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
name|struct
name|cfdata
modifier|*
name|cfdata
init|=
name|cab
operator|->
name|entry_cfdata
decl_stmt|;
comment|/* There are remaining bytes in current CFDATA, use it first. */
if|if
condition|(
name|cfdata
operator|!=
name|NULL
operator|&&
name|cfdata
operator|->
name|uncompressed_bytes_remaining
operator|>
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
if|if
condition|(
name|cfdata
operator|==
name|NULL
condition|)
block|{
name|int64_t
name|skip
decl_stmt|;
name|cab
operator|->
name|entry_cffolder
operator|->
name|cfdata_index
operator|=
literal|0
expr_stmt|;
comment|/* Seek read pointer to the offset of CFDATA if needed. */
name|skip
operator|=
name|cab
operator|->
name|entry_cffolder
operator|->
name|cfdata_offset_in_cab
operator|-
name|cab
operator|->
name|cab_offset
expr_stmt|;
if|if
condition|(
name|skip
operator|<
literal|0
condition|)
block|{
name|int
name|folder_index
decl_stmt|;
switch|switch
condition|(
name|cab
operator|->
name|entry_cffile
operator|->
name|folder
condition|)
block|{
case|case
name|iFoldCONTINUED_FROM_PREV
case|:
case|case
name|iFoldCONTINUED_PREV_AND_NEXT
case|:
name|folder_index
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|iFoldCONTINUED_TO_NEXT
case|:
name|folder_index
operator|=
name|cab
operator|->
name|cfheader
operator|.
name|folder_count
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
name|folder_index
operator|=
name|cab
operator|->
name|entry_cffile
operator|->
name|folder
expr_stmt|;
break|break;
block|}
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Invalid offset of CFDATA in folder(%d) %jd< %jd"
argument_list|,
name|folder_index
argument_list|,
operator|(
name|intmax_t
operator|)
name|cab
operator|->
name|entry_cffolder
operator|->
name|cfdata_offset_in_cab
argument_list|,
operator|(
name|intmax_t
operator|)
name|cab
operator|->
name|cab_offset
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|skip
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|skip
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|cab
operator|->
name|cab_offset
operator|=
name|cab
operator|->
name|entry_cffolder
operator|->
name|cfdata_offset_in_cab
expr_stmt|;
block|}
block|}
comment|/* 	 * Read a CFDATA. 	 */
if|if
condition|(
name|cab
operator|->
name|entry_cffolder
operator|->
name|cfdata_index
operator|<
name|cab
operator|->
name|entry_cffolder
operator|->
name|cfdata_count
condition|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|l
decl_stmt|;
name|cfdata
operator|=
operator|&
operator|(
name|cab
operator|->
name|entry_cffolder
operator|->
name|cfdata
operator|)
expr_stmt|;
name|cab
operator|->
name|entry_cffolder
operator|->
name|cfdata_index
operator|++
expr_stmt|;
name|cab
operator|->
name|entry_cfdata
operator|=
name|cfdata
expr_stmt|;
name|cfdata
operator|->
name|sum_calculated
operator|=
literal|0
expr_stmt|;
name|cfdata
operator|->
name|sum_extra_avail
operator|=
literal|0
expr_stmt|;
name|cfdata
operator|->
name|sum_ptr
operator|=
name|NULL
expr_stmt|;
name|l
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|cab
operator|->
name|cfheader
operator|.
name|flags
operator|&
name|RESERVE_PRESENT
condition|)
name|l
operator|+=
name|cab
operator|->
name|cfheader
operator|.
name|cfdata
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|l
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|truncated_error
argument_list|(
name|a
argument_list|)
operator|)
return|;
name|cfdata
operator|->
name|sum
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|CFDATA_csum
argument_list|)
expr_stmt|;
name|cfdata
operator|->
name|compressed_size
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|CFDATA_cbData
argument_list|)
expr_stmt|;
name|cfdata
operator|->
name|compressed_bytes_remaining
operator|=
name|cfdata
operator|->
name|compressed_size
expr_stmt|;
name|cfdata
operator|->
name|uncompressed_size
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|CFDATA_cbUncomp
argument_list|)
expr_stmt|;
name|cfdata
operator|->
name|uncompressed_bytes_remaining
operator|=
name|cfdata
operator|->
name|uncompressed_size
expr_stmt|;
name|cfdata
operator|->
name|uncompressed_avail
operator|=
literal|0
expr_stmt|;
name|cfdata
operator|->
name|read_offset
operator|=
literal|0
expr_stmt|;
name|cfdata
operator|->
name|unconsumed
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Sanity check if data size is acceptable. 		 */
if|if
condition|(
name|cfdata
operator|->
name|compressed_size
operator|==
literal|0
operator|||
name|cfdata
operator|->
name|compressed_size
operator|>
operator|(
literal|0x8000
operator|+
literal|6144
operator|)
condition|)
goto|goto
name|invalid
goto|;
if|if
condition|(
name|cfdata
operator|->
name|uncompressed_size
operator|>
literal|0x8000
condition|)
goto|goto
name|invalid
goto|;
if|if
condition|(
name|cfdata
operator|->
name|uncompressed_size
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|cab
operator|->
name|entry_cffile
operator|->
name|folder
condition|)
block|{
case|case
name|iFoldCONTINUED_PREV_AND_NEXT
case|:
case|case
name|iFoldCONTINUED_TO_NEXT
case|:
break|break;
case|case
name|iFoldCONTINUED_FROM_PREV
case|:
default|default:
goto|goto
name|invalid
goto|;
block|}
block|}
comment|/* If CFDATA is not last in a folder, an uncompressed 		 * size must be 0x8000(32KBi) */
if|if
condition|(
operator|(
name|cab
operator|->
name|entry_cffolder
operator|->
name|cfdata_index
operator|<
name|cab
operator|->
name|entry_cffolder
operator|->
name|cfdata_count
operator|)
operator|&&
name|cfdata
operator|->
name|uncompressed_size
operator|!=
literal|0x8000
condition|)
goto|goto
name|invalid
goto|;
comment|/* A compressed data size and an uncompressed data size must 		 * be the same in no compression mode. */
if|if
condition|(
name|cab
operator|->
name|entry_cffolder
operator|->
name|comptype
operator|==
name|COMPTYPE_NONE
operator|&&
name|cfdata
operator|->
name|compressed_size
operator|!=
name|cfdata
operator|->
name|uncompressed_size
condition|)
goto|goto
name|invalid
goto|;
comment|/* 		 * Save CFDATA image for sum check. 		 */
if|if
condition|(
name|cfdata
operator|->
name|memimage_size
operator|<
operator|(
name|size_t
operator|)
name|l
condition|)
block|{
name|free
argument_list|(
name|cfdata
operator|->
name|memimage
argument_list|)
expr_stmt|;
name|cfdata
operator|->
name|memimage
operator|=
name|malloc
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfdata
operator|->
name|memimage
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for CAB data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|cfdata
operator|->
name|memimage_size
operator|=
name|l
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|cfdata
operator|->
name|memimage
argument_list|,
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
comment|/* Consume bytes as much as we used. */
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|cab
operator|->
name|cab_offset
operator|+=
name|l
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cab
operator|->
name|entry_cffolder
operator|->
name|cfdata_count
operator|>
literal|0
condition|)
block|{
comment|/* Run out of all CFDATA in a folder. */
name|cfdata
operator|->
name|compressed_size
operator|=
literal|0
expr_stmt|;
name|cfdata
operator|->
name|uncompressed_size
operator|=
literal|0
expr_stmt|;
name|cfdata
operator|->
name|compressed_bytes_remaining
operator|=
literal|0
expr_stmt|;
name|cfdata
operator|->
name|uncompressed_bytes_remaining
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Current folder does not have any CFDATA. */
name|cfdata
operator|=
operator|&
operator|(
name|cab
operator|->
name|entry_cffolder
operator|->
name|cfdata
operator|)
expr_stmt|;
name|cab
operator|->
name|entry_cfdata
operator|=
name|cfdata
expr_stmt|;
name|memset
argument_list|(
name|cfdata
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cfdata
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
name|invalid
label|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid CFDATA"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read ahead CFDATA.  */
end_comment

begin_function
specifier|static
specifier|const
name|void
modifier|*
name|cab_read_ahead_cfdata
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|ssize_t
modifier|*
name|avail
parameter_list|)
block|{
name|struct
name|cab
modifier|*
name|cab
init|=
operator|(
expr|struct
name|cab
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|cab_next_cfdata
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
name|ARCHIVE_OK
condition|)
block|{
operator|*
name|avail
operator|=
name|err
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
switch|switch
condition|(
name|cab
operator|->
name|entry_cffolder
operator|->
name|comptype
condition|)
block|{
case|case
name|COMPTYPE_NONE
case|:
return|return
operator|(
name|cab_read_ahead_cfdata_none
argument_list|(
name|a
argument_list|,
name|avail
argument_list|)
operator|)
return|;
case|case
name|COMPTYPE_MSZIP
case|:
return|return
operator|(
name|cab_read_ahead_cfdata_deflate
argument_list|(
name|a
argument_list|,
name|avail
argument_list|)
operator|)
return|;
case|case
name|COMPTYPE_LZX
case|:
return|return
operator|(
name|cab_read_ahead_cfdata_lzx
argument_list|(
name|a
argument_list|,
name|avail
argument_list|)
operator|)
return|;
default|default:
comment|/* Unsupported compression. */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Unsupported CAB compression : %s"
argument_list|,
name|cab
operator|->
name|entry_cffolder
operator|->
name|compname
argument_list|)
expr_stmt|;
operator|*
name|avail
operator|=
name|ARCHIVE_FAILED
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Read ahead CFDATA as uncompressed data.  */
end_comment

begin_function
specifier|static
specifier|const
name|void
modifier|*
name|cab_read_ahead_cfdata_none
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|ssize_t
modifier|*
name|avail
parameter_list|)
block|{
name|struct
name|cab
modifier|*
name|cab
init|=
operator|(
expr|struct
name|cab
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
name|struct
name|cfdata
modifier|*
name|cfdata
decl_stmt|;
specifier|const
name|void
modifier|*
name|d
decl_stmt|;
name|cfdata
operator|=
name|cab
operator|->
name|entry_cfdata
expr_stmt|;
comment|/* 	 * Note: '1' here is a performance optimization. 	 * Recall that the decompression layer returns a count of 	 * available bytes; asking for more than that forces the 	 * decompressor to combine reads by copying data. 	 */
name|d
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
name|avail
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|avail
operator|<=
literal|0
condition|)
block|{
operator|*
name|avail
operator|=
name|truncated_error
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|avail
operator|>
name|cfdata
operator|->
name|uncompressed_bytes_remaining
condition|)
operator|*
name|avail
operator|=
name|cfdata
operator|->
name|uncompressed_bytes_remaining
expr_stmt|;
name|cfdata
operator|->
name|uncompressed_avail
operator|=
name|cfdata
operator|->
name|uncompressed_size
expr_stmt|;
name|cfdata
operator|->
name|unconsumed
operator|=
operator|*
name|avail
expr_stmt|;
name|cfdata
operator|->
name|sum_ptr
operator|=
name|d
expr_stmt|;
return|return
operator|(
name|d
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read ahead CFDATA as deflate data.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
end_ifdef

begin_function
specifier|static
specifier|const
name|void
modifier|*
name|cab_read_ahead_cfdata_deflate
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|ssize_t
modifier|*
name|avail
parameter_list|)
block|{
name|struct
name|cab
modifier|*
name|cab
init|=
operator|(
expr|struct
name|cab
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
name|struct
name|cfdata
modifier|*
name|cfdata
decl_stmt|;
specifier|const
name|void
modifier|*
name|d
decl_stmt|;
name|int
name|r
decl_stmt|,
name|mszip
decl_stmt|;
name|uint16_t
name|uavail
decl_stmt|;
name|char
name|eod
init|=
literal|0
decl_stmt|;
name|cfdata
operator|=
name|cab
operator|->
name|entry_cfdata
expr_stmt|;
comment|/* If the buffer hasn't been allocated, allocate it now. */
if|if
condition|(
name|cab
operator|->
name|uncompressed_buffer
operator|==
name|NULL
condition|)
block|{
name|cab
operator|->
name|uncompressed_buffer_size
operator|=
literal|0x8000
expr_stmt|;
name|cab
operator|->
name|uncompressed_buffer
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|cab
operator|->
name|uncompressed_buffer_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|cab
operator|->
name|uncompressed_buffer
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"No memory for CAB reader"
argument_list|)
expr_stmt|;
operator|*
name|avail
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|uavail
operator|=
name|cfdata
operator|->
name|uncompressed_avail
expr_stmt|;
if|if
condition|(
name|uavail
operator|==
name|cfdata
operator|->
name|uncompressed_size
condition|)
block|{
name|d
operator|=
name|cab
operator|->
name|uncompressed_buffer
operator|+
name|cfdata
operator|->
name|read_offset
expr_stmt|;
operator|*
name|avail
operator|=
name|uavail
operator|-
name|cfdata
operator|->
name|read_offset
expr_stmt|;
return|return
operator|(
name|d
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|cab
operator|->
name|entry_cffolder
operator|->
name|decompress_init
condition|)
block|{
name|cab
operator|->
name|stream
operator|.
name|next_in
operator|=
name|NULL
expr_stmt|;
name|cab
operator|->
name|stream
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|cab
operator|->
name|stream
operator|.
name|total_in
operator|=
literal|0
expr_stmt|;
name|cab
operator|->
name|stream
operator|.
name|next_out
operator|=
name|NULL
expr_stmt|;
name|cab
operator|->
name|stream
operator|.
name|avail_out
operator|=
literal|0
expr_stmt|;
name|cab
operator|->
name|stream
operator|.
name|total_out
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cab
operator|->
name|stream_valid
condition|)
name|r
operator|=
name|inflateReset
argument_list|(
operator|&
name|cab
operator|->
name|stream
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|inflateInit2
argument_list|(
operator|&
name|cab
operator|->
name|stream
argument_list|,
operator|-
literal|15
comment|/* Don't check for zlib header */
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|Z_OK
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Can't initialize deflate decompression."
argument_list|)
expr_stmt|;
operator|*
name|avail
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Stream structure has been set up. */
name|cab
operator|->
name|stream_valid
operator|=
literal|1
expr_stmt|;
comment|/* We've initialized decompression for this stream. */
name|cab
operator|->
name|entry_cffolder
operator|->
name|decompress_init
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cfdata
operator|->
name|compressed_bytes_remaining
operator|==
name|cfdata
operator|->
name|compressed_size
condition|)
name|mszip
operator|=
literal|2
expr_stmt|;
else|else
name|mszip
operator|=
literal|0
expr_stmt|;
name|eod
operator|=
literal|0
expr_stmt|;
name|cab
operator|->
name|stream
operator|.
name|total_out
operator|=
name|uavail
expr_stmt|;
comment|/* 	 * We always uncompress all data in current CFDATA. 	 */
while|while
condition|(
operator|!
name|eod
operator|&&
name|cab
operator|->
name|stream
operator|.
name|total_out
operator|<
name|cfdata
operator|->
name|uncompressed_size
condition|)
block|{
name|ssize_t
name|bytes_avail
decl_stmt|;
name|cab
operator|->
name|stream
operator|.
name|next_out
operator|=
name|cab
operator|->
name|uncompressed_buffer
operator|+
name|cab
operator|->
name|stream
operator|.
name|total_out
expr_stmt|;
name|cab
operator|->
name|stream
operator|.
name|avail_out
operator|=
name|cfdata
operator|->
name|uncompressed_size
operator|-
name|cab
operator|->
name|stream
operator|.
name|total_out
expr_stmt|;
name|d
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
operator|&
name|bytes_avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_avail
operator|<=
literal|0
condition|)
block|{
operator|*
name|avail
operator|=
name|truncated_error
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|bytes_avail
operator|>
name|cfdata
operator|->
name|compressed_bytes_remaining
condition|)
name|bytes_avail
operator|=
name|cfdata
operator|->
name|compressed_bytes_remaining
expr_stmt|;
comment|/* 		 * A bug in zlib.h: stream.next_in should be marked 'const' 		 * but isn't (the library never alters data through the 		 * next_in pointer, only reads it).  The result: this ugly 		 * cast to remove 'const'. 		 */
name|cab
operator|->
name|stream
operator|.
name|next_in
operator|=
operator|(
name|Bytef
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|d
expr_stmt|;
name|cab
operator|->
name|stream
operator|.
name|avail_in
operator|=
operator|(
name|uInt
operator|)
name|bytes_avail
expr_stmt|;
name|cab
operator|->
name|stream
operator|.
name|total_in
operator|=
literal|0
expr_stmt|;
comment|/* Cut out a tow-byte MSZIP signature(0x43, 0x4b). */
if|if
condition|(
name|mszip
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|bytes_avail
operator|<=
name|mszip
condition|)
block|{
if|if
condition|(
name|mszip
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|cab
operator|->
name|stream
operator|.
name|next_in
index|[
literal|0
index|]
operator|!=
literal|0x43
condition|)
goto|goto
name|nomszip
goto|;
if|if
condition|(
name|bytes_avail
operator|>
literal|1
operator|&&
name|cab
operator|->
name|stream
operator|.
name|next_in
index|[
literal|1
index|]
operator|!=
literal|0x4b
condition|)
goto|goto
name|nomszip
goto|;
block|}
elseif|else
if|if
condition|(
name|cab
operator|->
name|stream
operator|.
name|next_in
index|[
literal|0
index|]
operator|!=
literal|0x4b
condition|)
goto|goto
name|nomszip
goto|;
name|cfdata
operator|->
name|unconsumed
operator|=
name|bytes_avail
expr_stmt|;
name|cfdata
operator|->
name|sum_ptr
operator|=
name|d
expr_stmt|;
if|if
condition|(
name|cab_minimum_consume_cfdata
argument_list|(
name|a
argument_list|,
name|cfdata
operator|->
name|unconsumed
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|avail
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|mszip
operator|-=
operator|(
name|int
operator|)
name|bytes_avail
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|mszip
operator|==
literal|1
operator|&&
name|cab
operator|->
name|stream
operator|.
name|next_in
index|[
literal|0
index|]
operator|!=
literal|0x4b
condition|)
goto|goto
name|nomszip
goto|;
elseif|else
if|if
condition|(
name|cab
operator|->
name|stream
operator|.
name|next_in
index|[
literal|0
index|]
operator|!=
literal|0x43
operator|||
name|cab
operator|->
name|stream
operator|.
name|next_in
index|[
literal|1
index|]
operator|!=
literal|0x4b
condition|)
goto|goto
name|nomszip
goto|;
name|cab
operator|->
name|stream
operator|.
name|next_in
operator|+=
name|mszip
expr_stmt|;
name|cab
operator|->
name|stream
operator|.
name|avail_in
operator|-=
name|mszip
expr_stmt|;
name|cab
operator|->
name|stream
operator|.
name|total_in
operator|+=
name|mszip
expr_stmt|;
name|mszip
operator|=
literal|0
expr_stmt|;
block|}
name|r
operator|=
name|inflate
argument_list|(
operator|&
name|cab
operator|->
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|Z_OK
case|:
break|break;
case|case
name|Z_STREAM_END
case|:
name|eod
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
goto|goto
name|zlibfailed
goto|;
block|}
name|cfdata
operator|->
name|unconsumed
operator|=
name|cab
operator|->
name|stream
operator|.
name|total_in
expr_stmt|;
name|cfdata
operator|->
name|sum_ptr
operator|=
name|d
expr_stmt|;
if|if
condition|(
name|cab_minimum_consume_cfdata
argument_list|(
name|a
argument_list|,
name|cfdata
operator|->
name|unconsumed
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|avail
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|uavail
operator|=
operator|(
name|uint16_t
operator|)
name|cab
operator|->
name|stream
operator|.
name|total_out
expr_stmt|;
if|if
condition|(
name|uavail
operator|<
name|cfdata
operator|->
name|uncompressed_size
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Invalid uncompressed size (%d< %d)"
argument_list|,
name|uavail
argument_list|,
name|cfdata
operator|->
name|uncompressed_size
argument_list|)
expr_stmt|;
operator|*
name|avail
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Note: I suspect there is a bug in makecab.exe because, in rare 	 * case, compressed bytes are still remaining regardless we have 	 * gotten all uncompressed bytes, which size is recoded in CFDATA, 	 * as much as we need, and we have to use the garbage so as to 	 * correctly compute the sum of CFDATA accordingly. 	 */
if|if
condition|(
name|cfdata
operator|->
name|compressed_bytes_remaining
operator|>
literal|0
condition|)
block|{
name|ssize_t
name|bytes_avail
decl_stmt|;
name|d
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|cfdata
operator|->
name|compressed_bytes_remaining
argument_list|,
operator|&
name|bytes_avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_avail
operator|<=
literal|0
condition|)
block|{
operator|*
name|avail
operator|=
name|truncated_error
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|cfdata
operator|->
name|unconsumed
operator|=
name|cfdata
operator|->
name|compressed_bytes_remaining
expr_stmt|;
name|cfdata
operator|->
name|sum_ptr
operator|=
name|d
expr_stmt|;
if|if
condition|(
name|cab_minimum_consume_cfdata
argument_list|(
name|a
argument_list|,
name|cfdata
operator|->
name|unconsumed
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|avail
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* 	 * Set dictionary data for decompressing of next CFDATA, which 	 * in the same folder. This is why we always do decompress CFDATA 	 * even if beginning CFDATA or some of CFDATA are not used in 	 * skipping file data. 	 */
if|if
condition|(
name|cab
operator|->
name|entry_cffolder
operator|->
name|cfdata_index
operator|<
name|cab
operator|->
name|entry_cffolder
operator|->
name|cfdata_count
condition|)
block|{
name|r
operator|=
name|inflateReset
argument_list|(
operator|&
name|cab
operator|->
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|Z_OK
condition|)
goto|goto
name|zlibfailed
goto|;
name|r
operator|=
name|inflateSetDictionary
argument_list|(
operator|&
name|cab
operator|->
name|stream
argument_list|,
name|cab
operator|->
name|uncompressed_buffer
argument_list|,
name|cfdata
operator|->
name|uncompressed_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|Z_OK
condition|)
goto|goto
name|zlibfailed
goto|;
block|}
name|d
operator|=
name|cab
operator|->
name|uncompressed_buffer
operator|+
name|cfdata
operator|->
name|read_offset
expr_stmt|;
operator|*
name|avail
operator|=
name|uavail
operator|-
name|cfdata
operator|->
name|read_offset
expr_stmt|;
name|cfdata
operator|->
name|uncompressed_avail
operator|=
name|uavail
expr_stmt|;
return|return
operator|(
name|d
operator|)
return|;
name|zlibfailed
label|:
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|Z_MEM_ERROR
case|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Out of memory for deflate decompression"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Deflate decompression failed (%d)"
argument_list|,
name|r
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|avail
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
name|nomszip
label|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"CFDATA incorrect(no MSZIP signature)"
argument_list|)
expr_stmt|;
operator|*
name|avail
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* HAVE_ZLIB_H */
end_comment

begin_function
specifier|static
specifier|const
name|void
modifier|*
name|cab_read_ahead_cfdata_deflate
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|ssize_t
modifier|*
name|avail
parameter_list|)
block|{
operator|*
name|avail
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"libarchive compiled without deflate support (no libz)"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_ZLIB_H */
end_comment

begin_function
specifier|static
specifier|const
name|void
modifier|*
name|cab_read_ahead_cfdata_lzx
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|ssize_t
modifier|*
name|avail
parameter_list|)
block|{
name|struct
name|cab
modifier|*
name|cab
init|=
operator|(
expr|struct
name|cab
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
name|struct
name|cfdata
modifier|*
name|cfdata
decl_stmt|;
specifier|const
name|void
modifier|*
name|d
decl_stmt|;
name|int
name|r
decl_stmt|;
name|uint16_t
name|uavail
decl_stmt|;
name|cfdata
operator|=
name|cab
operator|->
name|entry_cfdata
expr_stmt|;
comment|/* If the buffer hasn't been allocated, allocate it now. */
if|if
condition|(
name|cab
operator|->
name|uncompressed_buffer
operator|==
name|NULL
condition|)
block|{
name|cab
operator|->
name|uncompressed_buffer_size
operator|=
literal|0x8000
expr_stmt|;
name|cab
operator|->
name|uncompressed_buffer
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|cab
operator|->
name|uncompressed_buffer_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|cab
operator|->
name|uncompressed_buffer
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"No memory for CAB reader"
argument_list|)
expr_stmt|;
operator|*
name|avail
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|uavail
operator|=
name|cfdata
operator|->
name|uncompressed_avail
expr_stmt|;
if|if
condition|(
name|uavail
operator|==
name|cfdata
operator|->
name|uncompressed_size
condition|)
block|{
name|d
operator|=
name|cab
operator|->
name|uncompressed_buffer
operator|+
name|cfdata
operator|->
name|read_offset
expr_stmt|;
operator|*
name|avail
operator|=
name|uavail
operator|-
name|cfdata
operator|->
name|read_offset
expr_stmt|;
return|return
operator|(
name|d
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|cab
operator|->
name|entry_cffolder
operator|->
name|decompress_init
condition|)
block|{
name|r
operator|=
name|lzx_decode_init
argument_list|(
operator|&
name|cab
operator|->
name|xstrm
argument_list|,
name|cab
operator|->
name|entry_cffolder
operator|->
name|compdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Can't initialize LZX decompression."
argument_list|)
expr_stmt|;
operator|*
name|avail
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* We've initialized decompression for this stream. */
name|cab
operator|->
name|entry_cffolder
operator|->
name|decompress_init
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Clean up remaining bits of previous CFDATA. */
name|lzx_cleanup_bitstream
argument_list|(
operator|&
name|cab
operator|->
name|xstrm
argument_list|)
expr_stmt|;
name|cab
operator|->
name|xstrm
operator|.
name|total_out
operator|=
name|uavail
expr_stmt|;
while|while
condition|(
name|cab
operator|->
name|xstrm
operator|.
name|total_out
operator|<
name|cfdata
operator|->
name|uncompressed_size
condition|)
block|{
name|ssize_t
name|bytes_avail
decl_stmt|;
name|cab
operator|->
name|xstrm
operator|.
name|next_out
operator|=
name|cab
operator|->
name|uncompressed_buffer
operator|+
name|cab
operator|->
name|xstrm
operator|.
name|total_out
expr_stmt|;
name|cab
operator|->
name|xstrm
operator|.
name|avail_out
operator|=
name|cfdata
operator|->
name|uncompressed_size
operator|-
name|cab
operator|->
name|xstrm
operator|.
name|total_out
expr_stmt|;
name|d
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
operator|&
name|bytes_avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_avail
operator|<=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated CAB file data"
argument_list|)
expr_stmt|;
operator|*
name|avail
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|bytes_avail
operator|>
name|cfdata
operator|->
name|compressed_bytes_remaining
condition|)
name|bytes_avail
operator|=
name|cfdata
operator|->
name|compressed_bytes_remaining
expr_stmt|;
name|cab
operator|->
name|xstrm
operator|.
name|next_in
operator|=
name|d
expr_stmt|;
name|cab
operator|->
name|xstrm
operator|.
name|avail_in
operator|=
name|bytes_avail
expr_stmt|;
name|cab
operator|->
name|xstrm
operator|.
name|total_in
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|lzx_decode
argument_list|(
operator|&
name|cab
operator|->
name|xstrm
argument_list|,
name|cfdata
operator|->
name|compressed_bytes_remaining
operator|==
name|bytes_avail
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|ARCHIVE_OK
case|:
case|case
name|ARCHIVE_EOF
case|:
break|break;
default|default:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"LZX decompression failed (%d)"
argument_list|,
name|r
argument_list|)
expr_stmt|;
operator|*
name|avail
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|cfdata
operator|->
name|unconsumed
operator|=
name|cab
operator|->
name|xstrm
operator|.
name|total_in
expr_stmt|;
name|cfdata
operator|->
name|sum_ptr
operator|=
name|d
expr_stmt|;
if|if
condition|(
name|cab_minimum_consume_cfdata
argument_list|(
name|a
argument_list|,
name|cfdata
operator|->
name|unconsumed
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|avail
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|uavail
operator|=
operator|(
name|uint16_t
operator|)
name|cab
operator|->
name|xstrm
operator|.
name|total_out
expr_stmt|;
comment|/* 	 * Make sure a read pointer advances to next CFDATA. 	 */
if|if
condition|(
name|cfdata
operator|->
name|compressed_bytes_remaining
operator|>
literal|0
condition|)
block|{
name|ssize_t
name|bytes_avail
decl_stmt|;
name|d
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|cfdata
operator|->
name|compressed_bytes_remaining
argument_list|,
operator|&
name|bytes_avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_avail
operator|<=
literal|0
condition|)
block|{
operator|*
name|avail
operator|=
name|truncated_error
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|cfdata
operator|->
name|unconsumed
operator|=
name|cfdata
operator|->
name|compressed_bytes_remaining
expr_stmt|;
name|cfdata
operator|->
name|sum_ptr
operator|=
name|d
expr_stmt|;
if|if
condition|(
name|cab_minimum_consume_cfdata
argument_list|(
name|a
argument_list|,
name|cfdata
operator|->
name|unconsumed
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|avail
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* 	 * Translation reversal of x86 proccessor CALL byte sequence(E8). 	 */
name|lzx_translation
argument_list|(
operator|&
name|cab
operator|->
name|xstrm
argument_list|,
name|cab
operator|->
name|uncompressed_buffer
argument_list|,
name|cfdata
operator|->
name|uncompressed_size
argument_list|,
operator|(
name|cab
operator|->
name|entry_cffolder
operator|->
name|cfdata_index
operator|-
literal|1
operator|)
operator|*
literal|0x8000
argument_list|)
expr_stmt|;
name|d
operator|=
name|cab
operator|->
name|uncompressed_buffer
operator|+
name|cfdata
operator|->
name|read_offset
expr_stmt|;
operator|*
name|avail
operator|=
name|uavail
operator|-
name|cfdata
operator|->
name|read_offset
expr_stmt|;
name|cfdata
operator|->
name|uncompressed_avail
operator|=
name|uavail
expr_stmt|;
return|return
operator|(
name|d
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Consume CFDATA.  * We always decompress CFDATA to consume CFDATA as much as we need  * in uncompressed bytes because all CFDATA in a folder are related  * so we do not skip any CFDATA without decompressing.  * Note: If the folder of a CFFILE is iFoldCONTINUED_PREV_AND_NEXT or  * iFoldCONTINUED_FROM_PREV, we won't decompress because a CFDATA for  * the CFFILE is remaining bytes of previous Multivolume CAB file.  */
end_comment

begin_function
specifier|static
name|int64_t
name|cab_consume_cfdata
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|int64_t
name|consumed_bytes
parameter_list|)
block|{
name|struct
name|cab
modifier|*
name|cab
init|=
operator|(
expr|struct
name|cab
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
name|struct
name|cfdata
modifier|*
name|cfdata
decl_stmt|;
name|int64_t
name|cbytes
decl_stmt|,
name|rbytes
decl_stmt|;
name|int
name|err
decl_stmt|;
name|rbytes
operator|=
name|cab_minimum_consume_cfdata
argument_list|(
name|a
argument_list|,
name|consumed_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbytes
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|cfdata
operator|=
name|cab
operator|->
name|entry_cfdata
expr_stmt|;
while|while
condition|(
name|rbytes
operator|>
literal|0
condition|)
block|{
name|ssize_t
name|avail
decl_stmt|;
if|if
condition|(
name|cfdata
operator|->
name|compressed_size
operator|==
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid CFDATA"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|cbytes
operator|=
name|cfdata
operator|->
name|uncompressed_bytes_remaining
expr_stmt|;
if|if
condition|(
name|cbytes
operator|>
name|rbytes
condition|)
name|cbytes
operator|=
name|rbytes
expr_stmt|;
name|rbytes
operator|-=
name|cbytes
expr_stmt|;
if|if
condition|(
name|cfdata
operator|->
name|uncompressed_avail
operator|==
literal|0
operator|&&
operator|(
name|cab
operator|->
name|entry_cffile
operator|->
name|folder
operator|==
name|iFoldCONTINUED_PREV_AND_NEXT
operator|||
name|cab
operator|->
name|entry_cffile
operator|->
name|folder
operator|==
name|iFoldCONTINUED_FROM_PREV
operator|)
condition|)
block|{
comment|/* We have not read any data yet. */
if|if
condition|(
name|cbytes
operator|==
name|cfdata
operator|->
name|uncompressed_bytes_remaining
condition|)
block|{
comment|/* Skip whole current CFDATA. */
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|cfdata
operator|->
name|compressed_size
argument_list|)
expr_stmt|;
name|cab
operator|->
name|cab_offset
operator|+=
name|cfdata
operator|->
name|compressed_size
expr_stmt|;
name|cfdata
operator|->
name|compressed_bytes_remaining
operator|=
literal|0
expr_stmt|;
name|cfdata
operator|->
name|uncompressed_bytes_remaining
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|cab_next_cfdata
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|cfdata
operator|=
name|cab
operator|->
name|entry_cfdata
expr_stmt|;
if|if
condition|(
name|cfdata
operator|->
name|uncompressed_size
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|cab
operator|->
name|entry_cffile
operator|->
name|folder
condition|)
block|{
case|case
name|iFoldCONTINUED_PREV_AND_NEXT
case|:
case|case
name|iFoldCONTINUED_TO_NEXT
case|:
case|case
name|iFoldCONTINUED_FROM_PREV
case|:
name|rbytes
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
continue|continue;
block|}
name|cfdata
operator|->
name|read_offset
operator|+=
operator|(
name|uint16_t
operator|)
name|cbytes
expr_stmt|;
name|cfdata
operator|->
name|uncompressed_bytes_remaining
operator|-=
operator|(
name|uint16_t
operator|)
name|cbytes
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|cbytes
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|cab_next_cfdata
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|cfdata
operator|=
name|cab
operator|->
name|entry_cfdata
expr_stmt|;
if|if
condition|(
name|cfdata
operator|->
name|uncompressed_size
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|cab
operator|->
name|entry_cffile
operator|->
name|folder
condition|)
block|{
case|case
name|iFoldCONTINUED_PREV_AND_NEXT
case|:
case|case
name|iFoldCONTINUED_TO_NEXT
case|:
case|case
name|iFoldCONTINUED_FROM_PREV
case|:
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
default|default:
break|break;
block|}
block|}
continue|continue;
block|}
while|while
condition|(
name|cbytes
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|cab_read_ahead_cfdata
argument_list|(
name|a
argument_list|,
operator|&
name|avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|avail
operator|<=
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
if|if
condition|(
name|avail
operator|>
name|cbytes
condition|)
name|avail
operator|=
operator|(
name|ssize_t
operator|)
name|cbytes
expr_stmt|;
if|if
condition|(
name|cab_minimum_consume_cfdata
argument_list|(
name|a
argument_list|,
name|avail
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|cbytes
operator|-=
name|avail
expr_stmt|;
block|}
block|}
return|return
operator|(
name|consumed_bytes
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Consume CFDATA as much as we have already gotten and  * compute the sum of CFDATA.  */
end_comment

begin_function
specifier|static
name|int64_t
name|cab_minimum_consume_cfdata
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|int64_t
name|consumed_bytes
parameter_list|)
block|{
name|struct
name|cab
modifier|*
name|cab
init|=
operator|(
expr|struct
name|cab
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
name|struct
name|cfdata
modifier|*
name|cfdata
decl_stmt|;
name|int64_t
name|cbytes
decl_stmt|,
name|rbytes
decl_stmt|;
name|int
name|err
decl_stmt|;
name|cfdata
operator|=
name|cab
operator|->
name|entry_cfdata
expr_stmt|;
name|rbytes
operator|=
name|consumed_bytes
expr_stmt|;
if|if
condition|(
name|cab
operator|->
name|entry_cffolder
operator|->
name|comptype
operator|==
name|COMPTYPE_NONE
condition|)
block|{
if|if
condition|(
name|consumed_bytes
operator|<
name|cfdata
operator|->
name|unconsumed
condition|)
name|cbytes
operator|=
name|consumed_bytes
expr_stmt|;
else|else
name|cbytes
operator|=
name|cfdata
operator|->
name|unconsumed
expr_stmt|;
name|rbytes
operator|-=
name|cbytes
expr_stmt|;
name|cfdata
operator|->
name|read_offset
operator|+=
operator|(
name|uint16_t
operator|)
name|cbytes
expr_stmt|;
name|cfdata
operator|->
name|uncompressed_bytes_remaining
operator|-=
operator|(
name|uint16_t
operator|)
name|cbytes
expr_stmt|;
name|cfdata
operator|->
name|unconsumed
operator|-=
name|cbytes
expr_stmt|;
block|}
else|else
block|{
name|cbytes
operator|=
name|cfdata
operator|->
name|uncompressed_avail
operator|-
name|cfdata
operator|->
name|read_offset
expr_stmt|;
if|if
condition|(
name|cbytes
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|consumed_bytes
operator|<
name|cbytes
condition|)
name|cbytes
operator|=
name|consumed_bytes
expr_stmt|;
name|rbytes
operator|-=
name|cbytes
expr_stmt|;
name|cfdata
operator|->
name|read_offset
operator|+=
operator|(
name|uint16_t
operator|)
name|cbytes
expr_stmt|;
name|cfdata
operator|->
name|uncompressed_bytes_remaining
operator|-=
operator|(
name|uint16_t
operator|)
name|cbytes
expr_stmt|;
block|}
if|if
condition|(
name|cfdata
operator|->
name|unconsumed
condition|)
block|{
name|cbytes
operator|=
name|cfdata
operator|->
name|unconsumed
expr_stmt|;
name|cfdata
operator|->
name|unconsumed
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|cbytes
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cbytes
condition|)
block|{
comment|/* Compute the sum. */
name|cab_checksum_update
argument_list|(
name|a
argument_list|,
operator|(
name|size_t
operator|)
name|cbytes
argument_list|)
expr_stmt|;
comment|/* Consume as much as the compressor actually used. */
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|cbytes
argument_list|)
expr_stmt|;
name|cab
operator|->
name|cab_offset
operator|+=
name|cbytes
expr_stmt|;
name|cfdata
operator|->
name|compressed_bytes_remaining
operator|-=
operator|(
name|uint16_t
operator|)
name|cbytes
expr_stmt|;
if|if
condition|(
name|cfdata
operator|->
name|compressed_bytes_remaining
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|cab_checksum_finish
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
return|return
operator|(
name|rbytes
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns ARCHIVE_OK if successful, ARCHIVE_FATAL otherwise, sets  * cab->end_of_entry if it consumes all of the data.  */
end_comment

begin_function
specifier|static
name|int
name|cab_read_data
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|int64_t
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|cab
modifier|*
name|cab
init|=
operator|(
expr|struct
name|cab
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
name|ssize_t
name|bytes_avail
decl_stmt|;
if|if
condition|(
name|cab
operator|->
name|entry_bytes_remaining
operator|==
literal|0
condition|)
block|{
operator|*
name|buff
operator|=
name|NULL
expr_stmt|;
operator|*
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|offset
operator|=
name|cab
operator|->
name|entry_offset
expr_stmt|;
name|cab
operator|->
name|end_of_entry
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
operator|*
name|buff
operator|=
name|cab_read_ahead_cfdata
argument_list|(
name|a
argument_list|,
operator|&
name|bytes_avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_avail
operator|<=
literal|0
condition|)
block|{
operator|*
name|buff
operator|=
name|NULL
expr_stmt|;
operator|*
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bytes_avail
operator|==
literal|0
operator|&&
name|cab
operator|->
name|entry_cfdata
operator|->
name|uncompressed_size
operator|==
literal|0
condition|)
block|{
comment|/* All of CFDATA in a folder has been handled. */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid CFDATA"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
else|else
return|return
operator|(
operator|(
name|int
operator|)
name|bytes_avail
operator|)
return|;
block|}
if|if
condition|(
name|bytes_avail
operator|>
name|cab
operator|->
name|entry_bytes_remaining
condition|)
name|bytes_avail
operator|=
operator|(
name|ssize_t
operator|)
name|cab
operator|->
name|entry_bytes_remaining
expr_stmt|;
operator|*
name|size
operator|=
name|bytes_avail
expr_stmt|;
operator|*
name|offset
operator|=
name|cab
operator|->
name|entry_offset
expr_stmt|;
name|cab
operator|->
name|entry_offset
operator|+=
name|bytes_avail
expr_stmt|;
name|cab
operator|->
name|entry_bytes_remaining
operator|-=
name|bytes_avail
expr_stmt|;
if|if
condition|(
name|cab
operator|->
name|entry_bytes_remaining
operator|==
literal|0
condition|)
name|cab
operator|->
name|end_of_entry
operator|=
literal|1
expr_stmt|;
name|cab
operator|->
name|entry_unconsumed
operator|=
name|bytes_avail
expr_stmt|;
if|if
condition|(
name|cab
operator|->
name|entry_cffolder
operator|->
name|comptype
operator|==
name|COMPTYPE_NONE
condition|)
block|{
comment|/* Don't consume more than current entry used. */
if|if
condition|(
name|cab
operator|->
name|entry_cfdata
operator|->
name|unconsumed
operator|>
name|cab
operator|->
name|entry_unconsumed
condition|)
name|cab
operator|->
name|entry_cfdata
operator|->
name|unconsumed
operator|=
name|cab
operator|->
name|entry_unconsumed
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_cab_read_data_skip
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|cab
modifier|*
name|cab
decl_stmt|;
name|int64_t
name|bytes_skipped
decl_stmt|;
name|int
name|r
decl_stmt|;
name|cab
operator|=
operator|(
expr|struct
name|cab
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|cab
operator|->
name|end_of_archive
condition|)
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
if|if
condition|(
operator|!
name|cab
operator|->
name|read_data_invoked
condition|)
block|{
name|cab
operator|->
name|bytes_skipped
operator|+=
name|cab
operator|->
name|entry_bytes_remaining
expr_stmt|;
name|cab
operator|->
name|entry_bytes_remaining
operator|=
literal|0
expr_stmt|;
comment|/* This entry is finished and done. */
name|cab
operator|->
name|end_of_entry_cleanup
operator|=
name|cab
operator|->
name|end_of_entry
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
if|if
condition|(
name|cab
operator|->
name|entry_unconsumed
condition|)
block|{
comment|/* Consume as much as the compressor actually used. */
name|r
operator|=
operator|(
name|int
operator|)
name|cab_consume_cfdata
argument_list|(
name|a
argument_list|,
name|cab
operator|->
name|entry_unconsumed
argument_list|)
expr_stmt|;
name|cab
operator|->
name|entry_unconsumed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|cab
operator|->
name|entry_cfdata
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|cab_next_cfdata
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
comment|/* if we've already read to end of data, we're done. */
if|if
condition|(
name|cab
operator|->
name|end_of_entry_cleanup
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
comment|/* 	 * If the length is at the beginning, we can skip the 	 * compressed data much more quickly. 	 */
name|bytes_skipped
operator|=
name|cab_consume_cfdata
argument_list|(
name|a
argument_list|,
name|cab
operator|->
name|entry_bytes_remaining
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_skipped
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
comment|/* If the compression type is none(uncompressed), we've already 	 * consumed data as much as the current entry size. */
if|if
condition|(
name|cab
operator|->
name|entry_cffolder
operator|->
name|comptype
operator|==
name|COMPTYPE_NONE
operator|&&
name|cab
operator|->
name|entry_cfdata
operator|!=
name|NULL
condition|)
name|cab
operator|->
name|entry_cfdata
operator|->
name|unconsumed
operator|=
literal|0
expr_stmt|;
comment|/* This entry is finished and done. */
name|cab
operator|->
name|end_of_entry_cleanup
operator|=
name|cab
operator|->
name|end_of_entry
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_cab_cleanup
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|cab
modifier|*
name|cab
init|=
operator|(
expr|struct
name|cab
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
name|struct
name|cfheader
modifier|*
name|hd
init|=
operator|&
name|cab
operator|->
name|cfheader
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|hd
operator|->
name|folder_array
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hd
operator|->
name|folder_count
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|hd
operator|->
name|folder_array
index|[
name|i
index|]
operator|.
name|cfdata
operator|.
name|memimage
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hd
operator|->
name|folder_array
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hd
operator|->
name|file_array
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cab
operator|->
name|cfheader
operator|.
name|file_count
condition|;
name|i
operator|++
control|)
name|archive_string_free
argument_list|(
operator|&
operator|(
name|hd
operator|->
name|file_array
index|[
name|i
index|]
operator|.
name|pathname
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hd
operator|->
name|file_array
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
if|if
condition|(
name|cab
operator|->
name|stream_valid
condition|)
name|inflateEnd
argument_list|(
operator|&
name|cab
operator|->
name|stream
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lzx_decode_free
argument_list|(
operator|&
name|cab
operator|->
name|xstrm
argument_list|)
expr_stmt|;
name|archive_wstring_free
argument_list|(
operator|&
name|cab
operator|->
name|ws
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cab
operator|->
name|uncompressed_buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cab
argument_list|)
expr_stmt|;
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert an MSDOS-style date/time into Unix-style time. */
end_comment

begin_function
specifier|static
name|time_t
name|cab_dos_time
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|)
block|{
name|int
name|msTime
decl_stmt|,
name|msDate
decl_stmt|;
name|struct
name|tm
name|ts
decl_stmt|;
name|msDate
operator|=
name|archive_le16dec
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|msTime
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
name|ts
operator|.
name|tm_year
operator|=
operator|(
operator|(
name|msDate
operator|>>
literal|9
operator|)
operator|&
literal|0x7f
operator|)
operator|+
literal|80
expr_stmt|;
comment|/* Years since 1900. */
name|ts
operator|.
name|tm_mon
operator|=
operator|(
operator|(
name|msDate
operator|>>
literal|5
operator|)
operator|&
literal|0x0f
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* Month number.     */
name|ts
operator|.
name|tm_mday
operator|=
name|msDate
operator|&
literal|0x1f
expr_stmt|;
comment|/* Day of month.     */
name|ts
operator|.
name|tm_hour
operator|=
operator|(
name|msTime
operator|>>
literal|11
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|ts
operator|.
name|tm_min
operator|=
operator|(
name|msTime
operator|>>
literal|5
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|ts
operator|.
name|tm_sec
operator|=
operator|(
name|msTime
operator|<<
literal|1
operator|)
operator|&
literal|0x3e
expr_stmt|;
name|ts
operator|.
name|tm_isdst
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|mktime
argument_list|(
operator|&
name|ts
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************  *  * LZX decompression code.  *  *****************************************************************/
end_comment

begin_comment
comment|/*  * Initialize LZX decoder.  *  * Returns ARCHIVE_OK if initialization was successful.  * Returns ARCHIVE_FAILED if w_bits has unsupported value.  * Returns ARCHIVE_FATAL if initialization failed; memory allocation  * error occurred.  */
end_comment

begin_function
specifier|static
name|int
name|lzx_decode_init
parameter_list|(
name|struct
name|lzx_stream
modifier|*
name|strm
parameter_list|,
name|int
name|w_bits
parameter_list|)
block|{
name|struct
name|lzx_dec
modifier|*
name|ds
decl_stmt|;
name|int
name|slot
decl_stmt|,
name|w_size
decl_stmt|,
name|w_slot
decl_stmt|;
name|int
name|base
decl_stmt|,
name|footer
decl_stmt|;
name|int
name|base_inc
index|[
literal|18
index|]
decl_stmt|;
if|if
condition|(
name|strm
operator|->
name|ds
operator|==
name|NULL
condition|)
block|{
name|strm
operator|->
name|ds
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|strm
operator|->
name|ds
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strm
operator|->
name|ds
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|ds
operator|=
name|strm
operator|->
name|ds
expr_stmt|;
name|ds
operator|->
name|error
operator|=
name|ARCHIVE_FAILED
expr_stmt|;
comment|/* Allow bits from 15(32KBi) up to 21(2MBi) */
if|if
condition|(
name|w_bits
operator|<
name|SLOT_BASE
operator|||
name|w_bits
operator|>
name|SLOT_MAX
condition|)
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
name|ds
operator|->
name|error
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
comment|/* 	 * Alloc window 	 */
name|w_size
operator|=
name|ds
operator|->
name|w_size
expr_stmt|;
name|w_slot
operator|=
name|slots
index|[
name|w_bits
operator|-
name|SLOT_BASE
index|]
expr_stmt|;
name|ds
operator|->
name|w_size
operator|=
literal|1U
operator|<<
name|w_bits
expr_stmt|;
name|ds
operator|->
name|w_mask
operator|=
name|ds
operator|->
name|w_size
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|w_buff
operator|==
name|NULL
operator|||
name|w_size
operator|!=
name|ds
operator|->
name|w_size
condition|)
block|{
name|free
argument_list|(
name|ds
operator|->
name|w_buff
argument_list|)
expr_stmt|;
name|ds
operator|->
name|w_buff
operator|=
name|malloc
argument_list|(
name|ds
operator|->
name|w_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|w_buff
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|free
argument_list|(
name|ds
operator|->
name|pos_tbl
argument_list|)
expr_stmt|;
name|ds
operator|->
name|pos_tbl
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ds
operator|->
name|pos_tbl
index|[
literal|0
index|]
argument_list|)
operator|*
name|w_slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|pos_tbl
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|lzx_huffman_free
argument_list|(
operator|&
operator|(
name|ds
operator|->
name|mt
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|footer
operator|=
literal|0
init|;
name|footer
operator|<
literal|18
condition|;
name|footer
operator|++
control|)
name|base_inc
index|[
name|footer
index|]
operator|=
literal|1
operator|<<
name|footer
expr_stmt|;
name|base
operator|=
name|footer
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|w_slot
condition|;
name|slot
operator|++
control|)
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|footer
operator|==
literal|0
condition|)
name|base
operator|=
name|slot
expr_stmt|;
else|else
name|base
operator|+=
name|base_inc
index|[
name|footer
index|]
expr_stmt|;
if|if
condition|(
name|footer
operator|<
literal|17
condition|)
block|{
name|footer
operator|=
operator|-
literal|2
expr_stmt|;
for|for
control|(
name|n
operator|=
name|base
init|;
name|n
condition|;
name|n
operator|>>=
literal|1
control|)
name|footer
operator|++
expr_stmt|;
if|if
condition|(
name|footer
operator|<=
literal|0
condition|)
name|footer
operator|=
literal|0
expr_stmt|;
block|}
name|ds
operator|->
name|pos_tbl
index|[
name|slot
index|]
operator|.
name|base
operator|=
name|base
expr_stmt|;
name|ds
operator|->
name|pos_tbl
index|[
name|slot
index|]
operator|.
name|footer_bits
operator|=
name|footer
expr_stmt|;
block|}
name|ds
operator|->
name|w_pos
operator|=
literal|0
expr_stmt|;
name|ds
operator|->
name|state
operator|=
literal|0
expr_stmt|;
name|ds
operator|->
name|br
operator|.
name|cache_buffer
operator|=
literal|0
expr_stmt|;
name|ds
operator|->
name|br
operator|.
name|cache_avail
operator|=
literal|0
expr_stmt|;
name|ds
operator|->
name|r0
operator|=
name|ds
operator|->
name|r1
operator|=
name|ds
operator|->
name|r2
operator|=
literal|1
expr_stmt|;
comment|/* Initialize aligned offset tree. */
if|if
condition|(
name|lzx_huffman_init
argument_list|(
operator|&
operator|(
name|ds
operator|->
name|at
operator|)
argument_list|,
literal|8
argument_list|,
literal|8
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
comment|/* Initialize pre-tree. */
if|if
condition|(
name|lzx_huffman_init
argument_list|(
operator|&
operator|(
name|ds
operator|->
name|pt
operator|)
argument_list|,
literal|20
argument_list|,
literal|10
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
comment|/* Initialize Main tree. */
if|if
condition|(
name|lzx_huffman_init
argument_list|(
operator|&
operator|(
name|ds
operator|->
name|mt
operator|)
argument_list|,
literal|256
operator|+
operator|(
name|w_slot
operator|<<
literal|3
operator|)
argument_list|,
literal|16
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
comment|/* Initialize Length tree. */
if|if
condition|(
name|lzx_huffman_init
argument_list|(
operator|&
operator|(
name|ds
operator|->
name|lt
operator|)
argument_list|,
literal|249
argument_list|,
literal|16
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|ds
operator|->
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release LZX decoder.  */
end_comment

begin_function
specifier|static
name|void
name|lzx_decode_free
parameter_list|(
name|struct
name|lzx_stream
modifier|*
name|strm
parameter_list|)
block|{
if|if
condition|(
name|strm
operator|->
name|ds
operator|==
name|NULL
condition|)
return|return;
name|free
argument_list|(
name|strm
operator|->
name|ds
operator|->
name|w_buff
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|strm
operator|->
name|ds
operator|->
name|pos_tbl
argument_list|)
expr_stmt|;
name|lzx_huffman_free
argument_list|(
operator|&
operator|(
name|strm
operator|->
name|ds
operator|->
name|at
operator|)
argument_list|)
expr_stmt|;
name|lzx_huffman_free
argument_list|(
operator|&
operator|(
name|strm
operator|->
name|ds
operator|->
name|pt
operator|)
argument_list|)
expr_stmt|;
name|lzx_huffman_free
argument_list|(
operator|&
operator|(
name|strm
operator|->
name|ds
operator|->
name|mt
operator|)
argument_list|)
expr_stmt|;
name|lzx_huffman_free
argument_list|(
operator|&
operator|(
name|strm
operator|->
name|ds
operator|->
name|lt
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|strm
operator|->
name|ds
argument_list|)
expr_stmt|;
name|strm
operator|->
name|ds
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * E8 Call Translation reversal.  */
end_comment

begin_function
specifier|static
name|void
name|lzx_translation
parameter_list|(
name|struct
name|lzx_stream
modifier|*
name|strm
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint32_t
name|offset
parameter_list|)
block|{
name|struct
name|lzx_dec
modifier|*
name|ds
init|=
name|strm
operator|->
name|ds
decl_stmt|;
name|unsigned
name|char
modifier|*
name|b
decl_stmt|,
modifier|*
name|end
decl_stmt|;
if|if
condition|(
operator|!
name|ds
operator|->
name|translation
operator|||
name|size
operator|<=
literal|10
condition|)
return|return;
name|b
operator|=
name|p
expr_stmt|;
name|end
operator|=
name|b
operator|+
name|size
operator|-
literal|10
expr_stmt|;
while|while
condition|(
name|b
operator|<
name|end
operator|&&
operator|(
name|b
operator|=
name|memchr
argument_list|(
name|b
argument_list|,
literal|0xE8
argument_list|,
name|end
operator|-
name|b
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|i
init|=
name|b
operator|-
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
decl_stmt|;
name|int32_t
name|cp
decl_stmt|,
name|displacement
decl_stmt|,
name|value
decl_stmt|;
name|cp
operator|=
call|(
name|int32_t
call|)
argument_list|(
name|offset
operator|+
operator|(
name|uint32_t
operator|)
name|i
argument_list|)
expr_stmt|;
name|value
operator|=
name|archive_le32dec
argument_list|(
operator|&
name|b
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|>=
operator|-
name|cp
operator|&&
name|value
operator|<
operator|(
name|int32_t
operator|)
name|ds
operator|->
name|translation_size
condition|)
block|{
if|if
condition|(
name|value
operator|>=
literal|0
condition|)
name|displacement
operator|=
name|value
operator|-
name|cp
expr_stmt|;
else|else
name|displacement
operator|=
name|value
operator|+
name|ds
operator|->
name|translation_size
expr_stmt|;
name|archive_le32enc
argument_list|(
operator|&
name|b
index|[
literal|1
index|]
argument_list|,
operator|(
name|uint32_t
operator|)
name|displacement
argument_list|)
expr_stmt|;
block|}
name|b
operator|+=
literal|5
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Bit stream reader.  */
end_comment

begin_comment
comment|/* Check that the cache buffer has enough bits. */
end_comment

begin_define
define|#
directive|define
name|lzx_br_has
parameter_list|(
name|br
parameter_list|,
name|n
parameter_list|)
value|((br)->cache_avail>= n)
end_define

begin_comment
comment|/* Get compressed data by bit. */
end_comment

begin_define
define|#
directive|define
name|lzx_br_bits
parameter_list|(
name|br
parameter_list|,
name|n
parameter_list|)
define|\
value|(((uint32_t)((br)->cache_buffer>>		\ 		((br)->cache_avail - (n))))& cache_masks[n])
end_define

begin_define
define|#
directive|define
name|lzx_br_bits_forced
parameter_list|(
name|br
parameter_list|,
name|n
parameter_list|)
define|\
value|(((uint32_t)((br)->cache_buffer<<		\ 		((n) - (br)->cache_avail)))& cache_masks[n])
end_define

begin_comment
comment|/* Read ahead to make sure the cache buffer has enough compressed data we  * will use.  *  True  : completed, there is enough data in the cache buffer.  *  False : we met that strm->next_in is empty, we have to get following  *          bytes. */
end_comment

begin_define
define|#
directive|define
name|lzx_br_read_ahead_0
parameter_list|(
name|strm
parameter_list|,
name|br
parameter_list|,
name|n
parameter_list|)
define|\
value|(lzx_br_has((br), (n)) || lzx_br_fillup(strm, br))
end_define

begin_comment
comment|/*  True  : the cache buffer has some bits as much as we need.  *  False : there are no enough bits in the cache buffer to be used,  *          we have to get following bytes if we could. */
end_comment

begin_define
define|#
directive|define
name|lzx_br_read_ahead
parameter_list|(
name|strm
parameter_list|,
name|br
parameter_list|,
name|n
parameter_list|)
define|\
value|(lzx_br_read_ahead_0((strm), (br), (n)) || lzx_br_has((br), (n)))
end_define

begin_comment
comment|/* Notify how many bits we consumed. */
end_comment

begin_define
define|#
directive|define
name|lzx_br_consume
parameter_list|(
name|br
parameter_list|,
name|n
parameter_list|)
value|((br)->cache_avail -= (n))
end_define

begin_define
define|#
directive|define
name|lzx_br_consume_unaligned_bits
parameter_list|(
name|br
parameter_list|)
value|((br)->cache_avail&= ~0x0f)
end_define

begin_define
define|#
directive|define
name|lzx_br_is_unaligned
parameter_list|(
name|br
parameter_list|)
value|((br)->cache_avail& 0x0f)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|uint32_t
name|cache_masks
index|[]
init|=
block|{
literal|0x00000000
block|,
literal|0x00000001
block|,
literal|0x00000003
block|,
literal|0x00000007
block|,
literal|0x0000000F
block|,
literal|0x0000001F
block|,
literal|0x0000003F
block|,
literal|0x0000007F
block|,
literal|0x000000FF
block|,
literal|0x000001FF
block|,
literal|0x000003FF
block|,
literal|0x000007FF
block|,
literal|0x00000FFF
block|,
literal|0x00001FFF
block|,
literal|0x00003FFF
block|,
literal|0x00007FFF
block|,
literal|0x0000FFFF
block|,
literal|0x0001FFFF
block|,
literal|0x0003FFFF
block|,
literal|0x0007FFFF
block|,
literal|0x000FFFFF
block|,
literal|0x001FFFFF
block|,
literal|0x003FFFFF
block|,
literal|0x007FFFFF
block|,
literal|0x00FFFFFF
block|,
literal|0x01FFFFFF
block|,
literal|0x03FFFFFF
block|,
literal|0x07FFFFFF
block|,
literal|0x0FFFFFFF
block|,
literal|0x1FFFFFFF
block|,
literal|0x3FFFFFFF
block|,
literal|0x7FFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Shift away used bits in the cache data and fill it up with following bits.  * Call this when cache buffer does not have enough bits you need.  *  * Returns 1 if the cache buffer is full.  * Returns 0 if the cache buffer is not full; input buffer is empty.  */
end_comment

begin_function
specifier|static
name|int
name|lzx_br_fillup
parameter_list|(
name|struct
name|lzx_stream
modifier|*
name|strm
parameter_list|,
name|struct
name|lzx_br
modifier|*
name|br
parameter_list|)
block|{
comment|/*  * x86 proccessor family can read misaligned data without an access error.  */
name|int
name|n
init|=
name|CACHE_BITS
operator|-
name|br
operator|->
name|cache_avail
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|n
operator|>>
literal|4
condition|)
block|{
case|case
literal|4
case|:
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|>=
literal|8
condition|)
block|{
name|br
operator|->
name|cache_buffer
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|1
index|]
operator|)
operator|<<
literal|56
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|0
index|]
operator|)
operator|<<
literal|48
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|3
index|]
operator|)
operator|<<
literal|40
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|2
index|]
operator|)
operator|<<
literal|32
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|5
index|]
operator|)
operator|<<
literal|24
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|4
index|]
operator|)
operator|<<
literal|16
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|7
index|]
operator|)
operator|<<
literal|8
operator||
operator|(
name|uint32_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|6
index|]
expr_stmt|;
name|strm
operator|->
name|next_in
operator|+=
literal|8
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|-=
literal|8
expr_stmt|;
name|br
operator|->
name|cache_avail
operator|+=
literal|8
operator|*
literal|8
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|>=
literal|6
condition|)
block|{
name|br
operator|->
name|cache_buffer
operator|=
operator|(
name|br
operator|->
name|cache_buffer
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|1
index|]
operator|)
operator|<<
literal|40
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|0
index|]
operator|)
operator|<<
literal|32
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|3
index|]
operator|)
operator|<<
literal|24
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|2
index|]
operator|)
operator|<<
literal|16
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|5
index|]
operator|)
operator|<<
literal|8
operator||
operator|(
name|uint32_t
operator|)
name|strm
operator|->
name|next_in
index|[
literal|4
index|]
expr_stmt|;
name|strm
operator|->
name|next_in
operator|+=
literal|6
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|-=
literal|6
expr_stmt|;
name|br
operator|->
name|cache_avail
operator|+=
literal|6
operator|*
literal|8
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
literal|0
case|:
comment|/* We have enough compressed data in 			 * the cache buffer.*/
return|return
operator|(
literal|1
operator|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|<
literal|2
condition|)
block|{
comment|/* There is not enough compressed data to 			 * fill up the cache buffer. */
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|==
literal|1
condition|)
block|{
name|br
operator|->
name|odd
operator|=
operator|*
name|strm
operator|->
name|next_in
operator|++
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|--
expr_stmt|;
name|br
operator|->
name|have_odd
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|br
operator|->
name|cache_buffer
operator|=
operator|(
name|br
operator|->
name|cache_buffer
operator|<<
literal|16
operator|)
operator||
name|archive_le16dec
argument_list|(
name|strm
operator|->
name|next_in
argument_list|)
expr_stmt|;
name|strm
operator|->
name|next_in
operator|+=
literal|2
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|-=
literal|2
expr_stmt|;
name|br
operator|->
name|cache_avail
operator|+=
literal|16
expr_stmt|;
name|n
operator|-=
literal|16
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lzx_br_fixup
parameter_list|(
name|struct
name|lzx_stream
modifier|*
name|strm
parameter_list|,
name|struct
name|lzx_br
modifier|*
name|br
parameter_list|)
block|{
name|int
name|n
init|=
name|CACHE_BITS
operator|-
name|br
operator|->
name|cache_avail
decl_stmt|;
if|if
condition|(
name|br
operator|->
name|have_odd
operator|&&
name|n
operator|>=
literal|16
operator|&&
name|strm
operator|->
name|avail_in
operator|>
literal|0
condition|)
block|{
name|br
operator|->
name|cache_buffer
operator|=
operator|(
name|br
operator|->
name|cache_buffer
operator|<<
literal|16
operator|)
operator||
operator|(
call|(
name|uint16_t
call|)
argument_list|(
operator|*
name|strm
operator|->
name|next_in
argument_list|)
operator|)
operator|<<
literal|8
operator||
name|br
operator|->
name|odd
expr_stmt|;
name|strm
operator|->
name|next_in
operator|++
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|--
expr_stmt|;
name|br
operator|->
name|cache_avail
operator|+=
literal|16
expr_stmt|;
name|br
operator|->
name|have_odd
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lzx_cleanup_bitstream
parameter_list|(
name|struct
name|lzx_stream
modifier|*
name|strm
parameter_list|)
block|{
name|strm
operator|->
name|ds
operator|->
name|br
operator|.
name|cache_avail
operator|=
literal|0
expr_stmt|;
name|strm
operator|->
name|ds
operator|->
name|br
operator|.
name|have_odd
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Decode LZX.  *  * 1. Returns ARCHIVE_OK if output buffer or input buffer are empty.  *    Please set available buffer and call this function again.  * 2. Returns ARCHIVE_EOF if decompression has been completed.  * 3. Returns ARCHIVE_FAILED if an error occurred; compressed data  *    is broken or you do not set 'last' flag properly.  */
end_comment

begin_define
define|#
directive|define
name|ST_RD_TRANSLATION
value|0
end_define

begin_define
define|#
directive|define
name|ST_RD_TRANSLATION_SIZE
value|1
end_define

begin_define
define|#
directive|define
name|ST_RD_BLOCK_TYPE
value|2
end_define

begin_define
define|#
directive|define
name|ST_RD_BLOCK_SIZE
value|3
end_define

begin_define
define|#
directive|define
name|ST_RD_ALIGNMENT
value|4
end_define

begin_define
define|#
directive|define
name|ST_RD_R0
value|5
end_define

begin_define
define|#
directive|define
name|ST_RD_R1
value|6
end_define

begin_define
define|#
directive|define
name|ST_RD_R2
value|7
end_define

begin_define
define|#
directive|define
name|ST_COPY_UNCOMP1
value|8
end_define

begin_define
define|#
directive|define
name|ST_COPY_UNCOMP2
value|9
end_define

begin_define
define|#
directive|define
name|ST_RD_ALIGNED_OFFSET
value|10
end_define

begin_define
define|#
directive|define
name|ST_RD_VERBATIM
value|11
end_define

begin_define
define|#
directive|define
name|ST_RD_PRE_MAIN_TREE_256
value|12
end_define

begin_define
define|#
directive|define
name|ST_MAIN_TREE_256
value|13
end_define

begin_define
define|#
directive|define
name|ST_RD_PRE_MAIN_TREE_REM
value|14
end_define

begin_define
define|#
directive|define
name|ST_MAIN_TREE_REM
value|15
end_define

begin_define
define|#
directive|define
name|ST_RD_PRE_LENGTH_TREE
value|16
end_define

begin_define
define|#
directive|define
name|ST_LENGTH_TREE
value|17
end_define

begin_define
define|#
directive|define
name|ST_MAIN
value|18
end_define

begin_define
define|#
directive|define
name|ST_LENGTH
value|19
end_define

begin_define
define|#
directive|define
name|ST_OFFSET
value|20
end_define

begin_define
define|#
directive|define
name|ST_REAL_POS
value|21
end_define

begin_define
define|#
directive|define
name|ST_COPY
value|22
end_define

begin_function
specifier|static
name|int
name|lzx_decode
parameter_list|(
name|struct
name|lzx_stream
modifier|*
name|strm
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|struct
name|lzx_dec
modifier|*
name|ds
init|=
name|strm
operator|->
name|ds
decl_stmt|;
name|int64_t
name|avail_in
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|ds
operator|->
name|error
condition|)
return|return
operator|(
name|ds
operator|->
name|error
operator|)
return|;
name|avail_in
operator|=
name|strm
operator|->
name|avail_in
expr_stmt|;
name|lzx_br_fixup
argument_list|(
name|strm
argument_list|,
operator|&
operator|(
name|ds
operator|->
name|br
operator|)
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|ds
operator|->
name|state
operator|<
name|ST_MAIN
condition|)
name|r
operator|=
name|lzx_read_blocks
argument_list|(
name|strm
argument_list|,
name|last
argument_list|)
expr_stmt|;
else|else
block|{
name|int64_t
name|bytes_written
init|=
name|strm
operator|->
name|avail_out
decl_stmt|;
name|r
operator|=
name|lzx_decode_blocks
argument_list|(
name|strm
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|bytes_written
operator|-=
name|strm
operator|->
name|avail_out
expr_stmt|;
name|strm
operator|->
name|next_out
operator|+=
name|bytes_written
expr_stmt|;
name|strm
operator|->
name|total_out
operator|+=
name|bytes_written
expr_stmt|;
block|}
block|}
do|while
condition|(
name|r
operator|==
literal|100
condition|)
do|;
name|strm
operator|->
name|total_in
operator|+=
name|avail_in
operator|-
name|strm
operator|->
name|avail_in
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lzx_read_blocks
parameter_list|(
name|struct
name|lzx_stream
modifier|*
name|strm
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|struct
name|lzx_dec
modifier|*
name|ds
init|=
name|strm
operator|->
name|ds
decl_stmt|;
name|struct
name|lzx_br
modifier|*
name|br
init|=
operator|&
operator|(
name|ds
operator|->
name|br
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|r
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|ds
operator|->
name|state
condition|)
block|{
case|case
name|ST_RD_TRANSLATION
case|:
if|if
condition|(
operator|!
name|lzx_br_read_ahead
argument_list|(
name|strm
argument_list|,
name|br
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ds
operator|->
name|state
operator|=
name|ST_RD_TRANSLATION
expr_stmt|;
if|if
condition|(
name|last
condition|)
goto|goto
name|failed
goto|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
name|ds
operator|->
name|translation
operator|=
name|lzx_br_bits
argument_list|(
name|br
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lzx_br_consume
argument_list|(
name|br
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|ST_RD_TRANSLATION_SIZE
case|:
if|if
condition|(
name|ds
operator|->
name|translation
condition|)
block|{
if|if
condition|(
operator|!
name|lzx_br_read_ahead
argument_list|(
name|strm
argument_list|,
name|br
argument_list|,
literal|32
argument_list|)
condition|)
block|{
name|ds
operator|->
name|state
operator|=
name|ST_RD_TRANSLATION_SIZE
expr_stmt|;
if|if
condition|(
name|last
condition|)
goto|goto
name|failed
goto|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
name|ds
operator|->
name|translation_size
operator|=
name|lzx_br_bits
argument_list|(
name|br
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|lzx_br_consume
argument_list|(
name|br
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|ds
operator|->
name|translation_size
operator|<<=
literal|16
expr_stmt|;
name|ds
operator|->
name|translation_size
operator||=
name|lzx_br_bits
argument_list|(
name|br
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|lzx_br_consume
argument_list|(
name|br
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
comment|/* FALL THROUGH */
case|case
name|ST_RD_BLOCK_TYPE
case|:
if|if
condition|(
operator|!
name|lzx_br_read_ahead
argument_list|(
name|strm
argument_list|,
name|br
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|ds
operator|->
name|state
operator|=
name|ST_RD_BLOCK_TYPE
expr_stmt|;
if|if
condition|(
name|last
condition|)
goto|goto
name|failed
goto|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
name|ds
operator|->
name|block_type
operator|=
name|lzx_br_bits
argument_list|(
name|br
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|lzx_br_consume
argument_list|(
name|br
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* Check a block type. */
switch|switch
condition|(
name|ds
operator|->
name|block_type
condition|)
block|{
case|case
name|VERBATIM_BLOCK
case|:
case|case
name|ALIGNED_OFFSET_BLOCK
case|:
case|case
name|UNCOMPRESSED_BLOCK
case|:
break|break;
default|default:
goto|goto
name|failed
goto|;
comment|/* Invalid */
block|}
comment|/* FALL THROUGH */
case|case
name|ST_RD_BLOCK_SIZE
case|:
if|if
condition|(
operator|!
name|lzx_br_read_ahead
argument_list|(
name|strm
argument_list|,
name|br
argument_list|,
literal|24
argument_list|)
condition|)
block|{
name|ds
operator|->
name|state
operator|=
name|ST_RD_BLOCK_SIZE
expr_stmt|;
if|if
condition|(
name|last
condition|)
goto|goto
name|failed
goto|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
name|ds
operator|->
name|block_size
operator|=
name|lzx_br_bits
argument_list|(
name|br
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|lzx_br_consume
argument_list|(
name|br
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|ds
operator|->
name|block_size
operator|<<=
literal|16
expr_stmt|;
name|ds
operator|->
name|block_size
operator||=
name|lzx_br_bits
argument_list|(
name|br
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|lzx_br_consume
argument_list|(
name|br
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|block_size
operator|==
literal|0
condition|)
goto|goto
name|failed
goto|;
name|ds
operator|->
name|block_bytes_avail
operator|=
name|ds
operator|->
name|block_size
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|block_type
operator|!=
name|UNCOMPRESSED_BLOCK
condition|)
block|{
if|if
condition|(
name|ds
operator|->
name|block_type
operator|==
name|VERBATIM_BLOCK
condition|)
name|ds
operator|->
name|state
operator|=
name|ST_RD_VERBATIM
expr_stmt|;
else|else
name|ds
operator|->
name|state
operator|=
name|ST_RD_ALIGNED_OFFSET
expr_stmt|;
break|break;
block|}
comment|/* FALL THROUGH */
case|case
name|ST_RD_ALIGNMENT
case|:
comment|/* 			 * Handle an Uncompressed Block. 			 */
comment|/* Skip padding to align following field on 			 * 16-bit boundary. */
if|if
condition|(
name|lzx_br_is_unaligned
argument_list|(
name|br
argument_list|)
condition|)
name|lzx_br_consume_unaligned_bits
argument_list|(
name|br
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|lzx_br_read_ahead
argument_list|(
name|strm
argument_list|,
name|br
argument_list|,
literal|16
argument_list|)
condition|)
name|lzx_br_consume
argument_list|(
name|br
argument_list|,
literal|16
argument_list|)
expr_stmt|;
else|else
block|{
name|ds
operator|->
name|state
operator|=
name|ST_RD_ALIGNMENT
expr_stmt|;
if|if
condition|(
name|last
condition|)
goto|goto
name|failed
goto|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
block|}
comment|/* Preparation to read repeated offsets R0,R1 and R2. */
name|ds
operator|->
name|rbytes_avail
operator|=
literal|0
expr_stmt|;
name|ds
operator|->
name|state
operator|=
name|ST_RD_R0
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|ST_RD_R0
case|:
case|case
name|ST_RD_R1
case|:
case|case
name|ST_RD_R2
case|:
do|do
block|{
name|uint16_t
name|u16
decl_stmt|;
comment|/* Drain bits in the cache buffer of 				 * bit-stream. */
if|if
condition|(
name|lzx_br_has
argument_list|(
name|br
argument_list|,
literal|32
argument_list|)
condition|)
block|{
name|u16
operator|=
name|lzx_br_bits
argument_list|(
name|br
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|lzx_br_consume
argument_list|(
name|br
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|archive_le16enc
argument_list|(
name|ds
operator|->
name|rbytes
argument_list|,
name|u16
argument_list|)
expr_stmt|;
name|u16
operator|=
name|lzx_br_bits
argument_list|(
name|br
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|lzx_br_consume
argument_list|(
name|br
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|archive_le16enc
argument_list|(
name|ds
operator|->
name|rbytes
operator|+
literal|2
argument_list|,
name|u16
argument_list|)
expr_stmt|;
name|ds
operator|->
name|rbytes_avail
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lzx_br_has
argument_list|(
name|br
argument_list|,
literal|16
argument_list|)
condition|)
block|{
name|u16
operator|=
name|lzx_br_bits
argument_list|(
name|br
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|lzx_br_consume
argument_list|(
name|br
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|archive_le16enc
argument_list|(
name|ds
operator|->
name|rbytes
argument_list|,
name|u16
argument_list|)
expr_stmt|;
name|ds
operator|->
name|rbytes_avail
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|ds
operator|->
name|rbytes_avail
operator|<
literal|4
operator|&&
name|ds
operator|->
name|br
operator|.
name|have_odd
condition|)
block|{
name|ds
operator|->
name|rbytes
index|[
name|ds
operator|->
name|rbytes_avail
operator|++
index|]
operator|=
name|ds
operator|->
name|br
operator|.
name|odd
expr_stmt|;
name|ds
operator|->
name|br
operator|.
name|have_odd
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|ds
operator|->
name|rbytes_avail
operator|<
literal|4
condition|)
block|{
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|last
condition|)
goto|goto
name|failed
goto|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
name|ds
operator|->
name|rbytes
index|[
name|ds
operator|->
name|rbytes_avail
operator|++
index|]
operator|=
operator|*
name|strm
operator|->
name|next_in
operator|++
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|--
expr_stmt|;
block|}
name|ds
operator|->
name|rbytes_avail
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|state
operator|==
name|ST_RD_R0
condition|)
block|{
name|ds
operator|->
name|r0
operator|=
name|archive_le32dec
argument_list|(
name|ds
operator|->
name|rbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|r0
operator|<
literal|0
condition|)
goto|goto
name|failed
goto|;
name|ds
operator|->
name|state
operator|=
name|ST_RD_R1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ds
operator|->
name|state
operator|==
name|ST_RD_R1
condition|)
block|{
name|ds
operator|->
name|r1
operator|=
name|archive_le32dec
argument_list|(
name|ds
operator|->
name|rbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|r1
operator|<
literal|0
condition|)
goto|goto
name|failed
goto|;
name|ds
operator|->
name|state
operator|=
name|ST_RD_R2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ds
operator|->
name|state
operator|==
name|ST_RD_R2
condition|)
block|{
name|ds
operator|->
name|r2
operator|=
name|archive_le32dec
argument_list|(
name|ds
operator|->
name|rbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|r2
operator|<
literal|0
condition|)
goto|goto
name|failed
goto|;
comment|/* We've gotten all repeated offsets. */
name|ds
operator|->
name|state
operator|=
name|ST_COPY_UNCOMP1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|ds
operator|->
name|state
operator|!=
name|ST_COPY_UNCOMP1
condition|)
do|;
comment|/* FALL THROUGH */
case|case
name|ST_COPY_UNCOMP1
case|:
comment|/* 			 * Copy bytes form next_in to next_out directly. 			 */
while|while
condition|(
name|ds
operator|->
name|block_bytes_avail
condition|)
block|{
name|int
name|l
decl_stmt|;
if|if
condition|(
name|strm
operator|->
name|avail_out
operator|<=
literal|0
condition|)
comment|/* Output buffer is empty. */
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|<=
literal|0
condition|)
block|{
comment|/* Input buffer is empty. */
if|if
condition|(
name|last
condition|)
goto|goto
name|failed
goto|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
name|l
operator|=
operator|(
name|int
operator|)
name|ds
operator|->
name|block_bytes_avail
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|ds
operator|->
name|w_size
operator|-
name|ds
operator|->
name|w_pos
condition|)
name|l
operator|=
name|ds
operator|->
name|w_size
operator|-
name|ds
operator|->
name|w_pos
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|strm
operator|->
name|avail_out
condition|)
name|l
operator|=
operator|(
name|int
operator|)
name|strm
operator|->
name|avail_out
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|strm
operator|->
name|avail_in
condition|)
name|l
operator|=
operator|(
name|int
operator|)
name|strm
operator|->
name|avail_in
expr_stmt|;
name|memcpy
argument_list|(
name|strm
operator|->
name|next_out
argument_list|,
name|strm
operator|->
name|next_in
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
name|ds
operator|->
name|w_buff
index|[
name|ds
operator|->
name|w_pos
index|]
operator|)
argument_list|,
name|strm
operator|->
name|next_in
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|strm
operator|->
name|next_in
operator|+=
name|l
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|-=
name|l
expr_stmt|;
name|strm
operator|->
name|next_out
operator|+=
name|l
expr_stmt|;
name|strm
operator|->
name|avail_out
operator|-=
name|l
expr_stmt|;
name|strm
operator|->
name|total_out
operator|+=
name|l
expr_stmt|;
name|ds
operator|->
name|w_pos
operator|=
operator|(
name|ds
operator|->
name|w_pos
operator|+
name|l
operator|)
operator|&
name|ds
operator|->
name|w_mask
expr_stmt|;
name|ds
operator|->
name|block_bytes_avail
operator|-=
name|l
expr_stmt|;
block|}
comment|/* FALL THROUGH */
case|case
name|ST_COPY_UNCOMP2
case|:
comment|/* Re-align; skip padding byte. */
if|if
condition|(
name|ds
operator|->
name|block_size
operator|&
literal|1
condition|)
block|{
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|<=
literal|0
condition|)
block|{
comment|/* Input buffer is empty. */
name|ds
operator|->
name|state
operator|=
name|ST_COPY_UNCOMP2
expr_stmt|;
if|if
condition|(
name|last
condition|)
goto|goto
name|failed
goto|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
name|strm
operator|->
name|next_in
operator|++
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|--
expr_stmt|;
block|}
comment|/* This block ended. */
name|ds
operator|->
name|state
operator|=
name|ST_RD_BLOCK_TYPE
expr_stmt|;
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
comment|/********************/
case|case
name|ST_RD_ALIGNED_OFFSET
case|:
comment|/* 			 * Read Aligned offset tree. 			 */
if|if
condition|(
operator|!
name|lzx_br_read_ahead
argument_list|(
name|strm
argument_list|,
name|br
argument_list|,
literal|3
operator|*
name|ds
operator|->
name|at
operator|.
name|len_size
argument_list|)
condition|)
block|{
name|ds
operator|->
name|state
operator|=
name|ST_RD_ALIGNED_OFFSET
expr_stmt|;
if|if
condition|(
name|last
condition|)
goto|goto
name|failed
goto|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
name|memset
argument_list|(
name|ds
operator|->
name|at
operator|.
name|freq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ds
operator|->
name|at
operator|.
name|freq
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ds
operator|->
name|at
operator|.
name|len_size
condition|;
name|i
operator|++
control|)
block|{
name|ds
operator|->
name|at
operator|.
name|bitlen
index|[
name|i
index|]
operator|=
name|lzx_br_bits
argument_list|(
name|br
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ds
operator|->
name|at
operator|.
name|freq
index|[
name|ds
operator|->
name|at
operator|.
name|bitlen
index|[
name|i
index|]
index|]
operator|++
expr_stmt|;
name|lzx_br_consume
argument_list|(
name|br
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|lzx_make_huffman_table
argument_list|(
operator|&
name|ds
operator|->
name|at
argument_list|)
condition|)
goto|goto
name|failed
goto|;
comment|/* FALL THROUGH */
case|case
name|ST_RD_VERBATIM
case|:
name|ds
operator|->
name|loop
operator|=
literal|0
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|ST_RD_PRE_MAIN_TREE_256
case|:
comment|/* 			 * Read Pre-tree for first 256 elements of main tree. 			 */
if|if
condition|(
operator|!
name|lzx_read_pre_tree
argument_list|(
name|strm
argument_list|)
condition|)
block|{
name|ds
operator|->
name|state
operator|=
name|ST_RD_PRE_MAIN_TREE_256
expr_stmt|;
if|if
condition|(
name|last
condition|)
goto|goto
name|failed
goto|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|lzx_make_huffman_table
argument_list|(
operator|&
name|ds
operator|->
name|pt
argument_list|)
condition|)
goto|goto
name|failed
goto|;
name|ds
operator|->
name|loop
operator|=
literal|0
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|ST_MAIN_TREE_256
case|:
comment|/* 			 * Get path lengths of first 256 elements of main tree. 			 */
name|r
operator|=
name|lzx_read_bitlen
argument_list|(
name|strm
argument_list|,
operator|&
name|ds
operator|->
name|mt
argument_list|,
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
goto|goto
name|failed
goto|;
elseif|else
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|ds
operator|->
name|state
operator|=
name|ST_MAIN_TREE_256
expr_stmt|;
if|if
condition|(
name|last
condition|)
goto|goto
name|failed
goto|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
name|ds
operator|->
name|loop
operator|=
literal|0
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|ST_RD_PRE_MAIN_TREE_REM
case|:
comment|/* 			 * Read Pre-tree for remaining elements of main tree. 			 */
if|if
condition|(
operator|!
name|lzx_read_pre_tree
argument_list|(
name|strm
argument_list|)
condition|)
block|{
name|ds
operator|->
name|state
operator|=
name|ST_RD_PRE_MAIN_TREE_REM
expr_stmt|;
if|if
condition|(
name|last
condition|)
goto|goto
name|failed
goto|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|lzx_make_huffman_table
argument_list|(
operator|&
name|ds
operator|->
name|pt
argument_list|)
condition|)
goto|goto
name|failed
goto|;
name|ds
operator|->
name|loop
operator|=
literal|256
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|ST_MAIN_TREE_REM
case|:
comment|/* 			 * Get path lengths of remaining elements of main tree. 			 */
name|r
operator|=
name|lzx_read_bitlen
argument_list|(
name|strm
argument_list|,
operator|&
name|ds
operator|->
name|mt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
goto|goto
name|failed
goto|;
elseif|else
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|ds
operator|->
name|state
operator|=
name|ST_MAIN_TREE_REM
expr_stmt|;
if|if
condition|(
name|last
condition|)
goto|goto
name|failed
goto|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|lzx_make_huffman_table
argument_list|(
operator|&
name|ds
operator|->
name|mt
argument_list|)
condition|)
goto|goto
name|failed
goto|;
name|ds
operator|->
name|loop
operator|=
literal|0
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|ST_RD_PRE_LENGTH_TREE
case|:
comment|/* 			 * Read Pre-tree for remaining elements of main tree. 			 */
if|if
condition|(
operator|!
name|lzx_read_pre_tree
argument_list|(
name|strm
argument_list|)
condition|)
block|{
name|ds
operator|->
name|state
operator|=
name|ST_RD_PRE_LENGTH_TREE
expr_stmt|;
if|if
condition|(
name|last
condition|)
goto|goto
name|failed
goto|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|lzx_make_huffman_table
argument_list|(
operator|&
name|ds
operator|->
name|pt
argument_list|)
condition|)
goto|goto
name|failed
goto|;
name|ds
operator|->
name|loop
operator|=
literal|0
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|ST_LENGTH_TREE
case|:
comment|/* 			 * Get path lengths of remaining elements of main tree. 			 */
name|r
operator|=
name|lzx_read_bitlen
argument_list|(
name|strm
argument_list|,
operator|&
name|ds
operator|->
name|lt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
goto|goto
name|failed
goto|;
elseif|else
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|ds
operator|->
name|state
operator|=
name|ST_LENGTH_TREE
expr_stmt|;
if|if
condition|(
name|last
condition|)
goto|goto
name|failed
goto|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|lzx_make_huffman_table
argument_list|(
operator|&
name|ds
operator|->
name|lt
argument_list|)
condition|)
goto|goto
name|failed
goto|;
name|ds
operator|->
name|state
operator|=
name|ST_MAIN
expr_stmt|;
return|return
operator|(
literal|100
operator|)
return|;
block|}
block|}
name|failed
label|:
return|return
operator|(
name|ds
operator|->
name|error
operator|=
name|ARCHIVE_FAILED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lzx_decode_blocks
parameter_list|(
name|struct
name|lzx_stream
modifier|*
name|strm
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|struct
name|lzx_dec
modifier|*
name|ds
init|=
name|strm
operator|->
name|ds
decl_stmt|;
name|struct
name|lzx_br
name|bre
init|=
name|ds
operator|->
name|br
decl_stmt|;
name|struct
name|huffman
modifier|*
name|at
init|=
operator|&
operator|(
name|ds
operator|->
name|at
operator|)
decl_stmt|,
modifier|*
name|lt
init|=
operator|&
operator|(
name|ds
operator|->
name|lt
operator|)
decl_stmt|,
modifier|*
name|mt
init|=
operator|&
operator|(
name|ds
operator|->
name|mt
operator|)
decl_stmt|;
specifier|const
name|struct
name|lzx_pos_tbl
modifier|*
name|pos_tbl
init|=
name|ds
operator|->
name|pos_tbl
decl_stmt|;
name|unsigned
name|char
modifier|*
name|noutp
init|=
name|strm
operator|->
name|next_out
decl_stmt|;
name|unsigned
name|char
modifier|*
name|endp
init|=
name|noutp
operator|+
name|strm
operator|->
name|avail_out
decl_stmt|;
name|unsigned
name|char
modifier|*
name|w_buff
init|=
name|ds
operator|->
name|w_buff
decl_stmt|;
name|unsigned
name|char
modifier|*
name|at_bitlen
init|=
name|at
operator|->
name|bitlen
decl_stmt|;
name|unsigned
name|char
modifier|*
name|lt_bitlen
init|=
name|lt
operator|->
name|bitlen
decl_stmt|;
name|unsigned
name|char
modifier|*
name|mt_bitlen
init|=
name|mt
operator|->
name|bitlen
decl_stmt|;
name|size_t
name|block_bytes_avail
init|=
name|ds
operator|->
name|block_bytes_avail
decl_stmt|;
name|int
name|at_max_bits
init|=
name|at
operator|->
name|max_bits
decl_stmt|;
name|int
name|lt_max_bits
init|=
name|lt
operator|->
name|max_bits
decl_stmt|;
name|int
name|mt_max_bits
init|=
name|mt
operator|->
name|max_bits
decl_stmt|;
name|int
name|c
decl_stmt|,
name|copy_len
init|=
name|ds
operator|->
name|copy_len
decl_stmt|,
name|copy_pos
init|=
name|ds
operator|->
name|copy_pos
decl_stmt|;
name|int
name|w_pos
init|=
name|ds
operator|->
name|w_pos
decl_stmt|,
name|w_mask
init|=
name|ds
operator|->
name|w_mask
decl_stmt|,
name|w_size
init|=
name|ds
operator|->
name|w_size
decl_stmt|;
name|int
name|length_header
init|=
name|ds
operator|->
name|length_header
decl_stmt|;
name|int
name|offset_bits
init|=
name|ds
operator|->
name|offset_bits
decl_stmt|;
name|int
name|position_slot
init|=
name|ds
operator|->
name|position_slot
decl_stmt|;
name|int
name|r0
init|=
name|ds
operator|->
name|r0
decl_stmt|,
name|r1
init|=
name|ds
operator|->
name|r1
decl_stmt|,
name|r2
init|=
name|ds
operator|->
name|r2
decl_stmt|;
name|int
name|state
init|=
name|ds
operator|->
name|state
decl_stmt|;
name|char
name|block_type
init|=
name|ds
operator|->
name|block_type
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|ST_MAIN
case|:
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|block_bytes_avail
operator|==
literal|0
condition|)
block|{
comment|/* This block ended. */
name|ds
operator|->
name|state
operator|=
name|ST_RD_BLOCK_TYPE
expr_stmt|;
name|ds
operator|->
name|br
operator|=
name|bre
expr_stmt|;
name|ds
operator|->
name|block_bytes_avail
operator|=
name|block_bytes_avail
expr_stmt|;
name|ds
operator|->
name|copy_len
operator|=
name|copy_len
expr_stmt|;
name|ds
operator|->
name|copy_pos
operator|=
name|copy_pos
expr_stmt|;
name|ds
operator|->
name|length_header
operator|=
name|length_header
expr_stmt|;
name|ds
operator|->
name|position_slot
operator|=
name|position_slot
expr_stmt|;
name|ds
operator|->
name|r0
operator|=
name|r0
expr_stmt|;
name|ds
operator|->
name|r1
operator|=
name|r1
expr_stmt|;
name|ds
operator|->
name|r2
operator|=
name|r2
expr_stmt|;
name|ds
operator|->
name|w_pos
operator|=
name|w_pos
expr_stmt|;
name|strm
operator|->
name|avail_out
operator|=
name|endp
operator|-
name|noutp
expr_stmt|;
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
block|}
if|if
condition|(
name|noutp
operator|>=
name|endp
condition|)
comment|/* Output buffer is empty. */
goto|goto
name|next_data
goto|;
if|if
condition|(
operator|!
name|lzx_br_read_ahead
argument_list|(
name|strm
argument_list|,
operator|&
name|bre
argument_list|,
name|mt_max_bits
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|last
condition|)
goto|goto
name|next_data
goto|;
comment|/* Remaining bits are less than 					 * maximum bits(mt.max_bits) but maybe 					 * it still remains as much as we need, 					 * so we should try to use it with 					 * dummy bits. */
name|c
operator|=
name|lzx_decode_huffman
argument_list|(
name|mt
argument_list|,
name|lzx_br_bits_forced
argument_list|(
operator|&
name|bre
argument_list|,
name|mt_max_bits
argument_list|)
argument_list|)
expr_stmt|;
name|lzx_br_consume
argument_list|(
operator|&
name|bre
argument_list|,
name|mt_bitlen
index|[
name|c
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lzx_br_has
argument_list|(
operator|&
name|bre
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|failed
goto|;
comment|/* Over read. */
block|}
else|else
block|{
name|c
operator|=
name|lzx_decode_huffman
argument_list|(
name|mt
argument_list|,
name|lzx_br_bits
argument_list|(
operator|&
name|bre
argument_list|,
name|mt_max_bits
argument_list|)
argument_list|)
expr_stmt|;
name|lzx_br_consume
argument_list|(
operator|&
name|bre
argument_list|,
name|mt_bitlen
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|>
name|UCHAR_MAX
condition|)
break|break;
comment|/* 				 * 'c' is exactly literal code. 				 */
comment|/* Save a decoded code to reference it 				 * afterward. */
name|w_buff
index|[
name|w_pos
index|]
operator|=
name|c
expr_stmt|;
name|w_pos
operator|=
operator|(
name|w_pos
operator|+
literal|1
operator|)
operator|&
name|w_mask
expr_stmt|;
comment|/* Store the decoded code to output buffer. */
operator|*
name|noutp
operator|++
operator|=
name|c
expr_stmt|;
name|block_bytes_avail
operator|--
expr_stmt|;
block|}
comment|/* 			 * Get a match code, its length and offset. 			 */
name|c
operator|-=
name|UCHAR_MAX
operator|+
literal|1
expr_stmt|;
name|length_header
operator|=
name|c
operator|&
literal|7
expr_stmt|;
name|position_slot
operator|=
name|c
operator|>>
literal|3
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|ST_LENGTH
case|:
comment|/* 			 * Get a length. 			 */
if|if
condition|(
name|length_header
operator|==
literal|7
condition|)
block|{
if|if
condition|(
operator|!
name|lzx_br_read_ahead
argument_list|(
name|strm
argument_list|,
operator|&
name|bre
argument_list|,
name|lt_max_bits
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|last
condition|)
block|{
name|state
operator|=
name|ST_LENGTH
expr_stmt|;
goto|goto
name|next_data
goto|;
block|}
name|c
operator|=
name|lzx_decode_huffman
argument_list|(
name|lt
argument_list|,
name|lzx_br_bits_forced
argument_list|(
operator|&
name|bre
argument_list|,
name|lt_max_bits
argument_list|)
argument_list|)
expr_stmt|;
name|lzx_br_consume
argument_list|(
operator|&
name|bre
argument_list|,
name|lt_bitlen
index|[
name|c
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lzx_br_has
argument_list|(
operator|&
name|bre
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|failed
goto|;
comment|/* Over read. */
block|}
else|else
block|{
name|c
operator|=
name|lzx_decode_huffman
argument_list|(
name|lt
argument_list|,
name|lzx_br_bits
argument_list|(
operator|&
name|bre
argument_list|,
name|lt_max_bits
argument_list|)
argument_list|)
expr_stmt|;
name|lzx_br_consume
argument_list|(
operator|&
name|bre
argument_list|,
name|lt_bitlen
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
name|copy_len
operator|=
name|c
operator|+
literal|7
operator|+
literal|2
expr_stmt|;
block|}
else|else
name|copy_len
operator|=
name|length_header
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|copy_len
operator|>
name|block_bytes_avail
condition|)
goto|goto
name|failed
goto|;
comment|/* 			 * Get an offset. 			 */
switch|switch
condition|(
name|position_slot
condition|)
block|{
case|case
literal|0
case|:
comment|/* Use repeated offset 0. */
name|copy_pos
operator|=
name|r0
expr_stmt|;
name|state
operator|=
name|ST_REAL_POS
expr_stmt|;
continue|continue;
case|case
literal|1
case|:
comment|/* Use repeated offset 1. */
name|copy_pos
operator|=
name|r1
expr_stmt|;
comment|/* Swap repeated offset. */
name|r1
operator|=
name|r0
expr_stmt|;
name|r0
operator|=
name|copy_pos
expr_stmt|;
name|state
operator|=
name|ST_REAL_POS
expr_stmt|;
continue|continue;
case|case
literal|2
case|:
comment|/* Use repeated offset 2. */
name|copy_pos
operator|=
name|r2
expr_stmt|;
comment|/* Swap repeated offset. */
name|r2
operator|=
name|r0
expr_stmt|;
name|r0
operator|=
name|copy_pos
expr_stmt|;
name|state
operator|=
name|ST_REAL_POS
expr_stmt|;
continue|continue;
default|default:
name|offset_bits
operator|=
name|pos_tbl
index|[
name|position_slot
index|]
operator|.
name|footer_bits
expr_stmt|;
break|break;
block|}
comment|/* FALL THROUGH */
case|case
name|ST_OFFSET
case|:
comment|/* 			 * Get the offset, which is a distance from 			 * current window position. 			 */
if|if
condition|(
name|block_type
operator|==
name|ALIGNED_OFFSET_BLOCK
operator|&&
name|offset_bits
operator|>=
literal|3
condition|)
block|{
name|int
name|offbits
init|=
name|offset_bits
operator|-
literal|3
decl_stmt|;
if|if
condition|(
operator|!
name|lzx_br_read_ahead
argument_list|(
name|strm
argument_list|,
operator|&
name|bre
argument_list|,
name|offbits
argument_list|)
condition|)
block|{
name|state
operator|=
name|ST_OFFSET
expr_stmt|;
if|if
condition|(
name|last
condition|)
goto|goto
name|failed
goto|;
goto|goto
name|next_data
goto|;
block|}
name|copy_pos
operator|=
name|lzx_br_bits
argument_list|(
operator|&
name|bre
argument_list|,
name|offbits
argument_list|)
operator|<<
literal|3
expr_stmt|;
comment|/* Get an aligned number. */
if|if
condition|(
operator|!
name|lzx_br_read_ahead
argument_list|(
name|strm
argument_list|,
operator|&
name|bre
argument_list|,
name|offbits
operator|+
name|at_max_bits
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|last
condition|)
block|{
name|state
operator|=
name|ST_OFFSET
expr_stmt|;
goto|goto
name|next_data
goto|;
block|}
name|lzx_br_consume
argument_list|(
operator|&
name|bre
argument_list|,
name|offbits
argument_list|)
expr_stmt|;
name|c
operator|=
name|lzx_decode_huffman
argument_list|(
name|at
argument_list|,
name|lzx_br_bits_forced
argument_list|(
operator|&
name|bre
argument_list|,
name|at_max_bits
argument_list|)
argument_list|)
expr_stmt|;
name|lzx_br_consume
argument_list|(
operator|&
name|bre
argument_list|,
name|at_bitlen
index|[
name|c
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lzx_br_has
argument_list|(
operator|&
name|bre
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|failed
goto|;
comment|/* Over read. */
block|}
else|else
block|{
name|lzx_br_consume
argument_list|(
operator|&
name|bre
argument_list|,
name|offbits
argument_list|)
expr_stmt|;
name|c
operator|=
name|lzx_decode_huffman
argument_list|(
name|at
argument_list|,
name|lzx_br_bits
argument_list|(
operator|&
name|bre
argument_list|,
name|at_max_bits
argument_list|)
argument_list|)
expr_stmt|;
name|lzx_br_consume
argument_list|(
operator|&
name|bre
argument_list|,
name|at_bitlen
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Add an aligned number. */
name|copy_pos
operator|+=
name|c
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|lzx_br_read_ahead
argument_list|(
name|strm
argument_list|,
operator|&
name|bre
argument_list|,
name|offset_bits
argument_list|)
condition|)
block|{
name|state
operator|=
name|ST_OFFSET
expr_stmt|;
if|if
condition|(
name|last
condition|)
goto|goto
name|failed
goto|;
goto|goto
name|next_data
goto|;
block|}
name|copy_pos
operator|=
name|lzx_br_bits
argument_list|(
operator|&
name|bre
argument_list|,
name|offset_bits
argument_list|)
expr_stmt|;
name|lzx_br_consume
argument_list|(
operator|&
name|bre
argument_list|,
name|offset_bits
argument_list|)
expr_stmt|;
block|}
name|copy_pos
operator|+=
name|pos_tbl
index|[
name|position_slot
index|]
operator|.
name|base
operator|-
literal|2
expr_stmt|;
comment|/* Update repeated offset LRU queue. */
name|r2
operator|=
name|r1
expr_stmt|;
name|r1
operator|=
name|r0
expr_stmt|;
name|r0
operator|=
name|copy_pos
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|ST_REAL_POS
case|:
comment|/* 			 * Compute a real position in window. 			 */
name|copy_pos
operator|=
operator|(
name|w_pos
operator|-
name|copy_pos
operator|)
operator|&
name|w_mask
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|ST_COPY
case|:
comment|/* 			 * Copy several bytes as extracted data from the window 			 * into the output buffer. 			 */
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|l
decl_stmt|;
name|l
operator|=
name|copy_len
expr_stmt|;
if|if
condition|(
name|copy_pos
operator|>
name|w_pos
condition|)
block|{
if|if
condition|(
name|l
operator|>
name|w_size
operator|-
name|copy_pos
condition|)
name|l
operator|=
name|w_size
operator|-
name|copy_pos
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|l
operator|>
name|w_size
operator|-
name|w_pos
condition|)
name|l
operator|=
name|w_size
operator|-
name|w_pos
expr_stmt|;
block|}
if|if
condition|(
name|noutp
operator|+
name|l
operator|>=
name|endp
condition|)
name|l
operator|=
call|(
name|int
call|)
argument_list|(
name|endp
operator|-
name|noutp
argument_list|)
expr_stmt|;
name|s
operator|=
name|w_buff
operator|+
name|copy_pos
expr_stmt|;
if|if
condition|(
name|l
operator|>=
literal|8
operator|&&
operator|(
operator|(
name|copy_pos
operator|+
name|l
operator|<
name|w_pos
operator|)
operator|||
operator|(
name|w_pos
operator|+
name|l
operator|<
name|copy_pos
operator|)
operator|)
condition|)
block|{
name|memcpy
argument_list|(
name|w_buff
operator|+
name|w_pos
argument_list|,
name|s
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|noutp
argument_list|,
name|s
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|char
modifier|*
name|d
decl_stmt|;
name|int
name|li
decl_stmt|;
name|d
operator|=
name|w_buff
operator|+
name|w_pos
expr_stmt|;
for|for
control|(
name|li
operator|=
literal|0
init|;
name|li
operator|<
name|l
condition|;
name|li
operator|++
control|)
name|noutp
index|[
name|li
index|]
operator|=
name|d
index|[
name|li
index|]
operator|=
name|s
index|[
name|li
index|]
expr_stmt|;
block|}
name|noutp
operator|+=
name|l
expr_stmt|;
name|copy_pos
operator|=
operator|(
name|copy_pos
operator|+
name|l
operator|)
operator|&
name|w_mask
expr_stmt|;
name|w_pos
operator|=
operator|(
name|w_pos
operator|+
name|l
operator|)
operator|&
name|w_mask
expr_stmt|;
name|block_bytes_avail
operator|-=
name|l
expr_stmt|;
if|if
condition|(
name|copy_len
operator|<=
name|l
condition|)
comment|/* A copy of current pattern ended. */
break|break;
name|copy_len
operator|-=
name|l
expr_stmt|;
if|if
condition|(
name|noutp
operator|>=
name|endp
condition|)
block|{
comment|/* Output buffer is empty. */
name|state
operator|=
name|ST_COPY
expr_stmt|;
goto|goto
name|next_data
goto|;
block|}
block|}
name|state
operator|=
name|ST_MAIN
expr_stmt|;
break|break;
block|}
block|}
name|failed
label|:
return|return
operator|(
name|ds
operator|->
name|error
operator|=
name|ARCHIVE_FAILED
operator|)
return|;
name|next_data
label|:
name|ds
operator|->
name|br
operator|=
name|bre
expr_stmt|;
name|ds
operator|->
name|block_bytes_avail
operator|=
name|block_bytes_avail
expr_stmt|;
name|ds
operator|->
name|copy_len
operator|=
name|copy_len
expr_stmt|;
name|ds
operator|->
name|copy_pos
operator|=
name|copy_pos
expr_stmt|;
name|ds
operator|->
name|length_header
operator|=
name|length_header
expr_stmt|;
name|ds
operator|->
name|offset_bits
operator|=
name|offset_bits
expr_stmt|;
name|ds
operator|->
name|position_slot
operator|=
name|position_slot
expr_stmt|;
name|ds
operator|->
name|r0
operator|=
name|r0
expr_stmt|;
name|ds
operator|->
name|r1
operator|=
name|r1
expr_stmt|;
name|ds
operator|->
name|r2
operator|=
name|r2
expr_stmt|;
name|ds
operator|->
name|state
operator|=
name|state
expr_stmt|;
name|ds
operator|->
name|w_pos
operator|=
name|w_pos
expr_stmt|;
name|strm
operator|->
name|avail_out
operator|=
name|endp
operator|-
name|noutp
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lzx_read_pre_tree
parameter_list|(
name|struct
name|lzx_stream
modifier|*
name|strm
parameter_list|)
block|{
name|struct
name|lzx_dec
modifier|*
name|ds
init|=
name|strm
operator|->
name|ds
decl_stmt|;
name|struct
name|lzx_br
modifier|*
name|br
init|=
operator|&
operator|(
name|ds
operator|->
name|br
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ds
operator|->
name|loop
operator|==
literal|0
condition|)
name|memset
argument_list|(
name|ds
operator|->
name|pt
operator|.
name|freq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ds
operator|->
name|pt
operator|.
name|freq
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ds
operator|->
name|loop
init|;
name|i
operator|<
name|ds
operator|->
name|pt
operator|.
name|len_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|lzx_br_read_ahead
argument_list|(
name|strm
argument_list|,
name|br
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|ds
operator|->
name|loop
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ds
operator|->
name|pt
operator|.
name|bitlen
index|[
name|i
index|]
operator|=
name|lzx_br_bits
argument_list|(
name|br
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ds
operator|->
name|pt
operator|.
name|freq
index|[
name|ds
operator|->
name|pt
operator|.
name|bitlen
index|[
name|i
index|]
index|]
operator|++
expr_stmt|;
name|lzx_br_consume
argument_list|(
name|br
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|ds
operator|->
name|loop
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read a bunch of bit-lengths from pre-tree.  */
end_comment

begin_function
specifier|static
name|int
name|lzx_read_bitlen
parameter_list|(
name|struct
name|lzx_stream
modifier|*
name|strm
parameter_list|,
name|struct
name|huffman
modifier|*
name|d
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|struct
name|lzx_dec
modifier|*
name|ds
init|=
name|strm
operator|->
name|ds
decl_stmt|;
name|struct
name|lzx_br
modifier|*
name|br
init|=
operator|&
operator|(
name|ds
operator|->
name|br
operator|)
decl_stmt|;
name|int
name|c
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|ret
decl_stmt|,
name|same
decl_stmt|;
name|unsigned
name|rbits
decl_stmt|;
name|i
operator|=
name|ds
operator|->
name|loop
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|memset
argument_list|(
name|d
operator|->
name|freq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|d
operator|->
name|freq
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|end
operator|<
literal|0
condition|)
name|end
operator|=
name|d
operator|->
name|len_size
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|end
condition|)
block|{
name|ds
operator|->
name|loop
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|lzx_br_read_ahead
argument_list|(
name|strm
argument_list|,
name|br
argument_list|,
name|ds
operator|->
name|pt
operator|.
name|max_bits
argument_list|)
condition|)
goto|goto
name|getdata
goto|;
name|rbits
operator|=
name|lzx_br_bits
argument_list|(
name|br
argument_list|,
name|ds
operator|->
name|pt
operator|.
name|max_bits
argument_list|)
expr_stmt|;
name|c
operator|=
name|lzx_decode_huffman
argument_list|(
operator|&
operator|(
name|ds
operator|->
name|pt
operator|)
argument_list|,
name|rbits
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|17
case|:
comment|/* several zero lengths, from 4 to 19. */
if|if
condition|(
operator|!
name|lzx_br_read_ahead
argument_list|(
name|strm
argument_list|,
name|br
argument_list|,
name|ds
operator|->
name|pt
operator|.
name|bitlen
index|[
name|c
index|]
operator|+
literal|4
argument_list|)
condition|)
goto|goto
name|getdata
goto|;
name|lzx_br_consume
argument_list|(
name|br
argument_list|,
name|ds
operator|->
name|pt
operator|.
name|bitlen
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|same
operator|=
name|lzx_br_bits
argument_list|(
name|br
argument_list|,
literal|4
argument_list|)
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|i
operator|+
name|same
operator|>
name|end
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Invalid */
name|lzx_br_consume
argument_list|(
name|br
argument_list|,
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|same
condition|;
name|j
operator|++
control|)
name|d
operator|->
name|bitlen
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|18
case|:
comment|/* many zero lengths, from 20 to 51. */
if|if
condition|(
operator|!
name|lzx_br_read_ahead
argument_list|(
name|strm
argument_list|,
name|br
argument_list|,
name|ds
operator|->
name|pt
operator|.
name|bitlen
index|[
name|c
index|]
operator|+
literal|5
argument_list|)
condition|)
goto|goto
name|getdata
goto|;
name|lzx_br_consume
argument_list|(
name|br
argument_list|,
name|ds
operator|->
name|pt
operator|.
name|bitlen
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|same
operator|=
name|lzx_br_bits
argument_list|(
name|br
argument_list|,
literal|5
argument_list|)
operator|+
literal|20
expr_stmt|;
if|if
condition|(
name|i
operator|+
name|same
operator|>
name|end
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Invalid */
name|lzx_br_consume
argument_list|(
name|br
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|d
operator|->
name|bitlen
operator|+
name|i
argument_list|,
literal|0
argument_list|,
name|same
argument_list|)
expr_stmt|;
name|i
operator|+=
name|same
expr_stmt|;
break|break;
case|case
literal|19
case|:
comment|/* a few same lengths. */
if|if
condition|(
operator|!
name|lzx_br_read_ahead
argument_list|(
name|strm
argument_list|,
name|br
argument_list|,
name|ds
operator|->
name|pt
operator|.
name|bitlen
index|[
name|c
index|]
operator|+
literal|1
operator|+
name|ds
operator|->
name|pt
operator|.
name|max_bits
argument_list|)
condition|)
goto|goto
name|getdata
goto|;
name|lzx_br_consume
argument_list|(
name|br
argument_list|,
name|ds
operator|->
name|pt
operator|.
name|bitlen
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|same
operator|=
name|lzx_br_bits
argument_list|(
name|br
argument_list|,
literal|1
argument_list|)
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|i
operator|+
name|same
operator|>
name|end
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|lzx_br_consume
argument_list|(
name|br
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rbits
operator|=
name|lzx_br_bits
argument_list|(
name|br
argument_list|,
name|ds
operator|->
name|pt
operator|.
name|max_bits
argument_list|)
expr_stmt|;
name|c
operator|=
name|lzx_decode_huffman
argument_list|(
operator|&
operator|(
name|ds
operator|->
name|pt
operator|)
argument_list|,
name|rbits
argument_list|)
expr_stmt|;
name|lzx_br_consume
argument_list|(
name|br
argument_list|,
name|ds
operator|->
name|pt
operator|.
name|bitlen
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
name|d
operator|->
name|bitlen
index|[
name|i
index|]
operator|-
name|c
operator|+
literal|17
operator|)
operator|%
literal|17
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Invalid */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|same
condition|;
name|j
operator|++
control|)
name|d
operator|->
name|bitlen
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|d
operator|->
name|freq
index|[
name|c
index|]
operator|+=
name|same
expr_stmt|;
break|break;
default|default:
name|lzx_br_consume
argument_list|(
name|br
argument_list|,
name|ds
operator|->
name|pt
operator|.
name|bitlen
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
name|d
operator|->
name|bitlen
index|[
name|i
index|]
operator|-
name|c
operator|+
literal|17
operator|)
operator|%
literal|17
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Invalid */
name|d
operator|->
name|freq
index|[
name|c
index|]
operator|++
expr_stmt|;
name|d
operator|->
name|bitlen
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
break|break;
block|}
block|}
name|ret
operator|=
literal|1
expr_stmt|;
name|getdata
label|:
name|ds
operator|->
name|loop
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lzx_huffman_init
parameter_list|(
name|struct
name|huffman
modifier|*
name|hf
parameter_list|,
name|size_t
name|len_size
parameter_list|,
name|int
name|tbl_bits
parameter_list|)
block|{
name|int
name|bits
decl_stmt|;
if|if
condition|(
name|hf
operator|->
name|bitlen
operator|==
name|NULL
operator|||
name|hf
operator|->
name|len_size
operator|!=
operator|(
name|int
operator|)
name|len_size
condition|)
block|{
name|free
argument_list|(
name|hf
operator|->
name|bitlen
argument_list|)
expr_stmt|;
name|hf
operator|->
name|bitlen
operator|=
name|calloc
argument_list|(
name|len_size
argument_list|,
sizeof|sizeof
argument_list|(
name|hf
operator|->
name|bitlen
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hf
operator|->
name|bitlen
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|hf
operator|->
name|len_size
operator|=
operator|(
name|int
operator|)
name|len_size
expr_stmt|;
block|}
else|else
name|memset
argument_list|(
name|hf
operator|->
name|bitlen
argument_list|,
literal|0
argument_list|,
name|len_size
operator|*
sizeof|sizeof
argument_list|(
name|hf
operator|->
name|bitlen
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hf
operator|->
name|tbl
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|tbl_bits
operator|<
name|HTBL_BITS
condition|)
name|bits
operator|=
name|tbl_bits
expr_stmt|;
else|else
name|bits
operator|=
name|HTBL_BITS
expr_stmt|;
name|hf
operator|->
name|tbl
operator|=
name|malloc
argument_list|(
operator|(
operator|(
name|size_t
operator|)
literal|1
operator|<<
name|bits
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|hf
operator|->
name|tbl
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hf
operator|->
name|tbl
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|hf
operator|->
name|tbl_bits
operator|=
name|tbl_bits
expr_stmt|;
block|}
if|if
condition|(
name|hf
operator|->
name|tree
operator|==
name|NULL
operator|&&
name|tbl_bits
operator|>
name|HTBL_BITS
condition|)
block|{
name|hf
operator|->
name|tree_avail
operator|=
literal|1
operator|<<
operator|(
name|tbl_bits
operator|-
name|HTBL_BITS
operator|+
literal|4
operator|)
expr_stmt|;
name|hf
operator|->
name|tree
operator|=
name|malloc
argument_list|(
name|hf
operator|->
name|tree_avail
operator|*
sizeof|sizeof
argument_list|(
name|hf
operator|->
name|tree
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hf
operator|->
name|tree
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lzx_huffman_free
parameter_list|(
name|struct
name|huffman
modifier|*
name|hf
parameter_list|)
block|{
name|free
argument_list|(
name|hf
operator|->
name|bitlen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hf
operator|->
name|tbl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hf
operator|->
name|tree
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make a huffman coding table.  */
end_comment

begin_function
specifier|static
name|int
name|lzx_make_huffman_table
parameter_list|(
name|struct
name|huffman
modifier|*
name|hf
parameter_list|)
block|{
name|uint16_t
modifier|*
name|tbl
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|bitlen
decl_stmt|;
name|int
name|bitptn
index|[
literal|17
index|]
decl_stmt|,
name|weight
index|[
literal|17
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|maxbits
init|=
literal|0
decl_stmt|,
name|ptn
decl_stmt|,
name|tbl_size
decl_stmt|,
name|w
decl_stmt|;
name|int
name|diffbits
decl_stmt|,
name|len_avail
decl_stmt|;
comment|/* 	 * Initialize bit patterns. 	 */
name|ptn
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|w
operator|=
literal|1
operator|<<
literal|15
init|;
name|i
operator|<=
literal|16
condition|;
name|i
operator|++
operator|,
name|w
operator|>>=
literal|1
control|)
block|{
name|bitptn
index|[
name|i
index|]
operator|=
name|ptn
expr_stmt|;
name|weight
index|[
name|i
index|]
operator|=
name|w
expr_stmt|;
if|if
condition|(
name|hf
operator|->
name|freq
index|[
name|i
index|]
condition|)
block|{
name|ptn
operator|+=
name|hf
operator|->
name|freq
index|[
name|i
index|]
operator|*
name|w
expr_stmt|;
name|maxbits
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|ptn
operator|&
literal|0xffff
operator|)
operator|!=
literal|0
operator|||
name|maxbits
operator|>
name|hf
operator|->
name|tbl_bits
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Invalid */
name|hf
operator|->
name|max_bits
operator|=
name|maxbits
expr_stmt|;
comment|/* 	 * Cut out extra bits which we won't house in the table. 	 * This preparation reduces the same calculation in the for-loop 	 * making the table. 	 */
if|if
condition|(
name|maxbits
operator|<
literal|16
condition|)
block|{
name|int
name|ebits
init|=
literal|16
operator|-
name|maxbits
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|maxbits
condition|;
name|i
operator|++
control|)
block|{
name|bitptn
index|[
name|i
index|]
operator|>>=
name|ebits
expr_stmt|;
name|weight
index|[
name|i
index|]
operator|>>=
name|ebits
expr_stmt|;
block|}
block|}
if|if
condition|(
name|maxbits
operator|>
name|HTBL_BITS
condition|)
block|{
name|int
name|htbl_max
decl_stmt|;
name|uint16_t
modifier|*
name|p
decl_stmt|;
name|diffbits
operator|=
name|maxbits
operator|-
name|HTBL_BITS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|HTBL_BITS
condition|;
name|i
operator|++
control|)
block|{
name|bitptn
index|[
name|i
index|]
operator|>>=
name|diffbits
expr_stmt|;
name|weight
index|[
name|i
index|]
operator|>>=
name|diffbits
expr_stmt|;
block|}
name|htbl_max
operator|=
name|bitptn
index|[
name|HTBL_BITS
index|]
operator|+
name|weight
index|[
name|HTBL_BITS
index|]
operator|*
name|hf
operator|->
name|freq
index|[
name|HTBL_BITS
index|]
expr_stmt|;
name|p
operator|=
operator|&
operator|(
name|hf
operator|->
name|tbl
index|[
name|htbl_max
index|]
operator|)
expr_stmt|;
while|while
condition|(
name|p
operator|<
operator|&
name|hf
operator|->
name|tbl
index|[
literal|1U
operator|<<
name|HTBL_BITS
index|]
condition|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|diffbits
operator|=
literal|0
expr_stmt|;
name|hf
operator|->
name|shift_bits
operator|=
name|diffbits
expr_stmt|;
comment|/* 	 * Make the table. 	 */
name|tbl_size
operator|=
literal|1
operator|<<
name|HTBL_BITS
expr_stmt|;
name|tbl
operator|=
name|hf
operator|->
name|tbl
expr_stmt|;
name|bitlen
operator|=
name|hf
operator|->
name|bitlen
expr_stmt|;
name|len_avail
operator|=
name|hf
operator|->
name|len_size
expr_stmt|;
name|hf
operator|->
name|tree_used
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len_avail
condition|;
name|i
operator|++
control|)
block|{
name|uint16_t
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|,
name|cnt
decl_stmt|;
name|uint16_t
name|bit
decl_stmt|;
name|int
name|extlen
decl_stmt|;
name|struct
name|htree_t
modifier|*
name|ht
decl_stmt|;
if|if
condition|(
name|bitlen
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
comment|/* Get a bit pattern */
name|len
operator|=
name|bitlen
index|[
name|i
index|]
expr_stmt|;
name|ptn
operator|=
name|bitptn
index|[
name|len
index|]
expr_stmt|;
name|cnt
operator|=
name|weight
index|[
name|len
index|]
expr_stmt|;
if|if
condition|(
name|len
operator|<=
name|HTBL_BITS
condition|)
block|{
comment|/* Calculate next bit pattern */
if|if
condition|(
operator|(
name|bitptn
index|[
name|len
index|]
operator|=
name|ptn
operator|+
name|cnt
operator|)
operator|>
name|tbl_size
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Invalid */
comment|/* Update the table */
name|p
operator|=
operator|&
operator|(
name|tbl
index|[
name|ptn
index|]
operator|)
expr_stmt|;
while|while
condition|(
operator|--
name|cnt
operator|>=
literal|0
condition|)
name|p
index|[
name|cnt
index|]
operator|=
operator|(
name|uint16_t
operator|)
name|i
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * A bit length is too big to be housed to a direct table, 		 * so we use a tree model for its extra bits. 		 */
name|bitptn
index|[
name|len
index|]
operator|=
name|ptn
operator|+
name|cnt
expr_stmt|;
name|bit
operator|=
literal|1U
operator|<<
operator|(
name|diffbits
operator|-
literal|1
operator|)
expr_stmt|;
name|extlen
operator|=
name|len
operator|-
name|HTBL_BITS
expr_stmt|;
name|p
operator|=
operator|&
operator|(
name|tbl
index|[
name|ptn
operator|>>
name|diffbits
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
operator|*
name|p
operator|=
name|len_avail
operator|+
name|hf
operator|->
name|tree_used
expr_stmt|;
name|ht
operator|=
operator|&
operator|(
name|hf
operator|->
name|tree
index|[
name|hf
operator|->
name|tree_used
operator|++
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|hf
operator|->
name|tree_used
operator|>
name|hf
operator|->
name|tree_avail
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Invalid */
name|ht
operator|->
name|left
operator|=
literal|0
expr_stmt|;
name|ht
operator|->
name|right
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|p
operator|<
name|len_avail
operator|||
operator|*
name|p
operator|>=
operator|(
name|len_avail
operator|+
name|hf
operator|->
name|tree_used
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Invalid */
name|ht
operator|=
operator|&
operator|(
name|hf
operator|->
name|tree
index|[
operator|*
name|p
operator|-
name|len_avail
index|]
operator|)
expr_stmt|;
block|}
while|while
condition|(
operator|--
name|extlen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ptn
operator|&
name|bit
condition|)
block|{
if|if
condition|(
name|ht
operator|->
name|left
operator|<
name|len_avail
condition|)
block|{
name|ht
operator|->
name|left
operator|=
name|len_avail
operator|+
name|hf
operator|->
name|tree_used
expr_stmt|;
name|ht
operator|=
operator|&
operator|(
name|hf
operator|->
name|tree
index|[
name|hf
operator|->
name|tree_used
operator|++
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|hf
operator|->
name|tree_used
operator|>
name|hf
operator|->
name|tree_avail
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Invalid */
name|ht
operator|->
name|left
operator|=
literal|0
expr_stmt|;
name|ht
operator|->
name|right
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ht
operator|=
operator|&
operator|(
name|hf
operator|->
name|tree
index|[
name|ht
operator|->
name|left
operator|-
name|len_avail
index|]
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ht
operator|->
name|right
operator|<
name|len_avail
condition|)
block|{
name|ht
operator|->
name|right
operator|=
name|len_avail
operator|+
name|hf
operator|->
name|tree_used
expr_stmt|;
name|ht
operator|=
operator|&
operator|(
name|hf
operator|->
name|tree
index|[
name|hf
operator|->
name|tree_used
operator|++
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|hf
operator|->
name|tree_used
operator|>
name|hf
operator|->
name|tree_avail
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Invalid */
name|ht
operator|->
name|left
operator|=
literal|0
expr_stmt|;
name|ht
operator|->
name|right
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ht
operator|=
operator|&
operator|(
name|hf
operator|->
name|tree
index|[
name|ht
operator|->
name|right
operator|-
name|len_avail
index|]
operator|)
expr_stmt|;
block|}
block|}
name|bit
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ptn
operator|&
name|bit
condition|)
block|{
if|if
condition|(
name|ht
operator|->
name|left
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Invalid */
name|ht
operator|->
name|left
operator|=
operator|(
name|uint16_t
operator|)
name|i
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ht
operator|->
name|right
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Invalid */
name|ht
operator|->
name|right
operator|=
operator|(
name|uint16_t
operator|)
name|i
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lzx_decode_huffman_tree
parameter_list|(
name|struct
name|huffman
modifier|*
name|hf
parameter_list|,
name|unsigned
name|rbits
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|struct
name|htree_t
modifier|*
name|ht
decl_stmt|;
name|int
name|extlen
decl_stmt|;
name|ht
operator|=
name|hf
operator|->
name|tree
expr_stmt|;
name|extlen
operator|=
name|hf
operator|->
name|shift_bits
expr_stmt|;
while|while
condition|(
name|c
operator|>=
name|hf
operator|->
name|len_size
condition|)
block|{
name|c
operator|-=
name|hf
operator|->
name|len_size
expr_stmt|;
if|if
condition|(
name|extlen
operator|--
operator|<=
literal|0
operator|||
name|c
operator|>=
name|hf
operator|->
name|tree_used
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|rbits
operator|&
operator|(
literal|1U
operator|<<
name|extlen
operator|)
condition|)
name|c
operator|=
name|ht
index|[
name|c
index|]
operator|.
name|left
expr_stmt|;
else|else
name|c
operator|=
name|ht
index|[
name|c
index|]
operator|.
name|right
expr_stmt|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|lzx_decode_huffman
parameter_list|(
name|struct
name|huffman
modifier|*
name|hf
parameter_list|,
name|unsigned
name|rbits
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
comment|/* 	 * At first search an index table for a bit pattern. 	 * If it fails, search a huffman tree for. 	 */
name|c
operator|=
name|hf
operator|->
name|tbl
index|[
name|rbits
operator|>>
name|hf
operator|->
name|shift_bits
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|<
name|hf
operator|->
name|len_size
condition|)
return|return
operator|(
name|c
operator|)
return|;
comment|/* This bit pattern needs to be found out at a huffman tree. */
return|return
operator|(
name|lzx_decode_huffman_tree
argument_list|(
name|hf
argument_list|,
name|rbits
argument_list|,
name|c
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

