begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009-2011 Michihiro NAKAJIMA  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"archive_platform.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ERRNO_H
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"archive.h"
end_include

begin_include
include|#
directive|include
file|"archive_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_read_private.h"
end_include

begin_comment
comment|/* Maximum lookahead during bid phase */
end_comment

begin_define
define|#
directive|define
name|UUENCODE_BID_MAX_READ
value|128*1024
end_define

begin_comment
comment|/* in bytes */
end_comment

begin_struct
struct|struct
name|uudecode
block|{
name|int64_t
name|total
decl_stmt|;
name|unsigned
name|char
modifier|*
name|in_buff
decl_stmt|;
define|#
directive|define
name|IN_BUFF_SIZE
value|(1024)
name|int
name|in_cnt
decl_stmt|;
name|size_t
name|in_allocated
decl_stmt|;
name|unsigned
name|char
modifier|*
name|out_buff
decl_stmt|;
define|#
directive|define
name|OUT_BUFF_SIZE
value|(64 * 1024)
name|int
name|state
decl_stmt|;
define|#
directive|define
name|ST_FIND_HEAD
value|0
define|#
directive|define
name|ST_READ_UU
value|1
define|#
directive|define
name|ST_UUEND
value|2
define|#
directive|define
name|ST_READ_BASE64
value|3
define|#
directive|define
name|ST_IGNORE
value|4
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|uudecode_bidder_bid
parameter_list|(
name|struct
name|archive_read_filter_bidder
modifier|*
parameter_list|,
name|struct
name|archive_read_filter
modifier|*
name|filter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uudecode_bidder_init
parameter_list|(
name|struct
name|archive_read_filter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssize_t
name|uudecode_filter_read
parameter_list|(
name|struct
name|archive_read_filter
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uudecode_filter_close
parameter_list|(
name|struct
name|archive_read_filter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|ARCHIVE_VERSION_NUMBER
operator|<
literal|4000000
end_if

begin_comment
comment|/* Deprecated; remove in libarchive 4.0 */
end_comment

begin_function
name|int
name|archive_read_support_compression_uu
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|)
block|{
return|return
name|archive_read_support_filter_uu
argument_list|(
name|a
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|archive_read_support_filter_uu
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|struct
name|archive_read_filter_bidder
modifier|*
name|bidder
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_READ_MAGIC
argument_list|,
name|ARCHIVE_STATE_NEW
argument_list|,
literal|"archive_read_support_filter_uu"
argument_list|)
expr_stmt|;
if|if
condition|(
name|__archive_read_get_bidder
argument_list|(
name|a
argument_list|,
operator|&
name|bidder
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|bidder
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|bidder
operator|->
name|name
operator|=
literal|"uu"
expr_stmt|;
name|bidder
operator|->
name|bid
operator|=
name|uudecode_bidder_bid
expr_stmt|;
name|bidder
operator|->
name|init
operator|=
name|uudecode_bidder_init
expr_stmt|;
name|bidder
operator|->
name|options
operator|=
name|NULL
expr_stmt|;
name|bidder
operator|->
name|free
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|ascii
index|[
literal|256
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|'\n'
block|,
literal|0
block|,
literal|0
block|,
literal|'\r'
block|,
literal|0
block|,
literal|0
block|,
comment|/* 00 - 0F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 10 - 1F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 20 - 2F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 30 - 3F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 40 - 4F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 50 - 5F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 60 - 6F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
comment|/* 70 - 7F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 80 - 8F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 90 - 9F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* A0 - AF */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* B0 - BF */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* C0 - CF */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* D0 - DF */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* E0 - EF */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* F0 - FF */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|uuchar
index|[
literal|256
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 00 - 0F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 10 - 1F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 20 - 2F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 30 - 3F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 40 - 4F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 50 - 5F */
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 60 - 6F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 70 - 7F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 80 - 8F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 90 - 9F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* A0 - AF */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* B0 - BF */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* C0 - CF */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* D0 - DF */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* E0 - EF */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* F0 - FF */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|base64
index|[
literal|256
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 00 - 0F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 10 - 1F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
comment|/* 20 - 2F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
comment|/* 30 - 3F */
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 40 - 4F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 50 - 5F */
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 60 - 6F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 70 - 7F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 80 - 8F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 90 - 9F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* A0 - AF */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* B0 - BF */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* C0 - CF */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* D0 - DF */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* E0 - EF */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* F0 - FF */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|base64num
index|[
literal|128
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 00 - 0F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 10 - 1F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|62
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|63
block|,
comment|/* 20 - 2F */
literal|52
block|,
literal|53
block|,
literal|54
block|,
literal|55
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|59
block|,
literal|60
block|,
literal|61
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 30 - 3F */
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
comment|/* 40 - 4F */
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 50 - 5F */
literal|0
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
comment|/* 60 - 6F */
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|49
block|,
literal|50
block|,
literal|51
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 70 - 7F */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|ssize_t
name|get_line
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|b
parameter_list|,
name|ssize_t
name|avail
parameter_list|,
name|ssize_t
modifier|*
name|nlsize
parameter_list|)
block|{
name|ssize_t
name|len
decl_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|len
operator|<
name|avail
condition|)
block|{
switch|switch
condition|(
name|ascii
index|[
operator|*
name|b
index|]
condition|)
block|{
case|case
literal|0
case|:
comment|/* Non-ascii character or control character. */
if|if
condition|(
name|nlsize
operator|!=
name|NULL
condition|)
operator|*
name|nlsize
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
literal|'\r'
case|:
if|if
condition|(
name|avail
operator|-
name|len
operator|>
literal|1
operator|&&
name|b
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|nlsize
operator|!=
name|NULL
condition|)
operator|*
name|nlsize
operator|=
literal|2
expr_stmt|;
return|return
operator|(
name|len
operator|+
literal|2
operator|)
return|;
block|}
comment|/* FALL THROUGH */
case|case
literal|'\n'
case|:
if|if
condition|(
name|nlsize
operator|!=
name|NULL
condition|)
operator|*
name|nlsize
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|len
operator|+
literal|1
operator|)
return|;
case|case
literal|1
case|:
name|b
operator|++
expr_stmt|;
name|len
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|nlsize
operator|!=
name|NULL
condition|)
operator|*
name|nlsize
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|avail
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|bid_get_line
parameter_list|(
name|struct
name|archive_read_filter
modifier|*
name|filter
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|b
parameter_list|,
name|ssize_t
modifier|*
name|avail
parameter_list|,
name|ssize_t
modifier|*
name|ravail
parameter_list|,
name|ssize_t
modifier|*
name|nl
parameter_list|,
name|size_t
modifier|*
name|nbytes_read
parameter_list|)
block|{
name|ssize_t
name|len
decl_stmt|;
name|int
name|quit
decl_stmt|;
name|quit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|avail
operator|==
literal|0
condition|)
block|{
operator|*
name|nl
operator|=
literal|0
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|len
operator|=
name|get_line
argument_list|(
operator|*
name|b
argument_list|,
operator|*
name|avail
argument_list|,
name|nl
argument_list|)
expr_stmt|;
comment|/* 	 * Read bytes more while it does not reach the end of line. 	 */
while|while
condition|(
operator|*
name|nl
operator|==
literal|0
operator|&&
name|len
operator|==
operator|*
name|avail
operator|&&
operator|!
name|quit
operator|&&
operator|*
name|nbytes_read
operator|<
name|UUENCODE_BID_MAX_READ
condition|)
block|{
name|ssize_t
name|diff
init|=
operator|*
name|ravail
operator|-
operator|*
name|avail
decl_stmt|;
name|size_t
name|nbytes_req
init|=
operator|(
operator|*
name|ravail
operator|+
literal|1023
operator|)
operator|&
operator|~
literal|1023U
decl_stmt|;
name|ssize_t
name|tested
decl_stmt|;
comment|/* Increase reading bytes if it is not enough to at least 		 * new two lines. */
if|if
condition|(
name|nbytes_req
operator|<
operator|(
name|size_t
operator|)
operator|*
name|ravail
operator|+
literal|160
condition|)
name|nbytes_req
operator|<<=
literal|1
expr_stmt|;
operator|*
name|b
operator|=
name|__archive_read_filter_ahead
argument_list|(
name|filter
argument_list|,
name|nbytes_req
argument_list|,
name|avail
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|b
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|ravail
operator|>=
operator|*
name|avail
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Reading bytes reaches the end of a stream. */
operator|*
name|b
operator|=
name|__archive_read_filter_ahead
argument_list|(
name|filter
argument_list|,
operator|*
name|avail
argument_list|,
name|avail
argument_list|)
expr_stmt|;
name|quit
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|nbytes_read
operator|=
operator|*
name|avail
expr_stmt|;
operator|*
name|ravail
operator|=
operator|*
name|avail
expr_stmt|;
operator|*
name|b
operator|+=
name|diff
expr_stmt|;
operator|*
name|avail
operator|-=
name|diff
expr_stmt|;
name|tested
operator|=
name|len
expr_stmt|;
comment|/* Skip some bytes we already determinated. */
name|len
operator|=
name|get_line
argument_list|(
operator|*
name|b
operator|+
name|tested
argument_list|,
operator|*
name|avail
operator|-
name|tested
argument_list|,
name|nl
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
literal|0
condition|)
name|len
operator|+=
name|tested
expr_stmt|;
block|}
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|UUDECODE
parameter_list|(
name|c
parameter_list|)
value|(((c) - 0x20)& 0x3f)
end_define

begin_function
specifier|static
name|int
name|uudecode_bidder_bid
parameter_list|(
name|struct
name|archive_read_filter_bidder
modifier|*
name|self
parameter_list|,
name|struct
name|archive_read_filter
modifier|*
name|filter
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|b
decl_stmt|;
name|ssize_t
name|avail
decl_stmt|,
name|ravail
decl_stmt|;
name|ssize_t
name|len
decl_stmt|,
name|nl
decl_stmt|;
name|int
name|l
decl_stmt|;
name|int
name|firstline
decl_stmt|;
name|size_t
name|nbytes_read
decl_stmt|;
operator|(
name|void
operator|)
name|self
expr_stmt|;
comment|/* UNUSED */
name|b
operator|=
name|__archive_read_filter_ahead
argument_list|(
name|filter
argument_list|,
literal|1
argument_list|,
operator|&
name|avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|firstline
operator|=
literal|20
expr_stmt|;
name|ravail
operator|=
name|avail
expr_stmt|;
name|nbytes_read
operator|=
name|avail
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|len
operator|=
name|bid_get_line
argument_list|(
name|filter
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|avail
argument_list|,
operator|&
name|ravail
argument_list|,
operator|&
name|nl
argument_list|,
operator|&
name|nbytes_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|nl
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* No match found. */
if|if
condition|(
name|len
operator|-
name|nl
operator|>=
literal|11
operator|&&
name|memcmp
argument_list|(
name|b
argument_list|,
literal|"begin "
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|l
operator|=
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|-
name|nl
operator|>=
literal|18
operator|&&
name|memcmp
argument_list|(
name|b
argument_list|,
literal|"begin-base64 "
argument_list|,
literal|13
argument_list|)
operator|==
literal|0
condition|)
name|l
operator|=
literal|13
expr_stmt|;
else|else
name|l
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|l
operator|>
literal|0
operator|&&
operator|(
name|b
index|[
name|l
index|]
operator|<
literal|'0'
operator|||
name|b
index|[
name|l
index|]
operator|>
literal|'7'
operator|||
name|b
index|[
name|l
operator|+
literal|1
index|]
operator|<
literal|'0'
operator|||
name|b
index|[
name|l
operator|+
literal|1
index|]
operator|>
literal|'7'
operator|||
name|b
index|[
name|l
operator|+
literal|2
index|]
operator|<
literal|'0'
operator|||
name|b
index|[
name|l
operator|+
literal|2
index|]
operator|>
literal|'7'
operator|||
name|b
index|[
name|l
operator|+
literal|3
index|]
operator|!=
literal|' '
operator|)
condition|)
name|l
operator|=
literal|0
expr_stmt|;
name|b
operator|+=
name|len
expr_stmt|;
name|avail
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|l
condition|)
break|break;
name|firstline
operator|=
literal|0
expr_stmt|;
comment|/* Do not read more than UUENCODE_BID_MAX_READ bytes */
if|if
condition|(
name|nbytes_read
operator|>=
name|UUENCODE_BID_MAX_READ
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|avail
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|len
operator|=
name|bid_get_line
argument_list|(
name|filter
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|avail
argument_list|,
operator|&
name|ravail
argument_list|,
operator|&
name|nl
argument_list|,
operator|&
name|nbytes_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|nl
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* There are non-ascii characters. */
name|avail
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|6
condition|)
block|{
comment|/* "begin " */
if|if
condition|(
operator|!
name|uuchar
index|[
operator|*
name|b
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Get a length of decoded bytes. */
name|l
operator|=
name|UUDECODE
argument_list|(
operator|*
name|b
operator|++
argument_list|)
expr_stmt|;
name|len
operator|--
expr_stmt|;
if|if
condition|(
name|l
operator|>
literal|45
condition|)
comment|/* Normally, maximum length is 45(character 'M'). */
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
name|l
operator|&&
name|len
operator|-
name|nl
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|l
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|uuchar
index|[
operator|*
name|b
operator|++
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|uuchar
index|[
operator|*
name|b
operator|++
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|len
operator|-=
literal|2
expr_stmt|;
operator|--
name|l
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|uuchar
index|[
operator|*
name|b
operator|++
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|--
name|len
expr_stmt|;
operator|--
name|l
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|uuchar
index|[
operator|*
name|b
operator|++
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|--
name|len
expr_stmt|;
operator|--
name|l
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|-
name|nl
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|len
operator|-
name|nl
operator|==
literal|1
operator|&&
operator|(
name|uuchar
index|[
operator|*
name|b
index|]
operator|||
comment|/* Check sum. */
operator|(
operator|*
name|b
operator|>=
literal|'a'
operator|&&
operator|*
name|b
operator|<=
literal|'z'
operator|)
operator|)
condition|)
block|{
comment|/* Padding data(MINIX). */
operator|++
name|b
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
name|b
operator|+=
name|nl
expr_stmt|;
if|if
condition|(
name|avail
operator|&&
name|uuchar
index|[
operator|*
name|b
index|]
condition|)
return|return
operator|(
name|firstline
operator|+
literal|30
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|l
operator|==
literal|13
condition|)
block|{
comment|/* "begin-base64 " */
while|while
condition|(
name|len
operator|-
name|nl
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|base64
index|[
operator|*
name|b
operator|++
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|--
name|len
expr_stmt|;
block|}
name|b
operator|+=
name|nl
expr_stmt|;
if|if
condition|(
name|avail
operator|>=
literal|5
operator|&&
name|memcmp
argument_list|(
name|b
argument_list|,
literal|"====\n"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|firstline
operator|+
literal|40
operator|)
return|;
if|if
condition|(
name|avail
operator|>=
literal|6
operator|&&
name|memcmp
argument_list|(
name|b
argument_list|,
literal|"====\r\n"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|firstline
operator|+
literal|40
operator|)
return|;
if|if
condition|(
name|avail
operator|>
literal|0
operator|&&
name|base64
index|[
operator|*
name|b
index|]
condition|)
return|return
operator|(
name|firstline
operator|+
literal|30
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uudecode_bidder_init
parameter_list|(
name|struct
name|archive_read_filter
modifier|*
name|self
parameter_list|)
block|{
name|struct
name|uudecode
modifier|*
name|uudecode
decl_stmt|;
name|void
modifier|*
name|out_buff
decl_stmt|;
name|void
modifier|*
name|in_buff
decl_stmt|;
name|self
operator|->
name|code
operator|=
name|ARCHIVE_FILTER_UU
expr_stmt|;
name|self
operator|->
name|name
operator|=
literal|"uu"
expr_stmt|;
name|self
operator|->
name|read
operator|=
name|uudecode_filter_read
expr_stmt|;
name|self
operator|->
name|skip
operator|=
name|NULL
expr_stmt|;
comment|/* not supported */
name|self
operator|->
name|close
operator|=
name|uudecode_filter_close
expr_stmt|;
name|uudecode
operator|=
operator|(
expr|struct
name|uudecode
operator|*
operator|)
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|uudecode
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|out_buff
operator|=
name|malloc
argument_list|(
name|OUT_BUFF_SIZE
argument_list|)
expr_stmt|;
name|in_buff
operator|=
name|malloc
argument_list|(
name|IN_BUFF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|uudecode
operator|==
name|NULL
operator|||
name|out_buff
operator|==
name|NULL
operator|||
name|in_buff
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|self
operator|->
name|archive
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate data for uudecode"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|uudecode
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|out_buff
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|in_buff
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|self
operator|->
name|data
operator|=
name|uudecode
expr_stmt|;
name|uudecode
operator|->
name|in_buff
operator|=
name|in_buff
expr_stmt|;
name|uudecode
operator|->
name|in_cnt
operator|=
literal|0
expr_stmt|;
name|uudecode
operator|->
name|in_allocated
operator|=
name|IN_BUFF_SIZE
expr_stmt|;
name|uudecode
operator|->
name|out_buff
operator|=
name|out_buff
expr_stmt|;
name|uudecode
operator|->
name|state
operator|=
name|ST_FIND_HEAD
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ensure_in_buff_size
parameter_list|(
name|struct
name|archive_read_filter
modifier|*
name|self
parameter_list|,
name|struct
name|uudecode
modifier|*
name|uudecode
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|>
name|uudecode
operator|->
name|in_allocated
condition|)
block|{
name|unsigned
name|char
modifier|*
name|ptr
decl_stmt|;
name|size_t
name|newsize
decl_stmt|;
comment|/* 		 * Calculate a new buffer size for in_buff. 		 * Increase its value until it has enough size we need. 		 */
name|newsize
operator|=
name|uudecode
operator|->
name|in_allocated
expr_stmt|;
do|do
block|{
if|if
condition|(
name|newsize
operator|<
name|IN_BUFF_SIZE
operator|*
literal|32
condition|)
name|newsize
operator|<<=
literal|1
expr_stmt|;
else|else
name|newsize
operator|+=
name|IN_BUFF_SIZE
expr_stmt|;
block|}
do|while
condition|(
name|size
operator|>
name|newsize
condition|)
do|;
comment|/* Allocate the new buffer. */
name|ptr
operator|=
name|malloc
argument_list|(
name|newsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|self
operator|->
name|archive
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate data for uudecode"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Move the remaining data in in_buff into the new buffer. */
if|if
condition|(
name|uudecode
operator|->
name|in_cnt
condition|)
name|memmove
argument_list|(
name|ptr
argument_list|,
name|uudecode
operator|->
name|in_buff
argument_list|,
name|uudecode
operator|->
name|in_cnt
argument_list|)
expr_stmt|;
comment|/* Replace in_buff with the new buffer. */
name|free
argument_list|(
name|uudecode
operator|->
name|in_buff
argument_list|)
expr_stmt|;
name|uudecode
operator|->
name|in_buff
operator|=
name|ptr
expr_stmt|;
name|uudecode
operator|->
name|in_allocated
operator|=
name|newsize
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|uudecode_filter_read
parameter_list|(
name|struct
name|archive_read_filter
modifier|*
name|self
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|)
block|{
name|struct
name|uudecode
modifier|*
name|uudecode
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|b
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|unsigned
name|char
modifier|*
name|out
decl_stmt|;
name|ssize_t
name|avail_in
decl_stmt|,
name|ravail
decl_stmt|;
name|ssize_t
name|used
decl_stmt|;
name|ssize_t
name|total
decl_stmt|;
name|ssize_t
name|len
decl_stmt|,
name|llen
decl_stmt|,
name|nl
decl_stmt|;
name|uudecode
operator|=
operator|(
expr|struct
name|uudecode
operator|*
operator|)
name|self
operator|->
name|data
expr_stmt|;
name|read_more
label|:
name|d
operator|=
name|__archive_read_filter_ahead
argument_list|(
name|self
operator|->
name|upstream
argument_list|,
literal|1
argument_list|,
operator|&
name|avail_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
operator|&&
name|avail_in
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
comment|/* Quiet a code analyzer; make sure avail_in must be zero 	 * when d is NULL. */
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
name|avail_in
operator|=
literal|0
expr_stmt|;
name|used
operator|=
literal|0
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
name|out
operator|=
name|uudecode
operator|->
name|out_buff
expr_stmt|;
name|ravail
operator|=
name|avail_in
expr_stmt|;
if|if
condition|(
name|uudecode
operator|->
name|state
operator|==
name|ST_IGNORE
condition|)
block|{
name|used
operator|=
name|avail_in
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
if|if
condition|(
name|uudecode
operator|->
name|in_cnt
condition|)
block|{
comment|/* 		 * If there is remaining data which is saved by 		 * previous calling, use it first. 		 */
if|if
condition|(
name|ensure_in_buff_size
argument_list|(
name|self
argument_list|,
name|uudecode
argument_list|,
name|avail_in
operator|+
name|uudecode
operator|->
name|in_cnt
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|memcpy
argument_list|(
name|uudecode
operator|->
name|in_buff
operator|+
name|uudecode
operator|->
name|in_cnt
argument_list|,
name|d
argument_list|,
name|avail_in
argument_list|)
expr_stmt|;
name|d
operator|=
name|uudecode
operator|->
name|in_buff
expr_stmt|;
name|avail_in
operator|+=
name|uudecode
operator|->
name|in_cnt
expr_stmt|;
name|uudecode
operator|->
name|in_cnt
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
name|used
operator|<
name|avail_in
condition|;
name|d
operator|+=
name|llen
operator|,
name|used
operator|+=
name|llen
control|)
block|{
name|int64_t
name|l
decl_stmt|,
name|body
decl_stmt|;
name|b
operator|=
name|d
expr_stmt|;
name|len
operator|=
name|get_line
argument_list|(
name|b
argument_list|,
name|avail_in
operator|-
name|used
argument_list|,
operator|&
name|nl
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
comment|/* Non-ascii character is found. */
if|if
condition|(
name|uudecode
operator|->
name|state
operator|==
name|ST_FIND_HEAD
operator|&&
operator|(
name|uudecode
operator|->
name|total
operator|>
literal|0
operator|||
name|total
operator|>
literal|0
operator|)
condition|)
block|{
name|uudecode
operator|->
name|state
operator|=
name|ST_IGNORE
expr_stmt|;
name|used
operator|=
name|avail_in
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
name|archive_set_error
argument_list|(
operator|&
name|self
operator|->
name|archive
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Insufficient compressed data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|llen
operator|=
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|nl
operator|==
literal|0
operator|)
operator|&&
operator|(
name|uudecode
operator|->
name|state
operator|!=
name|ST_UUEND
operator|)
condition|)
block|{
if|if
condition|(
name|total
operator|==
literal|0
operator|&&
name|ravail
operator|<=
literal|0
condition|)
block|{
comment|/* There is nothing more to read, fail */
name|archive_set_error
argument_list|(
operator|&
name|self
operator|->
name|archive
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Missing format data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* 			 * Save remaining data which does not contain 			 * NL('\n','\r'). 			 */
if|if
condition|(
name|ensure_in_buff_size
argument_list|(
name|self
argument_list|,
name|uudecode
argument_list|,
name|len
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
if|if
condition|(
name|uudecode
operator|->
name|in_buff
operator|!=
name|b
condition|)
name|memmove
argument_list|(
name|uudecode
operator|->
name|in_buff
argument_list|,
name|b
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|uudecode
operator|->
name|in_cnt
operator|=
operator|(
name|int
operator|)
name|len
expr_stmt|;
if|if
condition|(
name|total
operator|==
literal|0
condition|)
block|{
comment|/* Do not return 0; it means end-of-file. 				 * We should try to read bytes more. */
name|__archive_read_filter_consume
argument_list|(
name|self
operator|->
name|upstream
argument_list|,
name|ravail
argument_list|)
expr_stmt|;
goto|goto
name|read_more
goto|;
block|}
name|used
operator|+=
name|len
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|uudecode
operator|->
name|state
condition|)
block|{
default|default:
case|case
name|ST_FIND_HEAD
case|:
comment|/* Do not read more than UUENCODE_BID_MAX_READ bytes */
if|if
condition|(
name|total
operator|+
name|len
operator|>=
name|UUENCODE_BID_MAX_READ
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|self
operator|->
name|archive
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid format data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|-
name|nl
operator|>=
literal|11
operator|&&
name|memcmp
argument_list|(
name|b
argument_list|,
literal|"begin "
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|l
operator|=
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|-
name|nl
operator|>=
literal|18
operator|&&
name|memcmp
argument_list|(
name|b
argument_list|,
literal|"begin-base64 "
argument_list|,
literal|13
argument_list|)
operator|==
literal|0
condition|)
name|l
operator|=
literal|13
expr_stmt|;
else|else
name|l
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|l
operator|!=
literal|0
operator|&&
name|b
index|[
name|l
index|]
operator|>=
literal|'0'
operator|&&
name|b
index|[
name|l
index|]
operator|<=
literal|'7'
operator|&&
name|b
index|[
name|l
operator|+
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|b
index|[
name|l
operator|+
literal|1
index|]
operator|<=
literal|'7'
operator|&&
name|b
index|[
name|l
operator|+
literal|2
index|]
operator|>=
literal|'0'
operator|&&
name|b
index|[
name|l
operator|+
literal|2
index|]
operator|<=
literal|'7'
operator|&&
name|b
index|[
name|l
operator|+
literal|3
index|]
operator|==
literal|' '
condition|)
block|{
if|if
condition|(
name|l
operator|==
literal|6
condition|)
name|uudecode
operator|->
name|state
operator|=
name|ST_READ_UU
expr_stmt|;
else|else
name|uudecode
operator|->
name|state
operator|=
name|ST_READ_BASE64
expr_stmt|;
block|}
break|break;
case|case
name|ST_READ_UU
case|:
if|if
condition|(
name|total
operator|+
name|len
operator|*
literal|2
operator|>
name|OUT_BUFF_SIZE
condition|)
goto|goto
name|finish
goto|;
name|body
operator|=
name|len
operator|-
name|nl
expr_stmt|;
if|if
condition|(
operator|!
name|uuchar
index|[
operator|*
name|b
index|]
operator|||
name|body
operator|<=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|self
operator|->
name|archive
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Insufficient compressed data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Get length of undecoded bytes of current line. */
name|l
operator|=
name|UUDECODE
argument_list|(
operator|*
name|b
operator|++
argument_list|)
expr_stmt|;
name|body
operator|--
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|body
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|self
operator|->
name|archive
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Insufficient compressed data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|l
operator|==
literal|0
condition|)
block|{
name|uudecode
operator|->
name|state
operator|=
name|ST_UUEND
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|l
operator|>
literal|0
condition|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|l
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|uuchar
index|[
name|b
index|[
literal|0
index|]
index|]
operator|||
operator|!
name|uuchar
index|[
name|b
index|[
literal|1
index|]
index|]
condition|)
break|break;
name|n
operator|=
name|UUDECODE
argument_list|(
operator|*
name|b
operator|++
argument_list|)
operator|<<
literal|18
expr_stmt|;
name|n
operator||=
name|UUDECODE
argument_list|(
operator|*
name|b
operator|++
argument_list|)
operator|<<
literal|12
expr_stmt|;
operator|*
name|out
operator|++
operator|=
name|n
operator|>>
literal|16
expr_stmt|;
name|total
operator|++
expr_stmt|;
operator|--
name|l
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|uuchar
index|[
name|b
index|[
literal|0
index|]
index|]
condition|)
break|break;
name|n
operator||=
name|UUDECODE
argument_list|(
operator|*
name|b
operator|++
argument_list|)
operator|<<
literal|6
expr_stmt|;
operator|*
name|out
operator|++
operator|=
operator|(
name|n
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|total
operator|++
expr_stmt|;
operator|--
name|l
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|uuchar
index|[
name|b
index|[
literal|0
index|]
index|]
condition|)
break|break;
name|n
operator||=
name|UUDECODE
argument_list|(
operator|*
name|b
operator|++
argument_list|)
expr_stmt|;
operator|*
name|out
operator|++
operator|=
name|n
operator|&
literal|0xFF
expr_stmt|;
name|total
operator|++
expr_stmt|;
operator|--
name|l
expr_stmt|;
block|}
block|}
if|if
condition|(
name|l
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|self
operator|->
name|archive
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Insufficient compressed data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
break|break;
case|case
name|ST_UUEND
case|:
if|if
condition|(
name|len
operator|-
name|nl
operator|==
literal|3
operator|&&
name|memcmp
argument_list|(
name|b
argument_list|,
literal|"end "
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|uudecode
operator|->
name|state
operator|=
name|ST_FIND_HEAD
expr_stmt|;
else|else
block|{
name|archive_set_error
argument_list|(
operator|&
name|self
operator|->
name|archive
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Insufficient compressed data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
break|break;
case|case
name|ST_READ_BASE64
case|:
if|if
condition|(
name|total
operator|+
name|len
operator|*
literal|2
operator|>
name|OUT_BUFF_SIZE
condition|)
goto|goto
name|finish
goto|;
name|l
operator|=
name|len
operator|-
name|nl
expr_stmt|;
if|if
condition|(
name|l
operator|>=
literal|3
operator|&&
name|b
index|[
literal|0
index|]
operator|==
literal|'='
operator|&&
name|b
index|[
literal|1
index|]
operator|==
literal|'='
operator|&&
name|b
index|[
literal|2
index|]
operator|==
literal|'='
condition|)
block|{
name|uudecode
operator|->
name|state
operator|=
name|ST_FIND_HEAD
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|l
operator|>
literal|0
condition|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|l
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|base64
index|[
name|b
index|[
literal|0
index|]
index|]
operator|||
operator|!
name|base64
index|[
name|b
index|[
literal|1
index|]
index|]
condition|)
break|break;
name|n
operator|=
name|base64num
index|[
operator|*
name|b
operator|++
index|]
operator|<<
literal|18
expr_stmt|;
name|n
operator||=
name|base64num
index|[
operator|*
name|b
operator|++
index|]
operator|<<
literal|12
expr_stmt|;
operator|*
name|out
operator|++
operator|=
name|n
operator|>>
literal|16
expr_stmt|;
name|total
operator|++
expr_stmt|;
name|l
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|b
operator|==
literal|'='
condition|)
break|break;
if|if
condition|(
operator|!
name|base64
index|[
operator|*
name|b
index|]
condition|)
break|break;
name|n
operator||=
name|base64num
index|[
operator|*
name|b
operator|++
index|]
operator|<<
literal|6
expr_stmt|;
operator|*
name|out
operator|++
operator|=
operator|(
name|n
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|total
operator|++
expr_stmt|;
operator|--
name|l
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|b
operator|==
literal|'='
condition|)
break|break;
if|if
condition|(
operator|!
name|base64
index|[
operator|*
name|b
index|]
condition|)
break|break;
name|n
operator||=
name|base64num
index|[
operator|*
name|b
operator|++
index|]
expr_stmt|;
operator|*
name|out
operator|++
operator|=
name|n
operator|&
literal|0xFF
expr_stmt|;
name|total
operator|++
expr_stmt|;
operator|--
name|l
expr_stmt|;
block|}
block|}
if|if
condition|(
name|l
operator|&&
operator|*
name|b
operator|!=
literal|'='
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|self
operator|->
name|archive
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Insufficient compressed data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
break|break;
block|}
block|}
name|finish
label|:
if|if
condition|(
name|ravail
operator|<
name|avail_in
condition|)
name|used
operator|-=
name|avail_in
operator|-
name|ravail
expr_stmt|;
name|__archive_read_filter_consume
argument_list|(
name|self
operator|->
name|upstream
argument_list|,
name|used
argument_list|)
expr_stmt|;
operator|*
name|buff
operator|=
name|uudecode
operator|->
name|out_buff
expr_stmt|;
name|uudecode
operator|->
name|total
operator|+=
name|total
expr_stmt|;
return|return
operator|(
name|total
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uudecode_filter_close
parameter_list|(
name|struct
name|archive_read_filter
modifier|*
name|self
parameter_list|)
block|{
name|struct
name|uudecode
modifier|*
name|uudecode
decl_stmt|;
name|uudecode
operator|=
operator|(
expr|struct
name|uudecode
operator|*
operator|)
name|self
operator|->
name|data
expr_stmt|;
name|free
argument_list|(
name|uudecode
operator|->
name|in_buff
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|uudecode
operator|->
name|out_buff
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|uudecode
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

end_unit

