begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2016 Christos Zoulas  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * DER (Distinguished Encoding Rules) Parser  *  * Sources:  * https://en.wikipedia.org/wiki/X.690  * http://fm4dd.com/openssl/certexamples.htm  * http://blog.engelke.com/2014/10/17/parsing-ber-and-der-encoded-asn-1-objects/  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TEST_DER
end_ifndef

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_macro
name|FILE_RCSID
argument_list|(
literal|"@(#)$File: der.c,v 1.12 2017/02/10 18:14:01 christos Exp $"
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|TEST_DER
end_ifndef

begin_include
include|#
directive|include
file|"magic.h"
end_include

begin_include
include|#
directive|include
file|"der.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DER_BAD
value|((uint32_t)-1)
end_define

begin_define
define|#
directive|define
name|DER_CLASS_UNIVERSAL
value|0
end_define

begin_define
define|#
directive|define
name|DER_CLASS_APPLICATION
value|1
end_define

begin_define
define|#
directive|define
name|DER_CLASS_CONTEXT
value|2
end_define

begin_define
define|#
directive|define
name|DER_CLASS_PRIVATE
value|3
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_DER
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|der_class
index|[]
init|=
literal|"UACP"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DER_TYPE_PRIMITIVE
value|0
end_define

begin_define
define|#
directive|define
name|DER_TYPE_CONSTRUCTED
value|1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_DER
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|der_type
index|[]
init|=
literal|"PC"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DER_TAG_EOC
value|0x00
end_define

begin_define
define|#
directive|define
name|DER_TAG_BOOLEAN
value|0x01
end_define

begin_define
define|#
directive|define
name|DER_TAG_INTEGER
value|0x02
end_define

begin_define
define|#
directive|define
name|DER_TAG_BIT
value|STRING		0x03
end_define

begin_define
define|#
directive|define
name|DER_TAG_OCTET_STRING
value|0x04
end_define

begin_define
define|#
directive|define
name|DER_TAG_NULL
value|0x05
end_define

begin_define
define|#
directive|define
name|DER_TAG_OBJECT_IDENTIFIER
value|0x06
end_define

begin_define
define|#
directive|define
name|DER_TAG_OBJECT_DESCRIPTOR
value|0x07
end_define

begin_define
define|#
directive|define
name|DER_TAG_EXTERNAL
value|0x08
end_define

begin_define
define|#
directive|define
name|DER_TAG_REAL
value|0x09
end_define

begin_define
define|#
directive|define
name|DER_TAG_ENUMERATED
value|0x0a
end_define

begin_define
define|#
directive|define
name|DER_TAG_EMBEDDED_PDV
value|0x0b
end_define

begin_define
define|#
directive|define
name|DER_TAG_UTF8_STRING
value|0x0c
end_define

begin_define
define|#
directive|define
name|DER_TAG_RELATIVE_OID
value|0x0d
end_define

begin_define
define|#
directive|define
name|DER_TAG_RESERVED_1
value|0x0e
end_define

begin_define
define|#
directive|define
name|DER_TAG_RESERVED_2
value|0x0f
end_define

begin_define
define|#
directive|define
name|DER_TAG_SEQUENCE
value|0x10
end_define

begin_define
define|#
directive|define
name|DER_TAG_SET
value|0x11
end_define

begin_define
define|#
directive|define
name|DER_TAG_NUMERIC_STRING
value|0x12
end_define

begin_define
define|#
directive|define
name|DER_TAG_PRINTABLE_STRING
value|0x13
end_define

begin_define
define|#
directive|define
name|DER_TAG_T61_STRING
value|0x14
end_define

begin_define
define|#
directive|define
name|DER_TAG_VIDEOTEX_STRING
value|0x15
end_define

begin_define
define|#
directive|define
name|DER_TAG_IA5_STRING
value|0x16
end_define

begin_define
define|#
directive|define
name|DER_TAG_UTCTIME
value|0x17
end_define

begin_define
define|#
directive|define
name|DER_TAG_GENERALIZED_TIME
value|0x18
end_define

begin_define
define|#
directive|define
name|DER_TAG_GRAPHIC_STRING
value|0x19
end_define

begin_define
define|#
directive|define
name|DER_TAG_VISIBLE_STRING
value|0x1a
end_define

begin_define
define|#
directive|define
name|DER_TAG_GENERAL_STRING
value|0x1b
end_define

begin_define
define|#
directive|define
name|DER_TAG_UNIVERSAL_STRING
value|0x1c
end_define

begin_define
define|#
directive|define
name|DER_TAG_CHARACTER_STRING
value|0x1d
end_define

begin_define
define|#
directive|define
name|DER_TAG_BMP_STRING
value|0x1e
end_define

begin_define
define|#
directive|define
name|DER_TAG_LONG
value|0x1f
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|der__tag
index|[]
init|=
block|{
literal|"eoc"
block|,
literal|"bool"
block|,
literal|"int"
block|,
literal|"bit_str"
block|,
literal|"octet_str"
block|,
literal|"null"
block|,
literal|"obj_id"
block|,
literal|"obj_desc"
block|,
literal|"ext"
block|,
literal|"real"
block|,
literal|"enum"
block|,
literal|"embed"
block|,
literal|"utf8_str"
block|,
literal|"oid"
block|,
literal|"res1"
block|,
literal|"res2"
block|,
literal|"seq"
block|,
literal|"set"
block|,
literal|"num_str"
block|,
literal|"prt_str"
block|,
literal|"t61_str"
block|,
literal|"vid_str"
block|,
literal|"ia5_str"
block|,
literal|"utc_time"
block|,
literal|"gen_time"
block|,
literal|"gr_str"
block|,
literal|"vis_str"
block|,
literal|"gen_str"
block|,
literal|"char_str"
block|,
literal|"bmp_str"
block|,
literal|"long"
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_DER
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|a
parameter_list|)
value|printf a
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|a
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TEST_DER
end_ifdef

begin_function
specifier|static
name|uint8_t
name|getclass
parameter_list|(
name|uint8_t
name|c
parameter_list|)
block|{
return|return
name|c
operator|>>
literal|6
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|gettype
parameter_list|(
name|uint8_t
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|>>
literal|5
operator|)
operator|&
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|uint32_t
name|gettag
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|c
parameter_list|,
name|size_t
modifier|*
name|p
parameter_list|,
name|size_t
name|l
parameter_list|)
block|{
name|uint32_t
name|tag
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|>=
name|l
condition|)
return|return
name|DER_BAD
return|;
name|tag
operator|=
name|c
index|[
operator|(
operator|*
name|p
operator|)
operator|++
index|]
operator|&
literal|0x1f
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
literal|0x1f
condition|)
return|return
name|tag
return|;
if|if
condition|(
operator|*
name|p
operator|>=
name|l
condition|)
return|return
name|DER_BAD
return|;
while|while
condition|(
name|c
index|[
operator|*
name|p
index|]
operator|>=
literal|0x80
condition|)
block|{
name|tag
operator|=
name|tag
operator|*
literal|128
operator|+
name|c
index|[
operator|(
operator|*
name|p
operator|)
operator|++
index|]
operator|-
literal|0x80
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|>=
name|l
condition|)
return|return
name|DER_BAD
return|;
block|}
return|return
name|tag
return|;
block|}
end_function

begin_comment
comment|/*  * Read the length of a DER tag from the input.  *  * `c` is the input, `p` is an output parameter that specifies how much of the  * input we consumed, and `l` is the maximum input length.  *  * Returns the length, or DER_BAD if the end of the input is reached or the  * length exceeds the remaining input.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|getlength
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|c
parameter_list|,
name|size_t
modifier|*
name|p
parameter_list|,
name|size_t
name|l
parameter_list|)
block|{
name|uint8_t
name|digits
decl_stmt|,
name|i
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|is_onebyte_result
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|>=
name|l
condition|)
return|return
name|DER_BAD
return|;
comment|/* 	 * Digits can either be 0b0 followed by the result, or 0b1 	 * followed by the number of digits of the result. In either case, 	 * we verify that we can read so many bytes from the input. 	 */
name|is_onebyte_result
operator|=
operator|(
name|c
index|[
operator|*
name|p
index|]
operator|&
literal|0x80
operator|)
operator|==
literal|0
expr_stmt|;
name|digits
operator|=
name|c
index|[
operator|(
operator|*
name|p
operator|)
operator|++
index|]
operator|&
literal|0x7f
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|+
name|digits
operator|>=
name|l
condition|)
return|return
name|DER_BAD
return|;
if|if
condition|(
name|is_onebyte_result
condition|)
return|return
name|digits
return|;
comment|/* 	 * Decode len. We've already verified that we're allowed to read 	 * `digits` bytes. 	 */
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|digits
condition|;
name|i
operator|++
control|)
name|len
operator|=
operator|(
name|len
operator|<<
literal|8
operator|)
operator||
name|c
index|[
operator|(
operator|*
name|p
operator|)
operator|++
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|+
name|len
operator|>=
name|l
condition|)
return|return
name|DER_BAD
return|;
return|return
name|CAST
argument_list|(
name|uint32_t
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|der_tag
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|uint32_t
name|tag
parameter_list|)
block|{
if|if
condition|(
name|tag
operator|<
name|DER_TAG_LONG
condition|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|der__tag
index|[
name|tag
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%#x"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|TEST_DER
end_ifndef

begin_function
specifier|static
name|int
name|der_data
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|blen
parameter_list|,
name|uint32_t
name|tag
parameter_list|,
specifier|const
name|void
modifier|*
name|q
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
specifier|const
name|uint8_t
modifier|*
name|d
init|=
name|CAST
argument_list|(
specifier|const
name|uint8_t
operator|*
argument_list|,
name|q
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|DER_TAG_PRINTABLE_STRING
case|:
case|case
name|DER_TAG_UTF8_STRING
case|:
case|case
name|DER_TAG_IA5_STRING
case|:
case|case
name|DER_TAG_UTCTIME
case|:
return|return
name|snprintf
argument_list|(
name|buf
argument_list|,
name|blen
argument_list|,
literal|"%.*s"
argument_list|,
name|len
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|q
argument_list|)
return|;
default|default:
break|break;
block|}
for|for
control|(
name|uint32_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|uint32_t
name|z
init|=
name|i
operator|<<
literal|1
decl_stmt|;
if|if
condition|(
name|z
operator|<
name|blen
operator|-
literal|2
condition|)
name|snprintf
argument_list|(
name|buf
operator|+
name|z
argument_list|,
name|blen
operator|-
name|z
argument_list|,
literal|"%.2x"
argument_list|,
name|d
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|len
operator|*
literal|2
return|;
block|}
end_function

begin_function
name|int32_t
name|der_offs
parameter_list|(
name|struct
name|magic_set
modifier|*
name|ms
parameter_list|,
name|struct
name|magic
modifier|*
name|m
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
block|{
specifier|const
name|uint8_t
modifier|*
name|b
init|=
name|RCAST
argument_list|(
specifier|const
name|uint8_t
operator|*
argument_list|,
name|ms
operator|->
name|search
operator|.
name|s
argument_list|)
decl_stmt|;
name|size_t
name|offs
init|=
literal|0
decl_stmt|,
name|len
init|=
name|ms
operator|->
name|search
operator|.
name|s_len
condition|?
name|ms
operator|->
name|search
operator|.
name|s_len
else|:
name|nbytes
decl_stmt|;
if|if
condition|(
name|gettag
argument_list|(
name|b
argument_list|,
operator|&
name|offs
argument_list|,
name|len
argument_list|)
operator|==
name|DER_BAD
condition|)
return|return
operator|-
literal|1
return|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s1: %d %zu %u\n"
operator|,
name|__func__
operator|,
name|ms
operator|->
name|offset
operator|,
name|offs
operator|,
name|m
operator|->
name|offset
operator|)
argument_list|)
expr_stmt|;
name|uint32_t
name|tlen
init|=
name|getlength
argument_list|(
name|b
argument_list|,
operator|&
name|offs
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|tlen
operator|==
name|DER_BAD
condition|)
return|return
operator|-
literal|1
return|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s2: %d %zu %u\n"
operator|,
name|__func__
operator|,
name|ms
operator|->
name|offset
operator|,
name|offs
operator|,
name|tlen
operator|)
argument_list|)
expr_stmt|;
name|offs
operator|+=
name|ms
operator|->
name|offset
operator|+
name|m
operator|->
name|offset
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"cont_level = %d\n"
operator|,
name|m
operator|->
name|cont_level
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_DER
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m
operator|->
name|cont_level
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"cont_level[%zu] = %u\n"
argument_list|,
name|i
argument_list|,
name|ms
operator|->
name|c
operator|.
name|li
index|[
name|i
index|]
operator|.
name|off
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|m
operator|->
name|cont_level
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|offs
operator|+
name|tlen
operator|>
name|nbytes
condition|)
return|return
operator|-
literal|1
return|;
name|ms
operator|->
name|c
operator|.
name|li
index|[
name|m
operator|->
name|cont_level
operator|-
literal|1
index|]
operator|.
name|off
operator|=
name|CAST
argument_list|(
name|int
argument_list|,
name|offs
operator|+
name|tlen
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"cont_level[%u] = %u\n"
operator|,
name|m
operator|->
name|cont_level
operator|-
literal|1
operator|,
name|ms
operator|->
name|c
operator|.
name|li
index|[
name|m
operator|->
name|cont_level
operator|-
literal|1
index|]
operator|.
name|off
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|CAST
argument_list|(
name|int32_t
argument_list|,
name|offs
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|der_cmp
parameter_list|(
name|struct
name|magic_set
modifier|*
name|ms
parameter_list|,
name|struct
name|magic
modifier|*
name|m
parameter_list|)
block|{
specifier|const
name|uint8_t
modifier|*
name|b
init|=
name|RCAST
argument_list|(
specifier|const
name|uint8_t
operator|*
argument_list|,
name|ms
operator|->
name|search
operator|.
name|s
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
init|=
name|m
operator|->
name|value
operator|.
name|s
decl_stmt|;
name|size_t
name|offs
init|=
literal|0
decl_stmt|,
name|len
init|=
name|ms
operator|->
name|search
operator|.
name|s_len
decl_stmt|;
name|uint32_t
name|tag
decl_stmt|,
name|tlen
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|tag
operator|=
name|gettag
argument_list|(
name|b
argument_list|,
operator|&
name|offs
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|DER_BAD
condition|)
return|return
operator|-
literal|1
return|;
name|tlen
operator|=
name|getlength
argument_list|(
name|b
argument_list|,
operator|&
name|offs
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlen
operator|==
name|DER_BAD
condition|)
return|return
operator|-
literal|1
return|;
name|der_tag
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ms
operator|->
name|flags
operator|&
name|MAGIC_DEBUG
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: tag %p got=%s exp=%s\n"
argument_list|,
name|__func__
argument_list|,
name|b
argument_list|,
name|buf
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|size_t
name|slen
init|=
name|strlen
argument_list|(
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
name|s
argument_list|,
name|slen
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|s
operator|+=
name|slen
expr_stmt|;
name|again
label|:
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'\0'
case|:
return|return
literal|1
return|;
case|case
literal|'='
case|:
name|s
operator|++
expr_stmt|;
goto|goto
name|val
goto|;
default|default:
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|)
return|return
literal|0
return|;
name|slen
operator|=
literal|0
expr_stmt|;
do|do
name|slen
operator|=
name|slen
operator|*
literal|10
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
do|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|++
name|s
argument_list|)
condition|)
do|;
if|if
condition|(
operator|(
name|ms
operator|->
name|flags
operator|&
name|MAGIC_DEBUG
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: len %zu %u\n"
argument_list|,
name|__func__
argument_list|,
name|slen
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlen
operator|!=
name|slen
condition|)
return|return
literal|0
return|;
goto|goto
name|again
goto|;
block|}
name|val
label|:
name|DPRINTF
argument_list|(
operator|(
literal|"%s: before data %zu %u\n"
operator|,
name|__func__
operator|,
name|offs
operator|,
name|tlen
operator|)
argument_list|)
expr_stmt|;
name|der_data
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|tag
argument_list|,
name|b
operator|+
name|offs
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ms
operator|->
name|flags
operator|&
name|MAGIC_DEBUG
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: data %s %s\n"
argument_list|,
name|__func__
argument_list|,
name|buf
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
name|s
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
literal|"x"
argument_list|,
name|s
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|strlcpy
argument_list|(
name|ms
operator|->
name|ms_value
operator|.
name|s
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|ms
operator|->
name|ms_value
operator|.
name|s
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TEST_DER
end_ifdef

begin_function
specifier|static
name|void
name|printtag
parameter_list|(
name|uint32_t
name|tag
parameter_list|,
specifier|const
name|void
modifier|*
name|q
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
specifier|const
name|uint8_t
modifier|*
name|d
init|=
name|q
decl_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|DER_TAG_PRINTABLE_STRING
case|:
case|case
name|DER_TAG_UTF8_STRING
case|:
name|printf
argument_list|(
literal|"%.*s\n"
argument_list|,
name|len
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|q
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
for|for
control|(
name|uint32_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%.2x"
argument_list|,
name|d
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|printdata
parameter_list|(
name|size_t
name|level
parameter_list|,
specifier|const
name|void
modifier|*
name|v
parameter_list|,
name|size_t
name|x
parameter_list|,
name|size_t
name|l
parameter_list|)
block|{
specifier|const
name|uint8_t
modifier|*
name|p
init|=
name|v
decl_stmt|,
modifier|*
name|ep
init|=
name|p
operator|+
name|l
decl_stmt|;
name|size_t
name|ox
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
while|while
condition|(
name|p
operator|+
name|x
operator|<
name|ep
condition|)
block|{
specifier|const
name|uint8_t
modifier|*
name|q
decl_stmt|;
name|uint8_t
name|c
init|=
name|getclass
argument_list|(
name|p
index|[
name|x
index|]
argument_list|)
decl_stmt|;
name|uint8_t
name|t
init|=
name|gettype
argument_list|(
name|p
index|[
name|x
index|]
argument_list|)
decl_stmt|;
name|ox
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%.2x %.2x %.2x\n"
argument_list|,
name|p
index|[
name|x
operator|-
literal|1
index|]
argument_list|,
name|p
index|[
name|x
index|]
argument_list|,
name|p
index|[
name|x
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|uint32_t
name|tag
init|=
name|gettag
argument_list|(
name|p
argument_list|,
operator|&
name|x
argument_list|,
name|ep
operator|-
name|p
operator|+
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|+
name|x
operator|>=
name|ep
condition|)
break|break;
name|uint32_t
name|len
init|=
name|getlength
argument_list|(
name|p
argument_list|,
operator|&
name|x
argument_list|,
name|ep
operator|-
name|p
operator|+
name|x
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"%zu %zu-%zu %c,%c,%s,%u:"
argument_list|,
name|level
argument_list|,
name|ox
argument_list|,
name|x
argument_list|,
name|der_class
index|[
name|c
index|]
argument_list|,
name|der_type
index|[
name|t
index|]
argument_list|,
name|der_tag
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|tag
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|+
name|x
expr_stmt|;
if|if
condition|(
name|p
operator|+
name|len
operator|>
name|ep
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"corrupt der"
argument_list|)
expr_stmt|;
name|printtag
argument_list|(
name|tag
argument_list|,
name|q
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|DER_TYPE_PRIMITIVE
condition|)
name|printdata
argument_list|(
name|level
operator|+
literal|1
argument_list|,
name|p
argument_list|,
name|x
argument_list|,
name|len
operator|+
name|x
argument_list|)
expr_stmt|;
name|x
operator|+=
name|len
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|size_t
name|l
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"open `%s'"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"stat `%s'"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|l
operator|=
operator|(
name|size_t
operator|)
name|st
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|l
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_FILE
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|MAP_FAILED
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"mmap `%s'"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|printdata
argument_list|(
literal|0
argument_list|,
name|p
argument_list|,
literal|0
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|munmap
argument_list|(
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

