begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) Ian F. Darwin 1986-1995.  * Software written by Ian F. Darwin and others;  * maintained 1995-present by Christos Zoulas and others.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, without modification,  *    this list of conditions, and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *    * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*###########################################################################   #                                                                           #   #                                vasprintf                                  #   #                                                                           #   #               Copyright (c) 2002-2005 David TAILLANDIER                   #   #                                                                           #   ###########################################################################*/
end_comment

begin_comment
comment|/*  This software is distributed under the "modified BSD licence".  This software is also released with GNU license (GPL) in another file (same source-code, only license differ).    Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. The name of the author may not be used to endorse or promote products derived from this software without specific prior written permission.   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ====================  Hacked from xnprintf version of 26th February 2005 to provide only vasprintf by Reuben Thomas<rrt@sc3d.org>.  ====================   'printf' function family use the following format string:  %[flag][width][.prec][modifier]type  %% is the escape sequence to print a '%' %  followed by an unknown format will print the characters without trying to do any interpretation  flag:   none   +     -     #     (blank) width:  n    0n    * prec:   none   .0    .n     .* modifier:    F N L h l ll z t    ('F' and 'N' are ms-dos/16-bit specific) type:  d i o u x X f e g E G c s p n   The function needs to allocate memory to store the full text before to actually writting it.  i.e if you want to fnprintf() 1000 characters, the functions will allocate 1000 bytes. This behaviour can be modified: you have to customise the code to flush the internal buffer (writing to screen or file) when it reach a given size. Then the buffer can have a shorter length. But what? If you really need to write HUGE string, don't use printf! During the process, some other memory is allocated (1024 bytes minimum) to handle the output of partial sprintf() calls. If you have only 10000 bytes free in memory, you *may* not be able to nprintf() a 8000 bytes-long text.  note: if a buffer overflow occurs, exit() is called. This situation should never appear ... but if you want to be *really* sure, you have to modify the code to handle those situations (only one place to modify). A buffer overflow can only occur if your sprintf() do strange things or when you use strange formats.  */
end_comment

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_macro
name|FILE_RCSID
argument_list|(
literal|"@(#)$File: vasprintf.c,v 1.12 2014/05/14 23:09:21 christos Exp $"
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* lint */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIMITS_H
end_ifdef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDDEF_H
end_ifdef

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ALLOC_CHUNK
value|2048
end_define

begin_define
define|#
directive|define
name|ALLOC_SECURITY_MARGIN
value|1024
end_define

begin_comment
comment|/* big value because some platforms have very big 'G' exponent */
end_comment

begin_if
if|#
directive|if
name|ALLOC_CHUNK
operator|<
name|ALLOC_SECURITY_MARGIN
end_if

begin_error
error|#
directive|error
error|!!! ALLOC_CHUNK< ALLOC_SECURITY_MARGIN !!!
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* note: to have some interest, ALLOC_CHUNK should be much greater than ALLOC_SECURITY_MARGIN */
end_comment

begin_comment
comment|/*  *  To save a lot of push/pop, every variable are stored into this  *  structure, which is passed among nearly every sub-functions.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|src_string
decl_stmt|;
comment|/* current position into intput string */
name|char
modifier|*
name|buffer_base
decl_stmt|;
comment|/* output buffer */
name|char
modifier|*
name|dest_string
decl_stmt|;
comment|/* current position into output string */
name|size_t
name|buffer_len
decl_stmt|;
comment|/* length of output buffer */
name|size_t
name|real_len
decl_stmt|;
comment|/* real current length of output text */
name|size_t
name|pseudo_len
decl_stmt|;
comment|/* total length of output text if it were not limited in size */
name|size_t
name|maxlen
decl_stmt|;
name|va_list
name|vargs
decl_stmt|;
comment|/* pointer to current position into vargs */
name|char
modifier|*
name|sprintf_string
decl_stmt|;
name|FILE
modifier|*
name|fprintf_file
decl_stmt|;
block|}
name|xprintf_struct
typedef|;
end_typedef

begin_comment
comment|/*  *  Realloc buffer if needed  *  Return value:  0 = ok  *               EOF = not enought memory  */
end_comment

begin_function
specifier|static
name|int
name|realloc_buff
parameter_list|(
name|xprintf_struct
modifier|*
name|s
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|len
operator|+
name|ALLOC_SECURITY_MARGIN
operator|+
name|s
operator|->
name|real_len
operator|>
name|s
operator|->
name|buffer_len
condition|)
block|{
name|len
operator|+=
name|s
operator|->
name|real_len
operator|+
name|ALLOC_CHUNK
expr_stmt|;
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|s
operator|->
name|buffer_base
operator|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
name|s
operator|->
name|buffer_base
operator|=
name|NULL
expr_stmt|;
return|return
name|EOF
return|;
block|}
name|s
operator|->
name|dest_string
operator|=
name|ptr
operator|+
call|(
name|size_t
call|)
argument_list|(
name|s
operator|->
name|dest_string
operator|-
name|s
operator|->
name|buffer_base
argument_list|)
expr_stmt|;
name|s
operator|->
name|buffer_base
operator|=
name|ptr
expr_stmt|;
name|s
operator|->
name|buffer_len
operator|=
name|len
expr_stmt|;
operator|(
name|s
operator|->
name|buffer_base
operator|)
index|[
name|s
operator|->
name|buffer_len
operator|-
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* overflow marker */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *  Prints 'usual' characters    up to next '%'  *                            or up to end of text  */
end_comment

begin_function
specifier|static
name|int
name|usual_char
parameter_list|(
name|xprintf_struct
modifier|*
name|s
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|strcspn
argument_list|(
name|s
operator|->
name|src_string
argument_list|,
literal|"%"
argument_list|)
expr_stmt|;
comment|/* reachs the next '%' or end of input string */
comment|/* note: 'len' is never 0 because the presence of '%' */
comment|/* or end-of-line is checked in the calling function  */
if|if
condition|(
name|realloc_buff
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
name|memcpy
argument_list|(
name|s
operator|->
name|dest_string
argument_list|,
name|s
operator|->
name|src_string
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
operator|->
name|src_string
operator|+=
name|len
expr_stmt|;
name|s
operator|->
name|dest_string
operator|+=
name|len
expr_stmt|;
name|s
operator|->
name|real_len
operator|+=
name|len
expr_stmt|;
name|s
operator|->
name|pseudo_len
operator|+=
name|len
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *  Return value: 0 = ok  *                EOF = error  */
end_comment

begin_function
specifier|static
name|int
name|print_it
parameter_list|(
name|xprintf_struct
modifier|*
name|s
parameter_list|,
name|size_t
name|approx_len
parameter_list|,
specifier|const
name|char
modifier|*
name|format_string
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|varg
decl_stmt|;
name|int
name|vsprintf_len
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|realloc_buff
argument_list|(
name|s
argument_list|,
name|approx_len
argument_list|)
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
name|va_start
argument_list|(
name|varg
argument_list|,
name|format_string
argument_list|)
expr_stmt|;
name|vsprintf_len
operator|=
name|vsprintf
argument_list|(
name|s
operator|->
name|dest_string
argument_list|,
name|format_string
argument_list|,
name|varg
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|varg
argument_list|)
expr_stmt|;
comment|/* Check for overflow */
name|assert
argument_list|(
operator|(
name|s
operator|->
name|buffer_base
operator|)
index|[
name|s
operator|->
name|buffer_len
operator|-
literal|1
index|]
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsprintf_len
operator|==
name|EOF
condition|)
comment|/* must be done *after* overflow-check */
return|return
name|EOF
return|;
name|s
operator|->
name|pseudo_len
operator|+=
name|vsprintf_len
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|s
operator|->
name|dest_string
argument_list|)
expr_stmt|;
name|s
operator|->
name|real_len
operator|+=
name|len
expr_stmt|;
name|s
operator|->
name|dest_string
operator|+=
name|len
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *  Prints a string (%s)  *  We need special handling because:  *     a: the length of the string is unknown  *     b: when .prec is used, we must not access any extra byte of the  *        string (of course, if the original sprintf() does... what the  *        hell, not my problem)  *  *  Return value: 0 = ok  *                EOF = error  */
end_comment

begin_function
specifier|static
name|int
name|type_s
parameter_list|(
name|xprintf_struct
modifier|*
name|s
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|prec
parameter_list|,
specifier|const
name|char
modifier|*
name|format_string
parameter_list|,
specifier|const
name|char
modifier|*
name|arg_string
parameter_list|)
block|{
name|size_t
name|string_len
decl_stmt|;
if|if
condition|(
name|arg_string
operator|==
name|NULL
condition|)
return|return
name|print_it
argument_list|(
name|s
argument_list|,
operator|(
name|size_t
operator|)
literal|6
argument_list|,
literal|"(null)"
argument_list|,
literal|0
argument_list|)
return|;
comment|/* hand-made strlen() whitch stops when 'prec' is reached. */
comment|/* if 'prec' is -1 then it is never reached. */
name|string_len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|arg_string
index|[
name|string_len
index|]
operator|!=
literal|0
operator|&&
operator|(
name|size_t
operator|)
name|prec
operator|!=
name|string_len
condition|)
name|string_len
operator|++
expr_stmt|;
if|if
condition|(
name|width
operator|!=
operator|-
literal|1
operator|&&
name|string_len
operator|<
operator|(
name|size_t
operator|)
name|width
condition|)
name|string_len
operator|=
operator|(
name|size_t
operator|)
name|width
expr_stmt|;
return|return
name|print_it
argument_list|(
name|s
argument_list|,
name|string_len
argument_list|,
name|format_string
argument_list|,
name|arg_string
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Read a serie of digits. Stop when non-digit is found.  *  Return value: the value read (between 0 and 32767).  *  Note: no checks are made against overflow. If the string contain a big  *  number, then the return value won't be what we want (but, in this case,  *  the programmer don't know whatr he wants, then no problem).  */
end_comment

begin_function
specifier|static
name|int
name|getint
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|string
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|string
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|i
operator|=
name|i
operator|*
literal|10
operator|+
operator|(
operator|*
operator|*
name|string
operator|-
literal|'0'
operator|)
expr_stmt|;
operator|(
operator|*
name|string
operator|)
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
literal|32767
condition|)
name|i
operator|=
literal|32767
expr_stmt|;
comment|/* if we have i==-10 this is not because the number is */
comment|/* negative; this is because the number is big */
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/*  *  Read a part of the format string. A part is 'usual characters' (ie "blabla")  *  or '%%' escape sequence (to print a single '%') or any combination of  *  format specifier (ie "%i" or "%10.2d").  *  After the current part is managed, the function returns to caller with  *  everything ready to manage the following part.  *  The caller must ensure than the string is not empty, i.e. the first byte  *  is not zero.  *  *  Return value:  0 = ok  *                 EOF = error  */
end_comment

begin_function
specifier|static
name|int
name|dispatch
parameter_list|(
name|xprintf_struct
modifier|*
name|s
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|initial_ptr
decl_stmt|;
name|char
name|format_string
index|[
literal|24
index|]
decl_stmt|;
comment|/* max length may be something like  "% +-#032768.32768Ld" */
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|int
name|flag_plus
decl_stmt|,
name|flag_minus
decl_stmt|,
name|flag_space
decl_stmt|,
name|flag_sharp
decl_stmt|,
name|flag_zero
decl_stmt|;
name|int
name|width
decl_stmt|,
name|prec
decl_stmt|,
name|modifier
decl_stmt|,
name|approx_width
decl_stmt|;
name|char
name|type
decl_stmt|;
comment|/* most of those variables are here to rewrite the format string */
define|#
directive|define
name|SRCTXT
value|(s->src_string)
define|#
directive|define
name|DESTTXT
value|(s->dest_string)
comment|/* incoherent format string. Characters after the '%' will be printed with the next call */
define|#
directive|define
name|INCOHERENT
parameter_list|()
value|do {SRCTXT=initial_ptr; return 0;} while (0)
comment|/* do/while to avoid */
define|#
directive|define
name|INCOHERENT_TEST
parameter_list|()
value|do {if(*SRCTXT==0)   INCOHERENT();} while (0)
comment|/* a null statement  */
comment|/* 'normal' text */
if|if
condition|(
operator|*
name|SRCTXT
operator|!=
literal|'%'
condition|)
return|return
name|usual_char
argument_list|(
name|s
argument_list|)
return|;
comment|/* we then have a '%' */
name|SRCTXT
operator|++
expr_stmt|;
comment|/* don't check for end-of-string ; this is done later */
comment|/* '%%' escape sequence */
if|if
condition|(
operator|*
name|SRCTXT
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
name|realloc_buff
argument_list|(
name|s
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|)
operator|==
name|EOF
condition|)
comment|/* because we can have "%%%%%%%%..." */
return|return
name|EOF
return|;
operator|*
name|DESTTXT
operator|=
literal|'%'
expr_stmt|;
name|DESTTXT
operator|++
expr_stmt|;
name|SRCTXT
operator|++
expr_stmt|;
operator|(
name|s
operator|->
name|real_len
operator|)
operator|++
expr_stmt|;
operator|(
name|s
operator|->
name|pseudo_len
operator|)
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* '%' managing */
name|initial_ptr
operator|=
name|SRCTXT
expr_stmt|;
comment|/* save current pointer in case of incorrect */
comment|/* 'decoding'. Points just after the '%' so the '%' */
comment|/* won't be printed in any case, as required. */
comment|/* flag */
name|flag_plus
operator|=
name|flag_minus
operator|=
name|flag_space
operator|=
name|flag_sharp
operator|=
name|flag_zero
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
name|SRCTXT
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|SRCTXT
operator|==
literal|' '
condition|)
name|flag_space
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|SRCTXT
operator|==
literal|'+'
condition|)
name|flag_plus
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|SRCTXT
operator|==
literal|'-'
condition|)
name|flag_minus
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|SRCTXT
operator|==
literal|'#'
condition|)
name|flag_sharp
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|SRCTXT
operator|==
literal|'0'
condition|)
name|flag_zero
operator|=
literal|1
expr_stmt|;
else|else
break|break;
block|}
name|INCOHERENT_TEST
argument_list|()
expr_stmt|;
comment|/* here is the first test for end of string */
comment|/* width */
if|if
condition|(
operator|*
name|SRCTXT
operator|==
literal|'*'
condition|)
block|{
comment|/* width given by next argument */
name|SRCTXT
operator|++
expr_stmt|;
name|width
operator|=
name|va_arg
argument_list|(
name|s
operator|->
name|vargs
argument_list|,
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|width
operator|>
literal|0x3fffU
condition|)
comment|/* 'size_t' to check against negative values too */
name|width
operator|=
literal|0x3fff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|SRCTXT
argument_list|)
condition|)
comment|/* width given as ASCII number */
name|width
operator|=
name|getint
argument_list|(
operator|&
name|SRCTXT
argument_list|)
expr_stmt|;
else|else
name|width
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no width specified */
name|INCOHERENT_TEST
argument_list|()
expr_stmt|;
comment|/* .prec */
if|if
condition|(
operator|*
name|SRCTXT
operator|==
literal|'.'
condition|)
block|{
name|SRCTXT
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|SRCTXT
operator|==
literal|'*'
condition|)
block|{
comment|/* .prec given by next argument */
name|SRCTXT
operator|++
expr_stmt|;
name|prec
operator|=
name|va_arg
argument_list|(
name|s
operator|->
name|vargs
argument_list|,
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|prec
operator|>=
literal|0x3fffU
condition|)
comment|/* 'size_t' to check against negative values too */
name|prec
operator|=
literal|0x3fff
expr_stmt|;
block|}
else|else
block|{
comment|/* .prec given as ASCII number */
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|SRCTXT
argument_list|)
operator|==
literal|0
condition|)
name|INCOHERENT
argument_list|()
expr_stmt|;
name|prec
operator|=
name|getint
argument_list|(
operator|&
name|SRCTXT
argument_list|)
expr_stmt|;
block|}
name|INCOHERENT_TEST
argument_list|()
expr_stmt|;
block|}
else|else
name|prec
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no .prec specified */
comment|/* modifier */
switch|switch
condition|(
operator|*
name|SRCTXT
condition|)
block|{
case|case
literal|'L'
case|:
case|case
literal|'h'
case|:
case|case
literal|'l'
case|:
case|case
literal|'z'
case|:
case|case
literal|'t'
case|:
name|modifier
operator|=
operator|*
name|SRCTXT
expr_stmt|;
name|SRCTXT
operator|++
expr_stmt|;
if|if
condition|(
name|modifier
operator|==
literal|'l'
operator|&&
operator|*
name|SRCTXT
operator|==
literal|'l'
condition|)
block|{
name|SRCTXT
operator|++
expr_stmt|;
name|modifier
operator|=
literal|'L'
expr_stmt|;
comment|/* 'll' == 'L'      long long == long double */
block|}
comment|/* only for compatibility ; not portable */
name|INCOHERENT_TEST
argument_list|()
expr_stmt|;
break|break;
default|default:
name|modifier
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no modifier specified */
break|break;
block|}
comment|/* type */
name|type
operator|=
operator|*
name|SRCTXT
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
literal|"diouxXfegEGcspn"
argument_list|,
name|type
argument_list|)
operator|==
name|NULL
condition|)
name|INCOHERENT
argument_list|()
expr_stmt|;
comment|/* unknown type */
name|SRCTXT
operator|++
expr_stmt|;
comment|/* rewrite format-string */
name|format_string
index|[
literal|0
index|]
operator|=
literal|'%'
expr_stmt|;
name|format_ptr
operator|=
operator|&
operator|(
name|format_string
index|[
literal|1
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|flag_plus
condition|)
block|{
operator|*
name|format_ptr
operator|=
literal|'+'
expr_stmt|;
name|format_ptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|flag_minus
condition|)
block|{
operator|*
name|format_ptr
operator|=
literal|'-'
expr_stmt|;
name|format_ptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|flag_space
condition|)
block|{
operator|*
name|format_ptr
operator|=
literal|' '
expr_stmt|;
name|format_ptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|flag_sharp
condition|)
block|{
operator|*
name|format_ptr
operator|=
literal|'#'
expr_stmt|;
name|format_ptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|flag_zero
condition|)
block|{
operator|*
name|format_ptr
operator|=
literal|'0'
expr_stmt|;
name|format_ptr
operator|++
expr_stmt|;
block|}
comment|/* '0' *must* be the last one */
if|if
condition|(
name|width
operator|!=
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|format_ptr
argument_list|,
literal|"%i"
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|format_ptr
operator|+=
name|strlen
argument_list|(
name|format_ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prec
operator|!=
operator|-
literal|1
condition|)
block|{
operator|*
name|format_ptr
operator|=
literal|'.'
expr_stmt|;
name|format_ptr
operator|++
expr_stmt|;
name|sprintf
argument_list|(
name|format_ptr
argument_list|,
literal|"%i"
argument_list|,
name|prec
argument_list|)
expr_stmt|;
name|format_ptr
operator|+=
name|strlen
argument_list|(
name|format_ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|modifier
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|modifier
operator|==
literal|'L'
operator|&&
name|strchr
argument_list|(
literal|"diouxX"
argument_list|,
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|format_ptr
operator|=
literal|'l'
expr_stmt|;
name|format_ptr
operator|++
expr_stmt|;
operator|*
name|format_ptr
operator|=
literal|'l'
expr_stmt|;
name|format_ptr
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
name|format_ptr
operator|=
name|modifier
expr_stmt|;
name|format_ptr
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|format_ptr
operator|=
name|type
expr_stmt|;
name|format_ptr
operator|++
expr_stmt|;
operator|*
name|format_ptr
operator|=
literal|0
expr_stmt|;
comment|/* vague approximation of minimal length if width or prec are specified */
name|approx_width
operator|=
name|width
operator|+
name|prec
expr_stmt|;
if|if
condition|(
name|approx_width
operator|<
literal|0
condition|)
comment|/* because width == -1 and/or prec == -1 */
name|approx_width
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
comment|/* int */
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
case|case
literal|'o'
case|:
case|case
literal|'u'
case|:
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
switch|switch
condition|(
name|modifier
condition|)
block|{
case|case
operator|-
literal|1
case|:
return|return
name|print_it
argument_list|(
name|s
argument_list|,
operator|(
name|size_t
operator|)
name|approx_width
argument_list|,
name|format_string
argument_list|,
name|va_arg
argument_list|(
name|s
operator|->
name|vargs
argument_list|,
name|int
argument_list|)
argument_list|)
return|;
case|case
literal|'L'
case|:
return|return
name|print_it
argument_list|(
name|s
argument_list|,
operator|(
name|size_t
operator|)
name|approx_width
argument_list|,
name|format_string
argument_list|,
name|va_arg
argument_list|(
argument|s->vargs
argument_list|,
argument|long long int
argument_list|)
argument_list|)
return|;
case|case
literal|'l'
case|:
return|return
name|print_it
argument_list|(
name|s
argument_list|,
operator|(
name|size_t
operator|)
name|approx_width
argument_list|,
name|format_string
argument_list|,
name|va_arg
argument_list|(
argument|s->vargs
argument_list|,
argument|long int
argument_list|)
argument_list|)
return|;
case|case
literal|'h'
case|:
return|return
name|print_it
argument_list|(
name|s
argument_list|,
operator|(
name|size_t
operator|)
name|approx_width
argument_list|,
name|format_string
argument_list|,
name|va_arg
argument_list|(
name|s
operator|->
name|vargs
argument_list|,
name|int
argument_list|)
argument_list|)
return|;
case|case
literal|'z'
case|:
return|return
name|print_it
argument_list|(
name|s
argument_list|,
operator|(
name|size_t
operator|)
name|approx_width
argument_list|,
name|format_string
argument_list|,
name|va_arg
argument_list|(
name|s
operator|->
name|vargs
argument_list|,
name|size_t
argument_list|)
argument_list|)
return|;
case|case
literal|'t'
case|:
return|return
name|print_it
argument_list|(
name|s
argument_list|,
operator|(
name|size_t
operator|)
name|approx_width
argument_list|,
name|format_string
argument_list|,
name|va_arg
argument_list|(
name|s
operator|->
name|vargs
argument_list|,
name|ptrdiff_t
argument_list|)
argument_list|)
return|;
comment|/* 'int' instead of 'short int' because default promotion is 'int' */
default|default:
name|INCOHERENT
argument_list|()
expr_stmt|;
block|}
comment|/* char */
case|case
literal|'c'
case|:
if|if
condition|(
name|modifier
operator|!=
operator|-
literal|1
condition|)
name|INCOHERENT
argument_list|()
expr_stmt|;
return|return
name|print_it
argument_list|(
name|s
argument_list|,
operator|(
name|size_t
operator|)
name|approx_width
argument_list|,
name|format_string
argument_list|,
name|va_arg
argument_list|(
name|s
operator|->
name|vargs
argument_list|,
name|int
argument_list|)
argument_list|)
return|;
comment|/* 'int' instead of 'char' because default promotion is 'int' */
comment|/* math */
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'E'
case|:
case|case
literal|'G'
case|:
switch|switch
condition|(
name|modifier
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* because of default promotion, no modifier means 'l' */
case|case
literal|'l'
case|:
return|return
name|print_it
argument_list|(
name|s
argument_list|,
operator|(
name|size_t
operator|)
name|approx_width
argument_list|,
name|format_string
argument_list|,
name|va_arg
argument_list|(
name|s
operator|->
name|vargs
argument_list|,
name|double
argument_list|)
argument_list|)
return|;
case|case
literal|'L'
case|:
return|return
name|print_it
argument_list|(
name|s
argument_list|,
operator|(
name|size_t
operator|)
name|approx_width
argument_list|,
name|format_string
argument_list|,
name|va_arg
argument_list|(
argument|s->vargs
argument_list|,
argument|long double
argument_list|)
argument_list|)
return|;
default|default:
name|INCOHERENT
argument_list|()
expr_stmt|;
block|}
comment|/* string */
case|case
literal|'s'
case|:
return|return
name|type_s
argument_list|(
name|s
argument_list|,
name|width
argument_list|,
name|prec
argument_list|,
name|format_string
argument_list|,
name|va_arg
argument_list|(
name|s
operator|->
name|vargs
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
return|;
comment|/* pointer */
case|case
literal|'p'
case|:
if|if
condition|(
name|modifier
operator|==
operator|-
literal|1
condition|)
return|return
name|print_it
argument_list|(
name|s
argument_list|,
operator|(
name|size_t
operator|)
name|approx_width
argument_list|,
name|format_string
argument_list|,
name|va_arg
argument_list|(
name|s
operator|->
name|vargs
argument_list|,
name|void
operator|*
argument_list|)
argument_list|)
return|;
name|INCOHERENT
argument_list|()
expr_stmt|;
comment|/* store */
case|case
literal|'n'
case|:
if|if
condition|(
name|modifier
operator|==
operator|-
literal|1
condition|)
block|{
name|int
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|va_arg
argument_list|(
name|s
operator|->
name|vargs
argument_list|,
name|int
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|=
name|s
operator|->
name|pseudo_len
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EOF
return|;
block|}
name|INCOHERENT
argument_list|()
expr_stmt|;
block|}
comment|/* switch */
name|INCOHERENT
argument_list|()
expr_stmt|;
comment|/* unknown type */
undef|#
directive|undef
name|INCOHERENT
undef|#
directive|undef
name|INCOHERENT_TEST
undef|#
directive|undef
name|SRCTXT
undef|#
directive|undef
name|DESTTXT
block|}
end_function

begin_comment
comment|/*  *  Return value: number of *virtually* written characters  *                EOF = error  */
end_comment

begin_function
specifier|static
name|int
name|core
parameter_list|(
name|xprintf_struct
modifier|*
name|s
parameter_list|)
block|{
name|size_t
name|save_len
decl_stmt|;
name|char
modifier|*
name|dummy_base
decl_stmt|;
comment|/* basic checks */
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|s
operator|->
name|maxlen
argument_list|)
operator|<=
literal|0
condition|)
comment|/* 'int' to check against some conversion */
return|return
name|EOF
return|;
comment|/* error for example if value is (int)-10 */
name|s
operator|->
name|maxlen
operator|--
expr_stmt|;
comment|/* because initial maxlen counts final 0 */
comment|/* note: now 'maxlen' _can_ be zero */
if|if
condition|(
name|s
operator|->
name|src_string
operator|==
name|NULL
condition|)
name|s
operator|->
name|src_string
operator|=
literal|"(null)"
expr_stmt|;
comment|/* struct init and memory allocation */
name|s
operator|->
name|buffer_base
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|buffer_len
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|real_len
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|pseudo_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|realloc_buff
argument_list|(
name|s
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|)
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
name|s
operator|->
name|dest_string
operator|=
name|s
operator|->
name|buffer_base
expr_stmt|;
comment|/* process source string */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* up to end of source string */
if|if
condition|(
operator|*
operator|(
name|s
operator|->
name|src_string
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
operator|(
name|s
operator|->
name|dest_string
operator|)
operator|=
literal|'\0'
expr_stmt|;
comment|/* final NUL */
break|break;
block|}
if|if
condition|(
name|dispatch
argument_list|(
name|s
argument_list|)
operator|==
name|EOF
condition|)
goto|goto
name|free_EOF
goto|;
comment|/* up to end of dest string */
if|if
condition|(
name|s
operator|->
name|real_len
operator|>=
name|s
operator|->
name|maxlen
condition|)
block|{
operator|(
name|s
operator|->
name|buffer_base
operator|)
index|[
name|s
operator|->
name|maxlen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* final NUL */
break|break;
block|}
block|}
comment|/* for (v)asnprintf */
name|dummy_base
operator|=
name|s
operator|->
name|buffer_base
expr_stmt|;
name|dummy_base
operator|=
name|s
operator|->
name|buffer_base
operator|+
name|s
operator|->
name|real_len
expr_stmt|;
name|save_len
operator|=
name|s
operator|->
name|real_len
expr_stmt|;
comment|/* process the remaining of source string to compute 'pseudo_len'. We    * overwrite again and again, starting at 'dummy_base' because we don't    * need the text, only char count. */
while|while
condition|(
operator|*
operator|(
name|s
operator|->
name|src_string
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* up to end of source string */
name|s
operator|->
name|real_len
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|dest_string
operator|=
name|dummy_base
expr_stmt|;
if|if
condition|(
name|dispatch
argument_list|(
name|s
argument_list|)
operator|==
name|EOF
condition|)
goto|goto
name|free_EOF
goto|;
block|}
name|s
operator|->
name|buffer_base
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|s
operator|->
name|buffer_base
operator|)
argument_list|,
name|save_len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|buffer_base
operator|==
name|NULL
condition|)
return|return
name|EOF
return|;
comment|/* should rarely happen because we shrink the buffer */
return|return
name|s
operator|->
name|pseudo_len
return|;
name|free_EOF
label|:
name|free
argument_list|(
name|s
operator|->
name|buffer_base
argument_list|)
expr_stmt|;
return|return
name|EOF
return|;
block|}
end_function

begin_function
name|int
name|vasprintf
parameter_list|(
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|format_string
parameter_list|,
name|va_list
name|vargs
parameter_list|)
block|{
name|xprintf_struct
name|s
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|s
operator|.
name|src_string
operator|=
name|format_string
expr_stmt|;
ifdef|#
directive|ifdef
name|va_copy
name|va_copy
argument_list|(
name|s
operator|.
name|vargs
argument_list|,
name|vargs
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|__va_copy
name|__va_copy
argument_list|(
name|s
operator|.
name|vargs
argument_list|,
name|vargs
argument_list|)
expr_stmt|;
else|#
directive|else
name|memcpy
argument_list|(
operator|&
name|s
operator|.
name|vargs
argument_list|,
operator|&
name|vargs
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|.
name|va_args
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __va_copy */
endif|#
directive|endif
comment|/* va_copy */
name|s
operator|.
name|maxlen
operator|=
operator|(
name|size_t
operator|)
name|INT_MAX
expr_stmt|;
name|retval
operator|=
name|core
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|s
operator|.
name|vargs
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|EOF
condition|)
block|{
operator|*
name|ptr
operator|=
name|NULL
expr_stmt|;
return|return
name|EOF
return|;
block|}
operator|*
name|ptr
operator|=
name|s
operator|.
name|buffer_base
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

end_unit

