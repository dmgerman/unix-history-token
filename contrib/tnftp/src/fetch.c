begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: fetch.c,v 1.18 2009/11/15 10:12:37 lukem Exp $	*/
end_comment

begin_comment
comment|/*	from	NetBSD: fetch.c,v 1.191 2009/08/17 09:08:16 christos Exp	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 1997-2009 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Luke Mewburn.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Scott Aaron Bamford.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"tnftp.h"
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* tnftp */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_endif
unit|__RCSID(" NetBSD: fetch.c,v 1.191 2009/08/17 09:08:16 christos Exp  ");
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * FTP User Program -- Command line file retrieval  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/ftp.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* tnftp */
end_comment

begin_include
include|#
directive|include
file|"ftp_var.h"
end_include

begin_include
include|#
directive|include
file|"version.h"
end_include

begin_typedef
typedef|typedef
enum|enum
block|{
name|UNKNOWN_URL_T
init|=
operator|-
literal|1
block|,
name|HTTP_URL_T
block|,
name|FTP_URL_T
block|,
name|FILE_URL_T
block|,
name|CLASSIC_URL_T
block|}
name|url_t
typedef|;
end_typedef

begin_function_decl
name|void
name|aborthttp
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|NO_AUTH
end_ifndef

begin_function_decl
specifier|static
name|int
name|auth_url
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|base64_encode
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|go_fetch
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fetch_ftp
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fetch_url
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|match_token
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_url
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|url_t
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|in_port_t
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|url_decode
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|redirect_loop
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|STRNEQUAL
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(strncasecmp((a), (b), sizeof((b))-1) == 0)
end_define

begin_define
define|#
directive|define
name|ISLWS
parameter_list|(
name|x
parameter_list|)
value|((x)=='\r' || (x)=='\n' || (x)==' ' || (x)=='\t')
end_define

begin_define
define|#
directive|define
name|SKIPLWS
parameter_list|(
name|x
parameter_list|)
value|do { while (ISLWS((*x))) x++; } while (0)
end_define

begin_define
define|#
directive|define
name|ABOUT_URL
value|"about:"
end_define

begin_comment
comment|/* propaganda */
end_comment

begin_define
define|#
directive|define
name|FILE_URL
value|"file://"
end_define

begin_comment
comment|/* file URL prefix */
end_comment

begin_define
define|#
directive|define
name|FTP_URL
value|"ftp://"
end_define

begin_comment
comment|/* ftp URL prefix */
end_comment

begin_define
define|#
directive|define
name|HTTP_URL
value|"http://"
end_define

begin_comment
comment|/* http URL prefix */
end_comment

begin_comment
comment|/*  * Determine if token is the next word in buf (case insensitive).  * If so, advance buf past the token and any trailing LWS, and  * return a pointer to the token (in buf).  Otherwise, return NULL.  * token may be preceded by LWS.  * token must be followed by LWS or NUL.  (I.e, don't partial match).  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|match_token
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|orig
decl_stmt|;
name|size_t
name|tlen
decl_stmt|;
name|tlen
operator|=
name|strlen
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|p
operator|=
operator|*
name|buf
expr_stmt|;
name|SKIPLWS
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|orig
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|p
argument_list|,
name|token
argument_list|,
name|tlen
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
name|p
operator|+=
name|tlen
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|!
name|ISLWS
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return
name|NULL
return|;
name|SKIPLWS
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|orig
operator|=
operator|*
name|buf
expr_stmt|;
operator|*
name|buf
operator|=
name|p
expr_stmt|;
return|return
name|orig
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_AUTH
end_ifndef

begin_comment
comment|/*  * Generate authorization response based on given authentication challenge.  * Returns -1 if an error occurred, otherwise 0.  * Sets response to a malloc(3)ed string; caller should free.  */
end_comment

begin_function
specifier|static
name|int
name|auth_url
parameter_list|(
specifier|const
name|char
modifier|*
name|challenge
parameter_list|,
name|char
modifier|*
modifier|*
name|response
parameter_list|,
specifier|const
name|char
modifier|*
name|guser
parameter_list|,
specifier|const
name|char
modifier|*
name|gpass
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|scheme
decl_stmt|,
modifier|*
name|errormsg
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|,
modifier|*
name|clear
decl_stmt|,
modifier|*
name|realm
decl_stmt|;
name|char
name|uuser
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|gotpass
decl_stmt|;
specifier|const
name|char
modifier|*
name|upass
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|clen
decl_stmt|,
name|rlen
decl_stmt|;
operator|*
name|response
operator|=
name|NULL
expr_stmt|;
name|clear
operator|=
name|realm
operator|=
name|NULL
expr_stmt|;
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
name|cp
operator|=
name|challenge
expr_stmt|;
name|scheme
operator|=
literal|"Basic"
expr_stmt|;
comment|/* only support Basic authentication */
name|gotpass
operator|=
name|NULL
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"auth_url: challenge `%s'\n"
argument_list|,
name|challenge
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|match_token
argument_list|(
operator|&
name|cp
argument_list|,
name|scheme
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Unsupported authentication challenge `%s'"
argument_list|,
name|challenge
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_auth_url
goto|;
block|}
define|#
directive|define
name|REALM
value|"realm=\""
if|if
condition|(
name|STRNEQUAL
argument_list|(
name|cp
argument_list|,
name|REALM
argument_list|)
condition|)
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|REALM
argument_list|)
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"Unsupported authentication challenge `%s'"
argument_list|,
name|challenge
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_auth_url
goto|;
block|}
comment|/* XXX: need to improve quoted-string parsing to support \ quoting, etc. */
if|if
condition|(
operator|(
name|ep
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\"'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|ep
operator|-
name|cp
expr_stmt|;
name|realm
operator|=
operator|(
name|char
operator|*
operator|)
name|ftp_malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|realm
argument_list|,
name|cp
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"Unsupported authentication challenge `%s'"
argument_list|,
name|challenge
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_auth_url
goto|;
block|}
name|fprintf
argument_list|(
name|ttyout
argument_list|,
literal|"Username for `%s': "
argument_list|,
name|realm
argument_list|)
expr_stmt|;
if|if
condition|(
name|guser
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|uuser
argument_list|,
name|guser
argument_list|,
sizeof|sizeof
argument_list|(
name|uuser
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ttyout
argument_list|,
literal|"%s\n"
argument_list|,
name|uuser
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|ttyout
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_line
argument_list|(
name|stdin
argument_list|,
name|uuser
argument_list|,
sizeof|sizeof
argument_list|(
name|uuser
argument_list|)
argument_list|,
operator|&
name|errormsg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"%s; can't authenticate"
argument_list|,
name|errormsg
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_auth_url
goto|;
block|}
block|}
if|if
condition|(
name|gpass
operator|!=
name|NULL
condition|)
name|upass
operator|=
name|gpass
expr_stmt|;
else|else
block|{
name|gotpass
operator|=
name|getpass
argument_list|(
literal|"Password: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|gotpass
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Can't read password"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_auth_url
goto|;
block|}
name|upass
operator|=
name|gotpass
expr_stmt|;
block|}
name|clen
operator|=
name|strlen
argument_list|(
name|uuser
argument_list|)
operator|+
name|strlen
argument_list|(
name|upass
argument_list|)
operator|+
literal|2
expr_stmt|;
comment|/* user + ":" + pass + "\0" */
name|clear
operator|=
operator|(
name|char
operator|*
operator|)
name|ftp_malloc
argument_list|(
name|clen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|clear
argument_list|,
name|uuser
argument_list|,
name|clen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|clear
argument_list|,
literal|":"
argument_list|,
name|clen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|clear
argument_list|,
name|upass
argument_list|,
name|clen
argument_list|)
expr_stmt|;
if|if
condition|(
name|gotpass
condition|)
name|memset
argument_list|(
name|gotpass
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|gotpass
argument_list|)
argument_list|)
expr_stmt|;
comment|/* scheme + " " + enc + "\0" */
name|rlen
operator|=
name|strlen
argument_list|(
name|scheme
argument_list|)
operator|+
literal|1
operator|+
operator|(
name|clen
operator|+
literal|2
operator|)
operator|*
literal|4
operator|/
literal|3
operator|+
literal|1
expr_stmt|;
operator|*
name|response
operator|=
operator|(
name|char
operator|*
operator|)
name|ftp_malloc
argument_list|(
name|rlen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
operator|*
name|response
argument_list|,
name|scheme
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlcat
argument_list|(
operator|*
name|response
argument_list|,
literal|" "
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
comment|/* use  `clen - 1'  to not encode the trailing NUL */
name|base64_encode
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|clear
argument_list|,
name|clen
operator|-
literal|1
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|*
name|response
operator|+
name|len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|clear
argument_list|,
literal|0
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|rval
operator|=
literal|0
expr_stmt|;
name|cleanup_auth_url
label|:
name|FREEPTR
argument_list|(
name|clear
argument_list|)
expr_stmt|;
name|FREEPTR
argument_list|(
name|realm
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Encode len bytes starting at clear using base64 encoding into encoded,  * which should be at least ((len + 2) * 4 / 3 + 1) in size.  */
end_comment

begin_function
specifier|static
name|void
name|base64_encode
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|clear
parameter_list|,
name|size_t
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|encoded
parameter_list|)
block|{
specifier|static
specifier|const
name|unsigned
name|char
name|enc
index|[]
init|=
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
decl_stmt|;
name|unsigned
name|char
modifier|*
name|cp
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|cp
operator|=
name|encoded
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|3
control|)
block|{
operator|*
operator|(
name|cp
operator|++
operator|)
operator|=
name|enc
index|[
operator|(
operator|(
name|clear
index|[
name|i
operator|+
literal|0
index|]
operator|>>
literal|2
operator|)
operator|)
index|]
expr_stmt|;
operator|*
operator|(
name|cp
operator|++
operator|)
operator|=
name|enc
index|[
operator|(
operator|(
name|clear
index|[
name|i
operator|+
literal|0
index|]
operator|<<
literal|4
operator|)
operator|&
literal|0x30
operator|)
operator||
operator|(
operator|(
name|clear
index|[
name|i
operator|+
literal|1
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
operator|)
index|]
expr_stmt|;
operator|*
operator|(
name|cp
operator|++
operator|)
operator|=
name|enc
index|[
operator|(
operator|(
name|clear
index|[
name|i
operator|+
literal|1
index|]
operator|<<
literal|2
operator|)
operator|&
literal|0x3c
operator|)
operator||
operator|(
operator|(
name|clear
index|[
name|i
operator|+
literal|2
index|]
operator|>>
literal|6
operator|)
operator|&
literal|0x03
operator|)
index|]
expr_stmt|;
operator|*
operator|(
name|cp
operator|++
operator|)
operator|=
name|enc
index|[
operator|(
operator|(
name|clear
index|[
name|i
operator|+
literal|2
index|]
operator|)
operator|&
literal|0x3f
operator|)
index|]
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
name|len
condition|)
operator|*
operator|(
operator|--
name|cp
operator|)
operator|=
literal|'='
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Decode %xx escapes in given string, `in-place'.  */
end_comment

begin_function
specifier|static
name|void
name|url_decode
parameter_list|(
name|char
modifier|*
name|url
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|EMPTYSTRING
argument_list|(
name|url
argument_list|)
condition|)
return|return;
name|p
operator|=
name|q
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|url
expr_stmt|;
define|#
directive|define
name|HEXTOINT
parameter_list|(
name|x
parameter_list|)
value|(x - (isdigit(x) ? '0' : (islower(x) ? 'a' : 'A') - 10))
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'%'
operator|&&
name|p
index|[
literal|1
index|]
operator|&&
name|isxdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|p
index|[
literal|1
index|]
argument_list|)
operator|&&
name|p
index|[
literal|2
index|]
operator|&&
name|isxdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|p
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
operator|*
name|q
operator|++
operator|=
name|HEXTOINT
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
operator|*
literal|16
operator|+
name|HEXTOINT
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|3
expr_stmt|;
block|}
else|else
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse URL of form (per RFC3986):  *<type>://[<user>[:<password>]@]<host>[:<port>][/<path>]  * Returns -1 if a parse error occurred, otherwise 0.  * It's the caller's responsibility to url_decode() the returned  * user, pass and path.  *  * Sets type to url_t, each of the given char ** pointers to a  * malloc(3)ed strings of the relevant section, and port to  * the number given, or ftpport if ftp://, or httpport if http://.  *  * XXX: this is not totally RFC3986 compliant;<path> will have the  * leading `/' unless it's an ftp:// URL, as this makes things easier  * for file:// and http:// URLs.  ftp:// URLs have the `/' between the  * host and the URL-path removed, but any additional leading slashes  * in the URL-path are retained (because they imply that we should  * later do "CWD" with a null argument).  *  * Examples:  *	 input URL			 output path  *	 ---------			 -----------  *	"http://host"			"/"  *	"http://host/"			"/"  *	"http://host/path"		"/path"  *	"file://host/dir/file"		"dir/file"  *	"ftp://host"			""  *	"ftp://host/"			""  *	"ftp://host//"			"/"  *	"ftp://host/dir/file"		"dir/file"  *	"ftp://host//dir/file"		"/dir/file"  */
end_comment

begin_function
specifier|static
name|int
name|parse_url
parameter_list|(
specifier|const
name|char
modifier|*
name|url
parameter_list|,
specifier|const
name|char
modifier|*
name|desc
parameter_list|,
name|url_t
modifier|*
name|utype
parameter_list|,
name|char
modifier|*
modifier|*
name|uuser
parameter_list|,
name|char
modifier|*
modifier|*
name|pass
parameter_list|,
name|char
modifier|*
modifier|*
name|host
parameter_list|,
name|char
modifier|*
modifier|*
name|port
parameter_list|,
name|in_port_t
modifier|*
name|portnum
parameter_list|,
name|char
modifier|*
modifier|*
name|path
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|origurl
decl_stmt|,
modifier|*
name|tport
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|thost
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|url
operator|==
name|NULL
operator|||
name|desc
operator|==
name|NULL
operator|||
name|utype
operator|==
name|NULL
operator|||
name|uuser
operator|==
name|NULL
operator|||
name|pass
operator|==
name|NULL
operator|||
name|host
operator|==
name|NULL
operator|||
name|port
operator|==
name|NULL
operator|||
name|portnum
operator|==
name|NULL
operator|||
name|path
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"parse_url: invoked with NULL argument!"
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"parse_url: %s `%s'\n"
argument_list|,
name|desc
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|origurl
operator|=
name|url
expr_stmt|;
operator|*
name|utype
operator|=
name|UNKNOWN_URL_T
expr_stmt|;
operator|*
name|uuser
operator|=
operator|*
name|pass
operator|=
operator|*
name|host
operator|=
operator|*
name|port
operator|=
operator|*
name|path
operator|=
name|NULL
expr_stmt|;
operator|*
name|portnum
operator|=
literal|0
expr_stmt|;
name|tport
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|STRNEQUAL
argument_list|(
name|url
argument_list|,
name|HTTP_URL
argument_list|)
condition|)
block|{
name|url
operator|+=
sizeof|sizeof
argument_list|(
name|HTTP_URL
argument_list|)
operator|-
literal|1
expr_stmt|;
operator|*
name|utype
operator|=
name|HTTP_URL_T
expr_stmt|;
operator|*
name|portnum
operator|=
name|HTTP_PORT
expr_stmt|;
name|tport
operator|=
name|httpport
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STRNEQUAL
argument_list|(
name|url
argument_list|,
name|FTP_URL
argument_list|)
condition|)
block|{
name|url
operator|+=
sizeof|sizeof
argument_list|(
name|FTP_URL
argument_list|)
operator|-
literal|1
expr_stmt|;
operator|*
name|utype
operator|=
name|FTP_URL_T
expr_stmt|;
operator|*
name|portnum
operator|=
name|FTP_PORT
expr_stmt|;
name|tport
operator|=
name|ftpport
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STRNEQUAL
argument_list|(
name|url
argument_list|,
name|FILE_URL
argument_list|)
condition|)
block|{
name|url
operator|+=
sizeof|sizeof
argument_list|(
name|FILE_URL
argument_list|)
operator|-
literal|1
expr_stmt|;
operator|*
name|utype
operator|=
name|FILE_URL_T
expr_stmt|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"Invalid %s `%s'"
argument_list|,
name|desc
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|cleanup_parse_url
label|:
name|FREEPTR
argument_list|(
operator|*
name|uuser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pass
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
operator|*
name|pass
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
operator|*
name|pass
argument_list|)
argument_list|)
expr_stmt|;
name|FREEPTR
argument_list|(
operator|*
name|pass
argument_list|)
expr_stmt|;
name|FREEPTR
argument_list|(
operator|*
name|host
argument_list|)
expr_stmt|;
name|FREEPTR
argument_list|(
operator|*
name|port
argument_list|)
expr_stmt|;
name|FREEPTR
argument_list|(
operator|*
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|url
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* find [user[:pass]@]host[:port] */
name|ep
operator|=
name|strchr
argument_list|(
name|url
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
name|thost
operator|=
name|ftp_strdup
argument_list|(
name|url
argument_list|)
expr_stmt|;
else|else
block|{
name|len
operator|=
name|ep
operator|-
name|url
expr_stmt|;
name|thost
operator|=
operator|(
name|char
operator|*
operator|)
name|ftp_malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|thost
argument_list|,
name|url
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|utype
operator|==
name|FTP_URL_T
condition|)
comment|/* skip first / for ftp URLs */
name|ep
operator|++
expr_stmt|;
operator|*
name|path
operator|=
name|ftp_strdup
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|strchr
argument_list|(
name|thost
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
comment|/* look for user[:pass]@ in URLs */
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|utype
operator|==
name|FTP_URL_T
condition|)
name|anonftp
operator|=
literal|0
expr_stmt|;
comment|/* disable anonftp */
operator|*
name|uuser
operator|=
name|thost
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|thost
operator|=
name|ftp_strdup
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
operator|*
name|uuser
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|pass
operator|=
name|ftp_strdup
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|url_decode
argument_list|(
operator|*
name|uuser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pass
condition|)
name|url_decode
argument_list|(
operator|*
name|pass
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INET6
comment|/* 			 * Check if thost is an encoded IPv6 address, as per 			 * RFC3986: 			 *	`[' ipv6-address ']' 			 */
if|if
condition|(
operator|*
name|thost
operator|==
literal|'['
condition|)
block|{
name|cp
operator|=
name|thost
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|ep
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|']'
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|ep
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|&&
name|ep
index|[
literal|1
index|]
operator|!=
literal|':'
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Invalid address `%s' in %s `%s'"
argument_list|,
name|thost
argument_list|,
name|desc
argument_list|,
name|origurl
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_parse_url
goto|;
block|}
name|len
operator|=
name|ep
operator|-
name|cp
expr_stmt|;
comment|/* change `[xyz]' -> `xyz' */
name|memmove
argument_list|(
name|thost
argument_list|,
name|thost
operator|+
literal|1
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|thost
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|isipv6addr
argument_list|(
name|thost
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Invalid IPv6 address `%s' in %s `%s'"
argument_list|,
name|thost
argument_list|,
name|desc
argument_list|,
name|origurl
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_parse_url
goto|;
block|}
name|cp
operator|=
name|ep
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|':'
condition|)
name|cp
operator|++
expr_stmt|;
else|else
name|cp
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* INET6 */
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|thost
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|host
operator|=
name|thost
expr_stmt|;
comment|/* look for [:port] */
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|long
name|nport
decl_stmt|;
name|nport
operator|=
name|strtoul
argument_list|(
name|cp
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
operator|||
operator|*
name|ep
operator|!=
literal|'\0'
operator|||
name|nport
operator|<
literal|1
operator|||
name|nport
operator|>
name|MAX_IN_PORT_T
condition|)
block|{
name|warnx
argument_list|(
literal|"Unknown port `%s' in %s `%s'"
argument_list|,
name|cp
argument_list|,
name|desc
argument_list|,
name|origurl
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_parse_url
goto|;
block|}
operator|*
name|portnum
operator|=
name|nport
expr_stmt|;
name|tport
operator|=
name|cp
expr_stmt|;
block|}
if|if
condition|(
name|tport
operator|!=
name|NULL
condition|)
operator|*
name|port
operator|=
name|ftp_strdup
argument_list|(
name|tport
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|path
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|emptypath
init|=
literal|"/"
decl_stmt|;
if|if
condition|(
operator|*
name|utype
operator|==
name|FTP_URL_T
condition|)
comment|/* skip first / for ftp URLs */
name|emptypath
operator|++
expr_stmt|;
operator|*
name|path
operator|=
name|ftp_strdup
argument_list|(
name|emptypath
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"parse_url: user `%s' pass `%s' host %s port %s(%d) "
literal|"path `%s'\n"
argument_list|,
name|STRorNULL
argument_list|(
operator|*
name|uuser
argument_list|)
argument_list|,
name|STRorNULL
argument_list|(
operator|*
name|pass
argument_list|)
argument_list|,
name|STRorNULL
argument_list|(
operator|*
name|host
argument_list|)
argument_list|,
name|STRorNULL
argument_list|(
operator|*
name|port
argument_list|)
argument_list|,
operator|*
name|portnum
condition|?
operator|*
name|portnum
else|:
operator|-
literal|1
argument_list|,
name|STRorNULL
argument_list|(
operator|*
name|path
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|sigjmp_buf
name|httpabort
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Retrieve URL, via a proxy if necessary, using HTTP.  * If proxyenv is set, use that for the proxy, otherwise try ftp_proxy or  * http_proxy as appropriate.  * Supports HTTP redirects.  * Returns 1 on failure, 0 on completed xfer, -1 if ftp connection  * is still open (e.g, ftp xfer with trailing /)  */
end_comment

begin_function
specifier|static
name|int
name|fetch_url
parameter_list|(
specifier|const
name|char
modifier|*
name|url
parameter_list|,
specifier|const
name|char
modifier|*
name|proxyenv
parameter_list|,
name|char
modifier|*
name|proxyauth
parameter_list|,
name|char
modifier|*
name|wwwauth
parameter_list|)
block|{
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|res
decl_stmt|,
modifier|*
name|res0
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sigfunc
specifier|volatile
name|oldintr
decl_stmt|;
name|sigfunc
specifier|volatile
name|oldintp
decl_stmt|;
name|int
specifier|volatile
name|s
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|int
specifier|volatile
name|ischunked
decl_stmt|;
name|int
specifier|volatile
name|isproxy
decl_stmt|;
name|int
specifier|volatile
name|rval
decl_stmt|;
name|int
specifier|volatile
name|hcode
decl_stmt|;
name|int
name|len
decl_stmt|;
name|size_t
name|flen
decl_stmt|;
specifier|static
name|size_t
name|bufsize
decl_stmt|;
specifier|static
name|char
modifier|*
name|xferbuf
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|token
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|char
name|buf
index|[
name|FTPBUFLEN
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|errormsg
decl_stmt|;
name|char
modifier|*
specifier|volatile
name|savefile
decl_stmt|;
name|char
modifier|*
specifier|volatile
name|auth
decl_stmt|;
name|char
modifier|*
specifier|volatile
name|location
decl_stmt|;
name|char
modifier|*
specifier|volatile
name|message
decl_stmt|;
name|char
modifier|*
name|uuser
decl_stmt|,
modifier|*
name|pass
decl_stmt|,
modifier|*
name|host
decl_stmt|,
modifier|*
name|port
decl_stmt|,
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
specifier|volatile
name|decodedpath
decl_stmt|;
name|char
modifier|*
name|puser
decl_stmt|,
modifier|*
name|ppass
decl_stmt|,
modifier|*
name|useragent
decl_stmt|;
name|off_t
name|hashbytes
decl_stmt|,
name|rangestart
decl_stmt|,
name|rangeend
decl_stmt|,
name|entitylen
decl_stmt|;
name|int
argument_list|(
operator|*
specifier|volatile
name|closefunc
argument_list|)
argument_list|(
name|FILE
operator|*
argument_list|)
expr_stmt|;
name|FILE
modifier|*
specifier|volatile
name|fin
decl_stmt|;
name|FILE
modifier|*
specifier|volatile
name|fout
decl_stmt|;
name|time_t
name|mtime
decl_stmt|;
name|url_t
name|urltype
decl_stmt|;
name|in_port_t
name|portnum
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"fetch_url: `%s' proxyenv `%s'\n"
argument_list|,
name|url
argument_list|,
name|STRorNULL
argument_list|(
name|proxyenv
argument_list|)
argument_list|)
expr_stmt|;
name|oldintr
operator|=
name|oldintp
operator|=
name|NULL
expr_stmt|;
name|closefunc
operator|=
name|NULL
expr_stmt|;
name|fin
operator|=
name|fout
operator|=
name|NULL
expr_stmt|;
name|s
operator|=
operator|-
literal|1
expr_stmt|;
name|savefile
operator|=
name|NULL
expr_stmt|;
name|auth
operator|=
name|location
operator|=
name|message
operator|=
name|NULL
expr_stmt|;
name|ischunked
operator|=
name|isproxy
operator|=
name|hcode
operator|=
literal|0
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
name|uuser
operator|=
name|pass
operator|=
name|host
operator|=
name|path
operator|=
name|decodedpath
operator|=
name|puser
operator|=
name|ppass
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|parse_url
argument_list|(
name|url
argument_list|,
literal|"URL"
argument_list|,
operator|&
name|urltype
argument_list|,
operator|&
name|uuser
argument_list|,
operator|&
name|pass
argument_list|,
operator|&
name|host
argument_list|,
operator|&
name|port
argument_list|,
operator|&
name|portnum
argument_list|,
operator|&
name|path
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|cleanup_fetch_url
goto|;
if|if
condition|(
name|urltype
operator|==
name|FILE_URL_T
operator|&&
operator|!
name|EMPTYSTRING
argument_list|(
name|host
argument_list|)
operator|&&
name|strcasecmp
argument_list|(
name|host
argument_list|,
literal|"localhost"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"No support for non local file URL `%s'"
argument_list|,
name|url
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
if|if
condition|(
name|EMPTYSTRING
argument_list|(
name|path
argument_list|)
condition|)
block|{
if|if
condition|(
name|urltype
operator|==
name|FTP_URL_T
condition|)
block|{
name|rval
operator|=
name|fetch_ftp
argument_list|(
name|url
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
if|if
condition|(
name|urltype
operator|!=
name|HTTP_URL_T
operator|||
name|outfile
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Invalid URL (no file after host) `%s'"
argument_list|,
name|url
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
block|}
name|decodedpath
operator|=
name|ftp_strdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|url_decode
argument_list|(
name|decodedpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|outfile
condition|)
name|savefile
operator|=
name|outfile
expr_stmt|;
else|else
block|{
name|cp
operator|=
name|strrchr
argument_list|(
name|decodedpath
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* find savefile */
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|savefile
operator|=
name|ftp_strdup
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|savefile
operator|=
name|ftp_strdup
argument_list|(
name|decodedpath
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"fetch_url: savefile `%s'\n"
argument_list|,
name|savefile
argument_list|)
expr_stmt|;
if|if
condition|(
name|EMPTYSTRING
argument_list|(
name|savefile
argument_list|)
condition|)
block|{
if|if
condition|(
name|urltype
operator|==
name|FTP_URL_T
condition|)
block|{
name|rval
operator|=
name|fetch_ftp
argument_list|(
name|url
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
name|warnx
argument_list|(
literal|"No file after directory (you must specify an "
literal|"output file) `%s'"
argument_list|,
name|url
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
name|restart_point
operator|=
literal|0
expr_stmt|;
name|filesize
operator|=
operator|-
literal|1
expr_stmt|;
name|rangestart
operator|=
name|rangeend
operator|=
name|entitylen
operator|=
operator|-
literal|1
expr_stmt|;
name|mtime
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|restartautofetch
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|savefile
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
condition|)
name|restart_point
operator|=
name|sb
operator|.
name|st_size
expr_stmt|;
block|}
if|if
condition|(
name|urltype
operator|==
name|FILE_URL_T
condition|)
block|{
comment|/* file:// URLs */
name|direction
operator|=
literal|"copied"
expr_stmt|;
name|fin
operator|=
name|fopen
argument_list|(
name|decodedpath
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fin
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"Can't open `%s'"
argument_list|,
name|decodedpath
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fin
argument_list|)
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mtime
operator|=
name|sb
operator|.
name|st_mtime
expr_stmt|;
name|filesize
operator|=
name|sb
operator|.
name|st_size
expr_stmt|;
block|}
if|if
condition|(
name|restart_point
condition|)
block|{
if|if
condition|(
name|lseek
argument_list|(
name|fileno
argument_list|(
name|fin
argument_list|)
argument_list|,
name|restart_point
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"Can't seek to restart `%s'"
argument_list|,
name|decodedpath
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
block|}
if|if
condition|(
name|verbose
condition|)
block|{
name|fprintf
argument_list|(
name|ttyout
argument_list|,
literal|"Copying %s"
argument_list|,
name|decodedpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|restart_point
condition|)
name|fprintf
argument_list|(
name|ttyout
argument_list|,
literal|" (restarting at "
name|LLF
literal|")"
argument_list|,
operator|(
name|LLT
operator|)
name|restart_point
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|ttyout
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* ftp:// or http:// URLs */
specifier|const
name|char
modifier|*
name|leading
decl_stmt|;
name|int
name|hasleading
decl_stmt|;
if|if
condition|(
name|proxyenv
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|urltype
operator|==
name|HTTP_URL_T
condition|)
name|proxyenv
operator|=
name|getoptionvalue
argument_list|(
literal|"http_proxy"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|urltype
operator|==
name|FTP_URL_T
condition|)
name|proxyenv
operator|=
name|getoptionvalue
argument_list|(
literal|"ftp_proxy"
argument_list|)
expr_stmt|;
block|}
name|direction
operator|=
literal|"retrieved"
expr_stmt|;
if|if
condition|(
operator|!
name|EMPTYSTRING
argument_list|(
name|proxyenv
argument_list|)
condition|)
block|{
comment|/* use proxy */
name|url_t
name|purltype
decl_stmt|;
name|char
modifier|*
name|phost
decl_stmt|,
modifier|*
name|ppath
decl_stmt|;
name|char
modifier|*
name|pport
decl_stmt|,
modifier|*
name|no_proxy
decl_stmt|;
name|in_port_t
name|pportnum
decl_stmt|;
name|isproxy
operator|=
literal|1
expr_stmt|;
comment|/* check URL against list of no_proxied sites */
name|no_proxy
operator|=
name|getoptionvalue
argument_list|(
literal|"no_proxy"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EMPTYSTRING
argument_list|(
name|no_proxy
argument_list|)
condition|)
block|{
name|char
modifier|*
name|np
decl_stmt|,
modifier|*
name|np_copy
decl_stmt|,
modifier|*
name|np_iter
decl_stmt|;
name|unsigned
name|long
name|np_port
decl_stmt|;
name|size_t
name|hlen
decl_stmt|,
name|plen
decl_stmt|;
name|np_iter
operator|=
name|np_copy
operator|=
name|ftp_strdup
argument_list|(
name|no_proxy
argument_list|)
expr_stmt|;
name|hlen
operator|=
name|strlen
argument_list|(
name|host
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cp
operator|=
name|strsep
argument_list|(
operator|&
name|np_iter
argument_list|,
literal|" ,"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
continue|continue;
if|if
condition|(
operator|(
name|np
operator|=
name|strrchr
argument_list|(
name|cp
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|np
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|np_port
operator|=
name|strtoul
argument_list|(
name|np
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|np
operator|==
literal|'\0'
operator|||
operator|*
name|ep
operator|!=
literal|'\0'
condition|)
continue|continue;
if|if
condition|(
name|np_port
operator|!=
name|portnum
condition|)
continue|continue;
block|}
name|plen
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|hlen
operator|<
name|plen
condition|)
continue|continue;
if|if
condition|(
name|strncasecmp
argument_list|(
name|host
operator|+
name|hlen
operator|-
name|plen
argument_list|,
name|cp
argument_list|,
name|plen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|isproxy
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|FREEPTR
argument_list|(
name|np_copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|isproxy
operator|==
literal|0
operator|&&
name|urltype
operator|==
name|FTP_URL_T
condition|)
block|{
name|rval
operator|=
name|fetch_ftp
argument_list|(
name|url
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
block|}
if|if
condition|(
name|isproxy
condition|)
block|{
if|if
condition|(
name|restart_point
condition|)
block|{
name|warnx
argument_list|(
literal|"Can't restart via proxy URL `%s'"
argument_list|,
name|proxyenv
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
if|if
condition|(
name|parse_url
argument_list|(
name|proxyenv
argument_list|,
literal|"proxy URL"
argument_list|,
operator|&
name|purltype
argument_list|,
operator|&
name|puser
argument_list|,
operator|&
name|ppass
argument_list|,
operator|&
name|phost
argument_list|,
operator|&
name|pport
argument_list|,
operator|&
name|pportnum
argument_list|,
operator|&
name|ppath
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|cleanup_fetch_url
goto|;
if|if
condition|(
operator|(
name|purltype
operator|!=
name|HTTP_URL_T
operator|&&
name|purltype
operator|!=
name|FTP_URL_T
operator|)
operator|||
name|EMPTYSTRING
argument_list|(
name|phost
argument_list|)
operator|||
operator|(
operator|!
name|EMPTYSTRING
argument_list|(
name|ppath
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|ppath
argument_list|,
literal|"/"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Malformed proxy URL `%s'"
argument_list|,
name|proxyenv
argument_list|)
expr_stmt|;
name|FREEPTR
argument_list|(
name|phost
argument_list|)
expr_stmt|;
name|FREEPTR
argument_list|(
name|pport
argument_list|)
expr_stmt|;
name|FREEPTR
argument_list|(
name|ppath
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
if|if
condition|(
name|isipv6addr
argument_list|(
name|host
argument_list|)
operator|&&
name|strchr
argument_list|(
name|host
argument_list|,
literal|'%'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Scoped address notation `%s' disallowed via web proxy"
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|FREEPTR
argument_list|(
name|phost
argument_list|)
expr_stmt|;
name|FREEPTR
argument_list|(
name|pport
argument_list|)
expr_stmt|;
name|FREEPTR
argument_list|(
name|ppath
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
name|FREEPTR
argument_list|(
name|host
argument_list|)
expr_stmt|;
name|host
operator|=
name|phost
expr_stmt|;
name|FREEPTR
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|port
operator|=
name|pport
expr_stmt|;
name|FREEPTR
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|path
operator|=
name|ftp_strdup
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|FREEPTR
argument_list|(
name|ppath
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ! EMPTYSTRING(proxyenv) */
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
literal|0
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|family
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|hints
operator|.
name|ai_protocol
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|getaddrinfo
argument_list|(
name|host
argument_list|,
name|port
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|res0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|warnx
argument_list|(
literal|"Can't lookup `%s:%s': %s"
argument_list|,
name|host
argument_list|,
name|port
argument_list|,
operator|(
name|error
operator|==
name|EAI_SYSTEM
operator|)
condition|?
name|strerror
argument_list|(
name|errno
argument_list|)
else|:
name|gai_strerror
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
if|if
condition|(
name|res0
operator|->
name|ai_canonname
condition|)
name|host
operator|=
name|res0
operator|->
name|ai_canonname
expr_stmt|;
name|s
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|res
operator|=
name|res0
init|;
name|res
condition|;
name|res
operator|=
name|res
operator|->
name|ai_next
control|)
block|{
name|char
name|hname
index|[
name|NI_MAXHOST
index|]
decl_stmt|,
name|sname
index|[
name|NI_MAXSERV
index|]
decl_stmt|;
name|ai_unmapped
argument_list|(
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|getnameinfo
argument_list|(
name|res
operator|->
name|ai_addr
argument_list|,
name|res
operator|->
name|ai_addrlen
argument_list|,
name|hname
argument_list|,
sizeof|sizeof
argument_list|(
name|hname
argument_list|)
argument_list|,
name|sname
argument_list|,
sizeof|sizeof
argument_list|(
name|sname
argument_list|)
argument_list|,
name|NI_NUMERICHOST
operator||
name|NI_NUMERICSERV
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|strlcpy
argument_list|(
name|hname
argument_list|,
literal|"?"
argument_list|,
sizeof|sizeof
argument_list|(
name|hname
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|sname
argument_list|,
literal|"?"
argument_list|,
sizeof|sizeof
argument_list|(
name|sname
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
operator|&&
name|res0
operator|->
name|ai_next
condition|)
block|{
name|fprintf
argument_list|(
name|ttyout
argument_list|,
literal|"Trying %s:%s ...\n"
argument_list|,
name|hname
argument_list|,
name|sname
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|socket
argument_list|(
name|res
operator|->
name|ai_family
argument_list|,
name|SOCK_STREAM
argument_list|,
name|res
operator|->
name|ai_protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"Can't create socket for connection to "
literal|"`%s:%s'"
argument_list|,
name|hname
argument_list|,
name|sname
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ftp_connect
argument_list|(
name|s
argument_list|,
name|res
operator|->
name|ai_addr
argument_list|,
name|res
operator|->
name|ai_addrlen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* success */
break|break;
block|}
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Can't connect to `%s:%s'"
argument_list|,
name|host
argument_list|,
name|port
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
name|fin
operator|=
name|fdopen
argument_list|(
name|s
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
comment|/* 		 * Construct and send the request. 		 */
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|ttyout
argument_list|,
literal|"Requesting %s\n"
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|leading
operator|=
literal|"  ("
expr_stmt|;
name|hasleading
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isproxy
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
block|{
name|fprintf
argument_list|(
name|ttyout
argument_list|,
literal|"%svia %s:%s"
argument_list|,
name|leading
argument_list|,
name|host
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|leading
operator|=
literal|", "
expr_stmt|;
name|hasleading
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fin
argument_list|,
literal|"GET %s HTTP/1.0\r\n"
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|flushcache
condition|)
name|fprintf
argument_list|(
name|fin
argument_list|,
literal|"Pragma: no-cache\r\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|fin
argument_list|,
literal|"GET %s HTTP/1.1\r\n"
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|host
argument_list|,
literal|':'
argument_list|)
condition|)
block|{
name|char
modifier|*
name|h
decl_stmt|,
modifier|*
name|p
decl_stmt|;
comment|/* 				 * strip off IPv6 scope identifier, since it is 				 * local to the node 				 */
name|h
operator|=
name|ftp_strdup
argument_list|(
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|isipv6addr
argument_list|(
name|h
argument_list|)
operator|&&
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|h
argument_list|,
literal|'%'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fin
argument_list|,
literal|"Host: [%s]"
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|fin
argument_list|,
literal|"Host: %s"
argument_list|,
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|portnum
operator|!=
name|HTTP_PORT
condition|)
name|fprintf
argument_list|(
name|fin
argument_list|,
literal|":%u"
argument_list|,
name|portnum
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fin
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fin
argument_list|,
literal|"Accept: */*\r\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fin
argument_list|,
literal|"Connection: close\r\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|restart_point
condition|)
block|{
name|fputs
argument_list|(
name|leading
argument_list|,
name|ttyout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fin
argument_list|,
literal|"Range: bytes="
name|LLF
literal|"-\r\n"
argument_list|,
operator|(
name|LLT
operator|)
name|restart_point
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ttyout
argument_list|,
literal|"restarting at "
name|LLF
argument_list|,
operator|(
name|LLT
operator|)
name|restart_point
argument_list|)
expr_stmt|;
name|leading
operator|=
literal|", "
expr_stmt|;
name|hasleading
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|flushcache
condition|)
name|fprintf
argument_list|(
name|fin
argument_list|,
literal|"Cache-Control: no-cache\r\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|useragent
operator|=
name|getenv
argument_list|(
literal|"FTPUSERAGENT"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|fin
argument_list|,
literal|"User-Agent: %s\r\n"
argument_list|,
name|useragent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|fin
argument_list|,
literal|"User-Agent: %s/%s\r\n"
argument_list|,
name|FTP_PRODUCT
argument_list|,
name|FTP_VERSION
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wwwauth
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
block|{
name|fprintf
argument_list|(
name|ttyout
argument_list|,
literal|"%swith authorization"
argument_list|,
name|leading
argument_list|)
expr_stmt|;
name|leading
operator|=
literal|", "
expr_stmt|;
name|hasleading
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fin
argument_list|,
literal|"Authorization: %s\r\n"
argument_list|,
name|wwwauth
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|proxyauth
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
block|{
name|fprintf
argument_list|(
name|ttyout
argument_list|,
literal|"%swith proxy authorization"
argument_list|,
name|leading
argument_list|)
expr_stmt|;
name|leading
operator|=
literal|", "
expr_stmt|;
name|hasleading
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fin
argument_list|,
literal|"Proxy-Authorization: %s\r\n"
argument_list|,
name|proxyauth
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
operator|&&
name|hasleading
condition|)
name|fputs
argument_list|(
literal|")\n"
argument_list|,
name|ttyout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fin
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflush
argument_list|(
name|fin
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|warn
argument_list|(
literal|"Writing HTTP request"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
comment|/* Read the response */
name|len
operator|=
name|get_line
argument_list|(
name|fin
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|&
name|errormsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|errormsg
operator|==
literal|'\n'
condition|)
name|errormsg
operator|++
expr_stmt|;
name|warnx
argument_list|(
literal|"Receiving HTTP reply: %s"
argument_list|,
name|errormsg
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
operator|(
name|ISLWS
argument_list|(
name|buf
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
operator|)
condition|)
name|buf
index|[
operator|--
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"fetch_url: received `%s'\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Determine HTTP response code */
name|cp
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
goto|goto
name|improper
goto|;
else|else
name|cp
operator|++
expr_stmt|;
name|hcode
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ep
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|ep
argument_list|)
condition|)
goto|goto
name|improper
goto|;
name|message
operator|=
name|ftp_strdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* Read the rest of the header. */
while|while
condition|(
literal|1
condition|)
block|{
name|len
operator|=
name|get_line
argument_list|(
name|fin
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|&
name|errormsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|errormsg
operator|==
literal|'\n'
condition|)
name|errormsg
operator|++
expr_stmt|;
name|warnx
argument_list|(
literal|"Receiving HTTP reply: %s"
argument_list|,
name|errormsg
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
operator|(
name|ISLWS
argument_list|(
name|buf
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
operator|)
condition|)
name|buf
index|[
operator|--
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
name|DPRINTF
argument_list|(
literal|"fetch_url: received `%s'\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* 		 * Look for some headers 		 */
name|cp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|match_token
argument_list|(
operator|&
name|cp
argument_list|,
literal|"Content-Length:"
argument_list|)
condition|)
block|{
name|filesize
operator|=
name|STRTOLL
argument_list|(
name|cp
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|filesize
operator|<
literal|0
operator|||
operator|*
name|ep
operator|!=
literal|'\0'
condition|)
goto|goto
name|improper
goto|;
name|DPRINTF
argument_list|(
literal|"fetch_url: parsed len as: "
name|LLF
literal|"\n"
argument_list|,
operator|(
name|LLT
operator|)
name|filesize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|match_token
argument_list|(
operator|&
name|cp
argument_list|,
literal|"Content-Range:"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|match_token
argument_list|(
operator|&
name|cp
argument_list|,
literal|"bytes"
argument_list|)
condition|)
goto|goto
name|improper
goto|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'*'
condition|)
name|cp
operator|++
expr_stmt|;
else|else
block|{
name|rangestart
operator|=
name|STRTOLL
argument_list|(
name|cp
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|rangestart
operator|<
literal|0
operator|||
operator|*
name|ep
operator|!=
literal|'-'
condition|)
goto|goto
name|improper
goto|;
name|cp
operator|=
name|ep
operator|+
literal|1
expr_stmt|;
name|rangeend
operator|=
name|STRTOLL
argument_list|(
name|cp
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|rangeend
operator|<
literal|0
operator|||
name|rangeend
operator|<
name|rangestart
condition|)
goto|goto
name|improper
goto|;
name|cp
operator|=
name|ep
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'/'
condition|)
goto|goto
name|improper
goto|;
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'*'
condition|)
name|cp
operator|++
expr_stmt|;
else|else
block|{
name|entitylen
operator|=
name|STRTOLL
argument_list|(
name|cp
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|entitylen
operator|<
literal|0
condition|)
goto|goto
name|improper
goto|;
name|cp
operator|=
name|ep
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
goto|goto
name|improper
goto|;
ifndef|#
directive|ifndef
name|NO_DEBUG
if|if
condition|(
name|ftp_debug
condition|)
block|{
name|fprintf
argument_list|(
name|ttyout
argument_list|,
literal|"parsed range as: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|rangestart
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|ttyout
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|ttyout
argument_list|,
name|LLF
literal|"-"
name|LLF
argument_list|,
operator|(
name|LLT
operator|)
name|rangestart
argument_list|,
operator|(
name|LLT
operator|)
name|rangeend
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ttyout
argument_list|,
literal|"/"
name|LLF
literal|"\n"
argument_list|,
operator|(
name|LLT
operator|)
name|entitylen
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|restart_point
condition|)
block|{
name|warnx
argument_list|(
literal|"Received unexpected Content-Range header"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|match_token
argument_list|(
operator|&
name|cp
argument_list|,
literal|"Last-Modified:"
argument_list|)
condition|)
block|{
name|struct
name|tm
name|parsed
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|memset
argument_list|(
operator|&
name|parsed
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|parsed
argument_list|)
argument_list|)
expr_stmt|;
comment|/* RFC1123 */
if|if
condition|(
operator|(
name|t
operator|=
name|strptime
argument_list|(
name|cp
argument_list|,
literal|"%a, %d %b %Y %H:%M:%S GMT"
argument_list|,
operator|&
name|parsed
argument_list|)
operator|)
comment|/* RFC0850 */
operator|||
operator|(
name|t
operator|=
name|strptime
argument_list|(
name|cp
argument_list|,
literal|"%a, %d-%b-%y %H:%M:%S GMT"
argument_list|,
operator|&
name|parsed
argument_list|)
operator|)
comment|/* asctime */
operator|||
operator|(
name|t
operator|=
name|strptime
argument_list|(
name|cp
argument_list|,
literal|"%a, %b %d %H:%M:%S %Y"
argument_list|,
operator|&
name|parsed
argument_list|)
operator|)
condition|)
block|{
name|parsed
operator|.
name|tm_isdst
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|'\0'
condition|)
name|mtime
operator|=
name|timegm
argument_list|(
operator|&
name|parsed
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_DEBUG
if|if
condition|(
name|ftp_debug
operator|&&
name|mtime
operator|!=
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|ttyout
argument_list|,
literal|"parsed date as: %s"
argument_list|,
name|rfc2822time
argument_list|(
name|localtime
argument_list|(
operator|&
name|mtime
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
elseif|else
if|if
condition|(
name|match_token
argument_list|(
operator|&
name|cp
argument_list|,
literal|"Location:"
argument_list|)
condition|)
block|{
name|location
operator|=
name|ftp_strdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"fetch_url: parsed location as `%s'\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|match_token
argument_list|(
operator|&
name|cp
argument_list|,
literal|"Transfer-Encoding:"
argument_list|)
condition|)
block|{
if|if
condition|(
name|match_token
argument_list|(
operator|&
name|cp
argument_list|,
literal|"binary"
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Bogus transfer encoding `binary' (fetching anyway)"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|token
operator|=
name|match_token
argument_list|(
operator|&
name|cp
argument_list|,
literal|"chunked"
argument_list|)
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Unsupported transfer encoding `%s'"
argument_list|,
name|token
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
name|ischunked
operator|++
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"fetch_url: using chunked encoding\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|match_token
argument_list|(
operator|&
name|cp
argument_list|,
literal|"Proxy-Authenticate:"
argument_list|)
operator|||
name|match_token
argument_list|(
operator|&
name|cp
argument_list|,
literal|"WWW-Authenticate:"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|token
operator|=
name|match_token
argument_list|(
operator|&
name|cp
argument_list|,
literal|"Basic"
argument_list|)
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"fetch_url: skipping unknown auth scheme `%s'\n"
argument_list|,
name|token
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|FREEPTR
argument_list|(
name|auth
argument_list|)
expr_stmt|;
name|auth
operator|=
name|ftp_strdup
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"fetch_url: parsed auth as `%s'\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* finished parsing header */
switch|switch
condition|(
name|hcode
condition|)
block|{
case|case
literal|200
case|:
break|break;
case|case
literal|206
case|:
if|if
condition|(
operator|!
name|restart_point
condition|)
block|{
name|warnx
argument_list|(
literal|"Not expecting partial content header"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
break|break;
case|case
literal|300
case|:
case|case
literal|301
case|:
case|case
literal|302
case|:
case|case
literal|303
case|:
case|case
literal|305
case|:
case|case
literal|307
case|:
if|if
condition|(
name|EMPTYSTRING
argument_list|(
name|location
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"No redirection Location provided by server"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
if|if
condition|(
name|redirect_loop
operator|++
operator|>
literal|5
condition|)
block|{
name|warnx
argument_list|(
literal|"Too many redirections requested"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
if|if
condition|(
name|hcode
operator|==
literal|305
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|ttyout
argument_list|,
literal|"Redirected via %s\n"
argument_list|,
name|location
argument_list|)
expr_stmt|;
name|rval
operator|=
name|fetch_url
argument_list|(
name|url
argument_list|,
name|location
argument_list|,
name|proxyauth
argument_list|,
name|wwwauth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|ttyout
argument_list|,
literal|"Redirected to %s\n"
argument_list|,
name|location
argument_list|)
expr_stmt|;
name|rval
operator|=
name|go_fetch
argument_list|(
name|location
argument_list|)
expr_stmt|;
block|}
goto|goto
name|cleanup_fetch_url
goto|;
ifndef|#
directive|ifndef
name|NO_AUTH
case|case
literal|401
case|:
case|case
literal|407
case|:
block|{
name|char
modifier|*
modifier|*
name|authp
decl_stmt|;
name|char
modifier|*
name|auser
decl_stmt|,
modifier|*
name|apass
decl_stmt|;
if|if
condition|(
name|hcode
operator|==
literal|401
condition|)
block|{
name|authp
operator|=
operator|&
name|wwwauth
expr_stmt|;
name|auser
operator|=
name|uuser
expr_stmt|;
name|apass
operator|=
name|pass
expr_stmt|;
block|}
else|else
block|{
name|authp
operator|=
operator|&
name|proxyauth
expr_stmt|;
name|auser
operator|=
name|puser
expr_stmt|;
name|apass
operator|=
name|ppass
expr_stmt|;
block|}
if|if
condition|(
name|verbose
operator|||
operator|*
name|authp
operator|==
name|NULL
operator|||
name|auser
operator|==
name|NULL
operator|||
name|apass
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|ttyout
argument_list|,
literal|"%s\n"
argument_list|,
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|EMPTYSTRING
argument_list|(
name|auth
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"No authentication challenge provided by server"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
if|if
condition|(
operator|*
name|authp
operator|!=
name|NULL
condition|)
block|{
name|char
name|reply
index|[
literal|10
index|]
decl_stmt|;
name|fprintf
argument_list|(
name|ttyout
argument_list|,
literal|"Authorization failed. Retry (y/n)? "
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_line
argument_list|(
name|stdin
argument_list|,
name|reply
argument_list|,
sizeof|sizeof
argument_list|(
name|reply
argument_list|)
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
goto|goto
name|cleanup_fetch_url
goto|;
block|}
if|if
condition|(
name|tolower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|reply
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|'y'
condition|)
goto|goto
name|cleanup_fetch_url
goto|;
name|auser
operator|=
name|NULL
expr_stmt|;
name|apass
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|auth_url
argument_list|(
name|auth
argument_list|,
name|authp
argument_list|,
name|auser
argument_list|,
name|apass
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rval
operator|=
name|fetch_url
argument_list|(
name|url
argument_list|,
name|proxyenv
argument_list|,
name|proxyauth
argument_list|,
name|wwwauth
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|*
name|authp
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
operator|*
name|authp
argument_list|)
argument_list|)
expr_stmt|;
name|FREEPTR
argument_list|(
operator|*
name|authp
argument_list|)
expr_stmt|;
block|}
goto|goto
name|cleanup_fetch_url
goto|;
block|}
endif|#
directive|endif
default|default:
if|if
condition|(
name|message
condition|)
name|warnx
argument_list|(
literal|"Error retrieving file `%s'"
argument_list|,
name|message
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
literal|"Unknown error retrieving file"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
block|}
comment|/* end of ftp:// or http:// specific setup */
comment|/* Open the output file. */
comment|/* 	 * Only trust filenames with special meaning if they came from 	 * the command line 	 */
if|if
condition|(
name|outfile
operator|==
name|savefile
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|savefile
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fout
operator|=
name|stdout
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|savefile
operator|==
literal|'|'
condition|)
block|{
name|oldintp
operator|=
name|xsignal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|fout
operator|=
name|popen
argument_list|(
name|savefile
operator|+
literal|1
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fout
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"Can't execute `%s'"
argument_list|,
name|savefile
operator|+
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
name|closefunc
operator|=
name|pclose
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fout
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|rangeend
operator|!=
operator|-
literal|1
operator|&&
name|rangeend
operator|<=
name|restart_point
operator|)
operator|||
operator|(
name|rangestart
operator|==
operator|-
literal|1
operator|&&
name|filesize
operator|!=
operator|-
literal|1
operator|&&
name|filesize
operator|<=
name|restart_point
operator|)
condition|)
block|{
comment|/* already done */
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|ttyout
argument_list|,
literal|"already done\n"
argument_list|)
expr_stmt|;
name|rval
operator|=
literal|0
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
if|if
condition|(
name|restart_point
operator|&&
name|rangestart
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|entitylen
operator|!=
operator|-
literal|1
condition|)
name|filesize
operator|=
name|entitylen
expr_stmt|;
if|if
condition|(
name|rangestart
operator|!=
name|restart_point
condition|)
block|{
name|warnx
argument_list|(
literal|"Size of `%s' differs from save file `%s'"
argument_list|,
name|url
argument_list|,
name|savefile
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
name|fout
operator|=
name|fopen
argument_list|(
name|savefile
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
block|}
else|else
name|fout
operator|=
name|fopen
argument_list|(
name|savefile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fout
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"Can't open `%s'"
argument_list|,
name|savefile
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
name|closefunc
operator|=
name|fclose
expr_stmt|;
block|}
comment|/* Trap signals */
if|if
condition|(
name|sigsetjmp
argument_list|(
name|httpabort
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|cleanup_fetch_url
goto|;
operator|(
name|void
operator|)
name|xsignal
argument_list|(
name|SIGQUIT
argument_list|,
name|psummary
argument_list|)
expr_stmt|;
name|oldintr
operator|=
name|xsignal
argument_list|(
name|SIGINT
argument_list|,
name|aborthttp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|rcvbuf_size
operator|>
name|bufsize
condition|)
block|{
if|if
condition|(
name|xferbuf
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
name|xferbuf
argument_list|)
expr_stmt|;
name|bufsize
operator|=
name|rcvbuf_size
expr_stmt|;
name|xferbuf
operator|=
name|ftp_malloc
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
block|}
name|bytes
operator|=
literal|0
expr_stmt|;
name|hashbytes
operator|=
name|mark
expr_stmt|;
name|progressmeter
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Finally, suck down the file. */
do|do
block|{
name|long
name|chunksize
decl_stmt|;
name|short
name|lastchunk
decl_stmt|;
name|chunksize
operator|=
literal|0
expr_stmt|;
name|lastchunk
operator|=
literal|0
expr_stmt|;
comment|/* read chunk-size */
if|if
condition|(
name|ischunked
condition|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|xferbuf
argument_list|,
name|bufsize
argument_list|,
name|fin
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Unexpected EOF reading chunk-size"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|chunksize
operator|=
name|strtol
argument_list|(
name|xferbuf
argument_list|,
operator|&
name|ep
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|xferbuf
condition|)
block|{
name|warnx
argument_list|(
literal|"Invalid chunk-size"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
if|if
condition|(
name|errno
operator|==
name|ERANGE
operator|||
name|chunksize
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|ERANGE
expr_stmt|;
name|warn
argument_list|(
literal|"Chunk-size `%.*s'"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ep
operator|-
name|xferbuf
argument_list|)
argument_list|,
name|xferbuf
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
comment|/* 				 * XXX:	Work around bug in Apache 1.3.9 and 				 *	1.3.11, which incorrectly put trailing 				 *	space after the chunk-size. 				 */
while|while
condition|(
operator|*
name|ep
operator|==
literal|' '
condition|)
name|ep
operator|++
expr_stmt|;
comment|/* skip [ chunk-ext ] */
if|if
condition|(
operator|*
name|ep
operator|==
literal|';'
condition|)
block|{
while|while
condition|(
operator|*
name|ep
operator|&&
operator|*
name|ep
operator|!=
literal|'\r'
condition|)
name|ep
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|ep
argument_list|,
literal|"\r\n"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Unexpected data following chunk-size"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
name|DPRINTF
argument_list|(
literal|"fetch_url: got chunk-size of "
name|LLF
literal|"\n"
argument_list|,
operator|(
name|LLT
operator|)
name|chunksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunksize
operator|==
literal|0
condition|)
block|{
name|lastchunk
operator|=
literal|1
expr_stmt|;
goto|goto
name|chunkdone
goto|;
block|}
block|}
comment|/* transfer file or chunk */
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|timeval
name|then
decl_stmt|,
name|now
decl_stmt|,
name|td
decl_stmt|;
name|off_t
name|bufrem
decl_stmt|;
if|if
condition|(
name|rate_get
condition|)
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|then
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bufrem
operator|=
name|rate_get
condition|?
name|rate_get
else|:
operator|(
name|off_t
operator|)
name|bufsize
expr_stmt|;
if|if
condition|(
name|ischunked
condition|)
name|bufrem
operator|=
name|MIN
argument_list|(
name|chunksize
argument_list|,
name|bufrem
argument_list|)
expr_stmt|;
while|while
condition|(
name|bufrem
operator|>
literal|0
condition|)
block|{
name|flen
operator|=
name|fread
argument_list|(
name|xferbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|MIN
argument_list|(
operator|(
name|off_t
operator|)
name|bufsize
argument_list|,
name|bufrem
argument_list|)
argument_list|,
name|fin
argument_list|)
expr_stmt|;
if|if
condition|(
name|flen
operator|<=
literal|0
condition|)
goto|goto
name|chunkdone
goto|;
name|bytes
operator|+=
name|flen
expr_stmt|;
name|bufrem
operator|-=
name|flen
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|xferbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|flen
argument_list|,
name|fout
argument_list|)
operator|!=
name|flen
condition|)
block|{
name|warn
argument_list|(
literal|"Writing `%s'"
argument_list|,
name|savefile
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
if|if
condition|(
name|hash
operator|&&
operator|!
name|progress
condition|)
block|{
while|while
condition|(
name|bytes
operator|>=
name|hashbytes
condition|)
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'#'
argument_list|,
name|ttyout
argument_list|)
expr_stmt|;
name|hashbytes
operator|+=
name|mark
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|ttyout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ischunked
condition|)
block|{
name|chunksize
operator|-=
name|flen
expr_stmt|;
if|if
condition|(
name|chunksize
operator|<=
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|rate_get
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|now
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|timersub
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|then
argument_list|,
operator|&
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|.
name|tv_sec
operator|>
literal|0
condition|)
break|break;
name|usleep
argument_list|(
literal|1000000
operator|-
name|td
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ischunked
operator|&&
name|chunksize
operator|<=
literal|0
condition|)
break|break;
block|}
comment|/* read CRLF after chunk*/
name|chunkdone
label|:
if|if
condition|(
name|ischunked
condition|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|xferbuf
argument_list|,
name|bufsize
argument_list|,
name|fin
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Unexpected EOF reading chunk CRLF"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|xferbuf
argument_list|,
literal|"\r\n"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Unexpected data following chunk"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
if|if
condition|(
name|lastchunk
condition|)
break|break;
block|}
block|}
do|while
condition|(
name|ischunked
condition|)
do|;
comment|/* XXX: deal with optional trailer& CRLF here? */
if|if
condition|(
name|hash
operator|&&
operator|!
name|progress
operator|&&
name|bytes
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|bytes
operator|<
name|mark
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'#'
argument_list|,
name|ttyout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ttyout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|fin
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"Reading file"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
block|}
name|progressmeter
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|fout
argument_list|)
expr_stmt|;
if|if
condition|(
name|closefunc
operator|==
name|fclose
operator|&&
name|mtime
operator|!=
operator|-
literal|1
condition|)
block|{
name|struct
name|timeval
name|tval
index|[
literal|2
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tval
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tval
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|mtime
expr_stmt|;
name|tval
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
call|(
modifier|*
name|closefunc
call|)
argument_list|(
name|fout
argument_list|)
expr_stmt|;
name|fout
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|utimes
argument_list|(
name|savefile
argument_list|,
name|tval
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|ttyout
argument_list|,
literal|"Can't change modification time to %s"
argument_list|,
name|rfc2822time
argument_list|(
name|localtime
argument_list|(
operator|&
name|mtime
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bytes
operator|>
literal|0
condition|)
name|ptransfer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bytes
operator|=
literal|0
expr_stmt|;
name|rval
operator|=
literal|0
expr_stmt|;
goto|goto
name|cleanup_fetch_url
goto|;
name|improper
label|:
name|warnx
argument_list|(
literal|"Improper response from `%s:%s'"
argument_list|,
name|host
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|cleanup_fetch_url
label|:
if|if
condition|(
name|oldintr
condition|)
operator|(
name|void
operator|)
name|xsignal
argument_list|(
name|SIGINT
argument_list|,
name|oldintr
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldintp
condition|)
operator|(
name|void
operator|)
name|xsignal
argument_list|(
name|SIGPIPE
argument_list|,
name|oldintp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fin
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|fin
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|closefunc
operator|!=
name|NULL
operator|&&
name|fout
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|closefunc
call|)
argument_list|(
name|fout
argument_list|)
expr_stmt|;
if|if
condition|(
name|res0
condition|)
name|freeaddrinfo
argument_list|(
name|res0
argument_list|)
expr_stmt|;
if|if
condition|(
name|savefile
operator|!=
name|outfile
condition|)
name|FREEPTR
argument_list|(
name|savefile
argument_list|)
expr_stmt|;
name|FREEPTR
argument_list|(
name|uuser
argument_list|)
expr_stmt|;
if|if
condition|(
name|pass
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
name|pass
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|pass
argument_list|)
argument_list|)
expr_stmt|;
name|FREEPTR
argument_list|(
name|pass
argument_list|)
expr_stmt|;
name|FREEPTR
argument_list|(
name|host
argument_list|)
expr_stmt|;
name|FREEPTR
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|FREEPTR
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|FREEPTR
argument_list|(
name|decodedpath
argument_list|)
expr_stmt|;
name|FREEPTR
argument_list|(
name|puser
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppass
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
name|ppass
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|ppass
argument_list|)
argument_list|)
expr_stmt|;
name|FREEPTR
argument_list|(
name|ppass
argument_list|)
expr_stmt|;
name|FREEPTR
argument_list|(
name|auth
argument_list|)
expr_stmt|;
name|FREEPTR
argument_list|(
name|location
argument_list|)
expr_stmt|;
name|FREEPTR
argument_list|(
name|message
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Abort a HTTP retrieval  */
end_comment

begin_function
name|void
name|aborthttp
parameter_list|(
name|int
name|notused
parameter_list|)
block|{
name|char
name|msgbuf
index|[
literal|100
index|]
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|sigint_raised
operator|=
literal|1
expr_stmt|;
name|alarmtimer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlcpy
argument_list|(
name|msgbuf
argument_list|,
literal|"\nHTTP fetch aborted.\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fileno
argument_list|(
name|ttyout
argument_list|)
argument_list|,
name|msgbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|siglongjmp
argument_list|(
name|httpabort
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Retrieve ftp URL or classic ftp argument using FTP.  * Returns 1 on failure, 0 on completed xfer, -1 if ftp connection  * is still open (e.g, ftp xfer with trailing /)  */
end_comment

begin_function
specifier|static
name|int
name|fetch_ftp
parameter_list|(
specifier|const
name|char
modifier|*
name|url
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|xargv
index|[
literal|5
index|]
decl_stmt|,
name|rempath
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
modifier|*
name|host
decl_stmt|,
modifier|*
name|path
decl_stmt|,
modifier|*
name|dir
decl_stmt|,
modifier|*
name|file
decl_stmt|,
modifier|*
name|uuser
decl_stmt|,
modifier|*
name|pass
decl_stmt|;
name|char
modifier|*
name|port
decl_stmt|;
name|char
name|cmdbuf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|dirbuf
index|[
literal|4
index|]
decl_stmt|;
name|int
name|dirhasglob
decl_stmt|,
name|filehasglob
decl_stmt|,
name|rval
decl_stmt|,
name|transtype
decl_stmt|,
name|xargc
decl_stmt|;
name|int
name|oanonftp
decl_stmt|,
name|oautologin
decl_stmt|;
name|in_port_t
name|portnum
decl_stmt|;
name|url_t
name|urltype
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"fetch_ftp: `%s'\n"
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|host
operator|=
name|path
operator|=
name|dir
operator|=
name|file
operator|=
name|uuser
operator|=
name|pass
operator|=
name|NULL
expr_stmt|;
name|port
operator|=
name|NULL
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
name|transtype
operator|=
name|TYPE_I
expr_stmt|;
if|if
condition|(
name|STRNEQUAL
argument_list|(
name|url
argument_list|,
name|FTP_URL
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|parse_url
argument_list|(
name|url
argument_list|,
literal|"URL"
argument_list|,
operator|&
name|urltype
argument_list|,
operator|&
name|uuser
argument_list|,
operator|&
name|pass
argument_list|,
operator|&
name|host
argument_list|,
operator|&
name|port
argument_list|,
operator|&
name|portnum
argument_list|,
operator|&
name|path
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|uuser
operator|!=
name|NULL
operator|&&
operator|*
name|uuser
operator|==
literal|'\0'
operator|)
operator|||
name|EMPTYSTRING
argument_list|(
name|host
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Invalid URL `%s'"
argument_list|,
name|url
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_ftp
goto|;
block|}
comment|/* 		 * Note: Don't url_decode(path) here.  We need to keep the 		 * distinction between "/" and "%2F" until later. 		 */
comment|/* check for trailing ';type=[aid]' */
if|if
condition|(
operator|!
name|EMPTYSTRING
argument_list|(
name|path
argument_list|)
operator|&&
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|';'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|cp
argument_list|,
literal|";type=a"
argument_list|)
operator|==
literal|0
condition|)
name|transtype
operator|=
name|TYPE_A
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|cp
argument_list|,
literal|";type=i"
argument_list|)
operator|==
literal|0
condition|)
name|transtype
operator|=
name|TYPE_I
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|cp
argument_list|,
literal|";type=d"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Directory listing via a URL is not supported"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_ftp
goto|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"Invalid suffix `%s' in URL `%s'"
argument_list|,
name|cp
argument_list|,
name|url
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_ftp
goto|;
block|}
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* classic style `[user@]host:[file]' */
name|urltype
operator|=
name|CLASSIC_URL_T
expr_stmt|;
name|host
operator|=
name|ftp_strdup
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|host
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|uuser
operator|=
name|host
expr_stmt|;
name|anonftp
operator|=
literal|0
expr_stmt|;
comment|/* disable anonftp */
name|host
operator|=
name|ftp_strdup
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|strchr
argument_list|(
name|host
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|path
operator|=
name|ftp_strdup
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|EMPTYSTRING
argument_list|(
name|host
argument_list|)
condition|)
goto|goto
name|cleanup_fetch_ftp
goto|;
comment|/* Extract the file and (if present) directory name. */
name|dir
operator|=
name|path
expr_stmt|;
if|if
condition|(
operator|!
name|EMPTYSTRING
argument_list|(
name|dir
argument_list|)
condition|)
block|{
comment|/* 		 * If we are dealing with classic `[user@]host:[path]' syntax, 		 * then a path of the form `/file' (resulting from input of the 		 * form `host:/file') means that we should do "CWD /" before 		 * retrieving the file.  So we set dir="/" and file="file". 		 * 		 * But if we are dealing with URLs like `ftp://host/path' then 		 * a path of the form `/file' (resulting from a URL of the form 		 * `ftp://host//file') means that we should do `CWD ' (with an 		 * empty argument) before retrieving the file.  So we set 		 * dir="" and file="file". 		 * 		 * If the path does not contain / at all, we set dir=NULL. 		 * (We get a path without any slashes if we are dealing with 		 * classic `[user@]host:[file]' or URL `ftp://host/file'.) 		 * 		 * In all other cases, we set dir to a string that does not 		 * include the final '/' that separates the dir part from the 		 * file part of the path.  (This will be the empty string if 		 * and only if we are dealing with a path of the form `/file' 		 * resulting from an URL of the form `ftp://host//file'.) 		 */
name|cp
operator|=
name|strrchr
argument_list|(
name|dir
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|dir
operator|&&
name|urltype
operator|==
name|CLASSIC_URL_T
condition|)
block|{
name|file
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|dirbuf
argument_list|,
literal|"/"
argument_list|,
sizeof|sizeof
argument_list|(
name|dirbuf
argument_list|)
argument_list|)
expr_stmt|;
name|dir
operator|=
name|dirbuf
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|file
operator|=
name|cp
expr_stmt|;
block|}
else|else
block|{
name|file
operator|=
name|dir
expr_stmt|;
name|dir
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
name|dir
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|urltype
operator|==
name|FTP_URL_T
operator|&&
name|file
operator|!=
name|NULL
condition|)
block|{
name|url_decode
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* but still don't url_decode(dir) */
block|}
name|DPRINTF
argument_list|(
literal|"fetch_ftp: user `%s' pass `%s' host %s port %s "
literal|"path `%s' dir `%s' file `%s'\n"
argument_list|,
name|STRorNULL
argument_list|(
name|uuser
argument_list|)
argument_list|,
name|STRorNULL
argument_list|(
name|pass
argument_list|)
argument_list|,
name|STRorNULL
argument_list|(
name|host
argument_list|)
argument_list|,
name|STRorNULL
argument_list|(
name|port
argument_list|)
argument_list|,
name|STRorNULL
argument_list|(
name|path
argument_list|)
argument_list|,
name|STRorNULL
argument_list|(
name|dir
argument_list|)
argument_list|,
name|STRorNULL
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|dirhasglob
operator|=
name|filehasglob
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|doglob
operator|&&
name|urltype
operator|==
name|CLASSIC_URL_T
condition|)
block|{
if|if
condition|(
operator|!
name|EMPTYSTRING
argument_list|(
name|dir
argument_list|)
operator|&&
name|strpbrk
argument_list|(
name|dir
argument_list|,
literal|"*?[]{}"
argument_list|)
operator|!=
name|NULL
condition|)
name|dirhasglob
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|EMPTYSTRING
argument_list|(
name|file
argument_list|)
operator|&&
name|strpbrk
argument_list|(
name|file
argument_list|,
literal|"*?[]{}"
argument_list|)
operator|!=
name|NULL
condition|)
name|filehasglob
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Set up the connection */
name|oanonftp
operator|=
name|anonftp
expr_stmt|;
if|if
condition|(
name|connected
condition|)
name|disconnect
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|anonftp
operator|=
name|oanonftp
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|cmdbuf
argument_list|,
name|getprogname
argument_list|()
argument_list|,
sizeof|sizeof
argument_list|(
name|cmdbuf
argument_list|)
argument_list|)
expr_stmt|;
name|xargv
index|[
literal|0
index|]
operator|=
name|cmdbuf
expr_stmt|;
name|xargv
index|[
literal|1
index|]
operator|=
name|host
expr_stmt|;
name|xargv
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
name|xargc
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|port
condition|)
block|{
name|xargv
index|[
literal|2
index|]
operator|=
name|port
expr_stmt|;
name|xargv
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
name|xargc
operator|=
literal|3
expr_stmt|;
block|}
name|oautologin
operator|=
name|autologin
expr_stmt|;
comment|/* don't autologin in setpeer(), use ftp_login() below */
name|autologin
operator|=
literal|0
expr_stmt|;
name|setpeer
argument_list|(
name|xargc
argument_list|,
name|xargv
argument_list|)
expr_stmt|;
name|autologin
operator|=
name|oautologin
expr_stmt|;
if|if
condition|(
operator|(
name|connected
operator|==
literal|0
operator|)
operator|||
operator|(
name|connected
operator|==
literal|1
operator|&&
operator|!
name|ftp_login
argument_list|(
name|host
argument_list|,
name|uuser
argument_list|,
name|pass
argument_list|)
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Can't connect or login to host `%s:%s'"
argument_list|,
name|host
argument_list|,
name|port
condition|?
name|port
else|:
literal|"?"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_ftp
goto|;
block|}
switch|switch
condition|(
name|transtype
condition|)
block|{
case|case
name|TYPE_A
case|:
name|setascii
argument_list|(
literal|1
argument_list|,
name|xargv
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_I
case|:
name|setbinary
argument_list|(
literal|1
argument_list|,
name|xargv
argument_list|)
expr_stmt|;
break|break;
default|default:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"fetch_ftp: unknown transfer type %d"
argument_list|,
name|transtype
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Change directories, if necessary. 		 * 		 * Note: don't use EMPTYSTRING(dir) below, because 		 * dir=="" means something different from dir==NULL. 		 */
if|if
condition|(
name|dir
operator|!=
name|NULL
operator|&&
operator|!
name|dirhasglob
condition|)
block|{
name|char
modifier|*
name|nextpart
decl_stmt|;
comment|/* 		 * If we are dealing with a classic `[user@]host:[path]' 		 * (urltype is CLASSIC_URL_T) then we have a raw directory 		 * name (not encoded in any way) and we can change 		 * directories in one step. 		 * 		 * If we are dealing with an `ftp://host/path' URL 		 * (urltype is FTP_URL_T), then RFC3986 says we need to 		 * send a separate CWD command for each unescaped "/" 		 * in the path, and we have to interpret %hex escaping 		 * *after* we find the slashes.  It's possible to get 		 * empty components here, (from multiple adjacent 		 * slashes in the path) and RFC3986 says that we should 		 * still do `CWD ' (with a null argument) in such cases. 		 * 		 * Many ftp servers don't support `CWD ', so if there's an 		 * error performing that command, bail out with a descriptive 		 * message. 		 * 		 * Examples: 		 * 		 * host:			dir="", urltype=CLASSIC_URL_T 		 *		logged in (to default directory) 		 * host:file			dir=NULL, urltype=CLASSIC_URL_T 		 *		"RETR file" 		 * host:dir/			dir="dir", urltype=CLASSIC_URL_T 		 *		"CWD dir", logged in 		 * ftp://host/			dir="", urltype=FTP_URL_T 		 *		logged in (to default directory) 		 * ftp://host/dir/		dir="dir", urltype=FTP_URL_T 		 *		"CWD dir", logged in 		 * ftp://host/file		dir=NULL, urltype=FTP_URL_T 		 *		"RETR file" 		 * ftp://host//file		dir="", urltype=FTP_URL_T 		 *		"CWD ", "RETR file" 		 * host:/file			dir="/", urltype=CLASSIC_URL_T 		 *		"CWD /", "RETR file" 		 * ftp://host///file		dir="/", urltype=FTP_URL_T 		 *		"CWD ", "CWD ", "RETR file" 		 * ftp://host/%2F/file		dir="%2F", urltype=FTP_URL_T 		 *		"CWD /", "RETR file" 		 * ftp://host/foo/file		dir="foo", urltype=FTP_URL_T 		 *		"CWD foo", "RETR file" 		 * ftp://host/foo/bar/file	dir="foo/bar" 		 *		"CWD foo", "CWD bar", "RETR file" 		 * ftp://host//foo/bar/file	dir="/foo/bar" 		 *		"CWD ", "CWD foo", "CWD bar", "RETR file" 		 * ftp://host/foo//bar/file	dir="foo//bar" 		 *		"CWD foo", "CWD ", "CWD bar", "RETR file" 		 * ftp://host/%2F/foo/bar/file	dir="%2F/foo/bar" 		 *		"CWD /", "CWD foo", "CWD bar", "RETR file" 		 * ftp://host/%2Ffoo/bar/file	dir="%2Ffoo/bar" 		 *		"CWD /foo", "CWD bar", "RETR file" 		 * ftp://host/%2Ffoo%2Fbar/file	dir="%2Ffoo%2Fbar" 		 *		"CWD /foo/bar", "RETR file" 		 * ftp://host/%2Ffoo%2Fbar%2Ffile	dir=NULL 		 *		"RETR /foo/bar/file" 		 * 		 * Note that we don't need `dir' after this point. 		 */
do|do
block|{
if|if
condition|(
name|urltype
operator|==
name|FTP_URL_T
condition|)
block|{
name|nextpart
operator|=
name|strchr
argument_list|(
name|dir
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextpart
condition|)
block|{
operator|*
name|nextpart
operator|=
literal|'\0'
expr_stmt|;
name|nextpart
operator|++
expr_stmt|;
block|}
name|url_decode
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
else|else
name|nextpart
operator|=
name|NULL
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"fetch_ftp: dir `%s', nextpart `%s'\n"
argument_list|,
name|STRorNULL
argument_list|(
name|dir
argument_list|)
argument_list|,
name|STRorNULL
argument_list|(
name|nextpart
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|urltype
operator|==
name|FTP_URL_T
operator|||
operator|*
name|dir
operator|!=
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|cmdbuf
argument_list|,
literal|"cd"
argument_list|,
sizeof|sizeof
argument_list|(
name|cmdbuf
argument_list|)
argument_list|)
expr_stmt|;
name|xargv
index|[
literal|0
index|]
operator|=
name|cmdbuf
expr_stmt|;
name|xargv
index|[
literal|1
index|]
operator|=
name|dir
expr_stmt|;
name|xargv
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
name|dirchange
operator|=
literal|0
expr_stmt|;
name|cd
argument_list|(
literal|2
argument_list|,
name|xargv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dirchange
condition|)
block|{
if|if
condition|(
operator|*
name|dir
operator|==
literal|'\0'
operator|&&
name|code
operator|==
literal|500
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
literal|"ftp: The `CWD ' command (without a directory), which is required by\n"
literal|"     RFC3986 to support the empty directory in the URL pathname (`//'),\n"
literal|"     conflicts with the server's conformance to RFC0959.\n"
literal|"     Try the same URL without the `//' in the URL pathname.\n"
literal|"\n"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_fetch_ftp
goto|;
block|}
block|}
name|dir
operator|=
name|nextpart
expr_stmt|;
block|}
do|while
condition|(
name|dir
operator|!=
name|NULL
condition|)
do|;
block|}
if|if
condition|(
name|EMPTYSTRING
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|cleanup_fetch_ftp
goto|;
block|}
if|if
condition|(
name|dirhasglob
condition|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|rempath
argument_list|,
name|dir
argument_list|,
sizeof|sizeof
argument_list|(
name|rempath
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|rempath
argument_list|,
literal|"/"
argument_list|,
sizeof|sizeof
argument_list|(
name|rempath
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|rempath
argument_list|,
name|file
argument_list|,
sizeof|sizeof
argument_list|(
name|rempath
argument_list|)
argument_list|)
expr_stmt|;
name|file
operator|=
name|rempath
expr_stmt|;
block|}
comment|/* Fetch the file(s). */
name|xargc
operator|=
literal|2
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|cmdbuf
argument_list|,
literal|"get"
argument_list|,
sizeof|sizeof
argument_list|(
name|cmdbuf
argument_list|)
argument_list|)
expr_stmt|;
name|xargv
index|[
literal|0
index|]
operator|=
name|cmdbuf
expr_stmt|;
name|xargv
index|[
literal|1
index|]
operator|=
name|file
expr_stmt|;
name|xargv
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dirhasglob
operator|||
name|filehasglob
condition|)
block|{
name|int
name|ointeractive
decl_stmt|;
name|ointeractive
operator|=
name|interactive
expr_stmt|;
name|interactive
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|restartautofetch
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|cmdbuf
argument_list|,
literal|"mreget"
argument_list|,
sizeof|sizeof
argument_list|(
name|cmdbuf
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|cmdbuf
argument_list|,
literal|"mget"
argument_list|,
sizeof|sizeof
argument_list|(
name|cmdbuf
argument_list|)
argument_list|)
expr_stmt|;
name|xargv
index|[
literal|0
index|]
operator|=
name|cmdbuf
expr_stmt|;
name|mget
argument_list|(
name|xargc
argument_list|,
name|xargv
argument_list|)
expr_stmt|;
name|interactive
operator|=
name|ointeractive
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|outfile
operator|==
name|NULL
condition|)
block|{
name|cp
operator|=
name|strrchr
argument_list|(
name|file
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* find savefile */
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|outfile
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
else|else
name|outfile
operator|=
name|file
expr_stmt|;
block|}
name|xargv
index|[
literal|2
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|outfile
expr_stmt|;
name|xargv
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
name|xargc
operator|++
expr_stmt|;
if|if
condition|(
name|restartautofetch
condition|)
name|reget
argument_list|(
name|xargc
argument_list|,
name|xargv
argument_list|)
expr_stmt|;
else|else
name|get
argument_list|(
name|xargc
argument_list|,
name|xargv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|code
operator|/
literal|100
operator|)
operator|==
name|COMPLETE
condition|)
name|rval
operator|=
literal|0
expr_stmt|;
name|cleanup_fetch_ftp
label|:
name|FREEPTR
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|FREEPTR
argument_list|(
name|host
argument_list|)
expr_stmt|;
name|FREEPTR
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|FREEPTR
argument_list|(
name|uuser
argument_list|)
expr_stmt|;
if|if
condition|(
name|pass
condition|)
name|memset
argument_list|(
name|pass
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|pass
argument_list|)
argument_list|)
expr_stmt|;
name|FREEPTR
argument_list|(
name|pass
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve the given file to outfile.  * Supports arguments of the form:  *	"host:path", "ftp://host/path"	if $ftpproxy, call fetch_url() else  *					call fetch_ftp()  *	"http://host/path"		call fetch_url() to use HTTP  *	"file:///path"			call fetch_url() to copy  *	"about:..."			print a message  *  * Returns 1 on failure, 0 on completed xfer, -1 if ftp connection  * is still open (e.g, ftp xfer with trailing /)  */
end_comment

begin_function
specifier|static
name|int
name|go_fetch
parameter_list|(
specifier|const
name|char
modifier|*
name|url
parameter_list|)
block|{
name|char
modifier|*
name|proxyenv
decl_stmt|;
ifndef|#
directive|ifndef
name|NO_ABOUT
comment|/* 	 * Check for about:* 	 */
if|if
condition|(
name|STRNEQUAL
argument_list|(
name|url
argument_list|,
name|ABOUT_URL
argument_list|)
condition|)
block|{
name|url
operator|+=
sizeof|sizeof
argument_list|(
name|ABOUT_URL
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|url
argument_list|,
literal|"ftp"
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
name|url
argument_list|,
literal|"tnftp"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|"This version of ftp has been enhanced by Luke Mewburn<lukem@NetBSD.org>\n"
literal|"for the NetBSD project.  Execute `man ftp' for more details.\n"
argument_list|,
name|ttyout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|url
argument_list|,
literal|"lukem"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|"Luke Mewburn is the author of most of the enhancements in this ftp client.\n"
literal|"Please email feedback to<lukem@NetBSD.org>.\n"
argument_list|,
name|ttyout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|url
argument_list|,
literal|"netbsd"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|"NetBSD is a freely available and redistributable UNIX-like operating system.\n"
literal|"For more information, see http://www.NetBSD.org/\n"
argument_list|,
name|ttyout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|url
argument_list|,
literal|"version"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|ttyout
argument_list|,
literal|"Version: %s %s%s\n"
argument_list|,
name|FTP_PRODUCT
argument_list|,
name|FTP_VERSION
argument_list|,
ifdef|#
directive|ifdef
name|INET6
literal|""
else|#
directive|else
literal|" (-IPv6)"
endif|#
directive|endif
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|ttyout
argument_list|,
literal|"`%s' is an interesting topic.\n"
argument_list|,
name|url
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|ttyout
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* 	 * Check for file:// and http:// URLs. 	 */
if|if
condition|(
name|STRNEQUAL
argument_list|(
name|url
argument_list|,
name|HTTP_URL
argument_list|)
operator|||
name|STRNEQUAL
argument_list|(
name|url
argument_list|,
name|FILE_URL
argument_list|)
condition|)
return|return
operator|(
name|fetch_url
argument_list|(
name|url
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
comment|/* 	 * Try FTP URL-style and host:file arguments next. 	 * If ftpproxy is set with an FTP URL, use fetch_url() 	 * Othewise, use fetch_ftp(). 	 */
name|proxyenv
operator|=
name|getoptionvalue
argument_list|(
literal|"ftp_proxy"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EMPTYSTRING
argument_list|(
name|proxyenv
argument_list|)
operator|&&
name|STRNEQUAL
argument_list|(
name|url
argument_list|,
name|FTP_URL
argument_list|)
condition|)
return|return
operator|(
name|fetch_url
argument_list|(
name|url
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
return|return
operator|(
name|fetch_ftp
argument_list|(
name|url
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve multiple files from the command line,  * calling go_fetch() for each file.  *  * If an ftp path has a trailing "/", the path will be cd-ed into and  * the connection remains open, and the function will return -1  * (to indicate the connection is alive).  * If an error occurs the return value will be the offset+1 in  * argv[] of the file that caused a problem (i.e, argv[x]  * returns x+1)  * Otherwise, 0 is returned if all files retrieved successfully.  */
end_comment

begin_function
name|int
name|auto_fetch
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
specifier|volatile
name|int
name|argpos
decl_stmt|,
name|rval
decl_stmt|;
name|argpos
operator|=
name|rval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sigsetjmp
argument_list|(
name|toplevel
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|connected
condition|)
name|disconnect
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|>
literal|0
condition|)
name|rval
operator|=
name|argpos
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|xsignal
argument_list|(
name|SIGINT
argument_list|,
name|intr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xsignal
argument_list|(
name|SIGPIPE
argument_list|,
name|lostpeer
argument_list|)
expr_stmt|;
comment|/* 	 * Loop through as long as there's files to fetch. 	 */
for|for
control|(
init|;
operator|(
name|rval
operator|==
literal|0
operator|)
operator|&&
operator|(
name|argpos
operator|<
name|argc
operator|)
condition|;
name|argpos
operator|++
control|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|argv
index|[
name|argpos
index|]
argument_list|,
literal|':'
argument_list|)
operator|==
name|NULL
condition|)
break|break;
name|redirect_loop
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|anonftp
condition|)
name|anonftp
operator|=
literal|2
expr_stmt|;
comment|/* Handle "automatic" transfers. */
name|rval
operator|=
name|go_fetch
argument_list|(
name|argv
index|[
name|argpos
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|outfile
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|outfile
argument_list|,
literal|"-"
argument_list|)
operator|!=
literal|0
operator|&&
name|outfile
index|[
literal|0
index|]
operator|!=
literal|'|'
condition|)
name|outfile
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rval
operator|>
literal|0
condition|)
name|rval
operator|=
name|argpos
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|connected
operator|&&
name|rval
operator|!=
operator|-
literal|1
condition|)
name|disconnect
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Upload multiple files from the command line.  *  * If an error occurs the return value will be the offset+1 in  * argv[] of the file that caused a problem (i.e, argv[x]  * returns x+1)  * Otherwise, 0 is returned if all files uploaded successfully.  */
end_comment

begin_function
name|int
name|auto_put
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|uploadserver
parameter_list|)
block|{
name|char
modifier|*
name|uargv
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|path
decl_stmt|,
modifier|*
name|pathsep
decl_stmt|;
name|int
name|uargc
decl_stmt|,
name|rval
decl_stmt|,
name|argpos
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
name|cmdbuf
index|[
name|MAX_C_NAME
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|cmdbuf
argument_list|,
literal|"mput"
argument_list|,
sizeof|sizeof
argument_list|(
name|cmdbuf
argument_list|)
argument_list|)
expr_stmt|;
name|uargv
index|[
literal|0
index|]
operator|=
name|cmdbuf
expr_stmt|;
name|uargv
index|[
literal|1
index|]
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|uargc
operator|=
literal|2
expr_stmt|;
name|uargv
index|[
literal|2
index|]
operator|=
name|uargv
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
name|pathsep
operator|=
name|NULL
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"auto_put: target `%s'\n"
argument_list|,
name|uploadserver
argument_list|)
expr_stmt|;
name|path
operator|=
name|ftp_strdup
argument_list|(
name|uploadserver
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|&&
name|path
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|':'
condition|)
block|{
comment|/* 			 * make sure we always pass a directory to auto_fetch 			 */
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
comment|/* more than one file to upload */
name|len
operator|=
name|strlen
argument_list|(
name|uploadserver
argument_list|)
operator|+
literal|2
expr_stmt|;
comment|/* path + "/" + "\0" */
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|ftp_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|path
argument_list|,
name|uploadserver
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|path
argument_list|,
literal|"/"
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* single file to upload */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|cmdbuf
argument_list|,
literal|"put"
argument_list|,
sizeof|sizeof
argument_list|(
name|cmdbuf
argument_list|)
argument_list|)
expr_stmt|;
name|uargv
index|[
literal|0
index|]
operator|=
name|cmdbuf
expr_stmt|;
name|pathsep
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pathsep
operator|==
name|NULL
condition|)
block|{
name|pathsep
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pathsep
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Invalid URL `%s'"
argument_list|,
name|path
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_auto_put
goto|;
block|}
name|pathsep
operator|++
expr_stmt|;
name|uargv
index|[
literal|2
index|]
operator|=
name|ftp_strdup
argument_list|(
name|pathsep
argument_list|)
expr_stmt|;
name|pathsep
index|[
literal|0
index|]
operator|=
literal|'/'
expr_stmt|;
block|}
else|else
name|uargv
index|[
literal|2
index|]
operator|=
name|ftp_strdup
argument_list|(
name|pathsep
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pathsep
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|uargc
operator|++
expr_stmt|;
block|}
block|}
name|DPRINTF
argument_list|(
literal|"auto_put: URL `%s' argv[2] `%s'\n"
argument_list|,
name|path
argument_list|,
name|STRorNULL
argument_list|(
name|uargv
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* connect and cwd */
name|rval
operator|=
name|auto_fetch
argument_list|(
literal|1
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|>=
literal|0
condition|)
goto|goto
name|cleanup_auto_put
goto|;
name|rval
operator|=
literal|0
expr_stmt|;
comment|/* target filename provided; upload 1 file */
comment|/* XXX : is this the best way? */
if|if
condition|(
name|uargc
operator|==
literal|3
condition|)
block|{
name|uargv
index|[
literal|1
index|]
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|put
argument_list|(
name|uargc
argument_list|,
name|uargv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|/
literal|100
operator|)
operator|!=
name|COMPLETE
condition|)
name|rval
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* otherwise a target dir: upload all files to it */
for|for
control|(
name|argpos
operator|=
literal|0
init|;
name|argv
index|[
name|argpos
index|]
operator|!=
name|NULL
condition|;
name|argpos
operator|++
control|)
block|{
name|uargv
index|[
literal|1
index|]
operator|=
name|argv
index|[
name|argpos
index|]
expr_stmt|;
name|mput
argument_list|(
name|uargc
argument_list|,
name|uargv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|/
literal|100
operator|)
operator|!=
name|COMPLETE
condition|)
block|{
name|rval
operator|=
name|argpos
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
name|cleanup_auto_put
label|:
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|FREEPTR
argument_list|(
name|uargv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

end_unit

