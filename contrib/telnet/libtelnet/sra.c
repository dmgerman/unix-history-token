begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SRA
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<arpa/telnet.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NOPAM
argument_list|)
end_if

begin_include
include|#
directive|include
file|<security/pam_appl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<ttyent.h>
end_include

begin_include
include|#
directive|include
file|"auth.h"
end_include

begin_include
include|#
directive|include
file|"misc.h"
end_include

begin_include
include|#
directive|include
file|"encrypt.h"
end_include

begin_include
include|#
directive|include
file|"pk.h"
end_include

begin_decl_stmt
name|char
name|pka
index|[
name|HEXKEYBYTES
operator|+
literal|1
index|]
decl_stmt|,
name|ska
index|[
name|HEXKEYBYTES
operator|+
literal|1
index|]
decl_stmt|,
name|pkb
index|[
name|HEXKEYBYTES
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|user
decl_stmt|,
modifier|*
name|pass
decl_stmt|,
modifier|*
name|xuser
decl_stmt|,
modifier|*
name|xpass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DesData
name|ck
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|IdeaData
name|ik
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|auth_debug_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sra_valid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|passwd_sent
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|str_data
index|[
literal|1024
index|]
init|=
block|{
name|IAC
block|,
name|SB
block|,
name|TELOPT_AUTHENTICATION
block|,
literal|0
block|,
name|AUTHTYPE_SRA
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SRA_KEY
value|0
end_define

begin_define
define|#
directive|define
name|SRA_USER
value|1
end_define

begin_define
define|#
directive|define
name|SRA_CONTINUE
value|2
end_define

begin_define
define|#
directive|define
name|SRA_PASS
value|3
end_define

begin_define
define|#
directive|define
name|SRA_ACCEPT
value|4
end_define

begin_define
define|#
directive|define
name|SRA_REJECT
value|5
end_define

begin_function_decl
specifier|static
name|int
name|check_user
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* support routine to send out authentication message */
end_comment

begin_function
specifier|static
name|int
name|Data
parameter_list|(
name|Authenticator
modifier|*
name|ap
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|d
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
init|=
name|str_data
operator|+
literal|4
decl_stmt|;
name|unsigned
name|char
modifier|*
name|cd
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|d
decl_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
name|c
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cd
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth_debug_mode
condition|)
block|{
name|printf
argument_list|(
literal|"%s:%d: [%d] (%d)"
argument_list|,
name|str_data
index|[
literal|3
index|]
operator|==
name|TELQUAL_IS
condition|?
literal|">>>IS"
else|:
literal|">>>REPLY"
argument_list|,
name|str_data
index|[
literal|3
index|]
argument_list|,
name|type
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|printd
argument_list|(
name|d
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
name|ap
operator|->
name|type
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|ap
operator|->
name|way
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|type
expr_stmt|;
while|while
condition|(
name|c
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|++
operator|=
operator|*
name|cd
operator|++
operator|)
operator|==
name|IAC
condition|)
operator|*
name|p
operator|++
operator|=
name|IAC
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
name|IAC
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|SE
expr_stmt|;
if|if
condition|(
name|str_data
index|[
literal|3
index|]
operator|==
name|TELQUAL_IS
condition|)
name|printsub
argument_list|(
literal|'>'
argument_list|,
operator|&
name|str_data
index|[
literal|2
index|]
argument_list|,
name|p
operator|-
operator|(
operator|&
name|str_data
index|[
literal|2
index|]
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|net_write
argument_list|(
name|str_data
argument_list|,
name|p
operator|-
name|str_data
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sra_init
parameter_list|(
name|Authenticator
modifier|*
name|ap
parameter_list|,
name|int
name|server
parameter_list|)
block|{
if|if
condition|(
name|server
condition|)
name|str_data
index|[
literal|3
index|]
operator|=
name|TELQUAL_REPLY
expr_stmt|;
else|else
name|str_data
index|[
literal|3
index|]
operator|=
name|TELQUAL_IS
expr_stmt|;
name|user
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|256
argument_list|)
expr_stmt|;
name|xuser
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|513
argument_list|)
expr_stmt|;
name|pass
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|256
argument_list|)
expr_stmt|;
name|xpass
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|513
argument_list|)
expr_stmt|;
if|if
condition|(
name|user
operator|==
name|NULL
operator|||
name|xuser
operator|==
name|NULL
operator|||
name|pass
operator|==
name|NULL
operator|||
name|xpass
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* malloc failed */
name|passwd_sent
operator|=
literal|0
expr_stmt|;
name|genkeys
argument_list|(
name|pka
argument_list|,
name|ska
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* client received a go-ahead for sra */
end_comment

begin_function
name|int
name|sra_send
parameter_list|(
name|Authenticator
modifier|*
name|ap
parameter_list|)
block|{
comment|/* send PKA */
if|if
condition|(
name|auth_debug_mode
condition|)
name|printf
argument_list|(
literal|"Sent PKA to server.\r\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Trying SRA secure login:\r\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Data
argument_list|(
name|ap
argument_list|,
name|SRA_KEY
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pka
argument_list|,
name|HEXKEYBYTES
argument_list|)
condition|)
block|{
if|if
condition|(
name|auth_debug_mode
condition|)
name|printf
argument_list|(
literal|"Not enough room for authentication data\r\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* server received an IS -- could be SRA KEY, USER, or PASS */
end_comment

begin_function
name|void
name|sra_is
parameter_list|(
name|Authenticator
modifier|*
name|ap
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|int
name|valid
decl_stmt|;
name|Session_Key
name|skey
decl_stmt|;
if|if
condition|(
name|cnt
operator|--
operator|<
literal|1
condition|)
goto|goto
name|bad
goto|;
switch|switch
condition|(
operator|*
name|data
operator|++
condition|)
block|{
case|case
name|SRA_KEY
case|:
if|if
condition|(
name|cnt
operator|<
name|HEXKEYBYTES
condition|)
block|{
name|Data
argument_list|(
name|ap
argument_list|,
name|SRA_REJECT
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|auth_finished
argument_list|(
name|ap
argument_list|,
name|AUTH_USER
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth_debug_mode
condition|)
block|{
name|printf
argument_list|(
literal|"SRA user rejected for bad PKB\r\n"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|auth_debug_mode
condition|)
name|printf
argument_list|(
literal|"Sent pka\r\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Data
argument_list|(
name|ap
argument_list|,
name|SRA_KEY
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pka
argument_list|,
name|HEXKEYBYTES
argument_list|)
condition|)
block|{
if|if
condition|(
name|auth_debug_mode
condition|)
name|printf
argument_list|(
literal|"Not enough room\r\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|memcpy
argument_list|(
name|pkb
argument_list|,
name|data
argument_list|,
name|HEXKEYBYTES
argument_list|)
expr_stmt|;
name|pkb
index|[
name|HEXKEYBYTES
index|]
operator|=
literal|'\0'
expr_stmt|;
name|common_key
argument_list|(
name|ska
argument_list|,
name|pkb
argument_list|,
operator|&
name|ik
argument_list|,
operator|&
name|ck
argument_list|)
expr_stmt|;
return|return;
case|case
name|SRA_USER
case|:
comment|/* decode KAB(u) */
if|if
condition|(
name|cnt
operator|>
literal|512
condition|)
comment|/* Attempted buffer overflow */
break|break;
name|memcpy
argument_list|(
name|xuser
argument_list|,
name|data
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|xuser
index|[
name|cnt
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pk_decode
argument_list|(
name|xuser
argument_list|,
name|user
argument_list|,
operator|&
name|ck
argument_list|)
expr_stmt|;
name|auth_encrypt_user
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|Data
argument_list|(
name|ap
argument_list|,
name|SRA_CONTINUE
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|SRA_PASS
case|:
if|if
condition|(
name|cnt
operator|>
literal|512
condition|)
comment|/* Attempted buffer overflow */
break|break;
comment|/* decode KAB(P) */
name|memcpy
argument_list|(
name|xpass
argument_list|,
name|data
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|xpass
index|[
name|cnt
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pk_decode
argument_list|(
name|xpass
argument_list|,
name|pass
argument_list|,
operator|&
name|ck
argument_list|)
expr_stmt|;
comment|/* check user's password */
name|valid
operator|=
name|check_user
argument_list|(
name|user
argument_list|,
name|pass
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid
condition|)
block|{
name|Data
argument_list|(
name|ap
argument_list|,
name|SRA_ACCEPT
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DES_ENCRYPTION
name|skey
operator|.
name|data
operator|=
name|ck
expr_stmt|;
name|skey
operator|.
name|type
operator|=
name|SK_DES
expr_stmt|;
name|skey
operator|.
name|length
operator|=
literal|8
expr_stmt|;
name|encrypt_session_key
argument_list|(
operator|&
name|skey
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sra_valid
operator|=
literal|1
expr_stmt|;
name|auth_finished
argument_list|(
name|ap
argument_list|,
name|AUTH_VALID
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth_debug_mode
condition|)
block|{
name|printf
argument_list|(
literal|"SRA user accepted\r\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Data
argument_list|(
name|ap
argument_list|,
name|SRA_CONTINUE
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 			Data(ap, SRA_REJECT, (void *)0, 0); 			sra_valid = 0; 			auth_finished(ap, AUTH_REJECT); */
if|if
condition|(
name|auth_debug_mode
condition|)
block|{
name|printf
argument_list|(
literal|"SRA user failed\r\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
default|default:
if|if
condition|(
name|auth_debug_mode
condition|)
name|printf
argument_list|(
literal|"Unknown SRA option %d\r\n"
argument_list|,
name|data
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|bad
label|:
name|Data
argument_list|(
name|ap
argument_list|,
name|SRA_REJECT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sra_valid
operator|=
literal|0
expr_stmt|;
name|auth_finished
argument_list|(
name|ap
argument_list|,
name|AUTH_REJECT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* client received REPLY -- could be SRA KEY, CONTINUE, ACCEPT, or REJECT */
end_comment

begin_function
name|void
name|sra_reply
parameter_list|(
name|Authenticator
modifier|*
name|ap
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
specifier|extern
name|char
modifier|*
name|telnet_gets
parameter_list|()
function_decl|;
name|char
name|uprompt
index|[
literal|256
index|]
decl_stmt|,
name|tuser
index|[
literal|256
index|]
decl_stmt|;
name|Session_Key
name|skey
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cnt
operator|--
operator|<
literal|1
condition|)
return|return;
switch|switch
condition|(
operator|*
name|data
operator|++
condition|)
block|{
case|case
name|SRA_KEY
case|:
comment|/* calculate common key */
if|if
condition|(
name|cnt
operator|<
name|HEXKEYBYTES
condition|)
block|{
if|if
condition|(
name|auth_debug_mode
condition|)
block|{
name|printf
argument_list|(
literal|"SRA user rejected for bad PKB\r\n"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|memcpy
argument_list|(
name|pkb
argument_list|,
name|data
argument_list|,
name|HEXKEYBYTES
argument_list|)
expr_stmt|;
name|pkb
index|[
name|HEXKEYBYTES
index|]
operator|=
literal|'\0'
expr_stmt|;
name|common_key
argument_list|(
name|ska
argument_list|,
name|pkb
argument_list|,
operator|&
name|ik
argument_list|,
operator|&
name|ck
argument_list|)
expr_stmt|;
name|enc_user
label|:
comment|/* encode user */
name|memset
argument_list|(
name|tuser
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tuser
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|uprompt
argument_list|,
literal|"User (%s): "
argument_list|,
name|UserNameRequested
argument_list|)
expr_stmt|;
name|telnet_gets
argument_list|(
name|uprompt
argument_list|,
name|tuser
argument_list|,
literal|255
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tuser
index|[
literal|0
index|]
operator|==
literal|'\n'
operator|||
name|tuser
index|[
literal|0
index|]
operator|==
literal|'\r'
condition|)
name|strcpy
argument_list|(
name|user
argument_list|,
name|UserNameRequested
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* telnet_gets leaves the newline on */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|tuser
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tuser
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
block|{
name|tuser
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
name|strcpy
argument_list|(
name|user
argument_list|,
name|tuser
argument_list|)
expr_stmt|;
block|}
name|pk_encode
argument_list|(
name|user
argument_list|,
name|xuser
argument_list|,
operator|&
name|ck
argument_list|)
expr_stmt|;
comment|/* send it off */
if|if
condition|(
name|auth_debug_mode
condition|)
name|printf
argument_list|(
literal|"Sent KAB(U)\r\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Data
argument_list|(
name|ap
argument_list|,
name|SRA_USER
argument_list|,
operator|(
name|void
operator|*
operator|)
name|xuser
argument_list|,
name|strlen
argument_list|(
name|xuser
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|auth_debug_mode
condition|)
name|printf
argument_list|(
literal|"Not enough room\r\n"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|SRA_CONTINUE
case|:
if|if
condition|(
name|passwd_sent
condition|)
block|{
name|passwd_sent
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"[ SRA login failed ]\r\n"
argument_list|)
expr_stmt|;
goto|goto
name|enc_user
goto|;
block|}
comment|/* encode password */
name|memset
argument_list|(
name|pass
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pass
argument_list|)
argument_list|)
expr_stmt|;
name|telnet_gets
argument_list|(
literal|"Password: "
argument_list|,
name|pass
argument_list|,
literal|255
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pk_encode
argument_list|(
name|pass
argument_list|,
name|xpass
argument_list|,
operator|&
name|ck
argument_list|)
expr_stmt|;
comment|/* send it off */
if|if
condition|(
name|auth_debug_mode
condition|)
name|printf
argument_list|(
literal|"Sent KAB(P)\r\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Data
argument_list|(
name|ap
argument_list|,
name|SRA_PASS
argument_list|,
operator|(
name|void
operator|*
operator|)
name|xpass
argument_list|,
name|strlen
argument_list|(
name|xpass
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|auth_debug_mode
condition|)
name|printf
argument_list|(
literal|"Not enough room\r\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|passwd_sent
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SRA_REJECT
case|:
name|printf
argument_list|(
literal|"[ SRA refuses authentication ]\r\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Trying plaintext login:\r\n"
argument_list|)
expr_stmt|;
name|auth_finished
argument_list|(
literal|0
argument_list|,
name|AUTH_REJECT
argument_list|)
expr_stmt|;
return|return;
case|case
name|SRA_ACCEPT
case|:
name|printf
argument_list|(
literal|"[ SRA accepts you ]\r\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DES_ENCRYPTION
name|skey
operator|.
name|data
operator|=
name|ck
expr_stmt|;
name|skey
operator|.
name|type
operator|=
name|SK_DES
expr_stmt|;
name|skey
operator|.
name|length
operator|=
literal|8
expr_stmt|;
name|encrypt_session_key
argument_list|(
operator|&
name|skey
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|auth_finished
argument_list|(
name|ap
argument_list|,
name|AUTH_VALID
argument_list|)
expr_stmt|;
return|return;
default|default:
if|if
condition|(
name|auth_debug_mode
condition|)
name|printf
argument_list|(
literal|"Unknown SRA option %d\r\n"
argument_list|,
name|data
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
name|int
name|sra_status
parameter_list|(
name|Authenticator
modifier|*
name|ap
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|level
parameter_list|)
block|{
if|if
condition|(
name|level
operator|<
name|AUTH_USER
condition|)
return|return
operator|(
name|level
operator|)
return|;
if|if
condition|(
name|UserNameRequested
operator|&&
name|sra_valid
condition|)
block|{
name|strcpy
argument_list|(
name|name
argument_list|,
name|UserNameRequested
argument_list|)
expr_stmt|;
return|return
operator|(
name|AUTH_VALID
operator|)
return|;
block|}
else|else
return|return
operator|(
name|AUTH_USER
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|BUMP
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|)
value|while (*(buf)) {++(buf), --(len);}
end_define

begin_define
define|#
directive|define
name|ADDC
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|,
name|c
parameter_list|)
value|if ((len)> 0) {*(buf)++ = (c); --(len);}
end_define

begin_function
name|void
name|sra_printsub
parameter_list|(
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|cnt
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|buflen
parameter_list|)
block|{
name|char
name|lbuf
index|[
literal|32
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|buf
index|[
name|buflen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* make sure its NULL terminated */
name|buflen
operator|-=
literal|1
expr_stmt|;
switch|switch
condition|(
name|data
index|[
literal|3
index|]
condition|)
block|{
case|case
name|SRA_CONTINUE
case|:
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|" CONTINUE "
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
goto|goto
name|common
goto|;
case|case
name|SRA_REJECT
case|:
comment|/* Rejected (reason might follow) */
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|" REJECT "
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
goto|goto
name|common
goto|;
case|case
name|SRA_ACCEPT
case|:
comment|/* Accepted (name might follow) */
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|" ACCEPT "
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|common
label|:
name|BUMP
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|<=
literal|4
condition|)
break|break;
name|ADDC
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
name|ADDC
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ADDC
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
name|ADDC
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
break|break;
case|case
name|SRA_KEY
case|:
comment|/* Authentication data follows */
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|" KEY "
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
goto|goto
name|common2
goto|;
case|case
name|SRA_USER
case|:
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|" USER "
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
goto|goto
name|common2
goto|;
case|case
name|SRA_PASS
case|:
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|" PASS "
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
goto|goto
name|common2
goto|;
default|default:
name|sprintf
argument_list|(
name|lbuf
argument_list|,
literal|" %d (unknown)"
argument_list|,
name|data
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|lbuf
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|common2
label|:
name|BUMP
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|lbuf
argument_list|,
literal|" %d"
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|lbuf
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|BUMP
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_decl_stmt
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Helper function for sgetpwnam().  */
end_comment

begin_function
name|char
modifier|*
name|sgetsave
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|new
init|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|new
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|passwd
modifier|*
name|sgetpwnam
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|static
name|struct
name|passwd
name|save
decl_stmt|;
specifier|register
name|struct
name|passwd
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|sgetsave
parameter_list|()
function_decl|;
if|if
condition|(
operator|(
name|p
operator|=
name|getpwnam
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|p
operator|)
return|;
if|if
condition|(
name|save
operator|.
name|pw_name
condition|)
block|{
name|free
argument_list|(
name|save
operator|.
name|pw_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|save
operator|.
name|pw_passwd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|save
operator|.
name|pw_gecos
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|save
operator|.
name|pw_dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|save
operator|.
name|pw_shell
argument_list|)
expr_stmt|;
block|}
name|save
operator|=
operator|*
name|p
expr_stmt|;
name|save
operator|.
name|pw_name
operator|=
name|sgetsave
argument_list|(
name|p
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|save
operator|.
name|pw_passwd
operator|=
name|sgetsave
argument_list|(
name|p
operator|->
name|pw_passwd
argument_list|)
expr_stmt|;
name|save
operator|.
name|pw_gecos
operator|=
name|sgetsave
argument_list|(
name|p
operator|->
name|pw_gecos
argument_list|)
expr_stmt|;
name|save
operator|.
name|pw_dir
operator|=
name|sgetsave
argument_list|(
name|p
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|save
operator|.
name|pw_shell
operator|=
name|sgetsave
argument_list|(
name|p
operator|->
name|pw_shell
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|syslog(LOG_WARNING,"%s\n",save.pw_name); syslog(LOG_WARNING,"%s\n",save.pw_passwd); syslog(LOG_WARNING,"%s\n",save.pw_gecos); syslog(LOG_WARNING,"%s\n",save.pw_dir);
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_SHADOW
block|{
name|struct
name|spwd
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|getspnam
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|save
operator|.
name|pw_passwd
argument_list|)
expr_stmt|;
name|save
operator|.
name|pw_passwd
operator|=
name|sgetsave
argument_list|(
name|sp
operator|->
name|sp_pwdp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
operator|&
name|save
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isroot
parameter_list|(
specifier|const
name|char
modifier|*
name|user
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|user
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|!
name|pw
operator|->
name|pw_uid
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rootterm
parameter_list|(
name|char
modifier|*
name|ttyn
parameter_list|)
block|{
name|struct
name|ttyent
modifier|*
name|t
decl_stmt|;
return|return
operator|(
operator|(
name|t
operator|=
name|getttynam
argument_list|(
name|ttyn
argument_list|)
operator|)
operator|&&
name|t
operator|->
name|ty_status
operator|&
name|TTY_SECURE
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NOPAM
end_ifdef

begin_function
specifier|static
name|int
name|check_user
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|pass
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|xpasswd
decl_stmt|,
modifier|*
name|salt
decl_stmt|;
if|if
condition|(
name|isroot
argument_list|(
name|name
argument_list|)
operator|&&
operator|!
name|rootterm
argument_list|(
name|line
argument_list|)
condition|)
block|{
name|crypt
argument_list|(
literal|"AA"
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
comment|/* Waste some time to simulate success */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|pw
operator|=
name|sgetpwnam
argument_list|(
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|pw
operator|->
name|pw_shell
operator|==
name|NULL
condition|)
block|{
name|pw
operator|=
operator|(
expr|struct
name|passwd
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|salt
operator|=
name|pw
operator|->
name|pw_passwd
expr_stmt|;
name|xpasswd
operator|=
name|crypt
argument_list|(
name|pass
argument_list|,
name|salt
argument_list|)
expr_stmt|;
comment|/* The strcmp does not catch null passwords! */
if|if
condition|(
name|pw
operator|==
name|NULL
operator|||
operator|*
name|pw
operator|->
name|pw_passwd
operator|==
literal|'\0'
operator|||
name|strcmp
argument_list|(
name|xpasswd
argument_list|,
name|pw
operator|->
name|pw_passwd
argument_list|)
condition|)
block|{
name|pw
operator|=
operator|(
expr|struct
name|passwd
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * The following is stolen from ftpd, which stole it from the imap-uw  * PAM module and login.c. It is needed because we can't really  * "converse" with the user, having already gone to the trouble of  * getting their username and password through an encrypted channel.  */
end_comment

begin_define
define|#
directive|define
name|COPY_STRING
parameter_list|(
name|s
parameter_list|)
value|(s ? strdup(s):NULL)
end_define

begin_struct
struct|struct
name|cred_t
block|{
specifier|const
name|char
modifier|*
name|uname
decl_stmt|;
specifier|const
name|char
modifier|*
name|pass
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|cred_t
name|cred_t
typedef|;
end_typedef

begin_function
name|int
name|auth_conv
parameter_list|(
name|int
name|num_msg
parameter_list|,
specifier|const
name|struct
name|pam_message
modifier|*
modifier|*
name|msg
parameter_list|,
name|struct
name|pam_response
modifier|*
modifier|*
name|resp
parameter_list|,
name|void
modifier|*
name|appdata
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|cred_t
modifier|*
name|cred
init|=
operator|(
name|cred_t
operator|*
operator|)
name|appdata
decl_stmt|;
name|struct
name|pam_response
modifier|*
name|reply
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pam_response
argument_list|)
operator|*
name|num_msg
argument_list|)
decl_stmt|;
if|if
condition|(
name|reply
operator|==
name|NULL
condition|)
return|return
name|PAM_BUF_ERR
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_msg
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|msg
index|[
name|i
index|]
operator|->
name|msg_style
condition|)
block|{
case|case
name|PAM_PROMPT_ECHO_ON
case|:
comment|/* assume want user name */
name|reply
index|[
name|i
index|]
operator|.
name|resp_retcode
operator|=
name|PAM_SUCCESS
expr_stmt|;
name|reply
index|[
name|i
index|]
operator|.
name|resp
operator|=
name|COPY_STRING
argument_list|(
name|cred
operator|->
name|uname
argument_list|)
expr_stmt|;
comment|/* PAM frees resp. */
break|break;
case|case
name|PAM_PROMPT_ECHO_OFF
case|:
comment|/* assume want password */
name|reply
index|[
name|i
index|]
operator|.
name|resp_retcode
operator|=
name|PAM_SUCCESS
expr_stmt|;
name|reply
index|[
name|i
index|]
operator|.
name|resp
operator|=
name|COPY_STRING
argument_list|(
name|cred
operator|->
name|pass
argument_list|)
expr_stmt|;
comment|/* PAM frees resp. */
break|break;
case|case
name|PAM_TEXT_INFO
case|:
case|case
name|PAM_ERROR_MSG
case|:
name|reply
index|[
name|i
index|]
operator|.
name|resp_retcode
operator|=
name|PAM_SUCCESS
expr_stmt|;
name|reply
index|[
name|i
index|]
operator|.
name|resp
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
comment|/* unknown message style */
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
name|PAM_CONV_ERR
return|;
block|}
block|}
operator|*
name|resp
operator|=
name|reply
expr_stmt|;
return|return
name|PAM_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  * The PAM version as a side effect may put a new username in *name.  */
end_comment

begin_function
specifier|static
name|int
name|check_user
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|pass
parameter_list|)
block|{
name|pam_handle_t
modifier|*
name|pamh
init|=
name|NULL
decl_stmt|;
specifier|const
name|void
modifier|*
name|item
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|int
name|e
decl_stmt|;
name|cred_t
name|auth_cred
init|=
block|{
name|name
block|,
name|pass
block|}
decl_stmt|;
name|struct
name|pam_conv
name|conv
init|=
block|{
operator|&
name|auth_conv
block|,
operator|&
name|auth_cred
block|}
decl_stmt|;
name|e
operator|=
name|pam_start
argument_list|(
literal|"telnetd"
argument_list|,
name|name
argument_list|,
operator|&
name|conv
argument_list|,
operator|&
name|pamh
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|!=
name|PAM_SUCCESS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pam_start: %s"
argument_list|,
name|pam_strerror
argument_list|(
name|pamh
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|#
directive|if
literal|0
comment|/* Where can we find this value? */
block|e = pam_set_item(pamh, PAM_RHOST, remotehost); 	if (e != PAM_SUCCESS) { 		syslog(LOG_ERR, "pam_set_item(PAM_RHOST): %s", 			pam_strerror(pamh, e)); 		return 0; 	}
endif|#
directive|endif
name|e
operator|=
name|pam_authenticate
argument_list|(
name|pamh
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|e
condition|)
block|{
case|case
name|PAM_SUCCESS
case|:
comment|/* 		 * With PAM we support the concept of a "template" 		 * user.  The user enters a login name which is 		 * authenticated by PAM, usually via a remote service 		 * such as RADIUS or TACACS+.  If authentication 		 * succeeds, a different but related "template" name 		 * is used for setting the credentials, shell, and 		 * home directory.  The name the user enters need only 		 * exist on the remote authentication server, but the 		 * template name must be present in the local password 		 * database. 		 * 		 * This is supported by two various mechanisms in the 		 * individual modules.  However, from the application's 		 * point of view, the template user is always passed 		 * back as a changed value of the PAM_USER item. 		 */
if|if
condition|(
operator|(
name|e
operator|=
name|pam_get_item
argument_list|(
name|pamh
argument_list|,
name|PAM_USER
argument_list|,
operator|&
name|item
argument_list|)
operator|)
operator|==
name|PAM_SUCCESS
condition|)
block|{
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|name
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|item
argument_list|)
expr_stmt|;
block|}
else|else
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Couldn't get PAM_USER: %s"
argument_list|,
name|pam_strerror
argument_list|(
name|pamh
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isroot
argument_list|(
name|name
argument_list|)
operator|&&
operator|!
name|rootterm
argument_list|(
name|line
argument_list|)
condition|)
name|rval
operator|=
literal|0
expr_stmt|;
else|else
name|rval
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PAM_AUTH_ERR
case|:
case|case
name|PAM_USER_UNKNOWN
case|:
case|case
name|PAM_MAXTRIES
case|:
name|rval
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"auth_pam: %s"
argument_list|,
name|pam_strerror
argument_list|(
name|pamh
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|e
operator|=
name|pam_end
argument_list|(
name|pamh
argument_list|,
name|e
argument_list|)
operator|)
operator|!=
name|PAM_SUCCESS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pam_end: %s"
argument_list|,
name|pam_strerror
argument_list|(
name|pamh
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

