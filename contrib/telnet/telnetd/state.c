begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static const char sccsid[] = "@(#)state.c	8.5 (Berkeley) 5/30/95";
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|"telnetd.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|AUTHENTICATION
argument_list|)
end_if

begin_include
include|#
directive|include
file|<libtelnet/auth.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ENCRYPTION
argument_list|)
end_if

begin_include
include|#
directive|include
file|<libtelnet/encrypt.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|unsigned
name|char
name|doopt
index|[]
init|=
block|{
name|IAC
block|,
name|DO
block|,
literal|'%'
block|,
literal|'c'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|dont
index|[]
init|=
block|{
name|IAC
block|,
name|DONT
block|,
literal|'%'
block|,
literal|'c'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|will
index|[]
init|=
block|{
name|IAC
block|,
name|WILL
block|,
literal|'%'
block|,
literal|'c'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|wont
index|[]
init|=
block|{
name|IAC
block|,
name|WONT
block|,
literal|'%'
block|,
literal|'c'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|not42
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Buffer for sub-options, and macros  * for suboptions buffer manipulations  */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|subbuffer
index|[
literal|512
index|]
decl_stmt|,
modifier|*
name|subpointer
init|=
name|subbuffer
decl_stmt|,
modifier|*
name|subend
init|=
name|subbuffer
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SB_CLEAR
parameter_list|()
value|subpointer = subbuffer
end_define

begin_define
define|#
directive|define
name|SB_TERM
parameter_list|()
value|{ subend = subpointer; SB_CLEAR(); }
end_define

begin_define
define|#
directive|define
name|SB_ACCUM
parameter_list|(
name|c
parameter_list|)
value|if (subpointer< (subbuffer+sizeof subbuffer)) { \ 				*subpointer++ = (c); \ 			}
end_define

begin_define
define|#
directive|define
name|SB_GET
parameter_list|()
value|((*subpointer++)&0xff)
end_define

begin_define
define|#
directive|define
name|SB_EOF
parameter_list|()
value|(subpointer>= subend)
end_define

begin_define
define|#
directive|define
name|SB_LEN
parameter_list|()
value|(subend - subpointer)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ENV_HACK
end_ifdef

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|subsave
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SB_SAVE
parameter_list|()
value|subsave = subpointer;
end_define

begin_define
define|#
directive|define
name|SB_RESTORE
parameter_list|()
value|subpointer = subsave;
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * State for recv fsm  */
end_comment

begin_define
define|#
directive|define
name|TS_DATA
value|0
end_define

begin_comment
comment|/* base state */
end_comment

begin_define
define|#
directive|define
name|TS_IAC
value|1
end_define

begin_comment
comment|/* look for double IAC's */
end_comment

begin_define
define|#
directive|define
name|TS_CR
value|2
end_define

begin_comment
comment|/* CR-LF ->'s CR */
end_comment

begin_define
define|#
directive|define
name|TS_SB
value|3
end_define

begin_comment
comment|/* throw away begin's... */
end_comment

begin_define
define|#
directive|define
name|TS_SE
value|4
end_define

begin_comment
comment|/* ...end's (suboption negotiation) */
end_comment

begin_define
define|#
directive|define
name|TS_WILL
value|5
end_define

begin_comment
comment|/* will option negotiation */
end_comment

begin_define
define|#
directive|define
name|TS_WONT
value|6
end_define

begin_comment
comment|/* wont " */
end_comment

begin_define
define|#
directive|define
name|TS_DO
value|7
end_define

begin_comment
comment|/* do " */
end_comment

begin_define
define|#
directive|define
name|TS_DONT
value|8
end_define

begin_comment
comment|/* dont " */
end_comment

begin_function
name|void
name|telrcv
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|static
name|int
name|state
init|=
name|TS_DATA
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|CRAY2
argument_list|)
operator|&&
name|defined
argument_list|(
name|UNICOS5
argument_list|)
name|char
modifier|*
name|opfrontp
init|=
name|pfrontp
decl_stmt|;
endif|#
directive|endif
while|while
condition|(
name|ncc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|&
name|ptyobuf
index|[
name|BUFSIZ
index|]
operator|-
name|pfrontp
operator|)
operator|<
literal|2
condition|)
break|break;
name|c
operator|=
operator|*
name|netip
operator|++
operator|&
literal|0377
operator|,
name|ncc
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|ENCRYPTION
if|if
condition|(
name|decrypt_input
condition|)
name|c
operator|=
call|(
modifier|*
name|decrypt_input
call|)
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ENCRYPTION */
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|TS_CR
case|:
name|state
operator|=
name|TS_DATA
expr_stmt|;
comment|/* Strip off \n or \0 after a \r */
if|if
condition|(
operator|(
name|c
operator|==
literal|0
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\n'
operator|)
condition|)
block|{
break|break;
block|}
comment|/* FALL THROUGH */
case|case
name|TS_DATA
case|:
if|if
condition|(
name|c
operator|==
name|IAC
condition|)
block|{
name|state
operator|=
name|TS_IAC
expr_stmt|;
break|break;
block|}
comment|/* 			 * We now map \r\n ==> \r for pragmatic reasons. 			 * Many client implementations send \r\n when 			 * the user hits the CarriageReturn key. 			 * 			 * We USED to map \r\n ==> \n, since \r\n says 			 * that we want to be in column 1 of the next 			 * printable line, and \n is the standard 			 * unix way of saying that (\r is only good 			 * if CRMOD is set, which it normally is). 			 */
if|if
condition|(
operator|(
name|c
operator|==
literal|'\r'
operator|)
operator|&&
name|his_state_is_wont
argument_list|(
name|TELOPT_BINARY
argument_list|)
condition|)
block|{
name|int
name|nc
init|=
operator|*
name|netip
decl_stmt|;
ifdef|#
directive|ifdef
name|ENCRYPTION
if|if
condition|(
name|decrypt_input
condition|)
name|nc
operator|=
call|(
modifier|*
name|decrypt_input
call|)
argument_list|(
name|nc
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ENCRYPTION */
ifdef|#
directive|ifdef
name|LINEMODE
comment|/* 				 * If we are operating in linemode, 				 * convert to local end-of-line. 				 */
if|if
condition|(
name|linemode
operator|&&
operator|(
name|ncc
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
literal|'\n'
operator|==
name|nc
operator|)
operator|||
operator|(
operator|(
literal|0
operator|==
name|nc
operator|)
operator|&&
name|tty_iscrnl
argument_list|()
operator|)
operator|)
condition|)
block|{
name|netip
operator|++
expr_stmt|;
name|ncc
operator|--
expr_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|ENCRYPTION
if|if
condition|(
name|decrypt_input
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|decrypt_input
argument_list|)
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ENCRYPTION */
name|state
operator|=
name|TS_CR
expr_stmt|;
block|}
block|}
operator|*
name|pfrontp
operator|++
operator|=
name|c
expr_stmt|;
break|break;
case|case
name|TS_IAC
case|:
name|gotiac
label|:
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* 			 * Send the process on the pty side an 			 * interrupt.  Do this with a NULL or 			 * interrupt char; depending on the tty mode. 			 */
case|case
name|IP
case|:
name|DIAG
argument_list|(
name|TD_OPTIONS
argument_list|,
name|printoption
argument_list|(
literal|"td: recv IAC"
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|interrupt
argument_list|()
expr_stmt|;
break|break;
case|case
name|BREAK
case|:
name|DIAG
argument_list|(
name|TD_OPTIONS
argument_list|,
name|printoption
argument_list|(
literal|"td: recv IAC"
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|sendbrk
argument_list|()
expr_stmt|;
break|break;
comment|/* 			 * Are You There? 			 */
case|case
name|AYT
case|:
name|DIAG
argument_list|(
name|TD_OPTIONS
argument_list|,
name|printoption
argument_list|(
literal|"td: recv IAC"
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|recv_ayt
argument_list|()
expr_stmt|;
break|break;
comment|/* 			 * Abort Output 			 */
case|case
name|AO
case|:
block|{
name|DIAG
argument_list|(
name|TD_OPTIONS
argument_list|,
name|printoption
argument_list|(
literal|"td: recv IAC"
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|ptyflush
argument_list|()
expr_stmt|;
comment|/* half-hearted */
name|init_termbuf
argument_list|()
expr_stmt|;
if|if
condition|(
name|slctab
index|[
name|SLC_AO
index|]
operator|.
name|sptr
operator|&&
operator|*
name|slctab
index|[
name|SLC_AO
index|]
operator|.
name|sptr
operator|!=
call|(
name|cc_t
call|)
argument_list|(
name|_POSIX_VDISABLE
argument_list|)
condition|)
block|{
operator|*
name|pfrontp
operator|++
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|slctab
index|[
name|SLC_AO
index|]
operator|.
name|sptr
expr_stmt|;
block|}
name|netclear
argument_list|()
expr_stmt|;
comment|/* clear buffer back */
name|output_data
argument_list|(
literal|"%c%c"
argument_list|,
name|IAC
argument_list|,
name|DM
argument_list|)
expr_stmt|;
name|neturg
operator|=
name|nfrontp
operator|-
literal|1
expr_stmt|;
comment|/* off by one XXX */
name|DIAG
argument_list|(
name|TD_OPTIONS
argument_list|,
name|printoption
argument_list|(
literal|"td: send IAC"
argument_list|,
name|DM
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * Erase Character and 			 * Erase Line 			 */
case|case
name|EC
case|:
case|case
name|EL
case|:
block|{
name|cc_t
name|ch
decl_stmt|;
name|DIAG
argument_list|(
name|TD_OPTIONS
argument_list|,
name|printoption
argument_list|(
literal|"td: recv IAC"
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|ptyflush
argument_list|()
expr_stmt|;
comment|/* half-hearted */
name|init_termbuf
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EC
condition|)
name|ch
operator|=
operator|*
name|slctab
index|[
name|SLC_EC
index|]
operator|.
name|sptr
expr_stmt|;
else|else
name|ch
operator|=
operator|*
name|slctab
index|[
name|SLC_EL
index|]
operator|.
name|sptr
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
call|(
name|cc_t
call|)
argument_list|(
name|_POSIX_VDISABLE
argument_list|)
condition|)
operator|*
name|pfrontp
operator|++
operator|=
operator|(
name|unsigned
name|char
operator|)
name|ch
expr_stmt|;
break|break;
block|}
comment|/* 			 * Check for urgent data... 			 */
case|case
name|DM
case|:
name|DIAG
argument_list|(
name|TD_OPTIONS
argument_list|,
name|printoption
argument_list|(
literal|"td: recv IAC"
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|SYNCHing
operator|=
name|stilloob
argument_list|(
name|net
argument_list|)
expr_stmt|;
name|settimer
argument_list|(
name|gotDM
argument_list|)
expr_stmt|;
break|break;
comment|/* 			 * Begin option subnegotiation... 			 */
case|case
name|SB
case|:
name|state
operator|=
name|TS_SB
expr_stmt|;
name|SB_CLEAR
argument_list|()
expr_stmt|;
continue|continue;
case|case
name|WILL
case|:
name|state
operator|=
name|TS_WILL
expr_stmt|;
continue|continue;
case|case
name|WONT
case|:
name|state
operator|=
name|TS_WONT
expr_stmt|;
continue|continue;
case|case
name|DO
case|:
name|state
operator|=
name|TS_DO
expr_stmt|;
continue|continue;
case|case
name|DONT
case|:
name|state
operator|=
name|TS_DONT
expr_stmt|;
continue|continue;
case|case
name|EOR
case|:
if|if
condition|(
name|his_state_is_will
argument_list|(
name|TELOPT_EOR
argument_list|)
condition|)
name|doeof
argument_list|()
expr_stmt|;
break|break;
comment|/* 			 * Handle RFC 10xx Telnet linemode option additions 			 * to command stream (EOF, SUSP, ABORT). 			 */
case|case
name|xEOF
case|:
name|doeof
argument_list|()
expr_stmt|;
break|break;
case|case
name|SUSP
case|:
name|sendsusp
argument_list|()
expr_stmt|;
break|break;
case|case
name|ABORT
case|:
name|sendbrk
argument_list|()
expr_stmt|;
break|break;
case|case
name|IAC
case|:
operator|*
name|pfrontp
operator|++
operator|=
name|c
expr_stmt|;
break|break;
block|}
name|state
operator|=
name|TS_DATA
expr_stmt|;
break|break;
case|case
name|TS_SB
case|:
if|if
condition|(
name|c
operator|==
name|IAC
condition|)
block|{
name|state
operator|=
name|TS_SE
expr_stmt|;
block|}
else|else
block|{
name|SB_ACCUM
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TS_SE
case|:
if|if
condition|(
name|c
operator|!=
name|SE
condition|)
block|{
if|if
condition|(
name|c
operator|!=
name|IAC
condition|)
block|{
comment|/* 					 * bad form of suboption negotiation. 					 * handle it in such a way as to avoid 					 * damage to local state.  Parse 					 * suboption buffer found so far, 					 * then treat remaining stream as 					 * another command sequence. 					 */
comment|/* for DIAGNOSTICS */
name|SB_ACCUM
argument_list|(
name|IAC
argument_list|)
expr_stmt|;
name|SB_ACCUM
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|subpointer
operator|-=
literal|2
expr_stmt|;
name|SB_TERM
argument_list|()
expr_stmt|;
name|suboption
argument_list|()
expr_stmt|;
name|state
operator|=
name|TS_IAC
expr_stmt|;
goto|goto
name|gotiac
goto|;
block|}
name|SB_ACCUM
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|state
operator|=
name|TS_SB
expr_stmt|;
block|}
else|else
block|{
comment|/* for DIAGNOSTICS */
name|SB_ACCUM
argument_list|(
name|IAC
argument_list|)
expr_stmt|;
name|SB_ACCUM
argument_list|(
name|SE
argument_list|)
expr_stmt|;
name|subpointer
operator|-=
literal|2
expr_stmt|;
name|SB_TERM
argument_list|()
expr_stmt|;
name|suboption
argument_list|()
expr_stmt|;
comment|/* handle sub-option */
name|state
operator|=
name|TS_DATA
expr_stmt|;
block|}
break|break;
case|case
name|TS_WILL
case|:
name|willoption
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
case|case
name|TS_WONT
case|:
name|wontoption
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
case|case
name|TS_DO
case|:
name|dooption
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
case|case
name|TS_DONT
case|:
name|dontoption
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
default|default:
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"panic state=%d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"telnetd: panic state=%d\n"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|CRAY2
argument_list|)
operator|&&
name|defined
argument_list|(
name|UNICOS5
argument_list|)
if|if
condition|(
operator|!
name|linemode
condition|)
block|{
name|char
name|xptyobuf
index|[
name|BUFSIZ
operator|+
name|NETSLOP
index|]
decl_stmt|;
name|char
name|xbuf2
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|n
init|=
name|pfrontp
operator|-
name|opfrontp
decl_stmt|,
name|oc
decl_stmt|;
name|memmove
argument_list|(
name|xptyobuf
argument_list|,
name|opfrontp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|pfrontp
operator|=
name|opfrontp
expr_stmt|;
name|pfrontp
operator|+=
name|term_input
argument_list|(
name|xptyobuf
argument_list|,
name|pfrontp
argument_list|,
name|n
argument_list|,
name|BUFSIZ
operator|+
name|NETSLOP
argument_list|,
name|xbuf2
argument_list|,
operator|&
name|oc
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|xbuf2
init|;
name|oc
operator|>
literal|0
condition|;
operator|--
name|oc
control|)
if|if
condition|(
operator|(
operator|*
name|nfrontp
operator|++
operator|=
operator|*
name|cp
operator|++
operator|)
operator|==
name|IAC
condition|)
operator|*
name|nfrontp
operator|++
operator|=
name|IAC
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(CRAY2)&& defined(UNICOS5) */
block|}
end_function

begin_comment
comment|/* end of telrcv */
end_comment

begin_comment
comment|/*  * The will/wont/do/dont state machines are based on Dave Borman's  * Telnet option processing state machine.  *  * These correspond to the following states:  *	my_state = the last negotiated state  *	want_state = what I want the state to go to  *	want_resp = how many requests I have sent  * All state defaults are negative, and resp defaults to 0.  *  * When initiating a request to change state to new_state:  *  * if ((want_resp == 0&& new_state == my_state) || want_state == new_state) {  *	do nothing;  * } else {  *	want_state = new_state;  *	send new_state;  *	want_resp++;  * }  *  * When receiving new_state:  *  * if (want_resp) {  *	want_resp--;  *	if (want_resp&& (new_state == my_state))  *		want_resp--;  * }  * if ((want_resp == 0)&& (new_state != want_state)) {  *	if (ok_to_switch_to new_state)  *		want_state = new_state;  *	else  *		want_resp++;  *	send want_state;  * }  * my_state = new_state;  *  * Note that new_state is implied in these functions by the function itself.  * will and do imply positive new_state, wont and dont imply negative.  *  * Finally, there is one catch.  If we send a negative response to a  * positive request, my_state will be the positive while want_state will  * remain negative.  my_state will revert to negative when the negative  * acknowlegment arrives from the peer.  Thus, my_state generally tells  * us not only the last negotiated state, but also tells us what the peer  * wants to be doing as well.  It is important to understand this difference  * as we may wish to be processing data streams based on our desired state  * (want_state) or based on what the peer thinks the state is (my_state).  *  * This all works fine because if the peer sends a positive request, the data  * that we receive prior to negative acknowlegment will probably be affected  * by the positive state, and we can process it as such (if we can; if we  * can't then it really doesn't matter).  If it is that important, then the  * peer probably should be buffering until this option state negotiation  * is complete.  *  */
end_comment

begin_function
name|void
name|send_do
parameter_list|(
name|option
parameter_list|,
name|init
parameter_list|)
name|int
name|option
decl_stmt|,
name|init
decl_stmt|;
block|{
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
operator|(
name|do_dont_resp
index|[
name|option
index|]
operator|==
literal|0
operator|&&
name|his_state_is_will
argument_list|(
name|option
argument_list|)
operator|)
operator|||
name|his_want_state_is_will
argument_list|(
name|option
argument_list|)
condition|)
return|return;
comment|/* 		 * Special case for TELOPT_TM:  We send a DO, but pretend 		 * that we sent a DONT, so that we can send more DOs if 		 * we want to. 		 */
if|if
condition|(
name|option
operator|==
name|TELOPT_TM
condition|)
name|set_his_want_state_wont
argument_list|(
name|option
argument_list|)
expr_stmt|;
else|else
name|set_his_want_state_will
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|do_dont_resp
index|[
name|option
index|]
operator|++
expr_stmt|;
block|}
name|output_data
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|doopt
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|DIAG
argument_list|(
name|TD_OPTIONS
argument_list|,
name|printoption
argument_list|(
literal|"td: send do"
argument_list|,
name|option
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AUTHENTICATION
end_ifdef

begin_function_decl
specifier|extern
name|void
name|auth_request
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LINEMODE
end_ifdef

begin_function_decl
specifier|extern
name|void
name|doclientstat
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ENCRYPTION
end_ifdef

begin_function_decl
specifier|extern
name|void
name|encrypt_send_support
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENCRYPTION */
end_comment

begin_function
name|void
name|willoption
parameter_list|(
name|option
parameter_list|)
name|int
name|option
decl_stmt|;
block|{
name|int
name|changeok
init|=
literal|0
decl_stmt|;
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
init|=
literal|0
function_decl|;
comment|/* 	 * process input from peer. 	 */
name|DIAG
argument_list|(
name|TD_OPTIONS
argument_list|,
name|printoption
argument_list|(
literal|"td: recv will"
argument_list|,
name|option
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_dont_resp
index|[
name|option
index|]
condition|)
block|{
name|do_dont_resp
index|[
name|option
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|do_dont_resp
index|[
name|option
index|]
operator|&&
name|his_state_is_will
argument_list|(
name|option
argument_list|)
condition|)
name|do_dont_resp
index|[
name|option
index|]
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|do_dont_resp
index|[
name|option
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|his_want_state_is_wont
argument_list|(
name|option
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|TELOPT_BINARY
case|:
name|init_termbuf
argument_list|()
expr_stmt|;
name|tty_binaryin
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|set_termbuf
argument_list|()
expr_stmt|;
name|changeok
operator|++
expr_stmt|;
break|break;
case|case
name|TELOPT_ECHO
case|:
comment|/* 			 * See comments below for more info. 			 */
name|not42
operator|=
literal|0
expr_stmt|;
comment|/* looks like a 4.2 system */
break|break;
case|case
name|TELOPT_TM
case|:
if|#
directive|if
name|defined
argument_list|(
name|LINEMODE
argument_list|)
operator|&&
name|defined
argument_list|(
name|KLUDGELINEMODE
argument_list|)
comment|/* 			 * This telnetd implementation does not really 			 * support timing marks, it just uses them to 			 * support the kludge linemode stuff.  If we 			 * receive a will or wont TM in response to our 			 * do TM request that may have been sent to 			 * determine kludge linemode support, process 			 * it, otherwise TM should get a negative 			 * response back. 			 */
comment|/* 			 * Handle the linemode kludge stuff. 			 * If we are not currently supporting any 			 * linemode at all, then we assume that this 			 * is the client telling us to use kludge 			 * linemode in response to our query.  Set the 			 * linemode type that is to be supported, note 			 * that the client wishes to use linemode, and 			 * eat the will TM as though it never arrived. 			 */
if|if
condition|(
name|lmodetype
operator|<
name|KLUDGE_LINEMODE
condition|)
block|{
name|lmodetype
operator|=
name|KLUDGE_LINEMODE
expr_stmt|;
name|clientstat
argument_list|(
name|TELOPT_LINEMODE
argument_list|,
name|WILL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_wont
argument_list|(
name|TELOPT_SGA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lmodetype
operator|==
name|NO_AUTOKLUDGE
condition|)
block|{
name|lmodetype
operator|=
name|KLUDGE_OK
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(LINEMODE)&& defined(KLUDGELINEMODE) */
comment|/* 			 * We never respond to a WILL TM, and 			 * we leave the state WONT. 			 */
return|return;
case|case
name|TELOPT_LFLOW
case|:
comment|/* 			 * If we are going to support flow control 			 * option, then don't worry peer that we can't 			 * change the flow control characters. 			 */
name|slctab
index|[
name|SLC_XON
index|]
operator|.
name|defset
operator|.
name|flag
operator|&=
operator|~
name|SLC_LEVELBITS
expr_stmt|;
name|slctab
index|[
name|SLC_XON
index|]
operator|.
name|defset
operator|.
name|flag
operator||=
name|SLC_DEFAULT
expr_stmt|;
name|slctab
index|[
name|SLC_XOFF
index|]
operator|.
name|defset
operator|.
name|flag
operator|&=
operator|~
name|SLC_LEVELBITS
expr_stmt|;
name|slctab
index|[
name|SLC_XOFF
index|]
operator|.
name|defset
operator|.
name|flag
operator||=
name|SLC_DEFAULT
expr_stmt|;
case|case
name|TELOPT_TTYPE
case|:
case|case
name|TELOPT_SGA
case|:
case|case
name|TELOPT_NAWS
case|:
case|case
name|TELOPT_TSPEED
case|:
case|case
name|TELOPT_XDISPLOC
case|:
case|case
name|TELOPT_NEW_ENVIRON
case|:
case|case
name|TELOPT_OLD_ENVIRON
case|:
name|changeok
operator|++
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|LINEMODE
case|case
name|TELOPT_LINEMODE
case|:
ifdef|#
directive|ifdef
name|KLUDGELINEMODE
comment|/* 			 * Note client's desire to use linemode. 			 */
name|lmodetype
operator|=
name|REAL_LINEMODE
expr_stmt|;
endif|#
directive|endif
comment|/* KLUDGELINEMODE */
name|func
operator|=
name|doclientstat
expr_stmt|;
name|changeok
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* LINEMODE */
ifdef|#
directive|ifdef
name|AUTHENTICATION
case|case
name|TELOPT_AUTHENTICATION
case|:
name|func
operator|=
name|auth_request
expr_stmt|;
name|changeok
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENCRYPTION
case|case
name|TELOPT_ENCRYPT
case|:
name|func
operator|=
name|encrypt_send_support
expr_stmt|;
name|changeok
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* ENCRYPTION */
default|default:
break|break;
block|}
if|if
condition|(
name|changeok
condition|)
block|{
name|set_his_want_state_will
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|send_do
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|do_dont_resp
index|[
name|option
index|]
operator|++
expr_stmt|;
name|send_dont
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Option processing that should happen when 		 * we receive conformation of a change in 		 * state that we had requested. 		 */
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|TELOPT_ECHO
case|:
name|not42
operator|=
literal|0
expr_stmt|;
comment|/* looks like a 4.2 system */
comment|/* 			 * Egads, he responded "WILL ECHO".  Turn 			 * it off right now! 			 */
name|send_dont
argument_list|(
name|option
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 			 * "WILL ECHO".  Kludge upon kludge! 			 * A 4.2 client is now echoing user input at 			 * the tty.  This is probably undesireable and 			 * it should be stopped.  The client will 			 * respond WONT TM to the DO TM that we send to 			 * check for kludge linemode.  When the WONT TM 			 * arrives, linemode will be turned off and a 			 * change propogated to the pty.  This change 			 * will cause us to process the new pty state 			 * in localstat(), which will notice that 			 * linemode is off and send a WILL ECHO 			 * so that we are properly in character mode and 			 * all is well. 			 */
break|break;
ifdef|#
directive|ifdef
name|LINEMODE
case|case
name|TELOPT_LINEMODE
case|:
ifdef|#
directive|ifdef
name|KLUDGELINEMODE
comment|/* 			 * Note client's desire to use linemode. 			 */
name|lmodetype
operator|=
name|REAL_LINEMODE
expr_stmt|;
endif|#
directive|endif
comment|/* KLUDGELINEMODE */
name|func
operator|=
name|doclientstat
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* LINEMODE */
ifdef|#
directive|ifdef
name|AUTHENTICATION
case|case
name|TELOPT_AUTHENTICATION
case|:
name|func
operator|=
name|auth_request
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENCRYPTION
case|case
name|TELOPT_ENCRYPT
case|:
name|func
operator|=
name|encrypt_send_support
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* ENCRYPTION */
case|case
name|TELOPT_LFLOW
case|:
name|func
operator|=
name|flowstat
expr_stmt|;
break|break;
block|}
block|}
block|}
name|set_his_state_will
argument_list|(
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
condition|)
call|(
modifier|*
name|func
call|)
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of willoption */
end_comment

begin_function
name|void
name|send_dont
parameter_list|(
name|option
parameter_list|,
name|init
parameter_list|)
name|int
name|option
decl_stmt|,
name|init
decl_stmt|;
block|{
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
operator|(
name|do_dont_resp
index|[
name|option
index|]
operator|==
literal|0
operator|&&
name|his_state_is_wont
argument_list|(
name|option
argument_list|)
operator|)
operator|||
name|his_want_state_is_wont
argument_list|(
name|option
argument_list|)
condition|)
return|return;
name|set_his_want_state_wont
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|do_dont_resp
index|[
name|option
index|]
operator|++
expr_stmt|;
block|}
name|output_data
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|dont
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|DIAG
argument_list|(
name|TD_OPTIONS
argument_list|,
name|printoption
argument_list|(
literal|"td: send dont"
argument_list|,
name|option
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wontoption
parameter_list|(
name|option
parameter_list|)
name|int
name|option
decl_stmt|;
block|{
comment|/* 	 * Process client input. 	 */
name|DIAG
argument_list|(
name|TD_OPTIONS
argument_list|,
name|printoption
argument_list|(
literal|"td: recv wont"
argument_list|,
name|option
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_dont_resp
index|[
name|option
index|]
condition|)
block|{
name|do_dont_resp
index|[
name|option
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|do_dont_resp
index|[
name|option
index|]
operator|&&
name|his_state_is_wont
argument_list|(
name|option
argument_list|)
condition|)
name|do_dont_resp
index|[
name|option
index|]
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|do_dont_resp
index|[
name|option
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|his_want_state_is_will
argument_list|(
name|option
argument_list|)
condition|)
block|{
comment|/* it is always ok to change to negative state */
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|TELOPT_ECHO
case|:
name|not42
operator|=
literal|1
expr_stmt|;
comment|/* doesn't seem to be a 4.2 system */
break|break;
case|case
name|TELOPT_BINARY
case|:
name|init_termbuf
argument_list|()
expr_stmt|;
name|tty_binaryin
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|set_termbuf
argument_list|()
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|LINEMODE
case|case
name|TELOPT_LINEMODE
case|:
ifdef|#
directive|ifdef
name|KLUDGELINEMODE
comment|/* 			 * If real linemode is supported, then client is 			 * asking to turn linemode off. 			 */
if|if
condition|(
name|lmodetype
operator|!=
name|REAL_LINEMODE
condition|)
break|break;
endif|#
directive|endif
comment|/* KLUDGELINEMODE */
name|clientstat
argument_list|(
name|TELOPT_LINEMODE
argument_list|,
name|WONT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* LINEMODE */
case|case
name|TELOPT_TM
case|:
comment|/* 			 * If we get a WONT TM, and had sent a DO TM, 			 * don't respond with a DONT TM, just leave it 			 * as is.  Short circut the state machine to 			 * achive this. 			 */
name|set_his_want_state_wont
argument_list|(
name|TELOPT_TM
argument_list|)
expr_stmt|;
return|return;
case|case
name|TELOPT_LFLOW
case|:
comment|/* 			 * If we are not going to support flow control 			 * option, then let peer know that we can't 			 * change the flow control characters. 			 */
name|slctab
index|[
name|SLC_XON
index|]
operator|.
name|defset
operator|.
name|flag
operator|&=
operator|~
name|SLC_LEVELBITS
expr_stmt|;
name|slctab
index|[
name|SLC_XON
index|]
operator|.
name|defset
operator|.
name|flag
operator||=
name|SLC_CANTCHANGE
expr_stmt|;
name|slctab
index|[
name|SLC_XOFF
index|]
operator|.
name|defset
operator|.
name|flag
operator|&=
operator|~
name|SLC_LEVELBITS
expr_stmt|;
name|slctab
index|[
name|SLC_XOFF
index|]
operator|.
name|defset
operator|.
name|flag
operator||=
name|SLC_CANTCHANGE
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|AUTHENTICATION
argument_list|)
case|case
name|TELOPT_AUTHENTICATION
case|:
name|auth_finished
argument_list|(
literal|0
argument_list|,
name|AUTH_REJECT
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* 		 * For options that we might spin waiting for 		 * sub-negotiation, if the client turns off the 		 * option rather than responding to the request, 		 * we have to treat it here as if we got a response 		 * to the sub-negotiation, (by updating the timers) 		 * so that we'll break out of the loop. 		 */
case|case
name|TELOPT_TTYPE
case|:
name|settimer
argument_list|(
name|ttypesubopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|TELOPT_TSPEED
case|:
name|settimer
argument_list|(
name|tspeedsubopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|TELOPT_XDISPLOC
case|:
name|settimer
argument_list|(
name|xdisplocsubopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|TELOPT_OLD_ENVIRON
case|:
name|settimer
argument_list|(
name|oenvironsubopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|TELOPT_NEW_ENVIRON
case|:
name|settimer
argument_list|(
name|environsubopt
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|set_his_want_state_wont
argument_list|(
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
name|his_state_is_will
argument_list|(
name|option
argument_list|)
condition|)
name|send_dont
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|TELOPT_TM
case|:
if|#
directive|if
name|defined
argument_list|(
name|LINEMODE
argument_list|)
operator|&&
name|defined
argument_list|(
name|KLUDGELINEMODE
argument_list|)
if|if
condition|(
name|lmodetype
operator|<
name|NO_AUTOKLUDGE
condition|)
block|{
name|lmodetype
operator|=
name|NO_LINEMODE
expr_stmt|;
name|clientstat
argument_list|(
name|TELOPT_LINEMODE
argument_list|,
name|WONT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_will
argument_list|(
name|TELOPT_SGA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_will
argument_list|(
name|TELOPT_ECHO
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(LINEMODE)&& defined(KLUDGELINEMODE) */
break|break;
if|#
directive|if
name|defined
argument_list|(
name|AUTHENTICATION
argument_list|)
case|case
name|TELOPT_AUTHENTICATION
case|:
name|auth_finished
argument_list|(
literal|0
argument_list|,
name|AUTH_REJECT
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
block|}
block|}
name|set_his_state_wont
argument_list|(
name|option
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of wontoption */
end_comment

begin_function
name|void
name|send_will
parameter_list|(
name|option
parameter_list|,
name|init
parameter_list|)
name|int
name|option
decl_stmt|,
name|init
decl_stmt|;
block|{
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
operator|(
name|will_wont_resp
index|[
name|option
index|]
operator|==
literal|0
operator|&&
name|my_state_is_will
argument_list|(
name|option
argument_list|)
operator|)
operator|||
name|my_want_state_is_will
argument_list|(
name|option
argument_list|)
condition|)
return|return;
name|set_my_want_state_will
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|will_wont_resp
index|[
name|option
index|]
operator|++
expr_stmt|;
block|}
name|output_data
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|will
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|DIAG
argument_list|(
name|TD_OPTIONS
argument_list|,
name|printoption
argument_list|(
literal|"td: send will"
argument_list|,
name|option
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LINEMODE
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|KLUDGELINEMODE
argument_list|)
end_if

begin_comment
comment|/*  * When we get a DONT SGA, we will try once to turn it  * back on.  If the other side responds DONT SGA, we  * leave it at that.  This is so that when we talk to  * clients that understand KLUDGELINEMODE but not LINEMODE,  * we'll keep them in char-at-a-time mode.  */
end_comment

begin_decl_stmt
name|int
name|turn_on_sga
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|dooption
parameter_list|(
name|option
parameter_list|)
name|int
name|option
decl_stmt|;
block|{
name|int
name|changeok
init|=
literal|0
decl_stmt|;
comment|/* 	 * Process client input. 	 */
name|DIAG
argument_list|(
name|TD_OPTIONS
argument_list|,
name|printoption
argument_list|(
literal|"td: recv do"
argument_list|,
name|option
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|will_wont_resp
index|[
name|option
index|]
condition|)
block|{
name|will_wont_resp
index|[
name|option
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|will_wont_resp
index|[
name|option
index|]
operator|&&
name|my_state_is_will
argument_list|(
name|option
argument_list|)
condition|)
name|will_wont_resp
index|[
name|option
index|]
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|will_wont_resp
index|[
name|option
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
name|my_want_state_is_wont
argument_list|(
name|option
argument_list|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|TELOPT_ECHO
case|:
ifdef|#
directive|ifdef
name|LINEMODE
ifdef|#
directive|ifdef
name|KLUDGELINEMODE
if|if
condition|(
name|lmodetype
operator|==
name|NO_LINEMODE
condition|)
else|#
directive|else
if|if
condition|(
name|his_state_is_wont
argument_list|(
name|TELOPT_LINEMODE
argument_list|)
condition|)
endif|#
directive|endif
endif|#
directive|endif
block|{
name|init_termbuf
argument_list|()
expr_stmt|;
name|tty_setecho
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|set_termbuf
argument_list|()
expr_stmt|;
block|}
name|changeok
operator|++
expr_stmt|;
break|break;
case|case
name|TELOPT_BINARY
case|:
name|init_termbuf
argument_list|()
expr_stmt|;
name|tty_binaryout
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|set_termbuf
argument_list|()
expr_stmt|;
name|changeok
operator|++
expr_stmt|;
break|break;
case|case
name|TELOPT_SGA
case|:
if|#
directive|if
name|defined
argument_list|(
name|LINEMODE
argument_list|)
operator|&&
name|defined
argument_list|(
name|KLUDGELINEMODE
argument_list|)
comment|/* 			 * If kludge linemode is in use, then we must 			 * process an incoming do SGA for linemode 			 * purposes. 			 */
if|if
condition|(
name|lmodetype
operator|==
name|KLUDGE_LINEMODE
condition|)
block|{
comment|/* 				 * Receipt of "do SGA" in kludge 				 * linemode is the peer asking us to 				 * turn off linemode.  Make note of 				 * the request. 				 */
name|clientstat
argument_list|(
name|TELOPT_LINEMODE
argument_list|,
name|WONT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 				 * If linemode did not get turned off 				 * then don't tell peer that we did. 				 * Breaking here forces a wont SGA to 				 * be returned. 				 */
if|if
condition|(
name|linemode
condition|)
break|break;
block|}
else|#
directive|else
name|turn_on_sga
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* defined(LINEMODE)&& defined(KLUDGELINEMODE) */
name|changeok
operator|++
expr_stmt|;
break|break;
case|case
name|TELOPT_STATUS
case|:
name|changeok
operator|++
expr_stmt|;
break|break;
case|case
name|TELOPT_TM
case|:
comment|/* 			 * Special case for TM.  We send a WILL, but 			 * pretend we sent a WONT. 			 */
name|send_will
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_my_want_state_wont
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|set_my_state_wont
argument_list|(
name|option
argument_list|)
expr_stmt|;
return|return;
case|case
name|TELOPT_LOGOUT
case|:
comment|/* 			 * When we get a LOGOUT option, respond 			 * with a WILL LOGOUT, make sure that 			 * it gets written out to the network, 			 * and then just go away... 			 */
name|set_my_want_state_will
argument_list|(
name|TELOPT_LOGOUT
argument_list|)
expr_stmt|;
name|send_will
argument_list|(
name|TELOPT_LOGOUT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_my_state_will
argument_list|(
name|TELOPT_LOGOUT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|netflush
argument_list|()
expr_stmt|;
name|cleanup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
break|break;
ifdef|#
directive|ifdef
name|ENCRYPTION
case|case
name|TELOPT_ENCRYPT
case|:
name|changeok
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* ENCRYPTION */
case|case
name|TELOPT_LINEMODE
case|:
case|case
name|TELOPT_TTYPE
case|:
case|case
name|TELOPT_NAWS
case|:
case|case
name|TELOPT_TSPEED
case|:
case|case
name|TELOPT_LFLOW
case|:
case|case
name|TELOPT_XDISPLOC
case|:
ifdef|#
directive|ifdef
name|TELOPT_ENVIRON
case|case
name|TELOPT_NEW_ENVIRON
case|:
endif|#
directive|endif
case|case
name|TELOPT_OLD_ENVIRON
case|:
default|default:
break|break;
block|}
if|if
condition|(
name|changeok
condition|)
block|{
name|set_my_want_state_will
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|send_will
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|will_wont_resp
index|[
name|option
index|]
operator|++
expr_stmt|;
name|send_wont
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|set_my_state_will
argument_list|(
name|option
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of dooption */
end_comment

begin_function
name|void
name|send_wont
parameter_list|(
name|option
parameter_list|,
name|init
parameter_list|)
name|int
name|option
decl_stmt|,
name|init
decl_stmt|;
block|{
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
operator|(
name|will_wont_resp
index|[
name|option
index|]
operator|==
literal|0
operator|&&
name|my_state_is_wont
argument_list|(
name|option
argument_list|)
operator|)
operator|||
name|my_want_state_is_wont
argument_list|(
name|option
argument_list|)
condition|)
return|return;
name|set_my_want_state_wont
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|will_wont_resp
index|[
name|option
index|]
operator|++
expr_stmt|;
block|}
name|output_data
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|wont
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|DIAG
argument_list|(
name|TD_OPTIONS
argument_list|,
name|printoption
argument_list|(
literal|"td: send wont"
argument_list|,
name|option
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dontoption
parameter_list|(
name|option
parameter_list|)
name|int
name|option
decl_stmt|;
block|{
comment|/* 	 * Process client input. 	 */
name|DIAG
argument_list|(
name|TD_OPTIONS
argument_list|,
name|printoption
argument_list|(
literal|"td: recv dont"
argument_list|,
name|option
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|will_wont_resp
index|[
name|option
index|]
condition|)
block|{
name|will_wont_resp
index|[
name|option
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|will_wont_resp
index|[
name|option
index|]
operator|&&
name|my_state_is_wont
argument_list|(
name|option
argument_list|)
condition|)
name|will_wont_resp
index|[
name|option
index|]
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|will_wont_resp
index|[
name|option
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
name|my_want_state_is_will
argument_list|(
name|option
argument_list|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|TELOPT_BINARY
case|:
name|init_termbuf
argument_list|()
expr_stmt|;
name|tty_binaryout
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|set_termbuf
argument_list|()
expr_stmt|;
break|break;
case|case
name|TELOPT_ECHO
case|:
comment|/* we should stop echoing */
ifdef|#
directive|ifdef
name|LINEMODE
ifdef|#
directive|ifdef
name|KLUDGELINEMODE
if|if
condition|(
operator|(
name|lmodetype
operator|!=
name|REAL_LINEMODE
operator|)
operator|&&
operator|(
name|lmodetype
operator|!=
name|KLUDGE_LINEMODE
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|his_state_is_wont
argument_list|(
name|TELOPT_LINEMODE
argument_list|)
condition|)
endif|#
directive|endif
endif|#
directive|endif
block|{
name|init_termbuf
argument_list|()
expr_stmt|;
name|tty_setecho
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|set_termbuf
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|TELOPT_SGA
case|:
if|#
directive|if
name|defined
argument_list|(
name|LINEMODE
argument_list|)
operator|&&
name|defined
argument_list|(
name|KLUDGELINEMODE
argument_list|)
comment|/* 			 * If kludge linemode is in use, then we 			 * must process an incoming do SGA for 			 * linemode purposes. 			 */
if|if
condition|(
operator|(
name|lmodetype
operator|==
name|KLUDGE_LINEMODE
operator|)
operator|||
operator|(
name|lmodetype
operator|==
name|KLUDGE_OK
operator|)
condition|)
block|{
comment|/* 				 * The client is asking us to turn 				 * linemode on. 				 */
name|lmodetype
operator|=
name|KLUDGE_LINEMODE
expr_stmt|;
name|clientstat
argument_list|(
name|TELOPT_LINEMODE
argument_list|,
name|WILL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 				 * If we did not turn line mode on, 				 * then what do we say?  Will SGA? 				 * This violates design of telnet. 				 * Gross.  Very Gross. 				 */
block|}
break|break;
else|#
directive|else
name|set_my_want_state_wont
argument_list|(
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_state_is_will
argument_list|(
name|option
argument_list|)
condition|)
name|send_wont
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_my_state_wont
argument_list|(
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
name|turn_on_sga
operator|^=
literal|1
condition|)
name|send_will
argument_list|(
name|option
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
comment|/* defined(LINEMODE)&& defined(KLUDGELINEMODE) */
default|default:
break|break;
block|}
name|set_my_want_state_wont
argument_list|(
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_state_is_will
argument_list|(
name|option
argument_list|)
condition|)
name|send_wont
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|set_my_state_wont
argument_list|(
name|option
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of dontoption */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ENV_HACK
end_ifdef

begin_decl_stmt
name|int
name|env_ovar
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|env_ovalue
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ENV_HACK */
end_comment

begin_define
define|#
directive|define
name|env_ovar
value|OLD_ENV_VAR
end_define

begin_define
define|#
directive|define
name|env_ovalue
value|OLD_ENV_VALUE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENV_HACK */
end_comment

begin_comment
comment|/*  * suboption()  *  *	Look at the sub-option buffer, and try to be helpful to the other  * side.  *  *	Currently we recognize:  *  *	Terminal type is  *	Linemode  *	Window size  *	Terminal speed  */
end_comment

begin_function
name|void
name|suboption
parameter_list|()
block|{
specifier|register
name|int
name|subchar
decl_stmt|;
name|DIAG
argument_list|(
argument|TD_OPTIONS
argument_list|,
argument|{netflush(); printsub(
literal|'<'
argument|, subpointer, SB_LEN()+
literal|2
argument|);}
argument_list|)
empty_stmt|;
name|subchar
operator|=
name|SB_GET
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|subchar
condition|)
block|{
case|case
name|TELOPT_TSPEED
case|:
block|{
specifier|register
name|int
name|xspeed
decl_stmt|,
name|rspeed
decl_stmt|;
if|if
condition|(
name|his_state_is_wont
argument_list|(
name|TELOPT_TSPEED
argument_list|)
condition|)
comment|/* Ignore if option disabled */
break|break;
name|settimer
argument_list|(
name|tspeedsubopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|SB_EOF
argument_list|()
operator|||
name|SB_GET
argument_list|()
operator|!=
name|TELQUAL_IS
condition|)
return|return;
name|xspeed
operator|=
name|atoi
argument_list|(
operator|(
name|char
operator|*
operator|)
name|subpointer
argument_list|)
expr_stmt|;
while|while
condition|(
name|SB_GET
argument_list|()
operator|!=
literal|','
operator|&&
operator|!
name|SB_EOF
argument_list|()
condition|)
empty_stmt|;
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
return|return;
name|rspeed
operator|=
name|atoi
argument_list|(
operator|(
name|char
operator|*
operator|)
name|subpointer
argument_list|)
expr_stmt|;
name|clientstat
argument_list|(
name|TELOPT_TSPEED
argument_list|,
name|xspeed
argument_list|,
name|rspeed
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* end of case TELOPT_TSPEED */
case|case
name|TELOPT_TTYPE
case|:
block|{
comment|/* Yaaaay! */
specifier|static
name|char
name|terminalname
index|[
literal|41
index|]
decl_stmt|;
if|if
condition|(
name|his_state_is_wont
argument_list|(
name|TELOPT_TTYPE
argument_list|)
condition|)
comment|/* Ignore if option disabled */
break|break;
name|settimer
argument_list|(
name|ttypesubopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|SB_EOF
argument_list|()
operator|||
name|SB_GET
argument_list|()
operator|!=
name|TELQUAL_IS
condition|)
block|{
return|return;
comment|/* ??? XXX but, this is the most robust */
block|}
name|terminaltype
operator|=
name|terminalname
expr_stmt|;
while|while
condition|(
operator|(
name|terminaltype
operator|<
operator|(
name|terminalname
operator|+
sizeof|sizeof
name|terminalname
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|!
name|SB_EOF
argument_list|()
condition|)
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
name|SB_GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|c
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
operator|*
name|terminaltype
operator|++
operator|=
name|c
expr_stmt|;
comment|/* accumulate name */
block|}
operator|*
name|terminaltype
operator|=
literal|0
expr_stmt|;
name|terminaltype
operator|=
name|terminalname
expr_stmt|;
break|break;
block|}
comment|/* end of case TELOPT_TTYPE */
case|case
name|TELOPT_NAWS
case|:
block|{
specifier|register
name|int
name|xwinsize
decl_stmt|,
name|ywinsize
decl_stmt|;
if|if
condition|(
name|his_state_is_wont
argument_list|(
name|TELOPT_NAWS
argument_list|)
condition|)
comment|/* Ignore if option disabled */
break|break;
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
return|return;
name|xwinsize
operator|=
name|SB_GET
argument_list|()
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
return|return;
name|xwinsize
operator||=
name|SB_GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
return|return;
name|ywinsize
operator|=
name|SB_GET
argument_list|()
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
return|return;
name|ywinsize
operator||=
name|SB_GET
argument_list|()
expr_stmt|;
name|clientstat
argument_list|(
name|TELOPT_NAWS
argument_list|,
name|xwinsize
argument_list|,
name|ywinsize
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* end of case TELOPT_NAWS */
ifdef|#
directive|ifdef
name|LINEMODE
case|case
name|TELOPT_LINEMODE
case|:
block|{
specifier|register
name|int
name|request
decl_stmt|;
if|if
condition|(
name|his_state_is_wont
argument_list|(
name|TELOPT_LINEMODE
argument_list|)
condition|)
comment|/* Ignore if option disabled */
break|break;
comment|/* 	 * Process linemode suboptions. 	 */
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
break|break;
comment|/* garbage was sent */
name|request
operator|=
name|SB_GET
argument_list|()
expr_stmt|;
comment|/* get will/wont */
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
break|break;
comment|/* another garbage check */
if|if
condition|(
name|request
operator|==
name|LM_SLC
condition|)
block|{
comment|/* SLC is not preceeded by WILL or WONT */
comment|/* 		 * Process suboption buffer of slc's 		 */
name|start_slc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|do_opt_slc
argument_list|(
name|subpointer
argument_list|,
name|subend
operator|-
name|subpointer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|end_slc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|request
operator|==
name|LM_MODE
condition|)
block|{
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
return|return;
name|useeditmode
operator|=
name|SB_GET
argument_list|()
expr_stmt|;
comment|/* get mode flag */
name|clientstat
argument_list|(
name|LM_MODE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
break|break;
switch|switch
condition|(
name|SB_GET
argument_list|()
condition|)
block|{
comment|/* what suboption? */
case|case
name|LM_FORWARDMASK
case|:
comment|/* 		 * According to spec, only server can send request for 		 * forwardmask, and client can only return a positive response. 		 * So don't worry about it. 		 */
default|default:
break|break;
block|}
break|break;
block|}
comment|/* end of case TELOPT_LINEMODE */
endif|#
directive|endif
case|case
name|TELOPT_STATUS
case|:
block|{
name|int
name|mode
decl_stmt|;
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
break|break;
name|mode
operator|=
name|SB_GET
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|TELQUAL_SEND
case|:
if|if
condition|(
name|my_state_is_will
argument_list|(
name|TELOPT_STATUS
argument_list|)
condition|)
name|send_status
argument_list|()
expr_stmt|;
break|break;
case|case
name|TELQUAL_IS
case|:
break|break;
default|default:
break|break;
block|}
break|break;
block|}
comment|/* end of case TELOPT_STATUS */
case|case
name|TELOPT_XDISPLOC
case|:
block|{
if|if
condition|(
name|SB_EOF
argument_list|()
operator|||
name|SB_GET
argument_list|()
operator|!=
name|TELQUAL_IS
condition|)
return|return;
name|settimer
argument_list|(
name|xdisplocsubopt
argument_list|)
expr_stmt|;
name|subpointer
index|[
name|SB_LEN
argument_list|()
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|setenv
argument_list|(
literal|"DISPLAY"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|subpointer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* end of case TELOPT_XDISPLOC */
ifdef|#
directive|ifdef
name|TELOPT_NEW_ENVIRON
case|case
name|TELOPT_NEW_ENVIRON
case|:
endif|#
directive|endif
case|case
name|TELOPT_OLD_ENVIRON
case|:
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|varp
decl_stmt|,
modifier|*
name|valp
decl_stmt|;
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
return|return;
name|c
operator|=
name|SB_GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|TELQUAL_IS
condition|)
block|{
if|if
condition|(
name|subchar
operator|==
name|TELOPT_OLD_ENVIRON
condition|)
name|settimer
argument_list|(
name|oenvironsubopt
argument_list|)
expr_stmt|;
else|else
name|settimer
argument_list|(
name|environsubopt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
name|TELQUAL_INFO
condition|)
block|{
return|return;
block|}
ifdef|#
directive|ifdef
name|TELOPT_NEW_ENVIRON
if|if
condition|(
name|subchar
operator|==
name|TELOPT_NEW_ENVIRON
condition|)
block|{
while|while
condition|(
operator|!
name|SB_EOF
argument_list|()
condition|)
block|{
name|c
operator|=
name|SB_GET
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|NEW_ENV_VAR
operator|)
operator|||
operator|(
name|c
operator|==
name|ENV_USERVAR
operator|)
condition|)
break|break;
block|}
block|}
else|else
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|ENV_HACK
comment|/* 	     * We only want to do this if we haven't already decided 	     * whether or not the other side has its VALUE and VAR 	     * reversed. 	     */
if|if
condition|(
name|env_ovar
operator|<
literal|0
condition|)
block|{
specifier|register
name|int
name|last
init|=
operator|-
literal|1
decl_stmt|;
comment|/* invalid value */
name|int
name|empty
init|=
literal|0
decl_stmt|;
name|int
name|got_var
init|=
literal|0
decl_stmt|,
name|got_value
init|=
literal|0
decl_stmt|,
name|got_uservar
init|=
literal|0
decl_stmt|;
comment|/* 		 * The other side might have its VALUE and VAR values 		 * reversed.  To be interoperable, we need to determine 		 * which way it is.  If the first recognized character 		 * is a VAR or VALUE, then that will tell us what 		 * type of client it is.  If the fist recognized 		 * character is a USERVAR, then we continue scanning 		 * the suboption looking for two consecutive 		 * VAR or VALUE fields.  We should not get two 		 * consecutive VALUE fields, so finding two 		 * consecutive VALUE or VAR fields will tell us 		 * what the client is. 		 */
name|SB_SAVE
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|SB_EOF
argument_list|()
condition|)
block|{
name|c
operator|=
name|SB_GET
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OLD_ENV_VAR
case|:
if|if
condition|(
name|last
operator|<
literal|0
operator|||
name|last
operator|==
name|OLD_ENV_VAR
operator|||
operator|(
name|empty
operator|&&
operator|(
name|last
operator|==
name|OLD_ENV_VALUE
operator|)
operator|)
condition|)
goto|goto
name|env_ovar_ok
goto|;
name|got_var
operator|++
expr_stmt|;
name|last
operator|=
name|OLD_ENV_VAR
expr_stmt|;
break|break;
case|case
name|OLD_ENV_VALUE
case|:
if|if
condition|(
name|last
operator|<
literal|0
operator|||
name|last
operator|==
name|OLD_ENV_VALUE
operator|||
operator|(
name|empty
operator|&&
operator|(
name|last
operator|==
name|OLD_ENV_VAR
operator|)
operator|)
condition|)
goto|goto
name|env_ovar_wrong
goto|;
name|got_value
operator|++
expr_stmt|;
name|last
operator|=
name|OLD_ENV_VALUE
expr_stmt|;
break|break;
case|case
name|ENV_USERVAR
case|:
comment|/* count strings of USERVAR as one */
if|if
condition|(
name|last
operator|!=
name|ENV_USERVAR
condition|)
name|got_uservar
operator|++
expr_stmt|;
if|if
condition|(
name|empty
condition|)
block|{
if|if
condition|(
name|last
operator|==
name|OLD_ENV_VALUE
condition|)
goto|goto
name|env_ovar_ok
goto|;
if|if
condition|(
name|last
operator|==
name|OLD_ENV_VAR
condition|)
goto|goto
name|env_ovar_wrong
goto|;
block|}
name|last
operator|=
name|ENV_USERVAR
expr_stmt|;
break|break;
case|case
name|ENV_ESC
case|:
if|if
condition|(
operator|!
name|SB_EOF
argument_list|()
condition|)
name|c
operator|=
name|SB_GET
argument_list|()
expr_stmt|;
comment|/* FALL THROUGH */
default|default:
name|empty
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|empty
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|empty
condition|)
block|{
if|if
condition|(
name|last
operator|==
name|OLD_ENV_VALUE
condition|)
goto|goto
name|env_ovar_ok
goto|;
if|if
condition|(
name|last
operator|==
name|OLD_ENV_VAR
condition|)
goto|goto
name|env_ovar_wrong
goto|;
block|}
comment|/* 		 * Ok, the first thing was a USERVAR, and there 		 * are not two consecutive VAR or VALUE commands, 		 * and none of the VAR or VALUE commands are empty. 		 * If the client has sent us a well-formed option, 		 * then the number of VALUEs received should always 		 * be less than or equal to the number of VARs and 		 * USERVARs received. 		 * 		 * If we got exactly as many VALUEs as VARs and 		 * USERVARs, the client has the same definitions. 		 * 		 * If we got exactly as many VARs as VALUEs and 		 * USERVARS, the client has reversed definitions. 		 */
if|if
condition|(
name|got_uservar
operator|+
name|got_var
operator|==
name|got_value
condition|)
block|{
name|env_ovar_ok
label|:
name|env_ovar
operator|=
name|OLD_ENV_VAR
expr_stmt|;
name|env_ovalue
operator|=
name|OLD_ENV_VALUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|got_uservar
operator|+
name|got_value
operator|==
name|got_var
condition|)
block|{
name|env_ovar_wrong
label|:
name|env_ovar
operator|=
name|OLD_ENV_VALUE
expr_stmt|;
name|env_ovalue
operator|=
name|OLD_ENV_VAR
expr_stmt|;
name|DIAG
argument_list|(
name|TD_OPTIONS
argument_list|,
name|output_data
argument_list|(
literal|"ENVIRON VALUE and VAR are reversed!\r\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|SB_RESTORE
argument_list|()
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|!
name|SB_EOF
argument_list|()
condition|)
block|{
name|c
operator|=
name|SB_GET
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|env_ovar
operator|)
operator|||
operator|(
name|c
operator|==
name|ENV_USERVAR
operator|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
return|return;
name|cp
operator|=
name|varp
operator|=
operator|(
name|char
operator|*
operator|)
name|subpointer
expr_stmt|;
name|valp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|SB_EOF
argument_list|()
condition|)
block|{
name|c
operator|=
name|SB_GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|subchar
operator|==
name|TELOPT_OLD_ENVIRON
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|env_ovar
condition|)
name|c
operator|=
name|NEW_ENV_VAR
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|env_ovalue
condition|)
name|c
operator|=
name|NEW_ENV_VALUE
expr_stmt|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|NEW_ENV_VALUE
case|:
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
name|valp
operator|=
operator|(
name|char
operator|*
operator|)
name|subpointer
expr_stmt|;
break|break;
case|case
name|NEW_ENV_VAR
case|:
case|case
name|ENV_USERVAR
case|:
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|valp
condition|)
operator|(
name|void
operator|)
name|setenv
argument_list|(
name|varp
argument_list|,
name|valp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|unsetenv
argument_list|(
name|varp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|varp
operator|=
operator|(
name|char
operator|*
operator|)
name|subpointer
expr_stmt|;
name|valp
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ENV_ESC
case|:
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
break|break;
name|c
operator|=
name|SB_GET
argument_list|()
expr_stmt|;
comment|/* FALL THROUGH */
default|default:
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|valp
condition|)
operator|(
name|void
operator|)
name|setenv
argument_list|(
name|varp
argument_list|,
name|valp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|unsetenv
argument_list|(
name|varp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* end of case TELOPT_NEW_ENVIRON */
if|#
directive|if
name|defined
argument_list|(
name|AUTHENTICATION
argument_list|)
case|case
name|TELOPT_AUTHENTICATION
case|:
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
break|break;
switch|switch
condition|(
name|SB_GET
argument_list|()
condition|)
block|{
case|case
name|TELQUAL_SEND
case|:
case|case
name|TELQUAL_REPLY
case|:
comment|/* 		 * These are sent by us and cannot be sent by 		 * the client. 		 */
break|break;
case|case
name|TELQUAL_IS
case|:
name|auth_is
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|TELQUAL_NAME
case|:
name|auth_name
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENCRYPTION
case|case
name|TELOPT_ENCRYPT
case|:
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
break|break;
switch|switch
condition|(
name|SB_GET
argument_list|()
condition|)
block|{
case|case
name|ENCRYPT_SUPPORT
case|:
name|encrypt_support
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCRYPT_IS
case|:
name|encrypt_is
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCRYPT_REPLY
case|:
name|encrypt_reply
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCRYPT_START
case|:
name|encrypt_start
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCRYPT_END
case|:
name|encrypt_end
argument_list|()
expr_stmt|;
break|break;
case|case
name|ENCRYPT_REQSTART
case|:
name|encrypt_request_start
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCRYPT_REQEND
case|:
comment|/* 		 * We can always send an REQEND so that we cannot 		 * get stuck encrypting.  We should only get this 		 * if we have been able to get in the correct mode 		 * anyhow. 		 */
name|encrypt_request_end
argument_list|()
expr_stmt|;
break|break;
case|case
name|ENCRYPT_ENC_KEYID
case|:
name|encrypt_enc_keyid
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCRYPT_DEC_KEYID
case|:
name|encrypt_dec_keyid
argument_list|(
name|subpointer
argument_list|,
name|SB_LEN
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
endif|#
directive|endif
comment|/* ENCRYPTION */
default|default:
break|break;
block|}
comment|/* end of switch */
block|}
end_function

begin_comment
comment|/* end of suboption */
end_comment

begin_function
name|void
name|doclientstat
parameter_list|()
block|{
name|clientstat
argument_list|(
name|TELOPT_LINEMODE
argument_list|,
name|WILL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|ADD
parameter_list|(
name|c
parameter_list|)
value|*ncp++ = c
end_define

begin_define
define|#
directive|define
name|ADD_DATA
parameter_list|(
name|c
parameter_list|)
value|{ *ncp++ = c; if (c == SE || c == IAC) *ncp++ = c; }
end_define

begin_function
name|void
name|send_status
parameter_list|()
block|{
name|unsigned
name|char
name|statusbuf
index|[
literal|256
index|]
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|ncp
decl_stmt|;
specifier|register
name|unsigned
name|char
name|i
decl_stmt|;
name|ncp
operator|=
name|statusbuf
expr_stmt|;
name|netflush
argument_list|()
expr_stmt|;
comment|/* get rid of anything waiting to go out */
name|ADD
argument_list|(
name|IAC
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|SB
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|TELOPT_STATUS
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|TELQUAL_IS
argument_list|)
expr_stmt|;
comment|/* 	 * We check the want_state rather than the current state, 	 * because if we received a DO/WILL for an option that we 	 * don't support, and the other side didn't send a DONT/WONT 	 * in response to our WONT/DONT, then the "state" will be 	 * WILL/DO, and the "want_state" will be WONT/DONT.  We 	 * need to go by the latter. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|unsigned
name|char
operator|)
name|NTELOPTS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|my_want_state_is_will
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|ADD
argument_list|(
name|WILL
argument_list|)
expr_stmt|;
name|ADD_DATA
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|his_want_state_is_will
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|ADD
argument_list|(
name|DO
argument_list|)
expr_stmt|;
name|ADD_DATA
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|his_want_state_is_will
argument_list|(
name|TELOPT_LFLOW
argument_list|)
condition|)
block|{
name|ADD
argument_list|(
name|SB
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|TELOPT_LFLOW
argument_list|)
expr_stmt|;
if|if
condition|(
name|flowmode
condition|)
block|{
name|ADD
argument_list|(
name|LFLOW_ON
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ADD
argument_list|(
name|LFLOW_OFF
argument_list|)
expr_stmt|;
block|}
name|ADD
argument_list|(
name|SE
argument_list|)
expr_stmt|;
if|if
condition|(
name|restartany
operator|>=
literal|0
condition|)
block|{
name|ADD
argument_list|(
name|SB
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|TELOPT_LFLOW
argument_list|)
expr_stmt|;
if|if
condition|(
name|restartany
condition|)
block|{
name|ADD
argument_list|(
name|LFLOW_RESTART_ANY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ADD
argument_list|(
name|LFLOW_RESTART_XON
argument_list|)
expr_stmt|;
block|}
name|ADD
argument_list|(
name|SE
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|LINEMODE
if|if
condition|(
name|his_want_state_is_will
argument_list|(
name|TELOPT_LINEMODE
argument_list|)
condition|)
block|{
name|unsigned
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cpe
decl_stmt|;
name|int
name|len
decl_stmt|;
name|ADD
argument_list|(
name|SB
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|TELOPT_LINEMODE
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|LM_MODE
argument_list|)
expr_stmt|;
name|ADD_DATA
argument_list|(
name|editmode
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|SE
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|SB
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|TELOPT_LINEMODE
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|LM_SLC
argument_list|)
expr_stmt|;
name|start_slc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|send_slc
argument_list|()
expr_stmt|;
name|len
operator|=
name|end_slc
argument_list|(
operator|&
name|cp
argument_list|)
expr_stmt|;
for|for
control|(
name|cpe
operator|=
name|cp
operator|+
name|len
init|;
name|cp
operator|<
name|cpe
condition|;
name|cp
operator|++
control|)
name|ADD_DATA
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|SE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* LINEMODE */
name|ADD
argument_list|(
name|IAC
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|SE
argument_list|)
expr_stmt|;
name|writenet
argument_list|(
name|statusbuf
argument_list|,
name|ncp
operator|-
name|statusbuf
argument_list|)
expr_stmt|;
name|netflush
argument_list|()
expr_stmt|;
comment|/* Send it on its way */
name|DIAG
argument_list|(
argument|TD_OPTIONS
argument_list|,
argument|{printsub(
literal|'>'
argument|, statusbuf, ncp - statusbuf); netflush();}
argument_list|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function appends data to nfrontp and advances nfrontp.  */
end_comment

begin_function
name|int
name|output_data
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|size_t
name|remaining
decl_stmt|,
name|ret
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|remaining
operator|=
name|BUFSIZ
operator|-
operator|(
name|nfrontp
operator|-
name|netobuf
operator|)
expr_stmt|;
comment|/* try a netflush() if the room is too low */
if|if
condition|(
name|strlen
argument_list|(
name|format
argument_list|)
operator|>
name|remaining
operator|||
name|BUFSIZ
operator|/
literal|4
operator|>
name|remaining
condition|)
block|{
name|netflush
argument_list|()
expr_stmt|;
name|remaining
operator|=
name|BUFSIZ
operator|-
operator|(
name|nfrontp
operator|-
name|netobuf
operator|)
expr_stmt|;
block|}
name|ret
operator|=
name|vsnprintf
argument_list|(
name|nfrontp
argument_list|,
name|remaining
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|nfrontp
operator|+=
operator|(
operator|(
name|ret
operator|<
name|remaining
operator|-
literal|1
operator|)
condition|?
name|ret
else|:
name|remaining
operator|-
literal|1
operator|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|output_datalen
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|size_t
name|remaining
decl_stmt|;
name|remaining
operator|=
name|BUFSIZ
operator|-
operator|(
name|nfrontp
operator|-
name|netobuf
operator|)
expr_stmt|;
if|if
condition|(
name|remaining
operator|<
name|len
condition|)
block|{
name|netflush
argument_list|()
expr_stmt|;
name|remaining
operator|=
name|BUFSIZ
operator|-
operator|(
name|nfrontp
operator|-
name|netobuf
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|remaining
operator|<
name|len
condition|)
return|return
operator|-
literal|1
return|;
name|memmove
argument_list|(
name|nfrontp
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|nfrontp
operator|+=
name|len
expr_stmt|;
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

end_unit

