begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * evaluate the dc language, from a FILE* or a string  *  * Copyright (C) 1994, 1997, 1998 Free Software Foundation, Inc.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2, or (at your option)  * any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, you can either send email to this  * program's author (see below) or write to: The Free Software Foundation,  * Inc.; 675 Mass Ave. Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This is the only module which knows about the dc input language */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* memchr */
end_comment

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MEMORY_H
end_ifdef

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_comment
comment|/* memchr, maybe */
end_comment

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRINGS_H
end_ifdef

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_comment
comment|/* memchr, maybe */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"dc.h"
end_include

begin_include
include|#
directive|include
file|"dc-proto.h"
end_include

begin_typedef
typedef|typedef
enum|enum
block|{
name|DC_FALSE
block|,
name|DC_TRUE
block|}
name|dc_boolean
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|DC_OKAY
init|=
name|DC_SUCCESS
block|,
comment|/* no further intervention needed for this command */
name|DC_EATONE
block|,
comment|/* caller needs to eat the lookahead char */
name|DC_QUIT
block|,
comment|/* quit out of unwind_depth levels of evaluation */
comment|/* with the following return values, the caller does not have to  	 * fret about stdin_lookahead's value 	 */
name|DC_INT
block|,
comment|/* caller needs to parse a dc_num from input stream */
name|DC_STR
block|,
comment|/* caller needs to parse a dc_str from input stream */
name|DC_SYSTEM
block|,
comment|/* caller needs to run a system() on next input line */
name|DC_COMMENT
block|,
comment|/* caller needs to skip to the next input line */
name|DC_NEGCMP
block|,
comment|/* caller needs to re-call dc_func() with `negcmp' set */
name|DC_EOF_ERROR
comment|/* unexpected end of input; abort current eval */
block|}
name|dc_status
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|int
name|dc_ibase
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input base, 2<= dc_ibase<= DC_IBASE_MAX */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dc_obase
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output base, 2<= dc_obase */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dc_scale
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scale (see user documentaton) */
end_comment

begin_comment
comment|/* for Quitting evaluations */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unwind_depth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if true, active Quit will not exit program */
end_comment

begin_decl_stmt
specifier|static
name|dc_boolean
name|unwind_noexit
init|=
name|DC_FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Used to synchronize lookahead on stdin for '?' command.  * If set to EOF then lookahead is used up.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stdin_lookahead
init|=
name|EOF
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* input_fil and input_str are passed as arguments to dc_getnum */
end_comment

begin_comment
comment|/* used by the input_* functions: */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|input_fil_fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|input_str_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Since we have a need for two characters of pushback, and  * ungetc() only guarantees one, we place the second pushback here  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|input_pushback
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* passed as an argument to dc_getnum */
end_comment

begin_function
specifier|static
name|int
name|input_fil
name|DC_DECLVOID
parameter_list|()
block|{
if|if
condition|(
name|input_pushback
operator|!=
name|EOF
condition|)
block|{
name|int
name|c
init|=
name|input_pushback
decl_stmt|;
name|input_pushback
operator|=
name|EOF
expr_stmt|;
return|return
name|c
return|;
block|}
return|return
name|getc
argument_list|(
name|input_fil_fp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* passed as an argument to dc_getnum */
end_comment

begin_function
specifier|static
name|int
name|input_str
name|DC_DECLVOID
parameter_list|()
block|{
if|if
condition|(
operator|!
operator|*
name|input_str_string
condition|)
return|return
name|EOF
return|;
return|return
operator|*
name|input_str_string
operator|++
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* takes a string and evals it; frees the string when done */
end_comment

begin_comment
comment|/* Wrapper around dc_evalstr to avoid duplicating the free call  * at all possible return points.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dc_eval_and_free_str
name|DC_DECLARG
argument_list|(
operator|(
name|string
operator|)
argument_list|)
name|dc_data
name|string
name|DC_DECLEND
block|{
name|dc_status
name|status
decl_stmt|;
name|status
operator|=
name|dc_evalstr
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
operator|.
name|dc_type
operator|==
name|DC_STRING
condition|)
name|dc_free_str
argument_list|(
operator|&
name|string
operator|.
name|v
operator|.
name|string
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* dc_func does the grunt work of figuring out what each input  * character means; used by both dc_evalstr and dc_evalfile  *  * c -> the "current" input character under consideration  * peekc -> the lookahead input character  * negcmp -> negate comparison test (for<,=,> commands)  */
end_comment

begin_decl_stmt
specifier|static
name|dc_status
name|dc_func
name|DC_DECLARG
argument_list|(
operator|(
name|c
operator|,
name|peekc
operator|,
name|negcmp
operator|)
argument_list|)
name|int
name|c
name|DC_DECLSEP
name|int
name|peekc
name|DC_DECLSEP
name|int
name|negcmp
name|DC_DECLEND
block|{
comment|/* we occasionally need these for temporary data */
comment|/* Despite the GNU coding standards, it is much easier 	 * to have these declared once here, since this function 	 * is just one big switch statement. 	 */
name|dc_data
name|datum
decl_stmt|;
name|int
name|tmpint
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'_'
case|:
case|case
literal|'.'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
return|return
name|DC_INT
return|;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
comment|/* standard command separators */
break|break;
case|case
literal|'+'
case|:
comment|/* add top two stack elements */
name|dc_binop
argument_list|(
name|dc_add
argument_list|,
name|dc_scale
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
comment|/* subtract top two stack elements */
name|dc_binop
argument_list|(
name|dc_sub
argument_list|,
name|dc_scale
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
comment|/* multiply top two stack elements */
name|dc_binop
argument_list|(
name|dc_mul
argument_list|,
name|dc_scale
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
comment|/* divide top two stack elements */
name|dc_binop
argument_list|(
name|dc_div
argument_list|,
name|dc_scale
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
comment|/* take the remainder from division of the top two stack elements */
name|dc_binop
argument_list|(
name|dc_rem
argument_list|,
name|dc_scale
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
comment|/* Do division on the top two stack elements.  Return the 		 * quotient as next-to-top of stack and the remainder as 		 * top-of-stack. 		 */
name|dc_binop2
argument_list|(
name|dc_divrem
argument_list|,
name|dc_scale
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
comment|/* Consider the top three elements of the stack as (base, exp, mod), 		 * where mod is top-of-stack, exp is next-to-top, and base is 		 * second-from-top.  Mod must be non-zero and exp must be a 		 * non-negative integer.   Push the result of raising base to the exp 		 * power, reduced modulo mod.  If we had base in register b, exp in 		 * register e, and mod in register m then this is conceptually 		 * equivalent to "lble^lm%", but it is implemented in a more efficient 		 * manner, and can handle arbritrarily large values for exp. 		 */
name|dc_triop
argument_list|(
name|dc_modexp
argument_list|,
name|dc_scale
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
comment|/* exponientiation of the top two stack elements */
name|dc_binop
argument_list|(
name|dc_exp
argument_list|,
name|dc_scale
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
comment|/* eval register named by peekc if 		 * less-than holds for top two stack elements 		 */
if|if
condition|(
name|peekc
operator|==
name|EOF
condition|)
return|return
name|DC_EOF_ERROR
return|;
if|if
condition|(
operator|(
name|dc_cmpop
argument_list|()
operator|<
literal|0
operator|)
operator|==
operator|!
name|negcmp
condition|)
if|if
condition|(
name|dc_register_get
argument_list|(
name|peekc
argument_list|,
operator|&
name|datum
argument_list|)
operator|==
name|DC_SUCCESS
condition|)
if|if
condition|(
name|dc_eval_and_free_str
argument_list|(
name|datum
argument_list|)
operator|==
name|DC_QUIT
condition|)
return|return
name|DC_QUIT
return|;
return|return
name|DC_EATONE
return|;
case|case
literal|'='
case|:
comment|/* eval register named by peekc if 		 * equal-to holds for top two stack elements 		 */
if|if
condition|(
name|peekc
operator|==
name|EOF
condition|)
return|return
name|DC_EOF_ERROR
return|;
if|if
condition|(
operator|(
name|dc_cmpop
argument_list|()
operator|==
literal|0
operator|)
operator|==
operator|!
name|negcmp
condition|)
if|if
condition|(
name|dc_register_get
argument_list|(
name|peekc
argument_list|,
operator|&
name|datum
argument_list|)
operator|==
name|DC_SUCCESS
condition|)
if|if
condition|(
name|dc_eval_and_free_str
argument_list|(
name|datum
argument_list|)
operator|==
name|DC_QUIT
condition|)
return|return
name|DC_QUIT
return|;
return|return
name|DC_EATONE
return|;
case|case
literal|'>'
case|:
comment|/* eval register named by peekc if 		 * greater-than holds for top two stack elements 		 */
if|if
condition|(
name|peekc
operator|==
name|EOF
condition|)
return|return
name|DC_EOF_ERROR
return|;
if|if
condition|(
operator|(
name|dc_cmpop
argument_list|()
operator|>
literal|0
operator|)
operator|==
operator|!
name|negcmp
condition|)
if|if
condition|(
name|dc_register_get
argument_list|(
name|peekc
argument_list|,
operator|&
name|datum
argument_list|)
operator|==
name|DC_SUCCESS
condition|)
if|if
condition|(
name|dc_eval_and_free_str
argument_list|(
name|datum
argument_list|)
operator|==
name|DC_QUIT
condition|)
return|return
name|DC_QUIT
return|;
return|return
name|DC_EATONE
return|;
case|case
literal|'?'
case|:
comment|/* read a line from standard-input and eval it */
if|if
condition|(
name|stdin_lookahead
operator|!=
name|EOF
condition|)
block|{
name|ungetc
argument_list|(
name|stdin_lookahead
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|stdin_lookahead
operator|=
name|EOF
expr_stmt|;
block|}
if|if
condition|(
name|dc_eval_and_free_str
argument_list|(
name|dc_readstring
argument_list|(
name|stdin
argument_list|,
literal|'\n'
argument_list|,
literal|'\n'
argument_list|)
argument_list|)
operator|==
name|DC_QUIT
condition|)
return|return
name|DC_QUIT
return|;
return|return
name|DC_OKAY
return|;
case|case
literal|'['
case|:
comment|/* read to balancing ']' into a dc_str */
return|return
name|DC_STR
return|;
case|case
literal|'!'
case|:
comment|/* read to newline and call system() on resulting string */
if|if
condition|(
name|peekc
operator|==
literal|'<'
operator|||
name|peekc
operator|==
literal|'='
operator|||
name|peekc
operator|==
literal|'>'
condition|)
return|return
name|DC_NEGCMP
return|;
return|return
name|DC_SYSTEM
return|;
case|case
literal|'#'
case|:
comment|/* comment; skip remainder of current line */
return|return
name|DC_COMMENT
return|;
case|case
literal|'a'
case|:
comment|/* Convert top of stack to an ascii character. */
if|if
condition|(
name|dc_pop
argument_list|(
operator|&
name|datum
argument_list|)
operator|==
name|DC_SUCCESS
condition|)
block|{
name|char
name|tmps
decl_stmt|;
if|if
condition|(
name|datum
operator|.
name|dc_type
operator|==
name|DC_NUMBER
condition|)
block|{
name|tmps
operator|=
operator|(
name|char
operator|)
name|dc_num2int
argument_list|(
name|datum
operator|.
name|v
operator|.
name|number
argument_list|,
name|DC_TOSS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|datum
operator|.
name|dc_type
operator|==
name|DC_STRING
condition|)
block|{
name|tmps
operator|=
operator|*
name|dc_str2charp
argument_list|(
name|datum
operator|.
name|v
operator|.
name|string
argument_list|)
expr_stmt|;
name|dc_free_str
argument_list|(
operator|&
name|datum
operator|.
name|v
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dc_garbage
argument_list|(
literal|"at top of stack"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|dc_push
argument_list|(
name|dc_makestring
argument_list|(
operator|&
name|tmps
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'c'
case|:
comment|/* clear whole stack */
name|dc_clear_stack
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* duplicate the datum on the top of stack */
if|if
condition|(
name|dc_top_of_stack
argument_list|(
operator|&
name|datum
argument_list|)
operator|==
name|DC_SUCCESS
condition|)
name|dc_push
argument_list|(
name|dc_dup
argument_list|(
name|datum
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* print list of all stack items */
name|dc_printall
argument_list|(
name|dc_obase
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* set input base to value on top of stack */
if|if
condition|(
name|dc_pop
argument_list|(
operator|&
name|datum
argument_list|)
operator|==
name|DC_SUCCESS
condition|)
block|{
name|tmpint
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|datum
operator|.
name|dc_type
operator|==
name|DC_NUMBER
condition|)
name|tmpint
operator|=
name|dc_num2int
argument_list|(
name|datum
operator|.
name|v
operator|.
name|number
argument_list|,
name|DC_TOSS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
literal|2
operator|<=
name|tmpint
operator|&&
name|tmpint
operator|<=
name|DC_IBASE_MAX
operator|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: input base must be a number \ between 2 and %d (inclusive)\n"
argument_list|,
name|progname
argument_list|,
name|DC_IBASE_MAX
argument_list|)
expr_stmt|;
else|else
name|dc_ibase
operator|=
name|tmpint
expr_stmt|;
block|}
break|break;
case|case
literal|'k'
case|:
comment|/* set scale to value on top of stack */
if|if
condition|(
name|dc_pop
argument_list|(
operator|&
name|datum
argument_list|)
operator|==
name|DC_SUCCESS
condition|)
block|{
name|tmpint
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|datum
operator|.
name|dc_type
operator|==
name|DC_NUMBER
condition|)
name|tmpint
operator|=
name|dc_num2int
argument_list|(
name|datum
operator|.
name|v
operator|.
name|number
argument_list|,
name|DC_TOSS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmpint
operator|>=
literal|0
operator|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: scale must be a nonnegative number\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
else|else
name|dc_scale
operator|=
name|tmpint
expr_stmt|;
block|}
break|break;
case|case
literal|'l'
case|:
comment|/* "load" -- push value on top of register stack named 				 * by peekc onto top of evaluation stack; does not 				 * modify the register stack 				 */
if|if
condition|(
name|peekc
operator|==
name|EOF
condition|)
return|return
name|DC_EOF_ERROR
return|;
if|if
condition|(
name|dc_register_get
argument_list|(
name|peekc
argument_list|,
operator|&
name|datum
argument_list|)
operator|==
name|DC_SUCCESS
condition|)
name|dc_push
argument_list|(
name|datum
argument_list|)
expr_stmt|;
return|return
name|DC_EATONE
return|;
case|case
literal|'n'
case|:
comment|/* print the value popped off of top-of-stack; 				 * do not add a trailing newline 				 */
if|if
condition|(
name|dc_pop
argument_list|(
operator|&
name|datum
argument_list|)
operator|==
name|DC_SUCCESS
condition|)
name|dc_print
argument_list|(
name|datum
argument_list|,
name|dc_obase
argument_list|,
name|DC_NONL
argument_list|,
name|DC_TOSS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* set output base to value on top of stack */
if|if
condition|(
name|dc_pop
argument_list|(
operator|&
name|datum
argument_list|)
operator|==
name|DC_SUCCESS
condition|)
block|{
name|tmpint
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|datum
operator|.
name|dc_type
operator|==
name|DC_NUMBER
condition|)
name|tmpint
operator|=
name|dc_num2int
argument_list|(
name|datum
operator|.
name|v
operator|.
name|number
argument_list|,
name|DC_TOSS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmpint
operator|>
literal|1
operator|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: output base must be a number greater than 1\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
else|else
name|dc_obase
operator|=
name|tmpint
expr_stmt|;
block|}
break|break;
case|case
literal|'p'
case|:
comment|/* print the datum on the top of stack, 				 * with a trailing newline 				 */
if|if
condition|(
name|dc_top_of_stack
argument_list|(
operator|&
name|datum
argument_list|)
operator|==
name|DC_SUCCESS
condition|)
name|dc_print
argument_list|(
name|datum
argument_list|,
name|dc_obase
argument_list|,
name|DC_WITHNL
argument_list|,
name|DC_KEEP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* quit two levels of evaluation, posibly exiting program */
name|unwind_depth
operator|=
literal|1
expr_stmt|;
comment|/* the return below is the first level of returns */
name|unwind_noexit
operator|=
name|DC_FALSE
expr_stmt|;
return|return
name|DC_QUIT
return|;
case|case
literal|'r'
case|:
comment|/* rotate (swap) the top two elements on the stack 				 */
if|if
condition|(
name|dc_pop
argument_list|(
operator|&
name|datum
argument_list|)
operator|==
name|DC_SUCCESS
condition|)
block|{
name|dc_data
name|datum2
decl_stmt|;
name|int
name|two_status
decl_stmt|;
name|two_status
operator|=
name|dc_pop
argument_list|(
operator|&
name|datum2
argument_list|)
expr_stmt|;
name|dc_push
argument_list|(
name|datum
argument_list|)
expr_stmt|;
if|if
condition|(
name|two_status
operator|==
name|DC_SUCCESS
condition|)
name|dc_push
argument_list|(
name|datum2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'s'
case|:
comment|/* "store" -- replace top of register stack named 				 * by peekc with the value popped from the top 				 * of the evaluation stack 				 */
if|if
condition|(
name|peekc
operator|==
name|EOF
condition|)
return|return
name|DC_EOF_ERROR
return|;
if|if
condition|(
name|dc_pop
argument_list|(
operator|&
name|datum
argument_list|)
operator|==
name|DC_SUCCESS
condition|)
name|dc_register_set
argument_list|(
name|peekc
argument_list|,
name|datum
argument_list|)
expr_stmt|;
return|return
name|DC_EATONE
return|;
case|case
literal|'v'
case|:
comment|/* replace top of stack with its square root */
if|if
condition|(
name|dc_pop
argument_list|(
operator|&
name|datum
argument_list|)
operator|==
name|DC_SUCCESS
condition|)
block|{
name|dc_num
name|tmpnum
decl_stmt|;
if|if
condition|(
name|datum
operator|.
name|dc_type
operator|!=
name|DC_NUMBER
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: square root of nonnumeric attempted\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dc_sqrt
argument_list|(
name|datum
operator|.
name|v
operator|.
name|number
argument_list|,
name|dc_scale
argument_list|,
operator|&
name|tmpnum
argument_list|)
operator|==
name|DC_SUCCESS
condition|)
block|{
name|dc_free_num
argument_list|(
operator|&
name|datum
operator|.
name|v
operator|.
name|number
argument_list|)
expr_stmt|;
name|datum
operator|.
name|v
operator|.
name|number
operator|=
name|tmpnum
expr_stmt|;
name|dc_push
argument_list|(
name|datum
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'x'
case|:
comment|/* eval the datum popped from top of stack */
if|if
condition|(
name|dc_pop
argument_list|(
operator|&
name|datum
argument_list|)
operator|==
name|DC_SUCCESS
condition|)
block|{
if|if
condition|(
name|datum
operator|.
name|dc_type
operator|==
name|DC_STRING
condition|)
block|{
if|if
condition|(
name|dc_eval_and_free_str
argument_list|(
name|datum
argument_list|)
operator|==
name|DC_QUIT
condition|)
return|return
name|DC_QUIT
return|;
block|}
elseif|else
if|if
condition|(
name|datum
operator|.
name|dc_type
operator|==
name|DC_NUMBER
condition|)
block|{
name|dc_push
argument_list|(
name|datum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dc_garbage
argument_list|(
literal|"at top of stack"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'z'
case|:
comment|/* push the current stack depth onto the top of stack */
name|dc_push
argument_list|(
name|dc_int2data
argument_list|(
name|dc_tell_stackdepth
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* push the current input base onto the stack */
name|dc_push
argument_list|(
name|dc_int2data
argument_list|(
name|dc_ibase
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
comment|/* push the current scale onto the stack */
name|dc_push
argument_list|(
name|dc_int2data
argument_list|(
name|dc_scale
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* pop a value off of register stack named by peekc 				 * and push it onto the evaluation stack 				 */
if|if
condition|(
name|peekc
operator|==
name|EOF
condition|)
return|return
name|DC_EOF_ERROR
return|;
if|if
condition|(
name|dc_register_pop
argument_list|(
name|peekc
argument_list|,
operator|&
name|datum
argument_list|)
operator|==
name|DC_SUCCESS
condition|)
name|dc_push
argument_list|(
name|datum
argument_list|)
expr_stmt|;
return|return
name|DC_EATONE
return|;
case|case
literal|'O'
case|:
comment|/* push the current output base onto the stack */
name|dc_push
argument_list|(
name|dc_int2data
argument_list|(
name|dc_obase
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* Pop the value off the top of a stack.  If it is 		 * a number, dump out the integer portion of its 		 * absolute value as a "base UCHAR_MAX+1" byte stream; 		 * if it is a string, just print it. 		 * In either case, do not append a trailing newline. 		 */
if|if
condition|(
name|dc_pop
argument_list|(
operator|&
name|datum
argument_list|)
operator|==
name|DC_SUCCESS
condition|)
block|{
if|if
condition|(
name|datum
operator|.
name|dc_type
operator|==
name|DC_NUMBER
condition|)
name|dc_dump_num
argument_list|(
name|datum
operator|.
name|v
operator|.
name|number
argument_list|,
name|DC_TOSS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|datum
operator|.
name|dc_type
operator|==
name|DC_STRING
condition|)
name|dc_out_str
argument_list|(
name|datum
operator|.
name|v
operator|.
name|string
argument_list|,
name|DC_NONL
argument_list|,
name|DC_TOSS
argument_list|)
expr_stmt|;
else|else
name|dc_garbage
argument_list|(
literal|"at top of stack"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'Q'
case|:
comment|/* quit out of top-of-stack nested evals; 				 * pops value from stack; 				 * does not exit program (stops short if necessary) 				 */
if|if
condition|(
name|dc_pop
argument_list|(
operator|&
name|datum
argument_list|)
operator|==
name|DC_SUCCESS
condition|)
block|{
name|unwind_depth
operator|=
literal|0
expr_stmt|;
name|unwind_noexit
operator|=
name|DC_TRUE
expr_stmt|;
if|if
condition|(
name|datum
operator|.
name|dc_type
operator|==
name|DC_NUMBER
condition|)
name|unwind_depth
operator|=
name|dc_num2int
argument_list|(
name|datum
operator|.
name|v
operator|.
name|number
argument_list|,
name|DC_TOSS
argument_list|)
expr_stmt|;
if|if
condition|(
name|unwind_depth
operator|--
operator|>
literal|0
condition|)
return|return
name|DC_QUIT
return|;
name|unwind_depth
operator|=
literal|0
expr_stmt|;
comment|/* paranoia */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Q command requires a number>= 1\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
block|}
break|break;
if|#
directive|if
literal|0
block|case 'R':
comment|/* pop a value off of the evaluation stack,; 				 * rotate the top 				 remaining stack elements that many 				 * places forward (negative numbers mean rotate 				 * backward). 				 */
block|if (dc_pop(&datum) == DC_SUCCESS){ 			tmpint = 0; 			if (datum.dc_type == DC_NUMBER) 				tmpint = dc_num2int(datum.v.number, DC_TOSS); 			dc_stack_rotate(tmpint); 		} 		break;
endif|#
directive|endif
case|case
literal|'S'
case|:
comment|/* pop a value off of the evaluation stack 				 * and push it onto the register stack named by peekc 				 */
if|if
condition|(
name|peekc
operator|==
name|EOF
condition|)
return|return
name|DC_EOF_ERROR
return|;
if|if
condition|(
name|dc_pop
argument_list|(
operator|&
name|datum
argument_list|)
operator|==
name|DC_SUCCESS
condition|)
name|dc_register_push
argument_list|(
name|peekc
argument_list|,
name|datum
argument_list|)
expr_stmt|;
return|return
name|DC_EATONE
return|;
case|case
literal|'X'
case|:
comment|/* replace the number on top-of-stack with its scale factor */
if|if
condition|(
name|dc_pop
argument_list|(
operator|&
name|datum
argument_list|)
operator|==
name|DC_SUCCESS
condition|)
block|{
name|tmpint
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|datum
operator|.
name|dc_type
operator|==
name|DC_NUMBER
condition|)
name|tmpint
operator|=
name|dc_tell_scale
argument_list|(
name|datum
operator|.
name|v
operator|.
name|number
argument_list|,
name|DC_TOSS
argument_list|)
expr_stmt|;
name|dc_push
argument_list|(
name|dc_int2data
argument_list|(
name|tmpint
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'Z'
case|:
comment|/* replace the datum on the top-of-stack with its length */
if|if
condition|(
name|dc_pop
argument_list|(
operator|&
name|datum
argument_list|)
operator|==
name|DC_SUCCESS
condition|)
name|dc_push
argument_list|(
name|dc_int2data
argument_list|(
name|dc_tell_length
argument_list|(
name|datum
argument_list|,
name|DC_TOSS
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|':'
case|:
comment|/* store into array */
if|if
condition|(
name|peekc
operator|==
name|EOF
condition|)
return|return
name|DC_EOF_ERROR
return|;
if|if
condition|(
name|dc_pop
argument_list|(
operator|&
name|datum
argument_list|)
operator|==
name|DC_SUCCESS
condition|)
block|{
name|tmpint
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|datum
operator|.
name|dc_type
operator|==
name|DC_NUMBER
condition|)
name|tmpint
operator|=
name|dc_num2int
argument_list|(
name|datum
operator|.
name|v
operator|.
name|number
argument_list|,
name|DC_TOSS
argument_list|)
expr_stmt|;
if|if
condition|(
name|dc_pop
argument_list|(
operator|&
name|datum
argument_list|)
operator|==
name|DC_SUCCESS
condition|)
block|{
if|if
condition|(
name|tmpint
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: array index must be a nonnegative integer\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
else|else
name|dc_array_set
argument_list|(
name|peekc
argument_list|,
name|tmpint
argument_list|,
name|datum
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|DC_EATONE
return|;
case|case
literal|';'
case|:
comment|/* retreive from array */
if|if
condition|(
name|peekc
operator|==
name|EOF
condition|)
return|return
name|DC_EOF_ERROR
return|;
if|if
condition|(
name|dc_pop
argument_list|(
operator|&
name|datum
argument_list|)
operator|==
name|DC_SUCCESS
condition|)
block|{
name|tmpint
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|datum
operator|.
name|dc_type
operator|==
name|DC_NUMBER
condition|)
name|tmpint
operator|=
name|dc_num2int
argument_list|(
name|datum
operator|.
name|v
operator|.
name|number
argument_list|,
name|DC_TOSS
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpint
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: array index must be a nonnegative integer\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
else|else
name|dc_push
argument_list|(
name|dc_array_get
argument_list|(
name|peekc
argument_list|,
name|tmpint
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|DC_EATONE
return|;
default|default:
comment|/* What did that user mean? */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|dc_show_id
argument_list|(
name|stdout
argument_list|,
name|c
argument_list|,
literal|" unimplemented\n"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|DC_OKAY
return|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* takes a string and evals it */
end_comment

begin_decl_stmt
name|int
name|dc_evalstr
name|DC_DECLARG
argument_list|(
operator|(
name|string
operator|)
argument_list|)
name|dc_data
name|string
name|DC_DECLEND
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|peekc
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|negcmp
decl_stmt|;
name|int
name|next_negcmp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|string
operator|.
name|dc_type
operator|!=
name|DC_STRING
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: eval called with non-string argument\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
return|return
name|DC_OKAY
return|;
block|}
name|s
operator|=
name|dc_str2charp
argument_list|(
name|string
operator|.
name|v
operator|.
name|string
argument_list|)
expr_stmt|;
name|end
operator|=
name|s
operator|+
name|dc_strlen
argument_list|(
name|string
operator|.
name|v
operator|.
name|string
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|end
condition|)
block|{
name|c
operator|=
operator|*
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|s
operator|++
expr_stmt|;
name|peekc
operator|=
name|EOF
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|end
condition|)
name|peekc
operator|=
operator|*
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|s
expr_stmt|;
name|negcmp
operator|=
name|next_negcmp
expr_stmt|;
name|next_negcmp
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|dc_func
argument_list|(
name|c
argument_list|,
name|peekc
argument_list|,
name|negcmp
argument_list|)
condition|)
block|{
case|case
name|DC_OKAY
case|:
break|break;
case|case
name|DC_EATONE
case|:
if|if
condition|(
name|peekc
operator|!=
name|EOF
condition|)
operator|++
name|s
expr_stmt|;
break|break;
case|case
name|DC_QUIT
case|:
if|if
condition|(
name|unwind_depth
operator|>
literal|0
condition|)
block|{
operator|--
name|unwind_depth
expr_stmt|;
return|return
name|DC_QUIT
return|;
block|}
return|return
name|DC_OKAY
return|;
case|case
name|DC_INT
case|:
name|input_str_string
operator|=
name|s
operator|-
literal|1
expr_stmt|;
name|dc_push
argument_list|(
name|dc_getnum
argument_list|(
name|input_str
argument_list|,
name|dc_ibase
argument_list|,
operator|&
name|peekc
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|input_str_string
expr_stmt|;
if|if
condition|(
name|peekc
operator|!=
name|EOF
condition|)
operator|--
name|s
expr_stmt|;
break|break;
case|case
name|DC_STR
case|:
name|count
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|s
init|;
name|p
operator|<
name|end
operator|&&
name|count
operator|>
literal|0
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|']'
condition|)
operator|--
name|count
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'['
condition|)
operator|++
name|count
expr_stmt|;
name|len
operator|=
name|p
operator|-
name|s
expr_stmt|;
name|dc_push
argument_list|(
name|dc_makestring
argument_list|(
name|s
argument_list|,
name|len
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|p
expr_stmt|;
break|break;
case|case
name|DC_SYSTEM
case|:
name|s
operator|=
name|dc_system
argument_list|(
name|s
argument_list|)
expr_stmt|;
case|case
name|DC_COMMENT
case|:
name|s
operator|=
name|memchr
argument_list|(
name|s
argument_list|,
literal|'\n'
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|end
operator|-
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|s
operator|=
name|end
expr_stmt|;
else|else
operator|++
name|s
expr_stmt|;
break|break;
case|case
name|DC_NEGCMP
case|:
name|next_negcmp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DC_EOF_ERROR
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unexpected EOS\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
return|return
name|DC_OKAY
return|;
block|}
block|}
return|return
name|DC_OKAY
return|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* This is the main function of the whole DC program.  * Reads the file described by fp, calls dc_func to do  * the dirty work, and takes care of dc_func's shortcomings.  */
end_comment

begin_decl_stmt
name|int
name|dc_evalfile
name|DC_DECLARG
argument_list|(
operator|(
name|fp
operator|)
argument_list|)
name|FILE
modifier|*
name|fp
name|DC_DECLEND
block|{
name|int
name|c
decl_stmt|;
name|int
name|peekc
decl_stmt|;
name|int
name|negcmp
decl_stmt|;
name|int
name|next_negcmp
init|=
literal|0
decl_stmt|;
name|dc_data
name|datum
decl_stmt|;
name|stdin_lookahead
operator|=
name|EOF
expr_stmt|;
for|for
control|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
init|;
name|c
operator|!=
name|EOF
condition|;
name|c
operator|=
name|peekc
control|)
block|{
name|peekc
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* 		 * The following if() is the only place where ``stdin_lookahead'' 		 * might be set to other than EOF: 		 */
if|if
condition|(
name|fp
operator|==
name|stdin
condition|)
name|stdin_lookahead
operator|=
name|peekc
expr_stmt|;
name|negcmp
operator|=
name|next_negcmp
expr_stmt|;
name|next_negcmp
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|dc_func
argument_list|(
name|c
argument_list|,
name|peekc
argument_list|,
name|negcmp
argument_list|)
condition|)
block|{
case|case
name|DC_OKAY
case|:
if|if
condition|(
name|stdin_lookahead
operator|!=
name|peekc
operator|&&
name|fp
operator|==
name|stdin
condition|)
name|peekc
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DC_EATONE
case|:
name|peekc
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DC_QUIT
case|:
if|if
condition|(
name|unwind_noexit
operator|!=
name|DC_TRUE
condition|)
return|return
name|DC_FAIL
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Q command argument exceeded string execution depth\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdin_lookahead
operator|!=
name|peekc
operator|&&
name|fp
operator|==
name|stdin
condition|)
name|peekc
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DC_INT
case|:
name|input_fil_fp
operator|=
name|fp
expr_stmt|;
name|input_pushback
operator|=
name|c
expr_stmt|;
name|ungetc
argument_list|(
name|peekc
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|dc_push
argument_list|(
name|dc_getnum
argument_list|(
name|input_fil
argument_list|,
name|dc_ibase
argument_list|,
operator|&
name|peekc
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DC_STR
case|:
name|ungetc
argument_list|(
name|peekc
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|datum
operator|=
name|dc_readstring
argument_list|(
name|fp
argument_list|,
literal|'['
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
name|dc_push
argument_list|(
name|datum
argument_list|)
expr_stmt|;
name|peekc
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DC_SYSTEM
case|:
name|ungetc
argument_list|(
name|peekc
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|datum
operator|=
name|dc_readstring
argument_list|(
name|stdin
argument_list|,
literal|'\n'
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dc_system
argument_list|(
name|dc_str2charp
argument_list|(
name|datum
operator|.
name|v
operator|.
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|dc_free_str
argument_list|(
operator|&
name|datum
operator|.
name|v
operator|.
name|string
argument_list|)
expr_stmt|;
name|peekc
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DC_COMMENT
case|:
while|while
condition|(
name|peekc
operator|!=
name|EOF
operator|&&
name|peekc
operator|!=
literal|'\n'
condition|)
name|peekc
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|peekc
operator|!=
name|EOF
condition|)
name|peekc
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DC_NEGCMP
case|:
name|next_negcmp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DC_EOF_ERROR
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unexpected EOF\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
return|return
name|DC_FAIL
return|;
block|}
block|}
return|return
name|DC_SUCCESS
return|;
block|}
end_decl_stmt

end_unit

