begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * implement stack functions for dc  *  * Copyright (C) 1994, 1997, 1998 Free Software Foundation, Inc.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2, or (at your option)  * any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, you can either send email to this  * program's author (see below) or write to: The Free Software Foundation,  * Inc.; 675 Mass Ave. Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This module is the only one that knows what stacks (both the  * regular evaluation stack and the named register stacks)  * look like.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"dc.h"
end_include

begin_include
include|#
directive|include
file|"dc-proto.h"
end_include

begin_include
include|#
directive|include
file|"dc-regdef.h"
end_include

begin_comment
comment|/* an oft-used error message: */
end_comment

begin_define
define|#
directive|define
name|Empty_Stack
value|fprintf(stderr, "%s: stack empty\n", progname)
end_define

begin_comment
comment|/* simple linked-list implementaion suffices: */
end_comment

begin_struct
struct|struct
name|dc_list
block|{
name|dc_data
name|value
decl_stmt|;
name|struct
name|dc_array
modifier|*
name|array
decl_stmt|;
comment|/* opaque */
name|struct
name|dc_list
modifier|*
name|link
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|dc_list
name|dc_list
typedef|;
end_typedef

begin_comment
comment|/* the anonymous evaluation stack */
end_comment

begin_decl_stmt
specifier|static
name|dc_list
modifier|*
name|dc_stack
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the named register stacks */
end_comment

begin_decl_stmt
specifier|static
name|dc_list
modifier|*
name|dc_register
index|[
name|DC_REGCOUNT
index|]
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* allocate a new dc_list item */
end_comment

begin_function
specifier|static
name|dc_list
modifier|*
name|dc_alloc
name|DC_DECLVOID
parameter_list|()
block|{
name|dc_list
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|dc_malloc
argument_list|(
sizeof|sizeof
expr|*
name|result
argument_list|)
expr_stmt|;
name|result
operator|->
name|value
operator|.
name|dc_type
operator|=
name|DC_UNINITIALIZED
expr_stmt|;
name|result
operator|->
name|array
operator|=
name|NULL
expr_stmt|;
name|result
operator|->
name|link
operator|=
name|NULL
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* check that there are two numbers on top of the stack,  * then call op with the popped numbers.  Construct a dc_data  * value from the dc_num returned by op and push it  * on the stack.  * If the op call doesn't return DC_SUCCESS, then leave the stack  * unmodified.  */
end_comment

begin_decl_stmt
name|void
name|dc_binop
name|DC_DECLARG
argument_list|(
operator|(
name|op
operator|,
name|kscale
operator|)
argument_list|)
name|int
argument_list|(
operator|*
name|op
argument_list|)
name|DC_PROTO
argument_list|(
operator|(
name|dc_num
operator|,
name|dc_num
operator|,
name|int
operator|,
name|dc_num
operator|*
operator|)
argument_list|)
name|DC_DECLSEP
name|int
name|kscale
name|DC_DECLEND
block|{
name|dc_data
name|a
decl_stmt|;
name|dc_data
name|b
decl_stmt|;
name|dc_data
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|dc_stack
operator|||
operator|!
name|dc_stack
operator|->
name|link
condition|)
block|{
name|Empty_Stack
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dc_stack
operator|->
name|value
operator|.
name|dc_type
operator|!=
name|DC_NUMBER
operator|||
name|dc_stack
operator|->
name|link
operator|->
name|value
operator|.
name|dc_type
operator|!=
name|DC_NUMBER
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: non-numeric value\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|dc_pop
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dc_pop
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|op
call|)
argument_list|(
name|a
operator|.
name|v
operator|.
name|number
argument_list|,
name|b
operator|.
name|v
operator|.
name|number
argument_list|,
name|kscale
argument_list|,
operator|&
name|r
operator|.
name|v
operator|.
name|number
argument_list|)
operator|==
name|DC_SUCCESS
condition|)
block|{
name|r
operator|.
name|dc_type
operator|=
name|DC_NUMBER
expr_stmt|;
name|dc_push
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|dc_free_num
argument_list|(
operator|&
name|a
operator|.
name|v
operator|.
name|number
argument_list|)
expr_stmt|;
name|dc_free_num
argument_list|(
operator|&
name|b
operator|.
name|v
operator|.
name|number
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* op failed; restore the stack */
name|dc_push
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|dc_push
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/* check that there are two numbers on top of the stack,  * then call op with the popped numbers.  Construct two dc_data  * values from the dc_num's returned by op and push them  * on the stack.  * If the op call doesn't return DC_SUCCESS, then leave the stack  * unmodified.  */
end_comment

begin_decl_stmt
name|void
name|dc_binop2
name|DC_DECLARG
argument_list|(
operator|(
name|op
operator|,
name|kscale
operator|)
argument_list|)
name|int
argument_list|(
operator|*
name|op
argument_list|)
name|DC_PROTO
argument_list|(
operator|(
name|dc_num
operator|,
name|dc_num
operator|,
name|int
operator|,
name|dc_num
operator|*
operator|,
name|dc_num
operator|*
operator|)
argument_list|)
name|DC_DECLSEP
name|int
name|kscale
name|DC_DECLEND
block|{
name|dc_data
name|a
decl_stmt|;
name|dc_data
name|b
decl_stmt|;
name|dc_data
name|r1
decl_stmt|;
name|dc_data
name|r2
decl_stmt|;
if|if
condition|(
operator|!
name|dc_stack
operator|||
operator|!
name|dc_stack
operator|->
name|link
condition|)
block|{
name|Empty_Stack
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dc_stack
operator|->
name|value
operator|.
name|dc_type
operator|!=
name|DC_NUMBER
operator|||
name|dc_stack
operator|->
name|link
operator|->
name|value
operator|.
name|dc_type
operator|!=
name|DC_NUMBER
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: non-numeric value\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|dc_pop
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dc_pop
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|op
call|)
argument_list|(
name|a
operator|.
name|v
operator|.
name|number
argument_list|,
name|b
operator|.
name|v
operator|.
name|number
argument_list|,
name|kscale
argument_list|,
operator|&
name|r1
operator|.
name|v
operator|.
name|number
argument_list|,
operator|&
name|r2
operator|.
name|v
operator|.
name|number
argument_list|)
operator|==
name|DC_SUCCESS
condition|)
block|{
name|r1
operator|.
name|dc_type
operator|=
name|DC_NUMBER
expr_stmt|;
name|dc_push
argument_list|(
name|r1
argument_list|)
expr_stmt|;
name|r2
operator|.
name|dc_type
operator|=
name|DC_NUMBER
expr_stmt|;
name|dc_push
argument_list|(
name|r2
argument_list|)
expr_stmt|;
name|dc_free_num
argument_list|(
operator|&
name|a
operator|.
name|v
operator|.
name|number
argument_list|)
expr_stmt|;
name|dc_free_num
argument_list|(
operator|&
name|b
operator|.
name|v
operator|.
name|number
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* op failed; restore the stack */
name|dc_push
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|dc_push
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/* check that there are two numbers on top of the stack,  * then call dc_compare with the popped numbers.  * Return negative, zero, or positive based on the ordering  * of the two numbers.  */
end_comment

begin_function
name|int
name|dc_cmpop
name|DC_DECLVOID
parameter_list|()
block|{
name|int
name|result
decl_stmt|;
name|dc_data
name|a
decl_stmt|;
name|dc_data
name|b
decl_stmt|;
if|if
condition|(
operator|!
name|dc_stack
operator|||
operator|!
name|dc_stack
operator|->
name|link
condition|)
block|{
name|Empty_Stack
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|dc_stack
operator|->
name|value
operator|.
name|dc_type
operator|!=
name|DC_NUMBER
operator|||
name|dc_stack
operator|->
name|link
operator|->
name|value
operator|.
name|dc_type
operator|!=
name|DC_NUMBER
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: non-numeric value\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|(
name|void
operator|)
name|dc_pop
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dc_pop
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
name|result
operator|=
name|dc_compare
argument_list|(
name|b
operator|.
name|v
operator|.
name|number
argument_list|,
name|a
operator|.
name|v
operator|.
name|number
argument_list|)
expr_stmt|;
name|dc_free_num
argument_list|(
operator|&
name|a
operator|.
name|v
operator|.
name|number
argument_list|)
expr_stmt|;
name|dc_free_num
argument_list|(
operator|&
name|b
operator|.
name|v
operator|.
name|number
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* check that there are three numbers on top of the stack,  * then call op with the popped numbers.  Construct a dc_data  * value from the dc_num returned by op and push it  * on the stack.  * If the op call doesn't return DC_SUCCESS, then leave the stack  * unmodified.  */
end_comment

begin_decl_stmt
name|void
name|dc_triop
name|DC_DECLARG
argument_list|(
operator|(
name|op
operator|,
name|kscale
operator|)
argument_list|)
name|int
argument_list|(
operator|*
name|op
argument_list|)
name|DC_PROTO
argument_list|(
operator|(
name|dc_num
operator|,
name|dc_num
operator|,
name|dc_num
operator|,
name|int
operator|,
name|dc_num
operator|*
operator|)
argument_list|)
name|DC_DECLSEP
name|int
name|kscale
name|DC_DECLEND
block|{
name|dc_data
name|a
decl_stmt|;
name|dc_data
name|b
decl_stmt|;
name|dc_data
name|c
decl_stmt|;
name|dc_data
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|dc_stack
operator|||
operator|!
name|dc_stack
operator|->
name|link
operator|||
operator|!
name|dc_stack
operator|->
name|link
operator|->
name|link
condition|)
block|{
name|Empty_Stack
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dc_stack
operator|->
name|value
operator|.
name|dc_type
operator|!=
name|DC_NUMBER
operator|||
name|dc_stack
operator|->
name|link
operator|->
name|value
operator|.
name|dc_type
operator|!=
name|DC_NUMBER
operator|||
name|dc_stack
operator|->
name|link
operator|->
name|link
operator|->
name|value
operator|.
name|dc_type
operator|!=
name|DC_NUMBER
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: non-numeric value\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|dc_pop
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dc_pop
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dc_pop
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|op
call|)
argument_list|(
name|a
operator|.
name|v
operator|.
name|number
argument_list|,
name|b
operator|.
name|v
operator|.
name|number
argument_list|,
name|c
operator|.
name|v
operator|.
name|number
argument_list|,
name|kscale
argument_list|,
operator|&
name|r
operator|.
name|v
operator|.
name|number
argument_list|)
operator|==
name|DC_SUCCESS
condition|)
block|{
name|r
operator|.
name|dc_type
operator|=
name|DC_NUMBER
expr_stmt|;
name|dc_push
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|dc_free_num
argument_list|(
operator|&
name|a
operator|.
name|v
operator|.
name|number
argument_list|)
expr_stmt|;
name|dc_free_num
argument_list|(
operator|&
name|b
operator|.
name|v
operator|.
name|number
argument_list|)
expr_stmt|;
name|dc_free_num
argument_list|(
operator|&
name|c
operator|.
name|v
operator|.
name|number
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* op failed; restore the stack */
name|dc_push
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|dc_push
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|dc_push
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* initialize the register stacks to their initial values */
end_comment

begin_function
name|void
name|dc_register_init
name|DC_DECLVOID
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DC_REGCOUNT
condition|;
operator|++
name|i
control|)
name|dc_register
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* clear the evaluation stack */
end_comment

begin_function
name|void
name|dc_clear_stack
name|DC_DECLVOID
parameter_list|()
block|{
name|dc_list
modifier|*
name|n
decl_stmt|;
name|dc_list
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|n
operator|=
name|dc_stack
init|;
name|n
condition|;
name|n
operator|=
name|t
control|)
block|{
name|t
operator|=
name|n
operator|->
name|link
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|value
operator|.
name|dc_type
operator|==
name|DC_NUMBER
condition|)
name|dc_free_num
argument_list|(
operator|&
name|n
operator|->
name|value
operator|.
name|v
operator|.
name|number
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|->
name|value
operator|.
name|dc_type
operator|==
name|DC_STRING
condition|)
name|dc_free_str
argument_list|(
operator|&
name|n
operator|->
name|value
operator|.
name|v
operator|.
name|string
argument_list|)
expr_stmt|;
else|else
name|dc_garbage
argument_list|(
literal|"in stack"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dc_array_free
argument_list|(
name|n
operator|->
name|array
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
name|dc_stack
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* push a value onto the evaluation stack */
end_comment

begin_decl_stmt
name|void
name|dc_push
name|DC_DECLARG
argument_list|(
operator|(
name|value
operator|)
argument_list|)
name|dc_data
name|value
name|DC_DECLEND
block|{
name|dc_list
modifier|*
name|n
init|=
name|dc_alloc
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|.
name|dc_type
operator|!=
name|DC_NUMBER
operator|&&
name|value
operator|.
name|dc_type
operator|!=
name|DC_STRING
condition|)
name|dc_garbage
argument_list|(
literal|"in data being pushed"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|n
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|n
operator|->
name|link
operator|=
name|dc_stack
expr_stmt|;
name|dc_stack
operator|=
name|n
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* push a value onto the named register stack */
end_comment

begin_decl_stmt
name|void
name|dc_register_push
name|DC_DECLARG
argument_list|(
operator|(
name|stackid
operator|,
name|value
operator|)
argument_list|)
name|int
name|stackid
name|DC_DECLSEP
name|dc_data
name|value
name|DC_DECLEND
block|{
name|dc_list
modifier|*
name|n
init|=
name|dc_alloc
argument_list|()
decl_stmt|;
name|stackid
operator|=
name|regmap
argument_list|(
name|stackid
argument_list|)
expr_stmt|;
name|n
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|n
operator|->
name|link
operator|=
name|dc_register
index|[
name|stackid
index|]
expr_stmt|;
name|dc_register
index|[
name|stackid
index|]
operator|=
name|n
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* set *result to the value on the top of the evaluation stack */
end_comment

begin_comment
comment|/* The caller is responsible for duplicating the value if it  * is to be maintained as anything more than a transient identity.  *  * DC_FAIL is returned if the stack is empty (and *result unchanged),  * DC_SUCCESS is returned otherwise  */
end_comment

begin_decl_stmt
name|int
name|dc_top_of_stack
name|DC_DECLARG
argument_list|(
operator|(
name|result
operator|)
argument_list|)
name|dc_data
modifier|*
name|result
name|DC_DECLEND
block|{
if|if
condition|(
operator|!
name|dc_stack
condition|)
block|{
name|Empty_Stack
expr_stmt|;
return|return
name|DC_FAIL
return|;
block|}
if|if
condition|(
name|dc_stack
operator|->
name|value
operator|.
name|dc_type
operator|!=
name|DC_NUMBER
operator|&&
name|dc_stack
operator|->
name|value
operator|.
name|dc_type
operator|!=
name|DC_STRING
condition|)
name|dc_garbage
argument_list|(
literal|"at top of stack"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|dc_stack
operator|->
name|value
expr_stmt|;
return|return
name|DC_SUCCESS
return|;
block|}
end_decl_stmt

begin_comment
comment|/* set *result to a dup of the value on the top of the named register stack */
end_comment

begin_comment
comment|/*  * DC_FAIL is returned if the named stack is empty (and *result unchanged),  * DC_SUCCESS is returned otherwise  */
end_comment

begin_decl_stmt
name|int
name|dc_register_get
name|DC_DECLARG
argument_list|(
operator|(
name|regid
operator|,
name|result
operator|)
argument_list|)
name|int
name|regid
name|DC_DECLSEP
name|dc_data
modifier|*
name|result
name|DC_DECLEND
block|{
name|dc_list
modifier|*
name|r
decl_stmt|;
name|regid
operator|=
name|regmap
argument_list|(
name|regid
argument_list|)
expr_stmt|;
name|r
operator|=
name|dc_register
index|[
name|regid
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: register "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|dc_show_id
argument_list|(
name|stderr
argument_list|,
name|regid
argument_list|,
literal|" is empty\n"
argument_list|)
expr_stmt|;
return|return
name|DC_FAIL
return|;
block|}
operator|*
name|result
operator|=
name|dc_dup
argument_list|(
name|r
operator|->
name|value
argument_list|)
expr_stmt|;
return|return
name|DC_SUCCESS
return|;
block|}
end_decl_stmt

begin_comment
comment|/* set the top of the named register stack to the indicated value */
end_comment

begin_comment
comment|/* If the named stack is empty, craft a stack entry to enter the  * value into.  */
end_comment

begin_decl_stmt
name|void
name|dc_register_set
name|DC_DECLARG
argument_list|(
operator|(
name|regid
operator|,
name|value
operator|)
argument_list|)
name|int
name|regid
name|DC_DECLSEP
name|dc_data
name|value
name|DC_DECLEND
block|{
name|dc_list
modifier|*
name|r
decl_stmt|;
name|regid
operator|=
name|regmap
argument_list|(
name|regid
argument_list|)
expr_stmt|;
name|r
operator|=
name|dc_register
index|[
name|regid
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
name|dc_register
index|[
name|regid
index|]
operator|=
name|dc_alloc
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|value
operator|.
name|dc_type
operator|==
name|DC_NUMBER
condition|)
name|dc_free_num
argument_list|(
operator|&
name|r
operator|->
name|value
operator|.
name|v
operator|.
name|number
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|value
operator|.
name|dc_type
operator|==
name|DC_STRING
condition|)
name|dc_free_str
argument_list|(
operator|&
name|r
operator|->
name|value
operator|.
name|v
operator|.
name|string
argument_list|)
expr_stmt|;
else|else
name|dc_garbage
argument_list|(
literal|""
argument_list|,
name|regid
argument_list|)
expr_stmt|;
name|dc_register
index|[
name|regid
index|]
operator|->
name|value
operator|=
name|value
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* pop from the evaluation stack  *  * DC_FAIL is returned if the stack is empty (and *result unchanged),  * DC_SUCCESS is returned otherwise  */
end_comment

begin_decl_stmt
name|int
name|dc_pop
name|DC_DECLARG
argument_list|(
operator|(
name|result
operator|)
argument_list|)
name|dc_data
modifier|*
name|result
name|DC_DECLEND
block|{
name|dc_list
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|dc_stack
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|Empty_Stack
expr_stmt|;
return|return
name|DC_FAIL
return|;
block|}
if|if
condition|(
name|r
operator|->
name|value
operator|.
name|dc_type
operator|!=
name|DC_NUMBER
operator|&&
name|r
operator|->
name|value
operator|.
name|dc_type
operator|!=
name|DC_STRING
condition|)
name|dc_garbage
argument_list|(
literal|"at top of stack"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|r
operator|->
name|value
expr_stmt|;
name|dc_stack
operator|=
name|r
operator|->
name|link
expr_stmt|;
name|dc_array_free
argument_list|(
name|r
operator|->
name|array
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|DC_SUCCESS
return|;
block|}
end_decl_stmt

begin_comment
comment|/* pop from the named register stack  *  * DC_FAIL is returned if the named stack is empty (and *result unchanged),  * DC_SUCCESS is returned otherwise  */
end_comment

begin_decl_stmt
name|int
name|dc_register_pop
name|DC_DECLARG
argument_list|(
operator|(
name|stackid
operator|,
name|result
operator|)
argument_list|)
name|int
name|stackid
name|DC_DECLSEP
name|dc_data
modifier|*
name|result
name|DC_DECLEND
block|{
name|dc_list
modifier|*
name|r
decl_stmt|;
name|stackid
operator|=
name|regmap
argument_list|(
name|stackid
argument_list|)
expr_stmt|;
name|r
operator|=
name|dc_register
index|[
name|stackid
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: stack register "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|dc_show_id
argument_list|(
name|stderr
argument_list|,
name|stackid
argument_list|,
literal|" is empty\n"
argument_list|)
expr_stmt|;
return|return
name|DC_FAIL
return|;
block|}
if|if
condition|(
name|r
operator|->
name|value
operator|.
name|dc_type
operator|!=
name|DC_NUMBER
operator|&&
name|r
operator|->
name|value
operator|.
name|dc_type
operator|!=
name|DC_STRING
condition|)
name|dc_garbage
argument_list|(
literal|" stack"
argument_list|,
name|stackid
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|r
operator|->
name|value
expr_stmt|;
name|dc_register
index|[
name|stackid
index|]
operator|=
name|r
operator|->
name|link
expr_stmt|;
name|dc_array_free
argument_list|(
name|r
operator|->
name|array
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|DC_SUCCESS
return|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* tell how many entries are currently on the evaluation stack */
end_comment

begin_function
name|int
name|dc_tell_stackdepth
name|DC_DECLVOID
parameter_list|()
block|{
name|dc_list
modifier|*
name|n
decl_stmt|;
name|int
name|depth
init|=
literal|0
decl_stmt|;
for|for
control|(
name|n
operator|=
name|dc_stack
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|link
control|)
operator|++
name|depth
expr_stmt|;
return|return
name|depth
return|;
block|}
end_function

begin_comment
comment|/* return the length of the indicated data value;  * if discard_p is DC_TOSS, the deallocate the value when done  *  * The definition of a datum's length is deligated to the  * appropriate module.  */
end_comment

begin_decl_stmt
name|int
name|dc_tell_length
name|DC_DECLARG
argument_list|(
operator|(
name|value
operator|,
name|discard_p
operator|)
argument_list|)
name|dc_data
name|value
name|DC_DECLSEP
name|dc_discard
name|discard_p
name|DC_DECLEND
block|{
name|int
name|length
decl_stmt|;
if|if
condition|(
name|value
operator|.
name|dc_type
operator|==
name|DC_NUMBER
condition|)
block|{
name|length
operator|=
name|dc_numlen
argument_list|(
name|value
operator|.
name|v
operator|.
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|discard_p
operator|==
name|DC_TOSS
condition|)
name|dc_free_num
argument_list|(
operator|&
name|value
operator|.
name|v
operator|.
name|number
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|.
name|dc_type
operator|==
name|DC_STRING
condition|)
block|{
name|length
operator|=
name|dc_strlen
argument_list|(
name|value
operator|.
name|v
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|discard_p
operator|==
name|DC_TOSS
condition|)
name|dc_free_str
argument_list|(
operator|&
name|value
operator|.
name|v
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dc_garbage
argument_list|(
literal|"in tell_length"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
name|length
operator|=
literal|0
expr_stmt|;
comment|/*just to suppress spurious compiler warnings*/
block|}
return|return
name|length
return|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* print out all of the values on the evaluation stack */
end_comment

begin_decl_stmt
name|void
name|dc_printall
name|DC_DECLARG
argument_list|(
operator|(
name|obase
operator|)
argument_list|)
name|int
name|obase
name|DC_DECLEND
block|{
name|dc_list
modifier|*
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|dc_stack
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|link
control|)
name|dc_print
argument_list|(
name|n
operator|->
name|value
argument_list|,
name|obase
argument_list|,
name|DC_WITHNL
argument_list|,
name|DC_KEEP
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* get the current array head for the named array */
end_comment

begin_decl_stmt
name|struct
name|dc_array
modifier|*
name|dc_get_stacked_array
name|DC_DECLARG
argument_list|(
operator|(
name|array_id
operator|)
argument_list|)
name|int
name|array_id
name|DC_DECLEND
block|{
name|dc_list
modifier|*
name|r
init|=
name|dc_register
index|[
name|regmap
argument_list|(
name|array_id
argument_list|)
index|]
decl_stmt|;
return|return
name|r
condition|?
name|r
operator|->
name|array
else|:
name|NULL
return|;
block|}
end_decl_stmt

begin_comment
comment|/* set the current array head for the named array */
end_comment

begin_decl_stmt
name|void
name|dc_set_stacked_array
name|DC_DECLARG
argument_list|(
operator|(
name|array_id
operator|,
name|new_head
operator|)
argument_list|)
name|int
name|array_id
name|DC_DECLSEP
decl|struct
name|dc_array
modifier|*
name|new_head
name|DC_DECLEND
block|{
name|dc_list
modifier|*
name|r
decl_stmt|;
name|array_id
operator|=
name|regmap
argument_list|(
name|array_id
argument_list|)
expr_stmt|;
name|r
operator|=
name|dc_register
index|[
name|array_id
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
name|r
operator|=
name|dc_register
index|[
name|array_id
index|]
operator|=
name|dc_alloc
argument_list|()
expr_stmt|;
name|r
operator|->
name|array
operator|=
name|new_head
expr_stmt|;
block|}
end_decl_stmt

end_unit

