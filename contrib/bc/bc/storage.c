begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* storage.c:  Code and data storage manipulations.  This includes labels. */
end_comment

begin_comment
comment|/*  This file is part of GNU bc.     Copyright (C) 1991-1994, 1997, 2000 Free Software Foundation, Inc.      This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 2 of the License , or     (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License     along with this program; see the file COPYING.  If not, write to       The Free Software Foundation, Inc.       59 Temple Place, Suite 330       Boston, MA 02111 USA      You may contact the author by:        e-mail:  philnelson@acm.org       us-mail:  Philip A. Nelson                 Computer Science Department, 9062                 Western Washington University                 Bellingham, WA 98226-9062         *************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"bcdefs.h"
end_include

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|"proto.h"
end_include

begin_comment
comment|/* Initialize the storage at the beginning of the run. */
end_comment

begin_function
name|void
name|init_storage
parameter_list|()
block|{
comment|/* Functions: we start with none and ask for more. */
name|f_count
operator|=
literal|0
expr_stmt|;
name|more_functions
argument_list|()
expr_stmt|;
name|f_names
index|[
literal|0
index|]
operator|=
literal|"(main)"
expr_stmt|;
comment|/* Variables. */
name|v_count
operator|=
literal|0
expr_stmt|;
name|more_variables
argument_list|()
expr_stmt|;
comment|/* Arrays. */
name|a_count
operator|=
literal|0
expr_stmt|;
name|more_arrays
argument_list|()
expr_stmt|;
comment|/* Other things... */
name|ex_stack
operator|=
name|NULL
expr_stmt|;
name|fn_stack
operator|=
name|NULL
expr_stmt|;
name|i_base
operator|=
literal|10
expr_stmt|;
name|o_base
operator|=
literal|10
expr_stmt|;
name|scale
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|READLINE
argument_list|)
operator|||
name|defined
argument_list|(
name|LIBEDIT
argument_list|)
name|n_history
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|c_code
operator|=
name|FALSE
expr_stmt|;
name|bc_init_numbers
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Three functions for increasing the number of functions, variables, or    arrays that are needed.  This adds another 32 of the requested object. */
end_comment

begin_function
name|void
name|more_functions
parameter_list|(
name|VOID
parameter_list|)
block|{
name|int
name|old_count
decl_stmt|;
name|int
name|indx
decl_stmt|;
name|bc_function
modifier|*
name|old_f
decl_stmt|;
name|bc_function
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
modifier|*
name|old_names
decl_stmt|;
comment|/* Save old information. */
name|old_count
operator|=
name|f_count
expr_stmt|;
name|old_f
operator|=
name|functions
expr_stmt|;
name|old_names
operator|=
name|f_names
expr_stmt|;
comment|/* Add a fixed amount and allocate new space. */
name|f_count
operator|+=
name|STORE_INCR
expr_stmt|;
name|functions
operator|=
operator|(
name|bc_function
operator|*
operator|)
name|bc_malloc
argument_list|(
name|f_count
operator|*
sizeof|sizeof
argument_list|(
name|bc_function
argument_list|)
argument_list|)
expr_stmt|;
name|f_names
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|bc_malloc
argument_list|(
name|f_count
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy old ones. */
for|for
control|(
name|indx
operator|=
literal|0
init|;
name|indx
operator|<
name|old_count
condition|;
name|indx
operator|++
control|)
block|{
name|functions
index|[
name|indx
index|]
operator|=
name|old_f
index|[
name|indx
index|]
expr_stmt|;
name|f_names
index|[
name|indx
index|]
operator|=
name|old_names
index|[
name|indx
index|]
expr_stmt|;
block|}
comment|/* Initialize the new ones. */
for|for
control|(
init|;
name|indx
operator|<
name|f_count
condition|;
name|indx
operator|++
control|)
block|{
name|f
operator|=
operator|&
name|functions
index|[
name|indx
index|]
expr_stmt|;
name|f
operator|->
name|f_defined
operator|=
name|FALSE
expr_stmt|;
name|f
operator|->
name|f_body
operator|=
operator|(
name|char
operator|*
operator|)
name|bc_malloc
argument_list|(
name|BC_START_SIZE
argument_list|)
expr_stmt|;
name|f
operator|->
name|f_body_size
operator|=
name|BC_START_SIZE
expr_stmt|;
name|f
operator|->
name|f_code_size
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|f_label
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|f_autos
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|f_params
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Free the old elements. */
if|if
condition|(
name|old_count
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|old_f
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|old_names
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|more_variables
parameter_list|()
block|{
name|int
name|indx
decl_stmt|;
name|int
name|old_count
decl_stmt|;
name|bc_var
modifier|*
modifier|*
name|old_var
decl_stmt|;
name|char
modifier|*
modifier|*
name|old_names
decl_stmt|;
comment|/* Save the old values. */
name|old_count
operator|=
name|v_count
expr_stmt|;
name|old_var
operator|=
name|variables
expr_stmt|;
name|old_names
operator|=
name|v_names
expr_stmt|;
comment|/* Increment by a fixed amount and allocate. */
name|v_count
operator|+=
name|STORE_INCR
expr_stmt|;
name|variables
operator|=
operator|(
name|bc_var
operator|*
operator|*
operator|)
name|bc_malloc
argument_list|(
name|v_count
operator|*
sizeof|sizeof
argument_list|(
name|bc_var
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|v_names
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|bc_malloc
argument_list|(
name|v_count
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy the old variables. */
for|for
control|(
name|indx
operator|=
literal|3
init|;
name|indx
operator|<
name|old_count
condition|;
name|indx
operator|++
control|)
name|variables
index|[
name|indx
index|]
operator|=
name|old_var
index|[
name|indx
index|]
expr_stmt|;
comment|/* Initialize the new elements. */
for|for
control|(
init|;
name|indx
operator|<
name|v_count
condition|;
name|indx
operator|++
control|)
name|variables
index|[
name|indx
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Free the old elements. */
if|if
condition|(
name|old_count
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|old_var
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|old_names
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|more_arrays
parameter_list|()
block|{
name|int
name|indx
decl_stmt|;
name|int
name|old_count
decl_stmt|;
name|bc_var_array
modifier|*
modifier|*
name|old_ary
decl_stmt|;
name|char
modifier|*
modifier|*
name|old_names
decl_stmt|;
comment|/* Save the old values. */
name|old_count
operator|=
name|a_count
expr_stmt|;
name|old_ary
operator|=
name|arrays
expr_stmt|;
name|old_names
operator|=
name|a_names
expr_stmt|;
comment|/* Increment by a fixed amount and allocate. */
name|a_count
operator|+=
name|STORE_INCR
expr_stmt|;
name|arrays
operator|=
operator|(
name|bc_var_array
operator|*
operator|*
operator|)
name|bc_malloc
argument_list|(
name|a_count
operator|*
sizeof|sizeof
argument_list|(
name|bc_var_array
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|a_names
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|bc_malloc
argument_list|(
name|a_count
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy the old arrays. */
for|for
control|(
name|indx
operator|=
literal|1
init|;
name|indx
operator|<
name|old_count
condition|;
name|indx
operator|++
control|)
name|arrays
index|[
name|indx
index|]
operator|=
name|old_ary
index|[
name|indx
index|]
expr_stmt|;
comment|/* Initialize the new elements. */
for|for
control|(
init|;
name|indx
operator|<
name|v_count
condition|;
name|indx
operator|++
control|)
name|arrays
index|[
name|indx
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Free the old elements. */
if|if
condition|(
name|old_count
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|old_ary
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|old_names
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* clear_func clears out function FUNC and makes it ready to redefine. */
end_comment

begin_function
name|void
name|clear_func
parameter_list|(
name|func
parameter_list|)
name|int
name|func
decl_stmt|;
block|{
name|bc_function
modifier|*
name|f
decl_stmt|;
name|bc_label_group
modifier|*
name|lg
decl_stmt|;
comment|/* Set the pointer to the function. */
name|f
operator|=
operator|&
name|functions
index|[
name|func
index|]
expr_stmt|;
name|f
operator|->
name|f_defined
operator|=
name|FALSE
expr_stmt|;
comment|/* XXX restore f_body to initial size??? */
name|f
operator|->
name|f_code_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|f_autos
operator|!=
name|NULL
condition|)
block|{
name|free_args
argument_list|(
name|f
operator|->
name|f_autos
argument_list|)
expr_stmt|;
name|f
operator|->
name|f_autos
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|->
name|f_params
operator|!=
name|NULL
condition|)
block|{
name|free_args
argument_list|(
name|f
operator|->
name|f_params
argument_list|)
expr_stmt|;
name|f
operator|->
name|f_params
operator|=
name|NULL
expr_stmt|;
block|}
while|while
condition|(
name|f
operator|->
name|f_label
operator|!=
name|NULL
condition|)
block|{
name|lg
operator|=
name|f
operator|->
name|f_label
operator|->
name|l_next
expr_stmt|;
name|free
argument_list|(
name|f
operator|->
name|f_label
argument_list|)
expr_stmt|;
name|f
operator|->
name|f_label
operator|=
name|lg
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  Pop the function execution stack and return the top. */
end_comment

begin_function
name|int
name|fpop
parameter_list|()
block|{
name|fstack_rec
modifier|*
name|temp
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|fn_stack
operator|!=
name|NULL
condition|)
block|{
name|temp
operator|=
name|fn_stack
expr_stmt|;
name|fn_stack
operator|=
name|temp
operator|->
name|s_next
expr_stmt|;
name|retval
operator|=
name|temp
operator|->
name|s_val
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
literal|0
expr_stmt|;
name|rt_error
argument_list|(
literal|"function stack underflow, contact maintainer."
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Push VAL on to the function stack. */
end_comment

begin_function
name|void
name|fpush
parameter_list|(
name|val
parameter_list|)
name|int
name|val
decl_stmt|;
block|{
name|fstack_rec
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
name|fstack_rec
operator|*
operator|)
name|bc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fstack_rec
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|s_next
operator|=
name|fn_stack
expr_stmt|;
name|temp
operator|->
name|s_val
operator|=
name|val
expr_stmt|;
name|fn_stack
operator|=
name|temp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop and discard the top element of the regular execution stack. */
end_comment

begin_function
name|void
name|pop
parameter_list|()
block|{
name|estack_rec
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|ex_stack
operator|!=
name|NULL
condition|)
block|{
name|temp
operator|=
name|ex_stack
expr_stmt|;
name|ex_stack
operator|=
name|temp
operator|->
name|s_next
expr_stmt|;
name|bc_free_num
argument_list|(
operator|&
name|temp
operator|->
name|s_num
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Push a copy of NUM on to the regular execution stack. */
end_comment

begin_function
name|void
name|push_copy
parameter_list|(
name|num
parameter_list|)
name|bc_num
name|num
decl_stmt|;
block|{
name|estack_rec
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
name|estack_rec
operator|*
operator|)
name|bc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|estack_rec
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|s_num
operator|=
name|bc_copy_num
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|temp
operator|->
name|s_next
operator|=
name|ex_stack
expr_stmt|;
name|ex_stack
operator|=
name|temp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push NUM on to the regular execution stack.  Do NOT push a copy. */
end_comment

begin_function
name|void
name|push_num
parameter_list|(
name|num
parameter_list|)
name|bc_num
name|num
decl_stmt|;
block|{
name|estack_rec
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
name|estack_rec
operator|*
operator|)
name|bc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|estack_rec
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|s_num
operator|=
name|num
expr_stmt|;
name|temp
operator|->
name|s_next
operator|=
name|ex_stack
expr_stmt|;
name|ex_stack
operator|=
name|temp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make sure the ex_stack has at least DEPTH elements on it.    Return TRUE if it has at least DEPTH elements, otherwise    return FALSE. */
end_comment

begin_function
name|char
name|check_stack
parameter_list|(
name|depth
parameter_list|)
name|int
name|depth
decl_stmt|;
block|{
name|estack_rec
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
name|ex_stack
expr_stmt|;
while|while
condition|(
operator|(
name|temp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|depth
operator|>
literal|0
operator|)
condition|)
block|{
name|temp
operator|=
name|temp
operator|->
name|s_next
expr_stmt|;
name|depth
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
block|{
name|rt_error
argument_list|(
literal|"Stack error."
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* The following routines manipulate simple variables and    array variables. */
end_comment

begin_comment
comment|/* get_var returns a pointer to the variable VAR_NAME.  If one does not    exist, one is created. */
end_comment

begin_function
name|bc_var
modifier|*
name|get_var
parameter_list|(
name|var_name
parameter_list|)
name|int
name|var_name
decl_stmt|;
block|{
name|bc_var
modifier|*
name|var_ptr
decl_stmt|;
name|var_ptr
operator|=
name|variables
index|[
name|var_name
index|]
expr_stmt|;
if|if
condition|(
name|var_ptr
operator|==
name|NULL
condition|)
block|{
name|var_ptr
operator|=
name|variables
index|[
name|var_name
index|]
operator|=
operator|(
name|bc_var
operator|*
operator|)
name|bc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bc_var
argument_list|)
argument_list|)
expr_stmt|;
name|bc_init_num
argument_list|(
operator|&
name|var_ptr
operator|->
name|v_value
argument_list|)
expr_stmt|;
block|}
return|return
name|var_ptr
return|;
block|}
end_function

begin_comment
comment|/* get_array_num returns the address of the bc_num in the array    structure.  If more structure is requried to get to the index,    this routine does the work to create that structure. VAR_INDEX    is a zero based index into the arrays storage array. INDEX is    the index into the bc array. */
end_comment

begin_function
name|bc_num
modifier|*
name|get_array_num
parameter_list|(
name|var_index
parameter_list|,
name|index
parameter_list|)
name|int
name|var_index
decl_stmt|;
name|long
name|index
decl_stmt|;
block|{
name|bc_var_array
modifier|*
name|ary_ptr
decl_stmt|;
name|bc_array
modifier|*
name|a_var
decl_stmt|;
name|bc_array_node
modifier|*
name|temp
decl_stmt|;
name|int
name|log
decl_stmt|,
name|ix
decl_stmt|,
name|ix1
decl_stmt|;
name|int
name|sub
index|[
name|NODE_DEPTH
index|]
decl_stmt|;
comment|/* Get the array entry. */
name|ary_ptr
operator|=
name|arrays
index|[
name|var_index
index|]
expr_stmt|;
if|if
condition|(
name|ary_ptr
operator|==
name|NULL
condition|)
block|{
name|ary_ptr
operator|=
name|arrays
index|[
name|var_index
index|]
operator|=
operator|(
name|bc_var_array
operator|*
operator|)
name|bc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bc_var_array
argument_list|)
argument_list|)
expr_stmt|;
name|ary_ptr
operator|->
name|a_value
operator|=
name|NULL
expr_stmt|;
name|ary_ptr
operator|->
name|a_next
operator|=
name|NULL
expr_stmt|;
name|ary_ptr
operator|->
name|a_param
operator|=
name|FALSE
expr_stmt|;
block|}
name|a_var
operator|=
name|ary_ptr
operator|->
name|a_value
expr_stmt|;
if|if
condition|(
name|a_var
operator|==
name|NULL
condition|)
block|{
name|a_var
operator|=
name|ary_ptr
operator|->
name|a_value
operator|=
operator|(
name|bc_array
operator|*
operator|)
name|bc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bc_array
argument_list|)
argument_list|)
expr_stmt|;
name|a_var
operator|->
name|a_tree
operator|=
name|NULL
expr_stmt|;
name|a_var
operator|->
name|a_depth
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Get the index variable. */
name|sub
index|[
literal|0
index|]
operator|=
name|index
operator|&
name|NODE_MASK
expr_stmt|;
name|ix
operator|=
name|index
operator|>>
name|NODE_SHIFT
expr_stmt|;
name|log
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|ix
operator|>
literal|0
operator|||
name|log
operator|<
name|a_var
operator|->
name|a_depth
condition|)
block|{
name|sub
index|[
name|log
index|]
operator|=
name|ix
operator|&
name|NODE_MASK
expr_stmt|;
name|ix
operator|>>=
name|NODE_SHIFT
expr_stmt|;
name|log
operator|++
expr_stmt|;
block|}
comment|/* Build any tree that is necessary. */
while|while
condition|(
name|log
operator|>
name|a_var
operator|->
name|a_depth
condition|)
block|{
name|temp
operator|=
operator|(
name|bc_array_node
operator|*
operator|)
name|bc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bc_array_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|a_var
operator|->
name|a_depth
operator|!=
literal|0
condition|)
block|{
name|temp
operator|->
name|n_items
operator|.
name|n_down
index|[
literal|0
index|]
operator|=
name|a_var
operator|->
name|a_tree
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|1
init|;
name|ix
operator|<
name|NODE_SIZE
condition|;
name|ix
operator|++
control|)
name|temp
operator|->
name|n_items
operator|.
name|n_down
index|[
name|ix
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|NODE_SIZE
condition|;
name|ix
operator|++
control|)
name|temp
operator|->
name|n_items
operator|.
name|n_num
index|[
name|ix
index|]
operator|=
name|bc_copy_num
argument_list|(
name|_zero_
argument_list|)
expr_stmt|;
block|}
name|a_var
operator|->
name|a_tree
operator|=
name|temp
expr_stmt|;
name|a_var
operator|->
name|a_depth
operator|++
expr_stmt|;
block|}
comment|/* Find the indexed variable. */
name|temp
operator|=
name|a_var
operator|->
name|a_tree
expr_stmt|;
while|while
condition|(
name|log
operator|--
operator|>
literal|1
condition|)
block|{
name|ix1
operator|=
name|sub
index|[
name|log
index|]
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|n_items
operator|.
name|n_down
index|[
name|ix1
index|]
operator|==
name|NULL
condition|)
block|{
name|temp
operator|->
name|n_items
operator|.
name|n_down
index|[
name|ix1
index|]
operator|=
operator|(
name|bc_array_node
operator|*
operator|)
name|bc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bc_array_node
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|temp
operator|->
name|n_items
operator|.
name|n_down
index|[
name|ix1
index|]
expr_stmt|;
if|if
condition|(
name|log
operator|>
literal|1
condition|)
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|NODE_SIZE
condition|;
name|ix
operator|++
control|)
name|temp
operator|->
name|n_items
operator|.
name|n_down
index|[
name|ix
index|]
operator|=
name|NULL
expr_stmt|;
else|else
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|NODE_SIZE
condition|;
name|ix
operator|++
control|)
name|temp
operator|->
name|n_items
operator|.
name|n_num
index|[
name|ix
index|]
operator|=
name|bc_copy_num
argument_list|(
name|_zero_
argument_list|)
expr_stmt|;
block|}
else|else
name|temp
operator|=
name|temp
operator|->
name|n_items
operator|.
name|n_down
index|[
name|ix1
index|]
expr_stmt|;
block|}
comment|/* Return the address of the indexed variable. */
return|return
operator|&
operator|(
name|temp
operator|->
name|n_items
operator|.
name|n_num
index|[
name|sub
index|[
literal|0
index|]
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Store the top of the execution stack into VAR_NAME.      This includes the special variables ibase, obase, and scale. */
end_comment

begin_function
name|void
name|store_var
parameter_list|(
name|var_name
parameter_list|)
name|int
name|var_name
decl_stmt|;
block|{
name|bc_var
modifier|*
name|var_ptr
decl_stmt|;
name|long
name|temp
decl_stmt|;
name|char
name|toobig
decl_stmt|;
if|if
condition|(
name|var_name
operator|>
literal|3
condition|)
block|{
comment|/* It is a simple variable. */
name|var_ptr
operator|=
name|get_var
argument_list|(
name|var_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|var_ptr
operator|!=
name|NULL
condition|)
block|{
name|bc_free_num
argument_list|(
operator|&
name|var_ptr
operator|->
name|v_value
argument_list|)
expr_stmt|;
name|var_ptr
operator|->
name|v_value
operator|=
name|bc_copy_num
argument_list|(
name|ex_stack
operator|->
name|s_num
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* It is a special variable... */
name|toobig
operator|=
name|FALSE
expr_stmt|;
name|temp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bc_is_neg
argument_list|(
name|ex_stack
operator|->
name|s_num
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|var_name
condition|)
block|{
case|case
literal|0
case|:
name|rt_warn
argument_list|(
literal|"negative ibase, set to 2"
argument_list|)
expr_stmt|;
name|temp
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|rt_warn
argument_list|(
literal|"negative obase, set to 2"
argument_list|)
expr_stmt|;
name|temp
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|rt_warn
argument_list|(
literal|"negative scale, set to 0"
argument_list|)
expr_stmt|;
name|temp
operator|=
literal|0
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|READLINE
argument_list|)
operator|||
name|defined
argument_list|(
name|LIBEDIT
argument_list|)
case|case
literal|3
case|:
name|temp
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
else|else
block|{
name|temp
operator|=
name|bc_num2long
argument_list|(
name|ex_stack
operator|->
name|s_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bc_is_zero
argument_list|(
name|ex_stack
operator|->
name|s_num
argument_list|)
operator|&&
name|temp
operator|==
literal|0
condition|)
name|toobig
operator|=
name|TRUE
expr_stmt|;
block|}
switch|switch
condition|(
name|var_name
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|temp
operator|<
literal|2
operator|&&
operator|!
name|toobig
condition|)
block|{
name|i_base
operator|=
literal|2
expr_stmt|;
name|rt_warn
argument_list|(
literal|"ibase too small, set to 2"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|temp
operator|>
literal|16
operator|||
name|toobig
condition|)
block|{
name|i_base
operator|=
literal|16
expr_stmt|;
name|rt_warn
argument_list|(
literal|"ibase too large, set to 16"
argument_list|)
expr_stmt|;
block|}
else|else
name|i_base
operator|=
operator|(
name|int
operator|)
name|temp
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|temp
operator|<
literal|2
operator|&&
operator|!
name|toobig
condition|)
block|{
name|o_base
operator|=
literal|2
expr_stmt|;
name|rt_warn
argument_list|(
literal|"obase too small, set to 2"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|temp
operator|>
name|BC_BASE_MAX
operator|||
name|toobig
condition|)
block|{
name|o_base
operator|=
name|BC_BASE_MAX
expr_stmt|;
name|rt_warn
argument_list|(
literal|"obase too large, set to %d"
argument_list|,
name|BC_BASE_MAX
argument_list|)
expr_stmt|;
block|}
else|else
name|o_base
operator|=
operator|(
name|int
operator|)
name|temp
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/*  WARNING:  The following if statement may generate a compiler 	      warning if INT_MAX == LONG_MAX.  This is NOT a problem. */
if|if
condition|(
name|temp
operator|>
name|BC_SCALE_MAX
operator|||
name|toobig
condition|)
block|{
name|scale
operator|=
name|BC_SCALE_MAX
expr_stmt|;
name|rt_warn
argument_list|(
literal|"scale too large, set to %d"
argument_list|,
name|BC_SCALE_MAX
argument_list|)
expr_stmt|;
block|}
else|else
name|scale
operator|=
operator|(
name|int
operator|)
name|temp
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|READLINE
argument_list|)
operator|||
name|defined
argument_list|(
name|LIBEDIT
argument_list|)
case|case
literal|3
case|:
if|if
condition|(
name|toobig
condition|)
block|{
name|temp
operator|=
operator|-
literal|1
expr_stmt|;
name|rt_warn
argument_list|(
literal|"history too large, set to unlimited"
argument_list|)
expr_stmt|;
name|UNLIMIT_HISTORY
expr_stmt|;
block|}
else|else
block|{
name|n_history
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
name|UNLIMIT_HISTORY
expr_stmt|;
else|else
name|HISTORY_SIZE
argument_list|(
name|n_history
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_comment
comment|/* Store the top of the execution stack into array VAR_NAME.     VAR_NAME is the name of an array, and the next to the top    of stack for the index into the array. */
end_comment

begin_function
name|void
name|store_array
parameter_list|(
name|var_name
parameter_list|)
name|int
name|var_name
decl_stmt|;
block|{
name|bc_num
modifier|*
name|num_ptr
decl_stmt|;
name|long
name|index
decl_stmt|;
if|if
condition|(
operator|!
name|check_stack
argument_list|(
literal|2
argument_list|)
condition|)
return|return;
name|index
operator|=
name|bc_num2long
argument_list|(
name|ex_stack
operator|->
name|s_next
operator|->
name|s_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>
name|BC_DIM_MAX
operator|||
operator|(
name|index
operator|==
literal|0
operator|&&
operator|!
name|bc_is_zero
argument_list|(
name|ex_stack
operator|->
name|s_next
operator|->
name|s_num
argument_list|)
operator|)
condition|)
name|rt_error
argument_list|(
literal|"Array %s subscript out of bounds."
argument_list|,
name|a_names
index|[
name|var_name
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|num_ptr
operator|=
name|get_array_num
argument_list|(
name|var_name
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_ptr
operator|!=
name|NULL
condition|)
block|{
name|bc_free_num
argument_list|(
name|num_ptr
argument_list|)
expr_stmt|;
operator|*
name|num_ptr
operator|=
name|bc_copy_num
argument_list|(
name|ex_stack
operator|->
name|s_num
argument_list|)
expr_stmt|;
name|bc_free_num
argument_list|(
operator|&
name|ex_stack
operator|->
name|s_next
operator|->
name|s_num
argument_list|)
expr_stmt|;
name|ex_stack
operator|->
name|s_next
operator|->
name|s_num
operator|=
name|ex_stack
operator|->
name|s_num
expr_stmt|;
name|bc_init_num
argument_list|(
operator|&
name|ex_stack
operator|->
name|s_num
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  Load a copy of VAR_NAME on to the execution stack.  This includes     the special variables ibase, obase and scale.  */
end_comment

begin_function
name|void
name|load_var
parameter_list|(
name|var_name
parameter_list|)
name|int
name|var_name
decl_stmt|;
block|{
name|bc_var
modifier|*
name|var_ptr
decl_stmt|;
switch|switch
condition|(
name|var_name
condition|)
block|{
case|case
literal|0
case|:
comment|/* Special variable ibase. */
name|push_copy
argument_list|(
name|_zero_
argument_list|)
expr_stmt|;
name|bc_int2num
argument_list|(
operator|&
name|ex_stack
operator|->
name|s_num
argument_list|,
name|i_base
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Special variable obase. */
name|push_copy
argument_list|(
name|_zero_
argument_list|)
expr_stmt|;
name|bc_int2num
argument_list|(
operator|&
name|ex_stack
operator|->
name|s_num
argument_list|,
name|o_base
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Special variable scale. */
name|push_copy
argument_list|(
name|_zero_
argument_list|)
expr_stmt|;
name|bc_int2num
argument_list|(
operator|&
name|ex_stack
operator|->
name|s_num
argument_list|,
name|scale
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|READLINE
argument_list|)
operator|||
name|defined
argument_list|(
name|LIBEDIT
argument_list|)
case|case
literal|3
case|:
comment|/* Special variable history. */
name|push_copy
argument_list|(
name|_zero_
argument_list|)
expr_stmt|;
name|bc_int2num
argument_list|(
operator|&
name|ex_stack
operator|->
name|s_num
argument_list|,
name|n_history
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* It is a simple variable. */
name|var_ptr
operator|=
name|variables
index|[
name|var_name
index|]
expr_stmt|;
if|if
condition|(
name|var_ptr
operator|!=
name|NULL
condition|)
name|push_copy
argument_list|(
name|var_ptr
operator|->
name|v_value
argument_list|)
expr_stmt|;
else|else
name|push_copy
argument_list|(
name|_zero_
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  Load a copy of VAR_NAME on to the execution stack.  This includes     the special variables ibase, obase and scale.  */
end_comment

begin_function
name|void
name|load_array
parameter_list|(
name|var_name
parameter_list|)
name|int
name|var_name
decl_stmt|;
block|{
name|bc_num
modifier|*
name|num_ptr
decl_stmt|;
name|long
name|index
decl_stmt|;
if|if
condition|(
operator|!
name|check_stack
argument_list|(
literal|1
argument_list|)
condition|)
return|return;
name|index
operator|=
name|bc_num2long
argument_list|(
name|ex_stack
operator|->
name|s_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>
name|BC_DIM_MAX
operator|||
operator|(
name|index
operator|==
literal|0
operator|&&
operator|!
name|bc_is_zero
argument_list|(
name|ex_stack
operator|->
name|s_num
argument_list|)
operator|)
condition|)
name|rt_error
argument_list|(
literal|"Array %s subscript out of bounds."
argument_list|,
name|a_names
index|[
name|var_name
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|num_ptr
operator|=
name|get_array_num
argument_list|(
name|var_name
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_ptr
operator|!=
name|NULL
condition|)
block|{
name|pop
argument_list|()
expr_stmt|;
name|push_copy
argument_list|(
operator|*
name|num_ptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Decrement VAR_NAME by one.  This includes the special variables    ibase, obase, and scale. */
end_comment

begin_function
name|void
name|decr_var
parameter_list|(
name|var_name
parameter_list|)
name|int
name|var_name
decl_stmt|;
block|{
name|bc_var
modifier|*
name|var_ptr
decl_stmt|;
switch|switch
condition|(
name|var_name
condition|)
block|{
case|case
literal|0
case|:
comment|/* ibase */
if|if
condition|(
name|i_base
operator|>
literal|2
condition|)
name|i_base
operator|--
expr_stmt|;
else|else
name|rt_warn
argument_list|(
literal|"ibase too small in --"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* obase */
if|if
condition|(
name|o_base
operator|>
literal|2
condition|)
name|o_base
operator|--
expr_stmt|;
else|else
name|rt_warn
argument_list|(
literal|"obase too small in --"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* scale */
if|if
condition|(
name|scale
operator|>
literal|0
condition|)
name|scale
operator|--
expr_stmt|;
else|else
name|rt_warn
argument_list|(
literal|"scale can not be negative in -- "
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|READLINE
argument_list|)
operator|||
name|defined
argument_list|(
name|LIBEDIT
argument_list|)
case|case
literal|3
case|:
comment|/* history */
name|n_history
operator|--
expr_stmt|;
if|if
condition|(
name|n_history
operator|>=
literal|0
condition|)
name|HISTORY_SIZE
argument_list|(
name|n_history
argument_list|)
expr_stmt|;
else|else
block|{
name|n_history
operator|=
operator|-
literal|1
expr_stmt|;
name|rt_warn
argument_list|(
literal|"history is negative, set to unlimited"
argument_list|)
expr_stmt|;
name|UNLIMIT_HISTORY
expr_stmt|;
block|}
endif|#
directive|endif
default|default:
comment|/* It is a simple variable. */
name|var_ptr
operator|=
name|get_var
argument_list|(
name|var_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|var_ptr
operator|!=
name|NULL
condition|)
name|bc_sub
argument_list|(
name|var_ptr
operator|->
name|v_value
argument_list|,
name|_one_
argument_list|,
operator|&
name|var_ptr
operator|->
name|v_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Decrement VAR_NAME by one.  VAR_NAME is an array, and the top of    the execution stack is the index and it is popped off the stack. */
end_comment

begin_function
name|void
name|decr_array
parameter_list|(
name|var_name
parameter_list|)
name|int
name|var_name
decl_stmt|;
block|{
name|bc_num
modifier|*
name|num_ptr
decl_stmt|;
name|long
name|index
decl_stmt|;
comment|/* It is an array variable. */
if|if
condition|(
operator|!
name|check_stack
argument_list|(
literal|1
argument_list|)
condition|)
return|return;
name|index
operator|=
name|bc_num2long
argument_list|(
name|ex_stack
operator|->
name|s_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>
name|BC_DIM_MAX
operator|||
operator|(
name|index
operator|==
literal|0
operator|&&
operator|!
name|bc_is_zero
argument_list|(
name|ex_stack
operator|->
name|s_num
argument_list|)
operator|)
condition|)
name|rt_error
argument_list|(
literal|"Array %s subscript out of bounds."
argument_list|,
name|a_names
index|[
name|var_name
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|num_ptr
operator|=
name|get_array_num
argument_list|(
name|var_name
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_ptr
operator|!=
name|NULL
condition|)
block|{
name|pop
argument_list|()
expr_stmt|;
name|bc_sub
argument_list|(
operator|*
name|num_ptr
argument_list|,
name|_one_
argument_list|,
name|num_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Increment VAR_NAME by one.  This includes the special variables    ibase, obase, and scale. */
end_comment

begin_function
name|void
name|incr_var
parameter_list|(
name|var_name
parameter_list|)
name|int
name|var_name
decl_stmt|;
block|{
name|bc_var
modifier|*
name|var_ptr
decl_stmt|;
switch|switch
condition|(
name|var_name
condition|)
block|{
case|case
literal|0
case|:
comment|/* ibase */
if|if
condition|(
name|i_base
operator|<
literal|16
condition|)
name|i_base
operator|++
expr_stmt|;
else|else
name|rt_warn
argument_list|(
literal|"ibase too big in ++"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* obase */
if|if
condition|(
name|o_base
operator|<
name|BC_BASE_MAX
condition|)
name|o_base
operator|++
expr_stmt|;
else|else
name|rt_warn
argument_list|(
literal|"obase too big in ++"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|scale
operator|<
name|BC_SCALE_MAX
condition|)
name|scale
operator|++
expr_stmt|;
else|else
name|rt_warn
argument_list|(
literal|"Scale too big in ++"
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|READLINE
argument_list|)
operator|||
name|defined
argument_list|(
name|LIBEDIT
argument_list|)
case|case
literal|3
case|:
comment|/* history */
name|n_history
operator|++
expr_stmt|;
if|if
condition|(
name|n_history
operator|>
literal|0
condition|)
name|HISTORY_SIZE
argument_list|(
name|n_history
argument_list|)
expr_stmt|;
else|else
block|{
name|n_history
operator|=
operator|-
literal|1
expr_stmt|;
name|rt_warn
argument_list|(
literal|"history set to unlimited"
argument_list|)
expr_stmt|;
name|UNLIMIT_HISTORY
expr_stmt|;
block|}
endif|#
directive|endif
default|default:
comment|/* It is a simple variable. */
name|var_ptr
operator|=
name|get_var
argument_list|(
name|var_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|var_ptr
operator|!=
name|NULL
condition|)
name|bc_add
argument_list|(
name|var_ptr
operator|->
name|v_value
argument_list|,
name|_one_
argument_list|,
operator|&
name|var_ptr
operator|->
name|v_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Increment VAR_NAME by one.  VAR_NAME is an array and top of    execution stack is the index and is popped off the stack. */
end_comment

begin_function
name|void
name|incr_array
parameter_list|(
name|var_name
parameter_list|)
name|int
name|var_name
decl_stmt|;
block|{
name|bc_num
modifier|*
name|num_ptr
decl_stmt|;
name|long
name|index
decl_stmt|;
if|if
condition|(
operator|!
name|check_stack
argument_list|(
literal|1
argument_list|)
condition|)
return|return;
name|index
operator|=
name|bc_num2long
argument_list|(
name|ex_stack
operator|->
name|s_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>
name|BC_DIM_MAX
operator|||
operator|(
name|index
operator|==
literal|0
operator|&&
operator|!
name|bc_is_zero
argument_list|(
name|ex_stack
operator|->
name|s_num
argument_list|)
operator|)
condition|)
name|rt_error
argument_list|(
literal|"Array %s subscript out of bounds."
argument_list|,
name|a_names
index|[
name|var_name
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|num_ptr
operator|=
name|get_array_num
argument_list|(
name|var_name
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_ptr
operator|!=
name|NULL
condition|)
block|{
name|pop
argument_list|()
expr_stmt|;
name|bc_add
argument_list|(
operator|*
name|num_ptr
argument_list|,
name|_one_
argument_list|,
name|num_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Routines for processing autos variables and parameters. */
end_comment

begin_comment
comment|/* NAME is an auto variable that needs to be pushed on its stack. */
end_comment

begin_function
name|void
name|auto_var
parameter_list|(
name|name
parameter_list|)
name|int
name|name
decl_stmt|;
block|{
name|bc_var
modifier|*
name|v_temp
decl_stmt|;
name|bc_var_array
modifier|*
name|a_temp
decl_stmt|;
name|int
name|ix
decl_stmt|;
if|if
condition|(
name|name
operator|>
literal|0
condition|)
block|{
comment|/* A simple variable. */
name|ix
operator|=
name|name
expr_stmt|;
name|v_temp
operator|=
operator|(
name|bc_var
operator|*
operator|)
name|bc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bc_var
argument_list|)
argument_list|)
expr_stmt|;
name|v_temp
operator|->
name|v_next
operator|=
name|variables
index|[
name|ix
index|]
expr_stmt|;
name|bc_init_num
argument_list|(
operator|&
name|v_temp
operator|->
name|v_value
argument_list|)
expr_stmt|;
name|variables
index|[
name|ix
index|]
operator|=
name|v_temp
expr_stmt|;
block|}
else|else
block|{
comment|/* An array variable. */
name|ix
operator|=
operator|-
name|name
expr_stmt|;
name|a_temp
operator|=
operator|(
name|bc_var_array
operator|*
operator|)
name|bc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bc_var_array
argument_list|)
argument_list|)
expr_stmt|;
name|a_temp
operator|->
name|a_next
operator|=
name|arrays
index|[
name|ix
index|]
expr_stmt|;
name|a_temp
operator|->
name|a_value
operator|=
name|NULL
expr_stmt|;
name|a_temp
operator|->
name|a_param
operator|=
name|FALSE
expr_stmt|;
name|arrays
index|[
name|ix
index|]
operator|=
name|a_temp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Free_a_tree frees everything associated with an array variable tree.    This is used when popping an array variable off its auto stack.  */
end_comment

begin_function
name|void
name|free_a_tree
parameter_list|(
name|root
parameter_list|,
name|depth
parameter_list|)
name|bc_array_node
modifier|*
name|root
decl_stmt|;
name|int
name|depth
decl_stmt|;
block|{
name|int
name|ix
decl_stmt|;
if|if
condition|(
name|root
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|depth
operator|>
literal|1
condition|)
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|NODE_SIZE
condition|;
name|ix
operator|++
control|)
name|free_a_tree
argument_list|(
name|root
operator|->
name|n_items
operator|.
name|n_down
index|[
name|ix
index|]
argument_list|,
name|depth
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|NODE_SIZE
condition|;
name|ix
operator|++
control|)
name|bc_free_num
argument_list|(
operator|&
operator|(
name|root
operator|->
name|n_items
operator|.
name|n_num
index|[
name|ix
index|]
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* LIST is an NULL terminated list of varible names that need to be    popped off their auto stacks. */
end_comment

begin_function
name|void
name|pop_vars
parameter_list|(
name|list
parameter_list|)
name|arg_list
modifier|*
name|list
decl_stmt|;
block|{
name|bc_var
modifier|*
name|v_temp
decl_stmt|;
name|bc_var_array
modifier|*
name|a_temp
decl_stmt|;
name|int
name|ix
decl_stmt|;
while|while
condition|(
name|list
operator|!=
name|NULL
condition|)
block|{
name|ix
operator|=
name|list
operator|->
name|av_name
expr_stmt|;
if|if
condition|(
name|ix
operator|>
literal|0
condition|)
block|{
comment|/* A simple variable. */
name|v_temp
operator|=
name|variables
index|[
name|ix
index|]
expr_stmt|;
if|if
condition|(
name|v_temp
operator|!=
name|NULL
condition|)
block|{
name|variables
index|[
name|ix
index|]
operator|=
name|v_temp
operator|->
name|v_next
expr_stmt|;
name|bc_free_num
argument_list|(
operator|&
name|v_temp
operator|->
name|v_value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v_temp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* An array variable. */
name|ix
operator|=
operator|-
name|ix
expr_stmt|;
name|a_temp
operator|=
name|arrays
index|[
name|ix
index|]
expr_stmt|;
if|if
condition|(
name|a_temp
operator|!=
name|NULL
condition|)
block|{
name|arrays
index|[
name|ix
index|]
operator|=
name|a_temp
operator|->
name|a_next
expr_stmt|;
if|if
condition|(
operator|!
name|a_temp
operator|->
name|a_param
operator|&&
name|a_temp
operator|->
name|a_value
operator|!=
name|NULL
condition|)
block|{
name|free_a_tree
argument_list|(
name|a_temp
operator|->
name|a_value
operator|->
name|a_tree
argument_list|,
name|a_temp
operator|->
name|a_value
operator|->
name|a_depth
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|a_temp
operator|->
name|a_value
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|a_temp
argument_list|)
expr_stmt|;
block|}
block|}
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* COPY_NODE: Copies an array node for a call by value parameter. */
end_comment

begin_function
name|bc_array_node
modifier|*
name|copy_tree
parameter_list|(
name|ary_node
parameter_list|,
name|depth
parameter_list|)
name|bc_array_node
modifier|*
name|ary_node
decl_stmt|;
name|int
name|depth
decl_stmt|;
block|{
name|bc_array_node
modifier|*
name|res
init|=
operator|(
name|bc_array_node
operator|*
operator|)
name|bc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bc_array_node
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|depth
operator|>
literal|1
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NODE_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ary_node
operator|->
name|n_items
operator|.
name|n_down
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|res
operator|->
name|n_items
operator|.
name|n_down
index|[
name|i
index|]
operator|=
name|copy_tree
argument_list|(
name|ary_node
operator|->
name|n_items
operator|.
name|n_down
index|[
name|i
index|]
argument_list|,
name|depth
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|res
operator|->
name|n_items
operator|.
name|n_down
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NODE_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ary_node
operator|->
name|n_items
operator|.
name|n_num
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|res
operator|->
name|n_items
operator|.
name|n_num
index|[
name|i
index|]
operator|=
name|bc_copy_num
argument_list|(
name|ary_node
operator|->
name|n_items
operator|.
name|n_num
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|res
operator|->
name|n_items
operator|.
name|n_num
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* COPY_ARRAY: Copies an array for a call by value array parameter.     ARY is the pointer to the bc_array structure. */
end_comment

begin_function
name|bc_array
modifier|*
name|copy_array
parameter_list|(
name|ary
parameter_list|)
name|bc_array
modifier|*
name|ary
decl_stmt|;
block|{
name|bc_array
modifier|*
name|res
init|=
operator|(
name|bc_array
operator|*
operator|)
name|bc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bc_array
argument_list|)
argument_list|)
decl_stmt|;
name|res
operator|->
name|a_depth
operator|=
name|ary
operator|->
name|a_depth
expr_stmt|;
name|res
operator|->
name|a_tree
operator|=
name|copy_tree
argument_list|(
name|ary
operator|->
name|a_tree
argument_list|,
name|ary
operator|->
name|a_depth
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A call is being made to FUNC.  The call types are at PC.  Process    the parameters by doing an auto on the parameter variable and then    store the value at the new variable or put a pointer the the array    variable. */
end_comment

begin_function
name|void
name|process_params
parameter_list|(
name|pc
parameter_list|,
name|func
parameter_list|)
name|program_counter
modifier|*
name|pc
decl_stmt|;
name|int
name|func
decl_stmt|;
block|{
name|char
name|ch
decl_stmt|;
name|arg_list
modifier|*
name|params
decl_stmt|;
name|int
name|ix
decl_stmt|,
name|ix1
decl_stmt|;
name|bc_var
modifier|*
name|v_temp
decl_stmt|;
name|bc_var_array
modifier|*
name|a_src
decl_stmt|,
modifier|*
name|a_dest
decl_stmt|;
name|bc_num
modifier|*
name|n_temp
decl_stmt|;
comment|/* Get the parameter names from the function. */
name|params
operator|=
name|functions
index|[
name|func
index|]
operator|.
name|f_params
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|byte
argument_list|(
name|pc
argument_list|)
operator|)
operator|!=
literal|':'
condition|)
block|{
if|if
condition|(
name|params
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|==
literal|'0'
operator|)
operator|&&
name|params
operator|->
name|av_name
operator|>
literal|0
condition|)
block|{
comment|/* A simple variable. */
name|ix
operator|=
name|params
operator|->
name|av_name
expr_stmt|;
name|v_temp
operator|=
operator|(
name|bc_var
operator|*
operator|)
name|bc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bc_var
argument_list|)
argument_list|)
expr_stmt|;
name|v_temp
operator|->
name|v_next
operator|=
name|variables
index|[
name|ix
index|]
expr_stmt|;
name|v_temp
operator|->
name|v_value
operator|=
name|ex_stack
operator|->
name|s_num
expr_stmt|;
name|bc_init_num
argument_list|(
operator|&
name|ex_stack
operator|->
name|s_num
argument_list|)
expr_stmt|;
name|variables
index|[
name|ix
index|]
operator|=
name|v_temp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|==
literal|'1'
operator|)
operator|&&
operator|(
name|params
operator|->
name|av_name
operator|<
literal|0
operator|)
condition|)
block|{
comment|/* The variables is an array variable. */
comment|/* Compute source index and make sure some structure exists. */
name|ix
operator|=
operator|(
name|int
operator|)
name|bc_num2long
argument_list|(
name|ex_stack
operator|->
name|s_num
argument_list|)
expr_stmt|;
name|n_temp
operator|=
name|get_array_num
argument_list|(
name|ix
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Push a new array and Compute Destination index */
name|auto_var
argument_list|(
name|params
operator|->
name|av_name
argument_list|)
expr_stmt|;
name|ix1
operator|=
operator|-
name|params
operator|->
name|av_name
expr_stmt|;
comment|/* Set up the correct pointers in the structure. */
if|if
condition|(
name|ix
operator|==
name|ix1
condition|)
name|a_src
operator|=
name|arrays
index|[
name|ix
index|]
operator|->
name|a_next
expr_stmt|;
else|else
name|a_src
operator|=
name|arrays
index|[
name|ix
index|]
expr_stmt|;
name|a_dest
operator|=
name|arrays
index|[
name|ix1
index|]
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|arg_is_var
condition|)
block|{
name|a_dest
operator|->
name|a_param
operator|=
name|TRUE
expr_stmt|;
name|a_dest
operator|->
name|a_value
operator|=
name|a_src
operator|->
name|a_value
expr_stmt|;
block|}
else|else
block|{
name|a_dest
operator|->
name|a_param
operator|=
name|FALSE
expr_stmt|;
name|a_dest
operator|->
name|a_value
operator|=
name|copy_array
argument_list|(
name|a_src
operator|->
name|a_value
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|params
operator|->
name|av_name
operator|<
literal|0
condition|)
name|rt_error
argument_list|(
literal|"Parameter type mismatch parameter %s."
argument_list|,
name|a_names
index|[
operator|-
name|params
operator|->
name|av_name
index|]
argument_list|)
expr_stmt|;
else|else
name|rt_error
argument_list|(
literal|"Parameter type mismatch, parameter %s."
argument_list|,
name|v_names
index|[
name|params
operator|->
name|av_name
index|]
argument_list|)
expr_stmt|;
name|params
operator|++
expr_stmt|;
block|}
name|pop
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|rt_error
argument_list|(
literal|"Parameter number mismatch"
argument_list|)
expr_stmt|;
return|return;
block|}
name|params
operator|=
name|params
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|params
operator|!=
name|NULL
condition|)
name|rt_error
argument_list|(
literal|"Parameter number mismatch"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

