begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* load.c:  This code "loads" code into the code segments. */
end_comment

begin_comment
comment|/*  This file is part of GNU bc.     Copyright (C) 1991-1994, 1997, 2000 Free Software Foundation, Inc.      This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 2 of the License , or     (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License     along with this program; see the file COPYING.  If not, write to       The Free Software Foundation, Inc.       59 Temple Place, Suite 330       Boston, MA 02111 USA      You may contact the author by:        e-mail:  philnelson@acm.org       us-mail:  Philip A. Nelson                 Computer Science Department, 9062                 Western Washington University                 Bellingham, WA 98226-9062         *************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"bcdefs.h"
end_include

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|"proto.h"
end_include

begin_comment
comment|/* Load variables. */
end_comment

begin_decl_stmt
name|program_counter
name|load_adr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|load_str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|load_const
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the load sequence. */
end_comment

begin_function
name|void
name|init_load
parameter_list|()
block|{
name|clear_func
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|load_adr
operator|.
name|pc_func
operator|=
literal|0
expr_stmt|;
name|load_adr
operator|.
name|pc_addr
operator|=
literal|0
expr_stmt|;
name|load_str
operator|=
name|FALSE
expr_stmt|;
name|load_const
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* addbyte adds one BYTE to the current code segment. */
end_comment

begin_function
name|void
name|addbyte
parameter_list|(
name|byte
parameter_list|)
name|char
name|byte
decl_stmt|;
block|{
name|int
name|pc
decl_stmt|;
name|bc_function
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|new_body
decl_stmt|;
comment|/* If there was an error, don't continue. */
if|if
condition|(
name|had_error
condition|)
return|return;
comment|/* Calculate the segment and offset. */
name|pc
operator|=
name|load_adr
operator|.
name|pc_addr
operator|++
expr_stmt|;
name|f
operator|=
operator|&
name|functions
index|[
name|load_adr
operator|.
name|pc_func
index|]
expr_stmt|;
if|if
condition|(
name|pc
operator|>=
name|f
operator|->
name|f_body_size
condition|)
block|{
name|f
operator|->
name|f_body_size
operator|*=
literal|2
expr_stmt|;
name|new_body
operator|=
operator|(
name|char
operator|*
operator|)
name|bc_malloc
argument_list|(
name|f
operator|->
name|f_body_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_body
argument_list|,
name|f
operator|->
name|f_body
argument_list|,
name|f
operator|->
name|f_body_size
operator|/
literal|2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|f
operator|->
name|f_body
argument_list|)
expr_stmt|;
name|f
operator|->
name|f_body
operator|=
name|new_body
expr_stmt|;
block|}
comment|/* Store the byte. */
name|f
operator|->
name|f_body
index|[
name|pc
index|]
operator|=
name|byte
expr_stmt|;
name|f
operator|->
name|f_code_size
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define a label LAB to be the current program counter. */
end_comment

begin_function
name|void
name|def_label
parameter_list|(
name|lab
parameter_list|)
name|long
name|lab
decl_stmt|;
block|{
name|bc_label_group
modifier|*
name|temp
decl_stmt|;
name|int
name|group
decl_stmt|,
name|offset
decl_stmt|,
name|func
decl_stmt|;
comment|/* Get things ready. */
name|group
operator|=
name|lab
operator|>>
name|BC_LABEL_LOG
expr_stmt|;
name|offset
operator|=
name|lab
operator|%
name|BC_LABEL_GROUP
expr_stmt|;
name|func
operator|=
name|load_adr
operator|.
name|pc_func
expr_stmt|;
comment|/* Make sure there is at least one label group. */
if|if
condition|(
name|functions
index|[
name|func
index|]
operator|.
name|f_label
operator|==
name|NULL
condition|)
block|{
name|functions
index|[
name|func
index|]
operator|.
name|f_label
operator|=
operator|(
name|bc_label_group
operator|*
operator|)
name|bc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bc_label_group
argument_list|)
argument_list|)
expr_stmt|;
name|functions
index|[
name|func
index|]
operator|.
name|f_label
operator|->
name|l_next
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Add the label group. */
name|temp
operator|=
name|functions
index|[
name|func
index|]
operator|.
name|f_label
expr_stmt|;
while|while
condition|(
name|group
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|temp
operator|->
name|l_next
operator|==
name|NULL
condition|)
block|{
name|temp
operator|->
name|l_next
operator|=
operator|(
name|bc_label_group
operator|*
operator|)
name|bc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bc_label_group
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|l_next
operator|->
name|l_next
operator|=
name|NULL
expr_stmt|;
block|}
name|temp
operator|=
name|temp
operator|->
name|l_next
expr_stmt|;
name|group
operator|--
expr_stmt|;
block|}
comment|/* Define it! */
name|temp
operator|->
name|l_adrs
index|[
name|offset
index|]
operator|=
name|load_adr
operator|.
name|pc_addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Several instructions have integers in the code.  They    are all known to be legal longs.  So, no error code    is added.  STR is the pointer to the load string and    must be moved to the last non-digit character. */
end_comment

begin_function
name|long
name|long_val
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|val
init|=
literal|0
decl_stmt|;
name|char
name|neg
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|str
operator|==
literal|'-'
condition|)
block|{
name|neg
operator|=
name|TRUE
expr_stmt|;
operator|(
operator|*
name|str
operator|)
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|isdigit
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|*
operator|*
name|str
argument_list|)
argument_list|)
condition|)
name|val
operator|=
name|val
operator|*
literal|10
operator|+
operator|*
operator|(
operator|*
name|str
operator|)
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|neg
condition|)
return|return
operator|-
name|val
return|;
else|else
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* load_code loads the CODE into the machine. */
end_comment

begin_function
name|void
name|load_code
parameter_list|(
name|code
parameter_list|)
name|char
modifier|*
name|code
decl_stmt|;
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|long
name|ap_name
decl_stmt|;
comment|/* auto or parameter name. */
name|long
name|label_no
decl_stmt|;
name|long
name|vaf_name
decl_stmt|;
comment|/* variable, array or function number. */
name|long
name|func
decl_stmt|;
name|program_counter
name|save_adr
decl_stmt|;
comment|/* Initialize. */
name|str
operator|=
name|code
expr_stmt|;
comment|/* Scan the code. */
while|while
condition|(
operator|*
name|str
operator|!=
literal|0
condition|)
block|{
comment|/* If there was an error, don't continue. */
if|if
condition|(
name|had_error
condition|)
return|return;
if|if
condition|(
name|load_str
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
literal|'"'
condition|)
name|load_str
operator|=
name|FALSE
expr_stmt|;
name|addbyte
argument_list|(
operator|*
name|str
operator|++
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|load_const
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
literal|'\n'
condition|)
name|str
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|str
operator|==
literal|':'
condition|)
block|{
name|load_const
operator|=
name|FALSE
expr_stmt|;
name|addbyte
argument_list|(
operator|*
name|str
operator|++
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
literal|'.'
condition|)
name|addbyte
argument_list|(
operator|*
name|str
operator|++
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|str
operator|>=
literal|'A'
condition|)
name|addbyte
argument_list|(
operator|*
name|str
operator|++
operator|+
literal|10
operator|-
literal|'A'
argument_list|)
expr_stmt|;
else|else
name|addbyte
argument_list|(
operator|*
name|str
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
operator|*
name|str
condition|)
block|{
case|case
literal|'"'
case|:
comment|/* Starts a string. */
name|load_str
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/* A label */
name|str
operator|++
expr_stmt|;
name|label_no
operator|=
name|long_val
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
name|def_label
argument_list|(
name|label_no
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* Branch to label. */
case|case
literal|'J'
case|:
comment|/* Jump to label. */
case|case
literal|'Z'
case|:
comment|/* Branch Zero to label. */
name|addbyte
argument_list|(
operator|*
name|str
operator|++
argument_list|)
expr_stmt|;
name|label_no
operator|=
name|long_val
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|label_no
operator|>
literal|65535L
condition|)
block|{
comment|/* Better message? */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Program too big.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|addbyte
argument_list|(
call|(
name|char
call|)
argument_list|(
name|label_no
operator|&
literal|0xFF
argument_list|)
argument_list|)
expr_stmt|;
name|addbyte
argument_list|(
call|(
name|char
call|)
argument_list|(
name|label_no
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* A function, get the name and initialize it. */
name|str
operator|++
expr_stmt|;
name|func
operator|=
name|long_val
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
name|clear_func
argument_list|(
name|func
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|2
name|printf
argument_list|(
literal|"Loading function number %d\n"
argument_list|,
name|func
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* get the parameters */
while|while
condition|(
operator|*
name|str
operator|++
operator|!=
literal|'.'
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
literal|'.'
condition|)
block|{
name|str
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|str
operator|==
literal|'*'
condition|)
block|{
name|str
operator|++
expr_stmt|;
name|ap_name
operator|=
name|long_val
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|2
name|printf
argument_list|(
literal|"var parameter number %d\n"
argument_list|,
name|ap_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|functions
index|[
operator|(
name|int
operator|)
name|func
index|]
operator|.
name|f_params
operator|=
name|nextarg
argument_list|(
name|functions
index|[
operator|(
name|int
operator|)
name|func
index|]
operator|.
name|f_params
argument_list|,
name|ap_name
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ap_name
operator|=
name|long_val
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|2
name|printf
argument_list|(
literal|"parameter number %d\n"
argument_list|,
name|ap_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|functions
index|[
operator|(
name|int
operator|)
name|func
index|]
operator|.
name|f_params
operator|=
name|nextarg
argument_list|(
name|functions
index|[
operator|(
name|int
operator|)
name|func
index|]
operator|.
name|f_params
argument_list|,
name|ap_name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* get the auto vars */
while|while
condition|(
operator|*
name|str
operator|!=
literal|'['
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
literal|','
condition|)
name|str
operator|++
expr_stmt|;
name|ap_name
operator|=
name|long_val
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|2
name|printf
argument_list|(
literal|"auto number %d\n"
argument_list|,
name|ap_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|functions
index|[
operator|(
name|int
operator|)
name|func
index|]
operator|.
name|f_autos
operator|=
name|nextarg
argument_list|(
name|functions
index|[
operator|(
name|int
operator|)
name|func
index|]
operator|.
name|f_autos
argument_list|,
name|ap_name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|save_adr
operator|=
name|load_adr
expr_stmt|;
name|load_adr
operator|.
name|pc_func
operator|=
name|func
expr_stmt|;
name|load_adr
operator|.
name|pc_addr
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|']'
case|:
comment|/* A function end */
name|functions
index|[
name|load_adr
operator|.
name|pc_func
index|]
operator|.
name|f_defined
operator|=
name|TRUE
expr_stmt|;
name|load_adr
operator|=
name|save_adr
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* Call a function. */
name|addbyte
argument_list|(
operator|*
name|str
operator|++
argument_list|)
expr_stmt|;
name|func
operator|=
name|long_val
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|<
literal|128
condition|)
name|addbyte
argument_list|(
operator|(
name|char
operator|)
name|func
argument_list|)
expr_stmt|;
else|else
block|{
name|addbyte
argument_list|(
operator|(
operator|(
name|func
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
operator||
literal|0x80
argument_list|)
expr_stmt|;
name|addbyte
argument_list|(
name|func
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|str
operator|==
literal|','
condition|)
name|str
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|str
operator|!=
literal|':'
condition|)
name|addbyte
argument_list|(
operator|*
name|str
operator|++
argument_list|)
expr_stmt|;
name|addbyte
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* Call a special function. */
name|addbyte
argument_list|(
operator|*
name|str
operator|++
argument_list|)
expr_stmt|;
name|addbyte
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
comment|/* A constant.... may have an "F" in it. */
name|addbyte
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
name|load_const
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* Decrement. */
case|case
literal|'i'
case|:
comment|/* Increment. */
case|case
literal|'l'
case|:
comment|/* Load. */
case|case
literal|'s'
case|:
comment|/* Store. */
case|case
literal|'A'
case|:
comment|/* Array Increment */
case|case
literal|'M'
case|:
comment|/* Array Decrement */
case|case
literal|'L'
case|:
comment|/* Array Load */
case|case
literal|'S'
case|:
comment|/* Array Store */
name|addbyte
argument_list|(
operator|*
name|str
operator|++
argument_list|)
expr_stmt|;
name|vaf_name
operator|=
name|long_val
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|vaf_name
operator|<
literal|128
condition|)
name|addbyte
argument_list|(
name|vaf_name
argument_list|)
expr_stmt|;
else|else
block|{
name|addbyte
argument_list|(
operator|(
operator|(
name|vaf_name
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
operator||
literal|0x80
argument_list|)
expr_stmt|;
name|addbyte
argument_list|(
name|vaf_name
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'@'
case|:
comment|/* A command! */
switch|switch
condition|(
operator|*
operator|(
operator|++
name|str
operator|)
condition|)
block|{
case|case
literal|'i'
case|:
name|init_load
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|execute
argument_list|()
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'\n'
case|:
comment|/* Ignore the newlines */
break|break;
default|default:
comment|/* Anything else */
name|addbyte
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
block|}
name|str
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

