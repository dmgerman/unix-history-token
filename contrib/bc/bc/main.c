begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* main.c: The main program for bc.  */
end_comment

begin_comment
comment|/*  This file is part of GNU bc.     Copyright (C) 1991, 1992, 1993, 1994, 1997 Free Software Foundation, Inc.      This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 2 of the License , or     (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License     along with this program; see the file COPYING.  If not, write to     the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.      You may contact the author by:        e-mail:  phil@cs.wwu.edu       us-mail:  Philip A. Nelson                 Computer Science Department, 9062                 Western Washington University                 Bellingham, WA 98226-9062         *************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"bcdefs.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|"proto.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_comment
comment|/* Variables for processing multiple files. */
end_comment

begin_decl_stmt
name|char
name|first_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|yyin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Points to the last node in the file name list for easy adding. */
end_comment

begin_decl_stmt
specifier|static
name|file_node
modifier|*
name|last
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|READLINE
end_ifdef

begin_comment
comment|/* Readline support. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|rl_readline_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|rl_instream
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* long option support */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"compile"
block|,
literal|0
block|,
operator|&
name|compile_only
block|,
name|TRUE
block|}
block|,
block|{
literal|"mathlib"
block|,
literal|0
block|,
operator|&
name|use_math
block|,
name|TRUE
block|}
block|,
block|{
literal|"quiet"
block|,
literal|0
block|,
operator|&
name|quiet
block|,
name|TRUE
block|}
block|,
block|{
literal|"standard"
block|,
literal|0
block|,
operator|&
name|std_only
block|,
name|TRUE
block|}
block|,
block|{
literal|"version"
block|,
literal|0
block|,
literal|0
block|,
literal|'v'
block|}
block|,
block|{
literal|"warn"
block|,
literal|0
block|,
operator|&
name|warn_not_std
block|,
name|TRUE
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|parse_args
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|optch
decl_stmt|;
name|int
name|long_index
decl_stmt|;
name|file_node
modifier|*
name|temp
decl_stmt|;
comment|/* Force getopt to initialize.  Depends on GNU getopt. */
name|optind
operator|=
literal|0
expr_stmt|;
comment|/* Parse the command line */
while|while
condition|(
literal|1
condition|)
block|{
name|optch
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"lciqsvw"
argument_list|,
name|long_options
argument_list|,
operator|&
name|long_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|optch
operator|==
name|EOF
condition|)
comment|/* End of arguments. */
break|break;
switch|switch
condition|(
name|optch
condition|)
block|{
case|case
literal|'c'
case|:
comment|/* compile only */
name|compile_only
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* math lib */
name|use_math
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* force interactive */
name|interactive
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* quiet mode */
name|quiet
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Non standard features give errors. */
name|std_only
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* Print the version. */
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|BC_VERSION
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* Non standard features give warnings. */
name|warn_not_std
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
comment|/* Add file names to a list of files to process. */
while|while
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|temp
operator|=
operator|(
name|file_node
operator|*
operator|)
name|bc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|file_node
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|name
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last
operator|==
name|NULL
condition|)
name|file_names
operator|=
name|temp
expr_stmt|;
else|else
name|last
operator|->
name|next
operator|=
name|temp
expr_stmt|;
name|last
operator|=
name|temp
expr_stmt|;
name|optind
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The main program for bc. */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|env_value
decl_stmt|;
name|char
modifier|*
name|env_argv
index|[
literal|30
index|]
decl_stmt|;
name|int
name|env_argc
decl_stmt|;
specifier|extern
name|FILE
modifier|*
name|rl_outstream
decl_stmt|;
comment|/* Initialize many variables. */
name|compile_only
operator|=
name|FALSE
expr_stmt|;
name|use_math
operator|=
name|FALSE
expr_stmt|;
name|warn_not_std
operator|=
name|FALSE
expr_stmt|;
name|std_only
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|isatty
argument_list|(
literal|0
argument_list|)
operator|&&
name|isatty
argument_list|(
literal|1
argument_list|)
condition|)
name|interactive
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|interactive
operator|=
name|FALSE
expr_stmt|;
name|rl_outstream
operator|=
name|stderr
expr_stmt|;
block|}
name|quiet
operator|=
name|FALSE
expr_stmt|;
name|file_names
operator|=
name|NULL
expr_stmt|;
comment|/* Environment arguments. */
name|env_value
operator|=
name|getenv
argument_list|(
literal|"BC_ENV_ARGS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env_value
operator|!=
name|NULL
condition|)
block|{
name|env_argc
operator|=
literal|1
expr_stmt|;
name|env_argv
index|[
literal|0
index|]
operator|=
literal|"BC_ENV_ARGS"
expr_stmt|;
while|while
condition|(
operator|*
name|env_value
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|env_value
operator|!=
literal|' '
condition|)
block|{
name|env_argv
index|[
name|env_argc
operator|++
index|]
operator|=
name|env_value
expr_stmt|;
while|while
condition|(
operator|*
name|env_value
operator|!=
literal|' '
operator|&&
operator|*
name|env_value
operator|!=
literal|0
condition|)
name|env_value
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|env_value
operator|!=
literal|0
condition|)
block|{
operator|*
name|env_value
operator|=
literal|0
expr_stmt|;
name|env_value
operator|++
expr_stmt|;
block|}
block|}
else|else
name|env_value
operator|++
expr_stmt|;
block|}
name|parse_args
argument_list|(
name|env_argc
argument_list|,
name|env_argv
argument_list|)
expr_stmt|;
block|}
comment|/* Command line arguments. */
name|parse_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* Other environment processing. */
if|if
condition|(
name|getenv
argument_list|(
literal|"POSIXLY_CORRECT"
argument_list|)
operator|!=
name|NULL
condition|)
name|std_only
operator|=
name|TRUE
expr_stmt|;
name|env_value
operator|=
name|getenv
argument_list|(
literal|"BC_LINE_LENGTH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env_value
operator|!=
name|NULL
condition|)
block|{
name|line_size
operator|=
name|atoi
argument_list|(
name|env_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_size
operator|<
literal|2
condition|)
name|line_size
operator|=
literal|70
expr_stmt|;
block|}
else|else
name|line_size
operator|=
literal|70
expr_stmt|;
comment|/* Initialize the machine.  */
name|init_storage
argument_list|()
expr_stmt|;
name|init_load
argument_list|()
expr_stmt|;
comment|/* Set up interrupts to print a message. */
if|if
condition|(
name|interactive
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|use_quit
argument_list|)
expr_stmt|;
comment|/* Initialize the front end. */
name|init_tree
argument_list|()
expr_stmt|;
name|init_gen
argument_list|()
expr_stmt|;
name|is_std_in
operator|=
name|FALSE
expr_stmt|;
name|first_file
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|open_new_file
argument_list|()
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|READLINE
comment|/* Readline support.  Set both application name and input file. */
name|rl_readline_name
operator|=
literal|"bc"
expr_stmt|;
name|rl_instream
operator|=
name|stdin
expr_stmt|;
name|using_history
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Do the parse. */
name|yyparse
argument_list|()
expr_stmt|;
comment|/* End the compile only output with a newline. */
if|if
condition|(
name|compile_only
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is the function that opens all the files.     It returns TRUE if the file was opened, otherwise    it returns FALSE. */
end_comment

begin_function
name|int
name|open_new_file
parameter_list|()
block|{
name|FILE
modifier|*
name|new_file
decl_stmt|;
name|file_node
modifier|*
name|temp
decl_stmt|;
comment|/* Set the line number. */
name|line_no
operator|=
literal|1
expr_stmt|;
comment|/* Check to see if we are done. */
if|if
condition|(
name|is_std_in
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* Open the other files. */
if|if
condition|(
name|use_math
operator|&&
name|first_file
condition|)
block|{
ifdef|#
directive|ifdef
name|BC_MATH_FILE
comment|/* Make the first file be the math library. */
name|new_file
operator|=
name|fopen
argument_list|(
name|BC_MATH_FILE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|use_math
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|new_file
operator|!=
name|NULL
condition|)
block|{
name|new_yy_file
argument_list|(
name|new_file
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Math Library unavailable.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* Load the code from a precompiled version of the math libarary. */
specifier|extern
name|char
name|libmath
index|[]
decl_stmt|;
name|char
name|tmp
decl_stmt|;
comment|/* These MUST be in the order of first mention of each function. 	 That is why "a" comes before "c" even though "a" is defined after 	 after "c".  "a" is used in "s"! */
name|tmp
operator|=
name|lookup
argument_list|(
literal|"e"
argument_list|,
name|FUNCT
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|lookup
argument_list|(
literal|"l"
argument_list|,
name|FUNCT
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|lookup
argument_list|(
literal|"s"
argument_list|,
name|FUNCT
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|lookup
argument_list|(
literal|"a"
argument_list|,
name|FUNCT
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|lookup
argument_list|(
literal|"c"
argument_list|,
name|FUNCT
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|lookup
argument_list|(
literal|"j"
argument_list|,
name|FUNCT
argument_list|)
expr_stmt|;
name|load_code
argument_list|(
name|libmath
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* One of the argv values. */
if|if
condition|(
name|file_names
operator|!=
name|NULL
condition|)
block|{
name|new_file
operator|=
name|fopen
argument_list|(
name|file_names
operator|->
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_file
operator|!=
name|NULL
condition|)
block|{
name|new_yy_file
argument_list|(
name|new_file
argument_list|)
expr_stmt|;
name|temp
operator|=
name|file_names
expr_stmt|;
name|file_name
operator|=
name|temp
operator|->
name|name
expr_stmt|;
name|file_names
operator|=
name|temp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"File %s is unavailable.\n"
argument_list|,
name|file_names
operator|->
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If we fall through to here, we should return stdin. */
name|new_yy_file
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|is_std_in
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set yyin to the new file. */
end_comment

begin_function
name|void
name|new_yy_file
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|first_file
condition|)
name|fclose
argument_list|(
name|yyin
argument_list|)
expr_stmt|;
name|yyin
operator|=
name|file
expr_stmt|;
name|first_file
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Message to use quit.  */
end_comment

begin_function
name|void
name|use_quit
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"\n(interrupt) use quit to exit.\n"
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|use_quit
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

