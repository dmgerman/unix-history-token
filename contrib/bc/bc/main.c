begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* main.c: The main program for bc.  */
end_comment

begin_comment
comment|/*  This file is part of GNU bc.     Copyright (C) 1991-1994, 1997, 1998, 2000 Free Software Foundation, Inc.      This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 2 of the License , or     (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License     along with this program; see the file COPYING.  If not, write to       The Free Software Foundation, Inc.       59 Temple Place, Suite 330       Boston, MA 02111 USA      You may contact the author by:        e-mail:  philnelson@acm.org       us-mail:  Philip A. Nelson                 Computer Science Department, 9062                 Western Washington University                 Bellingham, WA 98226-9062  $FreeBSD$         *************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"bcdefs.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|"proto.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_comment
comment|/* Variables for processing multiple files. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|first_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Points to the last node in the file name list for easy adding. */
end_comment

begin_decl_stmt
specifier|static
name|file_node
modifier|*
name|last
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* long option support */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"compile"
block|,
literal|0
block|,
operator|&
name|compile_only
block|,
name|TRUE
block|}
block|,
block|{
literal|"help"
block|,
literal|0
block|,
literal|0
block|,
literal|'h'
block|}
block|,
block|{
literal|"interactive"
block|,
literal|0
block|,
literal|0
block|,
literal|'i'
block|}
block|,
block|{
literal|"mathlib"
block|,
literal|0
block|,
operator|&
name|use_math
block|,
name|TRUE
block|}
block|,
block|{
literal|"quiet"
block|,
literal|0
block|,
operator|&
name|quiet
block|,
name|TRUE
block|}
block|,
block|{
literal|"standard"
block|,
literal|0
block|,
operator|&
name|std_only
block|,
name|TRUE
block|}
block|,
block|{
literal|"version"
block|,
literal|0
block|,
literal|0
block|,
literal|'v'
block|}
block|,
block|{
literal|"warn"
block|,
literal|0
block|,
operator|&
name|warn_not_std
block|,
name|TRUE
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|usage
parameter_list|(
name|char
modifier|*
name|progname
parameter_list|)
block|{
name|printf
argument_list|(
literal|"usage: %s [options] [file ...]\n%s%s%s%s%s%s%s"
argument_list|,
name|progname
argument_list|,
literal|"  -h  --help         print this usage and exit\n"
argument_list|,
literal|"  -i  --interactive  force interactive mode\n"
argument_list|,
literal|"  -l  --mathlib      use the predefine math routnes\n"
argument_list|,
literal|"  -q  --quiet        don't print initial banner\n"
argument_list|,
literal|"  -s  --standard     non-standard bc constructs are errors\n"
argument_list|,
literal|"  -w  --warn         warn about non-standard bc constructs\n"
argument_list|,
literal|"  -v  --version      print version information and exit\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|parse_args
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|optch
decl_stmt|;
name|int
name|long_index
decl_stmt|;
name|file_node
modifier|*
name|temp
decl_stmt|;
comment|/* Force getopt to initialize.  Depends on GNU getopt. */
name|optind
operator|=
literal|0
expr_stmt|;
comment|/* Parse the command line */
while|while
condition|(
literal|1
condition|)
block|{
name|optch
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"chilqswv"
argument_list|,
name|long_options
argument_list|,
operator|&
name|long_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|optch
operator|==
name|EOF
condition|)
comment|/* End of arguments. */
break|break;
switch|switch
condition|(
name|optch
condition|)
block|{
case|case
literal|'c'
case|:
comment|/* compile only */
name|compile_only
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* help */
name|usage
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* force interactive */
name|interactive
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* math lib */
name|use_math
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* quiet mode */
name|quiet
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Non standard features give errors. */
name|std_only
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* Print the version. */
name|show_bc_version
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* Non standard features give warnings. */
name|warn_not_std
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* long options */
break|break;
default|default:
name|usage
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Add file names to a list of files to process. */
while|while
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|temp
operator|=
operator|(
name|file_node
operator|*
operator|)
name|bc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|file_node
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|name
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last
operator|==
name|NULL
condition|)
name|file_names
operator|=
name|temp
expr_stmt|;
else|else
name|last
operator|->
name|next
operator|=
name|temp
expr_stmt|;
name|last
operator|=
name|temp
expr_stmt|;
name|optind
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The main program for bc. */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|env_value
decl_stmt|;
name|char
modifier|*
name|env_argv
index|[
literal|30
index|]
decl_stmt|;
name|int
name|env_argc
decl_stmt|;
comment|/* Initialize many variables. */
name|compile_only
operator|=
name|FALSE
expr_stmt|;
name|use_math
operator|=
name|FALSE
expr_stmt|;
name|warn_not_std
operator|=
name|FALSE
expr_stmt|;
name|std_only
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|isatty
argument_list|(
literal|0
argument_list|)
operator|&&
name|isatty
argument_list|(
literal|1
argument_list|)
condition|)
name|interactive
operator|=
name|TRUE
expr_stmt|;
else|else
name|interactive
operator|=
name|FALSE
expr_stmt|;
name|quiet
operator|=
name|FALSE
expr_stmt|;
name|file_names
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SETVBUF
comment|/* attempt to simplify interaction with applications such as emacs */
operator|(
name|void
operator|)
name|setvbuf
argument_list|(
name|stdout
argument_list|,
name|NULL
argument_list|,
name|_IOLBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Environment arguments. */
name|env_value
operator|=
name|getenv
argument_list|(
literal|"BC_ENV_ARGS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env_value
operator|!=
name|NULL
condition|)
block|{
name|env_argc
operator|=
literal|1
expr_stmt|;
name|env_argv
index|[
literal|0
index|]
operator|=
literal|"BC_ENV_ARGS"
expr_stmt|;
while|while
condition|(
operator|*
name|env_value
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|env_value
operator|!=
literal|' '
condition|)
block|{
name|env_argv
index|[
name|env_argc
operator|++
index|]
operator|=
name|env_value
expr_stmt|;
while|while
condition|(
operator|*
name|env_value
operator|!=
literal|' '
operator|&&
operator|*
name|env_value
operator|!=
literal|0
condition|)
name|env_value
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|env_value
operator|!=
literal|0
condition|)
block|{
operator|*
name|env_value
operator|=
literal|0
expr_stmt|;
name|env_value
operator|++
expr_stmt|;
block|}
block|}
else|else
name|env_value
operator|++
expr_stmt|;
block|}
name|parse_args
argument_list|(
name|env_argc
argument_list|,
name|env_argv
argument_list|)
expr_stmt|;
block|}
comment|/* Command line arguments. */
name|parse_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* Other environment processing. */
if|if
condition|(
name|getenv
argument_list|(
literal|"POSIXLY_CORRECT"
argument_list|)
operator|!=
name|NULL
condition|)
name|std_only
operator|=
name|TRUE
expr_stmt|;
name|env_value
operator|=
name|getenv
argument_list|(
literal|"BC_LINE_LENGTH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env_value
operator|!=
name|NULL
condition|)
block|{
name|line_size
operator|=
name|atoi
argument_list|(
name|env_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_size
operator|<
literal|2
condition|)
name|line_size
operator|=
literal|70
expr_stmt|;
block|}
else|else
name|line_size
operator|=
literal|70
expr_stmt|;
comment|/* Initialize the machine.  */
name|init_storage
argument_list|()
expr_stmt|;
name|init_load
argument_list|()
expr_stmt|;
comment|/* Set up interrupts to print a message. */
if|if
condition|(
name|interactive
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|use_quit
argument_list|)
expr_stmt|;
comment|/* Initialize the front end. */
name|init_tree
argument_list|()
expr_stmt|;
name|init_gen
argument_list|()
expr_stmt|;
name|is_std_in
operator|=
name|FALSE
expr_stmt|;
name|first_file
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|open_new_file
argument_list|()
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LIBEDIT
argument_list|)
if|if
condition|(
name|interactive
condition|)
block|{
comment|/* Enable libedit support. */
name|edit
operator|=
name|el_init
argument_list|(
literal|"bc"
argument_list|,
name|stdin
argument_list|,
name|stdout
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|hist
operator|=
name|history_init
argument_list|()
expr_stmt|;
name|el_set
argument_list|(
name|edit
argument_list|,
name|EL_EDITOR
argument_list|,
literal|"emacs"
argument_list|)
expr_stmt|;
name|el_set
argument_list|(
name|edit
argument_list|,
name|EL_HIST
argument_list|,
name|history
argument_list|,
name|hist
argument_list|)
expr_stmt|;
name|el_set
argument_list|(
name|edit
argument_list|,
name|EL_PROMPT
argument_list|,
name|null_prompt
argument_list|)
expr_stmt|;
name|el_source
argument_list|(
name|edit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|history
argument_list|(
name|hist
argument_list|,
operator|&
name|histev
argument_list|,
name|H_SETSIZE
argument_list|,
name|INT_MAX
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|READLINE
argument_list|)
if|if
condition|(
name|interactive
condition|)
block|{
comment|/* Readline support.  Set both application name and input file. */
name|rl_readline_name
operator|=
literal|"bc"
expr_stmt|;
name|rl_instream
operator|=
name|stdin
expr_stmt|;
name|using_history
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Do the parse. */
name|yyparse
argument_list|()
expr_stmt|;
comment|/* End the compile only output with a newline. */
if|if
condition|(
name|compile_only
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is the function that opens all the files.     It returns TRUE if the file was opened, otherwise    it returns FALSE. */
end_comment

begin_function
name|int
name|open_new_file
parameter_list|()
block|{
name|FILE
modifier|*
name|new_file
decl_stmt|;
name|file_node
modifier|*
name|temp
decl_stmt|;
comment|/* Set the line number. */
name|line_no
operator|=
literal|1
expr_stmt|;
comment|/* Check to see if we are done. */
if|if
condition|(
name|is_std_in
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* Open the other files. */
if|if
condition|(
name|use_math
operator|&&
name|first_file
condition|)
block|{
comment|/* Load the code from a precompiled version of the math libarary. */
specifier|extern
name|char
modifier|*
name|libmath
index|[]
decl_stmt|;
name|char
modifier|*
modifier|*
name|mstr
decl_stmt|;
name|char
name|tmp
decl_stmt|;
comment|/* These MUST be in the order of first mention of each function. 	 That is why "a" comes before "c" even though "a" is defined after 	 after "c".  "a" is used in "s"! */
name|tmp
operator|=
name|lookup
argument_list|(
literal|"e"
argument_list|,
name|FUNCT
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|lookup
argument_list|(
literal|"l"
argument_list|,
name|FUNCT
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|lookup
argument_list|(
literal|"s"
argument_list|,
name|FUNCT
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|lookup
argument_list|(
literal|"a"
argument_list|,
name|FUNCT
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|lookup
argument_list|(
literal|"c"
argument_list|,
name|FUNCT
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|lookup
argument_list|(
literal|"j"
argument_list|,
name|FUNCT
argument_list|)
expr_stmt|;
name|mstr
operator|=
name|libmath
expr_stmt|;
while|while
condition|(
operator|*
name|mstr
condition|)
block|{
name|load_code
argument_list|(
operator|*
name|mstr
argument_list|)
expr_stmt|;
name|mstr
operator|++
expr_stmt|;
block|}
block|}
comment|/* One of the argv values. */
if|if
condition|(
name|file_names
operator|!=
name|NULL
condition|)
block|{
name|new_file
operator|=
name|fopen
argument_list|(
name|file_names
operator|->
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_file
operator|!=
name|NULL
condition|)
block|{
name|new_yy_file
argument_list|(
name|new_file
argument_list|)
expr_stmt|;
name|temp
operator|=
name|file_names
expr_stmt|;
name|file_name
operator|=
name|temp
operator|->
name|name
expr_stmt|;
name|file_names
operator|=
name|temp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"File %s is unavailable.\n"
argument_list|,
name|file_names
operator|->
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If we fall through to here, we should return stdin. */
name|new_yy_file
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|is_std_in
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set yyin to the new file. */
end_comment

begin_function
name|void
name|new_yy_file
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|first_file
condition|)
name|fclose
argument_list|(
name|yyin
argument_list|)
expr_stmt|;
name|yyin
operator|=
name|file
expr_stmt|;
name|first_file
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Message to use quit.  */
end_comment

begin_function
name|void
name|use_quit
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"\n(interrupt) use quit to exit.\n"
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|use_quit
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

