begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * (C) Copyright David Gibson<dwg@au1.ibm.com>, IBM Corporation.  2005.  *  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License as  * published by the Free Software Foundation; either version 2 of the  * License, or (at your option) any later version.  *  *  This program is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *  General Public License for more details.  *  *  You should have received a copy of the GNU General Public License  *  along with this program; if not, write to the Free Software  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  *                                                                   USA  */
end_comment

begin_include
include|#
directive|include
file|"dtc.h"
end_include

begin_include
include|#
directive|include
file|"srcpos.h"
end_include

begin_define
define|#
directive|define
name|FTF_FULLPATH
value|0x1
end_define

begin_define
define|#
directive|define
name|FTF_VARALIGN
value|0x2
end_define

begin_define
define|#
directive|define
name|FTF_NAMEPROPS
value|0x4
end_define

begin_define
define|#
directive|define
name|FTF_BOOTCPUID
value|0x8
end_define

begin_define
define|#
directive|define
name|FTF_STRTABSIZE
value|0x10
end_define

begin_define
define|#
directive|define
name|FTF_STRUCTSIZE
value|0x20
end_define

begin_define
define|#
directive|define
name|FTF_NOPS
value|0x40
end_define

begin_struct
specifier|static
struct|struct
name|version_info
block|{
name|int
name|version
decl_stmt|;
name|int
name|last_comp_version
decl_stmt|;
name|int
name|hdr_size
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|}
name|version_table
index|[]
init|=
block|{
block|{
literal|1
block|,
literal|1
block|,
name|FDT_V1_SIZE
block|,
name|FTF_FULLPATH
operator||
name|FTF_VARALIGN
operator||
name|FTF_NAMEPROPS
block|}
block|,
block|{
literal|2
block|,
literal|1
block|,
name|FDT_V2_SIZE
block|,
name|FTF_FULLPATH
operator||
name|FTF_VARALIGN
operator||
name|FTF_NAMEPROPS
operator||
name|FTF_BOOTCPUID
block|}
block|,
block|{
literal|3
block|,
literal|1
block|,
name|FDT_V3_SIZE
block|,
name|FTF_FULLPATH
operator||
name|FTF_VARALIGN
operator||
name|FTF_NAMEPROPS
operator||
name|FTF_BOOTCPUID
operator||
name|FTF_STRTABSIZE
block|}
block|,
block|{
literal|16
block|,
literal|16
block|,
name|FDT_V3_SIZE
block|,
name|FTF_BOOTCPUID
operator||
name|FTF_STRTABSIZE
operator||
name|FTF_NOPS
block|}
block|,
block|{
literal|17
block|,
literal|16
block|,
name|FDT_V17_SIZE
block|,
name|FTF_BOOTCPUID
operator||
name|FTF_STRTABSIZE
operator||
name|FTF_STRUCTSIZE
operator||
name|FTF_NOPS
block|}
block|, }
struct|;
end_struct

begin_struct
struct|struct
name|emitter
block|{
name|void
function_decl|(
modifier|*
name|cell
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|cell_t
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|string
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|align
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|data
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|data
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|beginnode
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|label
modifier|*
name|labels
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|endnode
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|label
modifier|*
name|labels
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|property
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|label
modifier|*
name|labels
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|bin_emit_cell
parameter_list|(
name|void
modifier|*
name|e
parameter_list|,
name|cell_t
name|val
parameter_list|)
block|{
name|struct
name|data
modifier|*
name|dtbuf
init|=
name|e
decl_stmt|;
operator|*
name|dtbuf
operator|=
name|data_append_cell
argument_list|(
operator|*
name|dtbuf
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bin_emit_string
parameter_list|(
name|void
modifier|*
name|e
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|data
modifier|*
name|dtbuf
init|=
name|e
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
operator|*
name|dtbuf
operator|=
name|data_append_data
argument_list|(
operator|*
name|dtbuf
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
name|dtbuf
operator|=
name|data_append_byte
argument_list|(
operator|*
name|dtbuf
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bin_emit_align
parameter_list|(
name|void
modifier|*
name|e
parameter_list|,
name|int
name|a
parameter_list|)
block|{
name|struct
name|data
modifier|*
name|dtbuf
init|=
name|e
decl_stmt|;
operator|*
name|dtbuf
operator|=
name|data_append_align
argument_list|(
operator|*
name|dtbuf
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bin_emit_data
parameter_list|(
name|void
modifier|*
name|e
parameter_list|,
name|struct
name|data
name|d
parameter_list|)
block|{
name|struct
name|data
modifier|*
name|dtbuf
init|=
name|e
decl_stmt|;
operator|*
name|dtbuf
operator|=
name|data_append_data
argument_list|(
operator|*
name|dtbuf
argument_list|,
name|d
operator|.
name|val
argument_list|,
name|d
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bin_emit_beginnode
parameter_list|(
name|void
modifier|*
name|e
parameter_list|,
name|struct
name|label
modifier|*
name|labels
parameter_list|)
block|{
name|bin_emit_cell
argument_list|(
name|e
argument_list|,
name|FDT_BEGIN_NODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bin_emit_endnode
parameter_list|(
name|void
modifier|*
name|e
parameter_list|,
name|struct
name|label
modifier|*
name|labels
parameter_list|)
block|{
name|bin_emit_cell
argument_list|(
name|e
argument_list|,
name|FDT_END_NODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bin_emit_property
parameter_list|(
name|void
modifier|*
name|e
parameter_list|,
name|struct
name|label
modifier|*
name|labels
parameter_list|)
block|{
name|bin_emit_cell
argument_list|(
name|e
argument_list|,
name|FDT_PROP
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|emitter
name|bin_emitter
init|=
block|{
operator|.
name|cell
operator|=
name|bin_emit_cell
block|,
operator|.
name|string
operator|=
name|bin_emit_string
block|,
operator|.
name|align
operator|=
name|bin_emit_align
block|,
operator|.
name|data
operator|=
name|bin_emit_data
block|,
operator|.
name|beginnode
operator|=
name|bin_emit_beginnode
block|,
operator|.
name|endnode
operator|=
name|bin_emit_endnode
block|,
operator|.
name|property
operator|=
name|bin_emit_property
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|emit_label
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|label
parameter_list|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.globl\t%s_%s\n"
argument_list|,
name|prefix
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s_%s:\n"
argument_list|,
name|prefix
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"_%s_%s:\n"
argument_list|,
name|prefix
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|emit_offset_label
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|label
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.globl\t%s\n"
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\t= . + %d\n"
argument_list|,
name|label
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|ASM_EMIT_BELONG
parameter_list|(
name|f
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
define|\
value|{ \ 		fprintf((f), "\t.byte\t((" fmt ")>> 24)& 0xff\n", __VA_ARGS__); \ 		fprintf((f), "\t.byte\t((" fmt ")>> 16)& 0xff\n", __VA_ARGS__); \ 		fprintf((f), "\t.byte\t((" fmt ")>> 8)& 0xff\n", __VA_ARGS__); \ 		fprintf((f), "\t.byte\t(" fmt ")& 0xff\n", __VA_ARGS__); \ 	}
end_define

begin_function
specifier|static
name|void
name|asm_emit_cell
parameter_list|(
name|void
modifier|*
name|e
parameter_list|,
name|cell_t
name|val
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|e
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.byte 0x%02x; .byte 0x%02x; .byte 0x%02x; .byte 0x%02x\n"
argument_list|,
operator|(
name|val
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|val
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|asm_emit_string
parameter_list|(
name|void
modifier|*
name|e
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|e
decl_stmt|;
name|char
name|c
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
comment|/* XXX: ewww */
name|c
operator|=
name|str
index|[
name|len
index|]
expr_stmt|;
name|str
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.string\t\"%s\"\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|str
index|[
name|len
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|asm_emit_align
parameter_list|(
name|void
modifier|*
name|e
parameter_list|,
name|int
name|a
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|e
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.balign\t%d, 0\n"
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|asm_emit_data
parameter_list|(
name|void
modifier|*
name|e
parameter_list|,
name|struct
name|data
name|d
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|e
decl_stmt|;
name|int
name|off
init|=
literal|0
decl_stmt|;
name|struct
name|marker
modifier|*
name|m
init|=
name|d
operator|.
name|markers
decl_stmt|;
name|for_each_marker_of_type
argument_list|(
argument|m
argument_list|,
argument|LABEL
argument_list|)
name|emit_offset_label
argument_list|(
name|f
argument_list|,
name|m
operator|->
name|ref
argument_list|,
name|m
operator|->
name|offset
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|d
operator|.
name|len
operator|-
name|off
operator|)
operator|>=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|asm_emit_cell
argument_list|(
name|e
argument_list|,
name|fdt32_to_cpu
argument_list|(
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|d
operator|.
name|val
operator|+
name|off
operator|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|off
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|d
operator|.
name|len
operator|-
name|off
operator|)
operator|>=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.byte\t0x%hhx\n"
argument_list|,
name|d
operator|.
name|val
index|[
name|off
index|]
argument_list|)
expr_stmt|;
name|off
operator|+=
literal|1
expr_stmt|;
block|}
name|assert
argument_list|(
name|off
operator|==
name|d
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|asm_emit_beginnode
parameter_list|(
name|void
modifier|*
name|e
parameter_list|,
name|struct
name|label
modifier|*
name|labels
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|e
decl_stmt|;
name|struct
name|label
modifier|*
name|l
decl_stmt|;
name|for_each_label
argument_list|(
argument|labels
argument_list|,
argument|l
argument_list|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.globl\t%s\n"
argument_list|,
name|l
operator|->
name|label
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s:\n"
argument_list|,
name|l
operator|->
name|label
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t/* FDT_BEGIN_NODE */\n"
argument_list|)
expr_stmt|;
name|asm_emit_cell
argument_list|(
name|e
argument_list|,
name|FDT_BEGIN_NODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|asm_emit_endnode
parameter_list|(
name|void
modifier|*
name|e
parameter_list|,
name|struct
name|label
modifier|*
name|labels
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|e
decl_stmt|;
name|struct
name|label
modifier|*
name|l
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t/* FDT_END_NODE */\n"
argument_list|)
expr_stmt|;
name|asm_emit_cell
argument_list|(
name|e
argument_list|,
name|FDT_END_NODE
argument_list|)
expr_stmt|;
name|for_each_label
argument_list|(
argument|labels
argument_list|,
argument|l
argument_list|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.globl\t%s_end\n"
argument_list|,
name|l
operator|->
name|label
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s_end:\n"
argument_list|,
name|l
operator|->
name|label
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|asm_emit_property
parameter_list|(
name|void
modifier|*
name|e
parameter_list|,
name|struct
name|label
modifier|*
name|labels
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|e
decl_stmt|;
name|struct
name|label
modifier|*
name|l
decl_stmt|;
name|for_each_label
argument_list|(
argument|labels
argument_list|,
argument|l
argument_list|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.globl\t%s\n"
argument_list|,
name|l
operator|->
name|label
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s:\n"
argument_list|,
name|l
operator|->
name|label
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t/* FDT_PROP */\n"
argument_list|)
expr_stmt|;
name|asm_emit_cell
argument_list|(
name|e
argument_list|,
name|FDT_PROP
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|emitter
name|asm_emitter
init|=
block|{
operator|.
name|cell
operator|=
name|asm_emit_cell
block|,
operator|.
name|string
operator|=
name|asm_emit_string
block|,
operator|.
name|align
operator|=
name|asm_emit_align
block|,
operator|.
name|data
operator|=
name|asm_emit_data
block|,
operator|.
name|beginnode
operator|=
name|asm_emit_beginnode
block|,
operator|.
name|endnode
operator|=
name|asm_emit_endnode
block|,
operator|.
name|property
operator|=
name|asm_emit_property
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|stringtable_insert
parameter_list|(
name|struct
name|data
modifier|*
name|d
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* FIXME: do this more efficiently? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|streq
argument_list|(
name|str
argument_list|,
name|d
operator|->
name|val
operator|+
name|i
argument_list|)
condition|)
return|return
name|i
return|;
block|}
operator|*
name|d
operator|=
name|data_append_data
argument_list|(
operator|*
name|d
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|flatten_tree
parameter_list|(
name|struct
name|node
modifier|*
name|tree
parameter_list|,
name|struct
name|emitter
modifier|*
name|emit
parameter_list|,
name|void
modifier|*
name|etarget
parameter_list|,
name|struct
name|data
modifier|*
name|strbuf
parameter_list|,
name|struct
name|version_info
modifier|*
name|vi
parameter_list|)
block|{
name|struct
name|property
modifier|*
name|prop
decl_stmt|;
name|struct
name|node
modifier|*
name|child
decl_stmt|;
name|bool
name|seen_name_prop
init|=
name|false
decl_stmt|;
if|if
condition|(
name|tree
operator|->
name|deleted
condition|)
return|return;
name|emit
operator|->
name|beginnode
argument_list|(
name|etarget
argument_list|,
name|tree
operator|->
name|labels
argument_list|)
expr_stmt|;
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|FTF_FULLPATH
condition|)
name|emit
operator|->
name|string
argument_list|(
name|etarget
argument_list|,
name|tree
operator|->
name|fullpath
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|emit
operator|->
name|string
argument_list|(
name|etarget
argument_list|,
name|tree
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit
operator|->
name|align
argument_list|(
name|etarget
argument_list|,
sizeof|sizeof
argument_list|(
name|cell_t
argument_list|)
argument_list|)
expr_stmt|;
name|for_each_property
argument_list|(
argument|tree
argument_list|,
argument|prop
argument_list|)
block|{
name|int
name|nameoff
decl_stmt|;
if|if
condition|(
name|streq
argument_list|(
name|prop
operator|->
name|name
argument_list|,
literal|"name"
argument_list|)
condition|)
name|seen_name_prop
operator|=
name|true
expr_stmt|;
name|nameoff
operator|=
name|stringtable_insert
argument_list|(
name|strbuf
argument_list|,
name|prop
operator|->
name|name
argument_list|)
expr_stmt|;
name|emit
operator|->
name|property
argument_list|(
name|etarget
argument_list|,
name|prop
operator|->
name|labels
argument_list|)
expr_stmt|;
name|emit
operator|->
name|cell
argument_list|(
name|etarget
argument_list|,
name|prop
operator|->
name|val
operator|.
name|len
argument_list|)
expr_stmt|;
name|emit
operator|->
name|cell
argument_list|(
name|etarget
argument_list|,
name|nameoff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vi
operator|->
name|flags
operator|&
name|FTF_VARALIGN
operator|)
operator|&&
operator|(
name|prop
operator|->
name|val
operator|.
name|len
operator|>=
literal|8
operator|)
condition|)
name|emit
operator|->
name|align
argument_list|(
name|etarget
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|emit
operator|->
name|data
argument_list|(
name|etarget
argument_list|,
name|prop
operator|->
name|val
argument_list|)
expr_stmt|;
name|emit
operator|->
name|align
argument_list|(
name|etarget
argument_list|,
sizeof|sizeof
argument_list|(
name|cell_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|vi
operator|->
name|flags
operator|&
name|FTF_NAMEPROPS
operator|)
operator|&&
operator|!
name|seen_name_prop
condition|)
block|{
name|emit
operator|->
name|property
argument_list|(
name|etarget
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|emit
operator|->
name|cell
argument_list|(
name|etarget
argument_list|,
name|tree
operator|->
name|basenamelen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|emit
operator|->
name|cell
argument_list|(
name|etarget
argument_list|,
name|stringtable_insert
argument_list|(
name|strbuf
argument_list|,
literal|"name"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vi
operator|->
name|flags
operator|&
name|FTF_VARALIGN
operator|)
operator|&&
operator|(
operator|(
name|tree
operator|->
name|basenamelen
operator|+
literal|1
operator|)
operator|>=
literal|8
operator|)
condition|)
name|emit
operator|->
name|align
argument_list|(
name|etarget
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|emit
operator|->
name|string
argument_list|(
name|etarget
argument_list|,
name|tree
operator|->
name|name
argument_list|,
name|tree
operator|->
name|basenamelen
argument_list|)
expr_stmt|;
name|emit
operator|->
name|align
argument_list|(
name|etarget
argument_list|,
sizeof|sizeof
argument_list|(
name|cell_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|for_each_child
argument_list|(
argument|tree
argument_list|,
argument|child
argument_list|)
block|{
name|flatten_tree
argument_list|(
name|child
argument_list|,
name|emit
argument_list|,
name|etarget
argument_list|,
name|strbuf
argument_list|,
name|vi
argument_list|)
expr_stmt|;
block|}
name|emit
operator|->
name|endnode
argument_list|(
name|etarget
argument_list|,
name|tree
operator|->
name|labels
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|data
name|flatten_reserve_list
parameter_list|(
name|struct
name|reserve_info
modifier|*
name|reservelist
parameter_list|,
name|struct
name|version_info
modifier|*
name|vi
parameter_list|)
block|{
name|struct
name|reserve_info
modifier|*
name|re
decl_stmt|;
name|struct
name|data
name|d
init|=
name|empty_data
decl_stmt|;
specifier|static
name|struct
name|fdt_reserve_entry
name|null_re
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|re
operator|=
name|reservelist
init|;
name|re
condition|;
name|re
operator|=
name|re
operator|->
name|next
control|)
block|{
name|d
operator|=
name|data_append_re
argument_list|(
name|d
argument_list|,
operator|&
name|re
operator|->
name|re
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Add additional reserved slots if the user asked for them. 	 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|reservenum
condition|;
name|j
operator|++
control|)
block|{
name|d
operator|=
name|data_append_re
argument_list|(
name|d
argument_list|,
operator|&
name|null_re
argument_list|)
expr_stmt|;
block|}
return|return
name|d
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|make_fdt_header
parameter_list|(
name|struct
name|fdt_header
modifier|*
name|fdt
parameter_list|,
name|struct
name|version_info
modifier|*
name|vi
parameter_list|,
name|int
name|reservesize
parameter_list|,
name|int
name|dtsize
parameter_list|,
name|int
name|strsize
parameter_list|,
name|int
name|boot_cpuid_phys
parameter_list|)
block|{
name|int
name|reserve_off
decl_stmt|;
name|reservesize
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|fdt_reserve_entry
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fdt
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fdt
argument_list|)
argument_list|)
expr_stmt|;
name|fdt
operator|->
name|magic
operator|=
name|cpu_to_fdt32
argument_list|(
name|FDT_MAGIC
argument_list|)
expr_stmt|;
name|fdt
operator|->
name|version
operator|=
name|cpu_to_fdt32
argument_list|(
name|vi
operator|->
name|version
argument_list|)
expr_stmt|;
name|fdt
operator|->
name|last_comp_version
operator|=
name|cpu_to_fdt32
argument_list|(
name|vi
operator|->
name|last_comp_version
argument_list|)
expr_stmt|;
comment|/* Reserve map should be doubleword aligned */
name|reserve_off
operator|=
name|ALIGN
argument_list|(
name|vi
operator|->
name|hdr_size
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|fdt
operator|->
name|off_mem_rsvmap
operator|=
name|cpu_to_fdt32
argument_list|(
name|reserve_off
argument_list|)
expr_stmt|;
name|fdt
operator|->
name|off_dt_struct
operator|=
name|cpu_to_fdt32
argument_list|(
name|reserve_off
operator|+
name|reservesize
argument_list|)
expr_stmt|;
name|fdt
operator|->
name|off_dt_strings
operator|=
name|cpu_to_fdt32
argument_list|(
name|reserve_off
operator|+
name|reservesize
operator|+
name|dtsize
argument_list|)
expr_stmt|;
name|fdt
operator|->
name|totalsize
operator|=
name|cpu_to_fdt32
argument_list|(
name|reserve_off
operator|+
name|reservesize
operator|+
name|dtsize
operator|+
name|strsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|FTF_BOOTCPUID
condition|)
name|fdt
operator|->
name|boot_cpuid_phys
operator|=
name|cpu_to_fdt32
argument_list|(
name|boot_cpuid_phys
argument_list|)
expr_stmt|;
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|FTF_STRTABSIZE
condition|)
name|fdt
operator|->
name|size_dt_strings
operator|=
name|cpu_to_fdt32
argument_list|(
name|strsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|FTF_STRUCTSIZE
condition|)
name|fdt
operator|->
name|size_dt_struct
operator|=
name|cpu_to_fdt32
argument_list|(
name|dtsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dt_to_blob
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|struct
name|dt_info
modifier|*
name|dti
parameter_list|,
name|int
name|version
parameter_list|)
block|{
name|struct
name|version_info
modifier|*
name|vi
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|data
name|blob
init|=
name|empty_data
decl_stmt|;
name|struct
name|data
name|reservebuf
init|=
name|empty_data
decl_stmt|;
name|struct
name|data
name|dtbuf
init|=
name|empty_data
decl_stmt|;
name|struct
name|data
name|strbuf
init|=
name|empty_data
decl_stmt|;
name|struct
name|fdt_header
name|fdt
decl_stmt|;
name|int
name|padlen
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|version_table
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|version_table
index|[
name|i
index|]
operator|.
name|version
operator|==
name|version
condition|)
name|vi
operator|=
operator|&
name|version_table
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|vi
condition|)
name|die
argument_list|(
literal|"Unknown device tree blob version %d\n"
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|flatten_tree
argument_list|(
name|dti
operator|->
name|dt
argument_list|,
operator|&
name|bin_emitter
argument_list|,
operator|&
name|dtbuf
argument_list|,
operator|&
name|strbuf
argument_list|,
name|vi
argument_list|)
expr_stmt|;
name|bin_emit_cell
argument_list|(
operator|&
name|dtbuf
argument_list|,
name|FDT_END
argument_list|)
expr_stmt|;
name|reservebuf
operator|=
name|flatten_reserve_list
argument_list|(
name|dti
operator|->
name|reservelist
argument_list|,
name|vi
argument_list|)
expr_stmt|;
comment|/* Make header */
name|make_fdt_header
argument_list|(
operator|&
name|fdt
argument_list|,
name|vi
argument_list|,
name|reservebuf
operator|.
name|len
argument_list|,
name|dtbuf
operator|.
name|len
argument_list|,
name|strbuf
operator|.
name|len
argument_list|,
name|dti
operator|->
name|boot_cpuid_phys
argument_list|)
expr_stmt|;
comment|/* 	 * If the user asked for more space than is used, adjust the totalsize. 	 */
if|if
condition|(
name|minsize
operator|>
literal|0
condition|)
block|{
name|padlen
operator|=
name|minsize
operator|-
name|fdt32_to_cpu
argument_list|(
name|fdt
operator|.
name|totalsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|padlen
operator|<
literal|0
condition|)
block|{
name|padlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|quiet
operator|<
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: blob size %d>= minimum size %d\n"
argument_list|,
name|fdt32_to_cpu
argument_list|(
name|fdt
operator|.
name|totalsize
argument_list|)
argument_list|,
name|minsize
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|padsize
operator|>
literal|0
condition|)
name|padlen
operator|=
name|padsize
expr_stmt|;
if|if
condition|(
name|alignsize
operator|>
literal|0
condition|)
name|padlen
operator|=
name|ALIGN
argument_list|(
name|fdt32_to_cpu
argument_list|(
name|fdt
operator|.
name|totalsize
argument_list|)
operator|+
name|padlen
argument_list|,
name|alignsize
argument_list|)
operator|-
name|fdt32_to_cpu
argument_list|(
name|fdt
operator|.
name|totalsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|padlen
operator|>
literal|0
condition|)
block|{
name|int
name|tsize
init|=
name|fdt32_to_cpu
argument_list|(
name|fdt
operator|.
name|totalsize
argument_list|)
decl_stmt|;
name|tsize
operator|+=
name|padlen
expr_stmt|;
name|fdt
operator|.
name|totalsize
operator|=
name|cpu_to_fdt32
argument_list|(
name|tsize
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Assemble the blob: start with the header, add with alignment 	 * the reserve buffer, add the reserve map terminating zeroes, 	 * the device tree itself, and finally the strings. 	 */
name|blob
operator|=
name|data_append_data
argument_list|(
name|blob
argument_list|,
operator|&
name|fdt
argument_list|,
name|vi
operator|->
name|hdr_size
argument_list|)
expr_stmt|;
name|blob
operator|=
name|data_append_align
argument_list|(
name|blob
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|blob
operator|=
name|data_merge
argument_list|(
name|blob
argument_list|,
name|reservebuf
argument_list|)
expr_stmt|;
name|blob
operator|=
name|data_append_zeroes
argument_list|(
name|blob
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fdt_reserve_entry
argument_list|)
argument_list|)
expr_stmt|;
name|blob
operator|=
name|data_merge
argument_list|(
name|blob
argument_list|,
name|dtbuf
argument_list|)
expr_stmt|;
name|blob
operator|=
name|data_merge
argument_list|(
name|blob
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
comment|/* 	 * If the user asked for more space than is used, pad out the blob. 	 */
if|if
condition|(
name|padlen
operator|>
literal|0
condition|)
name|blob
operator|=
name|data_append_zeroes
argument_list|(
name|blob
argument_list|,
name|padlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|blob
operator|.
name|val
argument_list|,
name|blob
operator|.
name|len
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
name|die
argument_list|(
literal|"Error writing device tree blob: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|die
argument_list|(
literal|"Short write on device tree blob\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * data_merge() frees the right-hand element so only the blob 	 * remains to be freed. 	 */
name|data_free
argument_list|(
name|blob
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_stringtable_asm
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|struct
name|data
name|strbuf
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
name|p
operator|=
name|strbuf
operator|.
name|val
expr_stmt|;
while|while
condition|(
name|p
operator|<
operator|(
name|strbuf
operator|.
name|val
operator|+
name|strbuf
operator|.
name|len
operator|)
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.string \"%s\"\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dt_to_asm
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|struct
name|dt_info
modifier|*
name|dti
parameter_list|,
name|int
name|version
parameter_list|)
block|{
name|struct
name|version_info
modifier|*
name|vi
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|data
name|strbuf
init|=
name|empty_data
decl_stmt|;
name|struct
name|reserve_info
modifier|*
name|re
decl_stmt|;
specifier|const
name|char
modifier|*
name|symprefix
init|=
literal|"dt"
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|version_table
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|version_table
index|[
name|i
index|]
operator|.
name|version
operator|==
name|version
condition|)
name|vi
operator|=
operator|&
name|version_table
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|vi
condition|)
name|die
argument_list|(
literal|"Unknown device tree blob version %d\n"
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"/* autogenerated by dtc, do not edit */\n\n"
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|f
argument_list|,
name|symprefix
argument_list|,
literal|"blob_start"
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|f
argument_list|,
name|symprefix
argument_list|,
literal|"header"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t/* magic */\n"
argument_list|)
expr_stmt|;
name|asm_emit_cell
argument_list|(
name|f
argument_list|,
name|FDT_MAGIC
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t/* totalsize */\n"
argument_list|)
expr_stmt|;
name|ASM_EMIT_BELONG
argument_list|(
name|f
argument_list|,
literal|"_%s_blob_abs_end - _%s_blob_start"
argument_list|,
name|symprefix
argument_list|,
name|symprefix
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t/* off_dt_struct */\n"
argument_list|)
expr_stmt|;
name|ASM_EMIT_BELONG
argument_list|(
name|f
argument_list|,
literal|"_%s_struct_start - _%s_blob_start"
argument_list|,
name|symprefix
argument_list|,
name|symprefix
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t/* off_dt_strings */\n"
argument_list|)
expr_stmt|;
name|ASM_EMIT_BELONG
argument_list|(
name|f
argument_list|,
literal|"_%s_strings_start - _%s_blob_start"
argument_list|,
name|symprefix
argument_list|,
name|symprefix
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t/* off_mem_rsvmap */\n"
argument_list|)
expr_stmt|;
name|ASM_EMIT_BELONG
argument_list|(
name|f
argument_list|,
literal|"_%s_reserve_map - _%s_blob_start"
argument_list|,
name|symprefix
argument_list|,
name|symprefix
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t/* version */\n"
argument_list|)
expr_stmt|;
name|asm_emit_cell
argument_list|(
name|f
argument_list|,
name|vi
operator|->
name|version
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t/* last_comp_version */\n"
argument_list|)
expr_stmt|;
name|asm_emit_cell
argument_list|(
name|f
argument_list|,
name|vi
operator|->
name|last_comp_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|FTF_BOOTCPUID
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t/* boot_cpuid_phys */\n"
argument_list|)
expr_stmt|;
name|asm_emit_cell
argument_list|(
name|f
argument_list|,
name|dti
operator|->
name|boot_cpuid_phys
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|FTF_STRTABSIZE
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t/* size_dt_strings */\n"
argument_list|)
expr_stmt|;
name|ASM_EMIT_BELONG
argument_list|(
name|f
argument_list|,
literal|"_%s_strings_end - _%s_strings_start"
argument_list|,
name|symprefix
argument_list|,
name|symprefix
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vi
operator|->
name|flags
operator|&
name|FTF_STRUCTSIZE
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t/* size_dt_struct */\n"
argument_list|)
expr_stmt|;
name|ASM_EMIT_BELONG
argument_list|(
name|f
argument_list|,
literal|"_%s_struct_end - _%s_struct_start"
argument_list|,
name|symprefix
argument_list|,
name|symprefix
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Reserve map entries. 	 * Align the reserve map to a doubleword boundary. 	 * Each entry is an (address, size) pair of u64 values. 	 * Always supply a zero-sized temination entry. 	 */
name|asm_emit_align
argument_list|(
name|f
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|f
argument_list|,
name|symprefix
argument_list|,
literal|"reserve_map"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"/* Memory reserve map from source file */\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Use .long on high and low halfs of u64s to avoid .quad 	 * as it appears .quad isn't available in some assemblers. 	 */
for|for
control|(
name|re
operator|=
name|dti
operator|->
name|reservelist
init|;
name|re
condition|;
name|re
operator|=
name|re
operator|->
name|next
control|)
block|{
name|struct
name|label
modifier|*
name|l
decl_stmt|;
name|for_each_label
argument_list|(
argument|re->labels
argument_list|,
argument|l
argument_list|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.globl\t%s\n"
argument_list|,
name|l
operator|->
name|label
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s:\n"
argument_list|,
name|l
operator|->
name|label
argument_list|)
expr_stmt|;
block|}
name|ASM_EMIT_BELONG
argument_list|(
name|f
argument_list|,
literal|"0x%08x"
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|re
operator|->
name|re
operator|.
name|address
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_EMIT_BELONG
argument_list|(
name|f
argument_list|,
literal|"0x%08x"
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|re
operator|->
name|re
operator|.
name|address
operator|&
literal|0xffffffff
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_EMIT_BELONG
argument_list|(
name|f
argument_list|,
literal|"0x%08x"
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|re
operator|->
name|re
operator|.
name|size
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_EMIT_BELONG
argument_list|(
name|f
argument_list|,
literal|"0x%08x"
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|re
operator|->
name|re
operator|.
name|size
operator|&
literal|0xffffffff
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reservenum
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.long\t0, 0\n\t.long\t0, 0\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.long\t0, 0\n\t.long\t0, 0\n"
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|f
argument_list|,
name|symprefix
argument_list|,
literal|"struct_start"
argument_list|)
expr_stmt|;
name|flatten_tree
argument_list|(
name|dti
operator|->
name|dt
argument_list|,
operator|&
name|asm_emitter
argument_list|,
name|f
argument_list|,
operator|&
name|strbuf
argument_list|,
name|vi
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t/* FDT_END */\n"
argument_list|)
expr_stmt|;
name|asm_emit_cell
argument_list|(
name|f
argument_list|,
name|FDT_END
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|f
argument_list|,
name|symprefix
argument_list|,
literal|"struct_end"
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|f
argument_list|,
name|symprefix
argument_list|,
literal|"strings_start"
argument_list|)
expr_stmt|;
name|dump_stringtable_asm
argument_list|(
name|f
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|f
argument_list|,
name|symprefix
argument_list|,
literal|"strings_end"
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|f
argument_list|,
name|symprefix
argument_list|,
literal|"blob_end"
argument_list|)
expr_stmt|;
comment|/* 	 * If the user asked for more space than is used, pad it out. 	 */
if|if
condition|(
name|minsize
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.space\t%d - (_%s_blob_end - _%s_blob_start), 0\n"
argument_list|,
name|minsize
argument_list|,
name|symprefix
argument_list|,
name|symprefix
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|padsize
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.space\t%d, 0\n"
argument_list|,
name|padsize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alignsize
operator|>
literal|0
condition|)
name|asm_emit_align
argument_list|(
name|f
argument_list|,
name|alignsize
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|f
argument_list|,
name|symprefix
argument_list|,
literal|"blob_abs_end"
argument_list|)
expr_stmt|;
name|data_free
argument_list|(
name|strbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|inbuf
block|{
name|char
modifier|*
name|base
decl_stmt|,
modifier|*
name|limit
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|inbuf_init
parameter_list|(
name|struct
name|inbuf
modifier|*
name|inb
parameter_list|,
name|void
modifier|*
name|base
parameter_list|,
name|void
modifier|*
name|limit
parameter_list|)
block|{
name|inb
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|inb
operator|->
name|limit
operator|=
name|limit
expr_stmt|;
name|inb
operator|->
name|ptr
operator|=
name|inb
operator|->
name|base
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|flat_read_chunk
parameter_list|(
name|struct
name|inbuf
modifier|*
name|inb
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
operator|(
name|inb
operator|->
name|ptr
operator|+
name|len
operator|)
operator|>
name|inb
operator|->
name|limit
condition|)
name|die
argument_list|(
literal|"Premature end of data parsing flat device tree\n"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|inb
operator|->
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|inb
operator|->
name|ptr
operator|+=
name|len
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|flat_read_word
parameter_list|(
name|struct
name|inbuf
modifier|*
name|inb
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|assert
argument_list|(
operator|(
operator|(
name|inb
operator|->
name|ptr
operator|-
name|inb
operator|->
name|base
operator|)
operator|%
sizeof|sizeof
argument_list|(
name|val
argument_list|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|flat_read_chunk
argument_list|(
name|inb
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fdt32_to_cpu
argument_list|(
name|val
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|flat_realign
parameter_list|(
name|struct
name|inbuf
modifier|*
name|inb
parameter_list|,
name|int
name|align
parameter_list|)
block|{
name|int
name|off
init|=
name|inb
operator|->
name|ptr
operator|-
name|inb
operator|->
name|base
decl_stmt|;
name|inb
operator|->
name|ptr
operator|=
name|inb
operator|->
name|base
operator|+
name|ALIGN
argument_list|(
name|off
argument_list|,
name|align
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
operator|->
name|ptr
operator|>
name|inb
operator|->
name|limit
condition|)
name|die
argument_list|(
literal|"Premature end of data parsing flat device tree\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|flat_read_string
parameter_list|(
name|struct
name|inbuf
modifier|*
name|inb
parameter_list|)
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|inb
operator|->
name|ptr
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
do|do
block|{
if|if
condition|(
name|p
operator|>=
name|inb
operator|->
name|limit
condition|)
name|die
argument_list|(
literal|"Premature end of data parsing flat device tree\n"
argument_list|)
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
do|;
name|str
operator|=
name|xstrdup
argument_list|(
name|inb
operator|->
name|ptr
argument_list|)
expr_stmt|;
name|inb
operator|->
name|ptr
operator|+=
name|len
expr_stmt|;
name|flat_realign
argument_list|(
name|inb
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|data
name|flat_read_data
parameter_list|(
name|struct
name|inbuf
modifier|*
name|inb
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|data
name|d
init|=
name|empty_data
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|empty_data
return|;
name|d
operator|=
name|data_grow_for
argument_list|(
name|d
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|d
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|flat_read_chunk
argument_list|(
name|inb
argument_list|,
name|d
operator|.
name|val
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|flat_realign
argument_list|(
name|inb
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|flat_read_stringtable
parameter_list|(
name|struct
name|inbuf
modifier|*
name|inb
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|inb
operator|->
name|base
operator|+
name|offset
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|p
operator|>=
name|inb
operator|->
name|limit
operator|||
name|p
operator|<
name|inb
operator|->
name|base
condition|)
name|die
argument_list|(
literal|"String offset %d overruns string table\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
name|p
operator|++
expr_stmt|;
block|}
return|return
name|xstrdup
argument_list|(
name|inb
operator|->
name|base
operator|+
name|offset
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|property
modifier|*
name|flat_read_property
parameter_list|(
name|struct
name|inbuf
modifier|*
name|dtbuf
parameter_list|,
name|struct
name|inbuf
modifier|*
name|strbuf
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|uint32_t
name|proplen
decl_stmt|,
name|stroff
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|data
name|val
decl_stmt|;
name|proplen
operator|=
name|flat_read_word
argument_list|(
name|dtbuf
argument_list|)
expr_stmt|;
name|stroff
operator|=
name|flat_read_word
argument_list|(
name|dtbuf
argument_list|)
expr_stmt|;
name|name
operator|=
name|flat_read_stringtable
argument_list|(
name|strbuf
argument_list|,
name|stroff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|FTF_VARALIGN
operator|)
operator|&&
operator|(
name|proplen
operator|>=
literal|8
operator|)
condition|)
name|flat_realign
argument_list|(
name|dtbuf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|val
operator|=
name|flat_read_data
argument_list|(
name|dtbuf
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
return|return
name|build_property
argument_list|(
name|name
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|reserve_info
modifier|*
name|flat_read_mem_reserve
parameter_list|(
name|struct
name|inbuf
modifier|*
name|inb
parameter_list|)
block|{
name|struct
name|reserve_info
modifier|*
name|reservelist
init|=
name|NULL
decl_stmt|;
name|struct
name|reserve_info
modifier|*
name|new
decl_stmt|;
name|struct
name|fdt_reserve_entry
name|re
decl_stmt|;
comment|/* 	 * Each entry is a pair of u64 (addr, size) values for 4 cell_t's. 	 * List terminates at an entry with size equal to zero. 	 * 	 * First pass, count entries. 	 */
while|while
condition|(
literal|1
condition|)
block|{
name|flat_read_chunk
argument_list|(
name|inb
argument_list|,
operator|&
name|re
argument_list|,
sizeof|sizeof
argument_list|(
name|re
argument_list|)
argument_list|)
expr_stmt|;
name|re
operator|.
name|address
operator|=
name|fdt64_to_cpu
argument_list|(
name|re
operator|.
name|address
argument_list|)
expr_stmt|;
name|re
operator|.
name|size
operator|=
name|fdt64_to_cpu
argument_list|(
name|re
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|.
name|size
operator|==
literal|0
condition|)
break|break;
name|new
operator|=
name|build_reserve_entry
argument_list|(
name|re
operator|.
name|address
argument_list|,
name|re
operator|.
name|size
argument_list|)
expr_stmt|;
name|reservelist
operator|=
name|add_reserve_entry
argument_list|(
name|reservelist
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
return|return
name|reservelist
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|nodename_from_path
parameter_list|(
specifier|const
name|char
modifier|*
name|ppath
parameter_list|,
specifier|const
name|char
modifier|*
name|cpath
parameter_list|)
block|{
name|int
name|plen
decl_stmt|;
name|plen
operator|=
name|strlen
argument_list|(
name|ppath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strneq
argument_list|(
name|ppath
argument_list|,
name|cpath
argument_list|,
name|plen
argument_list|)
condition|)
name|die
argument_list|(
literal|"Path \"%s\" is not valid as a child of \"%s\"\n"
argument_list|,
name|cpath
argument_list|,
name|ppath
argument_list|)
expr_stmt|;
comment|/* root node is a special case */
if|if
condition|(
operator|!
name|streq
argument_list|(
name|ppath
argument_list|,
literal|"/"
argument_list|)
condition|)
name|plen
operator|++
expr_stmt|;
return|return
name|xstrdup
argument_list|(
name|cpath
operator|+
name|plen
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|node
modifier|*
name|unflatten_tree
parameter_list|(
name|struct
name|inbuf
modifier|*
name|dtbuf
parameter_list|,
name|struct
name|inbuf
modifier|*
name|strbuf
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_flatname
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|node
modifier|*
name|node
decl_stmt|;
name|char
modifier|*
name|flatname
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|node
operator|=
name|build_node
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|flatname
operator|=
name|flat_read_string
argument_list|(
name|dtbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FTF_FULLPATH
condition|)
name|node
operator|->
name|name
operator|=
name|nodename_from_path
argument_list|(
name|parent_flatname
argument_list|,
name|flatname
argument_list|)
expr_stmt|;
else|else
name|node
operator|->
name|name
operator|=
name|flatname
expr_stmt|;
do|do
block|{
name|struct
name|property
modifier|*
name|prop
decl_stmt|;
name|struct
name|node
modifier|*
name|child
decl_stmt|;
name|val
operator|=
name|flat_read_word
argument_list|(
name|dtbuf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|val
condition|)
block|{
case|case
name|FDT_PROP
case|:
if|if
condition|(
name|node
operator|->
name|children
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: Flat tree input has "
literal|"subnodes preceding a property.\n"
argument_list|)
expr_stmt|;
name|prop
operator|=
name|flat_read_property
argument_list|(
name|dtbuf
argument_list|,
name|strbuf
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|add_property
argument_list|(
name|node
argument_list|,
name|prop
argument_list|)
expr_stmt|;
break|break;
case|case
name|FDT_BEGIN_NODE
case|:
name|child
operator|=
name|unflatten_tree
argument_list|(
name|dtbuf
argument_list|,
name|strbuf
argument_list|,
name|flatname
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|add_child
argument_list|(
name|node
argument_list|,
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|FDT_END_NODE
case|:
break|break;
case|case
name|FDT_END
case|:
name|die
argument_list|(
literal|"Premature FDT_END in device tree blob\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FDT_NOP
case|:
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|FTF_NOPS
operator|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: NOP tag found in flat tree"
literal|" version<16\n"
argument_list|)
expr_stmt|;
comment|/* Ignore */
break|break;
default|default:
name|die
argument_list|(
literal|"Invalid opcode word %08x in device tree blob\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|val
operator|!=
name|FDT_END_NODE
condition|)
do|;
if|if
condition|(
name|node
operator|->
name|name
operator|!=
name|flatname
condition|)
block|{
name|free
argument_list|(
name|flatname
argument_list|)
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
end_function

begin_function
name|struct
name|dt_info
modifier|*
name|dt_from_blob
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|uint32_t
name|magic
decl_stmt|,
name|totalsize
decl_stmt|,
name|version
decl_stmt|,
name|size_dt
decl_stmt|,
name|boot_cpuid_phys
decl_stmt|;
name|uint32_t
name|off_dt
decl_stmt|,
name|off_str
decl_stmt|,
name|off_mem_rsvmap
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|char
modifier|*
name|blob
decl_stmt|;
name|struct
name|fdt_header
modifier|*
name|fdt
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|inbuf
name|dtbuf
decl_stmt|,
name|strbuf
decl_stmt|;
name|struct
name|inbuf
name|memresvbuf
decl_stmt|;
name|int
name|sizeleft
decl_stmt|;
name|struct
name|reserve_info
modifier|*
name|reservelist
decl_stmt|;
name|struct
name|node
modifier|*
name|tree
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|f
operator|=
name|srcfile_relative_open
argument_list|(
name|fname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rc
operator|=
name|fread
argument_list|(
operator|&
name|magic
argument_list|,
sizeof|sizeof
argument_list|(
name|magic
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
name|die
argument_list|(
literal|"Error reading DT blob magic number: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|1
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|f
argument_list|)
condition|)
name|die
argument_list|(
literal|"EOF reading DT blob magic number\n"
argument_list|)
expr_stmt|;
else|else
name|die
argument_list|(
literal|"Mysterious short read reading magic number\n"
argument_list|)
expr_stmt|;
block|}
name|magic
operator|=
name|fdt32_to_cpu
argument_list|(
name|magic
argument_list|)
expr_stmt|;
if|if
condition|(
name|magic
operator|!=
name|FDT_MAGIC
condition|)
name|die
argument_list|(
literal|"Blob has incorrect magic number\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|fread
argument_list|(
operator|&
name|totalsize
argument_list|,
sizeof|sizeof
argument_list|(
name|totalsize
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
name|die
argument_list|(
literal|"Error reading DT blob size: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|1
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|f
argument_list|)
condition|)
name|die
argument_list|(
literal|"EOF reading DT blob size\n"
argument_list|)
expr_stmt|;
else|else
name|die
argument_list|(
literal|"Mysterious short read reading blob size\n"
argument_list|)
expr_stmt|;
block|}
name|totalsize
operator|=
name|fdt32_to_cpu
argument_list|(
name|totalsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|totalsize
operator|<
name|FDT_V1_SIZE
condition|)
name|die
argument_list|(
literal|"DT blob size (%d) is too small\n"
argument_list|,
name|totalsize
argument_list|)
expr_stmt|;
name|blob
operator|=
name|xmalloc
argument_list|(
name|totalsize
argument_list|)
expr_stmt|;
name|fdt
operator|=
operator|(
expr|struct
name|fdt_header
operator|*
operator|)
name|blob
expr_stmt|;
name|fdt
operator|->
name|magic
operator|=
name|cpu_to_fdt32
argument_list|(
name|magic
argument_list|)
expr_stmt|;
name|fdt
operator|->
name|totalsize
operator|=
name|cpu_to_fdt32
argument_list|(
name|totalsize
argument_list|)
expr_stmt|;
name|sizeleft
operator|=
name|totalsize
operator|-
sizeof|sizeof
argument_list|(
name|magic
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|totalsize
argument_list|)
expr_stmt|;
name|p
operator|=
name|blob
operator|+
sizeof|sizeof
argument_list|(
name|magic
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|totalsize
argument_list|)
expr_stmt|;
while|while
condition|(
name|sizeleft
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|f
argument_list|)
condition|)
name|die
argument_list|(
literal|"EOF before reading %d bytes of DT blob\n"
argument_list|,
name|totalsize
argument_list|)
expr_stmt|;
name|rc
operator|=
name|fread
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|sizeleft
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
name|die
argument_list|(
literal|"Error reading DT blob: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sizeleft
operator|-=
name|rc
expr_stmt|;
name|p
operator|+=
name|rc
expr_stmt|;
block|}
name|off_dt
operator|=
name|fdt32_to_cpu
argument_list|(
name|fdt
operator|->
name|off_dt_struct
argument_list|)
expr_stmt|;
name|off_str
operator|=
name|fdt32_to_cpu
argument_list|(
name|fdt
operator|->
name|off_dt_strings
argument_list|)
expr_stmt|;
name|off_mem_rsvmap
operator|=
name|fdt32_to_cpu
argument_list|(
name|fdt
operator|->
name|off_mem_rsvmap
argument_list|)
expr_stmt|;
name|version
operator|=
name|fdt32_to_cpu
argument_list|(
name|fdt
operator|->
name|version
argument_list|)
expr_stmt|;
name|boot_cpuid_phys
operator|=
name|fdt32_to_cpu
argument_list|(
name|fdt
operator|->
name|boot_cpuid_phys
argument_list|)
expr_stmt|;
if|if
condition|(
name|off_mem_rsvmap
operator|>=
name|totalsize
condition|)
name|die
argument_list|(
literal|"Mem Reserve structure offset exceeds total size\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|off_dt
operator|>=
name|totalsize
condition|)
name|die
argument_list|(
literal|"DT structure offset exceeds total size\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|off_str
operator|>
name|totalsize
condition|)
name|die
argument_list|(
literal|"String table offset exceeds total size\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|>=
literal|3
condition|)
block|{
name|uint32_t
name|size_str
init|=
name|fdt32_to_cpu
argument_list|(
name|fdt
operator|->
name|size_dt_strings
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|off_str
operator|+
name|size_str
operator|<
name|off_str
operator|)
operator|||
operator|(
name|off_str
operator|+
name|size_str
operator|>
name|totalsize
operator|)
condition|)
name|die
argument_list|(
literal|"String table extends past total size\n"
argument_list|)
expr_stmt|;
name|inbuf_init
argument_list|(
operator|&
name|strbuf
argument_list|,
name|blob
operator|+
name|off_str
argument_list|,
name|blob
operator|+
name|off_str
operator|+
name|size_str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inbuf_init
argument_list|(
operator|&
name|strbuf
argument_list|,
name|blob
operator|+
name|off_str
argument_list|,
name|blob
operator|+
name|totalsize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|version
operator|>=
literal|17
condition|)
block|{
name|size_dt
operator|=
name|fdt32_to_cpu
argument_list|(
name|fdt
operator|->
name|size_dt_struct
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|off_dt
operator|+
name|size_dt
operator|<
name|off_dt
operator|)
operator|||
operator|(
name|off_dt
operator|+
name|size_dt
operator|>
name|totalsize
operator|)
condition|)
name|die
argument_list|(
literal|"Structure block extends past total size\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|version
operator|<
literal|16
condition|)
block|{
name|flags
operator||=
name|FTF_FULLPATH
operator||
name|FTF_NAMEPROPS
operator||
name|FTF_VARALIGN
expr_stmt|;
block|}
else|else
block|{
name|flags
operator||=
name|FTF_NOPS
expr_stmt|;
block|}
name|inbuf_init
argument_list|(
operator|&
name|memresvbuf
argument_list|,
name|blob
operator|+
name|off_mem_rsvmap
argument_list|,
name|blob
operator|+
name|totalsize
argument_list|)
expr_stmt|;
name|inbuf_init
argument_list|(
operator|&
name|dtbuf
argument_list|,
name|blob
operator|+
name|off_dt
argument_list|,
name|blob
operator|+
name|totalsize
argument_list|)
expr_stmt|;
name|reservelist
operator|=
name|flat_read_mem_reserve
argument_list|(
operator|&
name|memresvbuf
argument_list|)
expr_stmt|;
name|val
operator|=
name|flat_read_word
argument_list|(
operator|&
name|dtbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|FDT_BEGIN_NODE
condition|)
name|die
argument_list|(
literal|"Device tree blob doesn't begin with FDT_BEGIN_NODE (begins with 0x%08x)\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|tree
operator|=
name|unflatten_tree
argument_list|(
operator|&
name|dtbuf
argument_list|,
operator|&
name|strbuf
argument_list|,
literal|""
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|val
operator|=
name|flat_read_word
argument_list|(
operator|&
name|dtbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|FDT_END
condition|)
name|die
argument_list|(
literal|"Device tree blob doesn't end with FDT_END\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|blob
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
name|build_dt_info
argument_list|(
name|DTSF_V1
argument_list|,
name|reservelist
argument_list|,
name|tree
argument_list|,
name|boot_cpuid_phys
argument_list|)
return|;
block|}
end_function

end_unit

