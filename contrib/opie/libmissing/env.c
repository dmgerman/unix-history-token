begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* env.c: Replacement environment handling functions.  %%% portions-copyright-cmetz Portions of this software are Copyright 1996 by Craig Metz, All Rights Reserved. The Inner Net License Version 2 applies to these portions of the software. You should have received a copy of the license with this software. If you didn't get a copy, you may request one from<license@inner.net>.  Portions of this software are Copyright 1995 by Randall Atkinson and Dan McDonald, All Rights Reserved. All Rights under this copyright are assigned to the U.S. Naval Research Laboratory (NRL). The NRL Copyright Notice and License Agreement applies to this software.  	History:          Modified by cmetz for OPIE 2.2. Changed ifdefs for libmissing. 	     Combined all env functions and made _findenv static.              Including headers is a good idea, though. Add more headers. 	Modified at NRL for OPIE 2.0. 	Originally from BSD. */
end_comment

begin_comment
comment|/*  * Copyright (c) 1987 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_include
include|#
directive|include
file|"opie_cfg.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_if
if|#
directive|if
name|HAVE_UNISTD_H
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UNISTD_H */
end_comment

begin_if
if|#
directive|if
name|HAVE_STDLIB_H
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_include
include|#
directive|include
file|"opie.h"
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|_findenv
name|FUNCTION
argument_list|(
operator|(
name|name
operator|,
name|offset
operator|)
argument_list|,
specifier|register
name|char
operator|*
name|name
name|AND
name|int
operator|*
name|offset
argument_list|)
block|{
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|P
decl_stmt|,
modifier|*
name|C
decl_stmt|;
for|for
control|(
name|C
operator|=
name|name
operator|,
name|len
operator|=
literal|0
init|;
operator|*
name|C
operator|&&
operator|*
name|C
operator|!=
literal|'='
condition|;
operator|++
name|C
operator|,
operator|++
name|len
control|)
empty_stmt|;
for|for
control|(
name|P
operator|=
name|environ
init|;
operator|*
name|P
condition|;
operator|++
name|P
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|P
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
condition|)
if|if
condition|(
operator|*
operator|(
name|C
operator|=
operator|*
name|P
operator|+
name|len
operator|)
operator|==
literal|'='
condition|)
block|{
operator|*
name|offset
operator|=
name|P
operator|-
name|environ
expr_stmt|;
return|return
operator|(
operator|++
name|C
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|HAVE_GETENV
end_if

begin_decl_stmt
name|char
modifier|*
name|getenv
name|FUNCTION
argument_list|(
operator|(
name|name
operator|)
argument_list|,
name|char
operator|*
name|name
argument_list|)
block|{
name|int
name|offset
decl_stmt|;
name|char
modifier|*
name|_findenv
parameter_list|()
function_decl|;
return|return
operator|(
name|_findenv
argument_list|(
name|name
argument_list|,
operator|&
name|offset
argument_list|)
operator|)
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_GETENV */
end_comment

begin_if
if|#
directive|if
operator|!
name|HAVE_SETENV
end_if

begin_decl_stmt
name|int
name|setenv
name|FUNCTION
argument_list|(
operator|(
name|name
operator|,
name|value
operator|,
name|rewrite
operator|)
argument_list|,
name|char
operator|*
name|name
name|AND
name|char
operator|*
name|value
name|AND
name|int
name|rewrite
argument_list|)
block|{
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
specifier|static
name|int
name|alloced
decl_stmt|;
comment|/* if allocated space before */
specifier|register
name|char
modifier|*
name|C
decl_stmt|;
name|int
name|l_value
decl_stmt|,
name|offset
decl_stmt|;
if|if
condition|(
operator|*
name|value
operator|==
literal|'='
condition|)
comment|/* no `=' in value */
operator|++
name|value
expr_stmt|;
name|l_value
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|C
operator|=
name|_findenv
argument_list|(
name|name
argument_list|,
operator|&
name|offset
argument_list|)
operator|)
condition|)
block|{
comment|/* find if already exists */
if|if
condition|(
operator|!
name|rewrite
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|strlen
argument_list|(
name|C
argument_list|)
operator|>=
name|l_value
condition|)
block|{
comment|/* old larger; copy over */
while|while
condition|(
operator|*
name|C
operator|++
operator|=
operator|*
name|value
operator|++
condition|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* create new slot */
specifier|register
name|int
name|cnt
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|P
decl_stmt|;
for|for
control|(
name|P
operator|=
name|environ
operator|,
name|cnt
operator|=
literal|0
init|;
operator|*
name|P
condition|;
operator|++
name|P
operator|,
operator|++
name|cnt
control|)
empty_stmt|;
if|if
condition|(
name|alloced
condition|)
block|{
comment|/* just increase size */
name|environ
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|environ
argument_list|,
call|(
name|u_int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|cnt
operator|+
literal|2
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|environ
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* get new space */
name|alloced
operator|=
literal|1
expr_stmt|;
comment|/* copy old entries into it */
name|P
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|u_int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|cnt
operator|+
literal|2
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|P
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|strncpy
argument_list|(
name|P
argument_list|,
name|environ
argument_list|,
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|environ
operator|=
name|P
expr_stmt|;
block|}
name|environ
index|[
name|cnt
operator|+
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|offset
operator|=
name|cnt
expr_stmt|;
block|}
for|for
control|(
name|C
operator|=
name|name
init|;
operator|*
name|C
operator|&&
operator|*
name|C
operator|!=
literal|'='
condition|;
operator|++
name|C
control|)
empty_stmt|;
comment|/* no `=' in name */
if|if
condition|(
operator|!
operator|(
name|environ
index|[
name|offset
index|]
operator|=
comment|/* name + `=' + value */
name|malloc
argument_list|(
call|(
name|u_int
call|)
argument_list|(
call|(
name|int
call|)
argument_list|(
name|C
operator|-
name|name
argument_list|)
operator|+
name|l_value
operator|+
literal|2
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|C
operator|=
name|environ
index|[
name|offset
index|]
init|;
operator|(
operator|*
name|C
operator|=
operator|*
name|name
operator|++
operator|)
operator|&&
operator|*
name|C
operator|!=
literal|'='
condition|;
operator|++
name|C
control|)
empty_stmt|;
for|for
control|(
operator|*
name|C
operator|++
operator|=
literal|'='
init|;
operator|*
name|C
operator|++
operator|=
operator|*
name|value
operator|++
condition|;
control|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_SETENV */
end_comment

begin_if
if|#
directive|if
operator|!
name|HAVE_UNSETENV
end_if

begin_decl_stmt
name|VOIDRET
name|unsetenv
name|FUNCTION
argument_list|(
operator|(
name|name
operator|)
argument_list|,
name|char
operator|*
name|name
argument_list|)
block|{
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|P
decl_stmt|;
name|int
name|offset
decl_stmt|;
while|while
condition|(
name|_findenv
argument_list|(
name|name
argument_list|,
operator|&
name|offset
argument_list|)
condition|)
comment|/* if set multiple times */
for|for
control|(
name|P
operator|=
operator|&
name|environ
index|[
name|offset
index|]
init|;
condition|;
operator|++
name|P
control|)
if|if
condition|(
operator|!
operator|(
operator|*
name|P
operator|=
operator|*
operator|(
name|P
operator|+
literal|1
operator|)
operator|)
condition|)
break|break;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_UNSETENV */
end_comment

end_unit

