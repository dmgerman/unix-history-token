begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* popen.c: A "safe" pipe open routine.  %%% portions-copyright-cmetz-96 Portions of this software are Copyright 1996-1999 by Craig Metz, All Rights Reserved. The Inner Net License Version 2 applies to these portions of the software. You should have received a copy of the license with this software. If you didn't get a copy, you may request one from<license@inner.net>.  Portions of this software are Copyright 1995 by Randall Atkinson and Dan McDonald, All Rights Reserved. All Rights under this copyright are assigned to the U.S. Naval Research Laboratory (NRL). The NRL Copyright Notice and License Agreement applies to this software.  	History:  	Modified by cmetz for OPIE 2.31. Merged in some 4.4BSD-Lite fixes. 	Modified by cmetz for OPIE 2.2. Use FUNCTION declaration et al.                 Removed useless string. ifdef around some headers.         Modified at NRL for OPIE 2.1. Optimized for only one pipe at a time.                 Added minimal version of sigprocmask(). Moved some pid_t 		dancing to the config headers. 	Modified at NRL for OPIE 2.0. 	Originally from BSD.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1988, 1993, 1994  *     The Regents of the University of California.  All rights reserved.  *  * This code is derived from software written by Ken Arnold and  * published in UNIX Review, Vol. 6, No. 8.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by the University of  *      California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|"opie_cfg.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_if
if|#
directive|if
name|HAVE_SIGNAL_H
end_if

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SIGNAL_H */
end_comment

begin_if
if|#
directive|if
name|HAVE_SYS_SIGNAL_H
end_if

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_SIGNAL_H */
end_comment

begin_if
if|#
directive|if
name|HAVE_UNISTD_H
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UNISTD_H */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_if
if|#
directive|if
name|HAVE_STDLIB_H
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_if
if|#
directive|if
name|HAVE_STRING_H
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STRING_H */
end_comment

begin_include
include|#
directive|include
file|"opie.h"
end_include

begin_decl_stmt
name|char
modifier|*
modifier|*
name|ftpglob
name|__P
argument_list|(
operator|(
specifier|register
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|copyblk
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VOIDRET
name|blkfree
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Special version of popen which avoids call to shell.  This ensures noone  * may create a pipe to a hidden program as a side effect of a list or dir  * command.  */
end_comment

begin_decl_stmt
specifier|static
name|pid_t
name|child_pid
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pipe_fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|ftpd_popen
name|FUNCTION
argument_list|(
operator|(
name|program
operator|,
name|type
operator|)
argument_list|,
name|char
operator|*
name|program
name|AND
name|char
operator|*
name|type
argument_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|FILE
modifier|*
name|iop
decl_stmt|;
name|int
name|argc
decl_stmt|,
name|gargc
decl_stmt|,
name|pdes
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|pop
decl_stmt|,
modifier|*
name|argv
index|[
literal|100
index|]
decl_stmt|,
modifier|*
name|gargv
index|[
literal|1000
index|]
decl_stmt|,
modifier|*
name|vv
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|type
operator|!=
literal|'r'
operator|&&
operator|*
name|type
operator|!=
literal|'w'
operator|)
operator|||
name|type
index|[
literal|1
index|]
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|pipe
argument_list|(
name|pdes
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* break up string into pieces */
for|for
control|(
name|argc
operator|=
literal|0
operator|,
name|cp
operator|=
name|program
init|;
condition|;
name|cp
operator|=
name|NULL
control|)
if|if
condition|(
operator|!
operator|(
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|strtok
argument_list|(
name|cp
argument_list|,
literal|" \t\n"
argument_list|)
operator|)
condition|)
break|break;
comment|/* glob each piece */
name|gargv
index|[
literal|0
index|]
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|gargc
operator|=
name|argc
operator|=
literal|1
init|;
name|argv
index|[
name|argc
index|]
condition|;
name|argc
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|pop
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ftpglob
argument_list|(
name|argv
index|[
name|argc
index|]
argument_list|)
operator|)
condition|)
block|{
comment|/* globbing failed */
name|vv
index|[
literal|0
index|]
operator|=
name|argv
index|[
name|argc
index|]
expr_stmt|;
name|vv
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|pop
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|copyblk
argument_list|(
name|vv
argument_list|)
expr_stmt|;
block|}
name|argv
index|[
name|argc
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|pop
expr_stmt|;
comment|/* save to free later */
while|while
condition|(
operator|*
name|pop
operator|&&
name|gargc
operator|<
literal|1000
condition|)
name|gargv
index|[
name|gargc
operator|++
index|]
operator|=
operator|*
name|pop
operator|++
expr_stmt|;
block|}
name|gargv
index|[
name|gargc
index|]
operator|=
name|NULL
expr_stmt|;
name|iop
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|child_pid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* error */
name|close
argument_list|(
name|pdes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pdes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|pfree
goto|;
comment|/* NOTREACHED */
case|case
literal|0
case|:
comment|/* child */
if|if
condition|(
operator|*
name|type
operator|==
literal|'r'
condition|)
block|{
if|if
condition|(
name|pdes
index|[
literal|1
index|]
operator|!=
literal|1
condition|)
block|{
name|dup2
argument_list|(
name|pdes
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|pdes
index|[
literal|1
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* stderr, too! */
name|close
argument_list|(
name|pdes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|pdes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pdes
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|dup2
argument_list|(
name|pdes
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pdes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|pdes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|environ
operator|=
name|NULL
expr_stmt|;
name|execv
argument_list|(
name|gargv
index|[
literal|0
index|]
argument_list|,
name|gargv
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* parent; assume fdopen can't fail...  */
if|if
condition|(
operator|*
name|type
operator|==
literal|'r'
condition|)
block|{
name|iop
operator|=
name|fdopen
argument_list|(
name|pipe_fd
operator|=
name|pdes
index|[
literal|0
index|]
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pdes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iop
operator|=
name|fdopen
argument_list|(
name|pipe_fd
operator|=
name|pdes
index|[
literal|1
index|]
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pdes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|pfree
label|:
for|for
control|(
name|argc
operator|=
literal|1
init|;
name|argv
index|[
name|argc
index|]
operator|!=
name|NULL
condition|;
name|argc
operator|++
control|)
block|{
name|blkfree
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
name|argv
index|[
name|argc
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
index|[
name|argc
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|iop
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|ftpd_pclose
name|FUNCTION
argument_list|(
operator|(
name|iop
operator|)
argument_list|,
name|FILE
operator|*
name|iop
argument_list|)
block|{
name|int
name|status
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|sigset_t
name|omask
decl_stmt|,
name|mask
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|mask
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|mask
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|mask
argument_list|,
name|SIGQUIT
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|mask
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
comment|/* pclose returns -1 if stream is not associated with a `popened' command,      or, if already `pclosed'. */
if|if
condition|(
operator|(
name|child_pid
operator|<
literal|0
operator|)
operator|||
operator|(
name|fileno
argument_list|(
name|iop
argument_list|)
operator|!=
name|pipe_fd
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|fclose
argument_list|(
name|iop
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|mask
argument_list|,
operator|&
name|omask
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pid
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|!=
name|child_pid
operator|&&
operator|(
name|pid
operator|!=
operator|-
literal|1
operator|)
condition|)
empty_stmt|;
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|omask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|child_pid
operator|=
operator|-
literal|1
expr_stmt|;
name|pipe_fd
operator|=
operator|-
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|WEXITSTATUS
argument_list|)
operator|&&
name|defined
argument_list|(
name|WIFEXITED
argument_list|)
if|if
condition|(
operator|(
name|pid
operator|>
literal|0
operator|)
operator|&&
name|WIFEXITED
argument_list|(
name|status
argument_list|)
condition|)
return|return
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
return|;
return|return
operator|-
literal|1
return|;
else|#
directive|else
comment|/* defined(WEXITSTATUS)&& defined(WIFEXITED) */
return|return
operator|(
name|pid
operator|==
operator|-
literal|1
condition|?
operator|-
literal|1
else|:
name|status
operator|.
name|w_status
operator|)
return|;
endif|#
directive|endif
comment|/* defined(WEXITSTATUS)&& defined(WIFEXITED) */
block|}
end_decl_stmt

end_unit

