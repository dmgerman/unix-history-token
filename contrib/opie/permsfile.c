begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* permsfile.c: implement SunOS /etc/fbtab and Solaris /etc/logindevperm    functionality to set device permissions on login  %%% portions-copyright-cmetz-96 Portions of this software are Copyright 1996-1998 by Craig Metz, All Rights Reserved. The Inner Net License Version 2 applies to these portions of the software. You should have received a copy of the license with this software. If you didn't get a copy, you may request one from<license@inner.net>.  Portions of this software are Copyright 1995 by Randall Atkinson and Dan McDonald, All Rights Reserved. All Rights under this copyright are assigned to the U.S. Naval Research Laboratory (NRL). The NRL Copyright Notice and License Agreement applies to this software.  	History:  	Modified by cmetz for OPIE 2.31. Include unistd.h. 	Modified by cmetz for OPIE 2.3. Check for NULL return from 	    ftpglob(), combine some expressions, fix a typo. Made file 	    selection a bit more generic. 	Modified by cmetz for OPIE 2.2. Use FUNCTION declaration et al.             Add opie.h. Ifdef around a header. 	Written at NRL for OPIE 2.0. */
end_comment

begin_include
include|#
directive|include
file|"opie_cfg.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LOGIN_PERMFILE
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|HAVE_STRING_H
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STRING_H */
end_comment

begin_if
if|#
directive|if
name|HAVE_UNISTD_H
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UNISTD_H */
end_comment

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|"opie.h"
end_include

begin_comment
comment|/* Line buffer size (one more than max line length) */
end_comment

begin_define
define|#
directive|define
name|BUFSIZE
value|128
end_define

begin_comment
comment|/* Maximum number of list items in a field */
end_comment

begin_define
define|#
directive|define
name|LISTSIZE
value|10
end_define

begin_decl_stmt
specifier|static
name|char
name|buf
index|[
name|BUFSIZE
index|]
decl_stmt|,
name|buf2
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|ftpglob
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VOIDRET
name|opiefatal
name|FUNCTION
argument_list|(
operator|(
name|x
operator|)
argument_list|,
name|char
operator|*
name|x
argument_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_include
include|#
directive|include
file|"glob.c"
end_include

begin_decl_stmt
specifier|static
name|int
name|getalist
name|FUNCTION
argument_list|(
operator|(
name|string
operator|,
name|list
operator|)
argument_list|,
name|char
operator|*
operator|*
name|string
name|AND
name|char
operator|*
operator|*
name|list
argument_list|)
block|{
name|char
modifier|*
name|s
init|=
operator|*
name|string
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|' '
operator|)
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|'\t'
operator|)
condition|)
if|if
condition|(
operator|(
operator|*
name|s
operator|==
literal|':'
operator|)
operator|||
operator|(
operator|*
name|s
operator|==
literal|','
operator|)
condition|)
block|{
operator|*
operator|(
name|s
operator|++
operator|)
operator|=
literal|0
expr_stmt|;
name|list
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|string
expr_stmt|;
operator|*
name|string
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|LISTSIZE
condition|)
return|return
name|i
return|;
block|}
else|else
name|s
operator|++
expr_stmt|;
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|s
argument_list|)
operator|-
call|(
name|int
call|)
argument_list|(
operator|*
name|string
argument_list|)
condition|)
block|{
operator|*
name|s
operator|=
literal|0
expr_stmt|;
name|list
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|string
expr_stmt|;
block|}
operator|*
name|string
operator|=
operator|++
name|s
expr_stmt|;
return|return
name|i
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOIDRET
name|doaline
name|FUNCTION
argument_list|(
operator|(
name|line
operator|,
name|name
operator|,
name|ttyn
operator|,
name|uid
operator|,
name|gid
operator|)
argument_list|,
name|char
operator|*
name|line
name|AND
name|char
operator|*
name|name
name|AND
name|char
operator|*
name|ttyn
name|AND
name|uid_t
name|uid
name|AND
name|gid_t
name|gid
argument_list|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|applies
decl_stmt|,
name|llen
decl_stmt|;
name|char
modifier|*
name|listbuf
index|[
name|LISTSIZE
index|]
decl_stmt|,
modifier|*
modifier|*
name|globlist
decl_stmt|;
if|if
condition|(
name|ptr
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'#'
argument_list|)
condition|)
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
comment|/* Skip whitespace */
for|for
control|(
name|ptr
operator|=
name|buf
init|;
operator|*
name|ptr
operator|&&
operator|(
operator|(
operator|*
name|ptr
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|ptr
operator|==
literal|'\t'
operator|)
operator|)
condition|;
name|ptr
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|ptr
condition|)
return|return;
comment|/* (Optional) Field 1: user name(s) */
if|if
condition|(
operator|(
operator|*
name|ptr
operator|!=
literal|'/'
operator|)
operator|&&
operator|(
operator|*
name|ptr
operator|!=
literal|'~'
operator|)
condition|)
block|{
name|llen
operator|=
name|getalist
argument_list|(
operator|&
name|ptr
argument_list|,
name|listbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|applies
operator|=
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|llen
operator|)
operator|&&
operator|!
name|applies
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|listbuf
index|[
name|i
index|]
argument_list|,
name|name
argument_list|)
condition|)
name|applies
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|&&
operator|(
operator|(
operator|*
name|ptr
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|ptr
operator|==
literal|'\t'
operator|)
operator|)
condition|)
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|applies
operator|||
operator|!
operator|*
name|ptr
condition|)
return|return;
block|}
comment|/* Field 2: terminal(s) */
name|llen
operator|=
name|getalist
argument_list|(
operator|&
name|ptr
argument_list|,
name|listbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|applies
operator|=
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|llen
operator|)
operator|&&
operator|!
name|applies
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|listbuf
index|[
name|i
index|]
argument_list|,
name|ttyn
argument_list|)
condition|)
name|applies
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|&&
operator|(
operator|(
operator|*
name|ptr
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|ptr
operator|==
literal|'\t'
operator|)
operator|)
condition|)
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|applies
operator|||
operator|!
operator|*
name|ptr
condition|)
return|return;
comment|/* Field 3: mode */
for|for
control|(
name|applies
operator|=
literal|0
init|;
operator|*
name|ptr
operator|&&
operator|(
operator|*
name|ptr
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|ptr
operator|<=
literal|'7'
operator|)
condition|;
name|applies
operator|=
operator|(
name|applies
operator|<<
literal|3
operator|)
operator||
operator|(
operator|*
operator|(
name|ptr
operator|++
operator|)
operator|-
literal|'0'
operator|)
control|)
empty_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|&&
operator|(
operator|(
operator|*
name|ptr
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|ptr
operator|==
literal|'\t'
operator|)
operator|)
condition|)
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|ptr
condition|)
return|return;
comment|/* Field 4: devices (the fun part...) */
name|llen
operator|=
name|getalist
argument_list|(
operator|&
name|ptr
argument_list|,
name|listbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|llen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|globlist
operator|=
name|ftpglob
argument_list|(
name|listbuf
index|[
name|i
index|]
argument_list|)
condition|)
while|while
condition|(
operator|*
name|globlist
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"setting %s to %d/%d %o"
argument_list|,
operator|*
name|globlist
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|,
name|applies
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
operator|(
name|chown
argument_list|(
operator|*
name|globlist
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|)
operator|<
literal|0
operator|)
operator|&&
operator|(
name|errno
operator|!=
name|ENOENT
operator|)
condition|)
name|perror
argument_list|(
literal|"chown"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chmod
argument_list|(
operator|*
operator|(
name|globlist
operator|++
operator|)
argument_list|,
name|applies
argument_list|)
operator|<
literal|0
operator|)
operator|&&
operator|(
name|errno
operator|!=
name|ENOENT
operator|)
condition|)
name|perror
argument_list|(
literal|"chmod"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_decl_stmt
name|VOIDRET
name|permsfile
name|FUNCTION
argument_list|(
operator|(
name|name
operator|,
name|ttyn
operator|,
name|uid
operator|,
name|gid
operator|)
argument_list|,
name|char
operator|*
name|name
name|AND
name|char
operator|*
name|ttyn
name|AND
name|uid_t
name|uid
name|AND
name|gid_t
name|gid
argument_list|)
block|{
name|FILE
modifier|*
name|fh
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|fh
operator|=
name|fopen
argument_list|(
name|HAVE_LOGIN_PERMFILE
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't open %s!"
argument_list|,
name|HAVE_LOGIN_PERMFILE
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: Can't set device permissions.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
do|do
block|{
if|if
condition|(
name|feof
argument_list|(
name|fh
argument_list|)
condition|)
return|return;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|BUFSIZE
argument_list|,
name|fh
argument_list|)
operator|==
name|NULL
condition|)
return|return;
name|buf
index|[
name|BUFSIZE
index|]
operator|=
literal|0
expr_stmt|;
name|doaline
argument_list|(
name|buf
argument_list|,
name|name
argument_list|,
name|ttyn
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LOGIN_PERMFILE */
end_comment

end_unit

