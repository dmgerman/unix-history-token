begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* unlock.c: The opieunlock() library function.  %%% portions-copyright-cmetz Portions of this software are Copyright 1996 by Craig Metz, All Rights Reserved. The Inner Net License Version 2 applies to these portions of the software. You should have received a copy of the license with this software. If you didn't get a copy, you may request one from<license@inner.net>.  Portions of this software are Copyright 1995 by Randall Atkinson and Dan McDonald, All Rights Reserved. All Rights under this copyright are assigned to the U.S. Naval Research Laboratory (NRL). The NRL Copyright Notice and License Agreement applies to this software.          History:  	Modified by cmetz for OPIE 2.3. Do refcounts whether or not             we actually lock. Fixed USER_LOCKING=0 case. 	Modified by cmetz for OPIE 2.22. Added reference count support. 	    Changed lock filename/refcount symbol names to better indicate 	    that they're not user serviceable. 	Modified by cmetz for OPIE 2.2. Use FUNCTION declaration.             Check for read() == -1. ifdef around unistd.h.         Created at NRL for OPIE 2.2 from opiesubr2.c */
end_comment

begin_include
include|#
directive|include
file|"opie_cfg.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_if
if|#
directive|if
name|HAVE_UNISTD_H
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UNISTD_H */
end_comment

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"opie.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|__opie_lockrefcount
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|USER_LOCKING
end_if

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|__opie_lockfilename
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USER_LOCKING */
end_comment

begin_comment
comment|/*    Just remove the lock, right?   Well, not exactly -- we need to make sure it's ours.  */
end_comment

begin_decl_stmt
name|int
name|opieunlock
name|FUNCTION_NOARGS
block|{
if|#
directive|if
name|USER_LOCKING
name|int
name|fh
decl_stmt|,
name|rval
init|=
operator|-
literal|1
decl_stmt|,
name|pid
decl_stmt|,
name|t
decl_stmt|,
name|i
decl_stmt|;
name|char
name|buffer
index|[
literal|128
index|]
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|c2
decl_stmt|;
if|if
condition|(
operator|--
name|__opie_lockrefcount
operator|>
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|__opie_lockfilename
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
operator|(
name|fh
operator|=
name|open
argument_list|(
name|__opie_lockfilename
argument_list|,
name|O_RDWR
argument_list|,
literal|0600
argument_list|)
operator|)
condition|)
goto|goto
name|unlockret
goto|;
if|if
condition|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|fh
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|unlockret
goto|;
name|buffer
index|[
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|buffer
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|=
name|strchr
argument_list|(
name|buffer
argument_list|,
literal|'\n'
argument_list|)
operator|)
condition|)
goto|goto
name|unlockret
goto|;
operator|*
operator|(
name|c
operator|++
operator|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c2
operator|=
name|strchr
argument_list|(
name|c
argument_list|,
literal|'\n'
argument_list|)
operator|)
condition|)
goto|goto
name|unlockret
goto|;
operator|*
operator|(
name|c2
operator|++
operator|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pid
operator|=
name|atoi
argument_list|(
name|buffer
argument_list|)
operator|)
condition|)
goto|goto
name|unlockret
goto|;
if|if
condition|(
operator|!
operator|(
name|t
operator|=
name|atoi
argument_list|(
name|c
argument_list|)
operator|)
condition|)
goto|goto
name|unlockret
goto|;
if|if
condition|(
operator|(
name|pid
operator|!=
name|getpid
argument_list|()
operator|)
operator|&&
operator|(
name|time
argument_list|(
name|NULL
argument_list|)
operator|+
name|OPIE_LOCK_TIMEOUT
operator|<=
name|t
operator|)
operator|&&
operator|(
operator|!
name|kill
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|rval
operator|=
literal|1
expr_stmt|;
goto|goto
name|unlockret1
goto|;
block|}
name|rval
operator|=
literal|0
expr_stmt|;
name|unlockret
label|:
name|unlink
argument_list|(
name|__opie_lockfilename
argument_list|)
expr_stmt|;
name|unlockret1
label|:
if|if
condition|(
name|fh
condition|)
name|close
argument_list|(
name|fh
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|__opie_lockfilename
argument_list|)
expr_stmt|;
name|__opie_lockfilename
operator|=
name|NULL
expr_stmt|;
return|return
name|rval
return|;
else|#
directive|else
comment|/* USER_LOCKING */
if|if
condition|(
name|__opie_lockrefcount
operator|--
operator|>
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
comment|/* USER_LOCKING */
block|}
end_decl_stmt

end_unit

