begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* lock.c: The opielock() library function.  %%% portions-copyright-cmetz-96 Portions of this software are Copyright 1996-1999 by Craig Metz, All Rights Reserved. The Inner Net License Version 2 applies to these portions of the software. You should have received a copy of the license with this software. If you didn't get a copy, you may request one from<license@inner.net>.  Portions of this software are Copyright 1995 by Randall Atkinson and Dan McDonald, All Rights Reserved. All Rights under this copyright are assigned to the U.S. Naval Research Laboratory (NRL). The NRL Copyright Notice and License Agreement applies to this software.          History:  	Modified by cmetz for OPIE 2.4. Use snprintf. 	Modified by cmetz for OPIE 2.31. Put locks in a separate dir.             Bug fixes. 	Modified by cmetz for OPIE 2.3. Do refcounts whether or not we             actually lock. Fixed USER_LOCKING=0 case. 	Modified by cmetz for OPIE 2.22. Added reference count for locks. 	    Changed lock filename/refcount symbol names to better indicate 	    that they're not user serviceable. 	Modified by cmetz for OPIE 2.2. Use FUNCTION declaration et al.             Use "principal" instead of "name" to make it clearer.             Ifdef around some headers, be more careful about allowed             error return values. Check open() return value properly.             Avoid NULL.         Created at NRL for OPIE 2.2 from opiesubr2.c */
end_comment

begin_include
include|#
directive|include
file|"opie_cfg.h"
end_include

begin_if
if|#
directive|if
name|HAVE_STRING_H
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STRING_H */
end_comment

begin_if
if|#
directive|if
name|HAVE_UNISTD_H
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UNISTD_H */
end_comment

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_if
if|#
directive|if
name|HAVE_STDLIB_H
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"opie.h"
end_include

begin_if
if|#
directive|if
operator|!
name|HAVE_LSTAT
end_if

begin_define
define|#
directive|define
name|lstat
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|stat(x, y)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_LSTAT */
end_comment

begin_decl_stmt
name|int
name|__opie_lockrefcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|USER_LOCKING
end_if

begin_decl_stmt
name|char
modifier|*
name|__opie_lockfilename
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* atexit() handler for opielock() */
end_comment

begin_decl_stmt
specifier|static
name|VOIDRET
name|opieunlockaeh
name|FUNCTION_NOARGS
block|{
if|if
condition|(
name|__opie_lockfilename
condition|)
block|{
name|__opie_lockrefcount
operator|=
literal|0
expr_stmt|;
name|opieunlock
argument_list|()
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USER_LOCKING */
end_comment

begin_comment
comment|/*     Serialize (we hope) authentication of user to prevent race conditions.    Creates a lock file with a name of OPIE_LOCK_PREFIX with the user name    appended. This file contains the pid of the lock's owner and a time()    stamp. We use the former to check for dead owners and the latter to    provide an upper bound on the lock duration. If there are any problems,    we assume the lock is bogus.     The value of this locking and its security implications are still not    completely clear and require further study.     One could conceivably hack this facility to provide locking of user    accounts after several authentication failures.      Return -1 on low-level error, 0 if ok, 1 on locking failure. */
end_comment

begin_decl_stmt
name|int
name|opielock
name|FUNCTION
argument_list|(
operator|(
name|principal
operator|)
argument_list|,
name|char
operator|*
name|principal
argument_list|)
block|{
if|#
directive|if
name|USER_LOCKING
name|int
name|fh
decl_stmt|,
name|waits
init|=
literal|0
decl_stmt|,
name|rval
init|=
operator|-
literal|1
decl_stmt|,
name|pid
decl_stmt|,
name|t
decl_stmt|,
name|i
decl_stmt|;
name|char
name|buffer
index|[
literal|128
index|]
decl_stmt|,
name|buffer2
index|[
literal|128
index|]
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|c2
decl_stmt|;
name|struct
name|stat
name|statbuf
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|getuid
argument_list|()
operator|&&
name|geteuid
argument_list|()
condition|)
block|{
if|#
directive|if
name|DEBUG
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"opielock: requires superuser priveleges"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
operator|-
literal|1
return|;
block|}
empty_stmt|;
if|if
condition|(
name|__opie_lockfilename
condition|)
block|{
name|__opie_lockrefcount
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|__opie_lockfilename
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|OPIE_LOCK_DIR
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|principal
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|strcpy
argument_list|(
name|__opie_lockfilename
argument_list|,
name|OPIE_LOCK_DIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|__opie_lockfilename
argument_list|,
literal|0700
argument_list|)
operator|<
literal|0
condition|)
if|if
condition|(
name|errno
operator|!=
name|EEXIST
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|lstat
argument_list|(
name|__opie_lockfilename
argument_list|,
operator|&
name|statbuf
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|statbuf
index|[
literal|0
index|]
operator|.
name|st_uid
condition|)
block|{
if|#
directive|if
name|DEBUG
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"opielock: %s isn't owned by the superuser."
argument_list|,
name|__opie_lockfilename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
operator|-
literal|1
return|;
block|}
empty_stmt|;
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|statbuf
index|[
literal|0
index|]
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|#
directive|if
name|DEBUG
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"opielock: %s isn't a directory."
argument_list|,
name|__opie_lockfilename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
operator|-
literal|1
return|;
block|}
empty_stmt|;
if|if
condition|(
operator|(
name|statbuf
index|[
literal|0
index|]
operator|.
name|st_mode
operator|&
literal|0777
operator|)
operator|!=
literal|00700
condition|)
block|{
if|#
directive|if
name|DEBUG
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"opielock: permissions on %s are not correct."
argument_list|,
name|__opie_lockfilename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
operator|-
literal|1
return|;
block|}
empty_stmt|;
name|strcat
argument_list|(
name|__opie_lockfilename
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|__opie_lockfilename
argument_list|,
name|principal
argument_list|)
expr_stmt|;
name|fh
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|fh
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|lstat
argument_list|(
name|__opie_lockfilename
argument_list|,
operator|&
name|statbuf
index|[
literal|0
index|]
argument_list|)
condition|)
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|statbuf
index|[
literal|0
index|]
operator|.
name|st_mode
argument_list|)
condition|)
goto|goto
name|lockret
goto|;
if|if
condition|(
operator|(
name|fh
operator|=
name|open
argument_list|(
name|__opie_lockfilename
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
literal|0600
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|lstat
argument_list|(
name|__opie_lockfilename
argument_list|,
operator|&
name|statbuf
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|lockret
goto|;
if|if
condition|(
name|statbuf
index|[
literal|0
index|]
operator|.
name|st_ino
operator|!=
name|statbuf
index|[
literal|1
index|]
operator|.
name|st_ino
condition|)
goto|goto
name|lockret
goto|;
if|if
condition|(
name|statbuf
index|[
literal|0
index|]
operator|.
name|st_mode
operator|!=
name|statbuf
index|[
literal|1
index|]
operator|.
name|st_mode
condition|)
goto|goto
name|lockret
goto|;
if|if
condition|(
operator|(
name|fh
operator|=
name|open
argument_list|(
name|__opie_lockfilename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0600
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|lockret
goto|;
if|if
condition|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|fh
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
operator|)
operator|<=
literal|0
condition|)
goto|goto
name|lockret
goto|;
name|buffer
index|[
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|buffer
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|=
name|strchr
argument_list|(
name|buffer
argument_list|,
literal|'\n'
argument_list|)
operator|)
condition|)
break|break;
operator|*
operator|(
name|c
operator|++
operator|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c2
operator|=
name|strchr
argument_list|(
name|c
argument_list|,
literal|'\n'
argument_list|)
operator|)
condition|)
break|break;
operator|*
operator|(
name|c2
operator|++
operator|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pid
operator|=
name|atoi
argument_list|(
name|buffer
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|t
operator|=
name|atoi
argument_list|(
name|c
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|t
operator|+
name|OPIE_LOCK_TIMEOUT
operator|)
operator|<
name|time
argument_list|(
literal|0
argument_list|)
condition|)
break|break;
if|if
condition|(
name|kill
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
name|close
argument_list|(
name|fh
argument_list|)
expr_stmt|;
name|fh
operator|=
literal|0
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|waits
operator|++
operator|>
literal|3
condition|)
block|{
name|rval
operator|=
literal|1
expr_stmt|;
goto|goto
name|lockret
goto|;
block|}
empty_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|__opie_lockfilename
argument_list|,
operator|&
name|statbuf
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|lockret
goto|;
if|if
condition|(
name|fstat
argument_list|(
name|fh
argument_list|,
operator|&
name|statbuf
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|lockret
goto|;
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|statbuf
index|[
literal|0
index|]
operator|.
name|st_mode
argument_list|)
operator|||
operator|(
name|statbuf
index|[
literal|0
index|]
operator|.
name|st_mode
operator|!=
name|statbuf
index|[
literal|1
index|]
operator|.
name|st_mode
operator|)
operator|||
operator|(
name|statbuf
index|[
literal|0
index|]
operator|.
name|st_ino
operator|!=
name|statbuf
index|[
literal|1
index|]
operator|.
name|st_ino
operator|)
condition|)
goto|goto
name|lockret
goto|;
if|if
condition|(
name|snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%d\n%d\n"
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|time
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
condition|)
goto|goto
name|lockret
goto|;
name|i
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fh
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|fh
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|__opie_lockfilename
argument_list|)
expr_stmt|;
name|fh
operator|=
literal|0
expr_stmt|;
goto|goto
name|lockret
goto|;
block|}
empty_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fh
argument_list|,
name|buffer
argument_list|,
name|i
argument_list|)
operator|!=
name|i
condition|)
block|{
name|close
argument_list|(
name|fh
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|__opie_lockfilename
argument_list|)
expr_stmt|;
name|fh
operator|=
literal|0
expr_stmt|;
goto|goto
name|lockret
goto|;
block|}
empty_stmt|;
name|close
argument_list|(
name|fh
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fh
operator|=
name|open
argument_list|(
name|__opie_lockfilename
argument_list|,
name|O_RDWR
argument_list|,
literal|0600
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|unlink
argument_list|(
name|__opie_lockfilename
argument_list|)
expr_stmt|;
goto|goto
name|lockret
goto|;
block|}
empty_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fh
argument_list|,
name|buffer2
argument_list|,
name|i
argument_list|)
operator|!=
name|i
condition|)
block|{
name|close
argument_list|(
name|fh
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|__opie_lockfilename
argument_list|)
expr_stmt|;
name|fh
operator|=
literal|0
expr_stmt|;
goto|goto
name|lockret
goto|;
block|}
empty_stmt|;
name|close
argument_list|(
name|fh
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|buffer
argument_list|,
name|buffer2
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|unlink
argument_list|(
name|__opie_lockfilename
argument_list|)
expr_stmt|;
goto|goto
name|lockret
goto|;
block|}
empty_stmt|;
name|__opie_lockrefcount
operator|++
expr_stmt|;
name|rval
operator|=
literal|0
expr_stmt|;
name|atexit
argument_list|(
name|opieunlockaeh
argument_list|)
expr_stmt|;
name|lockret
label|:
if|if
condition|(
name|fh
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|fh
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|__opie_lockrefcount
condition|)
block|{
name|free
argument_list|(
name|__opie_lockfilename
argument_list|)
expr_stmt|;
name|__opie_lockfilename
operator|=
name|NULL
expr_stmt|;
block|}
empty_stmt|;
return|return
name|rval
return|;
else|#
directive|else
comment|/* USER_LOCKING */
name|__opie_lockrefcount
operator|++
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* USER_LOCKING */
block|}
end_decl_stmt

end_unit

