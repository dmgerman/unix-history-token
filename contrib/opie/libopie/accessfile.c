begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* accessfile.c: Handle trusted network access file and per-user          overrides.  %%% portions-copyright-cmetz-96 Portions of this software are Copyright 1996-1997 by Craig Metz, All Rights Reserved. The Inner Net License Version 2 applies to these portions of the software. You should have received a copy of the license with this software. If you didn't get a copy, you may request one from<license@inner.net>.  Portions of this software are Copyright 1995 by Randall Atkinson and Dan McDonald, All Rights Reserved. All Rights under this copyright are assigned to the U.S. Naval Research Laboratory (NRL). The NRL Copyright Notice and License Agreement applies to this software.  	History:  	Modified by cmetz for OPIE 2.31. Include syslog.h on debug. 	Modified by cmetz for OPIE 2.3. Send debug info to syslog. 	Modified by cmetz for OPIE 2.2. Use FUNCTION declaration et al.                 Ifdef around some headers. Remove extra semicolon.         Modified at NRL for OPIE 2.2. Moved from accessfile.c to                 libopie/opieaccessfile.c. 	Modified at NRL for OPIE 2.0. 	Written at Bellcore for the S/Key Version 1 software distribution 		(login.c). */
end_comment

begin_include
include|#
directive|include
file|"opie_cfg.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_if
if|#
directive|if
name|HAVE_STRING_H
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STRING_H */
end_comment

begin_if
if|#
directive|if
name|HAVE_UNISTD_H
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UNISTD_H */
end_comment

begin_if
if|#
directive|if
name|HAVE_STDLIB_H
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_include
include|#
directive|include
file|"opie.h"
end_include

begin_decl_stmt
name|int
name|opieaccessfile
name|FUNCTION
argument_list|(
operator|(
name|host
operator|)
argument_list|,
name|char
operator|*
name|host
argument_list|)
block|{
ifdef|#
directive|ifdef
name|PATH_ACCESS_FILE
comment|/* Turn host into an IP address and then look it up in the authorization  * database to determine if ordinary password logins are OK  */
name|long
name|n
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|,
modifier|*
modifier|*
name|lp
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"accessfile: host=%s"
argument_list|,
name|host
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
operator|!
name|host
index|[
literal|0
index|]
condition|)
comment|/* Local login, okay */
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|isaddr
argument_list|(
name|host
argument_list|)
condition|)
block|{
name|n
operator|=
name|inet_addr
argument_list|(
name|host
argument_list|)
expr_stmt|;
return|return
name|rdnets
argument_list|(
name|n
argument_list|)
return|;
block|}
else|else
block|{
name|hp
operator|=
name|gethostbyname
argument_list|(
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hp
condition|)
block|{
name|printf
argument_list|(
literal|"Unknown host %s\n"
argument_list|,
name|host
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|lp
operator|=
name|hp
operator|->
name|h_addr_list
init|;
operator|*
name|lp
condition|;
name|lp
operator|++
control|)
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|n
argument_list|,
operator|*
name|lp
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdnets
argument_list|(
name|n
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|rdnets
name|FUNCTION
argument_list|(
operator|(
name|host
operator|)
argument_list|,
name|long
name|host
argument_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|long
name|pattern
decl_stmt|,
name|mask
decl_stmt|;
name|int
name|permit_it
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|PATH_ACCESS_FILE
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|,
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
continue|continue;
comment|/* Comment */
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
name|strtok
argument_list|(
name|buf
argument_list|,
literal|" \t"
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* two choices permit of deny */
if|if
condition|(
name|strncasecmp
argument_list|(
name|cp
argument_list|,
literal|"permit"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|permit_it
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strncasecmp
argument_list|(
name|cp
argument_list|,
literal|"deny"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|permit_it
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
continue|continue;
comment|/* ignore; it is not permit/deny */
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" \t"
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* Invalid line */
name|pattern
operator|=
name|inet_addr
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" \t"
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* Invalid line */
name|mask
operator|=
name|inet_addr
argument_list|(
name|cp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"accessfile: %08x& %08x == %08x (%s)"
argument_list|,
name|host
argument_list|,
name|mask
argument_list|,
name|pattern
argument_list|,
operator|(
operator|(
name|host
operator|&
name|mask
operator|)
operator|==
name|pattern
operator|)
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
operator|(
name|host
operator|&
name|mask
operator|)
operator|==
name|pattern
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|permit_it
return|;
block|}
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Return TRUE if string appears to be an IP address in dotted decimal;  * return FALSE otherwise (i.e., if string is a domain name)  */
end_comment

begin_decl_stmt
name|int
name|isaddr
name|FUNCTION
argument_list|(
operator|(
name|s
operator|)
argument_list|,
specifier|register
name|char
operator|*
name|s
argument_list|)
block|{
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return
literal|1
return|;
comment|/* Can't happen */
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'['
operator|&&
name|c
operator|!=
literal|']'
operator|&&
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'.'
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
else|#
directive|else
comment|/* PATH_ACCESS_FILE */
return|return
operator|!
name|host
index|[
literal|0
index|]
return|;
endif|#
directive|endif
comment|/* PATH_ACCESS_FILE */
block|}
end_decl_stmt

begin_comment
comment|/* Returns the opposite of what you might expect */
end_comment

begin_comment
comment|/* Returns 1 on error (allow)... this might not be what you want */
end_comment

begin_decl_stmt
name|int
name|opiealways
name|FUNCTION
argument_list|(
operator|(
name|homedir
operator|)
argument_list|,
name|char
operator|*
name|homedir
argument_list|)
block|{
name|char
modifier|*
name|opiealwayspath
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|homedir
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
operator|(
name|opiealwayspath
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|homedir
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|OPIE_ALWAYS_FILE
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
name|strcpy
argument_list|(
name|opiealwayspath
argument_list|,
name|homedir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|opiealwayspath
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|opiealwayspath
argument_list|,
name|OPIE_ALWAYS_FILE
argument_list|)
expr_stmt|;
name|i
operator|=
name|access
argument_list|(
name|opiealwayspath
argument_list|,
name|F_OK
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|opiealwayspath
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_decl_stmt

end_unit

