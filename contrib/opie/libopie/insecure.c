begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* insecure.c: The opieinsecure() library function.  %%% portions-copyright-cmetz-96 Portions of this software are Copyright 1996-1999 by Craig Metz, All Rights Reserved. The Inner Net License Version 2 applies to these portions of the software. You should have received a copy of the license with this software. If you didn't get a copy, you may request one from<license@inner.net>.  Portions of this software are Copyright 1995 by Randall Atkinson and Dan McDonald, All Rights Reserved. All Rights under this copyright are assigned to the U.S. Naval Research Laboratory (NRL). The NRL Copyright Notice and License Agreement applies to this software.          History:  	Modified by cmetz for OPIE 2.4. Do utmp checks on utmpx systems. 	     Handle unterminated ut_host. 	Modified by cmetz for OPIE 2.31. Fixed a logic bug. Call endut[x]ent(). 	Modified by cmetz for OPIE 2.3. Added result caching. Use 	     __opiegetutmpentry(). Ifdef around ut_host check. Eliminate 	     unused variable. 	Modified by cmetz for OPIE 2.2. Use FUNCTION declaration et al.              Allow IP loopback. DISPLAY and ut_host must match exactly,              not just the part before the colon. Added work-around for               Sun CDE dtterm bug. Leave the environment as it was              found. Use uname().         Created at NRL for OPIE 2.2 from opiesubr.c. Fixed pointer              assignment that should have been a comparison. */
end_comment

begin_include
include|#
directive|include
file|"opie_cfg.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* ANSI C standard library */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_if
if|#
directive|if
name|DOUTMPX
end_if

begin_include
include|#
directive|include
file|<utmpx.h>
end_include

begin_define
define|#
directive|define
name|utmp
value|utmpx
end_define

begin_define
define|#
directive|define
name|endutent
value|endutxent
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DOUTMPX */
end_comment

begin_if
if|#
directive|if
name|HAVE_SYS_UTSNAME_H
end_if

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_UTSNAME_H */
end_comment

begin_include
include|#
directive|include
file|"opie.h"
end_include

begin_decl_stmt
name|char
modifier|*
name|remote_terms
index|[]
init|=
block|{
literal|"xterm"
block|,
literal|"xterms"
block|,
literal|"kterm"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|opieinsecure
name|FUNCTION_NOARGS
block|{
ifndef|#
directive|ifndef
name|NO_INSECURE_CHECK
name|char
modifier|*
name|display_name
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|term_name
decl_stmt|;
name|int
name|insecure
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|HAVE_UT_HOST
operator|||
name|DOUTMPX
name|struct
name|utmp
name|utmp
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_UT_HOST || DOUTMPX */
specifier|static
name|int
name|result
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|result
operator|!=
operator|-
literal|1
condition|)
return|return
name|result
return|;
name|display_name
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"DISPLAY"
argument_list|)
expr_stmt|;
name|term_name
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|display_name
condition|)
block|{
name|insecure
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|s
operator|=
name|strchr
argument_list|(
name|display_name
argument_list|,
literal|':'
argument_list|)
condition|)
block|{
name|int
name|n
init|=
name|s
operator|-
name|display_name
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
name|insecure
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
literal|"unix"
argument_list|,
name|display_name
argument_list|,
name|n
argument_list|)
condition|)
name|insecure
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
literal|"localhost"
argument_list|,
name|display_name
argument_list|,
name|n
argument_list|)
condition|)
name|insecure
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
literal|"loopback"
argument_list|,
name|display_name
argument_list|,
name|n
argument_list|)
condition|)
name|insecure
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
literal|"127.0.0.1"
argument_list|,
name|display_name
argument_list|,
name|n
argument_list|)
condition|)
name|insecure
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|struct
name|utsname
name|utsname
decl_stmt|;
if|if
condition|(
operator|!
name|uname
argument_list|(
operator|&
name|utsname
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|utsname
operator|.
name|nodename
argument_list|,
name|display_name
argument_list|,
name|n
argument_list|)
condition|)
name|insecure
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|s
operator|=
name|strchr
argument_list|(
name|display_name
argument_list|,
literal|'.'
argument_list|)
condition|)
block|{
name|int
name|n2
init|=
name|s
operator|-
name|display_name
decl_stmt|;
if|if
condition|(
name|n
operator|<
name|n2
condition|)
name|n2
operator|=
name|n
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|utsname
operator|.
name|nodename
argument_list|,
name|display_name
argument_list|,
name|n2
argument_list|)
condition|)
name|insecure
operator|=
literal|0
expr_stmt|;
block|}
comment|/* endif display_name is '.' */
block|}
comment|/* endif hostname != display_name */
block|}
comment|/* endif was able to get hostname */
block|}
comment|/* endif display_name == UNIX */
block|}
block|}
block|}
comment|/* endif display_name == ":" */
if|if
condition|(
name|insecure
condition|)
return|return
operator|(
name|result
operator|=
literal|1
operator|)
return|;
comment|/* If no DISPLAY variable exists and TERM=xterm,       then we probably have an xterm executing on a remote system       with an rlogin or telnet to our system.  If it were a local      xterm, then the DISPLAY environment variable would      have to exist. rja */
if|if
condition|(
operator|!
name|display_name
operator|&&
name|term_name
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|remote_terms
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|term_name
argument_list|,
name|remote_terms
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
name|result
operator|=
literal|1
operator|)
return|;
block|}
empty_stmt|;
if|#
directive|if
name|HAVE_UT_HOST
operator|||
name|DOUTMPX
if|if
condition|(
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|memset
argument_list|(
operator|&
name|utmp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|utmp
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|int
name|i
init|=
name|__opiegetutmpentry
argument_list|(
name|ttyname
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|utmp
argument_list|)
decl_stmt|;
name|endutent
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|i
operator|&&
name|utmp
operator|.
name|ut_host
index|[
literal|0
index|]
condition|)
block|{
name|char
name|host
index|[
sizeof|sizeof
argument_list|(
name|utmp
operator|.
name|ut_host
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
name|insecure
operator|=
literal|1
expr_stmt|;
name|strncpy
argument_list|(
name|host
argument_list|,
name|utmp
operator|.
name|ut_host
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
operator|.
name|ut_host
argument_list|)
argument_list|)
expr_stmt|;
name|host
index|[
sizeof|sizeof
argument_list|(
name|utmp
operator|.
name|ut_host
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|=
name|strchr
argument_list|(
name|host
argument_list|,
literal|':'
argument_list|)
condition|)
block|{
name|int
name|n
init|=
name|s
operator|-
name|host
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
name|insecure
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|display_name
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|host
argument_list|,
name|display_name
argument_list|,
name|n
argument_list|)
condition|)
name|insecure
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|1
comment|/* def SOLARIS */
elseif|else
if|if
condition|(
name|s
operator|=
name|strchr
argument_list|(
name|host
argument_list|,
literal|' '
argument_list|)
condition|)
block|{
operator|*
name|s
operator|=
literal|':'
expr_stmt|;
if|if
condition|(
name|s
operator|=
name|strchr
argument_list|(
name|s
operator|+
literal|1
argument_list|,
literal|' '
argument_list|)
condition|)
operator|*
name|s
operator|=
literal|'.'
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|host
argument_list|,
name|display_name
argument_list|,
name|n
argument_list|)
condition|)
name|insecure
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SOLARIS */
block|}
block|}
block|}
block|}
empty_stmt|;
block|}
empty_stmt|;
endif|#
directive|endif
comment|/* HAVE_UT_HOST || DOUTMPX */
if|if
condition|(
name|insecure
condition|)
return|return
operator|(
name|result
operator|=
literal|1
operator|)
return|;
return|return
operator|(
name|result
operator|=
literal|0
operator|)
return|;
else|#
directive|else
comment|/* NO_INSECURE_CHECK */
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* NO_INSECURE_CHECK */
block|}
end_decl_stmt

end_unit

