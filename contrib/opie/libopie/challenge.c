begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* challenge.c: The opiechallenge() library function.  %%% portions-copyright-cmetz-96 Portions of this software are Copyright 1996-1998 by Craig Metz, All Rights Reserved. The Inner Net License Version 2 applies to these portions of the software. You should have received a copy of the license with this software. If you didn't get a copy, you may request one from<license@inner.net>.  Portions of this software are Copyright 1995 by Randall Atkinson and Dan McDonald, All Rights Reserved. All Rights under this copyright are assigned to the U.S. Naval Research Laboratory (NRL). The NRL Copyright Notice and License Agreement applies to this software.          History:  	Modified by cmetz for OPIE 2.32. Added extended response set 		identifier to the challenge. 	Modified by cmetz for OPIE 2.3. Use opie_ prefix. Send debug info to 		syslog. Add sha plumbing. 	Modified by cmetz for OPIE 2.2. Use FUNCTION declaration et al.         Created at NRL for OPIE 2.2 from opiesubr2.c */
end_comment

begin_include
include|#
directive|include
file|"opie_cfg.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_if
if|#
directive|if
name|DEBUG
end_if

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_include
include|#
directive|include
file|"opie.h"
end_include

begin_comment
comment|/* Return an OTP challenge string for user 'name'.      The return values are:     0  = All good    -1 = Low-level error (file, memory, I/O, etc.)    1  = High-level error (user not found or locked)     This function MUST eventually be followed by an opieverify() to release    the user lock and file handles.     This function will give you a blanked-out state block if it returns a    nonzero status. Even though it returns a non-zero status and a blank    state block, you still MUST call opieverify() to clear the lock and    any internal state (the latter condition is not actually used yet). */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|algids
index|[]
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"sha1"
block|,
literal|"md4"
block|,
literal|"md5"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|opiechallenge
name|FUNCTION
argument_list|(
operator|(
name|mp
operator|,
name|name
operator|,
name|ss
operator|)
argument_list|,
expr|struct
name|opie
operator|*
name|mp
name|AND
name|char
operator|*
name|name
name|AND
name|char
operator|*
name|ss
argument_list|)
block|{
name|int
name|rval
init|=
operator|-
literal|1
decl_stmt|;
name|memset
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
name|opielookup
argument_list|(
name|mp
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
if|if
condition|(
name|rval
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"opiechallenge: opielookup(mp, name=%s) returned %d"
argument_list|,
name|name
argument_list|,
name|rval
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
operator|!
name|rval
condition|)
block|{
name|rval
operator|=
name|opielock
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
if|if
condition|(
name|rval
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"opiechallenge: opielock(name=%s) returned %d"
argument_list|,
name|name
argument_list|,
name|rval
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
if|if
condition|(
name|rval
condition|)
block|{
name|opierandomchallenge
argument_list|(
name|ss
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|ss
argument_list|,
literal|"otp-%s %d %s ext"
argument_list|,
name|algids
index|[
name|MDX
index|]
argument_list|,
name|mp
operator|->
name|opie_n
operator|-
literal|1
argument_list|,
name|mp
operator|->
name|opie_seed
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_decl_stmt

end_unit

