begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* parsechallenge.c: The __opieparsechallenge() library function.  %%% copyright-cmetz-96 This software is Copyright 1996-2001 by Craig Metz, All Rights Reserved. The Inner Net License Version 3 applies to this software. You should have received a copy of the license with this software. If you didn't get a copy, you may request one from<license@inner.net>.          History:  	Modified by cmetz for OPIE 2.4. Use OPIE_SEQUENCE_MAX, check for 	        sequence number of zero. 	Modified by cmetz for OPIE 2.32. Check for extended response sets. 		Change prefix to double underscore. 	Created by cmetz for OPIE 2.3 using generator.c as a guide. */
end_comment

begin_include
include|#
directive|include
file|"opie_cfg.h"
end_include

begin_if
if|#
directive|if
name|HAVE_STRING_H
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STRING_H */
end_comment

begin_include
include|#
directive|include
file|"opie.h"
end_include

begin_struct
struct|struct
name|algorithm
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|num
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|algorithm
name|algorithms
index|[]
init|=
block|{
block|{
literal|"md5"
block|,
literal|5
block|}
block|,
block|{
literal|"md4"
block|,
literal|4
block|}
block|,
block|{
literal|"sha1"
block|,
literal|3
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|__opieparsechallenge
name|FUNCTION
argument_list|(
operator|(
name|buffer
operator|,
name|algorithm
operator|,
name|sequence
operator|,
name|seed
operator|,
name|exts
operator|)
argument_list|,
name|char
operator|*
name|buffer
name|AND
name|int
operator|*
name|algorithm
name|AND
name|int
operator|*
name|sequence
name|AND
name|char
operator|*
operator|*
name|seed
name|AND
name|int
operator|*
name|exts
argument_list|)
block|{
name|char
modifier|*
name|c
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|=
name|strchr
argument_list|(
name|buffer
argument_list|,
literal|' '
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
block|{
name|struct
name|algorithm
modifier|*
name|a
decl_stmt|;
for|for
control|(
name|a
operator|=
name|algorithms
init|;
name|a
operator|->
name|name
operator|&&
name|strncmp
argument_list|(
name|buffer
argument_list|,
name|a
operator|->
name|name
argument_list|,
call|(
name|int
call|)
argument_list|(
name|c
operator|-
name|buffer
argument_list|)
argument_list|)
condition|;
name|a
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|a
operator|->
name|name
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|algorithm
operator|=
name|a
operator|->
name|num
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
operator|*
name|sequence
operator|=
name|strtoul
argument_list|(
operator|++
name|c
argument_list|,
operator|&
name|c
argument_list|,
literal|10
argument_list|)
operator|)
operator|>
name|OPIE_SEQUENCE_MAX
operator|)
operator|||
operator|!
operator|*
name|sequence
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
operator|*
name|c
operator|&&
name|isspace
argument_list|(
operator|*
name|c
argument_list|)
condition|)
name|c
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|c
condition|)
return|return
operator|-
literal|1
return|;
name|buffer
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|*
name|c
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|c
argument_list|)
condition|)
name|c
operator|++
expr_stmt|;
block|{
name|int
name|i
init|=
call|(
name|int
call|)
argument_list|(
name|c
operator|-
name|buffer
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|>
name|OPIE_SEED_MAX
operator|)
operator|||
operator|(
name|i
operator|<
name|OPIE_SEED_MIN
operator|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|seed
operator|=
name|buffer
expr_stmt|;
operator|*
operator|(
name|c
operator|++
operator|)
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|c
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|c
argument_list|)
condition|)
name|c
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|&&
operator|!
name|strncmp
argument_list|(
name|c
argument_list|,
literal|"ext"
argument_list|,
literal|3
argument_list|)
condition|)
operator|*
name|exts
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|exts
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

end_unit

