begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* readpass.c: The opiereadpass() library function.  %%% portions-copyright-cmetz-96 Portions of this software are Copyright 1996-1998 by Craig Metz, All Rights Reserved. The Inner Net License Version 2 applies to these portions of the software. You should have received a copy of the license with this software. If you didn't get a copy, you may request one from<license@inner.net>.  Portions of this software are Copyright 1995 by Randall Atkinson and Dan McDonald, All Rights Reserved. All Rights under this copyright are assigned to the U.S. Naval Research Laboratory (NRL). The NRL Copyright Notice and License Agreement applies to this software.          History:  	Modified by cmetz for OPIE 2.31. Use usleep() to delay after setting 		the terminal attributes; this might help certain buggy 		systems. 	Modified by cmetz for OPIE 2.3. Use TCSAFLUSH always. 	Modified by cmetz for OPIE 2.22. Replaced echo w/ flags.                Really use FUNCTION. 	Modified by cmetz for OPIE 2.2. Use FUNCTION declaration et al.                Flush extraneous characters up to eol. Handle gobs of possible                erase and kill keys if on a terminal. To do so, use RAW                terminal I/O and handle echo ourselves. (should also help                DOS et al portability). Fixed include order. Re-did MSDOS 	       and OS/2 includes. Set up VMIN and VTIME. Added some non-UNIX 	       portability cruft. Limit backspacing and killing. In terminal                mode, eat random other control characters. Added eof handling.         Created at NRL for OPIE 2.2 from opiesubr.c. Change opiestrip_crlf to                opiestripcrlf. Don't strip to seven bits.  */
end_comment

begin_include
include|#
directive|include
file|"opie_cfg.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* ANSI C standard library */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|unix
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_comment
comment|/* POSIX file control function headers */
end_comment

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_comment
comment|/* POSIX Terminal I/O functions */
end_comment

begin_if
if|#
directive|if
name|HAVE_UNISTD_H
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* POSIX standard definitions */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UNISTD_H */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* unix */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__MSDOS__
end_ifdef

begin_include
include|#
directive|include
file|<dos.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __MSDOS__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__OS2__
end_ifdef

begin_define
define|#
directive|define
name|INCL_KBD
end_define

begin_include
include|#
directive|include
file|<os2.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __OS2__ */
end_comment

begin_include
include|#
directive|include
file|"opie.h"
end_include

begin_define
define|#
directive|define
name|CONTROL
parameter_list|(
name|x
parameter_list|)
value|(x - 64)
end_define

begin_decl_stmt
name|char
modifier|*
name|bsseq
init|=
literal|"\b \b"
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|unix
end_ifdef

begin_decl_stmt
specifier|static
name|jmp_buf
name|jmpbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOIDRET
name|catch
name|FUNCTION
argument_list|(
operator|(
name|i
operator|)
argument_list|,
name|int
name|i
argument_list|)
block|{
name|longjmp
argument_list|(
name|jmpbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* unix */
end_comment

begin_decl_stmt
name|char
modifier|*
name|opiereadpass
name|FUNCTION
argument_list|(
operator|(
name|buf
operator|,
name|len
operator|,
name|flags
operator|)
argument_list|,
name|char
operator|*
name|buf
name|AND
name|int
name|len
name|AND
name|int
name|flags
argument_list|)
block|{
ifdef|#
directive|ifdef
name|unix
name|struct
name|termios
name|attr
decl_stmt|,
name|orig_attr
decl_stmt|;
endif|#
directive|endif
comment|/* unix */
name|char
name|erase
index|[
literal|5
index|]
decl_stmt|;
name|char
name|kill
index|[
literal|4
index|]
decl_stmt|;
name|char
name|eof
index|[
literal|4
index|]
decl_stmt|;
name|memset
argument_list|(
name|erase
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|erase
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|kill
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|kill
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|eof
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|eof
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This section was heavily rewritten by rja following the model of code      samples circa page 151 of the POSIX Programmer's Guide by Donald Lewine,      ISBN 0-937175-73-0. That book is Copyright 1991 by O'Reilly&      Associates, Inc. All Rights Reserved. I recommend the book to anyone      trying to write portable software. rja */
ifdef|#
directive|ifdef
name|unix
if|if
condition|(
name|setjmp
argument_list|(
name|jmpbuf
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|catch
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* unix */
comment|/* Flush any pending output */
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|unix
comment|/* Get original terminal attributes */
if|if
condition|(
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|tcgetattr
argument_list|(
literal|0
argument_list|,
operator|&
name|orig_attr
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* copy terminal settings into attr */
name|memcpy
argument_list|(
operator|&
name|attr
argument_list|,
operator|&
name|orig_attr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|termios
argument_list|)
argument_list|)
expr_stmt|;
name|attr
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ECHO
operator||
name|ICANON
operator|)
expr_stmt|;
name|attr
operator|.
name|c_lflag
operator||=
name|ISIG
expr_stmt|;
name|attr
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|attr
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
name|erase
index|[
literal|0
index|]
operator|=
name|CONTROL
argument_list|(
literal|'H'
argument_list|)
expr_stmt|;
name|erase
index|[
literal|1
index|]
operator|=
literal|127
expr_stmt|;
ifdef|#
directive|ifdef
name|CERASE
block|{
name|char
modifier|*
name|e
init|=
name|erase
decl_stmt|;
while|while
condition|(
operator|*
name|e
condition|)
if|if
condition|(
operator|*
operator|(
name|e
operator|++
operator|)
operator|==
name|CERASE
condition|)
break|break;
if|if
condition|(
operator|!
operator|*
name|e
condition|)
operator|*
name|e
operator|=
name|CERASE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CERASE */
ifdef|#
directive|ifdef
name|VERASE
block|{
name|char
modifier|*
name|e
init|=
name|erase
decl_stmt|;
while|while
condition|(
operator|*
name|e
condition|)
if|if
condition|(
operator|*
operator|(
name|e
operator|++
operator|)
operator|==
name|attr
operator|.
name|c_cc
index|[
name|VERASE
index|]
condition|)
break|break;
if|if
condition|(
operator|!
operator|*
name|e
condition|)
operator|*
name|e
operator|=
name|attr
operator|.
name|c_cc
index|[
name|VERASE
index|]
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* VERASE */
name|kill
index|[
literal|0
index|]
operator|=
name|CONTROL
argument_list|(
literal|'U'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CKILL
block|{
name|char
modifier|*
name|e
init|=
name|kill
decl_stmt|;
while|while
condition|(
operator|*
name|e
condition|)
if|if
condition|(
operator|*
operator|(
name|e
operator|++
operator|)
operator|==
name|CKILL
condition|)
break|break;
if|if
condition|(
operator|!
operator|*
name|e
condition|)
operator|*
name|e
operator|=
name|CKILL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CKILL */
ifdef|#
directive|ifdef
name|VKILL
block|{
name|char
modifier|*
name|e
init|=
name|kill
decl_stmt|;
while|while
condition|(
operator|*
name|e
condition|)
if|if
condition|(
operator|*
operator|(
name|e
operator|++
operator|)
operator|==
name|attr
operator|.
name|c_cc
index|[
name|VKILL
index|]
condition|)
break|break;
if|if
condition|(
operator|!
operator|*
name|e
condition|)
operator|*
name|e
operator|=
name|attr
operator|.
name|c_cc
index|[
name|VKILL
index|]
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* VKILL */
name|eof
index|[
literal|0
index|]
operator|=
name|CONTROL
argument_list|(
literal|'D'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CEOF
block|{
name|char
modifier|*
name|e
init|=
name|eof
decl_stmt|;
while|while
condition|(
operator|*
name|e
condition|)
if|if
condition|(
operator|*
operator|(
name|e
operator|++
operator|)
operator|==
name|CEOF
condition|)
break|break;
if|if
condition|(
operator|!
operator|*
name|e
condition|)
operator|*
name|e
operator|=
name|CEOF
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CEOF */
ifdef|#
directive|ifdef
name|VEOF
block|{
name|char
modifier|*
name|e
init|=
name|eof
decl_stmt|;
while|while
condition|(
operator|*
name|e
condition|)
if|if
condition|(
operator|*
operator|(
name|e
operator|++
operator|)
operator|==
name|attr
operator|.
name|c_cc
index|[
name|VEOF
index|]
condition|)
break|break;
if|if
condition|(
operator|!
operator|*
name|e
condition|)
operator|*
name|e
operator|=
name|VEOF
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* VEOF */
if|#
directive|if
name|HAVE_USLEEP
name|usleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_USLEEP */
if|if
condition|(
name|tcsetattr
argument_list|(
literal|0
argument_list|,
name|TCSAFLUSH
argument_list|,
operator|&
name|attr
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|#
directive|if
name|HAVE_USLEEP
name|usleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_USLEEP */
block|}
else|#
directive|else
comment|/* unix */
name|erase
index|[
literal|0
index|]
operator|=
name|CONTROL
argument_list|(
literal|'H'
argument_list|)
expr_stmt|;
name|erase
index|[
literal|1
index|]
operator|=
literal|127
expr_stmt|;
name|kill
index|[
literal|0
index|]
operator|=
name|CONTROL
argument_list|(
literal|'U'
argument_list|)
expr_stmt|;
name|eof
index|[
literal|0
index|]
operator|=
name|CONTROL
argument_list|(
literal|'D'
argument_list|)
expr_stmt|;
name|eof
index|[
literal|1
index|]
operator|=
name|CONTROL
argument_list|(
literal|'Z'
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* unix */
block|{
name|char
modifier|*
name|c
init|=
name|buf
decl_stmt|,
modifier|*
name|end
init|=
name|buf
operator|+
name|len
decl_stmt|,
modifier|*
name|e
decl_stmt|;
ifdef|#
directive|ifdef
name|__OS2__
name|KBDKEYINFO
name|keyInfo
decl_stmt|;
endif|#
directive|endif
comment|/* __OS2__ */
name|loop
label|:
ifdef|#
directive|ifdef
name|unix
if|if
condition|(
name|read
argument_list|(
literal|0
argument_list|,
name|c
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|error
goto|;
endif|#
directive|endif
comment|/* unix */
ifdef|#
directive|ifdef
name|MSDOS
operator|*
name|c
operator|=
name|bdos
argument_list|(
literal|7
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
ifdef|#
directive|ifdef
name|__OS2__
name|KbdCharIn
argument_list|(
operator|&
name|keyInfo
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|c
operator|=
name|keyInfo
operator|.
name|chChar
expr_stmt|;
endif|#
directive|endif
comment|/* __OS2__ */
if|if
condition|(
operator|(
operator|*
name|c
operator|==
literal|'\r'
operator|)
operator|||
operator|(
operator|*
name|c
operator|==
literal|'\n'
operator|)
condition|)
block|{
operator|*
name|c
operator|=
literal|0
expr_stmt|;
goto|goto
name|restore
goto|;
block|}
name|e
operator|=
name|eof
expr_stmt|;
while|while
condition|(
operator|*
name|e
condition|)
if|if
condition|(
operator|*
operator|(
name|e
operator|++
operator|)
operator|==
operator|*
name|c
condition|)
goto|goto
name|error
goto|;
name|e
operator|=
name|erase
expr_stmt|;
while|while
condition|(
operator|*
name|e
condition|)
if|if
condition|(
operator|*
operator|(
name|e
operator|++
operator|)
operator|==
operator|*
name|c
condition|)
block|{
if|if
condition|(
name|c
operator|<=
name|buf
condition|)
goto|goto
name|beep
goto|;
if|if
condition|(
name|flags
operator|&
literal|1
condition|)
name|write
argument_list|(
literal|1
argument_list|,
name|bsseq
argument_list|,
sizeof|sizeof
argument_list|(
name|bsseq
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|c
operator|--
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|e
operator|=
name|kill
expr_stmt|;
while|while
condition|(
operator|*
name|e
condition|)
if|if
condition|(
operator|*
operator|(
name|e
operator|++
operator|)
operator|==
operator|*
name|c
condition|)
block|{
if|if
condition|(
name|c
operator|<=
name|buf
condition|)
goto|goto
name|beep
goto|;
if|if
condition|(
name|flags
operator|&
literal|1
condition|)
while|while
condition|(
name|c
operator|--
operator|>
name|buf
condition|)
name|write
argument_list|(
literal|1
argument_list|,
name|bsseq
argument_list|,
sizeof|sizeof
argument_list|(
name|bsseq
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|c
operator|=
name|buf
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|c
operator|<
name|end
condition|)
block|{
if|if
condition|(
operator|*
name|c
operator|<
literal|32
condition|)
goto|goto
name|beep
goto|;
if|if
condition|(
name|flags
operator|&
literal|1
condition|)
name|write
argument_list|(
literal|1
argument_list|,
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
else|else
block|{
name|beep
label|:
operator|*
name|c
operator|=
name|CONTROL
argument_list|(
literal|'G'
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|1
argument_list|,
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
goto|goto
name|loop
goto|;
block|}
name|restore
label|:
ifdef|#
directive|ifdef
name|unix
comment|/* Restore previous tty modes */
if|if
condition|(
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
if|if
condition|(
name|tcsetattr
argument_list|(
literal|0
argument_list|,
name|TCSAFLUSH
argument_list|,
operator|&
name|orig_attr
argument_list|)
condition|)
return|return
name|NULL
return|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* unix */
comment|/* After the secret key is taken from the keyboard, the line feed is      written to standard error instead of standard output.  That means that      anyone using the program from a terminal won't notice, but capturing      standard output will get the key words without a newline in front of      them. */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
literal|4
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
name|error
label|:
operator|*
name|buf
operator|=
literal|0
expr_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
goto|goto
name|restore
goto|;
block|}
end_decl_stmt

end_unit

