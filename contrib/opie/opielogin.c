begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* opielogin.c: The infamous /bin/login  %%% portions-copyright-cmetz-96 Portions of this software are Copyright 1996-1998 by Craig Metz, All Rights Reserved. The Inner Net License Version 2 applies to these portions of the software. You should have received a copy of the license with this software. If you didn't get a copy, you may request one from<license@inner.net>.  Portions of this software are Copyright 1995 by Randall Atkinson and Dan McDonald, All Rights Reserved. All Rights under this copyright are assigned to the U.S. Naval Research Laboratory (NRL). The NRL Copyright Notice and License Agreement applies to this software.  	History:  	Modified by cmetz for OPIE 2.32. Partially handle environment 		variables on the command line (a better implementation is 		coming soon). Handle failure to issue a challenge more 		gracefully. 	Modified by cmetz for OPIE 2.31. Use _PATH_NOLOGIN. Move Solaris 	        drain bamage kluge after rflag check; it breaks rlogin. 		Use TCSAFLUSH instead of TCSANOW (except where it flushes 		data we need). Sleep before kluging for Solaris. 	Modified by cmetz for OPIE 2.3. Process login environment files. 	        Made logindevperm/fbtab handling more generic. Kluge around                 Solaris drain bamage differently (maybe better?). Maybe 		allow cleartext logins even when opiechallenge() fails. 		Changed the conditions on when time.h and sys/time.h are 		included. Send debug info to syslog. Use opielogin() instead 		of dealing with utmp/setlogin() here. 	Modified by cmetz for OPIE 2.22. Call setlogin(). Decreased default 	        timeout to two minutes. Use opiereadpass() flags to get 		around Solaris drain bamage. 	Modified by cmetz for OPIE 2.21. Took the sizeof() the wrong thing.         Modified by cmetz for OPIE 2.2. Changed prompts to ask for OTP                 response where appropriate. Simple though small speed-up.                 Don't allow cleartext if echo on. Don't try to clear                 non-blocking I/O. Use opiereadpass(). Don't mess with                 termios (as much, at least) -- that's opiereadpass()'s                 job. Change opiereadpass() calls to add echo arg. Fixed                 CONTROL macro. Don't modify argv (at least, unless                 we have a reason to). Allow user in if ruserok() says                 so. Removed useless strings (I don't think that                 removing the ucb copyright one is a problem -- please                 let me know if I'm wrong). Use FUNCTION declaration et                 al. Moved definition of TRUE here. Ifdef around more                 headers. Make everything static. Removed support for                 omitting domain name if same domain -- it generally                 didn't work and it would be a big portability problem.                 Use opiereadpass() in getloginname() and then post-                 process. Added code to grab hpux time zone from                 /etc/src.sh. Renamed MAIL_DIR to PATH_MAIL. Removed                 dupe catchexit and extraneous closelog. openlog() as                 soon as possible because SunOS syslog is broken.                 Don't print an extra blank line before a new Response                 prompt.         Modified at NRL for OPIE 2.2. Changed strip_crlf to stripcrlf.                 Do opiebackspace() on entries. 	Modified at NRL for OPIE 2.1. Since we don't seem to use the 	        result of opiechallenge() anymore, discard it. Changed 		BSD4_3 to HAVE_GETTTYNAM. Other symbol changes for 		autoconf. Removed obselete usage comment. Removed 		des_crypt.h. File renamed to opielogin.c. Added bletch 		for setpriority. Added slash between MAIL_DIR and name.         Modified at NRL for OPIE 2.02. Flush stdio after printing login                 prompt. Fixed Solaris shadow password problem introduced                 in OPIE 2.01 (the shadow password structure is spwd, not                 spasswd).         Modified at NRL for OPIE 2.01. Changed password lookup handling                 to use a static structure to avoid problems with drain-                 bamaged shadow password packages. Make sure to close                 syslog by function to avoid problems with drain bamaged                 syslog implementations. Log a few interesting errors. 	Modified at NRL for OPIE 2.0. 	Modified at Bellcore for the Bellcore S/Key Version 1 software 		distribution. 	Originally from BSD. */
end_comment

begin_comment
comment|/*  * Portions of this software are  * Copyright (c) 1980,1987 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_include
include|#
directive|include
file|"opie_cfg.h"
end_include

begin_comment
comment|/* OPIE: defines symbols for filenames& pathnames */
end_comment

begin_if
if|#
directive|if
name|HAVE_SYS_PARAM_H
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_PARAM_H */
end_comment

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|HAVE_SETPRIORITY
operator|&&
name|HAVE_SYS_RESOURCE_H
end_if

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SETPRIORITY&& HAVE_SYS_RESOURCE_H */
end_comment

begin_if
if|#
directive|if
name|TIME_WITH_SYS_TIME
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* TIME_WITH_SYS_TIME */
end_comment

begin_if
if|#
directive|if
name|HAVE_SYS_TIME_H
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* HAVE_SYS_TIME_H */
end_comment

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_TIME_H */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TIME_WITH_SYS_TIME */
end_comment

begin_if
if|#
directive|if
name|HAVE_SYS_FILE_H
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_FILE_H */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_if
if|#
directive|if
name|HAVE_PWD_H
end_if

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_comment
comment|/* POSIX Password routines */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PWD_H */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|HAVE_UNISTD_H
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* Basic POSIX macros and functions */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UNISTD_H */
end_comment

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_comment
comment|/* POSIX terminal I/O */
end_comment

begin_if
if|#
directive|if
name|HAVE_STRING_H
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* ANSI C string functions */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STRING_H */
end_comment

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_comment
comment|/* File I/O functions */
end_comment

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_comment
comment|/* contains types needed for next include file */
end_comment

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_comment
comment|/* Inet addr<-->ascii functions */
end_comment

begin_if
if|#
directive|if
name|HAVE_STDLIB_H
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_if
if|#
directive|if
name|HAVE_SYS_SELECT_H
end_if

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_SELECT_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|QUOTA
end_ifdef

begin_include
include|#
directive|include
file|<sys/quota.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_GETTTYNAM
end_if

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_comment
comment|/* non-portable routines used only a few places */
end_comment

begin_include
include|#
directive|include
file|<ttyent.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_GETTTYNAM */
end_comment

begin_include
include|#
directive|include
file|"opie.h"
end_include

begin_define
define|#
directive|define
name|TTYGID
parameter_list|(
name|gid
parameter_list|)
value|tty_gid(gid)
end_define

begin_comment
comment|/* gid that owns all ttys */
end_comment

begin_define
define|#
directive|define
name|NMAX
value|32
end_define

begin_define
define|#
directive|define
name|HMAX
value|256
end_define

begin_if
if|#
directive|if
name|HAVE_LASTLOG_H
end_if

begin_include
include|#
directive|include
file|<lastlog.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LASTLOG_H */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|usererr
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stopmotd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|rusername
index|[
name|NMAX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|name
index|[
name|NMAX
operator|+
literal|1
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|minusnam
index|[
literal|16
index|]
init|=
literal|"-"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|envinit
index|[
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* now set by setenv calls */
end_comment

begin_decl_stmt
specifier|static
name|char
name|term
index|[
literal|64
index|]
init|=
literal|"\0"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* important to initialise to a NULL string */
end_comment

begin_decl_stmt
specifier|static
name|char
name|host
index|[
name|HMAX
operator|+
literal|1
index|]
init|=
literal|"\0"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|passwd
name|nouser
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|passwd
name|thisuser
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|HAVE_SHADOW_H
end_if

begin_include
include|#
directive|include
file|<shadow.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SHADOW_H */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ttyprompt
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PERMSFILE
end_ifdef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|home
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PERMSFILE */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|termios
name|attr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ouroptind
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ouroptarg
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|HAVE_LASTLOG_H
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|_PATH_LASTLOG
end_ifndef

begin_define
define|#
directive|define
name|_PATH_LASTLOG
value|"/var/adm/lastlog"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _PATH_LASTLOG */
end_comment

begin_decl_stmt
specifier|static
name|char
name|lastlog
index|[]
init|=
name|_PATH_LASTLOG
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LASTLOG_H */
end_comment

begin_comment
comment|/*  * The "timeout" variable bounds the time given to login.  * We initialize it here for safety and so that it can be  * patched on machines where the default value is not appropriate.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|timeout
init|=
literal|120
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getstr
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|HAVE_CRYPT_H
end_if

begin_include
include|#
directive|include
file|<crypt.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CRYPT_H */
end_comment

begin_undef
undef|#
directive|undef
name|TRUE
end_undef

begin_define
define|#
directive|define
name|TRUE
value|-1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCSWINSZ
end_ifdef

begin_comment
comment|/* Windowing variable relating to JWINSIZE/TIOCSWINSZ/TIOCGWINSZ. This is available on BSDish systems and at least Solaris 2.x, but portability to other systems is questionable. Use within this source code module is protected by suitable defines.  I'd be interested in hearing about a more portable approach. rja */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|winsize
name|win
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*------------------ BEGIN REAL CODE --------------------------------*/
end_comment

begin_comment
comment|/* We allow the malloc()s to potentially leak data out because we can only call this routine about four times in the lifetime of this process and the kernel will free all heap memory when we exit or exec. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lookupuser
name|FUNCTION_NOARGS
block|{
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
if|#
directive|if
name|HAVE_SHADOW
name|struct
name|spwd
modifier|*
name|spwd
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_SHADOW */
name|memcpy
argument_list|(
operator|&
name|thisuser
argument_list|,
operator|&
name|nouser
argument_list|,
sizeof|sizeof
argument_list|(
name|thisuser
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pwd
operator|=
name|getpwnam
argument_list|(
name|name
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|thisuser
operator|.
name|pw_uid
operator|=
name|pwd
operator|->
name|pw_uid
expr_stmt|;
name|thisuser
operator|.
name|pw_gid
operator|=
name|pwd
operator|->
name|pw_gid
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|thisuser
operator|.
name|pw_name
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
condition|)
goto|goto
name|lookupuserbad
goto|;
name|strcpy
argument_list|(
name|thisuser
operator|.
name|pw_name
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|thisuser
operator|.
name|pw_dir
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|pwd
operator|->
name|pw_dir
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
condition|)
goto|goto
name|lookupuserbad
goto|;
name|strcpy
argument_list|(
name|thisuser
operator|.
name|pw_dir
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|thisuser
operator|.
name|pw_shell
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|pwd
operator|->
name|pw_shell
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
condition|)
goto|goto
name|lookupuserbad
goto|;
name|strcpy
argument_list|(
name|thisuser
operator|.
name|pw_shell
argument_list|,
name|pwd
operator|->
name|pw_shell
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_SHADOW
if|if
condition|(
operator|!
operator|(
name|spwd
operator|=
name|getspnam
argument_list|(
name|name
argument_list|)
operator|)
condition|)
goto|goto
name|lookupuserbad
goto|;
name|pwd
operator|->
name|pw_passwd
operator|=
name|spwd
operator|->
name|sp_pwdp
expr_stmt|;
name|endspent
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SHADOW */
if|if
condition|(
operator|!
operator|(
name|thisuser
operator|.
name|pw_passwd
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|pwd
operator|->
name|pw_passwd
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
condition|)
goto|goto
name|lookupuserbad
goto|;
name|strcpy
argument_list|(
name|thisuser
operator|.
name|pw_passwd
argument_list|,
name|pwd
operator|->
name|pw_passwd
argument_list|)
expr_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
return|return
operator|(
operator|(
name|thisuser
operator|.
name|pw_passwd
index|[
literal|0
index|]
operator|==
literal|'*'
operator|)
operator|||
operator|(
name|thisuser
operator|.
name|pw_passwd
index|[
literal|0
index|]
operator|==
literal|'#'
operator|)
operator|)
return|;
name|lookupuserbad
label|:
name|memcpy
argument_list|(
operator|&
name|thisuser
argument_list|,
operator|&
name|nouser
argument_list|,
sizeof|sizeof
argument_list|(
name|thisuser
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOIDRET
name|getloginname
name|FUNCTION_NOARGS
block|{
specifier|register
name|char
modifier|*
name|namep
decl_stmt|;
name|char
name|c
decl_stmt|,
name|d
decl_stmt|;
name|int
name|flags
decl_stmt|;
specifier|static
name|int
name|first
init|=
literal|1
decl_stmt|;
name|memset
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|flags
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ttyprompt
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|flags
operator|=
literal|4
expr_stmt|;
name|first
operator|--
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
name|ttyprompt
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"login: "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|d
operator|==
literal|3
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opiereadpass
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
operator|-
literal|1
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"End-of-file (or other error?) on stdin!"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|namep
operator|=
name|name
init|;
operator|*
name|namep
condition|;
name|namep
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
name|c
operator|=
literal|'_'
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOIDRET
name|timedout
name|FUNCTION
argument_list|(
operator|(
name|i
operator|)
argument_list|,
name|int
name|i
argument_list|)
block|{
comment|/* input variable declared just to keep the compiler quiet */
name|printf
argument_list|(
literal|"Login timed out after %d seconds\n"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"Login timed out after %d seconds!"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|HAVE_MOTD_IN_PROFILE
end_if

begin_decl_stmt
specifier|static
name|VOIDRET
name|catch
name|FUNCTION
argument_list|(
operator|(
name|i
operator|)
argument_list|,
name|int
name|i
argument_list|)
block|{
comment|/* the input variable is declared to keep the compiler quiet */
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|stopmotd
operator|++
expr_stmt|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_MOTD_IN_PROFILE */
end_comment

begin_decl_stmt
specifier|static
name|VOIDRET
name|catchexit
name|FUNCTION_NOARGS
block|{
name|int
name|i
decl_stmt|;
name|tcsetattr
argument_list|(
name|STDIN_FILENO
argument_list|,
name|TCSAFLUSH
argument_list|,
operator|&
name|attr
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|closelog
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sysconf
argument_list|(
name|_SC_OPEN_MAX
argument_list|)
init|;
name|i
operator|>
literal|2
condition|;
name|i
operator|--
control|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rootterm
name|FUNCTION
argument_list|(
operator|(
name|ttyn
operator|)
argument_list|,
name|char
operator|*
name|ttyn
argument_list|)
block|{
if|#
directive|if
name|HAVE_GETTTYNAM
comment|/* The getttynam() call and the ttyent structure first appeared in 4.3 BSD and are not portable to System V systems such as Solaris 2.x. or modern versions of IRIX rja */
specifier|register
name|struct
name|ttyent
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|tty
decl_stmt|;
name|tty
operator|=
name|strrchr
argument_list|(
name|ttyn
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty
operator|==
name|NULL
condition|)
name|tty
operator|=
name|ttyn
expr_stmt|;
else|else
name|tty
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|getttynam
argument_list|(
name|tty
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|t
operator|->
name|ty_status
operator|&
name|TTY_SECURE
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* when in doubt, allow root logins */
elif|#
directive|elif
name|HAVE_ETC_DEFAULT_LOGIN
name|FILE
modifier|*
name|filno
decl_stmt|;
name|char
name|line
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|next
decl_stmt|,
modifier|*
name|next2
decl_stmt|;
comment|/* SVR4 only permits two security modes for root logins: 1) only from CONSOLE, if the string "CONSOLE=/dev/console" exists and is not commented out with "#" characters, or 2) from anywhere.  So we open /etc/default/login file grab the file contents one line at a time verify that the line being tested isn't commented out check for the substring "CONSOLE" and decide whether to permit this attempted root login/su. */
if|if
condition|(
operator|(
name|filno
operator|=
name|fopen
argument_list|(
literal|"/etc/default/login"
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
literal|128
argument_list|,
name|filno
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|line
expr_stmt|;
if|if
condition|(
operator|(
name|line
index|[
literal|0
index|]
operator|!=
literal|'#'
operator|)
operator|&&
operator|(
name|next
operator|=
name|strstr
argument_list|(
name|line
argument_list|,
literal|"CONSOLE"
argument_list|)
operator|)
condition|)
block|{
name|next
operator|+=
literal|7
expr_stmt|;
comment|/* get past the string "CONSOLE" */
while|while
condition|(
operator|*
name|next
operator|&&
operator|(
operator|*
name|next
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|next
operator|==
literal|'\t'
operator|)
condition|)
name|next
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|next
operator|++
operator|)
operator|!=
literal|'='
condition|)
break|break;
comment|/* some weird character, get next line */
name|next2
operator|=
name|next
expr_stmt|;
while|while
condition|(
operator|*
name|next2
operator|&&
operator|(
operator|*
name|next2
operator|!=
literal|'\t'
operator|)
operator|&&
operator|(
operator|*
name|next2
operator|!=
literal|' '
operator|)
operator|&&
operator|(
operator|*
name|next2
operator|!=
literal|'\n'
operator|)
condition|)
name|next2
operator|++
expr_stmt|;
operator|*
name|next2
operator|=
literal|0
expr_stmt|;
return|return
operator|!
name|strcmp
argument_list|(
name|ttyn
argument_list|,
name|next
argument_list|)
return|;
comment|/* Allow the login if and only if the 					   user's terminal line matches the 					   setting for CONSOLE */
block|}
block|}
comment|/* end while another line could be obtained */
block|}
comment|/* end if could open file */
return|return
operator|(
literal|1
operator|)
return|;
comment|/* when no CONSOLE line exists, root can login from anywhere */
elif|#
directive|elif
name|HAVE_SECURETTY
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
name|buffer
index|[
literal|1024
index|]
decl_stmt|,
modifier|*
name|c
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|f
operator|=
name|fopen
argument_list|(
literal|"/etc/securetty"
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|c
operator|=
name|strstr
argument_list|(
name|ttyn
argument_list|,
literal|"/dev/"
argument_list|)
condition|)
name|ttyn
operator|+=
literal|5
expr_stmt|;
if|if
condition|(
name|c
operator|=
name|strrchr
argument_list|(
name|ttyn
argument_list|,
literal|'/'
argument_list|)
condition|)
name|ttyn
operator|=
operator|++
name|c
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|f
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|=
name|strrchr
argument_list|(
name|buffer
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|=
name|strrchr
argument_list|(
name|buffer
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
name|c
operator|=
name|buffer
expr_stmt|;
else|else
name|c
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|c
argument_list|,
name|ttyn
argument_list|)
condition|)
name|rc
operator|=
literal|1
expr_stmt|;
block|}
empty_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
else|#
directive|else
return|return
operator|(
literal|1
operator|)
return|;
comment|/* when in doubt, allow root logins */
endif|#
directive|endif
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|doremotelogin
name|FUNCTION
argument_list|(
operator|(
name|host
operator|)
argument_list|,
name|char
operator|*
name|host
argument_list|)
block|{
name|int
name|rc
decl_stmt|;
name|getstr
argument_list|(
name|rusername
argument_list|,
sizeof|sizeof
argument_list|(
name|rusername
argument_list|)
argument_list|,
literal|"remuser"
argument_list|)
expr_stmt|;
name|getstr
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"locuser"
argument_list|)
expr_stmt|;
name|getstr
argument_list|(
name|term
argument_list|,
sizeof|sizeof
argument_list|(
name|term
argument_list|)
argument_list|,
literal|"Terminal type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|getuid
argument_list|()
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|thisuser
argument_list|,
operator|&
name|nouser
argument_list|,
sizeof|sizeof
argument_list|(
name|thisuser
argument_list|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getuid() failed"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|lookupuser
argument_list|()
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lookup failed for user %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|rc
operator|=
name|ruserok
argument_list|(
name|host
argument_list|,
operator|!
name|thisuser
operator|.
name|pw_uid
argument_list|,
name|rusername
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ruserok failed, host=%s, uid=%d, remote username=%s, local username=%s"
argument_list|,
name|host
argument_list|,
name|thisuser
operator|.
name|pw_uid
argument_list|,
name|rusername
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOIDRET
name|getstr
name|FUNCTION
argument_list|(
operator|(
name|buf
operator|,
name|cnt
operator|,
name|err
operator|)
argument_list|,
name|char
operator|*
name|buf
name|AND
name|int
name|cnt
name|AND
name|char
operator|*
name|err
argument_list|)
block|{
name|char
name|c
decl_stmt|;
do|do
block|{
if|if
condition|(
name|read
argument_list|(
literal|0
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|cnt
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s too long\r\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"%s too long"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|buf
operator|++
operator|=
name|c
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|c
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'~'
operator|)
condition|)
do|;
block|}
end_decl_stmt

begin_struct
struct|struct
name|speed_xlat
block|{
name|char
modifier|*
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
block|}
name|speeds
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|B0
block|{
literal|"0"
block|,
name|B0
block|}
block|,
endif|#
directive|endif
comment|/* B0 */
ifdef|#
directive|ifdef
name|B50
block|{
literal|"50"
block|,
name|B50
block|}
block|,
endif|#
directive|endif
comment|/* B50 */
ifdef|#
directive|ifdef
name|B75
block|{
literal|"75"
block|,
name|B75
block|}
block|,
endif|#
directive|endif
comment|/* B75 */
ifdef|#
directive|ifdef
name|B110
block|{
literal|"110"
block|,
name|B110
block|}
block|,
endif|#
directive|endif
comment|/* B110 */
ifdef|#
directive|ifdef
name|B134
block|{
literal|"134"
block|,
name|B134
block|}
block|,
endif|#
directive|endif
comment|/* B134 */
ifdef|#
directive|ifdef
name|B150
block|{
literal|"150"
block|,
name|B150
block|}
block|,
endif|#
directive|endif
comment|/* B150 */
ifdef|#
directive|ifdef
name|B200
block|{
literal|"200"
block|,
name|B200
block|}
block|,
endif|#
directive|endif
comment|/* B200 */
ifdef|#
directive|ifdef
name|B300
block|{
literal|"300"
block|,
name|B300
block|}
block|,
endif|#
directive|endif
comment|/* B300 */
ifdef|#
directive|ifdef
name|B600
block|{
literal|"600"
block|,
name|B600
block|}
block|,
endif|#
directive|endif
comment|/* B600 */
ifdef|#
directive|ifdef
name|B1200
block|{
literal|"1200"
block|,
name|B1200
block|}
block|,
endif|#
directive|endif
comment|/* B1200 */
ifdef|#
directive|ifdef
name|B1800
block|{
literal|"1800"
block|,
name|B1800
block|}
block|,
endif|#
directive|endif
comment|/* B1800 */
ifdef|#
directive|ifdef
name|B2400
block|{
literal|"2400"
block|,
name|B2400
block|}
block|,
endif|#
directive|endif
comment|/* B2400 */
ifdef|#
directive|ifdef
name|B4800
block|{
literal|"4800"
block|,
name|B4800
block|}
block|,
endif|#
directive|endif
comment|/* B4800 */
ifdef|#
directive|ifdef
name|B7200
block|{
literal|"7200"
block|,
name|B7200
block|}
block|,
endif|#
directive|endif
comment|/* B7200 */
ifdef|#
directive|ifdef
name|B9600
block|{
literal|"9600"
block|,
name|B9600
block|}
block|,
endif|#
directive|endif
comment|/* B9600 */
ifdef|#
directive|ifdef
name|B14400
block|{
literal|"14400"
block|,
name|B14400
block|}
block|,
endif|#
directive|endif
comment|/* B14400 */
ifdef|#
directive|ifdef
name|B19200
block|{
literal|"19200"
block|,
name|B19200
block|}
block|,
endif|#
directive|endif
comment|/* B19200 */
ifdef|#
directive|ifdef
name|B28800
block|{
literal|"28800"
block|,
name|B28800
block|}
block|,
endif|#
directive|endif
comment|/* B28800 */
ifdef|#
directive|ifdef
name|B38400
block|{
literal|"38400"
block|,
name|B38400
block|}
block|,
endif|#
directive|endif
comment|/* B38400 */
ifdef|#
directive|ifdef
name|B57600
block|{
literal|"57600"
block|,
name|B57600
block|}
block|,
endif|#
directive|endif
comment|/* B57600 */
ifdef|#
directive|ifdef
name|B115200
block|{
literal|"115200"
block|,
name|B115200
block|}
block|,
endif|#
directive|endif
comment|/* B115200 */
ifdef|#
directive|ifdef
name|B230400
block|{
literal|"230400"
block|,
name|B230400
block|}
block|,
endif|#
directive|endif
comment|/* 230400 */
block|{
name|NULL
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|VOIDRET
name|doremoteterm
name|FUNCTION
argument_list|(
operator|(
name|term
operator|)
argument_list|,
name|char
operator|*
name|term
argument_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|strchr
argument_list|(
name|term
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|speed
decl_stmt|;
name|struct
name|speed_xlat
modifier|*
name|x
decl_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|speed
operator|=
name|cp
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|speed
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|x
operator|=
name|speeds
init|;
name|x
operator|->
name|c
operator|!=
name|NULL
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|x
operator|->
name|c
argument_list|,
name|speed
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cfsetispeed
argument_list|(
operator|&
name|attr
argument_list|,
name|x
operator|->
name|i
argument_list|)
expr_stmt|;
name|cfsetospeed
argument_list|(
operator|&
name|attr
argument_list|,
name|x
operator|->
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tty_gid
name|FUNCTION
argument_list|(
operator|(
name|default_gid
operator|)
argument_list|,
name|int
name|default_gid
argument_list|)
block|{
name|struct
name|group
modifier|*
name|gr
decl_stmt|;
name|int
name|gid
init|=
name|default_gid
decl_stmt|;
name|gr
operator|=
name|getgrnam
argument_list|(
name|TTYGRPNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|gr
operator|!=
operator|(
expr|struct
name|group
operator|*
operator|)
literal|0
condition|)
name|gid
operator|=
name|gr
operator|->
name|gr_gid
expr_stmt|;
name|endgrent
argument_list|()
expr_stmt|;
return|return
operator|(
name|gid
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
decl|main
name|FUNCTION
argument_list|(
operator|(
name|argc
operator|,
name|argv
operator|)
argument_list|,
name|int
name|argc
name|AND
name|char
operator|*
name|argv
index|[]
argument_list|)
block|{
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
specifier|register
name|char
modifier|*
name|namep
decl_stmt|;
name|struct
name|opie
name|opie
decl_stmt|;
name|int
name|invalid
decl_stmt|,
name|quietlog
decl_stmt|;
name|FILE
modifier|*
name|nlfd
decl_stmt|;
name|char
modifier|*
name|tty
decl_stmt|,
name|host
index|[
literal|256
index|]
decl_stmt|;
name|int
name|pflag
init|=
literal|0
decl_stmt|,
name|hflag
init|=
literal|0
decl_stmt|,
name|fflag
init|=
literal|0
decl_stmt|;
name|int
name|t
decl_stmt|,
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|opieprompt
index|[
name|OPIE_CHALLENGE_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|af_pwok
decl_stmt|;
name|int
name|authsok
decl_stmt|;
name|char
modifier|*
name|pp
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|int
name|uid
decl_stmt|;
name|int
name|opiepassed
decl_stmt|;
ifndef|#
directive|ifndef
name|DEBUG
if|if
condition|(
name|geteuid
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"This program requires super-user priveleges.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
for|for
control|(
name|t
operator|=
name|sysconf
argument_list|(
name|_SC_OPEN_MAX
argument_list|)
init|;
name|t
operator|>
literal|2
condition|;
name|t
operator|--
control|)
name|close
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|openlog
argument_list|(
literal|"login"
argument_list|,
name|LOG_ODELAY
argument_list|,
name|LOG_AUTH
argument_list|)
expr_stmt|;
comment|/* initialisation */
name|host
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opieprompt
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"environment TERM=%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|strncpy
argument_list|(
name|term
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|term
argument_list|)
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|memset
argument_list|(
operator|&
name|nouser
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|nouser
argument_list|)
argument_list|)
expr_stmt|;
name|nouser
operator|.
name|pw_uid
operator|=
operator|-
literal|1
expr_stmt|;
name|nouser
operator|.
name|pw_gid
operator|=
operator|-
literal|1
expr_stmt|;
name|nouser
operator|.
name|pw_passwd
operator|=
literal|"#nope"
expr_stmt|;
name|nouser
operator|.
name|pw_name
operator|=
name|nouser
operator|.
name|pw_gecos
operator|=
name|nouser
operator|.
name|pw_dir
operator|=
name|nouser
operator|.
name|pw_shell
operator|=
literal|""
expr_stmt|;
if|#
directive|if
name|HAVE_SETPRIORITY
operator|&&
name|HAVE_SYS_RESOURCE_H
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SETPRIORITY&& HAVE_SYS_RESOURCE_H */
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|timedout
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|#
directive|if
name|DOTTYPROMPT
name|ttyprompt
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"TTYPROMPT"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TTYPROMPT */
ifdef|#
directive|ifdef
name|QUOTA
name|quota
argument_list|(
name|Q_SETUID
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
block|{
name|int
name|foo
decl_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"my args are: (argc=%d)"
argument_list|,
name|foo
operator|=
name|argc
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|foo
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%d: %s"
argument_list|,
name|foo
argument_list|,
name|argv
index|[
name|foo
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
comment|/* Implement our own getopt()-like functionality, but do so in a much more    strict manner to prevent security problems. */
for|for
control|(
name|ouroptind
operator|=
literal|1
init|;
name|ouroptind
operator|<
name|argc
condition|;
name|ouroptind
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|argv
index|[
name|ouroptind
index|]
condition|)
continue|continue;
if|if
condition|(
name|argv
index|[
name|ouroptind
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|char
modifier|*
name|c
init|=
name|argv
index|[
name|ouroptind
index|]
operator|+
literal|1
decl_stmt|;
while|while
condition|(
operator|*
name|c
condition|)
block|{
switch|switch
condition|(
operator|*
operator|(
name|c
operator|++
operator|)
condition|)
block|{
case|case
literal|'d'
case|:
if|if
condition|(
operator|*
name|c
operator|||
operator|(
operator|++
name|ouroptind
operator|==
name|argc
operator|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*    The '-d' option is apparently a performance hack to get around    ttyname() being slow. The potential does exist for it to be used    for malice, and it does not seem to be strictly necessary, so we    will just eat it. */
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|rflag
operator|||
name|hflag
operator|||
name|fflag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Other options not allowed with -r\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|c
operator|||
operator|(
operator|++
name|ouroptind
operator|==
name|argc
operator|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ouroptarg
operator|=
name|argv
index|[
name|ouroptind
index|]
operator|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|rflag
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|doremotelogin
argument_list|(
name|ouroptarg
argument_list|)
condition|)
name|rflag
operator|=
literal|1
expr_stmt|;
name|strncpy
argument_list|(
name|host
argument_list|,
name|ouroptarg
argument_list|,
sizeof|sizeof
argument_list|(
name|host
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
if|if
condition|(
operator|!
name|getuid
argument_list|()
condition|)
block|{
if|if
condition|(
name|rflag
operator|||
name|hflag
operator|||
name|fflag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Other options not allowed with -h\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|hflag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|||
operator|(
operator|++
name|ouroptind
operator|==
name|argc
operator|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ouroptarg
operator|=
name|argv
index|[
name|ouroptind
index|]
operator|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|host
argument_list|,
name|ouroptarg
argument_list|,
sizeof|sizeof
argument_list|(
name|host
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|rflag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Only one of -r and -f allowed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fflag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|||
operator|(
operator|++
name|ouroptind
operator|==
name|argc
operator|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ouroptarg
operator|=
name|argv
index|[
name|ouroptind
index|]
operator|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|ouroptarg
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|pflag
operator|=
literal|1
expr_stmt|;
break|break;
block|}
empty_stmt|;
block|}
empty_stmt|;
continue|continue;
block|}
empty_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|argv
index|[
name|ouroptind
index|]
argument_list|,
literal|'='
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|ouroptind
index|]
argument_list|,
literal|"TERM="
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|strncpy
argument_list|(
name|term
argument_list|,
operator|&
operator|(
name|argv
index|[
name|ouroptind
index|]
index|[
literal|5
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|term
argument_list|)
argument_list|)
expr_stmt|;
name|term
index|[
sizeof|sizeof
argument_list|(
name|term
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"passed TERM=%s, ouroptind = %d"
argument_list|,
name|term
argument_list|,
name|ouroptind
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"eating %s, ouroptind = %d"
argument_list|,
name|argv
index|[
name|ouroptind
index|]
argument_list|,
name|ouroptind
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
empty_stmt|;
continue|continue;
block|}
empty_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|argv
index|[
name|ouroptind
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
ifdef|#
directive|ifdef
name|TIOCNXCL
comment|/* BSDism:  not sure how to rewrite for POSIX.  rja */
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCNXCL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* set non-exclusive use of tty */
endif|#
directive|endif
comment|/* get original termio attributes */
if|if
condition|(
name|tcgetattr
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|&
name|attr
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* If talking to an rlogin process, propagate the terminal type and baud rate    across the network. */
if|if
condition|(
name|rflag
condition|)
name|doremoteterm
argument_list|(
name|term
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|termios
name|termios
decl_stmt|;
name|fd_set
name|fds
decl_stmt|;
name|struct
name|timeval
name|timeval
decl_stmt|;
name|memset
argument_list|(
operator|&
name|timeval
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
literal|0
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_USLEEP
name|usleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_USLEEP */
if|if
condition|(
name|select
argument_list|(
literal|1
argument_list|,
operator|&
name|fds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|timeval
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"reading user name from tty buffer"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|tcgetattr
argument_list|(
literal|0
argument_list|,
operator|&
name|termios
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"tcgetattr(0,&termios) failed"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|termios
operator|.
name|c_lflag
operator|&=
operator|~
name|ECHO
expr_stmt|;
if|if
condition|(
name|tcsetattr
argument_list|(
literal|0
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|termios
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"tcsetattr(0,&termios) failed"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
operator|-
literal|1
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|name
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'\r'
argument_list|)
operator|)
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'\n'
argument_list|)
operator|)
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Force termios portable control characters to the system default values as specified in termios.h. This should help the one-time password login feel the same as the vendor-supplied login. Common extensions are also set for completeness, but these are set within appropriate defines for portability. */
define|#
directive|define
name|CONTROL
parameter_list|(
name|x
parameter_list|)
value|(x - 64)
ifdef|#
directive|ifdef
name|VEOF
ifdef|#
directive|ifdef
name|CEOF
name|attr
operator|.
name|c_cc
index|[
name|VEOF
index|]
operator|=
name|CEOF
expr_stmt|;
else|#
directive|else
comment|/* CEOF */
name|attr
operator|.
name|c_cc
index|[
name|VEOF
index|]
operator|=
name|CONTROL
argument_list|(
literal|'D'
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CEOF */
endif|#
directive|endif
comment|/* VEOF */
ifdef|#
directive|ifdef
name|VEOL
ifdef|#
directive|ifdef
name|CEOL
name|attr
operator|.
name|c_cc
index|[
name|VEOL
index|]
operator|=
name|CEOL
expr_stmt|;
else|#
directive|else
comment|/* CEOL */
name|attr
operator|.
name|c_cc
index|[
name|VEOL
index|]
operator|=
name|CONTROL
argument_list|(
literal|'J'
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CEOL */
endif|#
directive|endif
comment|/* VEOL */
ifdef|#
directive|ifdef
name|VERASE
ifdef|#
directive|ifdef
name|CERASE
name|attr
operator|.
name|c_cc
index|[
name|VERASE
index|]
operator|=
name|CERASE
expr_stmt|;
else|#
directive|else
comment|/* CERASE */
name|attr
operator|.
name|c_cc
index|[
name|VERASE
index|]
operator|=
name|CONTROL
argument_list|(
literal|'H'
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CERASE */
endif|#
directive|endif
comment|/* VERASE */
ifdef|#
directive|ifdef
name|VINTR
ifdef|#
directive|ifdef
name|CINTR
name|attr
operator|.
name|c_cc
index|[
name|VINTR
index|]
operator|=
name|CINTR
expr_stmt|;
else|#
directive|else
comment|/* CINTR */
name|attr
operator|.
name|c_cc
index|[
name|VINTR
index|]
operator|=
name|CONTROL
argument_list|(
literal|'C'
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CINTR */
endif|#
directive|endif
comment|/* VINTR */
ifdef|#
directive|ifdef
name|VKILL
ifdef|#
directive|ifdef
name|CKILL
name|attr
operator|.
name|c_cc
index|[
name|VKILL
index|]
operator|=
name|CKILL
expr_stmt|;
else|#
directive|else
comment|/* CKILL */
name|attr
operator|.
name|c_cc
index|[
name|VKILL
index|]
operator|=
name|CONTROL
argument_list|(
literal|'U'
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CKILL */
endif|#
directive|endif
comment|/* VKILL */
ifdef|#
directive|ifdef
name|VQUIT
ifdef|#
directive|ifdef
name|CQUIT
name|attr
operator|.
name|c_cc
index|[
name|VQUIT
index|]
operator|=
name|CQUIT
expr_stmt|;
else|#
directive|else
comment|/* CQUIT */
name|attr
operator|.
name|c_cc
index|[
name|VQUIT
index|]
operator|=
name|CONTROL
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CQUIT */
endif|#
directive|endif
comment|/* VQUIT */
ifdef|#
directive|ifdef
name|VSUSP
ifdef|#
directive|ifdef
name|CSUSP
name|attr
operator|.
name|c_cc
index|[
name|VSUSP
index|]
operator|=
name|CSUSP
expr_stmt|;
else|#
directive|else
comment|/* CSUSP */
name|attr
operator|.
name|c_cc
index|[
name|VSUSP
index|]
operator|=
name|CONTROL
argument_list|(
literal|'Z'
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CSUSP */
endif|#
directive|endif
comment|/* VSUSP */
ifdef|#
directive|ifdef
name|VSTOP
ifdef|#
directive|ifdef
name|CSTOP
name|attr
operator|.
name|c_cc
index|[
name|VSTOP
index|]
operator|=
name|CSTOP
expr_stmt|;
else|#
directive|else
comment|/* CSTOP */
name|attr
operator|.
name|c_cc
index|[
name|VSTOP
index|]
operator|=
name|CONTROL
argument_list|(
literal|'S'
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CSTOP */
endif|#
directive|endif
comment|/* VSTOP */
ifdef|#
directive|ifdef
name|VSTART
ifdef|#
directive|ifdef
name|CSTART
name|attr
operator|.
name|c_cc
index|[
name|VSTART
index|]
operator|=
name|CSTART
expr_stmt|;
else|#
directive|else
comment|/* CSTART */
name|attr
operator|.
name|c_cc
index|[
name|VSTART
index|]
operator|=
name|CONTROL
argument_list|(
literal|'Q'
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CSTART */
endif|#
directive|endif
comment|/* VSTART */
ifdef|#
directive|ifdef
name|VDSUSP
ifdef|#
directive|ifdef
name|CDSUSP
name|attr
operator|.
name|c_cc
index|[
name|VDSUSP
index|]
operator|=
name|CDSUSP
expr_stmt|;
else|#
directive|else
comment|/* CDSUSP */
name|attr
operator|.
name|c_cc
index|[
name|VDSUSP
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* CDSUSP */
endif|#
directive|endif
comment|/* VDSUSP */
ifdef|#
directive|ifdef
name|VEOL2
ifdef|#
directive|ifdef
name|CEOL2
name|attr
operator|.
name|c_cc
index|[
name|VEOL2
index|]
operator|=
name|CEOL2
expr_stmt|;
else|#
directive|else
comment|/* CEOL2 */
name|attr
operator|.
name|c_cc
index|[
name|VEOL2
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* CEOL2 */
endif|#
directive|endif
comment|/* VEOL2 */
ifdef|#
directive|ifdef
name|VREPRINT
ifdef|#
directive|ifdef
name|CRPRNT
name|attr
operator|.
name|c_cc
index|[
name|VREPRINT
index|]
operator|=
name|CRPRNT
expr_stmt|;
else|#
directive|else
comment|/* CRPRNT */
name|attr
operator|.
name|c_cc
index|[
name|VREPRINT
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* CRPRNT */
endif|#
directive|endif
comment|/* VREPRINT */
ifdef|#
directive|ifdef
name|VWERASE
ifdef|#
directive|ifdef
name|CWERASE
name|attr
operator|.
name|c_cc
index|[
name|VWERASE
index|]
operator|=
name|CWERASE
expr_stmt|;
else|#
directive|else
comment|/* CWERASE */
name|attr
operator|.
name|c_cc
index|[
name|VWERASE
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* CWERASE */
endif|#
directive|endif
comment|/* VWERASE */
ifdef|#
directive|ifdef
name|VLNEXT
ifdef|#
directive|ifdef
name|CLNEXT
name|attr
operator|.
name|c_cc
index|[
name|VLNEXT
index|]
operator|=
name|CLNEXT
expr_stmt|;
else|#
directive|else
comment|/* CLNEXT */
name|attr
operator|.
name|c_cc
index|[
name|VLNEXT
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* CLNEXT */
endif|#
directive|endif
comment|/* VLNEXT */
name|attr
operator|.
name|c_lflag
operator||=
name|ICANON
expr_stmt|;
comment|/* enable canonical input processing */
name|attr
operator|.
name|c_lflag
operator|&=
operator|~
name|ISIG
expr_stmt|;
comment|/* disable INTR, QUIT,& SUSP signals */
name|attr
operator|.
name|c_lflag
operator||=
operator|(
name|ECHO
operator||
name|ECHOE
operator|)
expr_stmt|;
comment|/* enable echo and erase */
ifdef|#
directive|ifdef
name|ONLCR
comment|/* POSIX does not specify any output processing flags, but the usage below      is SVID compliant and is generally portable to modern versions of UNIX. */
name|attr
operator|.
name|c_oflag
operator||=
name|ONLCR
expr_stmt|;
comment|/* map CR to CRNL on output */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ICRNL
name|attr
operator|.
name|c_iflag
operator||=
name|ICRNL
expr_stmt|;
endif|#
directive|endif
comment|/* ICRNL */
name|attr
operator|.
name|c_oflag
operator||=
name|OPOST
expr_stmt|;
name|attr
operator|.
name|c_lflag
operator||=
name|ICANON
expr_stmt|;
comment|/* enable canonical input */
name|attr
operator|.
name|c_lflag
operator||=
name|ECHO
expr_stmt|;
name|attr
operator|.
name|c_lflag
operator||=
name|ECHOE
expr_stmt|;
comment|/* enable ERASE character */
name|attr
operator|.
name|c_lflag
operator||=
name|ECHOK
expr_stmt|;
comment|/* enable KILL to delete line */
name|attr
operator|.
name|c_cflag
operator||=
name|HUPCL
expr_stmt|;
comment|/* hangup on close */
comment|/* Set revised termio attributes */
if|if
condition|(
name|tcsetattr
argument_list|(
name|STDIN_FILENO
argument_list|,
name|TCSAFLUSH
argument_list|,
operator|&
name|attr
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|atexit
argument_list|(
name|catchexit
argument_list|)
expr_stmt|;
name|tty
operator|=
name|ttyname
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
operator|||
operator|*
name|tty
operator|==
literal|'\0'
condition|)
name|tty
operator|=
literal|"UNKNOWN"
expr_stmt|;
comment|/* was: "/dev/tty??" */
if|#
directive|if
name|HAVE_SETVBUF
operator|&&
name|defined
argument_list|(
name|_IONBF
argument_list|)
if|#
directive|if
name|SETVBUF_REVERSED
name|setvbuf
argument_list|(
name|stdout
argument_list|,
name|_IONBF
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setvbuf
argument_list|(
name|stderr
argument_list|,
name|_IONBF
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SETVBUF_REVERSED */
name|setvbuf
argument_list|(
name|stdout
argument_list|,
name|NULL
argument_list|,
name|_IONBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setvbuf
argument_list|(
name|stderr
argument_list|,
name|NULL
argument_list|,
name|_IONBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SETVBUF_REVERSED */
endif|#
directive|endif
comment|/* HAVE_SETVBUF&& defined(_IONBF) */
ifdef|#
directive|ifdef
name|DEBUG
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"tty = %s"
argument_list|,
name|tty
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
ifdef|#
directive|ifdef
name|HAVE_LOGIN_ENVFILE
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|f
operator|=
name|fopen
argument_list|(
name|HAVE_LOGIN_ENVFILE
argument_list|,
literal|"r"
argument_list|)
condition|)
block|{
name|char
name|line
index|[
literal|128
index|]
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|c2
decl_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
operator|-
literal|1
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|c
operator|=
name|line
expr_stmt|;
while|while
condition|(
operator|*
name|c
operator|&&
operator|(
name|isalnum
argument_list|(
operator|*
name|c
argument_list|)
operator|||
operator|(
operator|*
name|c
operator|==
literal|'_'
operator|)
operator|)
condition|)
name|c
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|==
literal|'='
condition|)
block|{
operator|*
operator|(
name|c
operator|++
operator|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c2
operator|=
name|strchr
argument_list|(
name|c
argument_list|,
literal|';'
argument_list|)
condition|)
operator|*
name|c2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c2
operator|=
name|strchr
argument_list|(
name|c
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|c2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c2
operator|=
name|strchr
argument_list|(
name|c
argument_list|,
literal|' '
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|c2
operator|=
name|strchr
argument_list|(
name|c
argument_list|,
literal|'\t'
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"TZ"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|setenv
argument_list|(
name|line
argument_list|,
name|c
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"setenv() failed -- environment full?\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_LOGIN_ENVFILE */
name|t
operator|=
literal|0
expr_stmt|;
name|invalid
operator|=
name|TRUE
expr_stmt|;
name|af_pwok
operator|=
name|opieaccessfile
argument_list|(
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
condition|)
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"User names can't start with '-'.\n"
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_AUTH
argument_list|,
literal|"Attempt to use invalid username: %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|invalid
operator|=
name|lookupuser
argument_list|()
expr_stmt|;
do|do
block|{
comment|/* If remote login take given name, otherwise prompt user for something. */
if|if
condition|(
name|invalid
operator|&&
operator|!
name|name
index|[
literal|0
index|]
condition|)
block|{
name|getloginname
argument_list|()
expr_stmt|;
name|invalid
operator|=
name|lookupuser
argument_list|()
expr_stmt|;
name|authsok
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"login name is +%s+, of length %d, [0] = %d"
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|fflag
condition|)
block|{
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
if|if
condition|(
name|uid
operator|!=
literal|0
operator|&&
name|uid
operator|!=
name|thisuser
operator|.
name|pw_uid
condition|)
name|fflag
operator|=
literal|0
expr_stmt|;
comment|/* Disallow automatic login for root. */
if|if
condition|(
name|thisuser
operator|.
name|pw_uid
operator|==
literal|0
condition|)
name|fflag
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* If no remote login authentication and a password exists for this user,        prompt for and verify a password. */
if|if
condition|(
operator|!
name|fflag
operator|&&
operator|(
name|rflag
operator|<
literal|1
operator|)
operator|&&
operator|*
name|thisuser
operator|.
name|pw_passwd
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"login name is +%s+, of length %d, [0] = %d\n"
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/* Attempt a one-time password challenge */
name|i
operator|=
name|opiechallenge
argument_list|(
operator|&
name|opie
argument_list|,
name|name
argument_list|,
name|opieprompt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|<
literal|0
operator|)
operator|||
operator|(
name|i
operator|>
literal|1
operator|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"error: opiechallenge() returned %d, errno=%d!\n"
argument_list|,
name|i
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|opieprompt
argument_list|)
expr_stmt|;
name|authsok
operator||=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|memcmp
argument_list|(
operator|&
name|thisuser
argument_list|,
operator|&
name|nouser
argument_list|,
sizeof|sizeof
argument_list|(
name|thisuser
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|host
index|[
literal|0
index|]
condition|)
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Invalid login attempt for %s on %s from %s."
argument_list|,
name|name
argument_list|,
name|tty
argument_list|,
name|host
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Invalid login attempt for %s on %s."
argument_list|,
name|name
argument_list|,
name|tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|af_pwok
operator|&&
name|opiealways
argument_list|(
name|thisuser
operator|.
name|pw_dir
argument_list|)
condition|)
name|authsok
operator||=
literal|2
expr_stmt|;
if|#
directive|if
name|DEBUG
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"af_pwok = %d, authsok = %d"
argument_list|,
name|af_pwok
argument_list|,
name|authsok
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
operator|!
name|authsok
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no authentication methods are available for %s!"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|#
directive|if
name|NEW_PROMPTS
if|if
condition|(
operator|(
name|authsok
operator|&
literal|1
operator|)
operator|||
operator|!
name|authsok
condition|)
name|printf
argument_list|(
literal|"Response"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|authsok
operator|&
literal|3
operator|)
operator|==
literal|3
operator|)
operator|||
operator|!
name|authsok
condition|)
name|printf
argument_list|(
literal|" or "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|authsok
operator|&
literal|2
operator|)
operator|||
operator|!
name|authsok
condition|)
name|printf
argument_list|(
literal|"Password"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opiereadpass
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|!
operator|(
name|authsok
operator|&
literal|2
operator|)
argument_list|)
condition|)
name|invalid
operator|=
name|TRUE
expr_stmt|;
else|#
directive|else
comment|/* NEW_PROMPTS */
if|if
condition|(
operator|!
operator|(
name|authsok
operator|&
literal|1
operator|)
operator|&&
name|authsok
condition|)
name|printf
argument_list|(
literal|"(OTP response required)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Password:"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opiereadpass
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|invalid
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
comment|/* NEW_PROMPTS */
if|if
condition|(
operator|!
name|buf
index|[
literal|0
index|]
operator|&&
operator|(
name|authsok
operator|&
literal|1
operator|)
condition|)
block|{
name|authsok
operator|&=
operator|~
literal|2
expr_stmt|;
comment|/* Null line entered, so display appropriate prompt& flush current 	   data. */
if|#
directive|if
name|NEW_PROMPTS
name|printf
argument_list|(
literal|"Response: "
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* NEW_PROMPTS */
name|printf
argument_list|(
literal|" (echo on)\nPassword:"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NEW_PROMPTS */
if|if
condition|(
operator|!
name|opiereadpass
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|invalid
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|authsok
operator|&
literal|1
condition|)
block|{
name|i
operator|=
name|opiegetsequence
argument_list|(
operator|&
name|opie
argument_list|)
expr_stmt|;
name|opiepassed
operator|=
operator|!
name|opieverify
argument_list|(
operator|&
name|opie
argument_list|,
name|buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"opiepassed = %d"
argument_list|,
name|opiepassed
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
if|if
condition|(
operator|!
name|invalid
condition|)
block|{
if|if
condition|(
operator|(
name|authsok
operator|&
literal|1
operator|)
operator|&&
name|opiepassed
condition|)
block|{
if|if
condition|(
name|i
operator|<
literal|10
condition|)
block|{
name|printf
argument_list|(
literal|"Warning: Re-initialize your OTP information"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|5
condition|)
name|printf
argument_list|(
literal|" NOW!"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|authsok
operator|&
literal|2
condition|)
block|{
name|pp
operator|=
name|crypt
argument_list|(
name|buf
argument_list|,
name|thisuser
operator|.
name|pw_passwd
argument_list|)
expr_stmt|;
name|invalid
operator|=
name|strcmp
argument_list|(
name|pp
argument_list|,
name|thisuser
operator|.
name|pw_passwd
argument_list|)
expr_stmt|;
block|}
else|else
name|invalid
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
comment|/* If user not super-user, check for logins disabled. */
if|if
condition|(
name|thisuser
operator|.
name|pw_uid
condition|)
block|{
if|if
condition|(
name|nlfd
operator|=
name|fopen
argument_list|(
name|_PATH_NOLOGIN
argument_list|,
literal|"r"
argument_list|)
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|nlfd
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If valid so far and root is logging in, see if root logins on this        terminal are permitted. */
if|if
condition|(
operator|!
name|invalid
operator|&&
operator|!
name|thisuser
operator|.
name|pw_uid
operator|&&
operator|!
name|rootterm
argument_list|(
name|tty
argument_list|)
condition|)
block|{
if|if
condition|(
name|host
index|[
literal|0
index|]
condition|)
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"ROOT LOGIN REFUSED ON %s FROM %.*s"
argument_list|,
name|tty
argument_list|,
name|HMAX
argument_list|,
name|host
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"ROOT LOGIN REFUSED ON %s"
argument_list|,
name|tty
argument_list|)
expr_stmt|;
name|invalid
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* If invalid, then log failure attempt data to appropriate system        logfiles and close the connection. */
if|if
condition|(
name|invalid
condition|)
block|{
name|printf
argument_list|(
literal|"Login incorrect\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|host
index|[
literal|0
index|]
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"LOGIN FAILURE ON %s FROM %.*s, %.*s"
argument_list|,
name|tty
argument_list|,
name|HMAX
argument_list|,
name|host
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"LOGIN FAILURE ON %s, %.*s"
argument_list|,
name|tty
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|t
operator|>=
literal|5
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|thisuser
operator|.
name|pw_shell
operator|==
literal|'\0'
condition|)
name|thisuser
operator|.
name|pw_shell
operator|=
literal|"/bin/sh"
expr_stmt|;
if|if
condition|(
operator|(
name|chdir
argument_list|(
name|thisuser
operator|.
name|pw_dir
argument_list|)
operator|<
literal|0
operator|)
operator|&&
operator|!
name|invalid
condition|)
block|{
if|if
condition|(
name|chdir
argument_list|(
literal|"/"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"No directory!\n"
argument_list|)
expr_stmt|;
name|invalid
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"No directory! %s\n"
argument_list|,
literal|"Logging in with HOME=/"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|thisuser
operator|.
name|pw_dir
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Remote login invalid must have been because of a restriction of some        sort, no extra chances. */
if|if
condition|(
name|invalid
condition|)
block|{
if|if
condition|(
operator|!
name|usererr
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
do|while
condition|(
name|invalid
condition|)
do|;
comment|/* Committed to login -- turn off timeout */
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QUOTA
if|if
condition|(
name|quota
argument_list|(
name|Q_SETUID
argument_list|,
name|thisuser
operator|.
name|pw_uid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINVAL
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EUSERS
condition|)
name|printf
argument_list|(
literal|"%s.\n%s.\n"
argument_list|,
literal|"Too many users logged on already"
argument_list|,
literal|"Try again later"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|errno
operator|==
name|EPROCLIM
condition|)
name|printf
argument_list|(
literal|"You have too many processes running.\n"
argument_list|)
expr_stmt|;
else|else
name|perror
argument_list|(
literal|"quota (Q_SETUID)"
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|opielogin
argument_list|(
name|tty
argument_list|,
name|name
argument_list|,
name|host
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't record login: tty %s, name %s, host %s"
argument_list|,
name|tty
argument_list|,
name|name
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|quietlog
operator|=
operator|!
name|access
argument_list|(
name|QUIET_LOGIN_FILE
argument_list|,
name|F_OK
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_LASTLOG_H
block|{
name|int
name|f
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|open
argument_list|(
name|lastlog
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|struct
name|lastlog
name|ll
decl_stmt|;
name|lseek
argument_list|(
name|f
argument_list|,
operator|(
name|long
operator|)
name|thisuser
operator|.
name|pw_uid
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|lastlog
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
sizeof|sizeof
argument_list|(
name|ll
argument_list|)
operator|==
name|read
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ll
argument_list|,
sizeof|sizeof
argument_list|(
name|ll
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|ll
operator|.
name|ll_time
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|!
name|quietlog
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Last login: %.*s "
argument_list|,
literal|24
operator|-
literal|5
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ctime
argument_list|(
operator|&
name|ll
operator|.
name|ll_time
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ll
operator|.
name|ll_host
operator|!=
literal|'\0'
condition|)
name|printf
argument_list|(
literal|"from %.*s\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|ll
operator|.
name|ll_host
argument_list|)
argument_list|,
name|ll
operator|.
name|ll_host
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"on %.*s\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|ll
operator|.
name|ll_line
argument_list|)
argument_list|,
name|ll
operator|.
name|ll_line
argument_list|)
expr_stmt|;
block|}
name|lseek
argument_list|(
name|f
argument_list|,
operator|(
name|long
operator|)
name|thisuser
operator|.
name|pw_uid
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|lastlog
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|ll
operator|.
name|ll_time
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ll
operator|.
name|ll_line
argument_list|,
name|tty
argument_list|,
sizeof|sizeof
argument_list|(
name|ll
operator|.
name|ll_line
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ll
operator|.
name|ll_host
argument_list|,
name|host
argument_list|,
sizeof|sizeof
argument_list|(
name|ll
operator|.
name|ll_host
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ll
argument_list|,
sizeof|sizeof
name|ll
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_LASTLOG_H */
name|chown
argument_list|(
name|tty
argument_list|,
name|thisuser
operator|.
name|pw_uid
argument_list|,
name|TTYGID
argument_list|(
name|thisuser
operator|.
name|pw_gid
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCSWINSZ
comment|/* POSIX does not specify any interface to set/get window sizes, so this is not portable.  It should work on most recent BSDish systems and the defines should protect it on older System Vish systems.  It does work under Solaris 2.4, though it isn't clear how many other SVR4 systems support it. I'd be interested in hearing of a more portable approach. rja */
if|if
condition|(
operator|!
name|hflag
operator|&&
operator|!
name|rflag
condition|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSWINSZ
argument_list|,
operator|&
name|win
argument_list|)
expr_stmt|;
comment|/* set window size to 0,0,0,0 */
endif|#
directive|endif
name|chmod
argument_list|(
name|tty
argument_list|,
literal|0622
argument_list|)
expr_stmt|;
name|setgid
argument_list|(
name|thisuser
operator|.
name|pw_gid
argument_list|)
expr_stmt|;
name|initgroups
argument_list|(
name|name
argument_list|,
name|thisuser
operator|.
name|pw_gid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QUOTA
name|quota
argument_list|(
name|Q_DOWARN
argument_list|,
name|thisuser
operator|.
name|pw_uid
argument_list|,
operator|(
name|dev_t
operator|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PERMSFILE
name|home
operator|=
name|thisuser
operator|.
name|pw_dir
expr_stmt|;
name|permsfile
argument_list|(
name|name
argument_list|,
name|tty
argument_list|,
name|thisuser
operator|.
name|pw_uid
argument_list|,
name|thisuser
operator|.
name|pw_gid
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PERMSFILE */
name|setuid
argument_list|(
name|thisuser
operator|.
name|pw_uid
argument_list|)
expr_stmt|;
comment|/* destroy environment unless user has asked to preserve it */
if|if
condition|(
operator|!
name|pflag
condition|)
name|environ
operator|=
name|envinit
expr_stmt|;
name|setenv
argument_list|(
literal|"HOME"
argument_list|,
name|thisuser
operator|.
name|pw_dir
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
literal|"SHELL"
argument_list|,
name|thisuser
operator|.
name|pw_shell
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|term
index|[
literal|0
index|]
condition|)
block|{
if|#
directive|if
name|HAVE_GETTTYNAM
comment|/*  * The getttynam() call and the ttyent structure first appeared in 4.3 BSD.  * They are not portable to System V systems such as Solaris 2.x.  *         rja  */
specifier|register
name|struct
name|ttyent
modifier|*
name|t
decl_stmt|;
specifier|register
name|char
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|c
operator|=
name|strrchr
argument_list|(
name|tty
argument_list|,
literal|'/'
argument_list|)
condition|)
name|c
operator|++
expr_stmt|;
else|else
name|c
operator|=
name|tty
expr_stmt|;
if|if
condition|(
name|t
operator|=
name|getttynam
argument_list|(
name|c
argument_list|)
condition|)
name|strncpy
argument_list|(
name|term
argument_list|,
name|t
operator|->
name|ty_type
argument_list|,
sizeof|sizeof
argument_list|(
name|term
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* HAVE_GETTTYNAM */
name|strcpy
argument_list|(
name|term
argument_list|,
literal|"unknown"
argument_list|)
expr_stmt|;
block|}
name|setenv
argument_list|(
literal|"USER"
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
literal|"LOGNAME"
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
literal|"PATH"
argument_list|,
name|DEFAULT_PATH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|term
index|[
literal|0
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"setting TERM=%s"
argument_list|,
name|term
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|setenv
argument_list|(
literal|"TERM"
argument_list|,
name|term
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_LOGIN_ENVFILE
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|f
operator|=
name|fopen
argument_list|(
name|HAVE_LOGIN_ENVFILE
argument_list|,
literal|"r"
argument_list|)
condition|)
block|{
name|char
name|line
index|[
literal|128
index|]
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|c2
decl_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
operator|-
literal|1
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|c
operator|=
name|line
expr_stmt|;
while|while
condition|(
operator|*
name|c
operator|&&
operator|(
name|isalnum
argument_list|(
operator|*
name|c
argument_list|)
operator|||
operator|(
operator|*
name|c
operator|==
literal|'_'
operator|)
operator|)
condition|)
name|c
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|==
literal|'='
condition|)
block|{
operator|*
operator|(
name|c
operator|++
operator|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c2
operator|=
name|strchr
argument_list|(
name|c
argument_list|,
literal|';'
argument_list|)
condition|)
operator|*
name|c2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c2
operator|=
name|strchr
argument_list|(
name|c
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|c2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c2
operator|=
name|strchr
argument_list|(
name|c
argument_list|,
literal|' '
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|c2
operator|=
name|strchr
argument_list|(
name|c
argument_list|,
literal|'\t'
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|setenv
argument_list|(
name|line
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"setenv() failed -- environment full?\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_LOGIN_ENVFILE */
if|if
condition|(
operator|(
name|namep
operator|=
name|strrchr
argument_list|(
name|thisuser
operator|.
name|pw_shell
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|namep
operator|=
name|thisuser
operator|.
name|pw_shell
expr_stmt|;
else|else
name|namep
operator|++
expr_stmt|;
name|strcat
argument_list|(
name|minusnam
argument_list|,
name|namep
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty
index|[
sizeof|sizeof
argument_list|(
literal|"tty"
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'d'
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"DIALUP %s, %s"
argument_list|,
name|tty
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|thisuser
operator|.
name|pw_uid
condition|)
if|if
condition|(
name|host
index|[
literal|0
index|]
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"ROOT LOGIN %s FROM %.*s"
argument_list|,
name|tty
argument_list|,
name|HMAX
argument_list|,
name|host
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"ROOT LOGIN %s"
argument_list|,
name|tty
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|HAVE_MOTD_IN_PROFILE
if|if
condition|(
operator|!
name|quietlog
condition|)
block|{
name|FILE
modifier|*
name|mf
decl_stmt|;
specifier|register
name|c
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|catch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mf
operator|=
name|fopen
argument_list|(
name|MOTD_FILE
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|mf
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
operator|!
name|stopmotd
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|mf
argument_list|)
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !HAVE_MOTD_IN_PROFILE */
if|#
directive|if
operator|!
name|HAVE_MAILCHECK_IN_PROFILE
if|if
condition|(
operator|!
name|quietlog
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|strncpy
argument_list|(
name|buf
argument_list|,
name|PATH_MAIL
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|buf
operator|+
name|len
operator|-
literal|1
operator|)
operator|!=
literal|'/'
condition|)
block|{
operator|*
operator|(
name|buf
operator|+
name|len
operator|)
operator|=
literal|'/'
expr_stmt|;
operator|*
operator|(
name|buf
operator|+
name|len
operator|+
literal|1
operator|)
operator|=
literal|0
expr_stmt|;
block|}
name|strcat
argument_list|(
name|buf
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"statting %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
operator|!
name|stat
argument_list|(
name|buf
argument_list|,
operator|&
name|st
argument_list|)
operator|&&
name|st
operator|.
name|st_size
condition|)
name|printf
argument_list|(
literal|"You have %smail.\n"
argument_list|,
operator|(
name|st
operator|.
name|st_mtime
operator|>
name|st
operator|.
name|st_atime
operator|)
condition|?
literal|"new "
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !HAVE_MAILCHECK_IN_PROFILE */
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|attr
operator|.
name|c_lflag
operator||=
operator|(
name|ISIG
operator||
name|IEXTEN
operator|)
expr_stmt|;
name|catchexit
argument_list|()
expr_stmt|;
name|execlp
argument_list|(
name|thisuser
operator|.
name|pw_shell
argument_list|,
name|minusnam
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|thisuser
operator|.
name|pw_shell
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"No shell\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

end_unit

