begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* opiekey.c: Stand-alone program for computing responses to OTP challenges.   Takes a sequence number and seed (presumably from an OPIE challenge)  as command line arguments, prompts for the user's secret pass phrase,  and outputs a response.  %%% portions-copyright-cmetz-96 Portions of this software are Copyright 1996-1999 by Craig Metz, All Rights Reserved. The Inner Net License Version 2 applies to these portions of the software. You should have received a copy of the license with this software. If you didn't get a copy, you may request one from<license@inner.net>.  Portions of this software are Copyright 1995 by Randall Atkinson and Dan McDonald, All Rights Reserved. All Rights under this copyright are assigned to the U.S. Naval Research Laboratory (NRL). The NRL Copyright Notice and License Agreement applies to this software.  	History:  	Modified by cmetz for OPIE 2.4. Use struct opie_key for key blocks. 	Modified by cmetz for OPIE 2.31. Renamed "init" and RESPONSE_INIT 	        to "init-hex" and RESPONSE_INIT_HEX. Removed active attack 		protection support. 	Modified by cmetz for OPIE 2.3. OPIE_PASS_MAX changed to 		OPIE_SECRET_MAX. Added extended responses, which created 		lots of changes. Eliminated extra variable. Added -x and 		-t to help. Added -f flag. Added SHA support. 	Modified by cmetz for OPIE 2.22. Print newline after seed too long 	        message. Check for minimum seed length. Correct a grammar 		error.         Modified at NRL for OPIE 2.2. Check opiereadpass() return.                 Change opiereadpass() calls to add echo arg. Use FUNCTION                 definition et al. Check seed length here, too. Added back 		hex output. Reworked final output function. 	Modified at NRL for OPIE 2.0. 	Written at Bellcore for the S/Key Version 1 software distribution 		(skey.c).  $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opie_cfg.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"opie.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__MSDOS__
end_ifdef

begin_include
include|#
directive|include
file|<dos.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_FCNTL_H
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_FCNTL_H */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|optind
decl_stmt|,
name|opterr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|aflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|algnames
index|[]
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"SHA-1"
block|,
literal|"MD4"
block|,
literal|"MD5"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|algids
index|[]
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"sha1"
block|,
literal|"md4"
block|,
literal|"md5"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******** Begin real source code ***************/
end_comment

begin_decl_stmt
specifier|static
name|VOIDRET
name|usage
name|FUNCTION
argument_list|(
operator|(
name|s
operator|)
argument_list|,
name|char
operator|*
name|s
argument_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-v] [-h] [-f] [-x] [-t type] [-4 | -5 | -s] [-a] [-n count] sequence_number seed\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_define
define|#
directive|define
name|RESPONSE_STANDARD
value|0
end_define

begin_define
define|#
directive|define
name|RESPONSE_WORD
value|1
end_define

begin_define
define|#
directive|define
name|RESPONSE_HEX
value|2
end_define

begin_define
define|#
directive|define
name|RESPONSE_INIT_HEX
value|3
end_define

begin_define
define|#
directive|define
name|RESPONSE_INIT_WORD
value|4
end_define

begin_define
define|#
directive|define
name|RESPONSE_UNKNOWN
value|5
end_define

begin_struct
struct|struct
name|_rtrans
block|{
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|_rtrans
name|rtrans
index|[]
init|=
block|{
block|{
name|RESPONSE_WORD
block|,
literal|"word"
block|}
block|,
block|{
name|RESPONSE_HEX
block|,
literal|"hex"
block|}
block|,
block|{
name|RESPONSE_INIT_HEX
block|,
literal|"init-hex"
block|}
block|,
block|{
name|RESPONSE_INIT_WORD
block|,
literal|"init-word"
block|}
block|,
block|{
name|RESPONSE_STANDARD
block|,
literal|""
block|}
block|,
block|{
name|RESPONSE_STANDARD
block|,
literal|"standard"
block|}
block|,
block|{
name|RESPONSE_STANDARD
block|,
literal|"otp"
block|}
block|,
block|{
name|RESPONSE_UNKNOWN
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getsecret
name|FUNCTION
argument_list|(
operator|(
name|secret
operator|,
name|promptextra
operator|,
name|retype
operator|)
argument_list|,
name|char
operator|*
name|secret
name|AND
name|char
operator|*
name|promptextra
name|AND
name|int
name|flags
argument_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Enter %ssecret pass phrase: "
argument_list|,
name|promptextra
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opiereadpass
argument_list|(
name|secret
argument_list|,
name|OPIE_SECRET_MAX
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error reading %ssecret pass phrase!\n"
argument_list|,
name|promptextra
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|secret
index|[
literal|0
index|]
operator|&&
operator|(
name|flags
operator|&
literal|1
operator|)
condition|)
block|{
name|char
name|verify
index|[
name|OPIE_SECRET_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Again %ssecret pass phrase: "
argument_list|,
name|promptextra
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opiereadpass
argument_list|(
name|verify
argument_list|,
name|OPIE_SECRET_MAX
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error reading %ssecret pass phrase!\n"
argument_list|,
name|promptextra
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|verify
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|verify
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|secret
argument_list|,
literal|0
argument_list|,
name|OPIE_SECRET_MAX
operator|+
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verify
index|[
literal|0
index|]
operator|&&
name|strcmp
argument_list|(
name|verify
argument_list|,
name|secret
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"They don't match. Try again.\n"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|verify
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|verify
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|secret
argument_list|,
literal|0
argument_list|,
name|OPIE_SECRET_MAX
operator|+
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|verify
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|verify
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
literal|2
operator|)
operator|&&
operator|!
name|aflag
operator|&&
name|opiepasscheck
argument_list|(
name|secret
argument_list|)
condition|)
block|{
name|memset
argument_list|(
name|secret
argument_list|,
literal|0
argument_list|,
name|OPIE_SECRET_MAX
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Secret pass phrases must be between %d and %d characters long.\n"
argument_list|,
name|OPIE_SECRET_MIN
argument_list|,
name|OPIE_SECRET_MAX
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
decl|main
name|FUNCTION
argument_list|(
operator|(
name|argc
operator|,
name|argv
operator|)
argument_list|,
name|int
name|argc
name|AND
name|char
operator|*
name|argv
index|[]
argument_list|)
block|{
comment|/* variable declarations */
name|unsigned
name|algorithm
init|=
name|MDX
decl_stmt|;
comment|/* default algorithm per Makefile's MDX 				   symbol */
name|int
name|keynum
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|;
name|char
name|secret
index|[
name|OPIE_SECRET_MAX
operator|+
literal|1
index|]
decl_stmt|,
name|newsecret
index|[
name|OPIE_SECRET_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|opie_otpkey
name|key
decl_stmt|,
name|newkey
decl_stmt|;
name|char
modifier|*
name|seed
decl_stmt|,
name|newseed
index|[
name|OPIE_SEED_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|response
index|[
name|OPIE_RESPONSE_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|slash
decl_stmt|;
name|int
name|hex
init|=
literal|0
decl_stmt|;
name|int
name|type
init|=
name|RESPONSE_STANDARD
decl_stmt|;
name|int
name|force
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|slash
operator|=
name|strchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
condition|)
name|slash
operator|++
expr_stmt|;
else|else
name|slash
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|slash
argument_list|,
literal|"key"
argument_list|)
operator|||
name|strstr
argument_list|(
name|slash
argument_list|,
literal|"md4"
argument_list|)
condition|)
name|algorithm
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|slash
argument_list|,
literal|"md5"
argument_list|)
condition|)
name|algorithm
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|slash
argument_list|,
literal|"sha"
argument_list|)
condition|)
name|algorithm
operator|=
literal|3
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"fhvn:x45at:s"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|'v'
case|:
name|opieversion
argument_list|()
expr_stmt|;
case|case
literal|'n'
case|:
name|count
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|hex
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|#
directive|if
name|INSECURE_OVERRIDE
name|force
operator|=
literal|1
expr_stmt|;
else|#
directive|else
comment|/* INSECURE_OVERRIDE */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Sorry, but the -f option is not supported by this build of OPIE.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* INSECURE_OVERRIDE */
break|break;
case|case
literal|'4'
case|:
comment|/* use MD4 algorithm */
name|algorithm
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'5'
case|:
comment|/* use MD5 algorithm */
name|algorithm
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|aflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
block|{
name|struct
name|_rtrans
modifier|*
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
name|rtrans
init|;
name|r
operator|->
name|name
operator|&&
name|strcmp
argument_list|(
name|r
operator|->
name|name
argument_list|,
name|optarg
argument_list|)
condition|;
name|r
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|r
operator|->
name|name
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: unknown response type.\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|r
operator|->
name|type
expr_stmt|;
block|}
break|break;
case|case
literal|'s'
case|:
name|algorithm
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|argc
operator|-
name|optind
operator|)
operator|<
literal|2
condition|)
name|usage
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Using the %s algorithm to compute response.\n"
argument_list|,
name|algnames
index|[
name|algorithm
index|]
argument_list|)
expr_stmt|;
comment|/* get sequence number, which is next-to-last parameter */
name|keynum
operator|=
name|atoi
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|keynum
operator|<
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Sequence number %s is not positive.\n"
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* get seed string, which is last parameter */
name|seed
operator|=
name|argv
index|[
name|optind
operator|+
literal|1
index|]
expr_stmt|;
block|{
name|i
operator|=
name|strlen
argument_list|(
name|seed
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|OPIE_SEED_MAX
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Seeds must be less than %d characters long.\n"
argument_list|,
name|OPIE_SEED_MAX
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|OPIE_SEED_MIN
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Seeds must be greater than %d characters long.\n"
argument_list|,
name|OPIE_SEED_MIN
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Reminder: Don't use opiekey from telnet or dial-in sessions.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opieinsecure
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Sorry, but you don't seem to be on the console or a secure terminal.\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|INSECURE_OVERRIDE
if|if
condition|(
name|force
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: Continuing could disclose your secret pass phrase to an attacker!\n"
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* INSECURE_OVERRIDE */
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|type
operator|==
name|RESPONSE_INIT_HEX
operator|)
operator|||
operator|(
name|type
operator|==
name|RESPONSE_INIT_WORD
operator|)
condition|)
block|{
if|#
directive|if
name|RETYPE
name|getsecret
argument_list|(
name|secret
argument_list|,
literal|"old "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* RETYPE */
name|getsecret
argument_list|(
name|secret
argument_list|,
literal|"old "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RETYPE */
name|getsecret
argument_list|(
name|newsecret
argument_list|,
literal|"new "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newsecret
index|[
literal|0
index|]
condition|)
name|strcpy
argument_list|(
name|newsecret
argument_list|,
name|secret
argument_list|)
expr_stmt|;
if|if
condition|(
name|opienewseed
argument_list|(
name|strcpy
argument_list|(
name|newseed
argument_list|,
name|seed
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error updating seed.\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|opiekeycrunch
argument_list|(
name|algorithm
argument_list|,
operator|&
name|newkey
argument_list|,
name|newseed
argument_list|,
name|newsecret
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: key crunch failed (1)\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|499
condition|;
name|i
operator|++
control|)
name|opiehash
argument_list|(
operator|&
name|newkey
argument_list|,
name|algorithm
argument_list|)
expr_stmt|;
block|}
else|else
if|#
directive|if
name|RETYPE
name|getsecret
argument_list|(
name|secret
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* RETYPE */
name|getsecret
argument_list|(
name|secret
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RETYPE */
comment|/* Crunch seed and secret password into starting key normally */
if|if
condition|(
name|opiekeycrunch
argument_list|(
name|algorithm
argument_list|,
operator|&
name|key
argument_list|,
name|seed
argument_list|,
name|secret
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: key crunch failed\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
operator|(
name|keynum
operator|-
name|count
operator|)
condition|;
name|i
operator|++
control|)
name|opiehash
argument_list|(
operator|&
name|key
argument_list|,
name|algorithm
argument_list|)
expr_stmt|;
block|{
name|char
name|buf
index|[
name|OPIE_SEED_MAX
operator|+
literal|48
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|c
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<=
name|keynum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|count
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"%d: %s"
argument_list|,
name|i
argument_list|,
operator|(
name|type
operator|==
name|RESPONSE_STANDARD
operator|)
condition|?
literal|""
else|:
literal|"\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RESPONSE_STANDARD
case|:
if|if
condition|(
name|hex
condition|)
name|opiebtoh
argument_list|(
name|response
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
else|else
name|opiebtoe
argument_list|(
name|response
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESPONSE_WORD
case|:
name|strcpy
argument_list|(
name|response
argument_list|,
literal|"word:"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|response
argument_list|,
name|opiebtoe
argument_list|(
name|buf
argument_list|,
operator|&
name|key
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESPONSE_HEX
case|:
name|strcpy
argument_list|(
name|response
argument_list|,
literal|"hex:"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|response
argument_list|,
name|opiebtoh
argument_list|(
name|buf
argument_list|,
operator|&
name|key
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESPONSE_INIT_HEX
case|:
case|case
name|RESPONSE_INIT_WORD
case|:
if|if
condition|(
name|type
operator|==
name|RESPONSE_INIT_HEX
condition|)
block|{
name|strcpy
argument_list|(
name|response
argument_list|,
literal|"init-hex:"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|response
argument_list|,
name|opiebtoh
argument_list|(
name|buf
argument_list|,
operator|&
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|":%s 499 %s:"
argument_list|,
name|algids
index|[
name|algorithm
index|]
argument_list|,
name|newseed
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|response
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|response
argument_list|,
name|opiebtoh
argument_list|(
name|buf
argument_list|,
operator|&
name|newkey
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|response
argument_list|,
literal|"init-word:"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|response
argument_list|,
name|opiebtoe
argument_list|(
name|buf
argument_list|,
operator|&
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|":%s 499 %s:"
argument_list|,
name|algids
index|[
name|algorithm
index|]
argument_list|,
name|newseed
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|response
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|response
argument_list|,
name|opiebtoe
argument_list|(
name|buf
argument_list|,
operator|&
name|newkey
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|puts
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|opiehash
argument_list|(
operator|&
name|key
argument_list|,
name|algorithm
argument_list|)
expr_stmt|;
block|}
block|}
name|memset
argument_list|(
name|secret
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|secret
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|newsecret
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|newsecret
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|error
label|:
name|memset
argument_list|(
name|secret
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|secret
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|newsecret
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|newsecret
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_decl_stmt

end_unit

