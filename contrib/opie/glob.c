begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* glob.c: The csh et al glob pattern matching routines.  %%% copyright-cmetz-96 This software is Copyright 1996-1998 by Craig Metz, All Rights Reserved. The Inner Net License Version 2 applies to this software. You should have received a copy of the license with this software. If you didn't get a copy, you may request one from<license@inner.net>.  Portions of this software are Copyright 1995 by Randall Atkinson and Dan McDonald, All Rights Reserved. All Rights under this copyright are assigned to the U.S. Naval Research Laboratory (NRL). The NRL Copyright Notice and License Agreement applies to this software.  	History:  	Modified by cmetz for OPIE 2.32. Remove include of dirent.h here; it's 		done already (and conditionally) in opie_cfg.h. 	Modified by cmetz for OPIE 2.2. Use FUNCTION declaration et al.              Remove useless strings. Prototype right. 	Modified at NRL for OPIE 2.0. 	Originally from BSD. */
end_comment

begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by the University of  *      California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * C-shell glob for random programs.  */
end_comment

begin_include
include|#
directive|include
file|"opie_cfg.h"
end_include

begin_if
if|#
directive|if
name|HAVE_SYS_PARAM_H
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_PARAM_H */
end_comment

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_if
if|#
directive|if
name|HAVE_PWD_H
end_if

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PWD_H */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_if
if|#
directive|if
name|HAVE_LIMITS_H
end_if

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LIMITS_H */
end_comment

begin_include
include|#
directive|include
file|"opie.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NCARGS
end_ifndef

begin_define
define|#
directive|define
name|NCARGS
value|600
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NCARGS */
end_comment

begin_define
define|#
directive|define
name|QUOTE
value|0200
end_define

begin_define
define|#
directive|define
name|TRIM
value|0177
end_define

begin_define
define|#
directive|define
name|eq
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(strcmp((a),(b)) == (0))
end_define

begin_define
define|#
directive|define
name|GAVSIZ
value|(NCARGS/6)
end_define

begin_define
define|#
directive|define
name|isdir
parameter_list|(
name|d
parameter_list|)
value|(((d.st_mode)& S_IFMT) == S_IFDIR)
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|gargv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to the (stack) arglist */
end_comment

begin_decl_stmt
specifier|static
name|int
name|gargc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number args in gargv */
end_comment

begin_decl_stmt
specifier|static
name|int
name|gnleft
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|gflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|letter
name|__P
argument_list|(
operator|(
specifier|register
name|char
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|digit
name|__P
argument_list|(
operator|(
specifier|register
name|char
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|any
name|__P
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|blklen
name|__P
argument_list|(
operator|(
specifier|register
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VOIDRET
name|blkfree
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|strspl
name|__P
argument_list|(
operator|(
specifier|register
name|char
operator|*
operator|,
specifier|register
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tglob
name|__P
argument_list|(
operator|(
specifier|register
name|char
name|c
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|strend
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|globcnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|globchars
init|=
literal|"`{[*?"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|globerr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|home
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|gpath
decl_stmt|,
modifier|*
name|gpathp
decl_stmt|,
modifier|*
name|lastgpathp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|globbed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|entp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|sortbas
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|amatch
name|__P
argument_list|(
operator|(
name|char
operator|*
name|p
operator|,
name|char
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|execbrc
name|__P
argument_list|(
operator|(
specifier|register
name|char
operator|*
name|p
operator|,
specifier|register
name|char
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VOIDRET
name|opiefatal
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|copyblk
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|match
name|FUNCTION
argument_list|(
operator|(
name|s
operator|,
name|p
operator|)
argument_list|,
name|char
operator|*
name|s
name|AND
name|char
operator|*
name|p
argument_list|)
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|sentp
decl_stmt|;
name|char
name|sglobbed
init|=
name|globbed
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
operator|&&
operator|*
name|p
operator|!=
literal|'.'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sentp
operator|=
name|entp
expr_stmt|;
name|entp
operator|=
name|s
expr_stmt|;
name|c
operator|=
name|amatch
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|entp
operator|=
name|sentp
expr_stmt|;
name|globbed
operator|=
name|sglobbed
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|Gmatch
name|FUNCTION
argument_list|(
operator|(
name|s
operator|,
name|p
operator|)
argument_list|,
specifier|register
name|char
operator|*
name|s
name|AND
specifier|register
name|char
operator|*
name|p
argument_list|)
block|{
specifier|register
name|int
name|scc
decl_stmt|;
name|int
name|ok
decl_stmt|,
name|lc
decl_stmt|;
name|int
name|c
decl_stmt|,
name|cc
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|scc
operator|=
operator|*
name|s
operator|++
operator|&
name|TRIM
expr_stmt|;
switch|switch
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
block|{
case|case
literal|'['
case|:
name|ok
operator|=
literal|0
expr_stmt|;
name|lc
operator|=
literal|077777
expr_stmt|;
while|while
condition|(
name|cc
operator|=
operator|*
name|p
operator|++
condition|)
block|{
if|if
condition|(
name|cc
operator|==
literal|']'
condition|)
block|{
if|if
condition|(
name|ok
condition|)
break|break;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|cc
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|lc
operator|<=
name|scc
operator|&&
name|scc
operator|<=
operator|*
name|p
operator|++
condition|)
name|ok
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scc
operator|==
operator|(
name|lc
operator|=
name|cc
operator|)
condition|)
name|ok
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
if|if
condition|(
name|ok
condition|)
name|p
operator|--
expr_stmt|;
else|else
return|return
literal|0
return|;
continue|continue;
case|case
literal|'*'
case|:
if|if
condition|(
operator|!
operator|*
name|p
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|s
operator|--
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
name|Gmatch
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0
case|:
return|return
operator|(
name|scc
operator|==
literal|0
operator|)
return|;
default|default:
if|if
condition|(
operator|(
name|c
operator|&
name|TRIM
operator|)
operator|!=
name|scc
condition|)
return|return
operator|(
literal|0
operator|)
return|;
continue|continue;
case|case
literal|'?'
case|:
if|if
condition|(
name|scc
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
continue|continue;
block|}
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOIDRET
name|Gcat
name|FUNCTION
argument_list|(
operator|(
name|s1
operator|,
name|s2
operator|)
argument_list|,
specifier|register
name|char
operator|*
name|s1
name|AND
specifier|register
name|char
operator|*
name|s2
argument_list|)
block|{
specifier|register
name|int
name|len
init|=
name|strlen
argument_list|(
name|s1
argument_list|)
operator|+
name|strlen
argument_list|(
name|s2
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|len
operator|>=
name|gnleft
operator|||
name|gargc
operator|>=
name|GAVSIZ
operator|-
literal|1
condition|)
name|globerr
operator|=
literal|"Arguments too long"
expr_stmt|;
else|else
block|{
name|gargc
operator|++
expr_stmt|;
name|gnleft
operator|-=
name|len
expr_stmt|;
name|gargv
index|[
name|gargc
index|]
operator|=
literal|0
expr_stmt|;
name|gargv
index|[
name|gargc
operator|-
literal|1
index|]
operator|=
name|strspl
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOIDRET
name|addpath
name|FUNCTION
argument_list|(
operator|(
name|c
operator|)
argument_list|,
name|char
name|c
argument_list|)
block|{
if|if
condition|(
name|gpathp
operator|>=
name|lastgpathp
condition|)
name|globerr
operator|=
literal|"Pathname too long"
expr_stmt|;
else|else
block|{
operator|*
name|gpathp
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|gpathp
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOIDRET
name|rscan
name|FUNCTION
argument_list|(
operator|(
name|t
operator|,
name|f
operator|)
argument_list|,
specifier|register
name|char
operator|*
operator|*
name|t
name|AND
name|int
argument_list|(
argument|*f
argument_list|)
name|__P
argument_list|(
operator|(
name|char
operator|)
argument_list|)
argument_list|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
name|c
decl_stmt|;
while|while
condition|(
name|p
operator|=
operator|*
name|t
operator|++
condition|)
block|{
if|if
condition|(
name|f
operator|==
name|tglob
condition|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'~'
condition|)
name|gflag
operator||=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|eq
argument_list|(
name|p
argument_list|,
literal|"{"
argument_list|)
operator|||
name|eq
argument_list|(
name|p
argument_list|,
literal|"{}"
argument_list|)
condition|)
continue|continue;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
call|(
modifier|*
name|f
call|)
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tglob
name|FUNCTION
argument_list|(
operator|(
name|c
operator|)
argument_list|,
specifier|register
name|char
name|c
argument_list|)
block|{
if|if
condition|(
name|any
argument_list|(
name|c
argument_list|,
name|globchars
argument_list|)
condition|)
name|gflag
operator||=
name|c
operator|==
literal|'{'
condition|?
literal|2
else|:
literal|1
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|letter
name|FUNCTION
argument_list|(
operator|(
name|c
operator|)
argument_list|,
specifier|register
name|char
name|c
argument_list|)
block|{
return|return
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
operator|||
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
operator|||
name|c
operator|==
literal|'_'
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|digit
name|FUNCTION
argument_list|(
operator|(
name|c
operator|)
argument_list|,
specifier|register
name|char
name|c
argument_list|)
block|{
return|return
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|any
name|FUNCTION
argument_list|(
operator|(
name|c
operator|,
name|s
operator|)
argument_list|,
name|int
name|c
name|AND
name|char
operator|*
name|s
argument_list|)
block|{
while|while
condition|(
operator|*
name|s
condition|)
if|if
condition|(
operator|*
name|s
operator|++
operator|==
name|c
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|blklen
name|FUNCTION
argument_list|(
operator|(
name|av
operator|)
argument_list|,
specifier|register
name|char
operator|*
operator|*
name|av
argument_list|)
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|av
operator|++
condition|)
name|i
operator|++
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|blkcpy
name|FUNCTION
argument_list|(
operator|(
name|oav
operator|,
name|bv
operator|)
argument_list|,
name|char
operator|*
operator|*
name|oav
name|AND
specifier|register
name|char
operator|*
operator|*
name|bv
argument_list|)
block|{
specifier|register
name|char
modifier|*
modifier|*
name|av
init|=
name|oav
decl_stmt|;
while|while
condition|(
operator|*
name|av
operator|++
operator|=
operator|*
name|bv
operator|++
condition|)
continue|continue;
return|return
operator|(
name|oav
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|VOIDRET
name|blkfree
name|FUNCTION
argument_list|(
operator|(
name|av0
operator|)
argument_list|,
name|char
operator|*
operator|*
name|av0
argument_list|)
block|{
specifier|register
name|char
modifier|*
modifier|*
name|av
init|=
name|av0
decl_stmt|;
while|while
condition|(
operator|*
name|av
condition|)
name|free
argument_list|(
operator|*
name|av
operator|++
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|strspl
name|FUNCTION
argument_list|(
operator|(
name|cp
operator|,
name|dp
operator|)
argument_list|,
specifier|register
name|char
operator|*
name|cp
name|AND
specifier|register
name|char
operator|*
name|dp
argument_list|)
block|{
specifier|register
name|char
modifier|*
name|ep
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
name|strlen
argument_list|(
name|dp
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ep
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|opiefatal
argument_list|(
literal|"Out of memory"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ep
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ep
argument_list|,
name|dp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ep
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|copyblk
name|FUNCTION
argument_list|(
operator|(
name|v
operator|)
argument_list|,
name|char
operator|*
operator|*
name|v
argument_list|)
block|{
specifier|register
name|char
modifier|*
modifier|*
name|nv
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|blklen
argument_list|(
name|v
argument_list|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|nv
operator|==
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
condition|)
name|opiefatal
argument_list|(
literal|"Out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|blkcpy
argument_list|(
name|nv
argument_list|,
name|v
argument_list|)
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|strend
name|FUNCTION
argument_list|(
operator|(
name|cp
operator|)
argument_list|,
specifier|register
name|char
operator|*
name|cp
argument_list|)
block|{
while|while
condition|(
operator|*
name|cp
condition|)
name|cp
operator|++
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Extract a home directory from the password file  * The argument points to a buffer where the name of the  * user whose home directory is sought is currently.  * We write the home directory of the user back there.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|gethdir
name|FUNCTION
argument_list|(
operator|(
name|home
operator|)
argument_list|,
name|char
operator|*
name|home
argument_list|)
block|{
specifier|register
name|struct
name|passwd
modifier|*
name|pp
init|=
name|getpwnam
argument_list|(
name|home
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|pp
operator|||
name|home
operator|+
name|strlen
argument_list|(
name|pp
operator|->
name|pw_dir
argument_list|)
operator|>=
name|lastgpathp
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|strcpy
argument_list|(
name|home
argument_list|,
name|pp
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOIDRET
name|ginit
name|FUNCTION
argument_list|(
operator|(
name|agargv
operator|)
argument_list|,
name|char
operator|*
operator|*
name|agargv
argument_list|)
block|{
name|agargv
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|gargv
operator|=
name|agargv
expr_stmt|;
name|sortbas
operator|=
name|agargv
expr_stmt|;
name|gargc
operator|=
literal|0
expr_stmt|;
name|gnleft
operator|=
name|NCARGS
operator|-
literal|4
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOIDRET
name|sort
name|FUNCTION_NOARGS
block|{
specifier|register
name|char
modifier|*
modifier|*
name|p1
decl_stmt|,
modifier|*
modifier|*
name|p2
decl_stmt|,
modifier|*
name|c
decl_stmt|;
name|char
modifier|*
modifier|*
name|Gvp
init|=
operator|&
name|gargv
index|[
name|gargc
index|]
decl_stmt|;
name|p1
operator|=
name|sortbas
expr_stmt|;
while|while
condition|(
name|p1
operator|<
name|Gvp
operator|-
literal|1
condition|)
block|{
name|p2
operator|=
name|p1
expr_stmt|;
while|while
condition|(
operator|++
name|p2
operator|<
name|Gvp
condition|)
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|p1
argument_list|,
operator|*
name|p2
argument_list|)
operator|>
literal|0
condition|)
name|c
operator|=
operator|*
name|p1
operator|,
operator|*
name|p1
operator|=
operator|*
name|p2
operator|,
operator|*
name|p2
operator|=
name|c
expr_stmt|;
name|p1
operator|++
expr_stmt|;
block|}
name|sortbas
operator|=
name|Gvp
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOIDRET
name|matchdir
name|FUNCTION
argument_list|(
operator|(
name|pattern
operator|)
argument_list|,
name|char
operator|*
name|pattern
argument_list|)
block|{
name|struct
name|stat
name|stb
decl_stmt|;
specifier|register
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|dirp
operator|=
name|opendir
argument_list|(
operator|*
name|gpath
operator|==
literal|'\0'
condition|?
literal|"."
else|:
name|gpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|globbed
condition|)
return|return;
goto|goto
name|patherr2
goto|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|linux
argument_list|)
if|if
condition|(
name|fstat
argument_list|(
name|dirp
operator|->
name|dd_fd
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|patherr1
goto|;
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|stb
argument_list|)
condition|)
block|{
name|errno
operator|=
name|ENOTDIR
expr_stmt|;
goto|goto
name|patherr1
goto|;
block|}
endif|#
directive|endif
comment|/* !defined(linux) */
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_ino
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|match
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|pattern
argument_list|)
condition|)
block|{
name|Gcat
argument_list|(
name|gpath
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|globcnt
operator|++
expr_stmt|;
block|}
block|}
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return;
name|patherr1
label|:
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
name|patherr2
label|:
name|globerr
operator|=
literal|"Bad directory components"
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOIDRET
name|expand
name|FUNCTION
argument_list|(
operator|(
name|as
operator|)
argument_list|,
name|char
operator|*
name|as
argument_list|)
block|{
specifier|register
name|char
modifier|*
name|cs
decl_stmt|;
specifier|register
name|char
modifier|*
name|sgpathp
decl_stmt|,
modifier|*
name|oldcs
decl_stmt|;
name|struct
name|stat
name|stb
decl_stmt|;
name|sgpathp
operator|=
name|gpathp
expr_stmt|;
name|cs
operator|=
name|as
expr_stmt|;
if|if
condition|(
operator|*
name|cs
operator|==
literal|'~'
operator|&&
name|gpathp
operator|==
name|gpath
condition|)
block|{
name|addpath
argument_list|(
literal|'~'
argument_list|)
expr_stmt|;
for|for
control|(
name|cs
operator|++
init|;
name|letter
argument_list|(
operator|*
name|cs
argument_list|)
operator|||
name|digit
argument_list|(
operator|*
name|cs
argument_list|)
operator|||
operator|*
name|cs
operator|==
literal|'-'
condition|;
control|)
name|addpath
argument_list|(
operator|*
name|cs
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|cs
operator|||
operator|*
name|cs
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|gpathp
operator|!=
name|gpath
operator|+
literal|1
condition|)
block|{
operator|*
name|gpathp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gethdir
argument_list|(
name|gpath
operator|+
literal|1
argument_list|)
condition|)
name|globerr
operator|=
literal|"Unknown user name after ~"
expr_stmt|;
name|strcpy
argument_list|(
name|gpath
argument_list|,
name|gpath
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|gpath
argument_list|,
name|home
argument_list|)
expr_stmt|;
name|gpathp
operator|=
name|strend
argument_list|(
name|gpath
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|!
name|any
argument_list|(
operator|*
name|cs
argument_list|,
name|globchars
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|cs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|globbed
condition|)
name|Gcat
argument_list|(
name|gpath
argument_list|,
literal|""
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|stat
argument_list|(
name|gpath
argument_list|,
operator|&
name|stb
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|Gcat
argument_list|(
name|gpath
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|globcnt
operator|++
expr_stmt|;
block|}
goto|goto
name|endit
goto|;
block|}
name|addpath
argument_list|(
operator|*
name|cs
operator|++
argument_list|)
expr_stmt|;
block|}
name|oldcs
operator|=
name|cs
expr_stmt|;
while|while
condition|(
name|cs
operator|>
name|as
operator|&&
operator|*
name|cs
operator|!=
literal|'/'
condition|)
name|cs
operator|--
operator|,
name|gpathp
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|cs
operator|==
literal|'/'
condition|)
name|cs
operator|++
operator|,
name|gpathp
operator|++
expr_stmt|;
operator|*
name|gpathp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|oldcs
operator|==
literal|'{'
condition|)
block|{
name|execbrc
argument_list|(
name|cs
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|matchdir
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|endit
label|:
name|gpathp
operator|=
name|sgpathp
expr_stmt|;
operator|*
name|gpathp
operator|=
literal|0
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|execbrc
name|FUNCTION
argument_list|(
operator|(
name|p
operator|,
name|s
operator|)
argument_list|,
name|char
operator|*
name|p
name|AND
name|char
operator|*
name|s
argument_list|)
block|{
name|char
name|restbuf
index|[
name|BUFSIZ
operator|+
literal|2
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|pe
decl_stmt|,
modifier|*
name|pm
decl_stmt|,
modifier|*
name|pl
decl_stmt|;
name|int
name|brclev
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|lm
decl_stmt|,
name|savec
decl_stmt|,
modifier|*
name|sgpathp
decl_stmt|;
for|for
control|(
name|lm
operator|=
name|restbuf
init|;
operator|*
name|p
operator|!=
literal|'{'
condition|;
operator|*
name|lm
operator|++
operator|=
operator|*
name|p
operator|++
control|)
continue|continue;
for|for
control|(
name|pe
operator|=
operator|++
name|p
init|;
operator|*
name|pe
condition|;
name|pe
operator|++
control|)
switch|switch
condition|(
operator|*
name|pe
condition|)
block|{
case|case
literal|'{'
case|:
name|brclev
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'}'
case|:
if|if
condition|(
name|brclev
operator|==
literal|0
condition|)
goto|goto
name|pend
goto|;
name|brclev
operator|--
expr_stmt|;
continue|continue;
case|case
literal|'['
case|:
for|for
control|(
name|pe
operator|++
init|;
operator|*
name|pe
operator|&&
operator|*
name|pe
operator|!=
literal|']'
condition|;
name|pe
operator|++
control|)
continue|continue;
continue|continue;
block|}
name|pend
label|:
name|brclev
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pl
operator|=
name|pm
operator|=
name|p
init|;
name|pm
operator|<=
name|pe
condition|;
name|pm
operator|++
control|)
switch|switch
condition|(
operator|*
name|pm
operator|&
operator|(
name|QUOTE
operator||
name|TRIM
operator|)
condition|)
block|{
case|case
literal|'{'
case|:
name|brclev
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'}'
case|:
if|if
condition|(
name|brclev
condition|)
block|{
name|brclev
operator|--
expr_stmt|;
continue|continue;
block|}
goto|goto
name|doit
goto|;
case|case
literal|','
operator||
name|QUOTE
case|:
case|case
literal|','
case|:
if|if
condition|(
name|brclev
condition|)
continue|continue;
name|doit
label|:
name|savec
operator|=
operator|*
name|pm
expr_stmt|;
operator|*
name|pm
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|lm
argument_list|,
name|pl
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|restbuf
argument_list|,
name|pe
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|pm
operator|=
name|savec
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
name|sgpathp
operator|=
name|gpathp
expr_stmt|;
name|expand
argument_list|(
name|restbuf
argument_list|)
expr_stmt|;
name|gpathp
operator|=
name|sgpathp
expr_stmt|;
operator|*
name|gpathp
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|amatch
argument_list|(
name|s
argument_list|,
name|restbuf
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|sort
argument_list|()
expr_stmt|;
name|pl
operator|=
name|pm
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|brclev
condition|)
return|return
operator|(
literal|0
operator|)
return|;
continue|continue;
case|case
literal|'['
case|:
for|for
control|(
name|pm
operator|++
init|;
operator|*
name|pm
operator|&&
operator|*
name|pm
operator|!=
literal|']'
condition|;
name|pm
operator|++
control|)
continue|continue;
if|if
condition|(
operator|!
operator|*
name|pm
condition|)
name|pm
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|brclev
condition|)
goto|goto
name|doit
goto|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOIDRET
name|acollect
name|FUNCTION
argument_list|(
operator|(
name|as
operator|)
argument_list|,
specifier|register
name|char
operator|*
name|as
argument_list|)
block|{
specifier|register
name|int
name|ogargc
init|=
name|gargc
decl_stmt|;
name|gpathp
operator|=
name|gpath
expr_stmt|;
operator|*
name|gpathp
operator|=
literal|0
expr_stmt|;
name|globbed
operator|=
literal|0
expr_stmt|;
name|expand
argument_list|(
name|as
argument_list|)
expr_stmt|;
if|if
condition|(
name|gargc
operator|!=
name|ogargc
condition|)
name|sort
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOIDRET
name|collect
name|FUNCTION
argument_list|(
operator|(
name|as
operator|)
argument_list|,
specifier|register
name|char
operator|*
name|as
argument_list|)
block|{
if|if
condition|(
name|eq
argument_list|(
name|as
argument_list|,
literal|"{"
argument_list|)
operator|||
name|eq
argument_list|(
name|as
argument_list|,
literal|"{}"
argument_list|)
condition|)
block|{
name|Gcat
argument_list|(
name|as
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sort
argument_list|()
expr_stmt|;
block|}
else|else
name|acollect
argument_list|(
name|as
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|amatch
name|FUNCTION
argument_list|(
operator|(
name|s
operator|,
name|p
operator|)
argument_list|,
specifier|register
name|char
operator|*
name|s
name|AND
specifier|register
name|char
operator|*
name|p
argument_list|)
block|{
specifier|register
name|int
name|scc
decl_stmt|;
name|int
name|ok
decl_stmt|,
name|lc
decl_stmt|;
name|char
modifier|*
name|sgpathp
decl_stmt|;
name|struct
name|stat
name|stb
decl_stmt|;
name|int
name|c
decl_stmt|,
name|cc
decl_stmt|;
name|globbed
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|scc
operator|=
operator|*
name|s
operator|++
operator|&
name|TRIM
expr_stmt|;
switch|switch
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
block|{
case|case
literal|'{'
case|:
return|return
operator|(
name|execbrc
argument_list|(
name|p
operator|-
literal|1
argument_list|,
name|s
operator|-
literal|1
argument_list|)
operator|)
return|;
case|case
literal|'['
case|:
name|ok
operator|=
literal|0
expr_stmt|;
name|lc
operator|=
literal|077777
expr_stmt|;
while|while
condition|(
name|cc
operator|=
operator|*
name|p
operator|++
condition|)
block|{
if|if
condition|(
name|cc
operator|==
literal|']'
condition|)
block|{
if|if
condition|(
name|ok
condition|)
break|break;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|cc
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|lc
operator|<=
name|scc
operator|&&
name|scc
operator|<=
operator|*
name|p
operator|++
condition|)
name|ok
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scc
operator|==
operator|(
name|lc
operator|=
name|cc
operator|)
condition|)
name|ok
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
if|if
condition|(
name|ok
condition|)
name|p
operator|--
expr_stmt|;
else|else
return|return
literal|0
return|;
continue|continue;
case|case
literal|'*'
case|:
if|if
condition|(
operator|!
operator|*
name|p
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
block|{
name|p
operator|++
expr_stmt|;
goto|goto
name|slash
goto|;
block|}
name|s
operator|--
expr_stmt|;
do|do
block|{
if|if
condition|(
name|amatch
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
do|while
condition|(
operator|*
name|s
operator|++
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0
case|:
return|return
operator|(
name|scc
operator|==
literal|0
operator|)
return|;
default|default:
if|if
condition|(
name|c
operator|!=
name|scc
condition|)
return|return
operator|(
literal|0
operator|)
return|;
continue|continue;
case|case
literal|'?'
case|:
if|if
condition|(
name|scc
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
continue|continue;
case|case
literal|'/'
case|:
if|if
condition|(
name|scc
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|slash
label|:
name|s
operator|=
name|entp
expr_stmt|;
name|sgpathp
operator|=
name|gpathp
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|addpath
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
name|addpath
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|gpath
argument_list|,
operator|&
name|stb
argument_list|)
operator|==
literal|0
operator|&&
name|isdir
argument_list|(
name|stb
argument_list|)
condition|)
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
name|Gcat
argument_list|(
name|gpath
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|globcnt
operator|++
expr_stmt|;
block|}
else|else
name|expand
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|gpathp
operator|=
name|sgpathp
expr_stmt|;
operator|*
name|gpathp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|ftpglob
name|FUNCTION
argument_list|(
operator|(
name|v
operator|)
argument_list|,
specifier|register
name|char
operator|*
name|v
argument_list|)
block|{
name|char
name|agpath
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|agargv
index|[
name|GAVSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|vv
index|[
literal|2
index|]
decl_stmt|;
name|vv
index|[
literal|0
index|]
operator|=
name|v
expr_stmt|;
name|vv
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|gflag
operator|=
literal|0
expr_stmt|;
name|rscan
argument_list|(
name|vv
argument_list|,
name|tglob
argument_list|)
expr_stmt|;
if|if
condition|(
name|gflag
operator|==
literal|0
condition|)
block|{
name|vv
index|[
literal|0
index|]
operator|=
name|strspl
argument_list|(
name|v
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|copyblk
argument_list|(
name|vv
argument_list|)
operator|)
return|;
block|}
name|globerr
operator|=
literal|0
expr_stmt|;
name|gpath
operator|=
name|agpath
expr_stmt|;
name|gpathp
operator|=
name|gpath
expr_stmt|;
operator|*
name|gpathp
operator|=
literal|0
expr_stmt|;
name|lastgpathp
operator|=
operator|&
name|gpath
index|[
sizeof|sizeof
name|agpath
operator|-
literal|2
index|]
expr_stmt|;
name|ginit
argument_list|(
name|agargv
argument_list|)
expr_stmt|;
name|globcnt
operator|=
literal|0
expr_stmt|;
name|collect
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|globcnt
operator|==
literal|0
operator|&&
operator|(
name|gflag
operator|&
literal|1
operator|)
condition|)
block|{
name|blkfree
argument_list|(
name|gargv
argument_list|)
operator|,
name|gargv
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
return|return
operator|(
name|gargv
operator|=
name|copyblk
argument_list|(
name|gargv
argument_list|)
operator|)
return|;
block|}
end_decl_stmt

end_unit

