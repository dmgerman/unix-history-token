begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* opiesu.c: main body of code for the su(1m) program  %%% portions-copyright-cmetz Portions of this software are Copyright 1996 by Craig Metz, All Rights Reserved. The Inner Net License Version 2 applies to these portions of the software. You should have received a copy of the license with this software. If you didn't get a copy, you may request one from<license@inner.net>.  Portions of this software are Copyright 1995 by Randall Atkinson and Dan McDonald, All Rights Reserved. All Rights under this copyright are assigned to the U.S. Naval Research Laboratory (NRL). The NRL Copyright Notice and License Agreement applies to this software.  	History:  	Modified by cmetz for OPIE 2.3. Limit the length of TERM on full login. 		Use HAVE_SULOG instead of DOSULOG.         Modified by cmetz for OPIE 2.2. Don't try to clear non-blocking I/O.                 Use opiereadpass(). Minor speedup. Removed termios manipulation                 -- that's opiereadpass()'s job. Change opiereadpass() calls                 to add echo arg. Removed useless strings (I don't think that                 removing the ucb copyright one is a problem -- please let me                 know if I'm wrong). Use FUNCTION declaration et al. Ifdef                 around some headers. Make everything static. Removed                 closelog() prototype. Use the same catchexit() trickery as                 opielogin.         Modified at NRL for OPIE 2.2. Changed opiestrip_crlf to                 opiestripcrlf.         Modified at NRL for OPIE 2.1. Added struct group declaration. 	        Added Solaris(+others?) sulog capability. Symbol changes 		for autoconf. Removed des_crypt.h. File renamed to 		opiesu.c. Symbol+misc changes for autoconf. Added bletch 		for setpriority.         Modified at NRL for OPIE 2.02. Added SU_STAR_CHECK (turning a bug                 into a feature ;). Fixed Solaris shadow password problem                 introduced in OPIE 2.01 (the shadow password structure is                 spwd, not spasswd).         Modified at NRL for OPIE 2.01. Changed password lookup handling                 to use a static structure to avoid problems with drain-                 bamaged shadow password packages. Always log failures.                 Make sure to close syslog by function to avoid problems                  with drain bamaged syslog implementations. Log a few                  interesting errors. 	Modified at NRL for OPIE 2.0. 	Modified at Bellcore for the S/Key Version 1 software distribution. 	Originally from BSD. */
end_comment

begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_include
include|#
directive|include
file|"opie_cfg.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_if
if|#
directive|if
name|HAVE_PWD_H
end_if

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PWD_H */
end_comment

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|HAVE_SETPRIORITY
operator|&&
name|HAVE_SYS_RESOURCE_H
end_if

begin_if
if|#
directive|if
name|TIME_WITH_SYS_TIME
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* TIME_WITH_SYS_TIME */
end_comment

begin_if
if|#
directive|if
name|HAVE_SYS_TIME_H
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* HAVE_SYS_TIME_H */
end_comment

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_TIME_H */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TIME_WITH_SYS_TIME */
end_comment

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* HAVE_SETPRIORITY&& HAVE_SYS_RESOURCE_H */
end_comment

begin_if
if|#
directive|if
name|TM_IN_SYS_TIME
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* TM_IN_SYS_TIME */
end_comment

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TM_IN_SYS_TIME */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SETPRIORITY&& HAVE_SYS_RESOURCE_H */
end_comment

begin_if
if|#
directive|if
name|HAVE_STDLIB_H
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_if
if|#
directive|if
name|HAVE_UNISTD_H
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UNISTD_H */
end_comment

begin_if
if|#
directive|if
name|HAVE_STRING_H
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STRING_H */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"opie.h"
end_include

begin_decl_stmt
specifier|static
name|char
name|userbuf
index|[
literal|16
index|]
init|=
literal|"USER="
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|homebuf
index|[
literal|128
index|]
init|=
literal|"HOME="
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|shellbuf
index|[
literal|128
index|]
init|=
literal|"SHELL="
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|pathbuf
index|[
literal|128
index|]
init|=
literal|"PATH="
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|termbuf
index|[
literal|32
index|]
init|=
literal|"TERM="
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cleanenv
index|[]
init|=
block|{
name|userbuf
block|,
name|homebuf
block|,
name|shellbuf
block|,
name|pathbuf
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|user
init|=
literal|"root"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|shell
init|=
literal|"/bin/sh"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fulllogin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fastlogin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|passwd
name|thisuser
decl_stmt|,
name|nouser
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|HAVE_SHADOW_H
end_if

begin_include
include|#
directive|include
file|<shadow.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SHADOW_H */
end_comment

begin_if
if|#
directive|if
name|HAVE_CRYPT_H
end_if

begin_include
include|#
directive|include
file|<crypt.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CRYPT_H */
end_comment

begin_decl_stmt
specifier|static
name|VOIDRET
name|catchexit
name|FUNCTION_NOARGS
block|{
name|int
name|i
decl_stmt|;
name|closelog
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sysconf
argument_list|(
name|_SC_OPEN_MAX
argument_list|)
init|;
name|i
operator|>
literal|2
condition|;
name|i
operator|--
control|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* We allow the malloc()s to potentially leak data out because we can only call this routine about four times in the lifetime of this process and the kernel will free all heap memory when we exit or exec. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lookupuser
name|FUNCTION
argument_list|(
operator|(
name|name
operator|)
argument_list|,
name|char
operator|*
name|name
argument_list|)
block|{
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
if|#
directive|if
name|HAVE_SHADOW
name|struct
name|spwd
modifier|*
name|spwd
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_SHADOW */
name|memcpy
argument_list|(
operator|&
name|thisuser
argument_list|,
operator|&
name|nouser
argument_list|,
sizeof|sizeof
argument_list|(
name|thisuser
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pwd
operator|=
name|getpwnam
argument_list|(
name|name
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|thisuser
operator|.
name|pw_uid
operator|=
name|pwd
operator|->
name|pw_uid
expr_stmt|;
name|thisuser
operator|.
name|pw_gid
operator|=
name|pwd
operator|->
name|pw_gid
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|thisuser
operator|.
name|pw_name
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
condition|)
goto|goto
name|lookupuserbad
goto|;
name|strcpy
argument_list|(
name|thisuser
operator|.
name|pw_name
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|thisuser
operator|.
name|pw_dir
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|pwd
operator|->
name|pw_dir
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
condition|)
goto|goto
name|lookupuserbad
goto|;
name|strcpy
argument_list|(
name|thisuser
operator|.
name|pw_dir
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|thisuser
operator|.
name|pw_shell
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|pwd
operator|->
name|pw_shell
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
condition|)
goto|goto
name|lookupuserbad
goto|;
name|strcpy
argument_list|(
name|thisuser
operator|.
name|pw_shell
argument_list|,
name|pwd
operator|->
name|pw_shell
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_SHADOW
if|if
condition|(
operator|!
operator|(
name|spwd
operator|=
name|getspnam
argument_list|(
name|name
argument_list|)
operator|)
condition|)
goto|goto
name|lookupuserbad
goto|;
name|pwd
operator|->
name|pw_passwd
operator|=
name|spwd
operator|->
name|sp_pwdp
expr_stmt|;
name|endspent
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SHADOW */
if|if
condition|(
operator|!
operator|(
name|thisuser
operator|.
name|pw_passwd
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|pwd
operator|->
name|pw_passwd
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
condition|)
goto|goto
name|lookupuserbad
goto|;
name|strcpy
argument_list|(
name|thisuser
operator|.
name|pw_passwd
argument_list|,
name|pwd
operator|->
name|pw_passwd
argument_list|)
expr_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
if|#
directive|if
name|SU_STAR_CHECK
return|return
operator|(
operator|(
name|thisuser
operator|.
name|pw_passwd
index|[
literal|0
index|]
operator|==
literal|'*'
operator|)
operator|||
operator|(
name|thisuser
operator|.
name|pw_passwd
index|[
literal|0
index|]
operator|==
literal|'#'
operator|)
operator|)
return|;
else|#
directive|else
comment|/* SU_STAR_CHECK */
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* SU_STAR_CHECK */
name|lookupuserbad
label|:
name|memcpy
argument_list|(
operator|&
name|thisuser
argument_list|,
operator|&
name|nouser
argument_list|,
sizeof|sizeof
argument_list|(
name|thisuser
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOIDRET
name|lsetenv
name|FUNCTION
argument_list|(
operator|(
name|ename
operator|,
name|eval
operator|,
name|buf
operator|)
argument_list|,
name|char
operator|*
name|ename
name|AND
name|char
operator|*
name|eval
name|AND
name|char
operator|*
name|buf
argument_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|ep
init|=
name|environ
decl_stmt|;
comment|/* this assumes an environment variable "ename" already exists */
while|while
condition|(
name|dp
operator|=
operator|*
name|ep
operator|++
condition|)
block|{
for|for
control|(
name|cp
operator|=
name|ename
init|;
operator|*
name|cp
operator|==
operator|*
name|dp
operator|&&
operator|*
name|cp
condition|;
name|cp
operator|++
operator|,
name|dp
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
operator|&&
operator|(
operator|*
name|dp
operator|==
literal|'='
operator|||
operator|*
name|dp
operator|==
literal|0
operator|)
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
name|eval
argument_list|)
expr_stmt|;
operator|*
operator|--
name|ep
operator|=
name|buf
expr_stmt|;
return|return;
block|}
block|}
block|}
end_decl_stmt

begin_if
if|#
directive|if
name|HAVE_SULOG
end_if

begin_decl_stmt
specifier|static
name|int
name|sulog
name|FUNCTION
argument_list|(
operator|(
name|status
operator|,
name|who
operator|)
argument_list|,
name|int
name|status
name|AND
name|char
operator|*
name|who
argument_list|)
block|{
name|char
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|ttynam
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|time_t
name|now
decl_stmt|;
if|if
condition|(
name|who
condition|)
name|from
operator|=
name|who
expr_stmt|;
else|else
name|from
operator|=
name|Getlogin
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ttynam
operator|=
name|ttyname
argument_list|(
literal|2
argument_list|)
argument_list|,
literal|"/dev/"
argument_list|,
literal|5
argument_list|)
condition|)
name|ttynam
operator|+=
literal|5
expr_stmt|;
name|now
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|tm
operator|=
name|localtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|f
operator|=
name|fopen
argument_list|(
literal|"/var/adm/sulog"
argument_list|,
literal|"a"
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't update su log!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"SU %02d/%02d %02d:%02d %c %s %s-%s\n"
argument_list|,
name|tm
operator|->
name|tm_mon
argument_list|,
name|tm
operator|->
name|tm_mday
argument_list|,
name|tm
operator|->
name|tm_hour
argument_list|,
name|tm
operator|->
name|tm_min
argument_list|,
name|result
condition|?
literal|'+'
else|:
literal|'-'
argument_list|,
name|ttynam
argument_list|,
name|from
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SULOG */
end_comment

begin_decl_stmt
name|int
decl|main
name|FUNCTION
argument_list|(
operator|(
name|argc
operator|,
name|argv
operator|)
argument_list|,
name|int
name|argc
name|AND
name|char
operator|*
name|argv
index|[]
argument_list|)
block|{
name|char
name|buf
index|[
literal|1000
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|struct
name|opie
name|opie
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|pbuf
index|[
literal|256
index|]
decl_stmt|;
name|char
name|opieprompt
index|[
literal|80
index|]
decl_stmt|;
name|int
name|console
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|Getlogin
parameter_list|()
value|(((p = getlogin())&& *p) ? p : buf)
for|for
control|(
name|i
operator|=
name|sysconf
argument_list|(
name|_SC_OPEN_MAX
argument_list|)
init|;
name|i
operator|>
literal|2
condition|;
name|i
operator|--
control|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|pathbuf
argument_list|,
name|DEFAULT_PATH
argument_list|)
expr_stmt|;
name|again
label|:
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-f"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fastlogin
operator|++
expr_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-c"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|console
operator|++
expr_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fulllogin
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
name|user
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
name|openlog
argument_list|(
literal|"su"
argument_list|,
name|LOG_ODELAY
argument_list|,
name|LOG_AUTH
argument_list|)
expr_stmt|;
name|atexit
argument_list|(
name|catchexit
argument_list|)
expr_stmt|;
block|{
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
if|if
condition|(
operator|(
name|pwd
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"'%s' failed for unknown uid %d on %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|ttyname
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_SULOG
name|sulog
argument_list|(
literal|0
argument_list|,
literal|"unknown"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SULOG */
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|buf
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lookupuser
argument_list|(
name|user
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"'%s' failed for %s on %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|Getlogin
argument_list|()
argument_list|,
name|ttyname
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_SULOG
name|sulog
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SULOG */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown user: %s\n"
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Implement the BSD "wheel group" su restriction. */
if|#
directive|if
name|DOWHEEL
comment|/* Only allow those in group zero to su to root? */
if|if
condition|(
name|thisuser
operator|.
name|pw_uid
operator|==
literal|0
condition|)
block|{
name|struct
name|group
modifier|*
name|gr
decl_stmt|;
if|if
condition|(
operator|(
name|gr
operator|=
name|getgrgid
argument_list|(
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|gr
operator|->
name|gr_mem
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
name|gr
operator|->
name|gr_mem
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|userok
goto|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"You do not have permission to su %s\n"
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|userok
label|:
empty_stmt|;
if|#
directive|if
name|HAVE_SETPRIORITY
operator|&&
name|HAVE_SYS_RESOURCE_H
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
literal|0
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SETPRIORITY&& HAVE_SYS_RESOURCE_H */
block|}
endif|#
directive|endif
comment|/* DOWHEEL */
if|if
condition|(
operator|!
name|thisuser
operator|.
name|pw_passwd
index|[
literal|0
index|]
operator|||
name|getuid
argument_list|()
operator|==
literal|0
condition|)
goto|goto
name|ok
goto|;
if|if
condition|(
name|console
condition|)
block|{
if|if
condition|(
operator|!
name|opiealways
argument_list|(
name|thisuser
operator|.
name|pw_dir
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"That account requires OTP responses.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* Get user's secret password */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Reminder - Only use this method from the console; NEVER from remote. If you\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"are using telnet, xterm, or a dial-in, type ^C now or exit with no password.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Then run su without the -c parameter.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opieinsecure
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Sorry, but you don't seem to be on the console or a secure terminal.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|#
directive|if
name|NEW_PROMPTS
name|printf
argument_list|(
literal|"%s's system password: "
argument_list|,
name|thisuser
operator|.
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opiereadpass
argument_list|(
name|pbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pbuf
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|error
goto|;
endif|#
directive|endif
comment|/* NEW_PROMPTS */
block|}
else|else
block|{
comment|/* Attempt an OTP challenge */
name|i
operator|=
name|opiechallenge
argument_list|(
operator|&
name|opie
argument_list|,
name|user
argument_list|,
name|opieprompt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|opieprompt
argument_list|)
expr_stmt|;
if|#
directive|if
name|NEW_PROMPTS
name|printf
argument_list|(
literal|"%s's response: "
argument_list|,
name|thisuser
operator|.
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opiereadpass
argument_list|(
name|pbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pbuf
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
else|#
directive|else
comment|/* NEW_PROMPTS */
name|printf
argument_list|(
literal|"(OTP response required)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NEW_PROMPTS */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|#
directive|if
operator|!
name|NEW_PROMPTS
name|printf
argument_list|(
literal|"%s's password: "
argument_list|,
name|thisuser
operator|.
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opiereadpass
argument_list|(
name|pbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pbuf
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|error
goto|;
endif|#
directive|endif
comment|/* !NEW_PROMPTS */
if|#
directive|if
operator|!
name|NEW_PROMPTS
if|if
condition|(
operator|!
name|pbuf
index|[
literal|0
index|]
operator|&&
operator|!
name|console
condition|)
block|{
comment|/* Null line entered; turn echoing back on and read again */
name|printf
argument_list|(
literal|" (echo on)\n%s's password: "
argument_list|,
name|thisuser
operator|.
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opiereadpass
argument_list|(
name|pbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pbuf
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error
goto|;
block|}
endif|#
directive|endif
comment|/* !NEW_PROMPTS */
if|if
condition|(
name|console
condition|)
block|{
comment|/* Try regular password check, if allowed */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|crypt
argument_list|(
name|pbuf
argument_list|,
name|thisuser
operator|.
name|pw_passwd
argument_list|)
argument_list|,
name|thisuser
operator|.
name|pw_passwd
argument_list|)
condition|)
goto|goto
name|ok
goto|;
block|}
else|else
block|{
name|int
name|i
init|=
name|opiegetsequence
argument_list|(
operator|&
name|opie
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|opieverify
argument_list|(
operator|&
name|opie
argument_list|,
name|pbuf
argument_list|)
condition|)
block|{
comment|/* OPIE authentication succeeded */
if|if
condition|(
name|i
operator|<
literal|5
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: Change %s's OTP secret pass phrase NOW!\n"
argument_list|,
name|user
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
literal|10
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: Change %s's OTP secret pass phrase soon.\n"
argument_list|,
name|user
argument_list|)
expr_stmt|;
goto|goto
name|ok
goto|;
block|}
empty_stmt|;
block|}
empty_stmt|;
name|error
label|:
name|opieverify
argument_list|(
operator|&
name|opie
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Sorry\n"
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"'%s' failed for %s on %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|Getlogin
argument_list|()
argument_list|,
name|ttyname
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_SULOG
name|sulog
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SULOG */
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ok
label|:
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"'%s' by %s on %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|Getlogin
argument_list|()
argument_list|,
name|ttyname
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_SULOG
name|sulog
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SULOG */
if|if
condition|(
name|setgid
argument_list|(
name|thisuser
operator|.
name|pw_gid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"su: setgid"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|initgroups
argument_list|(
name|user
argument_list|,
name|thisuser
operator|.
name|pw_gid
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"su: initgroups failed (errno=%d)\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setuid
argument_list|(
name|thisuser
operator|.
name|pw_uid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"su: setuid"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|thisuser
operator|.
name|pw_shell
operator|&&
operator|*
name|thisuser
operator|.
name|pw_shell
condition|)
name|shell
operator|=
name|thisuser
operator|.
name|pw_shell
expr_stmt|;
if|if
condition|(
name|fulllogin
condition|)
block|{
if|if
condition|(
name|p
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
condition|)
block|{
name|strncpy
argument_list|(
name|termbuf
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|termbuf
argument_list|)
argument_list|)
expr_stmt|;
name|cleanenv
index|[
literal|4
index|]
operator|=
name|termbuf
expr_stmt|;
block|}
name|environ
operator|=
name|cleanenv
expr_stmt|;
block|}
if|if
condition|(
name|fulllogin
operator|||
name|strcmp
argument_list|(
name|user
argument_list|,
literal|"root"
argument_list|)
operator|!=
literal|0
condition|)
name|lsetenv
argument_list|(
literal|"USER"
argument_list|,
name|thisuser
operator|.
name|pw_name
argument_list|,
name|userbuf
argument_list|)
expr_stmt|;
name|lsetenv
argument_list|(
literal|"SHELL"
argument_list|,
name|shell
argument_list|,
name|shellbuf
argument_list|)
expr_stmt|;
name|lsetenv
argument_list|(
literal|"HOME"
argument_list|,
name|thisuser
operator|.
name|pw_dir
argument_list|,
name|homebuf
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_SETPRIORITY
operator|&&
name|HAVE_SYS_RESOURCE_H
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SETPRIORITY&& HAVE_SYS_RESOURCE_H */
if|if
condition|(
name|fastlogin
condition|)
block|{
operator|*
name|argv
operator|--
operator|=
literal|"-f"
expr_stmt|;
operator|*
name|argv
operator|=
literal|"su"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fulllogin
condition|)
block|{
if|if
condition|(
name|chdir
argument_list|(
name|thisuser
operator|.
name|pw_dir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No directory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|6
argument_list|)
expr_stmt|;
block|}
operator|*
name|argv
operator|=
literal|"-su"
expr_stmt|;
block|}
else|else
block|{
operator|*
name|argv
operator|=
literal|"su"
expr_stmt|;
block|}
name|catchexit
argument_list|()
expr_stmt|;
if|#
directive|if
name|DEBUG
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"execing %s"
argument_list|,
name|shell
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|execv
argument_list|(
name|shell
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No shell\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|7
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

end_unit

