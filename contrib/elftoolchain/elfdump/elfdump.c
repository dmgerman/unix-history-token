begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007-2012 Kai Wang  * Copyright (c) 2003 David O'Brien.  All rights reserved.  * Copyright (c) 2001 Jake Burkholder  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ar.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<gelf.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<libelftc.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LIBARCHIVE_AR
end_ifdef

begin_include
include|#
directive|include
file|<archive.h>
end_include

begin_include
include|#
directive|include
file|<archive_entry.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"_elftc.h"
end_include

begin_expr_stmt
name|ELFTC_VCSID
argument_list|(
literal|"$Id: elfdump.c 3497 2016-10-17 20:57:22Z emaste $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ELFTC_NEED_ELF_NOTE_DEFINITION
argument_list|)
end_if

begin_include
include|#
directive|include
file|"native-elf-format.h"
end_include

begin_if
if|#
directive|if
name|ELFTC_CLASS
operator|==
name|ELFCLASS32
end_if

begin_typedef
typedef|typedef
name|Elf32_Nhdr
name|Elf_Note
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|Elf64_Nhdr
name|Elf_Note
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* elfdump(1) options. */
end_comment

begin_define
define|#
directive|define
name|ED_DYN
value|(1<<0)
end_define

begin_define
define|#
directive|define
name|ED_EHDR
value|(1<<1)
end_define

begin_define
define|#
directive|define
name|ED_GOT
value|(1<<2)
end_define

begin_define
define|#
directive|define
name|ED_HASH
value|(1<<3)
end_define

begin_define
define|#
directive|define
name|ED_INTERP
value|(1<<4)
end_define

begin_define
define|#
directive|define
name|ED_NOTE
value|(1<<5)
end_define

begin_define
define|#
directive|define
name|ED_PHDR
value|(1<<6)
end_define

begin_define
define|#
directive|define
name|ED_REL
value|(1<<7)
end_define

begin_define
define|#
directive|define
name|ED_SHDR
value|(1<<8)
end_define

begin_define
define|#
directive|define
name|ED_SYMTAB
value|(1<<9)
end_define

begin_define
define|#
directive|define
name|ED_SYMVER
value|(1<<10)
end_define

begin_define
define|#
directive|define
name|ED_CHECKSUM
value|(1<<11)
end_define

begin_define
define|#
directive|define
name|ED_ALL
value|((1<<12)-1)
end_define

begin_comment
comment|/* elfdump(1) run control flags. */
end_comment

begin_define
define|#
directive|define
name|SOLARIS_FMT
value|(1<<0)
end_define

begin_define
define|#
directive|define
name|PRINT_FILENAME
value|(1<<1)
end_define

begin_define
define|#
directive|define
name|PRINT_ARSYM
value|(1<<2)
end_define

begin_define
define|#
directive|define
name|ONLY_ARSYM
value|(1<<3)
end_define

begin_comment
comment|/* Convenient print macro. */
end_comment

begin_define
define|#
directive|define
name|PRT
parameter_list|(
modifier|...
parameter_list|)
value|fprintf(ed->out, __VA_ARGS__)
end_define

begin_comment
comment|/* Internal data structure for sections. */
end_comment

begin_struct
struct|struct
name|section
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* section name */
name|Elf_Scn
modifier|*
name|scn
decl_stmt|;
comment|/* section scn */
name|uint64_t
name|off
decl_stmt|;
comment|/* section offset */
name|uint64_t
name|sz
decl_stmt|;
comment|/* section size */
name|uint64_t
name|entsize
decl_stmt|;
comment|/* section entsize */
name|uint64_t
name|align
decl_stmt|;
comment|/* section alignment */
name|uint64_t
name|type
decl_stmt|;
comment|/* section type */
name|uint64_t
name|flags
decl_stmt|;
comment|/* section flags */
name|uint64_t
name|addr
decl_stmt|;
comment|/* section virtual addr */
name|uint32_t
name|link
decl_stmt|;
comment|/* section link ndx */
name|uint32_t
name|info
decl_stmt|;
comment|/* section info ndx */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|spec_name
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|spec_name
argument_list|)
name|sn_list
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Structure encapsulates the global data for readelf(1). */
end_comment

begin_struct
struct|struct
name|elfdump
block|{
name|FILE
modifier|*
name|out
decl_stmt|;
comment|/* output redirection. */
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* current processing file. */
specifier|const
name|char
modifier|*
name|archive
decl_stmt|;
comment|/* archive name */
name|int
name|options
decl_stmt|;
comment|/* command line options. */
name|int
name|flags
decl_stmt|;
comment|/* run control flags. */
name|Elf
modifier|*
name|elf
decl_stmt|;
comment|/* underlying ELF descriptor. */
ifndef|#
directive|ifndef
name|USE_LIBARCHIVE_AR
name|Elf
modifier|*
name|ar
decl_stmt|;
comment|/* ar(1) archive descriptor. */
endif|#
directive|endif
name|GElf_Ehdr
name|ehdr
decl_stmt|;
comment|/* ELF header. */
name|int
name|ec
decl_stmt|;
comment|/* ELF class. */
name|size_t
name|shnum
decl_stmt|;
comment|/* #sections. */
name|struct
name|section
modifier|*
name|sl
decl_stmt|;
comment|/* list of sections. */
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|spec_name
argument_list|)
name|snl
expr_stmt|;
comment|/* list of names specified by -N. */
block|}
struct|;
end_struct

begin_comment
comment|/* Relocation entry. */
end_comment

begin_struct
struct|struct
name|rel_entry
block|{
union|union
block|{
name|GElf_Rel
name|rel
decl_stmt|;
name|GElf_Rela
name|rela
decl_stmt|;
block|}
name|u_r
union|;
specifier|const
name|char
modifier|*
name|symn
decl_stmt|;
name|uint32_t
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ELFTC_NEED_BYTEORDER_EXTENSIONS
argument_list|)
end_if

begin_function
specifier|static
name|__inline
name|uint32_t
name|be32dec
parameter_list|(
specifier|const
name|void
modifier|*
name|pp
parameter_list|)
block|{
name|unsigned
name|char
specifier|const
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
specifier|const
operator|*
operator|)
name|pp
decl_stmt|;
return|return
operator|(
operator|(
name|p
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|p
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|p
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|p
index|[
literal|3
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|le32dec
parameter_list|(
specifier|const
name|void
modifier|*
name|pp
parameter_list|)
block|{
name|unsigned
name|char
specifier|const
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
specifier|const
operator|*
operator|)
name|pp
decl_stmt|;
return|return
operator|(
operator|(
name|p
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|p
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|p
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|p
index|[
literal|0
index|]
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#tag_encodings */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|d_tags
parameter_list|(
name|uint64_t
name|tag
parameter_list|)
block|{
specifier|static
name|char
name|unknown_buf
index|[
literal|64
index|]
decl_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|DT_NULL
case|:
return|return
literal|"DT_NULL"
return|;
case|case
name|DT_NEEDED
case|:
return|return
literal|"DT_NEEDED"
return|;
case|case
name|DT_PLTRELSZ
case|:
return|return
literal|"DT_PLTRELSZ"
return|;
case|case
name|DT_PLTGOT
case|:
return|return
literal|"DT_PLTGOT"
return|;
case|case
name|DT_HASH
case|:
return|return
literal|"DT_HASH"
return|;
case|case
name|DT_STRTAB
case|:
return|return
literal|"DT_STRTAB"
return|;
case|case
name|DT_SYMTAB
case|:
return|return
literal|"DT_SYMTAB"
return|;
case|case
name|DT_RELA
case|:
return|return
literal|"DT_RELA"
return|;
case|case
name|DT_RELASZ
case|:
return|return
literal|"DT_RELASZ"
return|;
case|case
name|DT_RELAENT
case|:
return|return
literal|"DT_RELAENT"
return|;
case|case
name|DT_STRSZ
case|:
return|return
literal|"DT_STRSZ"
return|;
case|case
name|DT_SYMENT
case|:
return|return
literal|"DT_SYMENT"
return|;
case|case
name|DT_INIT
case|:
return|return
literal|"DT_INIT"
return|;
case|case
name|DT_FINI
case|:
return|return
literal|"DT_FINI"
return|;
case|case
name|DT_SONAME
case|:
return|return
literal|"DT_SONAME"
return|;
case|case
name|DT_RPATH
case|:
return|return
literal|"DT_RPATH"
return|;
case|case
name|DT_SYMBOLIC
case|:
return|return
literal|"DT_SYMBOLIC"
return|;
case|case
name|DT_REL
case|:
return|return
literal|"DT_REL"
return|;
case|case
name|DT_RELSZ
case|:
return|return
literal|"DT_RELSZ"
return|;
case|case
name|DT_RELENT
case|:
return|return
literal|"DT_RELENT"
return|;
case|case
name|DT_PLTREL
case|:
return|return
literal|"DT_PLTREL"
return|;
case|case
name|DT_DEBUG
case|:
return|return
literal|"DT_DEBUG"
return|;
case|case
name|DT_TEXTREL
case|:
return|return
literal|"DT_TEXTREL"
return|;
case|case
name|DT_JMPREL
case|:
return|return
literal|"DT_JMPREL"
return|;
case|case
name|DT_BIND_NOW
case|:
return|return
literal|"DT_BIND_NOW"
return|;
case|case
name|DT_INIT_ARRAY
case|:
return|return
literal|"DT_INIT_ARRAY"
return|;
case|case
name|DT_FINI_ARRAY
case|:
return|return
literal|"DT_FINI_ARRAY"
return|;
case|case
name|DT_INIT_ARRAYSZ
case|:
return|return
literal|"DT_INIT_ARRAYSZ"
return|;
case|case
name|DT_FINI_ARRAYSZ
case|:
return|return
literal|"DT_FINI_ARRAYSZ"
return|;
case|case
name|DT_RUNPATH
case|:
return|return
literal|"DT_RUNPATH"
return|;
case|case
name|DT_FLAGS
case|:
return|return
literal|"DT_FLAGS"
return|;
case|case
name|DT_PREINIT_ARRAY
case|:
return|return
literal|"DT_PREINIT_ARRAY"
return|;
comment|/* XXX DT_ENCODING */
case|case
name|DT_PREINIT_ARRAYSZ
case|:
return|return
literal|"DT_PREINIT_ARRAYSZ"
return|;
comment|/* 0x6000000D - 0x6ffff000 operating system-specific semantics */
case|case
literal|0x6ffffdf5
case|:
return|return
literal|"DT_GNU_PRELINKED"
return|;
case|case
literal|0x6ffffdf6
case|:
return|return
literal|"DT_GNU_CONFLICTSZ"
return|;
case|case
literal|0x6ffffdf7
case|:
return|return
literal|"DT_GNU_LIBLISTSZ"
return|;
case|case
literal|0x6ffffdf8
case|:
return|return
literal|"DT_SUNW_CHECKSUM"
return|;
case|case
name|DT_PLTPADSZ
case|:
return|return
literal|"DT_PLTPADSZ"
return|;
case|case
name|DT_MOVEENT
case|:
return|return
literal|"DT_MOVEENT"
return|;
case|case
name|DT_MOVESZ
case|:
return|return
literal|"DT_MOVESZ"
return|;
case|case
literal|0x6ffffdfc
case|:
return|return
literal|"DT_FEATURE"
return|;
case|case
name|DT_POSFLAG_1
case|:
return|return
literal|"DT_POSFLAG_1"
return|;
case|case
name|DT_SYMINSZ
case|:
return|return
literal|"DT_SYMINSZ"
return|;
case|case
name|DT_SYMINENT
case|:
return|return
literal|"DT_SYMINENT (DT_VALRNGHI)"
return|;
case|case
name|DT_ADDRRNGLO
case|:
return|return
literal|"DT_ADDRRNGLO"
return|;
case|case
name|DT_GNU_HASH
case|:
return|return
literal|"DT_GNU_HASH"
return|;
case|case
literal|0x6ffffef8
case|:
return|return
literal|"DT_GNU_CONFLICT"
return|;
case|case
literal|0x6ffffef9
case|:
return|return
literal|"DT_GNU_LIBLIST"
return|;
case|case
literal|0x6ffffefa
case|:
return|return
literal|"DT_CONFIG"
return|;
case|case
literal|0x6ffffefb
case|:
return|return
literal|"DT_DEPAUDIT"
return|;
case|case
literal|0x6ffffefc
case|:
return|return
literal|"DT_AUDIT"
return|;
case|case
literal|0x6ffffefd
case|:
return|return
literal|"DT_PLTPAD"
return|;
case|case
literal|0x6ffffefe
case|:
return|return
literal|"DT_MOVETAB"
return|;
case|case
name|DT_SYMINFO
case|:
return|return
literal|"DT_SYMINFO (DT_ADDRRNGHI)"
return|;
case|case
name|DT_RELACOUNT
case|:
return|return
literal|"DT_RELACOUNT"
return|;
case|case
name|DT_RELCOUNT
case|:
return|return
literal|"DT_RELCOUNT"
return|;
case|case
name|DT_FLAGS_1
case|:
return|return
literal|"DT_FLAGS_1"
return|;
case|case
name|DT_VERDEF
case|:
return|return
literal|"DT_VERDEF"
return|;
case|case
name|DT_VERDEFNUM
case|:
return|return
literal|"DT_VERDEFNUM"
return|;
case|case
name|DT_VERNEED
case|:
return|return
literal|"DT_VERNEED"
return|;
case|case
name|DT_VERNEEDNUM
case|:
return|return
literal|"DT_VERNEEDNUM"
return|;
case|case
literal|0x6ffffff0
case|:
return|return
literal|"DT_GNU_VERSYM"
return|;
comment|/* 0x70000000 - 0x7fffffff processor-specific semantics */
case|case
literal|0x70000000
case|:
return|return
literal|"DT_IA_64_PLT_RESERVE"
return|;
case|case
name|DT_AUXILIARY
case|:
return|return
literal|"DT_AUXILIARY"
return|;
case|case
name|DT_USED
case|:
return|return
literal|"DT_USED"
return|;
case|case
name|DT_FILTER
case|:
return|return
literal|"DT_FILTER"
return|;
block|}
name|snprintf
argument_list|(
name|unknown_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|unknown_buf
argument_list|)
argument_list|,
literal|"<unknown: %#llx>"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|unknown_buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|e_machines
parameter_list|(
name|unsigned
name|int
name|mach
parameter_list|)
block|{
specifier|static
name|char
name|machdesc
index|[
literal|64
index|]
decl_stmt|;
switch|switch
condition|(
name|mach
condition|)
block|{
case|case
name|EM_NONE
case|:
return|return
literal|"EM_NONE"
return|;
case|case
name|EM_M32
case|:
return|return
literal|"EM_M32"
return|;
case|case
name|EM_SPARC
case|:
return|return
literal|"EM_SPARC"
return|;
case|case
name|EM_386
case|:
return|return
literal|"EM_386"
return|;
case|case
name|EM_68K
case|:
return|return
literal|"EM_68K"
return|;
case|case
name|EM_88K
case|:
return|return
literal|"EM_88K"
return|;
case|case
name|EM_IAMCU
case|:
return|return
literal|"EM_IAMCU"
return|;
case|case
name|EM_860
case|:
return|return
literal|"EM_860"
return|;
case|case
name|EM_MIPS
case|:
return|return
literal|"EM_MIPS"
return|;
case|case
name|EM_PPC
case|:
return|return
literal|"EM_PPC"
return|;
case|case
name|EM_PPC64
case|:
return|return
literal|"EM_PPC64"
return|;
case|case
name|EM_ARM
case|:
return|return
literal|"EM_ARM"
return|;
case|case
name|EM_ALPHA
case|:
return|return
literal|"EM_ALPHA (legacy)"
return|;
case|case
name|EM_SPARCV9
case|:
return|return
literal|"EM_SPARCV9"
return|;
case|case
name|EM_IA_64
case|:
return|return
literal|"EM_IA_64"
return|;
case|case
name|EM_X86_64
case|:
return|return
literal|"EM_X86_64"
return|;
case|case
name|EM_AARCH64
case|:
return|return
literal|"EM_AARCH64"
return|;
case|case
name|EM_RISCV
case|:
return|return
literal|"EM_RISCV"
return|;
block|}
name|snprintf
argument_list|(
name|machdesc
argument_list|,
sizeof|sizeof
argument_list|(
name|machdesc
argument_list|)
argument_list|,
literal|"(unknown machine) -- type 0x%x"
argument_list|,
name|mach
argument_list|)
expr_stmt|;
return|return
operator|(
name|machdesc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|elf_type_str
parameter_list|(
name|unsigned
name|int
name|type
parameter_list|)
block|{
specifier|static
name|char
name|s_type
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ET_NONE
case|:
return|return
literal|"ET_NONE"
return|;
case|case
name|ET_REL
case|:
return|return
literal|"ET_REL"
return|;
case|case
name|ET_EXEC
case|:
return|return
literal|"ET_EXEC"
return|;
case|case
name|ET_DYN
case|:
return|return
literal|"ET_DYN"
return|;
case|case
name|ET_CORE
case|:
return|return
literal|"ET_CORE"
return|;
block|}
if|if
condition|(
name|type
operator|>=
name|ET_LOPROC
condition|)
name|snprintf
argument_list|(
name|s_type
argument_list|,
sizeof|sizeof
argument_list|(
name|s_type
argument_list|)
argument_list|,
literal|"<proc: %#x>"
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|>=
name|ET_LOOS
operator|&&
name|type
operator|<=
name|ET_HIOS
condition|)
name|snprintf
argument_list|(
name|s_type
argument_list|,
sizeof|sizeof
argument_list|(
name|s_type
argument_list|)
argument_list|,
literal|"<os: %#x>"
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|s_type
argument_list|,
sizeof|sizeof
argument_list|(
name|s_type
argument_list|)
argument_list|,
literal|"<unknown: %#x"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_type
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|elf_version_str
parameter_list|(
name|unsigned
name|int
name|ver
parameter_list|)
block|{
specifier|static
name|char
name|s_ver
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|ver
condition|)
block|{
case|case
name|EV_NONE
case|:
return|return
literal|"EV_NONE"
return|;
case|case
name|EV_CURRENT
case|:
return|return
literal|"EV_CURRENT"
return|;
block|}
name|snprintf
argument_list|(
name|s_ver
argument_list|,
sizeof|sizeof
argument_list|(
name|s_ver
argument_list|)
argument_list|,
literal|"<unknown: %#x>"
argument_list|,
name|ver
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_ver
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|elf_class_str
parameter_list|(
name|unsigned
name|int
name|class
parameter_list|)
block|{
specifier|static
name|char
name|s_class
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|ELFCLASSNONE
case|:
return|return
literal|"ELFCLASSNONE"
return|;
case|case
name|ELFCLASS32
case|:
return|return
literal|"ELFCLASS32"
return|;
case|case
name|ELFCLASS64
case|:
return|return
literal|"ELFCLASS64"
return|;
block|}
name|snprintf
argument_list|(
name|s_class
argument_list|,
sizeof|sizeof
argument_list|(
name|s_class
argument_list|)
argument_list|,
literal|"<unknown: %#x>"
argument_list|,
name|class
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_class
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|elf_data_str
parameter_list|(
name|unsigned
name|int
name|data
parameter_list|)
block|{
specifier|static
name|char
name|s_data
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|data
condition|)
block|{
case|case
name|ELFDATANONE
case|:
return|return
literal|"ELFDATANONE"
return|;
case|case
name|ELFDATA2LSB
case|:
return|return
literal|"ELFDATA2LSB"
return|;
case|case
name|ELFDATA2MSB
case|:
return|return
literal|"ELFDATA2MSB"
return|;
block|}
name|snprintf
argument_list|(
name|s_data
argument_list|,
sizeof|sizeof
argument_list|(
name|s_data
argument_list|)
argument_list|,
literal|"<unknown: %#x>"
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_data
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ei_abis
index|[
literal|256
index|]
init|=
block|{
literal|"ELFOSABI_NONE"
block|,
literal|"ELFOSABI_HPUX"
block|,
literal|"ELFOSABI_NETBSD"
block|,
literal|"ELFOSABI_LINUX"
block|,
literal|"ELFOSABI_HURD"
block|,
literal|"ELFOSABI_86OPEN"
block|,
literal|"ELFOSABI_SOLARIS"
block|,
literal|"ELFOSABI_AIX"
block|,
literal|"ELFOSABI_IRIX"
block|,
literal|"ELFOSABI_FREEBSD"
block|,
literal|"ELFOSABI_TRU64"
block|,
literal|"ELFOSABI_MODESTO"
block|,
literal|"ELFOSABI_OPENBSD"
block|,
index|[
literal|17
index|]
operator|=
literal|"ELFOSABI_CLOUDABI"
block|,
index|[
literal|64
index|]
operator|=
literal|"ELFOSABI_ARM_AEABI"
block|,
index|[
literal|97
index|]
operator|=
literal|"ELFOSABI_ARM"
block|,
index|[
literal|255
index|]
operator|=
literal|"ELFOSABI_STANDALONE"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|elf_phdr_type_str
parameter_list|(
name|unsigned
name|int
name|type
parameter_list|)
block|{
specifier|static
name|char
name|s_type
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|PT_NULL
case|:
return|return
literal|"PT_NULL"
return|;
case|case
name|PT_LOAD
case|:
return|return
literal|"PT_LOAD"
return|;
case|case
name|PT_DYNAMIC
case|:
return|return
literal|"PT_DYNAMIC"
return|;
case|case
name|PT_INTERP
case|:
return|return
literal|"PT_INTERP"
return|;
case|case
name|PT_NOTE
case|:
return|return
literal|"PT_NOTE"
return|;
case|case
name|PT_SHLIB
case|:
return|return
literal|"PT_SHLIB"
return|;
case|case
name|PT_PHDR
case|:
return|return
literal|"PT_PHDR"
return|;
case|case
name|PT_TLS
case|:
return|return
literal|"PT_TLS"
return|;
case|case
name|PT_GNU_EH_FRAME
case|:
return|return
literal|"PT_GNU_EH_FRAME"
return|;
case|case
name|PT_GNU_STACK
case|:
return|return
literal|"PT_GNU_STACK"
return|;
case|case
name|PT_GNU_RELRO
case|:
return|return
literal|"PT_GNU_RELRO"
return|;
block|}
name|snprintf
argument_list|(
name|s_type
argument_list|,
sizeof|sizeof
argument_list|(
name|s_type
argument_list|)
argument_list|,
literal|"<unknown: %#x>"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_type
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|p_flags
index|[]
init|=
block|{
literal|""
block|,
literal|"PF_X"
block|,
literal|"PF_W"
block|,
literal|"PF_X|PF_W"
block|,
literal|"PF_R"
block|,
literal|"PF_X|PF_R"
block|,
literal|"PF_W|PF_R"
block|,
literal|"PF_X|PF_W|PF_R"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|sh_name
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|int
name|ndx
parameter_list|)
block|{
specifier|static
name|char
name|num
index|[
literal|10
index|]
decl_stmt|;
switch|switch
condition|(
name|ndx
condition|)
block|{
case|case
name|SHN_UNDEF
case|:
return|return
literal|"UNDEF"
return|;
case|case
name|SHN_ABS
case|:
return|return
literal|"ABS"
return|;
case|case
name|SHN_COMMON
case|:
return|return
literal|"COMMON"
return|;
default|default:
if|if
condition|(
operator|(
name|uint64_t
operator|)
name|ndx
operator|<
name|ed
operator|->
name|shnum
condition|)
return|return
operator|(
name|ed
operator|->
name|sl
index|[
name|ndx
index|]
operator|.
name|name
operator|)
return|;
else|else
block|{
name|snprintf
argument_list|(
name|num
argument_list|,
sizeof|sizeof
argument_list|(
name|num
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|ndx
argument_list|)
expr_stmt|;
return|return
operator|(
name|num
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* http://www.sco.com/developers/gabi/latest/ch4.sheader.html#sh_type */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|sh_types
parameter_list|(
name|uint64_t
name|mach
parameter_list|,
name|uint64_t
name|sht
parameter_list|)
block|{
specifier|static
name|char
name|unknown_buf
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|sht
operator|<
literal|0x60000000
condition|)
block|{
switch|switch
condition|(
name|sht
condition|)
block|{
case|case
name|SHT_NULL
case|:
return|return
literal|"SHT_NULL"
return|;
case|case
name|SHT_PROGBITS
case|:
return|return
literal|"SHT_PROGBITS"
return|;
case|case
name|SHT_SYMTAB
case|:
return|return
literal|"SHT_SYMTAB"
return|;
case|case
name|SHT_STRTAB
case|:
return|return
literal|"SHT_STRTAB"
return|;
case|case
name|SHT_RELA
case|:
return|return
literal|"SHT_RELA"
return|;
case|case
name|SHT_HASH
case|:
return|return
literal|"SHT_HASH"
return|;
case|case
name|SHT_DYNAMIC
case|:
return|return
literal|"SHT_DYNAMIC"
return|;
case|case
name|SHT_NOTE
case|:
return|return
literal|"SHT_NOTE"
return|;
case|case
name|SHT_NOBITS
case|:
return|return
literal|"SHT_NOBITS"
return|;
case|case
name|SHT_REL
case|:
return|return
literal|"SHT_REL"
return|;
case|case
name|SHT_SHLIB
case|:
return|return
literal|"SHT_SHLIB"
return|;
case|case
name|SHT_DYNSYM
case|:
return|return
literal|"SHT_DYNSYM"
return|;
case|case
name|SHT_INIT_ARRAY
case|:
return|return
literal|"SHT_INIT_ARRAY"
return|;
case|case
name|SHT_FINI_ARRAY
case|:
return|return
literal|"SHT_FINI_ARRAY"
return|;
case|case
name|SHT_PREINIT_ARRAY
case|:
return|return
literal|"SHT_PREINIT_ARRAY"
return|;
case|case
name|SHT_GROUP
case|:
return|return
literal|"SHT_GROUP"
return|;
case|case
name|SHT_SYMTAB_SHNDX
case|:
return|return
literal|"SHT_SYMTAB_SHNDX"
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|sht
operator|<
literal|0x70000000
condition|)
block|{
comment|/* 0x60000000-0x6fffffff operating system-specific semantics */
switch|switch
condition|(
name|sht
condition|)
block|{
case|case
literal|0x6ffffff0
case|:
return|return
literal|"XXX:VERSYM"
return|;
case|case
name|SHT_SUNW_dof
case|:
return|return
literal|"SHT_SUNW_dof"
return|;
case|case
name|SHT_GNU_HASH
case|:
return|return
literal|"SHT_GNU_HASH"
return|;
case|case
literal|0x6ffffff7
case|:
return|return
literal|"SHT_GNU_LIBLIST"
return|;
case|case
literal|0x6ffffffc
case|:
return|return
literal|"XXX:VERDEF"
return|;
case|case
name|SHT_SUNW_verdef
case|:
return|return
literal|"SHT_SUNW(GNU)_verdef"
return|;
case|case
name|SHT_SUNW_verneed
case|:
return|return
literal|"SHT_SUNW(GNU)_verneed"
return|;
case|case
name|SHT_SUNW_versym
case|:
return|return
literal|"SHT_SUNW(GNU)_versym"
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|sht
operator|<
literal|0x80000000
condition|)
block|{
comment|/* 0x70000000 - 0x7fffffff processor-specific semantics */
switch|switch
condition|(
name|mach
condition|)
block|{
case|case
name|EM_ARM
case|:
switch|switch
condition|(
name|sht
condition|)
block|{
case|case
name|SHT_ARM_EXIDX
case|:
return|return
literal|"SHT_ARM_EXIDX"
return|;
case|case
name|SHT_ARM_PREEMPTMAP
case|:
return|return
literal|"SHT_ARM_PREEMPTMAP"
return|;
case|case
name|SHT_ARM_ATTRIBUTES
case|:
return|return
literal|"SHT_ARM_ATTRIBUTES"
return|;
case|case
name|SHT_ARM_DEBUGOVERLAY
case|:
return|return
literal|"SHT_ARM_DEBUGOVERLAY"
return|;
case|case
name|SHT_ARM_OVERLAYSECTION
case|:
return|return
literal|"SHT_ARM_OVERLAYSECTION"
return|;
block|}
break|break;
case|case
name|EM_IA_64
case|:
switch|switch
condition|(
name|sht
condition|)
block|{
case|case
literal|0x70000000
case|:
return|return
literal|"SHT_IA_64_EXT"
return|;
case|case
literal|0x70000001
case|:
return|return
literal|"SHT_IA_64_UNWIND"
return|;
block|}
break|break;
case|case
name|EM_MIPS
case|:
switch|switch
condition|(
name|sht
condition|)
block|{
case|case
name|SHT_MIPS_REGINFO
case|:
return|return
literal|"SHT_MIPS_REGINFO"
return|;
case|case
name|SHT_MIPS_OPTIONS
case|:
return|return
literal|"SHT_MIPS_OPTIONS"
return|;
case|case
name|SHT_MIPS_ABIFLAGS
case|:
return|return
literal|"SHT_MIPS_ABIFLAGS"
return|;
block|}
break|break;
block|}
switch|switch
condition|(
name|sht
condition|)
block|{
case|case
literal|0x7ffffffd
case|:
return|return
literal|"XXX:AUXILIARY"
return|;
case|case
literal|0x7fffffff
case|:
return|return
literal|"XXX:FILTER"
return|;
block|}
block|}
comment|/* 0x80000000 - 0xffffffff application programs */
name|snprintf
argument_list|(
name|unknown_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|unknown_buf
argument_list|)
argument_list|,
literal|"<unknown: %#llx>"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|sht
argument_list|)
expr_stmt|;
return|return
operator|(
name|unknown_buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Define known section flags. These flags are defined in the order  * they are to be printed out.  */
end_comment

begin_define
define|#
directive|define
name|DEFINE_SHFLAGS
parameter_list|()
define|\
value|DEFINE_SHF(WRITE)			\ 	DEFINE_SHF(ALLOC)			\ 	DEFINE_SHF(EXECINSTR)			\ 	DEFINE_SHF(MERGE)			\ 	DEFINE_SHF(STRINGS)			\ 	DEFINE_SHF(INFO_LINK)			\ 	DEFINE_SHF(LINK_ORDER)			\ 	DEFINE_SHF(OS_NONCONFORMING)		\ 	DEFINE_SHF(GROUP)			\ 	DEFINE_SHF(TLS)				\ 	DEFINE_SHF(COMPRESSED)
end_define

begin_undef
undef|#
directive|undef
name|DEFINE_SHF
end_undef

begin_define
define|#
directive|define
name|DEFINE_SHF
parameter_list|(
name|F
parameter_list|)
value|"SHF_" #F "|"
end_define

begin_define
define|#
directive|define
name|ALLSHFLAGS
value|DEFINE_SHFLAGS()
end_define

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|sh_flags
parameter_list|(
name|uint64_t
name|shf
parameter_list|)
block|{
specifier|static
name|char
name|flg
index|[
sizeof|sizeof
argument_list|(
name|ALLSHFLAGS
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
name|flg
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
undef|#
directive|undef
name|DEFINE_SHF
define|#
directive|define
name|DEFINE_SHF
parameter_list|(
name|N
parameter_list|)
define|\
value|if (shf& SHF_##N)			\ 		strcat(flg, "SHF_" #N "|");	\  	DEFINE_SHFLAGS()
name|flg
index|[
name|strlen
argument_list|(
name|flg
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Remove the trailing "|". */
return|return
operator|(
name|flg
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|st_type
parameter_list|(
name|unsigned
name|int
name|mach
parameter_list|,
name|unsigned
name|int
name|type
parameter_list|)
block|{
specifier|static
name|char
name|s_type
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|STT_NOTYPE
case|:
return|return
literal|"STT_NOTYPE"
return|;
case|case
name|STT_OBJECT
case|:
return|return
literal|"STT_OBJECT"
return|;
case|case
name|STT_FUNC
case|:
return|return
literal|"STT_FUNC"
return|;
case|case
name|STT_SECTION
case|:
return|return
literal|"STT_SECTION"
return|;
case|case
name|STT_FILE
case|:
return|return
literal|"STT_FILE"
return|;
case|case
name|STT_COMMON
case|:
return|return
literal|"STT_COMMON"
return|;
case|case
name|STT_TLS
case|:
return|return
literal|"STT_TLS"
return|;
case|case
literal|13
case|:
if|if
condition|(
name|mach
operator|==
name|EM_SPARCV9
condition|)
return|return
literal|"STT_SPARC_REGISTER"
return|;
break|break;
block|}
name|snprintf
argument_list|(
name|s_type
argument_list|,
sizeof|sizeof
argument_list|(
name|s_type
argument_list|)
argument_list|,
literal|"<unknown: %#x>"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_type
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|st_type_S
parameter_list|(
name|unsigned
name|int
name|type
parameter_list|)
block|{
specifier|static
name|char
name|s_type
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|STT_NOTYPE
case|:
return|return
literal|"NOTY"
return|;
case|case
name|STT_OBJECT
case|:
return|return
literal|"OBJT"
return|;
case|case
name|STT_FUNC
case|:
return|return
literal|"FUNC"
return|;
case|case
name|STT_SECTION
case|:
return|return
literal|"SECT"
return|;
case|case
name|STT_FILE
case|:
return|return
literal|"FILE"
return|;
block|}
name|snprintf
argument_list|(
name|s_type
argument_list|,
sizeof|sizeof
argument_list|(
name|s_type
argument_list|)
argument_list|,
literal|"<unknown: %#x>"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_type
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|st_bindings
parameter_list|(
name|unsigned
name|int
name|sbind
parameter_list|)
block|{
specifier|static
name|char
name|s_sbind
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|sbind
condition|)
block|{
case|case
name|STB_LOCAL
case|:
return|return
literal|"STB_LOCAL"
return|;
case|case
name|STB_GLOBAL
case|:
return|return
literal|"STB_GLOBAL"
return|;
case|case
name|STB_WEAK
case|:
return|return
literal|"STB_WEAK"
return|;
case|case
name|STB_GNU_UNIQUE
case|:
return|return
literal|"STB_GNU_UNIQUE"
return|;
default|default:
if|if
condition|(
name|sbind
operator|>=
name|STB_LOOS
operator|&&
name|sbind
operator|<=
name|STB_HIOS
condition|)
return|return
literal|"OS"
return|;
elseif|else
if|if
condition|(
name|sbind
operator|>=
name|STB_LOPROC
operator|&&
name|sbind
operator|<=
name|STB_HIPROC
condition|)
return|return
literal|"PROC"
return|;
else|else
name|snprintf
argument_list|(
name|s_sbind
argument_list|,
sizeof|sizeof
argument_list|(
name|s_sbind
argument_list|)
argument_list|,
literal|"<unknown: %#x>"
argument_list|,
name|sbind
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_sbind
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|st_bindings_S
parameter_list|(
name|unsigned
name|int
name|sbind
parameter_list|)
block|{
specifier|static
name|char
name|s_sbind
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|sbind
condition|)
block|{
case|case
name|STB_LOCAL
case|:
return|return
literal|"LOCL"
return|;
case|case
name|STB_GLOBAL
case|:
return|return
literal|"GLOB"
return|;
case|case
name|STB_WEAK
case|:
return|return
literal|"WEAK"
return|;
case|case
name|STB_GNU_UNIQUE
case|:
return|return
literal|"UNIQ"
return|;
default|default:
if|if
condition|(
name|sbind
operator|>=
name|STB_LOOS
operator|&&
name|sbind
operator|<=
name|STB_HIOS
condition|)
return|return
literal|"OS"
return|;
elseif|else
if|if
condition|(
name|sbind
operator|>=
name|STB_LOPROC
operator|&&
name|sbind
operator|<=
name|STB_HIPROC
condition|)
return|return
literal|"PROC"
return|;
else|else
name|snprintf
argument_list|(
name|s_sbind
argument_list|,
sizeof|sizeof
argument_list|(
name|s_sbind
argument_list|)
argument_list|,
literal|"<%#x>"
argument_list|,
name|sbind
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_sbind
operator|)
return|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|st_others
index|[]
init|=
block|{
literal|'D'
block|,
literal|'I'
block|,
literal|'H'
block|,
literal|'P'
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|add_name
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_object
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_elf
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_ehdr
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_phdr
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_shdr
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_symtab
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|int
name|i
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_symtabs
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_symver
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_verdef
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_verneed
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_interp
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_dynamic
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_rel_entry
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|,
name|int
name|j
parameter_list|,
name|struct
name|rel_entry
modifier|*
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_rela
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|,
name|Elf_Data
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_rel
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|,
name|Elf_Data
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_reloc
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_got
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_got_section
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_note
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_svr4_hash
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_svr4_hash64
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_gnu_hash
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_hash
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_checksum
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_gotrel
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|struct
name|section
modifier|*
name|gs
parameter_list|,
name|struct
name|rel_entry
modifier|*
name|got
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|spec_name
modifier|*
name|find_name
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_ent_count
parameter_list|(
specifier|const
name|struct
name|section
modifier|*
name|s
parameter_list|,
name|int
modifier|*
name|ent_count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|get_symbol_name
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|uint32_t
name|symtab
parameter_list|,
name|int
name|i
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|get_string
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|int
name|strtab
parameter_list|,
name|size_t
name|off
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_versym
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|int
name|i
parameter_list|,
name|uint16_t
modifier|*
modifier|*
name|vs
parameter_list|,
name|int
modifier|*
name|nvs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|load_sections
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unload_sections
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LIBARCHIVE_AR
end_ifdef

begin_function_decl
specifier|static
name|int
name|ac_detect_ar
parameter_list|(
name|int
name|fd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ac_print_ar
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|int
name|fd
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
name|elf_print_ar
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|int
name|fd
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_LIBARCHIVE_AR */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|option
name|elfdump_longopts
index|[]
init|=
block|{
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'H'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'V'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|struct
name|elfdump
modifier|*
name|ed
decl_stmt|,
name|ed_storage
decl_stmt|;
name|struct
name|spec_name
modifier|*
name|sn
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|i
decl_stmt|;
name|ed
operator|=
operator|&
name|ed_storage
expr_stmt|;
name|memset
argument_list|(
name|ed
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ed
argument_list|)
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|ed
operator|->
name|snl
argument_list|)
expr_stmt|;
name|ed
operator|->
name|out
operator|=
name|stdout
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt_long
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
literal|"acdeiGHhknN:prsSvVw:"
argument_list|,
name|elfdump_longopts
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'a'
case|:
name|ed
operator|->
name|options
operator|=
name|ED_ALL
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|ed
operator|->
name|options
operator||=
name|ED_SHDR
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|ed
operator|->
name|options
operator||=
name|ED_DYN
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|ed
operator|->
name|options
operator||=
name|ED_EHDR
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|ed
operator|->
name|options
operator||=
name|ED_INTERP
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|ed
operator|->
name|options
operator||=
name|ED_GOT
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|ed
operator|->
name|options
operator||=
name|ED_HASH
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|ed
operator|->
name|options
operator||=
name|ED_CHECKSUM
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|ed
operator|->
name|options
operator||=
name|ED_NOTE
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|add_name
argument_list|(
name|ed
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|ed
operator|->
name|options
operator||=
name|ED_PHDR
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|ed
operator|->
name|options
operator||=
name|ED_REL
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|ed
operator|->
name|options
operator||=
name|ED_SYMTAB
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|ed
operator|->
name|flags
operator||=
name|SOLARIS_FMT
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|ed
operator|->
name|options
operator||=
name|ED_SYMVER
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s (%s)\n"
argument_list|,
name|ELFTC_GETPROGNAME
argument_list|()
argument_list|,
name|elftc_version
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
operator|(
name|ed
operator|->
name|out
operator|=
name|fopen
argument_list|(
name|optarg
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"%s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
case|case
literal|'H'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
name|ac
operator|-=
name|optind
expr_stmt|;
name|av
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|options
operator|==
literal|0
condition|)
name|ed
operator|->
name|options
operator|=
name|ED_ALL
expr_stmt|;
name|sn
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|options
operator|&
name|ED_SYMTAB
operator|&&
operator|(
name|STAILQ_EMPTY
argument_list|(
operator|&
name|ed
operator|->
name|snl
argument_list|)
operator|||
operator|(
name|sn
operator|=
name|find_name
argument_list|(
name|ed
argument_list|,
literal|"ARSYM"
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|ed
operator|->
name|flags
operator||=
name|PRINT_ARSYM
expr_stmt|;
if|if
condition|(
name|sn
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|ed
operator|->
name|snl
argument_list|,
name|sn
argument_list|,
name|spec_name
argument_list|,
name|sn_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|STAILQ_EMPTY
argument_list|(
operator|&
name|ed
operator|->
name|snl
argument_list|)
condition|)
name|ed
operator|->
name|flags
operator||=
name|ONLY_ARSYM
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ac
operator|==
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|ac
operator|>
literal|1
condition|)
name|ed
operator|->
name|flags
operator||=
name|PRINT_FILENAME
expr_stmt|;
if|if
condition|(
name|elf_version
argument_list|(
name|EV_CURRENT
argument_list|)
operator|==
name|EV_NONE
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"ELF library initialization failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ac
condition|;
name|i
operator|++
control|)
block|{
name|ed
operator|->
name|filename
operator|=
name|av
index|[
name|i
index|]
expr_stmt|;
name|ed
operator|->
name|archive
operator|=
name|NULL
expr_stmt|;
name|elf_print_object
argument_list|(
name|ed
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LIBARCHIVE_AR
end_ifdef

begin_comment
comment|/* Archive symbol table entry. */
end_comment

begin_struct
struct|struct
name|arsym_entry
block|{
name|char
modifier|*
name|sym_name
decl_stmt|;
name|size_t
name|off
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Convenient wrapper for general libarchive error handling.  */
end_comment

begin_define
define|#
directive|define
name|AC
parameter_list|(
name|CALL
parameter_list|)
value|do {							\ 	if ((CALL)) {							\ 		warnx("%s", archive_error_string(a));			\ 		return;							\ 	}								\ } while (0)
end_define

begin_comment
comment|/*  * Detect an ar(1) archive using libarchive(3).  */
end_comment

begin_function
specifier|static
name|int
name|ac_detect_ar
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|struct
name|archive
modifier|*
name|a
decl_stmt|;
name|struct
name|archive_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|a
operator|=
name|archive_read_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|archive_read_support_format_ar
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_read_open_fd
argument_list|(
name|a
argument_list|,
name|fd
argument_list|,
literal|10240
argument_list|)
operator|==
name|ARCHIVE_OK
condition|)
name|r
operator|=
name|archive_read_next_header
argument_list|(
name|a
argument_list|,
operator|&
name|entry
argument_list|)
expr_stmt|;
name|archive_read_close
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|archive_read_free
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|==
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dump an ar(1) archive using libarchive(3).  */
end_comment

begin_function
specifier|static
name|void
name|ac_print_ar
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|struct
name|archive
modifier|*
name|a
decl_stmt|;
name|struct
name|archive_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|arsym_entry
modifier|*
name|arsym
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|idx
index|[
literal|10
index|]
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|void
modifier|*
name|buff
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|uint32_t
name|cnt
decl_stmt|,
name|i
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"lseek failed"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|a
operator|=
name|archive_read_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|archive_read_support_format_ar
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|AC
argument_list|(
name|archive_read_open_fd
argument_list|(
name|a
argument_list|,
name|fd
argument_list|,
literal|10240
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|r
operator|=
name|archive_read_next_header
argument_list|(
name|a
argument_list|,
operator|&
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_FATAL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_EOF
condition|)
break|break;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_WARN
operator|||
name|r
operator|==
name|ARCHIVE_RETRY
condition|)
name|warnx
argument_list|(
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_RETRY
condition|)
continue|continue;
name|name
operator|=
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|size
operator|=
name|archive_entry_size
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|buff
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"malloc failed"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|archive_read_data
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|size
argument_list|)
operator|!=
operator|(
name|ssize_t
operator|)
name|size
condition|)
block|{
name|warnx
argument_list|(
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buff
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Note that when processing arsym via libarchive, there is 		 * no way to tell which member a certain symbol belongs to, 		 * since we can not just "lseek" to a member offset and read 		 * the member header. 		 */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"/"
argument_list|)
operator|&&
name|ed
operator|->
name|flags
operator|&
name|PRINT_ARSYM
condition|)
block|{
name|b
operator|=
name|buff
expr_stmt|;
name|cnt
operator|=
name|be32dec
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|buff
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|arsym
operator|=
name|calloc
argument_list|(
name|cnt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|arsym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arsym
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
name|b
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|arsym
index|[
name|i
index|]
operator|.
name|off
operator|=
name|be32dec
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|arsym
index|[
name|i
index|]
operator|.
name|sym_name
operator|=
name|b
expr_stmt|;
name|b
operator|+=
name|strlen
argument_list|(
name|b
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
block|{
name|PRT
argument_list|(
literal|"\nSymbol Table: (archive)\n"
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"     index    offset    symbol\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|PRT
argument_list|(
literal|"\nsymbol table (archive):\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
block|{
name|snprintf
argument_list|(
name|idx
argument_list|,
sizeof|sizeof
argument_list|(
name|idx
argument_list|)
argument_list|,
literal|"[%d]"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"%10s  "
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"0x%8.8jx  "
argument_list|,
operator|(
name|uintmax_t
operator|)
name|arsym
index|[
name|i
index|]
operator|.
name|off
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"%s\n"
argument_list|,
name|arsym
index|[
name|i
index|]
operator|.
name|sym_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PRT
argument_list|(
literal|"\nentry: %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\toffset: %#jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|arsym
index|[
name|i
index|]
operator|.
name|off
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tsymbol: %s\n"
argument_list|,
name|arsym
index|[
name|i
index|]
operator|.
name|sym_name
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|arsym
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buff
argument_list|)
expr_stmt|;
comment|/* No need to continue if we only dump ARSYM. */
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|ONLY_ARSYM
condition|)
block|{
name|AC
argument_list|(
name|archive_read_close
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|AC
argument_list|(
name|archive_read_free
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
continue|continue;
block|}
if|if
condition|(
operator|(
name|ed
operator|->
name|elf
operator|=
name|elf_memory
argument_list|(
name|buff
argument_list|,
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_memroy() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buff
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Skip non-ELF member. */
if|if
condition|(
name|elf_kind
argument_list|(
name|ed
operator|->
name|elf
argument_list|)
operator|==
name|ELF_K_ELF
condition|)
block|{
name|printf
argument_list|(
literal|"\n%s(%s):\n"
argument_list|,
name|ed
operator|->
name|archive
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|elf_print_elf
argument_list|(
name|ed
argument_list|)
expr_stmt|;
block|}
name|elf_end
argument_list|(
name|ed
operator|->
name|elf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
name|AC
argument_list|(
name|archive_read_close
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|AC
argument_list|(
name|archive_read_free
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* USE_LIBARCHIVE_AR */
end_comment

begin_comment
comment|/*  * Dump an ar(1) archive.  */
end_comment

begin_function
specifier|static
name|void
name|elf_print_ar
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|Elf
modifier|*
name|e
decl_stmt|;
name|Elf_Arhdr
modifier|*
name|arh
decl_stmt|;
name|Elf_Arsym
modifier|*
name|arsym
decl_stmt|;
name|Elf_Cmd
name|cmd
decl_stmt|;
name|char
name|idx
index|[
literal|10
index|]
decl_stmt|;
name|size_t
name|cnt
decl_stmt|,
name|i
decl_stmt|;
name|ed
operator|->
name|ar
operator|=
name|ed
operator|->
name|elf
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|PRINT_ARSYM
condition|)
block|{
name|cnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|arsym
operator|=
name|elf_getarsym
argument_list|(
name|ed
operator|->
name|ar
argument_list|,
operator|&
name|cnt
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_getarsym failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|print_members
goto|;
block|}
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
goto|goto
name|print_members
goto|;
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
block|{
name|PRT
argument_list|(
literal|"\nSymbol Table: (archive)\n"
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"     index    offset    member name and symbol\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|PRT
argument_list|(
literal|"\nsymbol table (archive):\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|elf_rand
argument_list|(
name|ed
operator|->
name|ar
argument_list|,
name|arsym
index|[
name|i
index|]
operator|.
name|as_off
argument_list|)
operator|!=
name|arsym
index|[
name|i
index|]
operator|.
name|as_off
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_rand failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|e
operator|=
name|elf_begin
argument_list|(
name|fd
argument_list|,
name|ELF_C_READ
argument_list|,
name|ed
operator|->
name|ar
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_begin failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|arh
operator|=
name|elf_getarhdr
argument_list|(
name|e
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_getarhdr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
block|{
name|snprintf
argument_list|(
name|idx
argument_list|,
sizeof|sizeof
argument_list|(
name|idx
argument_list|)
argument_list|,
literal|"[%zu]"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"%10s  "
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"0x%8.8jx  "
argument_list|,
operator|(
name|uintmax_t
operator|)
name|arsym
index|[
name|i
index|]
operator|.
name|as_off
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"(%s):%s\n"
argument_list|,
name|arh
operator|->
name|ar_name
argument_list|,
name|arsym
index|[
name|i
index|]
operator|.
name|as_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PRT
argument_list|(
literal|"\nentry: %zu\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\toffset: %#jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|arsym
index|[
name|i
index|]
operator|.
name|as_off
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tmember: %s\n"
argument_list|,
name|arh
operator|->
name|ar_name
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tsymbol: %s\n"
argument_list|,
name|arsym
index|[
name|i
index|]
operator|.
name|as_name
argument_list|)
expr_stmt|;
block|}
name|elf_end
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
comment|/* No need to continue if we only dump ARSYM. */
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|ONLY_ARSYM
condition|)
return|return;
block|}
name|print_members
label|:
comment|/* Rewind the archive. */
if|if
condition|(
name|elf_rand
argument_list|(
name|ed
operator|->
name|ar
argument_list|,
name|SARMAG
argument_list|)
operator|!=
name|SARMAG
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_rand failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Dump each member of the archive. */
name|cmd
operator|=
name|ELF_C_READ
expr_stmt|;
while|while
condition|(
operator|(
name|ed
operator|->
name|elf
operator|=
name|elf_begin
argument_list|(
name|fd
argument_list|,
name|cmd
argument_list|,
name|ed
operator|->
name|ar
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Skip non-ELF member. */
if|if
condition|(
name|elf_kind
argument_list|(
name|ed
operator|->
name|elf
argument_list|)
operator|==
name|ELF_K_ELF
condition|)
block|{
if|if
condition|(
operator|(
name|arh
operator|=
name|elf_getarhdr
argument_list|(
name|ed
operator|->
name|elf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_getarhdr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"\n%s(%s):\n"
argument_list|,
name|ed
operator|->
name|archive
argument_list|,
name|arh
operator|->
name|ar_name
argument_list|)
expr_stmt|;
name|elf_print_elf
argument_list|(
name|ed
argument_list|)
expr_stmt|;
block|}
name|cmd
operator|=
name|elf_next
argument_list|(
name|ed
operator|->
name|elf
argument_list|)
expr_stmt|;
name|elf_end
argument_list|(
name|ed
operator|->
name|elf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_LIBARCHIVE_AR */
end_comment

begin_comment
comment|/*  * Dump an object. (ELF object or ar(1) archive)  */
end_comment

begin_function
specifier|static
name|void
name|elf_print_object
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|ed
operator|->
name|filename
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"open %s failed"
argument_list|,
name|ed
operator|->
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|USE_LIBARCHIVE_AR
if|if
condition|(
name|ac_detect_ar
argument_list|(
name|fd
argument_list|)
condition|)
block|{
name|ed
operator|->
name|archive
operator|=
name|ed
operator|->
name|filename
expr_stmt|;
name|ac_print_ar
argument_list|(
name|ed
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* USE_LIBARCHIVE_AR */
if|if
condition|(
operator|(
name|ed
operator|->
name|elf
operator|=
name|elf_begin
argument_list|(
name|fd
argument_list|,
name|ELF_C_READ
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_begin() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|elf_kind
argument_list|(
name|ed
operator|->
name|elf
argument_list|)
condition|)
block|{
case|case
name|ELF_K_NONE
case|:
name|warnx
argument_list|(
literal|"Not an ELF file."
argument_list|)
expr_stmt|;
return|return;
case|case
name|ELF_K_ELF
case|:
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|PRINT_FILENAME
condition|)
name|printf
argument_list|(
literal|"\n%s:\n"
argument_list|,
name|ed
operator|->
name|filename
argument_list|)
expr_stmt|;
name|elf_print_elf
argument_list|(
name|ed
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELF_K_AR
case|:
ifndef|#
directive|ifndef
name|USE_LIBARCHIVE_AR
name|ed
operator|->
name|archive
operator|=
name|ed
operator|->
name|filename
expr_stmt|;
name|elf_print_ar
argument_list|(
name|ed
argument_list|,
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|warnx
argument_list|(
literal|"Internal: libelf returned unknown elf kind."
argument_list|)
expr_stmt|;
return|return;
block|}
name|elf_end
argument_list|(
name|ed
operator|->
name|elf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dump an ELF object.  */
end_comment

begin_function
specifier|static
name|void
name|elf_print_elf
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
block|{
if|if
condition|(
name|gelf_getehdr
argument_list|(
name|ed
operator|->
name|elf
argument_list|,
operator|&
name|ed
operator|->
name|ehdr
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"gelf_getehdr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|ed
operator|->
name|ec
operator|=
name|gelf_getclass
argument_list|(
name|ed
operator|->
name|elf
argument_list|)
operator|)
operator|==
name|ELFCLASSNONE
condition|)
block|{
name|warnx
argument_list|(
literal|"gelf_getclass failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ed
operator|->
name|options
operator|&
operator|(
name|ED_SHDR
operator||
name|ED_DYN
operator||
name|ED_REL
operator||
name|ED_GOT
operator||
name|ED_SYMTAB
operator||
name|ED_SYMVER
operator||
name|ED_NOTE
operator||
name|ED_HASH
operator|)
condition|)
name|load_sections
argument_list|(
name|ed
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|options
operator|&
name|ED_EHDR
condition|)
name|elf_print_ehdr
argument_list|(
name|ed
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|options
operator|&
name|ED_PHDR
condition|)
name|elf_print_phdr
argument_list|(
name|ed
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|options
operator|&
name|ED_INTERP
condition|)
name|elf_print_interp
argument_list|(
name|ed
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|options
operator|&
name|ED_SHDR
condition|)
name|elf_print_shdr
argument_list|(
name|ed
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|options
operator|&
name|ED_DYN
condition|)
name|elf_print_dynamic
argument_list|(
name|ed
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|options
operator|&
name|ED_REL
condition|)
name|elf_print_reloc
argument_list|(
name|ed
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|options
operator|&
name|ED_GOT
condition|)
name|elf_print_got
argument_list|(
name|ed
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|options
operator|&
name|ED_SYMTAB
condition|)
name|elf_print_symtabs
argument_list|(
name|ed
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|options
operator|&
name|ED_SYMVER
condition|)
name|elf_print_symver
argument_list|(
name|ed
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|options
operator|&
name|ED_NOTE
condition|)
name|elf_print_note
argument_list|(
name|ed
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|options
operator|&
name|ED_HASH
condition|)
name|elf_print_hash
argument_list|(
name|ed
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|options
operator|&
name|ED_CHECKSUM
condition|)
name|elf_print_checksum
argument_list|(
name|ed
argument_list|)
expr_stmt|;
name|unload_sections
argument_list|(
name|ed
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read the section headers from ELF object and store them in the  * internal cache.  */
end_comment

begin_function
specifier|static
name|void
name|load_sections
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|Elf_Scn
modifier|*
name|scn
decl_stmt|;
name|GElf_Shdr
name|sh
decl_stmt|;
name|size_t
name|shstrndx
decl_stmt|,
name|ndx
decl_stmt|;
name|int
name|elferr
decl_stmt|;
name|assert
argument_list|(
name|ed
operator|->
name|sl
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_getshnum
argument_list|(
name|ed
operator|->
name|elf
argument_list|,
operator|&
name|ed
operator|->
name|shnum
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_getshnum failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ed
operator|->
name|shnum
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|ed
operator|->
name|sl
operator|=
name|calloc
argument_list|(
name|ed
operator|->
name|shnum
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ed
operator|->
name|sl
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_getshstrndx
argument_list|(
name|ed
operator|->
name|elf
argument_list|,
operator|&
name|shstrndx
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_getshstrndx failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|scn
operator|=
name|elf_getscn
argument_list|(
name|ed
operator|->
name|elf
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_getscn failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
do|do
block|{
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|scn
argument_list|,
operator|&
name|sh
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"gelf_getshdr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|name
operator|=
name|elf_strptr
argument_list|(
name|ed
operator|->
name|elf
argument_list|,
name|shstrndx
argument_list|,
name|sh
operator|.
name|sh_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
name|name
operator|=
literal|"ERROR"
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ndx
operator|=
name|elf_ndxscn
argument_list|(
name|scn
argument_list|)
operator|)
operator|==
name|SHN_UNDEF
condition|)
if|if
condition|(
operator|(
name|elferr
operator|=
name|elf_errno
argument_list|()
operator|)
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_ndxscn failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ndx
operator|>=
name|ed
operator|->
name|shnum
condition|)
block|{
name|warnx
argument_list|(
literal|"section index of '%s' out of range"
argument_list|,
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|s
operator|=
operator|&
name|ed
operator|->
name|sl
index|[
name|ndx
index|]
expr_stmt|;
name|s
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|s
operator|->
name|scn
operator|=
name|scn
expr_stmt|;
name|s
operator|->
name|off
operator|=
name|sh
operator|.
name|sh_offset
expr_stmt|;
name|s
operator|->
name|sz
operator|=
name|sh
operator|.
name|sh_size
expr_stmt|;
name|s
operator|->
name|entsize
operator|=
name|sh
operator|.
name|sh_entsize
expr_stmt|;
name|s
operator|->
name|align
operator|=
name|sh
operator|.
name|sh_addralign
expr_stmt|;
name|s
operator|->
name|type
operator|=
name|sh
operator|.
name|sh_type
expr_stmt|;
name|s
operator|->
name|flags
operator|=
name|sh
operator|.
name|sh_flags
expr_stmt|;
name|s
operator|->
name|addr
operator|=
name|sh
operator|.
name|sh_addr
expr_stmt|;
name|s
operator|->
name|link
operator|=
name|sh
operator|.
name|sh_link
expr_stmt|;
name|s
operator|->
name|info
operator|=
name|sh
operator|.
name|sh_info
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|scn
operator|=
name|elf_nextscn
argument_list|(
name|ed
operator|->
name|elf
argument_list|,
name|scn
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
do|;
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_nextscn failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Release section related resources.  */
end_comment

begin_function
specifier|static
name|void
name|unload_sections
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
block|{
if|if
condition|(
name|ed
operator|->
name|sl
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ed
operator|->
name|sl
argument_list|)
expr_stmt|;
name|ed
operator|->
name|sl
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Add a name to the '-N' name list.  */
end_comment

begin_function
specifier|static
name|void
name|add_name
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|spec_name
modifier|*
name|sn
decl_stmt|;
if|if
condition|(
name|find_name
argument_list|(
name|ed
argument_list|,
name|name
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|sn
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sn
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"malloc failed"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sn
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ed
operator|->
name|snl
argument_list|,
name|sn
argument_list|,
name|sn_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Lookup a name in the '-N' name list.  */
end_comment

begin_function
specifier|static
name|struct
name|spec_name
modifier|*
name|find_name
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|spec_name
modifier|*
name|sn
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|sn
argument_list|,
argument|&ed->snl
argument_list|,
argument|sn_list
argument_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sn
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
operator|(
name|sn
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve the name of a symbol using the section index of the symbol  * table and the index of the symbol within that table.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_symbol_name
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|uint32_t
name|symtab
parameter_list|,
name|int
name|i
parameter_list|)
block|{
specifier|static
name|char
name|sname
index|[
literal|64
index|]
decl_stmt|;
name|struct
name|section
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|GElf_Sym
name|sym
decl_stmt|;
name|Elf_Data
modifier|*
name|data
decl_stmt|;
name|int
name|elferr
decl_stmt|;
if|if
condition|(
name|symtab
operator|>=
name|ed
operator|->
name|shnum
condition|)
return|return
operator|(
literal|""
operator|)
return|;
name|s
operator|=
operator|&
name|ed
operator|->
name|sl
index|[
name|symtab
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|!=
name|SHT_SYMTAB
operator|&&
name|s
operator|->
name|type
operator|!=
name|SHT_DYNSYM
condition|)
return|return
operator|(
literal|""
operator|)
return|;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|""
operator|)
return|;
block|}
if|if
condition|(
name|gelf_getsym
argument_list|(
name|data
argument_list|,
name|i
argument_list|,
operator|&
name|sym
argument_list|)
operator|!=
operator|&
name|sym
condition|)
return|return
operator|(
literal|""
operator|)
return|;
if|if
condition|(
name|GELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|<
name|ed
operator|->
name|shnum
condition|)
block|{
name|snprintf
argument_list|(
name|sname
argument_list|,
sizeof|sizeof
argument_list|(
name|sname
argument_list|)
argument_list|,
literal|"%s (section)"
argument_list|,
name|ed
operator|->
name|sl
index|[
name|sym
operator|.
name|st_shndx
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|sname
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|""
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|name
operator|=
name|elf_strptr
argument_list|(
name|ed
operator|->
name|elf
argument_list|,
name|s
operator|->
name|link
argument_list|,
name|sym
operator|.
name|st_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|""
operator|)
return|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve a string using string table section index and the string offset.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_string
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|int
name|strtab
parameter_list|,
name|size_t
name|off
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|(
name|name
operator|=
name|elf_strptr
argument_list|(
name|ed
operator|->
name|elf
argument_list|,
name|strtab
argument_list|,
name|off
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|""
operator|)
return|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dump the ELF Executable Header.  */
end_comment

begin_function
specifier|static
name|void
name|elf_print_ehdr
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
block|{
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|ed
operator|->
name|snl
argument_list|)
condition|)
return|return;
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
block|{
name|PRT
argument_list|(
literal|"\nELF Header\n"
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"  ei_magic:   { %#x, %c, %c, %c }\n"
argument_list|,
name|ed
operator|->
name|ehdr
operator|.
name|e_ident
index|[
literal|0
index|]
argument_list|,
name|ed
operator|->
name|ehdr
operator|.
name|e_ident
index|[
literal|1
index|]
argument_list|,
name|ed
operator|->
name|ehdr
operator|.
name|e_ident
index|[
literal|2
index|]
argument_list|,
name|ed
operator|->
name|ehdr
operator|.
name|e_ident
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"  ei_class:   %-18s"
argument_list|,
name|elf_class_str
argument_list|(
name|ed
operator|->
name|ehdr
operator|.
name|e_ident
index|[
name|EI_CLASS
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"  ei_data:      %s\n"
argument_list|,
name|elf_data_str
argument_list|(
name|ed
operator|->
name|ehdr
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"  e_machine:  %-18s"
argument_list|,
name|e_machines
argument_list|(
name|ed
operator|->
name|ehdr
operator|.
name|e_machine
argument_list|)
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"  e_version:    %s\n"
argument_list|,
name|elf_version_str
argument_list|(
name|ed
operator|->
name|ehdr
operator|.
name|e_version
argument_list|)
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"  e_type:     %s\n"
argument_list|,
name|elf_type_str
argument_list|(
name|ed
operator|->
name|ehdr
operator|.
name|e_type
argument_list|)
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"  e_flags:    %18d\n"
argument_list|,
name|ed
operator|->
name|ehdr
operator|.
name|e_flags
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"  e_entry:    %#18jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ed
operator|->
name|ehdr
operator|.
name|e_entry
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"  e_ehsize: %6d"
argument_list|,
name|ed
operator|->
name|ehdr
operator|.
name|e_ehsize
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"  e_shstrndx:%5d\n"
argument_list|,
name|ed
operator|->
name|ehdr
operator|.
name|e_shstrndx
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"  e_shoff:    %#18jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ed
operator|->
name|ehdr
operator|.
name|e_shoff
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"  e_shentsize: %3d"
argument_list|,
name|ed
operator|->
name|ehdr
operator|.
name|e_shentsize
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"  e_shnum:   %5d\n"
argument_list|,
name|ed
operator|->
name|ehdr
operator|.
name|e_shnum
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"  e_phoff:    %#18jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ed
operator|->
name|ehdr
operator|.
name|e_phoff
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"  e_phentsize: %3d"
argument_list|,
name|ed
operator|->
name|ehdr
operator|.
name|e_phentsize
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"  e_phnum:   %5d\n"
argument_list|,
name|ed
operator|->
name|ehdr
operator|.
name|e_phnum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PRT
argument_list|(
literal|"\nelf header:\n"
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\te_ident: %s %s %s\n"
argument_list|,
name|elf_class_str
argument_list|(
name|ed
operator|->
name|ehdr
operator|.
name|e_ident
index|[
name|EI_CLASS
index|]
argument_list|)
argument_list|,
name|elf_data_str
argument_list|(
name|ed
operator|->
name|ehdr
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
argument_list|)
argument_list|,
name|ei_abis
index|[
name|ed
operator|->
name|ehdr
operator|.
name|e_ident
index|[
name|EI_OSABI
index|]
index|]
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\te_type: %s\n"
argument_list|,
name|elf_type_str
argument_list|(
name|ed
operator|->
name|ehdr
operator|.
name|e_type
argument_list|)
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\te_machine: %s\n"
argument_list|,
name|e_machines
argument_list|(
name|ed
operator|->
name|ehdr
operator|.
name|e_machine
argument_list|)
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\te_version: %s\n"
argument_list|,
name|elf_version_str
argument_list|(
name|ed
operator|->
name|ehdr
operator|.
name|e_version
argument_list|)
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\te_entry: %#jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ed
operator|->
name|ehdr
operator|.
name|e_entry
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\te_phoff: %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ed
operator|->
name|ehdr
operator|.
name|e_phoff
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\te_shoff: %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ed
operator|->
name|ehdr
operator|.
name|e_shoff
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\te_flags: %u\n"
argument_list|,
name|ed
operator|->
name|ehdr
operator|.
name|e_flags
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\te_ehsize: %u\n"
argument_list|,
name|ed
operator|->
name|ehdr
operator|.
name|e_ehsize
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\te_phentsize: %u\n"
argument_list|,
name|ed
operator|->
name|ehdr
operator|.
name|e_phentsize
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\te_phnum: %u\n"
argument_list|,
name|ed
operator|->
name|ehdr
operator|.
name|e_phnum
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\te_shentsize: %u\n"
argument_list|,
name|ed
operator|->
name|ehdr
operator|.
name|e_shentsize
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\te_shnum: %u\n"
argument_list|,
name|ed
operator|->
name|ehdr
operator|.
name|e_shnum
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\te_shstrndx: %u\n"
argument_list|,
name|ed
operator|->
name|ehdr
operator|.
name|e_shstrndx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Dump the ELF Program Header Table.  */
end_comment

begin_function
specifier|static
name|void
name|elf_print_phdr
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
block|{
name|GElf_Phdr
name|ph
decl_stmt|;
name|size_t
name|phnum
decl_stmt|,
name|i
decl_stmt|;
name|int
name|header
decl_stmt|;
if|if
condition|(
name|elf_getphnum
argument_list|(
name|ed
operator|->
name|elf
argument_list|,
operator|&
name|phnum
argument_list|)
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_getphnum failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|header
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|phnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|gelf_getphdr
argument_list|(
name|ed
operator|->
name|elf
argument_list|,
name|i
argument_list|,
operator|&
name|ph
argument_list|)
operator|!=
operator|&
name|ph
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_getphdr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|ed
operator|->
name|snl
argument_list|)
operator|&&
name|find_name
argument_list|(
name|ed
argument_list|,
name|elf_phdr_type_str
argument_list|(
name|ph
operator|.
name|p_type
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
block|{
name|PRT
argument_list|(
literal|"\nProgram Header[%zu]:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"    p_vaddr:      %#-14jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ph
operator|.
name|p_vaddr
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"  p_flags:    [ %s ]\n"
argument_list|,
name|p_flags
index|[
name|ph
operator|.
name|p_flags
operator|&
literal|0x7
index|]
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"    p_paddr:      %#-14jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ph
operator|.
name|p_paddr
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"  p_type:     [ %s ]\n"
argument_list|,
name|elf_phdr_type_str
argument_list|(
name|ph
operator|.
name|p_type
argument_list|)
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"    p_filesz:     %#-14jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ph
operator|.
name|p_filesz
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"  p_memsz:    %#jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ph
operator|.
name|p_memsz
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"    p_offset:     %#-14jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ph
operator|.
name|p_offset
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"  p_align:    %#jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ph
operator|.
name|p_align
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|header
condition|)
block|{
name|PRT
argument_list|(
literal|"\nprogram header:\n"
argument_list|)
expr_stmt|;
name|header
operator|=
literal|1
expr_stmt|;
block|}
name|PRT
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"entry: %zu\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tp_type: %s\n"
argument_list|,
name|elf_phdr_type_str
argument_list|(
name|ph
operator|.
name|p_type
argument_list|)
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tp_offset: %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ph
operator|.
name|p_offset
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tp_vaddr: %#jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ph
operator|.
name|p_vaddr
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tp_paddr: %#jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ph
operator|.
name|p_paddr
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tp_filesz: %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ph
operator|.
name|p_filesz
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tp_memsz: %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ph
operator|.
name|p_memsz
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tp_flags: %s\n"
argument_list|,
name|p_flags
index|[
name|ph
operator|.
name|p_flags
operator|&
literal|0x7
index|]
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tp_align: %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ph
operator|.
name|p_align
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Dump the ELF Section Header Table.  */
end_comment

begin_function
specifier|static
name|void
name|elf_print_shdr
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|size_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|ed
operator|->
name|snl
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
operator|)
operator|==
literal|0
condition|)
name|PRT
argument_list|(
literal|"\nsection header:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ed
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|ed
operator|->
name|sl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
continue|continue;
name|PRT
argument_list|(
literal|"\nSection Header[%zu]:"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"  sh_name: %s\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"    sh_addr:      %#-14jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|s
operator|->
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|flags
operator|!=
literal|0
condition|)
name|PRT
argument_list|(
literal|"  sh_flags:   [ %s ]\n"
argument_list|,
name|sh_flags
argument_list|(
name|s
operator|->
name|flags
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|PRT
argument_list|(
literal|"  sh_flags:   0\n"
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"    sh_size:      %#-14jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|s
operator|->
name|sz
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"  sh_type:    [ %s ]\n"
argument_list|,
name|sh_types
argument_list|(
name|ed
operator|->
name|ehdr
operator|.
name|e_machine
argument_list|,
name|s
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"    sh_offset:    %#-14jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|s
operator|->
name|off
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"  sh_entsize: %#jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|s
operator|->
name|entsize
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"    sh_link:      %-14u"
argument_list|,
name|s
operator|->
name|link
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"  sh_info:    %u\n"
argument_list|,
name|s
operator|->
name|info
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"    sh_addralign: %#jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|s
operator|->
name|align
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PRT
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"entry: %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|i
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tsh_name: %s\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tsh_type: %s\n"
argument_list|,
name|sh_types
argument_list|(
name|ed
operator|->
name|ehdr
operator|.
name|e_machine
argument_list|,
name|s
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tsh_flags: %s\n"
argument_list|,
name|sh_flags
argument_list|(
name|s
operator|->
name|flags
argument_list|)
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tsh_addr: %#jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|s
operator|->
name|addr
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tsh_offset: %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|s
operator|->
name|off
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tsh_size: %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|s
operator|->
name|sz
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tsh_link: %u\n"
argument_list|,
name|s
operator|->
name|link
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tsh_info: %u\n"
argument_list|,
name|s
operator|->
name|info
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tsh_addralign: %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|s
operator|->
name|align
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tsh_entsize: %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|s
operator|->
name|entsize
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Return number of entries in the given section. We'd prefer ent_count be a  * size_t, but libelf APIs already use int for section indices.  */
end_comment

begin_function
specifier|static
name|int
name|get_ent_count
parameter_list|(
specifier|const
name|struct
name|section
modifier|*
name|s
parameter_list|,
name|int
modifier|*
name|ent_count
parameter_list|)
block|{
if|if
condition|(
name|s
operator|->
name|entsize
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"section %s has entry size 0"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|sz
operator|/
name|s
operator|->
name|entsize
operator|>
name|INT_MAX
condition|)
block|{
name|warnx
argument_list|(
literal|"section %s has invalid section count"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|ent_count
operator|=
call|(
name|int
call|)
argument_list|(
name|s
operator|->
name|sz
operator|/
name|s
operator|->
name|entsize
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve the content of the corresponding SHT_SUNW_versym section for  * a symbol table section.  */
end_comment

begin_function
specifier|static
name|void
name|get_versym
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|int
name|i
parameter_list|,
name|uint16_t
modifier|*
modifier|*
name|vs
parameter_list|,
name|int
modifier|*
name|nvs
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|Elf_Data
modifier|*
name|data
decl_stmt|;
name|size_t
name|j
decl_stmt|;
name|int
name|elferr
decl_stmt|;
name|s
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ed
operator|->
name|shnum
condition|;
name|j
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|ed
operator|->
name|sl
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|SHT_SUNW_versym
operator|&&
name|s
operator|->
name|link
operator|==
operator|(
name|uint32_t
operator|)
name|i
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|>=
name|ed
operator|->
name|shnum
condition|)
block|{
operator|*
name|vs
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|vs
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
operator|*
name|vs
operator|=
name|data
operator|->
name|d_buf
expr_stmt|;
name|assert
argument_list|(
name|data
operator|->
name|d_size
operator|==
name|s
operator|->
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_ent_count
argument_list|(
name|s
argument_list|,
name|nvs
argument_list|)
condition|)
operator|*
name|nvs
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dump the symbol table section.  */
end_comment

begin_function
specifier|static
name|void
name|elf_print_symtab
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|uint16_t
modifier|*
name|vs
decl_stmt|;
name|char
name|idx
index|[
literal|10
index|]
decl_stmt|;
name|Elf_Data
modifier|*
name|data
decl_stmt|;
name|GElf_Sym
name|sym
decl_stmt|;
name|int
name|len
decl_stmt|,
name|j
decl_stmt|,
name|elferr
decl_stmt|,
name|nvs
decl_stmt|;
name|s
operator|=
operator|&
name|ed
operator|->
name|sl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
name|PRT
argument_list|(
literal|"\nSymbol Table Section:  %s\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|PRT
argument_list|(
literal|"\nsymbol table (%s):\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|vs
operator|=
name|NULL
expr_stmt|;
name|nvs
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
name|data
operator|->
name|d_size
operator|==
name|s
operator|->
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_ent_count
argument_list|(
name|s
argument_list|,
operator|&
name|len
argument_list|)
condition|)
return|return;
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
block|{
if|if
condition|(
name|ed
operator|->
name|ec
operator|==
name|ELFCLASS32
condition|)
name|PRT
argument_list|(
literal|"     index    value       "
argument_list|)
expr_stmt|;
else|else
name|PRT
argument_list|(
literal|"     index        value           "
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"size     type bind oth ver shndx       name\n"
argument_list|)
expr_stmt|;
name|get_versym
argument_list|(
name|ed
argument_list|,
name|i
argument_list|,
operator|&
name|vs
argument_list|,
operator|&
name|nvs
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs
operator|!=
name|NULL
operator|&&
name|nvs
operator|!=
name|len
condition|)
block|{
name|warnx
argument_list|(
literal|"#symbol not equal to #versym"
argument_list|)
expr_stmt|;
name|vs
operator|=
name|NULL
expr_stmt|;
block|}
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|gelf_getsym
argument_list|(
name|data
argument_list|,
name|j
argument_list|,
operator|&
name|sym
argument_list|)
operator|!=
operator|&
name|sym
condition|)
block|{
name|warnx
argument_list|(
literal|"gelf_getsym failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|name
operator|=
name|get_string
argument_list|(
name|ed
argument_list|,
name|s
operator|->
name|link
argument_list|,
name|sym
operator|.
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
block|{
name|snprintf
argument_list|(
name|idx
argument_list|,
sizeof|sizeof
argument_list|(
name|idx
argument_list|)
argument_list|,
literal|"[%d]"
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|ec
operator|==
name|ELFCLASS32
condition|)
name|PRT
argument_list|(
literal|"%10s  "
argument_list|,
name|idx
argument_list|)
expr_stmt|;
else|else
name|PRT
argument_list|(
literal|"%10s      "
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"0x%8.8jx "
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sym
operator|.
name|st_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|ec
operator|==
name|ELFCLASS32
condition|)
name|PRT
argument_list|(
literal|"0x%8.8jx  "
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sym
operator|.
name|st_size
argument_list|)
expr_stmt|;
else|else
name|PRT
argument_list|(
literal|"0x%12.12jx  "
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sym
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"%s "
argument_list|,
name|st_type_S
argument_list|(
name|GELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"%s  "
argument_list|,
name|st_bindings_S
argument_list|(
name|GELF_ST_BIND
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"%c  "
argument_list|,
name|st_others
index|[
name|sym
operator|.
name|st_other
index|]
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"%3u "
argument_list|,
operator|(
name|vs
operator|==
name|NULL
condition|?
literal|0
else|:
name|vs
index|[
name|j
index|]
operator|)
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"%-11.11s "
argument_list|,
name|sh_name
argument_list|(
name|ed
argument_list|,
name|sym
operator|.
name|st_shndx
argument_list|)
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"%s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PRT
argument_list|(
literal|"\nentry: %d\n"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tst_name: %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tst_value: %#jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sym
operator|.
name|st_value
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tst_size: %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sym
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tst_info: %s %s\n"
argument_list|,
name|st_type
argument_list|(
name|ed
operator|->
name|ehdr
operator|.
name|e_machine
argument_list|,
name|GELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
argument_list|)
argument_list|,
name|st_bindings
argument_list|(
name|GELF_ST_BIND
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tst_shndx: %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sym
operator|.
name|st_shndx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Dump the symbol tables. (.dynsym and .symtab)  */
end_comment

begin_function
specifier|static
name|void
name|elf_print_symtabs
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ed
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|ed
operator|->
name|sl
index|[
name|i
index|]
operator|.
name|type
operator|==
name|SHT_SYMTAB
operator|||
name|ed
operator|->
name|sl
index|[
name|i
index|]
operator|.
name|type
operator|==
name|SHT_DYNSYM
operator|)
operator|&&
operator|(
name|STAILQ_EMPTY
argument_list|(
operator|&
name|ed
operator|->
name|snl
argument_list|)
operator|||
name|find_name
argument_list|(
name|ed
argument_list|,
name|ed
operator|->
name|sl
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|)
condition|)
name|elf_print_symtab
argument_list|(
name|ed
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dump the content of .dynamic section.  */
end_comment

begin_function
specifier|static
name|void
name|elf_print_dynamic
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|idx
index|[
literal|10
index|]
decl_stmt|;
name|Elf_Data
modifier|*
name|data
decl_stmt|;
name|GElf_Dyn
name|dyn
decl_stmt|;
name|int
name|elferr
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|;
name|s
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|ed
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|ed
operator|->
name|sl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|SHT_DYNAMIC
operator|&&
operator|(
name|STAILQ_EMPTY
argument_list|(
operator|&
name|ed
operator|->
name|snl
argument_list|)
operator|||
name|find_name
argument_list|(
name|ed
argument_list|,
name|s
operator|->
name|name
argument_list|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|size_t
operator|)
name|i
operator|>=
name|ed
operator|->
name|shnum
condition|)
return|return;
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
block|{
name|PRT
argument_list|(
literal|"Dynamic Section:  %s\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"     index  tag               value\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|PRT
argument_list|(
literal|"\ndynamic:\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|assert
argument_list|(
name|data
operator|->
name|d_size
operator|==
name|s
operator|->
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_ent_count
argument_list|(
name|s
argument_list|,
operator|&
name|len
argument_list|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|gelf_getdyn
argument_list|(
name|data
argument_list|,
name|i
argument_list|,
operator|&
name|dyn
argument_list|)
operator|!=
operator|&
name|dyn
condition|)
block|{
name|warnx
argument_list|(
literal|"gelf_getdyn failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
block|{
name|snprintf
argument_list|(
name|idx
argument_list|,
sizeof|sizeof
argument_list|(
name|idx
argument_list|)
argument_list|,
literal|"[%d]"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"%10s  %-16s "
argument_list|,
name|idx
argument_list|,
name|d_tags
argument_list|(
name|dyn
operator|.
name|d_tag
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PRT
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"entry: %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\td_tag: %s\n"
argument_list|,
name|d_tags
argument_list|(
name|dyn
operator|.
name|d_tag
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
case|case
name|DT_NEEDED
case|:
case|case
name|DT_SONAME
case|:
case|case
name|DT_RPATH
case|:
case|case
name|DT_RUNPATH
case|:
if|if
condition|(
operator|(
name|name
operator|=
name|elf_strptr
argument_list|(
name|ed
operator|->
name|elf
argument_list|,
name|s
operator|->
name|link
argument_list|,
name|dyn
operator|.
name|d_un
operator|.
name|d_val
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|name
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
name|PRT
argument_list|(
literal|"%#-16jx %s\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|PRT
argument_list|(
literal|"\td_val: %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
case|case
name|DT_RELA
case|:
case|case
name|DT_RELASZ
case|:
case|case
name|DT_RELAENT
case|:
case|case
name|DT_RELACOUNT
case|:
case|case
name|DT_STRSZ
case|:
case|case
name|DT_SYMENT
case|:
case|case
name|DT_RELSZ
case|:
case|case
name|DT_RELENT
case|:
case|case
name|DT_PLTREL
case|:
case|case
name|DT_VERDEF
case|:
case|case
name|DT_VERDEFNUM
case|:
case|case
name|DT_VERNEED
case|:
case|case
name|DT_VERNEEDNUM
case|:
case|case
name|DT_VERSYM
case|:
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
name|PRT
argument_list|(
literal|"%#jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
else|else
name|PRT
argument_list|(
literal|"\td_val: %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_PLTGOT
case|:
case|case
name|DT_HASH
case|:
case|case
name|DT_GNU_HASH
case|:
case|case
name|DT_STRTAB
case|:
case|case
name|DT_SYMTAB
case|:
case|case
name|DT_INIT
case|:
case|case
name|DT_FINI
case|:
case|case
name|DT_REL
case|:
case|case
name|DT_JMPREL
case|:
case|case
name|DT_DEBUG
case|:
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
name|PRT
argument_list|(
literal|"%#jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
argument_list|)
expr_stmt|;
else|else
name|PRT
argument_list|(
literal|"\td_ptr: %#jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NULL
case|:
case|case
name|DT_SYMBOLIC
case|:
case|case
name|DT_TEXTREL
case|:
default|default:
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
name|PRT
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Dump a .rel/.rela section entry.  */
end_comment

begin_function
specifier|static
name|void
name|elf_print_rel_entry
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|,
name|int
name|j
parameter_list|,
name|struct
name|rel_entry
modifier|*
name|r
parameter_list|)
block|{
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
block|{
name|PRT
argument_list|(
literal|"        %-23s "
argument_list|,
name|elftc_reloc_type_str
argument_list|(
name|ed
operator|->
name|ehdr
operator|.
name|e_machine
argument_list|,
name|GELF_R_TYPE
argument_list|(
name|r
operator|->
name|u_r
operator|.
name|rel
operator|.
name|r_info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"%#12jx "
argument_list|,
operator|(
name|uintmax_t
operator|)
name|r
operator|->
name|u_r
operator|.
name|rel
operator|.
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|type
operator|==
name|SHT_RELA
condition|)
name|PRT
argument_list|(
literal|"%10jd  "
argument_list|,
operator|(
name|intmax_t
operator|)
name|r
operator|->
name|u_r
operator|.
name|rela
operator|.
name|r_addend
argument_list|)
expr_stmt|;
else|else
name|PRT
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"%-14s "
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"%s\n"
argument_list|,
name|r
operator|->
name|symn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PRT
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"entry: %d\n"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tr_offset: %#jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|r
operator|->
name|u_r
operator|.
name|rel
operator|.
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|ec
operator|==
name|ELFCLASS32
condition|)
name|PRT
argument_list|(
literal|"\tr_info: %#jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ELF32_R_INFO
argument_list|(
name|ELF64_R_SYM
argument_list|(
name|r
operator|->
name|u_r
operator|.
name|rel
operator|.
name|r_info
argument_list|)
argument_list|,
name|ELF64_R_TYPE
argument_list|(
name|r
operator|->
name|u_r
operator|.
name|rel
operator|.
name|r_info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|PRT
argument_list|(
literal|"\tr_info: %#jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|r
operator|->
name|u_r
operator|.
name|rel
operator|.
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|type
operator|==
name|SHT_RELA
condition|)
name|PRT
argument_list|(
literal|"\tr_addend: %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|r
operator|->
name|u_r
operator|.
name|rela
operator|.
name|r_addend
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Dump a relocation section of type SHT_RELA.  */
end_comment

begin_function
specifier|static
name|void
name|elf_print_rela
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|,
name|Elf_Data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|rel_entry
name|r
decl_stmt|;
name|int
name|j
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
block|{
name|PRT
argument_list|(
literal|"\nRelocation Section:  %s\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"        type                          offset     "
literal|"addend  section        with respect to\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|PRT
argument_list|(
literal|"\nrelocation with addend (%s):\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|r
operator|.
name|type
operator|=
name|SHT_RELA
expr_stmt|;
name|assert
argument_list|(
name|data
operator|->
name|d_size
operator|==
name|s
operator|->
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_ent_count
argument_list|(
name|s
argument_list|,
operator|&
name|len
argument_list|)
condition|)
return|return;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|gelf_getrela
argument_list|(
name|data
argument_list|,
name|j
argument_list|,
operator|&
name|r
operator|.
name|u_r
operator|.
name|rela
argument_list|)
operator|!=
operator|&
name|r
operator|.
name|u_r
operator|.
name|rela
condition|)
block|{
name|warnx
argument_list|(
literal|"gelf_getrela failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|r
operator|.
name|symn
operator|=
name|get_symbol_name
argument_list|(
name|ed
argument_list|,
name|s
operator|->
name|link
argument_list|,
name|GELF_R_SYM
argument_list|(
name|r
operator|.
name|u_r
operator|.
name|rela
operator|.
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
name|elf_print_rel_entry
argument_list|(
name|ed
argument_list|,
name|s
argument_list|,
name|j
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Dump a relocation section of type SHT_REL.  */
end_comment

begin_function
specifier|static
name|void
name|elf_print_rel
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|,
name|Elf_Data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|rel_entry
name|r
decl_stmt|;
name|int
name|j
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
block|{
name|PRT
argument_list|(
literal|"\nRelocation Section:  %s\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"        type                          offset     "
literal|"section        with respect to\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|PRT
argument_list|(
literal|"\nrelocation (%s):\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|r
operator|.
name|type
operator|=
name|SHT_REL
expr_stmt|;
name|assert
argument_list|(
name|data
operator|->
name|d_size
operator|==
name|s
operator|->
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_ent_count
argument_list|(
name|s
argument_list|,
operator|&
name|len
argument_list|)
condition|)
return|return;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|gelf_getrel
argument_list|(
name|data
argument_list|,
name|j
argument_list|,
operator|&
name|r
operator|.
name|u_r
operator|.
name|rel
argument_list|)
operator|!=
operator|&
name|r
operator|.
name|u_r
operator|.
name|rel
condition|)
block|{
name|warnx
argument_list|(
literal|"gelf_getrel failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|r
operator|.
name|symn
operator|=
name|get_symbol_name
argument_list|(
name|ed
argument_list|,
name|s
operator|->
name|link
argument_list|,
name|GELF_R_SYM
argument_list|(
name|r
operator|.
name|u_r
operator|.
name|rel
operator|.
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
name|elf_print_rel_entry
argument_list|(
name|ed
argument_list|,
name|s
argument_list|,
name|j
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Dump relocation sections.  */
end_comment

begin_function
specifier|static
name|void
name|elf_print_reloc
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|Elf_Data
modifier|*
name|data
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
name|elferr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ed
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|ed
operator|->
name|sl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|type
operator|==
name|SHT_REL
operator|||
name|s
operator|->
name|type
operator|==
name|SHT_RELA
operator|)
operator|&&
operator|(
name|STAILQ_EMPTY
argument_list|(
operator|&
name|ed
operator|->
name|snl
argument_list|)
operator|||
name|find_name
argument_list|(
name|ed
argument_list|,
name|s
operator|->
name|name
argument_list|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|SHT_REL
condition|)
name|elf_print_rel
argument_list|(
name|ed
argument_list|,
name|s
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
name|elf_print_rela
argument_list|(
name|ed
argument_list|,
name|s
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Dump the content of PT_INTERP segment.  */
end_comment

begin_function
specifier|static
name|void
name|elf_print_interp
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|GElf_Phdr
name|phdr
decl_stmt|;
name|size_t
name|filesize
decl_stmt|,
name|i
decl_stmt|,
name|phnum
decl_stmt|;
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|ed
operator|->
name|snl
argument_list|)
operator|&&
name|find_name
argument_list|(
name|ed
argument_list|,
literal|"PT_INTERP"
argument_list|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|s
operator|=
name|elf_rawfile
argument_list|(
name|ed
operator|->
name|elf
argument_list|,
operator|&
name|filesize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_rawfile failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|elf_getphnum
argument_list|(
name|ed
operator|->
name|elf
argument_list|,
operator|&
name|phnum
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_getphnum failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|phnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|gelf_getphdr
argument_list|(
name|ed
operator|->
name|elf
argument_list|,
name|i
argument_list|,
operator|&
name|phdr
argument_list|)
operator|!=
operator|&
name|phdr
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_getphdr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|phdr
operator|.
name|p_type
operator|==
name|PT_INTERP
condition|)
block|{
if|if
condition|(
name|phdr
operator|.
name|p_offset
operator|>=
name|filesize
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid phdr offset"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|PRT
argument_list|(
literal|"\ninterp:\n"
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\t%s\n"
argument_list|,
name|s
operator|+
name|phdr
operator|.
name|p_offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Search the relocation sections for entries referring to the .got section.  */
end_comment

begin_function
specifier|static
name|void
name|find_gotrel
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|struct
name|section
modifier|*
name|gs
parameter_list|,
name|struct
name|rel_entry
modifier|*
name|got
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|struct
name|rel_entry
name|r
decl_stmt|;
name|Elf_Data
modifier|*
name|data
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
name|elferr
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|len
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ed
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|ed
operator|->
name|sl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|!=
name|SHT_REL
operator|&&
name|s
operator|->
name|type
operator|!=
name|SHT_RELA
condition|)
continue|continue;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
operator|&
name|r
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rel_entry
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|.
name|type
operator|=
name|s
operator|->
name|type
expr_stmt|;
name|assert
argument_list|(
name|data
operator|->
name|d_size
operator|==
name|s
operator|->
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_ent_count
argument_list|(
name|s
argument_list|,
operator|&
name|len
argument_list|)
condition|)
return|return;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|SHT_REL
condition|)
block|{
if|if
condition|(
name|gelf_getrel
argument_list|(
name|data
argument_list|,
name|j
argument_list|,
operator|&
name|r
operator|.
name|u_r
operator|.
name|rel
argument_list|)
operator|!=
operator|&
name|r
operator|.
name|u_r
operator|.
name|rel
condition|)
block|{
name|warnx
argument_list|(
literal|"gelf_getrel failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
if|if
condition|(
name|gelf_getrela
argument_list|(
name|data
argument_list|,
name|j
argument_list|,
operator|&
name|r
operator|.
name|u_r
operator|.
name|rela
argument_list|)
operator|!=
operator|&
name|r
operator|.
name|u_r
operator|.
name|rela
condition|)
block|{
name|warnx
argument_list|(
literal|"gelf_getrel failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|r
operator|.
name|u_r
operator|.
name|rel
operator|.
name|r_offset
operator|>=
name|gs
operator|->
name|addr
operator|&&
name|r
operator|.
name|u_r
operator|.
name|rel
operator|.
name|r_offset
operator|<
name|gs
operator|->
name|addr
operator|+
name|gs
operator|->
name|sz
condition|)
block|{
name|r
operator|.
name|symn
operator|=
name|get_symbol_name
argument_list|(
name|ed
argument_list|,
name|s
operator|->
name|link
argument_list|,
name|GELF_R_SYM
argument_list|(
name|r
operator|.
name|u_r
operator|.
name|rel
operator|.
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
name|k
operator|=
operator|(
name|r
operator|.
name|u_r
operator|.
name|rel
operator|.
name|r_offset
operator|-
name|gs
operator|->
name|addr
operator|)
operator|/
name|gs
operator|->
name|entsize
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|got
index|[
name|k
index|]
argument_list|,
operator|&
name|r
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rel_entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|elf_print_got_section
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|rel_entry
modifier|*
name|got
decl_stmt|;
name|Elf_Data
modifier|*
name|data
decl_stmt|,
name|dst
decl_stmt|;
name|int
name|elferr
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|entsize
operator|==
literal|0
condition|)
block|{
comment|/* XXX IA64 GOT section generated by gcc has entry size 0. */
if|if
condition|(
name|s
operator|->
name|align
operator|!=
literal|0
condition|)
name|s
operator|->
name|entsize
operator|=
name|s
operator|->
name|align
expr_stmt|;
else|else
return|return;
block|}
if|if
condition|(
operator|!
name|get_ent_count
argument_list|(
name|s
argument_list|,
operator|&
name|len
argument_list|)
condition|)
return|return;
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
name|PRT
argument_list|(
literal|"\nGlobal Offset Table Section:  %s  (%d entries)\n"
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|PRT
argument_list|(
literal|"\nglobal offset table: %s\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * GOT section has section type SHT_PROGBITS, thus libelf treats it as 	 * byte stream and will not perform any translation on it. As a result, 	 * an exlicit call to gelf_xlatetom is needed here. Depends on arch, 	 * GOT section should be translated to either WORD or XWORD. 	 */
if|if
condition|(
name|ed
operator|->
name|ec
operator|==
name|ELFCLASS32
condition|)
name|data
operator|->
name|d_type
operator|=
name|ELF_T_WORD
expr_stmt|;
else|else
name|data
operator|->
name|d_type
operator|=
name|ELF_T_XWORD
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|dst
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gelf_xlatetom
argument_list|(
name|ed
operator|->
name|elf
argument_list|,
operator|&
name|dst
argument_list|,
name|data
argument_list|,
name|ed
operator|->
name|ehdr
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
argument_list|)
operator|!=
operator|&
name|dst
condition|)
block|{
name|warnx
argument_list|(
literal|"gelf_xlatetom failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|assert
argument_list|(
name|dst
operator|.
name|d_size
operator|==
name|s
operator|->
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
block|{
comment|/* 		 * In verbose/Solaris mode, we search the relocation sections 		 * and try to find the corresponding reloc entry for each GOT 		 * section entry. 		 */
if|if
condition|(
operator|(
name|got
operator|=
name|calloc
argument_list|(
name|len
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rel_entry
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
name|find_gotrel
argument_list|(
name|ed
argument_list|,
name|s
argument_list|,
name|got
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|ec
operator|==
name|ELFCLASS32
condition|)
block|{
name|PRT
argument_list|(
literal|" ndx     addr      value    reloc              "
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"addend   symbol\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PRT
argument_list|(
literal|" ndx     addr              value             "
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"reloc              addend       symbol\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|PRT
argument_list|(
literal|"[%5.5d]  "
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|ec
operator|==
name|ELFCLASS32
condition|)
block|{
name|PRT
argument_list|(
literal|"%-8.8jx  "
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
name|s
operator|->
name|addr
operator|+
name|i
operator|*
name|s
operator|->
name|entsize
argument_list|)
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"%-8.8x "
argument_list|,
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|dst
operator|.
name|d_buf
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PRT
argument_list|(
literal|"%-16.16jx  "
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
name|s
operator|->
name|addr
operator|+
name|i
operator|*
name|s
operator|->
name|entsize
argument_list|)
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"%-16.16jx  "
argument_list|,
operator|(
name|uintmax_t
operator|)
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|dst
operator|.
name|d_buf
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
name|PRT
argument_list|(
literal|"%-18s "
argument_list|,
name|elftc_reloc_type_str
argument_list|(
name|ed
operator|->
name|ehdr
operator|.
name|e_machine
argument_list|,
name|GELF_R_TYPE
argument_list|(
name|got
index|[
name|i
index|]
operator|.
name|u_r
operator|.
name|rel
operator|.
name|r_info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|ec
operator|==
name|ELFCLASS32
condition|)
name|PRT
argument_list|(
literal|"%-8.8jd "
argument_list|,
operator|(
name|intmax_t
operator|)
name|got
index|[
name|i
index|]
operator|.
name|u_r
operator|.
name|rela
operator|.
name|r_addend
argument_list|)
expr_stmt|;
else|else
name|PRT
argument_list|(
literal|"%-12.12jd "
argument_list|,
operator|(
name|intmax_t
operator|)
name|got
index|[
name|i
index|]
operator|.
name|u_r
operator|.
name|rela
operator|.
name|r_addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|got
index|[
name|i
index|]
operator|.
name|symn
operator|==
name|NULL
condition|)
name|got
index|[
name|i
index|]
operator|.
name|symn
operator|=
literal|""
expr_stmt|;
name|PRT
argument_list|(
literal|"%s\n"
argument_list|,
name|got
index|[
name|i
index|]
operator|.
name|symn
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|got
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|PRT
argument_list|(
literal|"\nentry: %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|ec
operator|==
name|ELFCLASS32
condition|)
name|PRT
argument_list|(
literal|"\t%#x\n"
argument_list|,
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|dst
operator|.
name|d_buf
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
else|else
name|PRT
argument_list|(
literal|"\t%#jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|dst
operator|.
name|d_buf
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Dump the content of Global Offset Table section.  */
end_comment

begin_function
specifier|static
name|void
name|elf_print_got
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|size_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|ed
operator|->
name|snl
argument_list|)
condition|)
return|return;
name|s
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ed
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|ed
operator|->
name|sl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|name
operator|&&
operator|!
name|strncmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|".got"
argument_list|,
literal|4
argument_list|)
operator|&&
operator|(
name|STAILQ_EMPTY
argument_list|(
operator|&
name|ed
operator|->
name|snl
argument_list|)
operator|||
name|find_name
argument_list|(
name|ed
argument_list|,
name|s
operator|->
name|name
argument_list|)
operator|)
condition|)
name|elf_print_got_section
argument_list|(
name|ed
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Dump the content of .note.ABI-tag section.  */
end_comment

begin_function
specifier|static
name|void
name|elf_print_note
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|Elf_Data
modifier|*
name|data
decl_stmt|;
name|Elf_Note
modifier|*
name|en
decl_stmt|;
name|uint32_t
name|namesz
decl_stmt|;
name|uint32_t
name|descsz
decl_stmt|;
name|uint32_t
name|desc
decl_stmt|;
name|size_t
name|count
decl_stmt|;
name|int
name|elferr
decl_stmt|,
name|i
decl_stmt|;
name|uint8_t
modifier|*
name|src
decl_stmt|;
name|char
name|idx
index|[
literal|10
index|]
decl_stmt|;
name|s
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|ed
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|ed
operator|->
name|sl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|SHT_NOTE
operator|&&
name|s
operator|->
name|name
operator|&&
operator|!
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|".note.ABI-tag"
argument_list|)
operator|&&
operator|(
name|STAILQ_EMPTY
argument_list|(
operator|&
name|ed
operator|->
name|snl
argument_list|)
operator|||
name|find_name
argument_list|(
name|ed
argument_list|,
name|s
operator|->
name|name
argument_list|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|size_t
operator|)
name|i
operator|>=
name|ed
operator|->
name|shnum
condition|)
return|return;
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
name|PRT
argument_list|(
literal|"\nNote Section:  %s\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|PRT
argument_list|(
literal|"\nnote (%s):\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|src
operator|=
name|data
operator|->
name|d_buf
expr_stmt|;
name|count
operator|=
name|data
operator|->
name|d_size
expr_stmt|;
while|while
condition|(
name|count
operator|>
sizeof|sizeof
argument_list|(
name|Elf_Note
argument_list|)
condition|)
block|{
name|en
operator|=
operator|(
name|Elf_Note
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|src
expr_stmt|;
name|namesz
operator|=
name|en
operator|->
name|n_namesz
expr_stmt|;
name|descsz
operator|=
name|en
operator|->
name|n_descsz
expr_stmt|;
name|src
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_Note
argument_list|)
expr_stmt|;
name|count
operator|-=
sizeof|sizeof
argument_list|(
name|Elf_Note
argument_list|)
expr_stmt|;
if|if
condition|(
name|roundup2
argument_list|(
name|namesz
argument_list|,
literal|4
argument_list|)
operator|+
name|roundup2
argument_list|(
name|descsz
argument_list|,
literal|4
argument_list|)
operator|>
name|count
condition|)
block|{
name|warnx
argument_list|(
literal|"truncated note section"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
block|{
name|PRT
argument_list|(
literal|"\n    type   %#x\n"
argument_list|,
name|en
operator|->
name|n_type
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"    namesz %#x:\n"
argument_list|,
name|en
operator|->
name|n_namesz
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"%s\n"
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
else|else
name|PRT
argument_list|(
literal|"\t%s "
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|src
operator|+=
name|roundup2
argument_list|(
name|namesz
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|count
operator|-=
name|roundup2
argument_list|(
name|namesz
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* 		 * Note that we dump the whole desc part if we're in 		 * "Solaris mode", while in the normal mode, we only look 		 * at the first 4 bytes (a 32bit word) of the desc, i.e, 		 * we assume that it's always a FreeBSD version number. 		 */
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
block|{
name|PRT
argument_list|(
literal|"    descsz %#x:"
argument_list|,
name|en
operator|->
name|n_descsz
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|uint32_t
operator|)
name|i
operator|<
name|descsz
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|&
literal|0xF
operator|)
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|idx
argument_list|,
sizeof|sizeof
argument_list|(
name|idx
argument_list|)
argument_list|,
literal|"desc[%d]"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\n      %-9s"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|&
literal|0x3
operator|)
operator|==
literal|0
condition|)
name|PRT
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|" %2.2x"
argument_list|,
name|src
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|PRT
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ed
operator|->
name|ehdr
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
operator|==
name|ELFDATA2MSB
condition|)
name|desc
operator|=
name|be32dec
argument_list|(
name|src
argument_list|)
expr_stmt|;
else|else
name|desc
operator|=
name|le32dec
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"%d\n"
argument_list|,
name|desc
argument_list|)
expr_stmt|;
block|}
name|src
operator|+=
name|roundup2
argument_list|(
name|descsz
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|count
operator|-=
name|roundup2
argument_list|(
name|descsz
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Dump a hash table.  */
end_comment

begin_function
specifier|static
name|void
name|elf_print_svr4_hash
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
block|{
name|Elf_Data
modifier|*
name|data
decl_stmt|;
name|uint32_t
modifier|*
name|buf
decl_stmt|;
name|uint32_t
modifier|*
name|bucket
decl_stmt|,
modifier|*
name|chain
decl_stmt|;
name|uint32_t
name|nbucket
decl_stmt|,
name|nchain
decl_stmt|;
name|uint32_t
modifier|*
name|bl
decl_stmt|,
modifier|*
name|c
decl_stmt|,
name|maxl
decl_stmt|,
name|total
decl_stmt|;
name|uint32_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|first
decl_stmt|,
name|elferr
decl_stmt|;
name|char
name|idx
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
name|PRT
argument_list|(
literal|"\nHash Section:  %s\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|PRT
argument_list|(
literal|"\nhash table (%s):\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|data
operator|->
name|d_size
operator|<
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|".hash section too small"
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf
operator|=
name|data
operator|->
name|d_buf
expr_stmt|;
name|nbucket
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|nchain
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|nbucket
operator|<=
literal|0
operator|||
name|nchain
operator|<=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Malformed .hash section"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|data
operator|->
name|d_size
operator|!=
operator|(
operator|(
name|uint64_t
operator|)
name|nbucket
operator|+
operator|(
name|uint64_t
operator|)
name|nchain
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Malformed .hash section"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bucket
operator|=
operator|&
name|buf
index|[
literal|2
index|]
expr_stmt|;
name|chain
operator|=
operator|&
name|buf
index|[
literal|2
operator|+
name|nbucket
index|]
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
block|{
name|maxl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|bl
operator|=
name|calloc
argument_list|(
name|nbucket
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bl
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbucket
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
name|bucket
index|[
name|i
index|]
init|;
name|j
operator|>
literal|0
operator|&&
name|j
operator|<
name|nchain
condition|;
name|j
operator|=
name|chain
index|[
name|j
index|]
control|)
if|if
condition|(
operator|++
name|bl
index|[
name|i
index|]
operator|>
name|maxl
condition|)
name|maxl
operator|=
name|bl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|calloc
argument_list|(
name|maxl
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbucket
condition|;
name|i
operator|++
control|)
name|c
index|[
name|bl
index|[
name|i
index|]
index|]
operator|++
expr_stmt|;
name|PRT
argument_list|(
literal|"    bucket    symndx    name\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbucket
condition|;
name|i
operator|++
control|)
block|{
name|first
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
name|bucket
index|[
name|i
index|]
init|;
name|j
operator|>
literal|0
operator|&&
name|j
operator|<
name|nchain
condition|;
name|j
operator|=
name|chain
index|[
name|j
index|]
control|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|PRT
argument_list|(
literal|"%10d  "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|PRT
argument_list|(
literal|"            "
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|idx
argument_list|,
sizeof|sizeof
argument_list|(
name|idx
argument_list|)
argument_list|,
literal|"[%d]"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"%-10s  "
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"%s\n"
argument_list|,
name|get_symbol_name
argument_list|(
name|ed
argument_list|,
name|s
operator|->
name|link
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|PRT
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|maxl
condition|;
name|i
operator|++
control|)
block|{
name|total
operator|+=
name|c
index|[
name|i
index|]
operator|*
name|i
expr_stmt|;
name|PRT
argument_list|(
literal|"%10u  buckets contain %8d symbols\n"
argument_list|,
name|c
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|PRT
argument_list|(
literal|"%10u  buckets         %8u symbols (globals)\n"
argument_list|,
name|nbucket
argument_list|,
name|total
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PRT
argument_list|(
literal|"\nnbucket: %u\n"
argument_list|,
name|nbucket
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"nchain: %u\n\n"
argument_list|,
name|nchain
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbucket
condition|;
name|i
operator|++
control|)
name|PRT
argument_list|(
literal|"bucket[%d]:\n\t%u\n\n"
argument_list|,
name|i
argument_list|,
name|bucket
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchain
condition|;
name|i
operator|++
control|)
name|PRT
argument_list|(
literal|"chain[%d]:\n\t%u\n\n"
argument_list|,
name|i
argument_list|,
name|chain
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Dump a 64bit hash table.  */
end_comment

begin_function
specifier|static
name|void
name|elf_print_svr4_hash64
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
block|{
name|Elf_Data
modifier|*
name|data
decl_stmt|,
name|dst
decl_stmt|;
name|uint64_t
modifier|*
name|buf
decl_stmt|;
name|uint64_t
modifier|*
name|bucket
decl_stmt|,
modifier|*
name|chain
decl_stmt|;
name|uint64_t
name|nbucket
decl_stmt|,
name|nchain
decl_stmt|;
name|uint64_t
modifier|*
name|bl
decl_stmt|,
modifier|*
name|c
decl_stmt|,
name|maxl
decl_stmt|,
name|total
decl_stmt|;
name|uint64_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|elferr
decl_stmt|,
name|first
decl_stmt|;
name|char
name|idx
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
name|PRT
argument_list|(
literal|"\nHash Section:  %s\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|PRT
argument_list|(
literal|"\nhash table (%s):\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * ALPHA uses 64-bit hash entries. Since libelf assumes that 	 * .hash section contains only 32-bit entry, an explicit 	 * gelf_xlatetom is needed here. 	 */
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|=
name|elf_rawdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_rawdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|data
operator|->
name|d_type
operator|=
name|ELF_T_XWORD
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|dst
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gelf_xlatetom
argument_list|(
name|ed
operator|->
name|elf
argument_list|,
operator|&
name|dst
argument_list|,
name|data
argument_list|,
name|ed
operator|->
name|ehdr
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
argument_list|)
operator|!=
operator|&
name|dst
condition|)
block|{
name|warnx
argument_list|(
literal|"gelf_xlatetom failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dst
operator|.
name|d_size
operator|<
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|".hash section too small"
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf
operator|=
name|dst
operator|.
name|d_buf
expr_stmt|;
name|nbucket
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|nchain
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|nbucket
operator|<=
literal|0
operator|||
name|nchain
operator|<=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Malformed .hash section"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dst
operator|.
name|d_size
operator|!=
operator|(
name|nbucket
operator|+
name|nchain
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Malformed .hash section"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bucket
operator|=
operator|&
name|buf
index|[
literal|2
index|]
expr_stmt|;
name|chain
operator|=
operator|&
name|buf
index|[
literal|2
operator|+
name|nbucket
index|]
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
block|{
name|maxl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|bl
operator|=
name|calloc
argument_list|(
name|nbucket
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bl
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbucket
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
name|bucket
index|[
name|i
index|]
init|;
name|j
operator|>
literal|0
operator|&&
name|j
operator|<
name|nchain
condition|;
name|j
operator|=
name|chain
index|[
name|j
index|]
control|)
if|if
condition|(
operator|++
name|bl
index|[
name|i
index|]
operator|>
name|maxl
condition|)
name|maxl
operator|=
name|bl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|calloc
argument_list|(
name|maxl
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbucket
condition|;
name|i
operator|++
control|)
name|c
index|[
name|bl
index|[
name|i
index|]
index|]
operator|++
expr_stmt|;
name|PRT
argument_list|(
literal|"    bucket    symndx    name\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbucket
condition|;
name|i
operator|++
control|)
block|{
name|first
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
name|bucket
index|[
name|i
index|]
init|;
name|j
operator|>
literal|0
operator|&&
name|j
operator|<
name|nchain
condition|;
name|j
operator|=
name|chain
index|[
name|j
index|]
control|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|PRT
argument_list|(
literal|"%10zu  "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|PRT
argument_list|(
literal|"            "
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|idx
argument_list|,
sizeof|sizeof
argument_list|(
name|idx
argument_list|)
argument_list|,
literal|"[%zu]"
argument_list|,
operator|(
name|size_t
operator|)
name|j
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"%-10s  "
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"%s\n"
argument_list|,
name|get_symbol_name
argument_list|(
name|ed
argument_list|,
name|s
operator|->
name|link
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|PRT
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|maxl
condition|;
name|i
operator|++
control|)
block|{
name|total
operator|+=
name|c
index|[
name|i
index|]
operator|*
name|i
expr_stmt|;
name|PRT
argument_list|(
literal|"%10ju  buckets contain %8zu symbols\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|c
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|PRT
argument_list|(
literal|"%10ju  buckets         %8ju symbols (globals)\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|nbucket
argument_list|,
operator|(
name|uintmax_t
operator|)
name|total
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PRT
argument_list|(
literal|"\nnbucket: %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|nbucket
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"nchain: %ju\n\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|nchain
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbucket
condition|;
name|i
operator|++
control|)
name|PRT
argument_list|(
literal|"bucket[%zu]:\n\t%ju\n\n"
argument_list|,
name|i
argument_list|,
operator|(
name|uintmax_t
operator|)
name|bucket
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchain
condition|;
name|i
operator|++
control|)
name|PRT
argument_list|(
literal|"chain[%zu]:\n\t%ju\n\n"
argument_list|,
name|i
argument_list|,
operator|(
name|uintmax_t
operator|)
name|chain
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Dump a GNU hash table.  */
end_comment

begin_function
specifier|static
name|void
name|elf_print_gnu_hash
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|ds
decl_stmt|;
name|Elf_Data
modifier|*
name|data
decl_stmt|;
name|uint32_t
modifier|*
name|buf
decl_stmt|;
name|uint32_t
modifier|*
name|bucket
decl_stmt|,
modifier|*
name|chain
decl_stmt|;
name|uint32_t
name|nbucket
decl_stmt|,
name|nchain
decl_stmt|,
name|symndx
decl_stmt|,
name|maskwords
decl_stmt|,
name|shift2
decl_stmt|;
name|uint32_t
modifier|*
name|bl
decl_stmt|,
modifier|*
name|c
decl_stmt|,
name|maxl
decl_stmt|,
name|total
decl_stmt|;
name|uint32_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|first
decl_stmt|,
name|elferr
decl_stmt|,
name|dynsymcount
decl_stmt|;
name|char
name|idx
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
name|PRT
argument_list|(
literal|"\nGNU Hash Section:  %s\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|PRT
argument_list|(
literal|"\ngnu hash table (%s):\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|data
operator|->
name|d_size
operator|<
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|".gnu.hash section too small"
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf
operator|=
name|data
operator|->
name|d_buf
expr_stmt|;
name|nbucket
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|symndx
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|maskwords
operator|=
name|buf
index|[
literal|2
index|]
expr_stmt|;
name|shift2
operator|=
name|buf
index|[
literal|3
index|]
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|link
operator|>=
name|ed
operator|->
name|shnum
condition|)
block|{
name|warnx
argument_list|(
literal|"Malformed .gnu.hash section"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ds
operator|=
operator|&
name|ed
operator|->
name|sl
index|[
name|s
operator|->
name|link
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|get_ent_count
argument_list|(
name|ds
argument_list|,
operator|&
name|dynsymcount
argument_list|)
condition|)
return|return;
if|if
condition|(
name|symndx
operator|>=
operator|(
name|uint32_t
operator|)
name|dynsymcount
condition|)
block|{
name|warnx
argument_list|(
literal|"Malformed .gnu.hash section"
argument_list|)
expr_stmt|;
return|return;
block|}
name|nchain
operator|=
name|dynsymcount
operator|-
name|symndx
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|d_size
operator|!=
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
name|maskwords
operator|*
operator|(
name|ed
operator|->
name|ec
operator|==
name|ELFCLASS32
condition|?
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
else|:
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|)
operator|+
operator|(
operator|(
name|uint64_t
operator|)
name|nbucket
operator|+
operator|(
name|uint64_t
operator|)
name|nchain
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Malformed .gnu.hash section"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bucket
operator|=
name|buf
operator|+
operator|(
name|ed
operator|->
name|ec
operator|==
name|ELFCLASS32
condition|?
name|maskwords
else|:
name|maskwords
operator|*
literal|2
operator|)
expr_stmt|;
name|chain
operator|=
name|bucket
operator|+
name|nbucket
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
block|{
name|maxl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|bl
operator|=
name|calloc
argument_list|(
name|nbucket
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bl
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbucket
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
name|bucket
index|[
name|i
index|]
init|;
name|j
operator|>
literal|0
operator|&&
name|j
operator|-
name|symndx
operator|<
name|nchain
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|++
name|bl
index|[
name|i
index|]
operator|>
name|maxl
condition|)
name|maxl
operator|=
name|bl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|chain
index|[
name|j
operator|-
name|symndx
index|]
operator|&
literal|1
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|c
operator|=
name|calloc
argument_list|(
name|maxl
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbucket
condition|;
name|i
operator|++
control|)
name|c
index|[
name|bl
index|[
name|i
index|]
index|]
operator|++
expr_stmt|;
name|PRT
argument_list|(
literal|"    bucket    symndx    name\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbucket
condition|;
name|i
operator|++
control|)
block|{
name|first
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
name|bucket
index|[
name|i
index|]
init|;
name|j
operator|>
literal|0
operator|&&
name|j
operator|-
name|symndx
operator|<
name|nchain
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|PRT
argument_list|(
literal|"%10d  "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|PRT
argument_list|(
literal|"            "
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|idx
argument_list|,
sizeof|sizeof
argument_list|(
name|idx
argument_list|)
argument_list|,
literal|"[%d]"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"%-10s  "
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"%s\n"
argument_list|,
name|get_symbol_name
argument_list|(
name|ed
argument_list|,
name|s
operator|->
name|link
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
index|[
name|j
operator|-
name|symndx
index|]
operator|&
literal|1
condition|)
break|break;
block|}
block|}
name|PRT
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|maxl
condition|;
name|i
operator|++
control|)
block|{
name|total
operator|+=
name|c
index|[
name|i
index|]
operator|*
name|i
expr_stmt|;
name|PRT
argument_list|(
literal|"%10u  buckets contain %8d symbols\n"
argument_list|,
name|c
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|PRT
argument_list|(
literal|"%10u  buckets         %8u symbols (globals)\n"
argument_list|,
name|nbucket
argument_list|,
name|total
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PRT
argument_list|(
literal|"\nnbucket: %u\n"
argument_list|,
name|nbucket
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"symndx: %u\n"
argument_list|,
name|symndx
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"maskwords: %u\n"
argument_list|,
name|maskwords
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"shift2: %u\n"
argument_list|,
name|shift2
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"nchain: %u\n\n"
argument_list|,
name|nchain
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbucket
condition|;
name|i
operator|++
control|)
name|PRT
argument_list|(
literal|"bucket[%d]:\n\t%u\n\n"
argument_list|,
name|i
argument_list|,
name|bucket
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchain
condition|;
name|i
operator|++
control|)
name|PRT
argument_list|(
literal|"chain[%d]:\n\t%u\n\n"
argument_list|,
name|i
argument_list|,
name|chain
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Dump hash tables.  */
end_comment

begin_function
specifier|static
name|void
name|elf_print_hash
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ed
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|ed
operator|->
name|sl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|type
operator|==
name|SHT_HASH
operator|||
name|s
operator|->
name|type
operator|==
name|SHT_GNU_HASH
operator|)
operator|&&
operator|(
name|STAILQ_EMPTY
argument_list|(
operator|&
name|ed
operator|->
name|snl
argument_list|)
operator|||
name|find_name
argument_list|(
name|ed
argument_list|,
name|s
operator|->
name|name
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|SHT_GNU_HASH
condition|)
name|elf_print_gnu_hash
argument_list|(
name|ed
argument_list|,
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ed
operator|->
name|ehdr
operator|.
name|e_machine
operator|==
name|EM_ALPHA
operator|&&
name|s
operator|->
name|entsize
operator|==
literal|8
condition|)
name|elf_print_svr4_hash64
argument_list|(
name|ed
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|elf_print_svr4_hash
argument_list|(
name|ed
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Dump the content of a Version Definition(SHT_SUNW_Verdef) Section.  */
end_comment

begin_function
specifier|static
name|void
name|elf_print_verdef
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
block|{
name|Elf_Data
modifier|*
name|data
decl_stmt|;
name|Elf32_Verdef
modifier|*
name|vd
decl_stmt|;
name|Elf32_Verdaux
modifier|*
name|vda
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|char
name|idx
index|[
literal|10
index|]
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|buf2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|elferr
decl_stmt|,
name|count
decl_stmt|;
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
name|PRT
argument_list|(
literal|"Version Definition Section:  %s\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|PRT
argument_list|(
literal|"\nversion definition section (%s):\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf
operator|=
name|data
operator|->
name|d_buf
expr_stmt|;
name|end
operator|=
name|buf
operator|+
name|data
operator|->
name|d_size
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
name|PRT
argument_list|(
literal|"     index  version                     dependency\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|Elf32_Verdef
argument_list|)
operator|<=
name|end
condition|)
block|{
name|vd
operator|=
operator|(
name|Elf32_Verdef
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|buf
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
block|{
name|snprintf
argument_list|(
name|idx
argument_list|,
sizeof|sizeof
argument_list|(
name|idx
argument_list|)
argument_list|,
literal|"[%d]"
argument_list|,
name|vd
operator|->
name|vd_ndx
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"%10s  "
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PRT
argument_list|(
literal|"\nentry: %d\n"
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tvd_version: %u\n"
argument_list|,
name|vd
operator|->
name|vd_version
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tvd_flags: %u\n"
argument_list|,
name|vd
operator|->
name|vd_flags
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tvd_ndx: %u\n"
argument_list|,
name|vd
operator|->
name|vd_ndx
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tvd_cnt: %u\n"
argument_list|,
name|vd
operator|->
name|vd_cnt
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tvd_hash: %u\n"
argument_list|,
name|vd
operator|->
name|vd_hash
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tvd_aux: %u\n"
argument_list|,
name|vd
operator|->
name|vd_aux
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tvd_next: %u\n\n"
argument_list|,
name|vd
operator|->
name|vd_next
argument_list|)
expr_stmt|;
block|}
name|buf2
operator|=
name|buf
operator|+
name|vd
operator|->
name|vd_aux
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|buf2
operator|+
sizeof|sizeof
argument_list|(
name|Elf32_Verdaux
argument_list|)
operator|<=
name|end
operator|&&
name|j
operator|<
name|vd
operator|->
name|vd_cnt
condition|)
block|{
name|vda
operator|=
operator|(
name|Elf32_Verdaux
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|buf2
expr_stmt|;
name|str
operator|=
name|get_string
argument_list|(
name|ed
argument_list|,
name|s
operator|->
name|link
argument_list|,
name|vda
operator|->
name|vda_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|PRT
argument_list|(
literal|"%-26.26s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|count
operator|==
literal|1
condition|)
name|PRT
argument_list|(
literal|"  %-20.20s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
else|else
block|{
name|PRT
argument_list|(
literal|"\n%40.40s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|PRT
argument_list|(
literal|"\t\tvda: %d\n"
argument_list|,
name|j
operator|++
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\t\t\tvda_name: %s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\t\t\tvda_next: %u\n"
argument_list|,
name|vda
operator|->
name|vda_next
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vda
operator|->
name|vda_next
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
block|{
if|if
condition|(
name|vd
operator|->
name|vd_flags
operator|&
name|VER_FLG_BASE
condition|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|PRT
argument_list|(
literal|"%-20.20s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"%s"
argument_list|,
literal|"[ BASE ]"
argument_list|)
expr_stmt|;
block|}
name|PRT
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
name|count
operator|++
expr_stmt|;
name|buf2
operator|+=
name|vda
operator|->
name|vda_next
expr_stmt|;
block|}
if|if
condition|(
name|vd
operator|->
name|vd_next
operator|==
literal|0
condition|)
break|break;
name|buf
operator|+=
name|vd
operator|->
name|vd_next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Dump the content of a Version Needed(SHT_SUNW_Verneed) Section.  */
end_comment

begin_function
specifier|static
name|void
name|elf_print_verneed
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
block|{
name|Elf_Data
modifier|*
name|data
decl_stmt|;
name|Elf32_Verneed
modifier|*
name|vn
decl_stmt|;
name|Elf32_Vernaux
modifier|*
name|vna
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|buf2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|elferr
decl_stmt|,
name|first
decl_stmt|;
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
name|PRT
argument_list|(
literal|"\nVersion Needed Section:  %s\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|PRT
argument_list|(
literal|"\nversion need section (%s):\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf
operator|=
name|data
operator|->
name|d_buf
expr_stmt|;
name|end
operator|=
name|buf
operator|+
name|data
operator|->
name|d_size
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
name|PRT
argument_list|(
literal|"            file                        version\n"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|Elf32_Verneed
argument_list|)
operator|<=
name|end
condition|)
block|{
name|vn
operator|=
operator|(
name|Elf32_Verneed
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|buf
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
name|PRT
argument_list|(
literal|"            %-26.26s  "
argument_list|,
name|get_string
argument_list|(
name|ed
argument_list|,
name|s
operator|->
name|link
argument_list|,
name|vn
operator|->
name|vn_file
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|PRT
argument_list|(
literal|"\nentry: %d\n"
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tvn_version: %u\n"
argument_list|,
name|vn
operator|->
name|vn_version
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tvn_cnt: %u\n"
argument_list|,
name|vn
operator|->
name|vn_cnt
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tvn_file: %s\n"
argument_list|,
name|get_string
argument_list|(
name|ed
argument_list|,
name|s
operator|->
name|link
argument_list|,
name|vn
operator|->
name|vn_file
argument_list|)
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tvn_aux: %u\n"
argument_list|,
name|vn
operator|->
name|vn_aux
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\tvn_next: %u\n\n"
argument_list|,
name|vn
operator|->
name|vn_next
argument_list|)
expr_stmt|;
block|}
name|buf2
operator|=
name|buf
operator|+
name|vn
operator|->
name|vn_aux
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|buf2
operator|+
sizeof|sizeof
argument_list|(
name|Elf32_Vernaux
argument_list|)
operator|<=
name|end
operator|&&
name|j
operator|<
name|vn
operator|->
name|vn_cnt
condition|)
block|{
name|vna
operator|=
operator|(
name|Elf32_Vernaux
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|buf2
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|flags
operator|&
name|SOLARIS_FMT
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|PRT
argument_list|(
literal|"%40.40s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|first
operator|=
literal|0
expr_stmt|;
name|PRT
argument_list|(
literal|"%s\n"
argument_list|,
name|get_string
argument_list|(
name|ed
argument_list|,
name|s
operator|->
name|link
argument_list|,
name|vna
operator|->
name|vna_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PRT
argument_list|(
literal|"\t\tvna: %d\n"
argument_list|,
name|j
operator|++
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\t\t\tvna_hash: %u\n"
argument_list|,
name|vna
operator|->
name|vna_hash
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\t\t\tvna_flags: %u\n"
argument_list|,
name|vna
operator|->
name|vna_flags
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\t\t\tvna_other: %u\n"
argument_list|,
name|vna
operator|->
name|vna_other
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\t\t\tvna_name: %s\n"
argument_list|,
name|get_string
argument_list|(
name|ed
argument_list|,
name|s
operator|->
name|link
argument_list|,
name|vna
operator|->
name|vna_name
argument_list|)
argument_list|)
expr_stmt|;
name|PRT
argument_list|(
literal|"\t\t\tvna_next: %u\n"
argument_list|,
name|vna
operator|->
name|vna_next
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vna
operator|->
name|vna_next
operator|==
literal|0
condition|)
break|break;
name|buf2
operator|+=
name|vna
operator|->
name|vna_next
expr_stmt|;
block|}
if|if
condition|(
name|vn
operator|->
name|vn_next
operator|==
literal|0
condition|)
break|break;
name|buf
operator|+=
name|vn
operator|->
name|vn_next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Dump the symbol-versioning sections.  */
end_comment

begin_function
specifier|static
name|void
name|elf_print_symver
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ed
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|ed
operator|->
name|sl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|ed
operator|->
name|snl
argument_list|)
operator|&&
operator|!
name|find_name
argument_list|(
name|ed
argument_list|,
name|s
operator|->
name|name
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|SHT_SUNW_verdef
condition|)
name|elf_print_verdef
argument_list|(
name|ed
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|SHT_SUNW_verneed
condition|)
name|elf_print_verneed
argument_list|(
name|ed
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Dump the ELF checksum. See gelf_checksum(3) for details.  */
end_comment

begin_function
specifier|static
name|void
name|elf_print_checksum
parameter_list|(
name|struct
name|elfdump
modifier|*
name|ed
parameter_list|)
block|{
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|ed
operator|->
name|snl
argument_list|)
condition|)
return|return;
name|PRT
argument_list|(
literal|"\nelf checksum: %#lx\n"
argument_list|,
name|gelf_checksum
argument_list|(
name|ed
operator|->
name|elf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|USAGE_MESSAGE
value|"\ Usage: %s [options] file...\n\   Display information about ELF objects and ar(1) archives.\n\n\   Options:\n\   -a                        Show all information.\n\   -c                        Show shared headers.\n\   -d                        Show dynamic symbols.\n\   -e                        Show the ELF header.\n\   -G                        Show the GOT.\n\   -H | --help               Show a usage message and exit.\n\   -h                        Show hash values.\n\   -i                        Show the dynamic interpreter.\n\   -k                        Show the ELF checksum.\n\   -n                        Show the contents of note sections.\n\   -N NAME                   Show the section named \"NAME\".\n\   -p                        Show the program header.\n\   -r                        Show relocations.\n\   -s                        Show the symbol table.\n\   -S                        Use the Solaris elfdump format.\n\   -v                        Show symbol-versioning information.\n\   -V | --version            Print a version identifier and exit.\n\   -w FILE                   Write output to \"FILE\".\n"
end_define

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|USAGE_MESSAGE
argument_list|,
name|ELFTC_GETPROGNAME
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

