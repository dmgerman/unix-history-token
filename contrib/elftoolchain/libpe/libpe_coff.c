begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015 Kai Wang  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"_libpe.h"
end_include

begin_expr_stmt
name|ELFTC_VCSID
argument_list|(
literal|"$Id: libpe_coff.c 3326 2016-01-16 17:46:17Z kaiwang27 $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|libpe_parse_coff_header
parameter_list|(
name|PE
modifier|*
name|pe
parameter_list|,
name|char
modifier|*
name|hdr
parameter_list|)
block|{
name|char
name|tmp
index|[
literal|128
index|]
decl_stmt|;
name|PE_CoffHdr
modifier|*
name|ch
decl_stmt|;
name|PE_OptHdr
modifier|*
name|oh
decl_stmt|;
name|PE_DataDir
modifier|*
name|dd
decl_stmt|;
name|unsigned
name|p
decl_stmt|,
name|r
decl_stmt|,
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|ch
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|PE_CoffHdr
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|PE_READ16
argument_list|(
name|hdr
argument_list|,
name|ch
operator|->
name|ch_machine
argument_list|)
expr_stmt|;
name|PE_READ16
argument_list|(
name|hdr
argument_list|,
name|ch
operator|->
name|ch_nsec
argument_list|)
expr_stmt|;
name|PE_READ32
argument_list|(
name|hdr
argument_list|,
name|ch
operator|->
name|ch_timestamp
argument_list|)
expr_stmt|;
name|PE_READ32
argument_list|(
name|hdr
argument_list|,
name|ch
operator|->
name|ch_symptr
argument_list|)
expr_stmt|;
name|PE_READ32
argument_list|(
name|hdr
argument_list|,
name|ch
operator|->
name|ch_nsym
argument_list|)
expr_stmt|;
name|PE_READ16
argument_list|(
name|hdr
argument_list|,
name|ch
operator|->
name|ch_optsize
argument_list|)
expr_stmt|;
name|PE_READ16
argument_list|(
name|hdr
argument_list|,
name|ch
operator|->
name|ch_char
argument_list|)
expr_stmt|;
name|pe
operator|->
name|pe_ch
operator|=
name|ch
expr_stmt|;
comment|/* 	 * The Optional header is omitted for object files. 	 */
if|if
condition|(
name|ch
operator|->
name|ch_optsize
operator|==
literal|0
condition|)
return|return
operator|(
name|libpe_parse_section_headers
argument_list|(
name|pe
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|oh
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|PE_OptHdr
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pe
operator|->
name|pe_oh
operator|=
name|oh
expr_stmt|;
define|#
directive|define
name|READ_OPT
parameter_list|(
name|n
parameter_list|)
define|\
value|do {								\
comment|/*							\ 		 * Since the Optional Header size is variable, we must	\ 		 * check if the requested read size will overrun the	\ 		 * remaining header bytes.				\ 		 */
value|\ 		if (p + (n)> ch->ch_optsize) {				\
comment|/* Consume the "extra" bytes */
value|\ 			r = ch->ch_optsize - p;				\ 			if (read(pe->pe_fd, tmp, r) != (ssize_t) r) {	\ 				pe->pe_flags |= LIBPE_F_BAD_SEC_HEADER;\ 				return (0);				\ 			}						\ 			return (libpe_parse_section_headers(pe));	\ 		}							\ 		if (read(pe->pe_fd, tmp, (n)) != (ssize_t) (n)) {	\ 			pe->pe_flags |= LIBPE_F_BAD_OPT_HEADER;	\ 			return (0);					\ 		}							\ 		p += (n);						\ 	} while (0)
define|#
directive|define
name|READ_OPT8
parameter_list|(
name|v
parameter_list|)
value|do { READ_OPT(1); (v) = *tmp; } while(0)
define|#
directive|define
name|READ_OPT16
parameter_list|(
name|v
parameter_list|)
value|do { READ_OPT(2); (v) = le16dec(tmp); } while(0)
define|#
directive|define
name|READ_OPT32
parameter_list|(
name|v
parameter_list|)
value|do { READ_OPT(4); (v) = le32dec(tmp); } while(0)
define|#
directive|define
name|READ_OPT64
parameter_list|(
name|v
parameter_list|)
value|do { READ_OPT(8); (v) = le64dec(tmp); } while(0)
comment|/* 	 * Read in the Optional header. Size of some fields are depending 	 * on the PE format specified by the oh_magic field. (PE32 or PE32+) 	 */
name|p
operator|=
literal|0
expr_stmt|;
name|READ_OPT16
argument_list|(
name|oh
operator|->
name|oh_magic
argument_list|)
expr_stmt|;
if|if
condition|(
name|oh
operator|->
name|oh_magic
operator|==
name|PE_FORMAT_32P
condition|)
name|pe
operator|->
name|pe_obj
operator|=
name|PE_O_PE32P
expr_stmt|;
name|READ_OPT8
argument_list|(
name|oh
operator|->
name|oh_ldvermajor
argument_list|)
expr_stmt|;
name|READ_OPT8
argument_list|(
name|oh
operator|->
name|oh_ldverminor
argument_list|)
expr_stmt|;
name|READ_OPT32
argument_list|(
name|oh
operator|->
name|oh_textsize
argument_list|)
expr_stmt|;
name|READ_OPT32
argument_list|(
name|oh
operator|->
name|oh_datasize
argument_list|)
expr_stmt|;
name|READ_OPT32
argument_list|(
name|oh
operator|->
name|oh_bsssize
argument_list|)
expr_stmt|;
name|READ_OPT32
argument_list|(
name|oh
operator|->
name|oh_entry
argument_list|)
expr_stmt|;
name|READ_OPT32
argument_list|(
name|oh
operator|->
name|oh_textbase
argument_list|)
expr_stmt|;
if|if
condition|(
name|oh
operator|->
name|oh_magic
operator|!=
name|PE_FORMAT_32P
condition|)
block|{
name|READ_OPT32
argument_list|(
name|oh
operator|->
name|oh_database
argument_list|)
expr_stmt|;
name|READ_OPT32
argument_list|(
name|oh
operator|->
name|oh_imgbase
argument_list|)
expr_stmt|;
block|}
else|else
name|READ_OPT64
argument_list|(
name|oh
operator|->
name|oh_imgbase
argument_list|)
expr_stmt|;
name|READ_OPT32
argument_list|(
name|oh
operator|->
name|oh_secalign
argument_list|)
expr_stmt|;
name|READ_OPT32
argument_list|(
name|oh
operator|->
name|oh_filealign
argument_list|)
expr_stmt|;
name|READ_OPT16
argument_list|(
name|oh
operator|->
name|oh_osvermajor
argument_list|)
expr_stmt|;
name|READ_OPT16
argument_list|(
name|oh
operator|->
name|oh_osverminor
argument_list|)
expr_stmt|;
name|READ_OPT16
argument_list|(
name|oh
operator|->
name|oh_imgvermajor
argument_list|)
expr_stmt|;
name|READ_OPT16
argument_list|(
name|oh
operator|->
name|oh_imgverminor
argument_list|)
expr_stmt|;
name|READ_OPT16
argument_list|(
name|oh
operator|->
name|oh_subvermajor
argument_list|)
expr_stmt|;
name|READ_OPT16
argument_list|(
name|oh
operator|->
name|oh_subverminor
argument_list|)
expr_stmt|;
name|READ_OPT32
argument_list|(
name|oh
operator|->
name|oh_win32ver
argument_list|)
expr_stmt|;
name|READ_OPT32
argument_list|(
name|oh
operator|->
name|oh_imgsize
argument_list|)
expr_stmt|;
name|READ_OPT32
argument_list|(
name|oh
operator|->
name|oh_hdrsize
argument_list|)
expr_stmt|;
name|READ_OPT32
argument_list|(
name|oh
operator|->
name|oh_checksum
argument_list|)
expr_stmt|;
name|READ_OPT16
argument_list|(
name|oh
operator|->
name|oh_subsystem
argument_list|)
expr_stmt|;
name|READ_OPT16
argument_list|(
name|oh
operator|->
name|oh_dllchar
argument_list|)
expr_stmt|;
if|if
condition|(
name|oh
operator|->
name|oh_magic
operator|!=
name|PE_FORMAT_32P
condition|)
block|{
name|READ_OPT32
argument_list|(
name|oh
operator|->
name|oh_stacksizer
argument_list|)
expr_stmt|;
name|READ_OPT32
argument_list|(
name|oh
operator|->
name|oh_stacksizec
argument_list|)
expr_stmt|;
name|READ_OPT32
argument_list|(
name|oh
operator|->
name|oh_heapsizer
argument_list|)
expr_stmt|;
name|READ_OPT32
argument_list|(
name|oh
operator|->
name|oh_heapsizec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|READ_OPT64
argument_list|(
name|oh
operator|->
name|oh_stacksizer
argument_list|)
expr_stmt|;
name|READ_OPT64
argument_list|(
name|oh
operator|->
name|oh_stacksizec
argument_list|)
expr_stmt|;
name|READ_OPT64
argument_list|(
name|oh
operator|->
name|oh_heapsizer
argument_list|)
expr_stmt|;
name|READ_OPT64
argument_list|(
name|oh
operator|->
name|oh_heapsizec
argument_list|)
expr_stmt|;
block|}
name|READ_OPT32
argument_list|(
name|oh
operator|->
name|oh_ldrflags
argument_list|)
expr_stmt|;
name|READ_OPT32
argument_list|(
name|oh
operator|->
name|oh_ndatadir
argument_list|)
expr_stmt|;
comment|/* 	 * Read in the Data Directories. 	 */
if|if
condition|(
name|oh
operator|->
name|oh_ndatadir
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|dd
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|PE_DataDir
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pe
operator|->
name|pe_dd
operator|=
name|dd
expr_stmt|;
name|dd
operator|->
name|dd_total
operator|=
name|oh
operator|->
name|oh_ndatadir
operator|<
name|PE_DD_MAX
condition|?
name|oh
operator|->
name|oh_ndatadir
else|:
name|PE_DD_MAX
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|uint32_t
operator|)
name|i
operator|<
name|dd
operator|->
name|dd_total
condition|;
name|i
operator|++
control|)
block|{
name|READ_OPT32
argument_list|(
name|dd
operator|->
name|dd_e
index|[
name|i
index|]
operator|.
name|de_addr
argument_list|)
expr_stmt|;
name|READ_OPT32
argument_list|(
name|dd
operator|->
name|dd_e
index|[
name|i
index|]
operator|.
name|de_size
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Consume the remaining bytes in the Optional header, if any. */
if|if
condition|(
name|ch
operator|->
name|ch_optsize
operator|>
name|p
condition|)
block|{
name|r
operator|=
name|ch
operator|->
name|ch_optsize
operator|-
name|p
expr_stmt|;
for|for
control|(
init|;
name|r
operator|>
literal|0
condition|;
name|r
operator|-=
name|s
control|)
block|{
name|s
operator|=
name|r
operator|>
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
condition|?
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
else|:
name|r
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|pe
operator|->
name|pe_fd
argument_list|,
name|tmp
argument_list|,
name|s
argument_list|)
operator|!=
operator|(
name|ssize_t
operator|)
name|s
condition|)
block|{
name|pe
operator|->
name|pe_flags
operator||=
name|LIBPE_F_BAD_SEC_HEADER
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|libpe_parse_section_headers
argument_list|(
name|pe
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|off_t
name|libpe_write_pe_header
parameter_list|(
name|PE
modifier|*
name|pe
parameter_list|,
name|off_t
name|off
parameter_list|)
block|{
name|char
name|tmp
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|pe
operator|->
name|pe_cmd
operator|==
name|PE_C_RDWR
operator|&&
operator|(
name|pe
operator|->
name|pe_flags
operator|&
name|LIBPE_F_BAD_PE_HEADER
operator|)
operator|==
literal|0
condition|)
block|{
name|assert
argument_list|(
name|pe
operator|->
name|pe_dh
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|off
operator|=
name|lseek
argument_list|(
name|pe
operator|->
name|pe_fd
argument_list|,
operator|(
name|off_t
operator|)
name|pe
operator|->
name|pe_dh
operator|->
name|dh_lfanew
operator|+
literal|4
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
return|return
operator|(
name|off
operator|)
return|;
block|}
comment|/* 	 * PE Header should to be aligned on 8-byte boundary according to 	 * the PE/COFF specification. 	 */
if|if
condition|(
operator|(
name|off
operator|=
name|libpe_align
argument_list|(
name|pe
argument_list|,
name|off
argument_list|,
literal|8
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|le32enc
argument_list|(
name|tmp
argument_list|,
name|PE_SIGNATURE
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pe
operator|->
name|pe_fd
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|!=
operator|(
name|ssize_t
operator|)
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|off
operator|+=
literal|4
expr_stmt|;
name|pe
operator|->
name|pe_flags
operator|&=
operator|~
name|LIBPE_F_BAD_PE_HEADER
expr_stmt|;
comment|/* Trigger rewrite for the following headers. */
name|pe
operator|->
name|pe_flags
operator||=
name|LIBPE_F_DIRTY_COFF_HEADER
expr_stmt|;
name|pe
operator|->
name|pe_flags
operator||=
name|LIBPE_F_DIRTY_OPT_HEADER
expr_stmt|;
return|return
operator|(
name|off
operator|)
return|;
block|}
end_function

begin_function
name|off_t
name|libpe_write_coff_header
parameter_list|(
name|PE
modifier|*
name|pe
parameter_list|,
name|off_t
name|off
parameter_list|)
block|{
name|char
name|tmp
index|[
literal|128
index|]
decl_stmt|,
modifier|*
name|hdr
decl_stmt|;
name|PE_CoffHdr
modifier|*
name|ch
decl_stmt|;
name|PE_DataDir
modifier|*
name|dd
decl_stmt|;
name|PE_OptHdr
modifier|*
name|oh
decl_stmt|;
name|PE_Scn
modifier|*
name|ps
decl_stmt|;
name|PE_SecHdr
modifier|*
name|sh
decl_stmt|;
name|unsigned
name|p
decl_stmt|;
name|uint32_t
name|reloc_rva
decl_stmt|,
name|reloc_sz
decl_stmt|;
name|int
name|i
decl_stmt|,
name|reloc
decl_stmt|;
name|reloc
operator|=
literal|0
expr_stmt|;
name|reloc_rva
operator|=
name|reloc_sz
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pe
operator|->
name|pe_cmd
operator|==
name|PE_C_RDWR
condition|)
block|{
name|assert
argument_list|(
operator|(
name|pe
operator|->
name|pe_flags
operator|&
name|LIBPE_F_SPECIAL_FILE
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pe
operator|->
name|pe_flags
operator|&
name|LIBPE_F_DIRTY_COFF_HEADER
operator|)
operator|==
literal|0
operator|&&
operator|(
name|pe
operator|->
name|pe_flags
operator|&
name|LIBPE_F_BAD_COFF_HEADER
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|lseek
argument_list|(
name|pe
operator|->
name|pe_fd
argument_list|,
operator|(
name|off_t
operator|)
sizeof|sizeof
argument_list|(
name|PE_CoffHdr
argument_list|)
argument_list|,
name|SEEK_CUR
argument_list|)
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|off
operator|+=
sizeof|sizeof
argument_list|(
name|PE_CoffHdr
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pe
operator|->
name|pe_ch
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ch
operator|=
name|pe
operator|->
name|pe_ch
expr_stmt|;
goto|goto
name|coff_done
goto|;
block|}
comment|/* lseek(2) to the offset of the COFF header. */
if|if
condition|(
name|lseek
argument_list|(
name|pe
operator|->
name|pe_fd
argument_list|,
name|off
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|pe
operator|->
name|pe_ch
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|PE_CoffHdr
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pe
operator|->
name|pe_ch
operator|=
name|ch
expr_stmt|;
comment|/* 		 * Default value for ch_machine if not provided by the 		 * application. 		 */
if|if
condition|(
name|pe
operator|->
name|pe_obj
operator|==
name|PE_O_PE32P
condition|)
name|ch
operator|->
name|ch_machine
operator|=
name|IMAGE_FILE_MACHINE_AMD64
expr_stmt|;
else|else
name|ch
operator|->
name|ch_machine
operator|=
name|IMAGE_FILE_MACHINE_I386
expr_stmt|;
block|}
else|else
name|ch
operator|=
name|pe
operator|->
name|pe_ch
expr_stmt|;
if|if
condition|(
operator|!
name|ch
operator|->
name|ch_timestamp
condition|)
name|ch
operator|->
name|ch_timestamp
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe
operator|->
name|pe_obj
operator|==
name|PE_O_PE32
condition|)
block|{
if|if
condition|(
operator|!
name|ch
operator|->
name|ch_optsize
condition|)
name|ch
operator|->
name|ch_optsize
operator|=
name|PE_COFF_OPT_SIZE_32
expr_stmt|;
name|ch
operator|->
name|ch_char
operator||=
name|IMAGE_FILE_EXECUTABLE_IMAGE
operator||
name|IMAGE_FILE_32BIT_MACHINE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pe
operator|->
name|pe_obj
operator|==
name|PE_O_PE32P
condition|)
block|{
if|if
condition|(
operator|!
name|ch
operator|->
name|ch_optsize
condition|)
name|ch
operator|->
name|ch_optsize
operator|=
name|PE_COFF_OPT_SIZE_32P
expr_stmt|;
name|ch
operator|->
name|ch_char
operator||=
name|IMAGE_FILE_EXECUTABLE_IMAGE
operator||
name|IMAGE_FILE_LARGE_ADDRESS_AWARE
expr_stmt|;
block|}
else|else
name|ch
operator|->
name|ch_optsize
operator|=
literal|0
expr_stmt|;
comment|/* 	 * COFF line number is deprecated by the PE/COFF 	 * specification. COFF symbol table is deprecated 	 * for executables. 	 */
name|ch
operator|->
name|ch_char
operator||=
name|IMAGE_FILE_LINE_NUMS_STRIPPED
expr_stmt|;
if|if
condition|(
name|pe
operator|->
name|pe_obj
operator|==
name|PE_O_PE32
operator|||
name|pe
operator|->
name|pe_obj
operator|==
name|PE_O_PE32P
condition|)
name|ch
operator|->
name|ch_char
operator||=
name|IMAGE_FILE_LOCAL_SYMS_STRIPPED
expr_stmt|;
name|ch
operator|->
name|ch_nsec
operator|=
name|pe
operator|->
name|pe_nscn
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|ps
argument_list|,
argument|&pe->pe_scn
argument_list|,
argument|ps_next
argument_list|)
block|{
name|sh
operator|=
operator|&
name|ps
operator|->
name|ps_sh
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|ps_ndx
operator|==
literal|0xFFFFFFFFU
condition|)
block|{
name|ch
operator|->
name|ch_symptr
operator|=
name|sh
operator|->
name|sh_rawptr
expr_stmt|;
name|ch
operator|->
name|ch_nsym
operator|=
name|pe
operator|->
name|pe_nsym
expr_stmt|;
block|}
if|if
condition|(
name|pe
operator|->
name|pe_obj
operator|==
name|PE_O_PE32
operator|||
name|pe
operator|->
name|pe_obj
operator|==
name|PE_O_PE32P
condition|)
block|{
if|if
condition|(
name|ps
operator|->
name|ps_ndx
operator|==
operator|(
literal|0xFFFF0000
operator||
name|PE_DD_BASERELOC
operator|)
operator|||
name|strncmp
argument_list|(
name|sh
operator|->
name|sh_name
argument_list|,
literal|".reloc"
argument_list|,
name|strlen
argument_list|(
literal|".reloc"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|reloc
operator|=
literal|1
expr_stmt|;
name|reloc_rva
operator|=
name|sh
operator|->
name|sh_addr
expr_stmt|;
name|reloc_sz
operator|=
name|sh
operator|->
name|sh_virtsize
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|reloc
condition|)
name|ch
operator|->
name|ch_char
operator||=
name|IMAGE_FILE_RELOCS_STRIPPED
expr_stmt|;
if|if
condition|(
name|pe
operator|->
name|pe_flags
operator|&
name|LIBPE_F_BAD_OPT_HEADER
condition|)
block|{
if|if
condition|(
name|pe
operator|->
name|pe_obj
operator|==
name|PE_O_PE32
condition|)
name|ch
operator|->
name|ch_optsize
operator|=
name|PE_COFF_OPT_SIZE_32
expr_stmt|;
elseif|else
if|if
condition|(
name|pe
operator|->
name|pe_obj
operator|==
name|PE_O_PE32P
condition|)
name|ch
operator|->
name|ch_optsize
operator|=
name|PE_COFF_OPT_SIZE_32P
expr_stmt|;
else|else
name|ch
operator|->
name|ch_optsize
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Write the COFF header. 	 */
name|hdr
operator|=
name|tmp
expr_stmt|;
name|PE_WRITE16
argument_list|(
name|hdr
argument_list|,
name|ch
operator|->
name|ch_machine
argument_list|)
expr_stmt|;
name|PE_WRITE16
argument_list|(
name|hdr
argument_list|,
name|ch
operator|->
name|ch_nsec
argument_list|)
expr_stmt|;
name|PE_WRITE32
argument_list|(
name|hdr
argument_list|,
name|ch
operator|->
name|ch_timestamp
argument_list|)
expr_stmt|;
name|PE_WRITE32
argument_list|(
name|hdr
argument_list|,
name|ch
operator|->
name|ch_symptr
argument_list|)
expr_stmt|;
name|PE_WRITE32
argument_list|(
name|hdr
argument_list|,
name|ch
operator|->
name|ch_nsym
argument_list|)
expr_stmt|;
name|PE_WRITE16
argument_list|(
name|hdr
argument_list|,
name|ch
operator|->
name|ch_optsize
argument_list|)
expr_stmt|;
name|PE_WRITE16
argument_list|(
name|hdr
argument_list|,
name|ch
operator|->
name|ch_char
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pe
operator|->
name|pe_fd
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|PE_CoffHdr
argument_list|)
argument_list|)
operator|!=
operator|(
name|ssize_t
operator|)
sizeof|sizeof
argument_list|(
name|PE_CoffHdr
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|coff_done
label|:
name|off
operator|+=
sizeof|sizeof
argument_list|(
name|PE_CoffHdr
argument_list|)
expr_stmt|;
name|pe
operator|->
name|pe_flags
operator|&=
operator|~
name|LIBPE_F_DIRTY_COFF_HEADER
expr_stmt|;
name|pe
operator|->
name|pe_flags
operator|&=
operator|~
name|LIBPE_F_BAD_COFF_HEADER
expr_stmt|;
name|pe
operator|->
name|pe_flags
operator||=
name|LIBPE_F_DIRTY_SEC_HEADER
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|ch_optsize
operator|==
literal|0
condition|)
return|return
operator|(
name|off
operator|)
return|;
comment|/* 	 * Write the Optional header. 	 */
if|if
condition|(
name|pe
operator|->
name|pe_cmd
operator|==
name|PE_C_RDWR
condition|)
block|{
if|if
condition|(
operator|(
name|pe
operator|->
name|pe_flags
operator|&
name|LIBPE_F_DIRTY_OPT_HEADER
operator|)
operator|==
literal|0
operator|&&
operator|(
name|pe
operator|->
name|pe_flags
operator|&
name|LIBPE_F_BAD_OPT_HEADER
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|lseek
argument_list|(
name|pe
operator|->
name|pe_fd
argument_list|,
operator|(
name|off_t
operator|)
name|ch
operator|->
name|ch_optsize
argument_list|,
name|SEEK_CUR
argument_list|)
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|off
operator|+=
name|ch
operator|->
name|ch_optsize
expr_stmt|;
return|return
operator|(
name|off
operator|)
return|;
block|}
block|}
if|if
condition|(
name|pe
operator|->
name|pe_oh
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|oh
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|PE_OptHdr
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pe
operator|->
name|pe_oh
operator|=
name|oh
expr_stmt|;
block|}
else|else
name|oh
operator|=
name|pe
operator|->
name|pe_oh
expr_stmt|;
if|if
condition|(
name|pe
operator|->
name|pe_obj
operator|==
name|PE_O_PE32
condition|)
name|oh
operator|->
name|oh_magic
operator|=
name|PE_FORMAT_32
expr_stmt|;
else|else
name|oh
operator|->
name|oh_magic
operator|=
name|PE_FORMAT_32P
expr_stmt|;
comment|/* 	 * LinkerVersion should not be less than 2.5, which will cause 	 * Windows to complain the executable is invalid in some case. 	 * By default we set LinkerVersion to 2.22 (binutils 2.22) 	 */
if|if
condition|(
operator|!
name|oh
operator|->
name|oh_ldvermajor
operator|&&
operator|!
name|oh
operator|->
name|oh_ldverminor
condition|)
block|{
name|oh
operator|->
name|oh_ldvermajor
operator|=
literal|2
expr_stmt|;
name|oh
operator|->
name|oh_ldverminor
operator|=
literal|22
expr_stmt|;
block|}
comment|/* 	 * The library always tries to write out all 16 data directories 	 * but the actual data dir written will depend on ch_optsize. 	 */
name|oh
operator|->
name|oh_ndatadir
operator|=
name|PE_DD_MAX
expr_stmt|;
if|if
condition|(
operator|!
name|oh
operator|->
name|oh_filealign
condition|)
name|oh
operator|->
name|oh_filealign
operator|=
literal|0x200
expr_stmt|;
if|if
condition|(
operator|!
name|oh
operator|->
name|oh_secalign
condition|)
name|oh
operator|->
name|oh_secalign
operator|=
literal|0x1000
expr_stmt|;
name|oh
operator|->
name|oh_hdrsize
operator|=
name|roundup
argument_list|(
name|off
operator|+
name|ch
operator|->
name|ch_optsize
operator|+
name|pe
operator|->
name|pe_nscn
operator|*
sizeof|sizeof
argument_list|(
name|PE_SecHdr
argument_list|)
argument_list|,
name|oh
operator|->
name|oh_filealign
argument_list|)
expr_stmt|;
name|oh
operator|->
name|oh_imgsize
operator|=
name|roundup
argument_list|(
name|pe
operator|->
name|pe_rvamax
argument_list|,
name|oh
operator|->
name|oh_secalign
argument_list|)
expr_stmt|;
define|#
directive|define
name|WRITE_OPT
parameter_list|(
name|n
parameter_list|)
define|\
value|do {								\
comment|/*							\ 		 * Since the Optional Header size is variable, we must	\ 		 * check if the requested write size will overrun the	\ 		 * remaining header bytes.				\ 		 */
value|\ 		if (p + (n)> ch->ch_optsize) {				\
comment|/* Pad the "extra" bytes */
value|\ 			if (libpe_pad(pe, ch->ch_optsize - p)< 0) {	\ 				errno = EIO;				\ 				return (-1);				\ 			}						\ 			goto opt_done;					\ 		}							\ 		if (write(pe->pe_fd, tmp, (n)) != (ssize_t) (n)) {	\ 			errno = EIO;					\ 			return (-1);					\ 		}							\ 		p += (n);						\ 	} while (0)
define|#
directive|define
name|WRITE_OPT8
parameter_list|(
name|v
parameter_list|)
value|do { *tmp = (v); WRITE_OPT(1); } while(0)
define|#
directive|define
name|WRITE_OPT16
parameter_list|(
name|v
parameter_list|)
value|do { le16enc(tmp, (v)); WRITE_OPT(2); } while(0)
define|#
directive|define
name|WRITE_OPT32
parameter_list|(
name|v
parameter_list|)
value|do { le32enc(tmp, (v)); WRITE_OPT(4); } while(0)
define|#
directive|define
name|WRITE_OPT64
parameter_list|(
name|v
parameter_list|)
value|do { le64enc(tmp, (v)); WRITE_OPT(8); } while(0)
name|p
operator|=
literal|0
expr_stmt|;
name|WRITE_OPT16
argument_list|(
name|oh
operator|->
name|oh_magic
argument_list|)
expr_stmt|;
if|if
condition|(
name|oh
operator|->
name|oh_magic
operator|==
name|PE_FORMAT_32P
condition|)
name|pe
operator|->
name|pe_obj
operator|=
name|PE_O_PE32P
expr_stmt|;
name|WRITE_OPT8
argument_list|(
name|oh
operator|->
name|oh_ldvermajor
argument_list|)
expr_stmt|;
name|WRITE_OPT8
argument_list|(
name|oh
operator|->
name|oh_ldverminor
argument_list|)
expr_stmt|;
name|WRITE_OPT32
argument_list|(
name|oh
operator|->
name|oh_textsize
argument_list|)
expr_stmt|;
name|WRITE_OPT32
argument_list|(
name|oh
operator|->
name|oh_datasize
argument_list|)
expr_stmt|;
name|WRITE_OPT32
argument_list|(
name|oh
operator|->
name|oh_bsssize
argument_list|)
expr_stmt|;
name|WRITE_OPT32
argument_list|(
name|oh
operator|->
name|oh_entry
argument_list|)
expr_stmt|;
name|WRITE_OPT32
argument_list|(
name|oh
operator|->
name|oh_textbase
argument_list|)
expr_stmt|;
if|if
condition|(
name|oh
operator|->
name|oh_magic
operator|!=
name|PE_FORMAT_32P
condition|)
block|{
name|WRITE_OPT32
argument_list|(
name|oh
operator|->
name|oh_database
argument_list|)
expr_stmt|;
name|WRITE_OPT32
argument_list|(
name|oh
operator|->
name|oh_imgbase
argument_list|)
expr_stmt|;
block|}
else|else
name|WRITE_OPT64
argument_list|(
name|oh
operator|->
name|oh_imgbase
argument_list|)
expr_stmt|;
name|WRITE_OPT32
argument_list|(
name|oh
operator|->
name|oh_secalign
argument_list|)
expr_stmt|;
name|WRITE_OPT32
argument_list|(
name|oh
operator|->
name|oh_filealign
argument_list|)
expr_stmt|;
name|WRITE_OPT16
argument_list|(
name|oh
operator|->
name|oh_osvermajor
argument_list|)
expr_stmt|;
name|WRITE_OPT16
argument_list|(
name|oh
operator|->
name|oh_osverminor
argument_list|)
expr_stmt|;
name|WRITE_OPT16
argument_list|(
name|oh
operator|->
name|oh_imgvermajor
argument_list|)
expr_stmt|;
name|WRITE_OPT16
argument_list|(
name|oh
operator|->
name|oh_imgverminor
argument_list|)
expr_stmt|;
name|WRITE_OPT16
argument_list|(
name|oh
operator|->
name|oh_subvermajor
argument_list|)
expr_stmt|;
name|WRITE_OPT16
argument_list|(
name|oh
operator|->
name|oh_subverminor
argument_list|)
expr_stmt|;
name|WRITE_OPT32
argument_list|(
name|oh
operator|->
name|oh_win32ver
argument_list|)
expr_stmt|;
name|WRITE_OPT32
argument_list|(
name|oh
operator|->
name|oh_imgsize
argument_list|)
expr_stmt|;
name|WRITE_OPT32
argument_list|(
name|oh
operator|->
name|oh_hdrsize
argument_list|)
expr_stmt|;
name|WRITE_OPT32
argument_list|(
name|oh
operator|->
name|oh_checksum
argument_list|)
expr_stmt|;
name|WRITE_OPT16
argument_list|(
name|oh
operator|->
name|oh_subsystem
argument_list|)
expr_stmt|;
name|WRITE_OPT16
argument_list|(
name|oh
operator|->
name|oh_dllchar
argument_list|)
expr_stmt|;
if|if
condition|(
name|oh
operator|->
name|oh_magic
operator|!=
name|PE_FORMAT_32P
condition|)
block|{
name|WRITE_OPT32
argument_list|(
name|oh
operator|->
name|oh_stacksizer
argument_list|)
expr_stmt|;
name|WRITE_OPT32
argument_list|(
name|oh
operator|->
name|oh_stacksizec
argument_list|)
expr_stmt|;
name|WRITE_OPT32
argument_list|(
name|oh
operator|->
name|oh_heapsizer
argument_list|)
expr_stmt|;
name|WRITE_OPT32
argument_list|(
name|oh
operator|->
name|oh_heapsizec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|WRITE_OPT64
argument_list|(
name|oh
operator|->
name|oh_stacksizer
argument_list|)
expr_stmt|;
name|WRITE_OPT64
argument_list|(
name|oh
operator|->
name|oh_stacksizec
argument_list|)
expr_stmt|;
name|WRITE_OPT64
argument_list|(
name|oh
operator|->
name|oh_heapsizer
argument_list|)
expr_stmt|;
name|WRITE_OPT64
argument_list|(
name|oh
operator|->
name|oh_heapsizec
argument_list|)
expr_stmt|;
block|}
name|WRITE_OPT32
argument_list|(
name|oh
operator|->
name|oh_ldrflags
argument_list|)
expr_stmt|;
name|WRITE_OPT32
argument_list|(
name|oh
operator|->
name|oh_ndatadir
argument_list|)
expr_stmt|;
comment|/* 	 * Write the Data Directories. 	 */
if|if
condition|(
name|oh
operator|->
name|oh_ndatadir
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|pe
operator|->
name|pe_dd
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|dd
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|PE_DataDir
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pe
operator|->
name|pe_dd
operator|=
name|dd
expr_stmt|;
name|dd
operator|->
name|dd_total
operator|=
name|PE_DD_MAX
expr_stmt|;
block|}
else|else
name|dd
operator|=
name|pe
operator|->
name|pe_dd
expr_stmt|;
name|assert
argument_list|(
name|oh
operator|->
name|oh_ndatadir
operator|<=
name|PE_DD_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
condition|)
block|{
name|dd
operator|->
name|dd_e
index|[
name|PE_DD_BASERELOC
index|]
operator|.
name|de_addr
operator|=
name|reloc_rva
expr_stmt|;
name|dd
operator|->
name|dd_e
index|[
name|PE_DD_BASERELOC
index|]
operator|.
name|de_size
operator|=
name|reloc_sz
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|uint32_t
operator|)
name|i
operator|<
name|dd
operator|->
name|dd_total
condition|;
name|i
operator|++
control|)
block|{
name|WRITE_OPT32
argument_list|(
name|dd
operator|->
name|dd_e
index|[
name|i
index|]
operator|.
name|de_addr
argument_list|)
expr_stmt|;
name|WRITE_OPT32
argument_list|(
name|dd
operator|->
name|dd_e
index|[
name|i
index|]
operator|.
name|de_size
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Pad the remaining bytes in the Optional header, if any. */
if|if
condition|(
name|ch
operator|->
name|ch_optsize
operator|>
name|p
condition|)
block|{
if|if
condition|(
name|libpe_pad
argument_list|(
name|pe
argument_list|,
name|ch
operator|->
name|ch_optsize
operator|-
name|p
argument_list|)
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|opt_done
label|:
name|off
operator|+=
name|ch
operator|->
name|ch_optsize
expr_stmt|;
name|pe
operator|->
name|pe_flags
operator|&=
operator|~
name|LIBPE_F_DIRTY_OPT_HEADER
expr_stmt|;
name|pe
operator|->
name|pe_flags
operator|&=
operator|~
name|LIBPE_F_BAD_OPT_HEADER
expr_stmt|;
name|pe
operator|->
name|pe_flags
operator||=
name|LIBPE_F_DIRTY_SEC_HEADER
expr_stmt|;
return|return
operator|(
name|off
operator|)
return|;
block|}
end_function

end_unit

