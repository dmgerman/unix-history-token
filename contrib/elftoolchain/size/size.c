begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007 S.Sam Arun Raj  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<gelf.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<libelftc.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"_elftc.h"
end_include

begin_expr_stmt
name|ELFTC_VCSID
argument_list|(
literal|"$Id: size.c 2350 2011-12-19 10:20:06Z jkoshy $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|BUF_SIZE
value|1024
end_define

begin_define
define|#
directive|define
name|ELF_ALIGN
parameter_list|(
name|val
parameter_list|,
name|x
parameter_list|)
value|(((val)+(x)-1)& ~((x)-1))
end_define

begin_define
define|#
directive|define
name|SIZE_VERSION_STRING
value|"size 1.0"
end_define

begin_enum
enum|enum
name|return_code
block|{
name|RETURN_OK
block|,
name|RETURN_NOINPUT
block|,
name|RETURN_DATAERR
block|,
name|RETURN_USAGE
block|}
enum|;
end_enum

begin_enum
enum|enum
name|output_style
block|{
name|STYLE_BERKELEY
block|,
name|STYLE_SYSV
block|}
enum|;
end_enum

begin_enum
enum|enum
name|radix_style
block|{
name|RADIX_OCTAL
block|,
name|RADIX_DECIMAL
block|,
name|RADIX_HEX
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|uint64_t
name|bss_size
decl_stmt|,
name|data_size
decl_stmt|,
name|text_size
decl_stmt|,
name|total_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|bss_size_total
decl_stmt|,
name|data_size_total
decl_stmt|,
name|text_size_total
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|show_totals
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|size_option
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|radix_style
name|radix
init|=
name|RADIX_DECIMAL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|output_style
name|style
init|=
name|STYLE_BERKELEY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|default_args
index|[
literal|2
index|]
init|=
block|{
literal|"a.out"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
block|{
name|int
name|row
decl_stmt|;
name|int
name|col
decl_stmt|;
name|int
modifier|*
name|width
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|tbl
decl_stmt|;
block|}
modifier|*
name|tb
struct|;
end_struct

begin_enum
enum|enum
block|{
name|OPT_FORMAT
block|,
name|OPT_RADIX
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|struct
name|option
name|size_longopts
index|[]
init|=
block|{
block|{
literal|"format"
block|,
name|required_argument
block|,
operator|&
name|size_option
block|,
name|OPT_FORMAT
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'h'
block|}
block|,
block|{
literal|"radix"
block|,
name|required_argument
block|,
operator|&
name|size_option
block|,
name|OPT_RADIX
block|}
block|,
block|{
literal|"totals"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'t'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'V'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|berkeley_calc
parameter_list|(
name|GElf_Shdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|berkeley_footer
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|berkeley_header
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|berkeley_totals
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|handle_core
parameter_list|(
name|char
specifier|const
modifier|*
parameter_list|,
name|Elf
modifier|*
name|elf
parameter_list|,
name|GElf_Ehdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_core_note
parameter_list|(
name|Elf
modifier|*
parameter_list|,
name|GElf_Ehdr
modifier|*
parameter_list|,
name|GElf_Phdr
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|handle_elf
parameter_list|(
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_phdr
parameter_list|(
name|Elf
modifier|*
parameter_list|,
name|GElf_Ehdr
modifier|*
parameter_list|,
name|GElf_Phdr
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|show_version
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sysv_header
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|Elf_Arhdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sysv_footer
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sysv_calc
parameter_list|(
name|Elf
modifier|*
parameter_list|,
name|GElf_Ehdr
modifier|*
parameter_list|,
name|GElf_Shdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tbl_new
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tbl_print
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tbl_print_num
parameter_list|(
name|uint64_t
parameter_list|,
name|enum
name|radix_style
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tbl_append
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tbl_flush
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * size utility using elf(3) and gelf(3) API to list section sizes and  * total in elf files. Supports only elf files (core dumps in elf  * included) that can be opened by libelf, other formats are not supported.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|ch
decl_stmt|,
name|r
decl_stmt|,
name|rc
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|files
decl_stmt|,
modifier|*
name|fn
decl_stmt|;
name|rc
operator|=
name|RETURN_OK
expr_stmt|;
if|if
condition|(
name|elf_version
argument_list|(
name|EV_CURRENT
argument_list|)
operator|==
name|EV_NONE
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"ELF library initialization failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"ABVdhotx"
argument_list|,
name|size_longopts
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
operator|(
name|char
operator|)
name|ch
condition|)
block|{
case|case
literal|'A'
case|:
name|style
operator|=
name|STYLE_SYSV
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|style
operator|=
name|STYLE_BERKELEY
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|show_version
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|radix
operator|=
name|RADIX_DECIMAL
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|radix
operator|=
name|RADIX_OCTAL
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|show_totals
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|radix
operator|=
name|RADIX_HEX
expr_stmt|;
break|break;
case|case
literal|0
case|:
switch|switch
condition|(
name|size_option
condition|)
block|{
case|case
name|OPT_FORMAT
case|:
if|if
condition|(
operator|*
name|optarg
operator|==
literal|'s'
operator|||
operator|*
name|optarg
operator|==
literal|'S'
condition|)
name|style
operator|=
name|STYLE_SYSV
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|optarg
operator|==
literal|'b'
operator|||
operator|*
name|optarg
operator|==
literal|'B'
condition|)
name|style
operator|=
name|STYLE_BERKELEY
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"unrecognized format \"%s\"."
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|OPT_RADIX
case|:
name|r
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|8
condition|)
name|radix
operator|=
name|RADIX_OCTAL
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|==
literal|10
condition|)
name|radix
operator|=
name|RADIX_DECIMAL
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|==
literal|16
condition|)
name|radix
operator|=
name|RADIX_HEX
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"unsupported radix \"%s\"."
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"Error in option handling."
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
break|break;
case|case
literal|'h'
case|:
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
name|files
operator|=
operator|(
name|argc
operator|==
literal|0
operator|)
condition|?
name|default_args
else|:
operator|(
name|void
operator|*
operator|)
name|argv
expr_stmt|;
while|while
condition|(
operator|(
name|fn
operator|=
operator|*
name|files
operator|)
operator|!=
name|NULL
condition|)
block|{
name|rc
operator|=
name|handle_elf
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|RETURN_OK
condition|)
name|warnx
argument_list|(
name|rc
operator|==
name|RETURN_NOINPUT
condition|?
literal|"'%s': No such file"
else|:
literal|"%s: File format not recognized"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|files
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|style
operator|==
name|STYLE_BERKELEY
condition|)
block|{
if|if
condition|(
name|show_totals
condition|)
name|berkeley_totals
argument_list|()
expr_stmt|;
name|tbl_flush
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|Elf_Data
modifier|*
name|xlatetom
parameter_list|(
name|Elf
modifier|*
name|elf
parameter_list|,
name|GElf_Ehdr
modifier|*
name|elfhdr
parameter_list|,
name|void
modifier|*
name|_src
parameter_list|,
name|void
modifier|*
name|_dst
parameter_list|,
name|Elf_Type
name|type
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|Elf_Data
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|src
operator|.
name|d_buf
operator|=
name|_src
expr_stmt|;
name|src
operator|.
name|d_type
operator|=
name|type
expr_stmt|;
name|src
operator|.
name|d_version
operator|=
name|elfhdr
operator|->
name|e_version
expr_stmt|;
name|src
operator|.
name|d_size
operator|=
name|size
expr_stmt|;
name|dst
operator|.
name|d_buf
operator|=
name|_dst
expr_stmt|;
name|dst
operator|.
name|d_version
operator|=
name|elfhdr
operator|->
name|e_version
expr_stmt|;
name|dst
operator|.
name|d_size
operator|=
name|size
expr_stmt|;
return|return
operator|(
name|gelf_xlatetom
argument_list|(
name|elf
argument_list|,
operator|&
name|dst
argument_list|,
operator|&
name|src
argument_list|,
name|elfhdr
operator|->
name|e_ident
index|[
name|EI_DATA
index|]
argument_list|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NOTE_OFFSET_32
parameter_list|(
name|nhdr
parameter_list|,
name|namesz
parameter_list|,
name|offset
parameter_list|)
define|\
value|((char *)nhdr + sizeof(Elf32_Nhdr) +			\ 	    ELF_ALIGN((int32_t)namesz, 4) + offset)
end_define

begin_define
define|#
directive|define
name|NOTE_OFFSET_64
parameter_list|(
name|nhdr
parameter_list|,
name|namesz
parameter_list|,
name|offset
parameter_list|)
define|\
value|((char *)nhdr + sizeof(Elf32_Nhdr) +			\ 	    ELF_ALIGN((int32_t)namesz, 8) + offset)
end_define

begin_define
define|#
directive|define
name|PID32
parameter_list|(
name|nhdr
parameter_list|,
name|namesz
parameter_list|,
name|offset
parameter_list|)
define|\
value|(pid_t)*((int *)((uintptr_t)NOTE_OFFSET_32(nhdr,	\ 	    namesz, offset)));
end_define

begin_define
define|#
directive|define
name|PID64
parameter_list|(
name|nhdr
parameter_list|,
name|namesz
parameter_list|,
name|offset
parameter_list|)
define|\
value|(pid_t)*((int *)((uintptr_t)NOTE_OFFSET_64(nhdr,	\ 	    namesz, offset)));
end_define

begin_define
define|#
directive|define
name|NEXT_NOTE
parameter_list|(
name|elfhdr
parameter_list|,
name|descsz
parameter_list|,
name|namesz
parameter_list|,
name|offset
parameter_list|)
value|do {		\ 	if (elfhdr->e_ident[EI_CLASS] == ELFCLASS32) { 		\ 		offset += ELF_ALIGN((int32_t)descsz, 4) +	\ 		    sizeof(Elf32_Nhdr) + 			\ 			ELF_ALIGN((int32_t)namesz, 4); 		\ 	} else {						\ 		offset += ELF_ALIGN((int32_t)descsz, 8) + 	\ 		    sizeof(Elf32_Nhdr) + 			\ 		        ELF_ALIGN((int32_t)namesz, 8); 		\ 	}							\ } while (0)
end_define

begin_comment
comment|/*  * Parse individual note entries inside a PT_NOTE segment.  */
end_comment

begin_function
specifier|static
name|void
name|handle_core_note
parameter_list|(
name|Elf
modifier|*
name|elf
parameter_list|,
name|GElf_Ehdr
modifier|*
name|elfhdr
parameter_list|,
name|GElf_Phdr
modifier|*
name|phdr
parameter_list|,
name|char
modifier|*
modifier|*
name|cmd_line
parameter_list|)
block|{
name|size_t
name|max_size
decl_stmt|;
name|uint64_t
name|raw_size
decl_stmt|;
name|GElf_Off
name|offset
decl_stmt|;
specifier|static
name|pid_t
name|pid
decl_stmt|;
name|uintptr_t
name|ver
decl_stmt|;
name|Elf32_Nhdr
modifier|*
name|nhdr
decl_stmt|,
name|nhdr_l
decl_stmt|;
specifier|static
name|int
name|reg_pseudo
init|=
literal|0
decl_stmt|,
name|reg2_pseudo
init|=
literal|0
comment|/*, regxfp_pseudo = 0*/
decl_stmt|;
name|char
name|buf
index|[
name|BUF_SIZE
index|]
decl_stmt|,
modifier|*
name|data
decl_stmt|,
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|elf
operator|==
name|NULL
operator|||
name|elfhdr
operator|==
name|NULL
operator|||
name|phdr
operator|==
name|NULL
condition|)
return|return;
name|data
operator|=
name|elf_rawfile
argument_list|(
name|elf
argument_list|,
operator|&
name|max_size
argument_list|)
expr_stmt|;
name|offset
operator|=
name|phdr
operator|->
name|p_offset
expr_stmt|;
while|while
condition|(
name|data
operator|!=
name|NULL
operator|&&
name|offset
operator|<
name|phdr
operator|->
name|p_offset
operator|+
name|phdr
operator|->
name|p_filesz
condition|)
block|{
name|nhdr
operator|=
operator|(
name|Elf32_Nhdr
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|offset
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|nhdr_l
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_Nhdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xlatetom
argument_list|(
name|elf
argument_list|,
name|elfhdr
argument_list|,
operator|&
name|nhdr
operator|->
name|n_type
argument_list|,
operator|&
name|nhdr_l
operator|.
name|n_type
argument_list|,
name|ELF_T_WORD
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_Word
argument_list|)
argument_list|)
operator|||
operator|!
name|xlatetom
argument_list|(
name|elf
argument_list|,
name|elfhdr
argument_list|,
operator|&
name|nhdr
operator|->
name|n_descsz
argument_list|,
operator|&
name|nhdr_l
operator|.
name|n_descsz
argument_list|,
name|ELF_T_WORD
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_Word
argument_list|)
argument_list|)
operator|||
operator|!
name|xlatetom
argument_list|(
name|elf
argument_list|,
name|elfhdr
argument_list|,
operator|&
name|nhdr
operator|->
name|n_namesz
argument_list|,
operator|&
name|nhdr_l
operator|.
name|n_namesz
argument_list|,
name|ELF_T_WORD
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_Word
argument_list|)
argument_list|)
condition|)
break|break;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|nhdr
operator|+
sizeof|sizeof
argument_list|(
name|Elf32_Nhdr
argument_list|)
operator|)
expr_stmt|;
switch|switch
condition|(
name|nhdr_l
operator|.
name|n_type
condition|)
block|{
case|case
name|NT_PRSTATUS
case|:
block|{
name|raw_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|elfhdr
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|==
name|ELFOSABI_FREEBSD
operator|&&
name|nhdr_l
operator|.
name|n_namesz
operator|==
literal|0x8
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"FreeBSD"
argument_list|)
condition|)
block|{
if|if
condition|(
name|elfhdr
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|==
name|ELFCLASS32
condition|)
block|{
name|raw_size
operator|=
operator|(
name|uint64_t
operator|)
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|name
operator|+
name|ELF_ALIGN
argument_list|(
operator|(
name|int32_t
operator|)
name|nhdr_l
operator|.
name|n_namesz
argument_list|,
literal|4
argument_list|)
operator|+
literal|8
argument_list|)
operator|)
expr_stmt|;
name|ver
operator|=
operator|(
name|uintptr_t
operator|)
name|NOTE_OFFSET_32
argument_list|(
name|nhdr
argument_list|,
name|nhdr_l
operator|.
name|n_namesz
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|ver
operator|)
operator|==
literal|1
condition|)
name|pid
operator|=
name|PID32
argument_list|(
name|nhdr
argument_list|,
name|nhdr_l
operator|.
name|n_namesz
argument_list|,
literal|24
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|raw_size
operator|=
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|name
operator|+
name|ELF_ALIGN
argument_list|(
operator|(
name|int32_t
operator|)
name|nhdr_l
operator|.
name|n_namesz
argument_list|,
literal|8
argument_list|)
operator|+
literal|16
argument_list|)
operator|)
expr_stmt|;
name|ver
operator|=
operator|(
name|uintptr_t
operator|)
name|NOTE_OFFSET_64
argument_list|(
name|nhdr
argument_list|,
name|nhdr_l
operator|.
name|n_namesz
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|ver
operator|)
operator|==
literal|1
condition|)
name|pid
operator|=
name|PID64
argument_list|(
name|nhdr
argument_list|,
name|nhdr_l
operator|.
name|n_namesz
argument_list|,
literal|40
argument_list|)
expr_stmt|;
block|}
name|xlatetom
argument_list|(
name|elf
argument_list|,
name|elfhdr
argument_list|,
operator|&
name|raw_size
argument_list|,
operator|&
name|raw_size
argument_list|,
name|ELF_T_WORD
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|xlatetom
argument_list|(
name|elf
argument_list|,
name|elfhdr
argument_list|,
operator|&
name|pid
argument_list|,
operator|&
name|pid
argument_list|,
name|ELF_T_WORD
argument_list|,
sizeof|sizeof
argument_list|(
name|pid_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|raw_size
operator|!=
literal|0
operator|&&
name|style
operator|==
name|STYLE_SYSV
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|BUF_SIZE
argument_list|,
literal|"%s/%d"
argument_list|,
literal|".reg"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|tbl_append
argument_list|()
expr_stmt|;
name|tbl_print
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tbl_print_num
argument_list|(
name|raw_size
argument_list|,
name|radix
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tbl_print_num
argument_list|(
literal|0
argument_list|,
name|radix
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reg_pseudo
condition|)
block|{
name|tbl_append
argument_list|()
expr_stmt|;
name|tbl_print
argument_list|(
literal|".reg"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tbl_print_num
argument_list|(
name|raw_size
argument_list|,
name|radix
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tbl_print_num
argument_list|(
literal|0
argument_list|,
name|radix
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|reg_pseudo
operator|=
literal|1
expr_stmt|;
name|text_size_total
operator|+=
name|raw_size
expr_stmt|;
block|}
name|text_size_total
operator|+=
name|raw_size
expr_stmt|;
block|}
block|}
break|break;
case|case
name|NT_FPREGSET
case|:
comment|/* same as NT_PRFPREG */
if|if
condition|(
name|style
operator|==
name|STYLE_SYSV
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|BUF_SIZE
argument_list|,
literal|"%s/%d"
argument_list|,
literal|".reg2"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|tbl_append
argument_list|()
expr_stmt|;
name|tbl_print
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tbl_print_num
argument_list|(
name|nhdr_l
operator|.
name|n_descsz
argument_list|,
name|radix
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tbl_print_num
argument_list|(
literal|0
argument_list|,
name|radix
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reg2_pseudo
condition|)
block|{
name|tbl_append
argument_list|()
expr_stmt|;
name|tbl_print
argument_list|(
literal|".reg2"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tbl_print_num
argument_list|(
name|nhdr_l
operator|.
name|n_descsz
argument_list|,
name|radix
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tbl_print_num
argument_list|(
literal|0
argument_list|,
name|radix
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|reg2_pseudo
operator|=
literal|1
expr_stmt|;
name|text_size_total
operator|+=
name|nhdr_l
operator|.
name|n_descsz
expr_stmt|;
block|}
name|text_size_total
operator|+=
name|nhdr_l
operator|.
name|n_descsz
expr_stmt|;
block|}
break|break;
if|#
directive|if
literal|0
block|case NT_AUXV: 			if (style == STYLE_SYSV) { 				tbl_append(); 				tbl_print(".auxv", 0); 				tbl_print_num(nhdr_l.n_descsz, radix, 1); 				tbl_print_num(0, radix, 2); 				text_size_total += nhdr_l.n_descsz; 			} 			break; 		case NT_PRXFPREG: 			if (style == STYLE_SYSV) { 				(void) snprintf(buf, BUF_SIZE, "%s/%d", 				    ".reg-xfp", pid); 				tbl_append(); 				tbl_print(buf, 0); 				tbl_print_num(nhdr_l.n_descsz, radix, 1); 				tbl_print_num(0, radix, 2); 				if (!regxfp_pseudo) { 					tbl_append(); 					tbl_print(".reg-xfp", 0); 					tbl_print_num(nhdr_l.n_descsz, radix, 					    1); 					tbl_print_num(0, radix, 2); 					regxfp_pseudo = 1; 					text_size_total += nhdr_l.n_descsz; 				} 				text_size_total += nhdr_l.n_descsz; 			} 			break; 		case NT_PSINFO:
endif|#
directive|endif
case|case
name|NT_PRPSINFO
case|:
block|{
comment|/* FreeBSD 64-bit */
if|if
condition|(
name|nhdr_l
operator|.
name|n_descsz
operator|==
literal|0x78
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"FreeBSD"
argument_list|)
condition|)
block|{
operator|*
name|cmd_line
operator|=
name|strdup
argument_list|(
name|NOTE_OFFSET_64
argument_list|(
name|nhdr
argument_list|,
name|nhdr_l
operator|.
name|n_namesz
argument_list|,
literal|33
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FreeBSD 32-bit */
block|}
elseif|else
if|if
condition|(
name|nhdr_l
operator|.
name|n_descsz
operator|==
literal|0x6c
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"FreeBSD"
argument_list|)
condition|)
block|{
operator|*
name|cmd_line
operator|=
name|strdup
argument_list|(
name|NOTE_OFFSET_32
argument_list|(
name|nhdr
argument_list|,
name|nhdr_l
operator|.
name|n_namesz
argument_list|,
literal|25
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Strip any trailing spaces */
if|if
condition|(
operator|*
name|cmd_line
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
operator|*
name|cmd_line
operator|+
name|strlen
argument_list|(
operator|*
name|cmd_line
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|>
operator|*
name|cmd_line
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|!=
literal|0x20
condition|)
break|break;
name|s
operator|--
expr_stmt|;
block|}
operator|*
name|s
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
if|#
directive|if
literal|0
block|case NT_PSTATUS: 		case NT_LWPSTATUS:
endif|#
directive|endif
default|default:
break|break;
block|}
name|NEXT_NOTE
argument_list|(
name|elfhdr
argument_list|,
name|nhdr_l
operator|.
name|n_descsz
argument_list|,
name|nhdr_l
operator|.
name|n_namesz
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handles program headers except for PT_NOTE, when sysv output stlye is  * choosen, prints out the segment name and length. For berkely output  * style only PT_LOAD segments are handled, and text,  * data, bss size is calculated for them.  */
end_comment

begin_function
specifier|static
name|void
name|handle_phdr
parameter_list|(
name|Elf
modifier|*
name|elf
parameter_list|,
name|GElf_Ehdr
modifier|*
name|elfhdr
parameter_list|,
name|GElf_Phdr
modifier|*
name|phdr
parameter_list|,
name|uint32_t
name|idx
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|uint64_t
name|addr
decl_stmt|,
name|size
decl_stmt|;
name|int
name|split
decl_stmt|;
name|char
name|buf
index|[
name|BUF_SIZE
index|]
decl_stmt|;
if|if
condition|(
name|elf
operator|==
name|NULL
operator|||
name|elfhdr
operator|==
name|NULL
operator|||
name|phdr
operator|==
name|NULL
condition|)
return|return;
name|size
operator|=
name|addr
operator|=
literal|0
expr_stmt|;
name|split
operator|=
operator|(
name|phdr
operator|->
name|p_memsz
operator|>
literal|0
operator|)
operator|&&
operator|(
name|phdr
operator|->
name|p_filesz
operator|>
literal|0
operator|)
operator|&&
operator|(
name|phdr
operator|->
name|p_memsz
operator|>
name|phdr
operator|->
name|p_filesz
operator|)
expr_stmt|;
if|if
condition|(
name|style
operator|==
name|STYLE_SYSV
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|BUF_SIZE
argument_list|,
literal|"%s%d%s"
argument_list|,
name|name
argument_list|,
name|idx
argument_list|,
operator|(
name|split
condition|?
literal|"a"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|tbl_append
argument_list|()
expr_stmt|;
name|tbl_print
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tbl_print_num
argument_list|(
name|phdr
operator|->
name|p_filesz
argument_list|,
name|radix
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tbl_print_num
argument_list|(
name|phdr
operator|->
name|p_vaddr
argument_list|,
name|radix
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|text_size_total
operator|+=
name|phdr
operator|->
name|p_filesz
expr_stmt|;
if|if
condition|(
name|split
condition|)
block|{
name|size
operator|=
name|phdr
operator|->
name|p_memsz
operator|-
name|phdr
operator|->
name|p_filesz
expr_stmt|;
name|addr
operator|=
name|phdr
operator|->
name|p_vaddr
operator|+
name|phdr
operator|->
name|p_filesz
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|BUF_SIZE
argument_list|,
literal|"%s%d%s"
argument_list|,
name|name
argument_list|,
name|idx
argument_list|,
literal|"b"
argument_list|)
expr_stmt|;
name|text_size_total
operator|+=
name|phdr
operator|->
name|p_memsz
operator|-
name|phdr
operator|->
name|p_filesz
expr_stmt|;
name|tbl_append
argument_list|()
expr_stmt|;
name|tbl_print
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tbl_print_num
argument_list|(
name|size
argument_list|,
name|radix
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tbl_print_num
argument_list|(
name|addr
argument_list|,
name|radix
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|phdr
operator|->
name|p_type
operator|!=
name|PT_LOAD
condition|)
return|return;
if|if
condition|(
operator|(
name|phdr
operator|->
name|p_flags
operator|&
name|PF_W
operator|)
operator|&&
operator|!
operator|(
name|phdr
operator|->
name|p_flags
operator|&
name|PF_X
operator|)
condition|)
block|{
name|data_size
operator|+=
name|phdr
operator|->
name|p_filesz
expr_stmt|;
if|if
condition|(
name|split
condition|)
name|data_size
operator|+=
name|phdr
operator|->
name|p_memsz
operator|-
name|phdr
operator|->
name|p_filesz
expr_stmt|;
block|}
else|else
block|{
name|text_size
operator|+=
name|phdr
operator|->
name|p_filesz
expr_stmt|;
if|if
condition|(
name|split
condition|)
name|text_size
operator|+=
name|phdr
operator|->
name|p_memsz
operator|-
name|phdr
operator|->
name|p_filesz
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Given a core dump file, this function maps program headers to segments.  */
end_comment

begin_function
specifier|static
name|int
name|handle_core
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|,
name|Elf
modifier|*
name|elf
parameter_list|,
name|GElf_Ehdr
modifier|*
name|elfhdr
parameter_list|)
block|{
name|GElf_Phdr
name|phdr
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|char
modifier|*
name|core_cmdline
decl_stmt|;
specifier|const
name|char
modifier|*
name|seg_name
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
name|elf
operator|==
name|NULL
operator|||
name|elfhdr
operator|==
name|NULL
condition|)
return|return
operator|(
name|RETURN_DATAERR
operator|)
return|;
if|if
condition|(
name|elfhdr
operator|->
name|e_shnum
operator|!=
literal|0
operator|||
name|elfhdr
operator|->
name|e_type
operator|!=
name|ET_CORE
condition|)
return|return
operator|(
name|RETURN_DATAERR
operator|)
return|;
name|seg_name
operator|=
name|core_cmdline
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|style
operator|==
name|STYLE_SYSV
condition|)
name|sysv_header
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|berkeley_header
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|elfhdr
operator|->
name|e_phnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|gelf_getphdr
argument_list|(
name|elf
argument_list|,
name|i
argument_list|,
operator|&
name|phdr
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|phdr
operator|.
name|p_type
operator|==
name|PT_NOTE
condition|)
block|{
name|handle_phdr
argument_list|(
name|elf
argument_list|,
name|elfhdr
argument_list|,
operator|&
name|phdr
argument_list|,
name|i
argument_list|,
literal|"note"
argument_list|)
expr_stmt|;
name|handle_core_note
argument_list|(
name|elf
argument_list|,
name|elfhdr
argument_list|,
operator|&
name|phdr
argument_list|,
operator|&
name|core_cmdline
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|phdr
operator|.
name|p_type
condition|)
block|{
case|case
name|PT_NULL
case|:
name|seg_name
operator|=
literal|"null"
expr_stmt|;
break|break;
case|case
name|PT_LOAD
case|:
name|seg_name
operator|=
literal|"load"
expr_stmt|;
break|break;
case|case
name|PT_DYNAMIC
case|:
name|seg_name
operator|=
literal|"dynamic"
expr_stmt|;
break|break;
case|case
name|PT_INTERP
case|:
name|seg_name
operator|=
literal|"interp"
expr_stmt|;
break|break;
case|case
name|PT_SHLIB
case|:
name|seg_name
operator|=
literal|"shlib"
expr_stmt|;
break|break;
case|case
name|PT_PHDR
case|:
name|seg_name
operator|=
literal|"phdr"
expr_stmt|;
break|break;
case|case
name|PT_GNU_EH_FRAME
case|:
name|seg_name
operator|=
literal|"eh_frame_hdr"
expr_stmt|;
break|break;
case|case
name|PT_GNU_STACK
case|:
name|seg_name
operator|=
literal|"stack"
expr_stmt|;
break|break;
default|default:
name|seg_name
operator|=
literal|"segment"
expr_stmt|;
block|}
name|handle_phdr
argument_list|(
name|elf
argument_list|,
name|elfhdr
argument_list|,
operator|&
name|phdr
argument_list|,
name|i
argument_list|,
name|seg_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|style
operator|==
name|STYLE_BERKELEY
condition|)
block|{
if|if
condition|(
name|core_cmdline
operator|!=
name|NULL
condition|)
block|{
name|berkeley_footer
argument_list|(
name|core_cmdline
argument_list|,
name|name
argument_list|,
literal|"core file invoked as"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|berkeley_footer
argument_list|(
name|core_cmdline
argument_list|,
name|name
argument_list|,
literal|"core file"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sysv_footer
argument_list|()
expr_stmt|;
if|if
condition|(
name|core_cmdline
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" (core file invoked as %s)\n\n"
argument_list|,
name|core_cmdline
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" (core file)\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|core_cmdline
argument_list|)
expr_stmt|;
return|return
operator|(
name|RETURN_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given an elf object,ar(1) filename, and based on the output style  * and radix format the various sections and their length will be printed  * or the size of the text, data, bss sections will be printed out.  */
end_comment

begin_function
specifier|static
name|int
name|handle_elf
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|GElf_Ehdr
name|elfhdr
decl_stmt|;
name|GElf_Shdr
name|shdr
decl_stmt|;
name|Elf
modifier|*
name|elf
decl_stmt|,
modifier|*
name|elf1
decl_stmt|;
name|Elf_Arhdr
modifier|*
name|arhdr
decl_stmt|;
name|Elf_Scn
modifier|*
name|scn
decl_stmt|;
name|Elf_Cmd
name|elf_cmd
decl_stmt|;
name|int
name|exit_code
decl_stmt|,
name|fd
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
operator|(
name|RETURN_NOINPUT
operator|)
return|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|RETURN_NOINPUT
operator|)
return|;
name|elf_cmd
operator|=
name|ELF_C_READ
expr_stmt|;
name|elf1
operator|=
name|elf_begin
argument_list|(
name|fd
argument_list|,
name|elf_cmd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|elf
operator|=
name|elf_begin
argument_list|(
name|fd
argument_list|,
name|elf_cmd
argument_list|,
name|elf1
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|arhdr
operator|=
name|elf_getarhdr
argument_list|(
name|elf
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_kind
argument_list|(
name|elf
argument_list|)
operator|==
name|ELF_K_NONE
operator|&&
name|arhdr
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|elf_end
argument_list|(
name|elf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_end
argument_list|(
name|elf1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|RETURN_DATAERR
operator|)
return|;
block|}
if|if
condition|(
name|elf_kind
argument_list|(
name|elf
argument_list|)
operator|!=
name|ELF_K_ELF
operator|||
operator|(
name|gelf_getehdr
argument_list|(
name|elf
argument_list|,
operator|&
name|elfhdr
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|elf_cmd
operator|=
name|elf_next
argument_list|(
name|elf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_end
argument_list|(
name|elf
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"%s: File format not recognized"
argument_list|,
name|arhdr
operator|->
name|ar_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Core dumps are handled seperately */
if|if
condition|(
name|elfhdr
operator|.
name|e_shnum
operator|==
literal|0
operator|&&
name|elfhdr
operator|.
name|e_type
operator|==
name|ET_CORE
condition|)
block|{
name|exit_code
operator|=
name|handle_core
argument_list|(
name|name
argument_list|,
name|elf
argument_list|,
operator|&
name|elfhdr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_end
argument_list|(
name|elf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_end
argument_list|(
name|elf1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|exit_code
operator|)
return|;
block|}
else|else
block|{
name|scn
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|style
operator|==
name|STYLE_BERKELEY
condition|)
block|{
name|berkeley_header
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|scn
operator|=
name|elf_nextscn
argument_list|(
name|elf
argument_list|,
name|scn
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|scn
argument_list|,
operator|&
name|shdr
argument_list|)
operator|!=
name|NULL
condition|)
name|berkeley_calc
argument_list|(
operator|&
name|shdr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sysv_header
argument_list|(
name|name
argument_list|,
name|arhdr
argument_list|)
expr_stmt|;
name|scn
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|scn
operator|=
name|elf_nextscn
argument_list|(
name|elf
argument_list|,
name|scn
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|scn
argument_list|,
operator|&
name|shdr
argument_list|)
operator|!=
name|NULL
condition|)
name|sysv_calc
argument_list|(
name|elf
argument_list|,
operator|&
name|elfhdr
argument_list|,
operator|&
name|shdr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|style
operator|==
name|STYLE_BERKELEY
condition|)
block|{
if|if
condition|(
name|arhdr
operator|!=
name|NULL
condition|)
block|{
name|berkeley_footer
argument_list|(
name|name
argument_list|,
name|arhdr
operator|->
name|ar_name
argument_list|,
literal|"ex"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|berkeley_footer
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
literal|"ex"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sysv_footer
argument_list|()
expr_stmt|;
block|}
block|}
name|elf_cmd
operator|=
name|elf_next
argument_list|(
name|elf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_end
argument_list|(
name|elf
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|elf_end
argument_list|(
name|elf1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|RETURN_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sysv formatting helper functions.  */
end_comment

begin_function
specifier|static
name|void
name|sysv_header
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|Elf_Arhdr
modifier|*
name|arhdr
parameter_list|)
block|{
name|text_size_total
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arhdr
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s   (ex %s):\n"
argument_list|,
name|arhdr
operator|->
name|ar_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s  :\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|tbl_new
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|tbl_append
argument_list|()
expr_stmt|;
name|tbl_print
argument_list|(
literal|"section"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tbl_print
argument_list|(
literal|"size"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tbl_print
argument_list|(
literal|"addr"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sysv_calc
parameter_list|(
name|Elf
modifier|*
name|elf
parameter_list|,
name|GElf_Ehdr
modifier|*
name|elfhdr
parameter_list|,
name|GElf_Shdr
modifier|*
name|shdr
parameter_list|)
block|{
name|char
modifier|*
name|section_name
decl_stmt|;
name|section_name
operator|=
name|elf_strptr
argument_list|(
name|elf
argument_list|,
name|elfhdr
operator|->
name|e_shstrndx
argument_list|,
operator|(
name|size_t
operator|)
name|shdr
operator|->
name|sh_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|shdr
operator|->
name|sh_type
operator|==
name|SHT_SYMTAB
operator|||
name|shdr
operator|->
name|sh_type
operator|==
name|SHT_STRTAB
operator|||
name|shdr
operator|->
name|sh_type
operator|==
name|SHT_RELA
operator|||
name|shdr
operator|->
name|sh_type
operator|==
name|SHT_REL
operator|)
operator|&&
name|shdr
operator|->
name|sh_addr
operator|==
literal|0
condition|)
return|return;
name|tbl_append
argument_list|()
expr_stmt|;
name|tbl_print
argument_list|(
name|section_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tbl_print_num
argument_list|(
name|shdr
operator|->
name|sh_size
argument_list|,
name|radix
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tbl_print_num
argument_list|(
name|shdr
operator|->
name|sh_addr
argument_list|,
name|radix
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|text_size_total
operator|+=
name|shdr
operator|->
name|sh_size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sysv_footer
parameter_list|(
name|void
parameter_list|)
block|{
name|tbl_append
argument_list|()
expr_stmt|;
name|tbl_print
argument_list|(
literal|"Total"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tbl_print_num
argument_list|(
name|text_size_total
argument_list|,
name|radix
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tbl_flush
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * berkeley style output formatting helper functions.  */
end_comment

begin_function
specifier|static
name|void
name|berkeley_header
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|printed
decl_stmt|;
name|text_size
operator|=
name|data_size
operator|=
name|bss_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|printed
condition|)
block|{
name|tbl_new
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|tbl_append
argument_list|()
expr_stmt|;
name|tbl_print
argument_list|(
literal|"text"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tbl_print
argument_list|(
literal|"data"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tbl_print
argument_list|(
literal|"bss"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|radix
operator|==
name|RADIX_OCTAL
condition|)
name|tbl_print
argument_list|(
literal|"oct"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
else|else
name|tbl_print
argument_list|(
literal|"dec"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|tbl_print
argument_list|(
literal|"hex"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tbl_print
argument_list|(
literal|"filename"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|printed
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|berkeley_calc
parameter_list|(
name|GElf_Shdr
modifier|*
name|shdr
parameter_list|)
block|{
if|if
condition|(
name|shdr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|shdr
operator|->
name|sh_flags
operator|&
name|SHF_ALLOC
operator|)
condition|)
return|return;
if|if
condition|(
operator|(
name|shdr
operator|->
name|sh_flags
operator|&
name|SHF_ALLOC
operator|)
operator|&&
operator|(
operator|(
name|shdr
operator|->
name|sh_flags
operator|&
name|SHF_EXECINSTR
operator|)
operator|||
operator|!
operator|(
name|shdr
operator|->
name|sh_flags
operator|&
name|SHF_WRITE
operator|)
operator|)
condition|)
name|text_size
operator|+=
name|shdr
operator|->
name|sh_size
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|shdr
operator|->
name|sh_flags
operator|&
name|SHF_ALLOC
operator|)
operator|&&
operator|(
name|shdr
operator|->
name|sh_flags
operator|&
name|SHF_WRITE
operator|)
operator|&&
operator|(
name|shdr
operator|->
name|sh_type
operator|!=
name|SHT_NOBITS
operator|)
condition|)
name|data_size
operator|+=
name|shdr
operator|->
name|sh_size
expr_stmt|;
else|else
name|bss_size
operator|+=
name|shdr
operator|->
name|sh_size
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|berkeley_totals
parameter_list|(
name|void
parameter_list|)
block|{
name|long
name|unsigned
name|int
name|grand_total
decl_stmt|;
name|grand_total
operator|=
name|text_size_total
operator|+
name|data_size_total
operator|+
name|bss_size_total
expr_stmt|;
name|tbl_append
argument_list|()
expr_stmt|;
name|tbl_print_num
argument_list|(
name|text_size_total
argument_list|,
name|radix
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tbl_print_num
argument_list|(
name|data_size_total
argument_list|,
name|radix
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tbl_print_num
argument_list|(
name|bss_size_total
argument_list|,
name|radix
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|radix
operator|==
name|RADIX_OCTAL
condition|)
name|tbl_print_num
argument_list|(
name|grand_total
argument_list|,
name|RADIX_OCTAL
argument_list|,
literal|3
argument_list|)
expr_stmt|;
else|else
name|tbl_print_num
argument_list|(
name|grand_total
argument_list|,
name|RADIX_DECIMAL
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|tbl_print_num
argument_list|(
name|grand_total
argument_list|,
name|RADIX_HEX
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|berkeley_footer
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|ar_name
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|char
name|buf
index|[
name|BUF_SIZE
index|]
decl_stmt|;
name|total_size
operator|=
name|text_size
operator|+
name|data_size
operator|+
name|bss_size
expr_stmt|;
if|if
condition|(
name|show_totals
condition|)
block|{
name|text_size_total
operator|+=
name|text_size
expr_stmt|;
name|bss_size_total
operator|+=
name|bss_size
expr_stmt|;
name|data_size_total
operator|+=
name|data_size
expr_stmt|;
block|}
name|tbl_append
argument_list|()
expr_stmt|;
name|tbl_print_num
argument_list|(
name|text_size
argument_list|,
name|radix
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tbl_print_num
argument_list|(
name|data_size
argument_list|,
name|radix
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tbl_print_num
argument_list|(
name|bss_size
argument_list|,
name|radix
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|radix
operator|==
name|RADIX_OCTAL
condition|)
name|tbl_print_num
argument_list|(
name|total_size
argument_list|,
name|RADIX_OCTAL
argument_list|,
literal|3
argument_list|)
expr_stmt|;
else|else
name|tbl_print_num
argument_list|(
name|total_size
argument_list|,
name|RADIX_DECIMAL
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|tbl_print_num
argument_list|(
name|total_size
argument_list|,
name|RADIX_HEX
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar_name
operator|!=
name|NULL
operator|&&
name|name
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|BUF_SIZE
argument_list|,
literal|"%s (%s %s)"
argument_list|,
name|ar_name
argument_list|,
name|msg
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ar_name
operator|!=
name|NULL
operator|&&
name|name
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|BUF_SIZE
argument_list|,
literal|"%s (%s)"
argument_list|,
name|ar_name
argument_list|,
name|msg
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|BUF_SIZE
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|tbl_print
argument_list|(
name|buf
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tbl_new
parameter_list|(
name|int
name|col
parameter_list|)
block|{
name|assert
argument_list|(
name|tb
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|col
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tb
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tb
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tb
operator|->
name|tbl
operator|=
name|calloc
argument_list|(
name|col
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tb
operator|->
name|tbl
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tb
operator|->
name|width
operator|=
name|calloc
argument_list|(
name|col
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tb
operator|->
name|width
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|tb
operator|->
name|col
operator|=
name|col
expr_stmt|;
name|tb
operator|->
name|row
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tbl_print
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|col
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|assert
argument_list|(
name|tb
operator|!=
name|NULL
operator|&&
name|tb
operator|->
name|col
operator|>
literal|0
operator|&&
name|tb
operator|->
name|row
operator|>
literal|0
operator|&&
name|col
operator|<
name|tb
operator|->
name|col
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|s
operator|!=
name|NULL
operator|&&
name|tb
operator|->
name|tbl
index|[
name|col
index|]
index|[
name|tb
operator|->
name|row
operator|-
literal|1
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tb
operator|->
name|tbl
index|[
name|col
index|]
index|[
name|tb
operator|->
name|row
operator|-
literal|1
index|]
operator|=
name|strdup
argument_list|(
name|s
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|tb
operator|->
name|width
index|[
name|col
index|]
condition|)
name|tb
operator|->
name|width
index|[
name|col
index|]
operator|=
name|len
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tbl_print_num
parameter_list|(
name|uint64_t
name|num
parameter_list|,
name|enum
name|radix_style
name|rad
parameter_list|,
name|int
name|col
parameter_list|)
block|{
name|char
name|buf
index|[
name|BUF_SIZE
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|BUF_SIZE
argument_list|,
operator|(
name|rad
operator|==
name|RADIX_DECIMAL
condition|?
literal|"%ju"
else|:
operator|(
operator|(
name|rad
operator|==
name|RADIX_OCTAL
operator|)
condition|?
literal|"0%jo"
else|:
literal|"0x%jx"
operator|)
operator|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|num
argument_list|)
expr_stmt|;
name|tbl_print
argument_list|(
name|buf
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tbl_append
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|assert
argument_list|(
name|tb
operator|!=
name|NULL
operator|&&
name|tb
operator|->
name|col
operator|>
literal|0
argument_list|)
expr_stmt|;
name|tb
operator|->
name|row
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tb
operator|->
name|col
condition|;
name|i
operator|++
control|)
block|{
name|tb
operator|->
name|tbl
index|[
name|i
index|]
operator|=
name|realloc
argument_list|(
name|tb
operator|->
name|tbl
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tb
operator|->
name|tbl
index|[
name|i
index|]
argument_list|)
operator|*
name|tb
operator|->
name|row
argument_list|)
expr_stmt|;
if|if
condition|(
name|tb
operator|->
name|tbl
index|[
name|i
index|]
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"realloc"
argument_list|)
expr_stmt|;
name|tb
operator|->
name|tbl
index|[
name|i
index|]
index|[
name|tb
operator|->
name|row
operator|-
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|tbl_flush
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|tb
operator|==
name|NULL
condition|)
return|return;
name|assert
argument_list|(
name|tb
operator|->
name|col
operator|>
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tb
operator|->
name|row
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|style
operator|==
name|STYLE_BERKELEY
condition|)
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|tb
operator|->
name|col
condition|;
name|j
operator|++
control|)
block|{
name|str
operator|=
operator|(
name|tb
operator|->
name|tbl
index|[
name|j
index|]
index|[
name|i
index|]
operator|!=
name|NULL
condition|?
name|tb
operator|->
name|tbl
index|[
name|j
index|]
index|[
name|i
index|]
else|:
literal|""
operator|)
expr_stmt|;
if|if
condition|(
name|style
operator|==
name|STYLE_SYSV
operator|&&
name|j
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%-*s"
argument_list|,
name|tb
operator|->
name|width
index|[
name|j
index|]
argument_list|,
name|str
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|style
operator|==
name|STYLE_BERKELEY
operator|&&
name|j
operator|==
name|tb
operator|->
name|col
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%*s"
argument_list|,
name|tb
operator|->
name|width
index|[
name|j
index|]
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|tb
operator|->
name|col
operator|-
literal|1
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"   "
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tb
operator|->
name|col
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|tb
operator|->
name|row
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|tb
operator|->
name|tbl
index|[
name|i
index|]
index|[
name|j
index|]
condition|)
name|free
argument_list|(
name|tb
operator|->
name|tbl
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|tb
operator|->
name|tbl
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|tb
operator|->
name|tbl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tb
operator|->
name|width
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tb
argument_list|)
expr_stmt|;
name|tb
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|USAGE_MESSAGE
value|"\ Usage: %s [options] file ...\n\   Display sizes of ELF sections.\n\n\   Options:\n\   --format=format    Display output in specified format.  Supported\n\                      values are `berkeley' and `sysv'.\n\   --help             Display this help message and exit.\n\   --radix=radix      Display numeric values in the specified radix.\n\                      Supported values are: 8, 10 and 16.\n\   --totals           Show cumulative totals of section sizes.\n\   --version          Display a version identifier and exit.\n\   -A                 Equivalent to `--format=sysv'.\n\   -B                 Equivalent to `--format=berkeley'.\n\   -V                 Equivalent to `--version'.\n\   -d                 Equivalent to `--radix=10'.\n\   -h                 Same as option --help.\n\   -o                 Equivalent to `--radix=8'.\n\   -t                 Equivalent to option --totals.\n\   -x                 Equivalent to `--radix=16'.\n"
end_define

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|USAGE_MESSAGE
argument_list|,
name|ELFTC_GETPROGNAME
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_version
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s (%s)\n"
argument_list|,
name|ELFTC_GETPROGNAME
argument_list|()
argument_list|,
name|elftc_version
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

