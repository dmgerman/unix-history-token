begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007 Hyogeol Lee<hyogeollee@gmail.com>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ar.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<dwarf.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<gelf.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<libdwarf.h>
end_include

begin_include
include|#
directive|include
file|<libelftc.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"_elftc.h"
end_include

begin_expr_stmt
name|ELFTC_VCSID
argument_list|(
literal|"$Id: nm.c 3124 2014-12-21 05:46:28Z kaiwang27 $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* symbol information list */
end_comment

begin_expr_stmt
name|STAILQ_HEAD
argument_list|(
name|sym_head
argument_list|,
name|sym_entry
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|sym_entry
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|GElf_Sym
modifier|*
name|sym
decl_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|sym_entry
argument_list|)
name|sym_entries
expr_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|fn_sort
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|fn_elem_print
function_decl|)
parameter_list|(
name|char
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|GElf_Sym
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|fn_sym_print
function_decl|)
parameter_list|(
specifier|const
name|GElf_Sym
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|fn_filter
function_decl|)
parameter_list|(
name|char
parameter_list|,
specifier|const
name|GElf_Sym
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* output filter list */
end_comment

begin_expr_stmt
specifier|static
name|SLIST_HEAD
argument_list|(
argument|filter_head
argument_list|,
argument|filter_entry
argument_list|)
name|nm_out_filter
operator|=
name|SLIST_HEAD_INITIALIZER
argument_list|(
name|nm_out_filter
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|filter_entry
block|{
name|fn_filter
name|fn
decl_stmt|;
name|SLIST_ENTRY
argument_list|(
argument|filter_entry
argument_list|)
name|filter_entries
expr_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sym_print_data
block|{
name|struct
name|sym_head
modifier|*
name|headp
decl_stmt|;
name|size_t
name|sh_num
decl_stmt|,
name|list_num
decl_stmt|;
specifier|const
name|char
modifier|*
name|t_table
decl_stmt|,
modifier|*
modifier|*
name|s_table
decl_stmt|,
modifier|*
name|filename
decl_stmt|,
modifier|*
name|objname
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|nm_prog_info
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|def_filename
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* List for line number information. */
end_comment

begin_struct
struct|struct
name|line_info_entry
block|{
name|uint64_t
name|addr
decl_stmt|;
comment|/* address */
name|uint64_t
name|line
decl_stmt|;
comment|/* line number */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* file name with path */
name|SLIST_ENTRY
argument_list|(
argument|line_info_entry
argument_list|)
name|entries
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|SLIST_HEAD
argument_list|(
name|line_info_head
argument_list|,
name|line_info_entry
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* List for function line number information. */
end_comment

begin_struct
struct|struct
name|func_info_entry
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* function name */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* file name with path */
name|uint64_t
name|lowpc
decl_stmt|;
comment|/* low address */
name|uint64_t
name|highpc
decl_stmt|;
comment|/* high address */
name|uint64_t
name|line
decl_stmt|;
comment|/* line number */
name|SLIST_ENTRY
argument_list|(
argument|func_info_entry
argument_list|)
name|entries
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|SLIST_HEAD
argument_list|(
name|func_info_head
argument_list|,
name|func_info_entry
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* List for variable line number information. */
end_comment

begin_struct
struct|struct
name|var_info_entry
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* variable name */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* file name with path */
name|uint64_t
name|addr
decl_stmt|;
comment|/* address */
name|uint64_t
name|line
decl_stmt|;
comment|/* line number */
name|SLIST_ENTRY
argument_list|(
argument|var_info_entry
argument_list|)
name|entries
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|SLIST_HEAD
argument_list|(
name|var_info_head
argument_list|,
name|var_info_entry
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* output numric type */
end_comment

begin_enum
enum|enum
name|radix
block|{
name|RADIX_OCT
block|,
name|RADIX_HEX
block|,
name|RADIX_DEC
block|}
enum|;
end_enum

begin_comment
comment|/* output symbol type, PRINT_SYM_DYN for dynamic symbol only */
end_comment

begin_enum
enum|enum
name|print_symbol
block|{
name|PRINT_SYM_SYM
block|,
name|PRINT_SYM_DYN
block|}
enum|;
end_enum

begin_comment
comment|/* output name type */
end_comment

begin_enum
enum|enum
name|print_name
block|{
name|PRINT_NAME_NONE
block|,
name|PRINT_NAME_FULL
block|,
name|PRINT_NAME_MULTI
block|}
enum|;
end_enum

begin_struct
struct|struct
name|nm_prog_options
block|{
name|enum
name|print_symbol
name|print_symbol
decl_stmt|;
name|enum
name|print_name
name|print_name
decl_stmt|;
name|enum
name|radix
name|t
decl_stmt|;
name|int
name|demangle_type
decl_stmt|;
name|bool
name|print_debug
decl_stmt|;
name|bool
name|print_armap
decl_stmt|;
name|int
name|print_size
decl_stmt|;
name|bool
name|debug_line
decl_stmt|;
name|int
name|def_only
decl_stmt|;
name|bool
name|undef_only
decl_stmt|;
name|int
name|sort_size
decl_stmt|;
name|bool
name|sort_reverse
decl_stmt|;
name|int
name|no_demangle
decl_stmt|;
comment|/* 	 * function pointer to sort symbol list. 	 * possible function - cmp_name, cmp_none, cmp_size, cmp_value 	 */
name|fn_sort
name|sort_fn
decl_stmt|;
comment|/* 	 * function pointer to print symbol elem. 	 * possible function - sym_elem_print_all 	 *		       sym_elem_print_all_portable 	 *		       sym_elem_print_all_sysv 	 */
name|fn_elem_print
name|elem_print_fn
decl_stmt|;
name|fn_sym_print
name|value_print_fn
decl_stmt|;
name|fn_sym_print
name|size_print_fn
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|CHECK_SYM_PRINT_DATA
parameter_list|(
name|p
parameter_list|)
value|(p->headp == NULL || p->sh_num == 0 ||	      \ p->t_table == NULL || p->s_table == NULL || p->filename == NULL)
end_define

begin_define
define|#
directive|define
name|IS_SYM_TYPE
parameter_list|(
name|t
parameter_list|)
value|((t) == '?' || isalpha((t)) != 0)
end_define

begin_define
define|#
directive|define
name|IS_UNDEF_SYM_TYPE
parameter_list|(
name|t
parameter_list|)
value|((t) == 'U' || (t) == 'v' || (t) == 'w')
end_define

begin_define
define|#
directive|define
name|UNUSED
parameter_list|(
name|p
parameter_list|)
value|((void)p)
end_define

begin_function_decl
specifier|static
name|int
name|cmp_name
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cmp_none
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cmp_size
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cmp_value
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|filter_dest
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filter_insert
parameter_list|(
name|fn_filter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_opt
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_sym
parameter_list|(
name|Elf
modifier|*
parameter_list|,
name|struct
name|sym_head
modifier|*
parameter_list|,
name|int
parameter_list|,
name|size_t
parameter_list|,
name|size_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|get_sym_name
parameter_list|(
name|Elf
modifier|*
parameter_list|,
specifier|const
name|GElf_Sym
modifier|*
parameter_list|,
name|size_t
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
name|get_sym_type
parameter_list|(
specifier|const
name|GElf_Sym
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|global_dest
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|global_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|is_sec_data
parameter_list|(
name|GElf_Shdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|is_sec_debug
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|is_sec_nobits
parameter_list|(
name|GElf_Shdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|is_sec_readonly
parameter_list|(
name|GElf_Shdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|is_sec_text
parameter_list|(
name|GElf_Shdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_ar_index
parameter_list|(
name|int
parameter_list|,
name|Elf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_header
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_version
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_elf
parameter_list|(
name|Elf
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|Elf_Kind
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_object
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_files
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_opt_value_print_fn
parameter_list|(
name|enum
name|radix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_elem_def
parameter_list|(
name|char
parameter_list|,
specifier|const
name|GElf_Sym
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_elem_global
parameter_list|(
name|char
parameter_list|,
specifier|const
name|GElf_Sym
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_elem_global_static
parameter_list|(
name|char
parameter_list|,
specifier|const
name|GElf_Sym
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_elem_nondebug
parameter_list|(
name|char
parameter_list|,
specifier|const
name|GElf_Sym
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_elem_nonzero_size
parameter_list|(
name|char
parameter_list|,
specifier|const
name|GElf_Sym
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_elem_print_all
parameter_list|(
name|char
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|GElf_Sym
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_elem_print_all_portable
parameter_list|(
name|char
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|GElf_Sym
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_elem_print_all_sysv
parameter_list|(
name|char
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|GElf_Sym
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_elem_undef
parameter_list|(
name|char
parameter_list|,
specifier|const
name|GElf_Sym
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_list_dest
parameter_list|(
name|struct
name|sym_head
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_list_insert
parameter_list|(
name|struct
name|sym_head
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|GElf_Sym
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_list_print
parameter_list|(
name|struct
name|sym_print_data
modifier|*
parameter_list|,
name|struct
name|func_info_head
modifier|*
parameter_list|,
name|struct
name|var_info_head
modifier|*
parameter_list|,
name|struct
name|line_info_head
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_list_print_each
parameter_list|(
name|struct
name|sym_entry
modifier|*
parameter_list|,
name|struct
name|sym_print_data
modifier|*
parameter_list|,
name|struct
name|func_info_head
modifier|*
parameter_list|,
name|struct
name|var_info_head
modifier|*
parameter_list|,
name|struct
name|line_info_head
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|sym_entry
modifier|*
name|sym_list_sort
parameter_list|(
name|struct
name|sym_print_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_size_oct_print
parameter_list|(
specifier|const
name|GElf_Sym
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_size_hex_print
parameter_list|(
specifier|const
name|GElf_Sym
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_size_dec_print
parameter_list|(
specifier|const
name|GElf_Sym
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_value_oct_print
parameter_list|(
specifier|const
name|GElf_Sym
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_value_hex_print
parameter_list|(
specifier|const
name|GElf_Sym
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_value_dec_print
parameter_list|(
specifier|const
name|GElf_Sym
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|nm_prog_info
name|nm_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|nm_prog_options
name|nm_opts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nm_elfclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Point to current sym_print_data to use portable qsort function.  *  (e.g. There is no qsort_r function in NetBSD.)  *  * Using in sym_list_sort.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sym_print_data
modifier|*
name|nm_print_data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|option
name|nm_longopts
index|[]
init|=
block|{
block|{
literal|"debug-syms"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'a'
block|}
block|,
block|{
literal|"defined-only"
block|,
name|no_argument
block|,
operator|&
name|nm_opts
operator|.
name|def_only
block|,
literal|1
block|}
block|,
block|{
literal|"demangle"
block|,
name|optional_argument
block|,
name|NULL
block|,
literal|'C'
block|}
block|,
block|{
literal|"dynamic"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'D'
block|}
block|,
block|{
literal|"format"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'F'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'h'
block|}
block|,
block|{
literal|"line-numbers"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'l'
block|}
block|,
block|{
literal|"no-demangle"
block|,
name|no_argument
block|,
operator|&
name|nm_opts
operator|.
name|no_demangle
block|,
literal|1
block|}
block|,
block|{
literal|"no-sort"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'p'
block|}
block|,
block|{
literal|"numeric-sort"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'v'
block|}
block|,
block|{
literal|"print-armap"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
literal|"print-file-name"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'A'
block|}
block|,
block|{
literal|"print-size"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'S'
block|}
block|,
block|{
literal|"radix"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'t'
block|}
block|,
block|{
literal|"reverse-sort"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'r'
block|}
block|,
block|{
literal|"size-sort"
block|,
name|no_argument
block|,
operator|&
name|nm_opts
operator|.
name|sort_size
block|,
literal|1
block|}
block|,
block|{
literal|"undefined-only"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'u'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'V'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ELFTC_NEED_BYTEORDER_EXTENSIONS
argument_list|)
end_if

begin_function
specifier|static
name|__inline
name|uint32_t
name|be32dec
parameter_list|(
specifier|const
name|void
modifier|*
name|pp
parameter_list|)
block|{
name|unsigned
name|char
specifier|const
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
specifier|const
operator|*
operator|)
name|pp
decl_stmt|;
return|return
operator|(
operator|(
name|p
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|p
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|p
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|p
index|[
literal|3
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|le32dec
parameter_list|(
specifier|const
name|void
modifier|*
name|pp
parameter_list|)
block|{
name|unsigned
name|char
specifier|const
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
specifier|const
operator|*
operator|)
name|pp
decl_stmt|;
return|return
operator|(
operator|(
name|p
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|p
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|p
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|p
index|[
literal|0
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint64_t
name|be64dec
parameter_list|(
specifier|const
name|void
modifier|*
name|pp
parameter_list|)
block|{
name|unsigned
name|char
specifier|const
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
specifier|const
operator|*
operator|)
name|pp
decl_stmt|;
return|return
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|be32dec
argument_list|(
name|p
argument_list|)
operator|<<
literal|32
operator|)
operator||
name|be32dec
argument_list|(
name|p
operator|+
literal|4
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint64_t
name|le64dec
parameter_list|(
specifier|const
name|void
modifier|*
name|pp
parameter_list|)
block|{
name|unsigned
name|char
specifier|const
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
specifier|const
operator|*
operator|)
name|pp
decl_stmt|;
return|return
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|le32dec
argument_list|(
name|p
operator|+
literal|4
argument_list|)
operator|<<
literal|32
operator|)
operator||
name|le32dec
argument_list|(
name|p
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|cmp_name
parameter_list|(
specifier|const
name|void
modifier|*
name|l
parameter_list|,
specifier|const
name|void
modifier|*
name|r
parameter_list|)
block|{
name|assert
argument_list|(
name|l
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|r
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
operator|(
specifier|const
expr|struct
name|sym_entry
operator|*
operator|)
name|l
operator|)
operator|->
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
operator|(
specifier|const
expr|struct
name|sym_entry
operator|*
operator|)
name|r
operator|)
operator|->
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|strcmp
argument_list|(
operator|(
operator|(
specifier|const
expr|struct
name|sym_entry
operator|*
operator|)
name|l
operator|)
operator|->
name|name
argument_list|,
operator|(
operator|(
specifier|const
expr|struct
name|sym_entry
operator|*
operator|)
name|r
operator|)
operator|->
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmp_none
parameter_list|(
specifier|const
name|void
modifier|*
name|l
parameter_list|,
specifier|const
name|void
modifier|*
name|r
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Size comparison. If l and r have same size, compare their name. */
end_comment

begin_function
specifier|static
name|int
name|cmp_size
parameter_list|(
specifier|const
name|void
modifier|*
name|lp
parameter_list|,
specifier|const
name|void
modifier|*
name|rp
parameter_list|)
block|{
specifier|const
name|struct
name|sym_entry
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|l
operator|=
name|lp
expr_stmt|;
name|r
operator|=
name|rp
expr_stmt|;
name|assert
argument_list|(
name|l
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|l
operator|->
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|l
operator|->
name|sym
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|r
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|r
operator|->
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|r
operator|->
name|sym
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|sym
operator|->
name|st_size
operator|==
name|r
operator|->
name|sym
operator|->
name|st_size
condition|)
return|return
operator|(
name|strcmp
argument_list|(
name|l
operator|->
name|name
argument_list|,
name|r
operator|->
name|name
argument_list|)
operator|)
return|;
return|return
operator|(
name|l
operator|->
name|sym
operator|->
name|st_size
operator|-
name|r
operator|->
name|sym
operator|->
name|st_size
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Value comparison. Undefined symbols come first. */
end_comment

begin_function
specifier|static
name|int
name|cmp_value
parameter_list|(
specifier|const
name|void
modifier|*
name|lp
parameter_list|,
specifier|const
name|void
modifier|*
name|rp
parameter_list|)
block|{
specifier|const
name|struct
name|sym_entry
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|ttable
decl_stmt|;
name|int
name|l_is_undef
decl_stmt|,
name|r_is_undef
decl_stmt|;
name|l
operator|=
name|lp
expr_stmt|;
name|r
operator|=
name|rp
expr_stmt|;
name|assert
argument_list|(
name|nm_print_data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ttable
operator|=
name|nm_print_data
operator|->
name|t_table
expr_stmt|;
name|assert
argument_list|(
name|l
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|l
operator|->
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|l
operator|->
name|sym
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|r
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|r
operator|->
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|r
operator|->
name|sym
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ttable
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|l_is_undef
operator|=
name|IS_UNDEF_SYM_TYPE
argument_list|(
name|get_sym_type
argument_list|(
name|l
operator|->
name|sym
argument_list|,
name|ttable
argument_list|)
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|r_is_undef
operator|=
name|IS_UNDEF_SYM_TYPE
argument_list|(
name|get_sym_type
argument_list|(
name|r
operator|->
name|sym
argument_list|,
name|ttable
argument_list|)
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|assert
argument_list|(
name|l_is_undef
operator|+
name|r_is_undef
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|l_is_undef
operator|+
name|r_is_undef
operator|<=
literal|2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|l_is_undef
operator|+
name|r_is_undef
condition|)
block|{
case|case
literal|0
case|:
comment|/* Both defined */
if|if
condition|(
name|l
operator|->
name|sym
operator|->
name|st_value
operator|==
name|r
operator|->
name|sym
operator|->
name|st_value
condition|)
return|return
operator|(
name|strcmp
argument_list|(
name|l
operator|->
name|name
argument_list|,
name|r
operator|->
name|name
argument_list|)
operator|)
return|;
return|return
operator|(
name|l
operator|->
name|sym
operator|->
name|st_value
operator|-
name|r
operator|->
name|sym
operator|->
name|st_value
operator|)
return|;
case|case
literal|1
case|:
comment|/* One undefined */
return|return
operator|(
name|l_is_undef
operator|==
literal|0
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|2
case|:
comment|/* Both undefined */
return|return
operator|(
name|strcmp
argument_list|(
name|l
operator|->
name|name
argument_list|,
name|r
operator|->
name|name
argument_list|)
operator|)
return|;
block|}
comment|/* NOTREACHED */
return|return
operator|(
name|l
operator|->
name|sym
operator|->
name|st_value
operator|-
name|r
operator|->
name|sym
operator|->
name|st_value
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|filter_dest
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|filter_entry
modifier|*
name|e
decl_stmt|;
while|while
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|nm_out_filter
argument_list|)
condition|)
block|{
name|e
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|nm_out_filter
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|nm_out_filter
argument_list|,
name|filter_entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|filter_insert
parameter_list|(
name|fn_filter
name|filter_fn
parameter_list|)
block|{
name|struct
name|filter_entry
modifier|*
name|e
decl_stmt|;
name|assert
argument_list|(
name|filter_fn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|filter_entry
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|e
operator|->
name|fn
operator|=
name|filter_fn
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|nm_out_filter
argument_list|,
name|e
argument_list|,
name|filter_entries
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_demangle_option
parameter_list|(
specifier|const
name|char
modifier|*
name|opt
parameter_list|)
block|{
if|if
condition|(
name|opt
operator|==
name|NULL
condition|)
return|return
operator|(
name|ELFTC_DEM_UNKNOWN
operator|)
return|;
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|opt
argument_list|,
literal|"gnu-v2"
argument_list|,
literal|6
argument_list|)
condition|)
return|return
operator|(
name|ELFTC_DEM_GNU2
operator|)
return|;
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|opt
argument_list|,
literal|"gnu-v3"
argument_list|,
literal|6
argument_list|)
condition|)
return|return
operator|(
name|ELFTC_DEM_GNU3
operator|)
return|;
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|opt
argument_list|,
literal|"arm"
argument_list|,
literal|3
argument_list|)
condition|)
return|return
operator|(
name|ELFTC_DEM_ARM
operator|)
return|;
else|else
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"unknown demangling style '%s'"
argument_list|,
name|opt
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_opt
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
name|bool
name|is_posix
decl_stmt|,
name|oflag
decl_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|0
operator|||
name|argv
operator|==
name|NULL
condition|)
return|return;
name|oflag
operator|=
name|is_posix
operator|=
name|false
expr_stmt|;
name|nm_opts
operator|.
name|t
operator|=
name|RADIX_HEX
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"ABCDF:PSVaefghlnoprst:uvx"
argument_list|,
name|nm_longopts
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'A'
case|:
name|nm_opts
operator|.
name|print_name
operator|=
name|PRINT_NAME_FULL
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|nm_opts
operator|.
name|elem_print_fn
operator|=
operator|&
name|sym_elem_print_all
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|nm_opts
operator|.
name|demangle_type
operator|=
name|parse_demangle_option
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|nm_opts
operator|.
name|print_symbol
operator|=
name|PRINT_SYM_DYN
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* sysv, bsd, posix */
switch|switch
condition|(
name|optarg
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'B'
case|:
case|case
literal|'b'
case|:
name|nm_opts
operator|.
name|elem_print_fn
operator|=
operator|&
name|sym_elem_print_all
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
case|case
literal|'p'
case|:
name|is_posix
operator|=
name|true
expr_stmt|;
name|nm_opts
operator|.
name|elem_print_fn
operator|=
operator|&
name|sym_elem_print_all_portable
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
name|nm_opts
operator|.
name|elem_print_fn
operator|=
operator|&
name|sym_elem_print_all_sysv
expr_stmt|;
break|break;
default|default:
name|warnx
argument_list|(
literal|"%s: Invalid format"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'P'
case|:
name|is_posix
operator|=
name|true
expr_stmt|;
name|nm_opts
operator|.
name|elem_print_fn
operator|=
operator|&
name|sym_elem_print_all_portable
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|nm_opts
operator|.
name|print_size
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|print_version
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|'a'
case|:
name|nm_opts
operator|.
name|print_debug
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|filter_insert
argument_list|(
name|sym_elem_global_static
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
break|break;
case|case
literal|'g'
case|:
name|filter_insert
argument_list|(
name|sym_elem_global
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|usage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|nm_opts
operator|.
name|debug_line
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
case|case
literal|'v'
case|:
name|nm_opts
operator|.
name|sort_fn
operator|=
operator|&
name|cmp_value
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|oflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|nm_opts
operator|.
name|sort_fn
operator|=
operator|&
name|cmp_none
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|nm_opts
operator|.
name|sort_reverse
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|nm_opts
operator|.
name|print_armap
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* t require always argument to getopt_long */
switch|switch
condition|(
name|optarg
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'d'
case|:
name|nm_opts
operator|.
name|t
operator|=
name|RADIX_DEC
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|nm_opts
operator|.
name|t
operator|=
name|RADIX_OCT
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|nm_opts
operator|.
name|t
operator|=
name|RADIX_HEX
expr_stmt|;
break|break;
default|default:
name|warnx
argument_list|(
literal|"%s: Invalid radix"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'u'
case|:
name|filter_insert
argument_list|(
name|sym_elem_undef
argument_list|)
expr_stmt|;
name|nm_opts
operator|.
name|undef_only
operator|=
name|true
expr_stmt|;
break|break;
comment|/* case 'v': see case 'n' above. */
case|case
literal|'x'
case|:
name|nm_opts
operator|.
name|t
operator|=
name|RADIX_HEX
expr_stmt|;
break|break;
case|case
literal|0
case|:
if|if
condition|(
name|nm_opts
operator|.
name|sort_size
operator|!=
literal|0
condition|)
block|{
name|nm_opts
operator|.
name|sort_fn
operator|=
operator|&
name|cmp_size
expr_stmt|;
name|filter_insert
argument_list|(
name|sym_elem_def
argument_list|)
expr_stmt|;
name|filter_insert
argument_list|(
name|sym_elem_nonzero_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nm_opts
operator|.
name|def_only
operator|!=
literal|0
condition|)
name|filter_insert
argument_list|(
name|sym_elem_def
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_opts
operator|.
name|no_demangle
operator|!=
literal|0
condition|)
name|nm_opts
operator|.
name|demangle_type
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
default|default :
name|usage
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * In POSIX mode, the '-o' option controls the output radix. 	 * In non-POSIX mode, the option is a synonym for the '-A' and 	 * '--print-file-name' options. 	 */
if|if
condition|(
name|oflag
condition|)
block|{
if|if
condition|(
name|is_posix
condition|)
name|nm_opts
operator|.
name|t
operator|=
name|RADIX_OCT
expr_stmt|;
else|else
name|nm_opts
operator|.
name|print_name
operator|=
name|PRINT_NAME_FULL
expr_stmt|;
block|}
name|assert
argument_list|(
name|nm_opts
operator|.
name|sort_fn
operator|!=
name|NULL
operator|&&
literal|"nm_opts.sort_fn is null"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|nm_opts
operator|.
name|elem_print_fn
operator|!=
name|NULL
operator|&&
literal|"nm_opts.elem_print_fn is null"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|nm_opts
operator|.
name|value_print_fn
operator|!=
name|NULL
operator|&&
literal|"nm_opts.value_print_fn is null"
argument_list|)
expr_stmt|;
name|set_opt_value_print_fn
argument_list|(
name|nm_opts
operator|.
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_opts
operator|.
name|undef_only
operator|==
name|true
condition|)
block|{
if|if
condition|(
name|nm_opts
operator|.
name|sort_fn
operator|==
operator|&
name|cmp_size
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"--size-sort with -u is meaningless"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_opts
operator|.
name|def_only
operator|!=
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"-u with --defined-only is meaningless"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nm_opts
operator|.
name|print_debug
operator|==
name|false
condition|)
name|filter_insert
argument_list|(
name|sym_elem_nondebug
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_opts
operator|.
name|sort_reverse
operator|==
name|true
operator|&&
name|nm_opts
operator|.
name|sort_fn
operator|==
name|cmp_none
condition|)
name|nm_opts
operator|.
name|sort_reverse
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get symbol information from elf.  */
end_comment

begin_function
specifier|static
name|int
name|get_sym
parameter_list|(
name|Elf
modifier|*
name|elf
parameter_list|,
name|struct
name|sym_head
modifier|*
name|headp
parameter_list|,
name|int
name|shnum
parameter_list|,
name|size_t
name|dynndx
parameter_list|,
name|size_t
name|strndx
parameter_list|,
specifier|const
name|char
modifier|*
name|type_table
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|sec_table
parameter_list|,
name|int
name|sec_table_size
parameter_list|)
block|{
name|Elf_Scn
modifier|*
name|scn
decl_stmt|;
name|Elf_Data
modifier|*
name|data
decl_stmt|;
name|GElf_Shdr
name|shdr
decl_stmt|;
name|GElf_Sym
name|sym
decl_stmt|;
name|struct
name|filter_entry
modifier|*
name|fep
decl_stmt|;
name|size_t
name|ndx
decl_stmt|;
name|int
name|rtn
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
name|char
name|type
decl_stmt|;
name|bool
name|filter
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|assert
argument_list|(
name|elf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|headp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rtn
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|shnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|scn
operator|=
name|elf_getscn
argument_list|(
name|elf
argument_list|,
name|i
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_getscn failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|scn
argument_list|,
operator|&
name|shdr
argument_list|)
operator|!=
operator|&
name|shdr
condition|)
block|{
name|warnx
argument_list|(
literal|"gelf_getshdr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|shdr
operator|.
name|sh_type
operator|==
name|SHT_SYMTAB
condition|)
block|{
if|if
condition|(
name|nm_opts
operator|.
name|print_symbol
operator|!=
name|PRINT_SYM_SYM
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|shdr
operator|.
name|sh_type
operator|==
name|SHT_DYNSYM
condition|)
block|{
if|if
condition|(
name|nm_opts
operator|.
name|print_symbol
operator|!=
name|PRINT_SYM_DYN
condition|)
continue|continue;
block|}
else|else
continue|continue;
name|ndx
operator|=
name|shdr
operator|.
name|sh_type
operator|==
name|SHT_DYNSYM
condition|?
name|dynndx
else|:
name|strndx
expr_stmt|;
name|data
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|data
operator|=
name|elf_getdata
argument_list|(
name|scn
argument_list|,
name|data
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|j
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|gelf_getsym
argument_list|(
name|data
argument_list|,
name|j
operator|++
argument_list|,
operator|&
name|sym
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|sym_name
operator|=
name|get_sym_name
argument_list|(
name|elf
argument_list|,
operator|&
name|sym
argument_list|,
name|ndx
argument_list|,
name|sec_table
argument_list|,
name|sec_table_size
argument_list|)
expr_stmt|;
name|filter
operator|=
name|false
expr_stmt|;
name|type
operator|=
name|get_sym_type
argument_list|(
operator|&
name|sym
argument_list|,
name|type_table
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|fep
argument_list|,
argument|&nm_out_filter
argument_list|,
argument|filter_entries
argument_list|)
block|{
if|if
condition|(
operator|!
name|fep
operator|->
name|fn
argument_list|(
name|type
argument_list|,
operator|&
name|sym
argument_list|,
name|sym_name
argument_list|)
condition|)
block|{
name|filter
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|filter
operator|==
name|false
condition|)
block|{
if|if
condition|(
name|sym_list_insert
argument_list|(
name|headp
argument_list|,
name|sym_name
argument_list|,
operator|&
name|sym
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rtn
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|rtn
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_sym_name
parameter_list|(
name|Elf
modifier|*
name|elf
parameter_list|,
specifier|const
name|GElf_Sym
modifier|*
name|sym
parameter_list|,
name|size_t
name|ndx
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|sec_table
parameter_list|,
name|int
name|sec_table_size
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
name|sym_name
operator|=
name|NULL
expr_stmt|;
comment|/* Show section name as symbol name for STT_SECTION symbols. */
if|if
condition|(
name|GELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
if|if
condition|(
name|sec_table
operator|!=
name|NULL
operator|&&
name|sym
operator|->
name|st_shndx
operator|<
name|sec_table_size
condition|)
name|sym_name
operator|=
name|sec_table
index|[
name|sym
operator|->
name|st_shndx
index|]
expr_stmt|;
block|}
else|else
name|sym_name
operator|=
name|elf_strptr
argument_list|(
name|elf
argument_list|,
name|ndx
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_name
operator|==
name|NULL
condition|)
name|sym_name
operator|=
literal|"(null)"
expr_stmt|;
return|return
operator|(
name|sym_name
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
name|get_sym_type
parameter_list|(
specifier|const
name|GElf_Sym
modifier|*
name|sym
parameter_list|,
specifier|const
name|char
modifier|*
name|type_table
parameter_list|)
block|{
name|bool
name|is_local
decl_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
operator|||
name|type_table
operator|==
name|NULL
condition|)
return|return
operator|(
literal|'?'
operator|)
return|;
name|is_local
operator|=
name|sym
operator|->
name|st_info
operator|>>
literal|4
operator|==
name|STB_LOCAL
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
comment|/* absolute */
return|return
operator|(
name|is_local
condition|?
literal|'a'
else|:
literal|'A'
operator|)
return|;
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
comment|/* common */
return|return
operator|(
literal|'C'
operator|)
return|;
if|if
condition|(
operator|(
name|sym
operator|->
name|st_info
operator|)
operator|>>
literal|4
operator|==
name|STB_WEAK
condition|)
block|{
comment|/* weak */
if|if
condition|(
operator|(
name|sym
operator|->
name|st_info
operator|&
literal|0xf
operator|)
operator|==
name|STT_OBJECT
condition|)
return|return
operator|(
name|sym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|?
literal|'v'
else|:
literal|'V'
operator|)
return|;
return|return
operator|(
name|sym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|?
literal|'w'
else|:
literal|'W'
operator|)
return|;
block|}
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
comment|/* undefined */
return|return
operator|(
literal|'U'
operator|)
return|;
return|return
operator|(
name|is_local
operator|==
name|true
operator|&&
name|type_table
index|[
name|sym
operator|->
name|st_shndx
index|]
operator|!=
literal|'N'
condition|?
name|tolower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|type_table
index|[
name|sym
operator|->
name|st_shndx
index|]
argument_list|)
else|:
name|type_table
index|[
name|sym
operator|->
name|st_shndx
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|global_dest
parameter_list|(
name|void
parameter_list|)
block|{
name|filter_dest
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|global_init
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|elf_version
argument_list|(
name|EV_CURRENT
argument_list|)
operator|==
name|EV_NONE
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_version error"
argument_list|)
expr_stmt|;
name|nm_info
operator|.
name|name
operator|=
name|ELFTC_GETPROGNAME
argument_list|()
expr_stmt|;
name|nm_info
operator|.
name|def_filename
operator|=
literal|"a.out"
expr_stmt|;
name|nm_opts
operator|.
name|print_symbol
operator|=
name|PRINT_SYM_SYM
expr_stmt|;
name|nm_opts
operator|.
name|print_name
operator|=
name|PRINT_NAME_NONE
expr_stmt|;
name|nm_opts
operator|.
name|demangle_type
operator|=
operator|-
literal|1
expr_stmt|;
name|nm_opts
operator|.
name|print_debug
operator|=
name|false
expr_stmt|;
name|nm_opts
operator|.
name|print_armap
operator|=
name|false
expr_stmt|;
name|nm_opts
operator|.
name|print_size
operator|=
literal|0
expr_stmt|;
name|nm_opts
operator|.
name|debug_line
operator|=
name|false
expr_stmt|;
name|nm_opts
operator|.
name|def_only
operator|=
literal|0
expr_stmt|;
name|nm_opts
operator|.
name|undef_only
operator|=
name|false
expr_stmt|;
name|nm_opts
operator|.
name|sort_size
operator|=
literal|0
expr_stmt|;
name|nm_opts
operator|.
name|sort_reverse
operator|=
name|false
expr_stmt|;
name|nm_opts
operator|.
name|no_demangle
operator|=
literal|0
expr_stmt|;
name|nm_opts
operator|.
name|sort_fn
operator|=
operator|&
name|cmp_name
expr_stmt|;
name|nm_opts
operator|.
name|elem_print_fn
operator|=
operator|&
name|sym_elem_print_all
expr_stmt|;
name|nm_opts
operator|.
name|value_print_fn
operator|=
operator|&
name|sym_value_dec_print
expr_stmt|;
name|nm_opts
operator|.
name|size_print_fn
operator|=
operator|&
name|sym_size_dec_print
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|nm_out_filter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|is_sec_data
parameter_list|(
name|GElf_Shdr
modifier|*
name|s
parameter_list|)
block|{
name|assert
argument_list|(
name|s
operator|!=
name|NULL
operator|&&
literal|"shdr is NULL"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|s
operator|->
name|sh_flags
operator|&
name|SHF_ALLOC
operator|)
operator|!=
literal|0
operator|)
operator|&&
name|s
operator|->
name|sh_type
operator|!=
name|SHT_NOBITS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|is_sec_debug
parameter_list|(
specifier|const
name|char
modifier|*
name|shname
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|dbg_sec
index|[]
init|=
block|{
literal|".debug"
block|,
literal|".gnu.linkonce.wi."
block|,
literal|".line"
block|,
literal|".rel.debug"
block|,
literal|".rela.debug"
block|,
literal|".stab"
block|,
name|NULL
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|assert
argument_list|(
name|shname
operator|!=
name|NULL
operator|&&
literal|"shname is NULL"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|dbg_sec
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|shname
argument_list|,
operator|*
name|p
argument_list|,
name|strlen
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|is_sec_nobits
parameter_list|(
name|GElf_Shdr
modifier|*
name|s
parameter_list|)
block|{
name|assert
argument_list|(
name|s
operator|!=
name|NULL
operator|&&
literal|"shdr is NULL"
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|->
name|sh_type
operator|==
name|SHT_NOBITS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|is_sec_readonly
parameter_list|(
name|GElf_Shdr
modifier|*
name|s
parameter_list|)
block|{
name|assert
argument_list|(
name|s
operator|!=
name|NULL
operator|&&
literal|"shdr is NULL"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|s
operator|->
name|sh_flags
operator|&
name|SHF_WRITE
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|is_sec_text
parameter_list|(
name|GElf_Shdr
modifier|*
name|s
parameter_list|)
block|{
name|assert
argument_list|(
name|s
operator|!=
name|NULL
operator|&&
literal|"shdr is NULL"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|s
operator|->
name|sh_flags
operator|&
name|SHF_EXECINSTR
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_ar_index
parameter_list|(
name|int
name|fd
parameter_list|,
name|Elf
modifier|*
name|arf
parameter_list|)
block|{
name|Elf
modifier|*
name|elf
decl_stmt|;
name|Elf_Arhdr
modifier|*
name|arhdr
decl_stmt|;
name|Elf_Arsym
modifier|*
name|arsym
decl_stmt|;
name|Elf_Cmd
name|cmd
decl_stmt|;
name|off_t
name|start
decl_stmt|;
name|size_t
name|arsym_size
decl_stmt|;
if|if
condition|(
name|arf
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|arsym
operator|=
name|elf_getarsym
argument_list|(
name|arf
argument_list|,
operator|&
name|arsym_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|printf
argument_list|(
literal|"\nArchive index:\n"
argument_list|)
expr_stmt|;
name|start
operator|=
name|arsym
operator|->
name|as_off
expr_stmt|;
name|cmd
operator|=
name|ELF_C_READ
expr_stmt|;
while|while
condition|(
name|arsym_size
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|elf_rand
argument_list|(
name|arf
argument_list|,
name|arsym
operator|->
name|as_off
argument_list|)
operator|==
name|arsym
operator|->
name|as_off
operator|&&
operator|(
name|elf
operator|=
name|elf_begin
argument_list|(
name|fd
argument_list|,
name|cmd
argument_list|,
name|arf
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|arhdr
operator|=
name|elf_getarhdr
argument_list|(
name|elf
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s in %s\n"
argument_list|,
name|arsym
operator|->
name|as_name
argument_list|,
name|arhdr
operator|->
name|ar_name
operator|!=
name|NULL
condition|?
name|arhdr
operator|->
name|ar_name
else|:
name|arhdr
operator|->
name|ar_rawname
argument_list|)
expr_stmt|;
name|elf_end
argument_list|(
name|elf
argument_list|)
expr_stmt|;
block|}
operator|++
name|arsym
expr_stmt|;
operator|--
name|arsym_size
expr_stmt|;
block|}
name|elf_rand
argument_list|(
name|arf
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|DEMANGLED_BUFFER_SIZE
value|(8 * 1024)
end_define

begin_define
define|#
directive|define
name|PRINT_DEMANGLED_NAME
parameter_list|(
name|FORMAT
parameter_list|,
name|NAME
parameter_list|)
value|do {				\ 	char _demangled[DEMANGLED_BUFFER_SIZE];				\ 	if (nm_opts.demangle_type< 0 ||				\ 	    elftc_demangle((NAME), _demangled, sizeof(_demangled),	\ 		nm_opts.demangle_type)< 0)				\ 		printf((FORMAT), (NAME));				\ 	else								\ 		printf((FORMAT), _demangled);				\ 	} while (0)
end_define

begin_function
specifier|static
name|void
name|print_header
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|obj
parameter_list|)
block|{
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|nm_opts
operator|.
name|elem_print_fn
operator|==
operator|&
name|sym_elem_print_all_sysv
condition|)
block|{
name|printf
argument_list|(
literal|"\n\n%s from %s"
argument_list|,
name|nm_opts
operator|.
name|undef_only
operator|==
name|false
condition|?
literal|"Symbols"
else|:
literal|"Undefined symbols"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"[%s]"
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|":\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ Name                  Value           Class        Type         Size             Line  Section\n\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* archive file without -A option and POSIX */
if|if
condition|(
name|nm_opts
operator|.
name|print_name
operator|!=
name|PRINT_NAME_FULL
operator|&&
name|obj
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nm_opts
operator|.
name|elem_print_fn
operator|==
name|sym_elem_print_all_portable
condition|)
name|printf
argument_list|(
literal|"%s[%s]:\n"
argument_list|,
name|file
argument_list|,
name|obj
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nm_opts
operator|.
name|elem_print_fn
operator|==
name|sym_elem_print_all
condition|)
name|printf
argument_list|(
literal|"\n%s:\n"
argument_list|,
name|obj
argument_list|)
expr_stmt|;
comment|/* multiple files(not archive) without -A option */
block|}
elseif|else
if|if
condition|(
name|nm_opts
operator|.
name|print_name
operator|==
name|PRINT_NAME_MULTI
condition|)
block|{
if|if
condition|(
name|nm_opts
operator|.
name|elem_print_fn
operator|==
name|sym_elem_print_all
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s:\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_version
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s (%s)\n"
argument_list|,
name|nm_info
operator|.
name|name
argument_list|,
name|elftc_version
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|get_block_value
parameter_list|(
name|Dwarf_Debug
name|dbg
parameter_list|,
name|Dwarf_Block
modifier|*
name|block
parameter_list|)
block|{
name|Elf
modifier|*
name|elf
decl_stmt|;
name|GElf_Ehdr
name|eh
decl_stmt|;
name|Dwarf_Error
name|de
decl_stmt|;
if|if
condition|(
name|dwarf_get_elf
argument_list|(
name|dbg
argument_list|,
operator|&
name|elf
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_get_elf failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|gelf_getehdr
argument_list|(
name|elf
argument_list|,
operator|&
name|eh
argument_list|)
operator|!=
operator|&
name|eh
condition|)
block|{
name|warnx
argument_list|(
literal|"gelf_getehdr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|block
operator|->
name|bl_len
operator|==
literal|5
condition|)
block|{
if|if
condition|(
name|eh
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
operator|==
name|ELFDATA2LSB
condition|)
return|return
operator|(
name|le32dec
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|block
operator|->
name|bl_data
operator|+
literal|1
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|be32dec
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|block
operator|->
name|bl_data
operator|+
literal|1
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|block
operator|->
name|bl_len
operator|==
literal|9
condition|)
block|{
if|if
condition|(
name|eh
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
operator|==
name|ELFDATA2LSB
condition|)
return|return
operator|(
name|le64dec
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|block
operator|->
name|bl_data
operator|+
literal|1
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|be64dec
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|block
operator|->
name|bl_data
operator|+
literal|1
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|search_line_attr
parameter_list|(
name|Dwarf_Debug
name|dbg
parameter_list|,
name|struct
name|func_info_head
modifier|*
name|func_info
parameter_list|,
name|struct
name|var_info_head
modifier|*
name|var_info
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|,
name|char
modifier|*
modifier|*
name|src_files
parameter_list|,
name|Dwarf_Signed
name|filecount
parameter_list|)
block|{
name|Dwarf_Attribute
name|at
decl_stmt|;
name|Dwarf_Unsigned
name|udata
decl_stmt|;
name|Dwarf_Half
name|tag
decl_stmt|;
name|Dwarf_Block
modifier|*
name|block
decl_stmt|;
name|Dwarf_Bool
name|flag
decl_stmt|;
name|Dwarf_Die
name|ret_die
decl_stmt|;
name|Dwarf_Error
name|de
decl_stmt|;
name|struct
name|func_info_entry
modifier|*
name|func
decl_stmt|;
name|struct
name|var_info_entry
modifier|*
name|var
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|dwarf_tag
argument_list|(
name|die
argument_list|,
operator|&
name|tag
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_tag failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cont_search
goto|;
block|}
comment|/* We're interested in DIEs which define functions or variables. */
if|if
condition|(
name|tag
operator|!=
name|DW_TAG_subprogram
operator|&&
name|tag
operator|!=
name|DW_TAG_entry_point
operator|&&
name|tag
operator|!=
name|DW_TAG_inlined_subroutine
operator|&&
name|tag
operator|!=
name|DW_TAG_variable
condition|)
goto|goto
name|cont_search
goto|;
if|if
condition|(
name|tag
operator|==
name|DW_TAG_variable
condition|)
block|{
comment|/* Ignore "artificial" variable. */
if|if
condition|(
name|dwarf_attrval_flag
argument_list|(
name|die
argument_list|,
name|DW_AT_artificial
argument_list|,
operator|&
name|flag
argument_list|,
operator|&
name|de
argument_list|)
operator|==
name|DW_DLV_OK
operator|&&
name|flag
condition|)
goto|goto
name|cont_search
goto|;
comment|/* Ignore pure declaration. */
if|if
condition|(
name|dwarf_attrval_flag
argument_list|(
name|die
argument_list|,
name|DW_AT_declaration
argument_list|,
operator|&
name|flag
argument_list|,
operator|&
name|de
argument_list|)
operator|==
name|DW_DLV_OK
operator|&&
name|flag
condition|)
goto|goto
name|cont_search
goto|;
comment|/* Ignore stack varaibles. */
if|if
condition|(
name|dwarf_attrval_flag
argument_list|(
name|die
argument_list|,
name|DW_AT_external
argument_list|,
operator|&
name|flag
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
operator|||
operator|!
name|flag
condition|)
goto|goto
name|cont_search
goto|;
if|if
condition|(
operator|(
name|var
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|var
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"calloc failed"
argument_list|)
expr_stmt|;
goto|goto
name|cont_search
goto|;
block|}
if|if
condition|(
name|dwarf_attrval_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_decl_file
argument_list|,
operator|&
name|udata
argument_list|,
operator|&
name|de
argument_list|)
operator|==
name|DW_DLV_OK
operator|&&
name|udata
operator|>
literal|0
operator|&&
call|(
name|Dwarf_Signed
call|)
argument_list|(
name|udata
operator|-
literal|1
argument_list|)
operator|<
name|filecount
condition|)
block|{
name|var
operator|->
name|file
operator|=
name|strdup
argument_list|(
name|src_files
index|[
name|udata
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|var
operator|->
name|file
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"strdup"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|var
argument_list|)
expr_stmt|;
goto|goto
name|cont_search
goto|;
block|}
block|}
if|if
condition|(
name|dwarf_attrval_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_decl_line
argument_list|,
operator|&
name|udata
argument_list|,
operator|&
name|de
argument_list|)
operator|==
name|DW_DLV_OK
condition|)
name|var
operator|->
name|line
operator|=
name|udata
expr_stmt|;
if|if
condition|(
name|dwarf_attrval_string
argument_list|(
name|die
argument_list|,
name|DW_AT_name
argument_list|,
operator|&
name|str
argument_list|,
operator|&
name|de
argument_list|)
operator|==
name|DW_DLV_OK
condition|)
block|{
name|var
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|var
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"strdup"
argument_list|)
expr_stmt|;
if|if
condition|(
name|var
operator|->
name|file
condition|)
name|free
argument_list|(
name|var
operator|->
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|var
argument_list|)
expr_stmt|;
goto|goto
name|cont_search
goto|;
block|}
block|}
if|if
condition|(
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_location
argument_list|,
operator|&
name|at
argument_list|,
operator|&
name|de
argument_list|)
operator|==
name|DW_DLV_OK
operator|&&
name|dwarf_formblock
argument_list|(
name|at
argument_list|,
operator|&
name|block
argument_list|,
operator|&
name|de
argument_list|)
operator|==
name|DW_DLV_OK
condition|)
block|{
comment|/* 			 * Since we ignored stack variables, the rest are the 			 * external varaibles which should always use DW_OP_addr 			 * operator for DW_AT_location value. 			 */
if|if
condition|(
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|block
operator|->
name|bl_data
operator|)
operator|==
name|DW_OP_addr
condition|)
name|var
operator|->
name|addr
operator|=
name|get_block_value
argument_list|(
name|dbg
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
name|var_info
argument_list|,
name|var
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|func
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|func
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"calloc failed"
argument_list|)
expr_stmt|;
goto|goto
name|cont_search
goto|;
block|}
comment|/* 		 * Note that dwarf_attrval_unsigned() handles DW_AT_abstract_origin 		 * internally, so it can retrieve DW_AT_decl_file/DW_AT_decl_line 		 * attributes for inlined functions as well. 		 */
if|if
condition|(
name|dwarf_attrval_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_decl_file
argument_list|,
operator|&
name|udata
argument_list|,
operator|&
name|de
argument_list|)
operator|==
name|DW_DLV_OK
operator|&&
name|udata
operator|>
literal|0
operator|&&
call|(
name|Dwarf_Signed
call|)
argument_list|(
name|udata
operator|-
literal|1
argument_list|)
operator|<
name|filecount
condition|)
block|{
name|func
operator|->
name|file
operator|=
name|strdup
argument_list|(
name|src_files
index|[
name|udata
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|->
name|file
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"strdup"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|func
argument_list|)
expr_stmt|;
goto|goto
name|cont_search
goto|;
block|}
block|}
if|if
condition|(
name|dwarf_attrval_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_decl_line
argument_list|,
operator|&
name|udata
argument_list|,
operator|&
name|de
argument_list|)
operator|==
name|DW_DLV_OK
condition|)
name|func
operator|->
name|line
operator|=
name|udata
expr_stmt|;
if|if
condition|(
name|dwarf_attrval_string
argument_list|(
name|die
argument_list|,
name|DW_AT_name
argument_list|,
operator|&
name|str
argument_list|,
operator|&
name|de
argument_list|)
operator|==
name|DW_DLV_OK
condition|)
block|{
name|func
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"strdup"
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|->
name|file
condition|)
name|free
argument_list|(
name|func
operator|->
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|func
argument_list|)
expr_stmt|;
goto|goto
name|cont_search
goto|;
block|}
block|}
if|if
condition|(
name|dwarf_attrval_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_low_pc
argument_list|,
operator|&
name|udata
argument_list|,
operator|&
name|de
argument_list|)
operator|==
name|DW_DLV_OK
condition|)
name|func
operator|->
name|lowpc
operator|=
name|udata
expr_stmt|;
if|if
condition|(
name|dwarf_attrval_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_high_pc
argument_list|,
operator|&
name|udata
argument_list|,
operator|&
name|de
argument_list|)
operator|==
name|DW_DLV_OK
condition|)
name|func
operator|->
name|highpc
operator|=
name|udata
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
name|func_info
argument_list|,
name|func
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
name|cont_search
label|:
comment|/* Search children. */
name|ret
operator|=
name|dwarf_child
argument_list|(
name|die
argument_list|,
operator|&
name|ret_die
argument_list|,
operator|&
name|de
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|DW_DLV_ERROR
condition|)
name|warnx
argument_list|(
literal|"dwarf_child: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
name|DW_DLV_OK
condition|)
name|search_line_attr
argument_list|(
name|dbg
argument_list|,
name|func_info
argument_list|,
name|var_info
argument_list|,
name|ret_die
argument_list|,
name|src_files
argument_list|,
name|filecount
argument_list|)
expr_stmt|;
comment|/* Search sibling. */
name|ret
operator|=
name|dwarf_siblingof
argument_list|(
name|dbg
argument_list|,
name|die
argument_list|,
operator|&
name|ret_die
argument_list|,
operator|&
name|de
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|DW_DLV_ERROR
condition|)
name|warnx
argument_list|(
literal|"dwarf_siblingof: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
name|DW_DLV_OK
condition|)
name|search_line_attr
argument_list|(
name|dbg
argument_list|,
name|func_info
argument_list|,
name|var_info
argument_list|,
name|ret_die
argument_list|,
name|src_files
argument_list|,
name|filecount
argument_list|)
expr_stmt|;
name|dwarf_dealloc
argument_list|(
name|dbg
argument_list|,
name|die
argument_list|,
name|DW_DLA_DIE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read elf file and collect symbol information, sort them, print.  * Return 1 at failed, 0 at success.  */
end_comment

begin_function
specifier|static
name|int
name|read_elf
parameter_list|(
name|Elf
modifier|*
name|elf
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|Elf_Kind
name|kind
parameter_list|)
block|{
name|Dwarf_Debug
name|dbg
decl_stmt|;
name|Dwarf_Die
name|die
decl_stmt|;
name|Dwarf_Error
name|de
decl_stmt|;
name|Dwarf_Half
name|tag
decl_stmt|;
name|Elf_Arhdr
modifier|*
name|arhdr
decl_stmt|;
name|Elf_Scn
modifier|*
name|scn
decl_stmt|;
name|GElf_Shdr
name|shdr
decl_stmt|;
name|GElf_Half
name|i
decl_stmt|;
name|Dwarf_Line
modifier|*
name|lbuf
decl_stmt|;
name|Dwarf_Unsigned
name|lineno
decl_stmt|;
name|Dwarf_Signed
name|lcount
decl_stmt|,
name|filecount
decl_stmt|;
name|Dwarf_Addr
name|lineaddr
decl_stmt|;
name|struct
name|sym_print_data
name|p_data
decl_stmt|;
name|struct
name|sym_head
name|list_head
decl_stmt|;
name|struct
name|line_info_head
modifier|*
name|line_info
decl_stmt|;
name|struct
name|func_info_head
modifier|*
name|func_info
decl_stmt|;
name|struct
name|var_info_head
modifier|*
name|var_info
decl_stmt|;
name|struct
name|line_info_entry
modifier|*
name|lie
decl_stmt|;
name|struct
name|func_info_entry
modifier|*
name|func
decl_stmt|;
name|struct
name|var_info_entry
modifier|*
name|var
decl_stmt|;
specifier|const
name|char
modifier|*
name|shname
decl_stmt|,
modifier|*
name|objname
decl_stmt|;
name|char
modifier|*
name|type_table
decl_stmt|,
modifier|*
modifier|*
name|sec_table
decl_stmt|,
modifier|*
name|sfile
decl_stmt|,
modifier|*
modifier|*
name|src_files
decl_stmt|;
name|size_t
name|shstrndx
decl_stmt|,
name|shnum
decl_stmt|,
name|dynndx
decl_stmt|,
name|strndx
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|rtn
decl_stmt|,
name|e_err
decl_stmt|;
define|#
directive|define
name|OBJNAME
value|(objname == NULL ? filename : objname)
name|assert
argument_list|(
name|filename
operator|!=
name|NULL
operator|&&
literal|"filename is null"
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|list_head
argument_list|)
expr_stmt|;
name|type_table
operator|=
name|NULL
expr_stmt|;
name|sec_table
operator|=
name|NULL
expr_stmt|;
name|line_info
operator|=
name|NULL
expr_stmt|;
name|func_info
operator|=
name|NULL
expr_stmt|;
name|var_info
operator|=
name|NULL
expr_stmt|;
name|objname
operator|=
name|NULL
expr_stmt|;
name|dynndx
operator|=
name|SHN_UNDEF
expr_stmt|;
name|strndx
operator|=
name|SHN_UNDEF
expr_stmt|;
name|rtn
operator|=
literal|0
expr_stmt|;
name|nm_elfclass
operator|=
name|gelf_getclass
argument_list|(
name|elf
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|ELF_K_AR
condition|)
block|{
if|if
condition|(
operator|(
name|arhdr
operator|=
name|elf_getarhdr
argument_list|(
name|elf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|next_cmd
goto|;
name|objname
operator|=
name|arhdr
operator|->
name|ar_name
operator|!=
name|NULL
condition|?
name|arhdr
operator|->
name|ar_name
else|:
name|arhdr
operator|->
name|ar_rawname
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|elf_getshnum
argument_list|(
name|elf
argument_list|,
operator|&
name|shnum
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|e_err
operator|=
name|elf_errno
argument_list|()
operator|)
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"%s: %s"
argument_list|,
name|OBJNAME
argument_list|,
name|elf_errmsg
argument_list|(
name|e_err
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
literal|"%s: cannot get section number"
argument_list|,
name|OBJNAME
argument_list|)
expr_stmt|;
name|rtn
operator|=
literal|1
expr_stmt|;
goto|goto
name|next_cmd
goto|;
block|}
if|if
condition|(
name|shnum
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: has no section"
argument_list|,
name|OBJNAME
argument_list|)
expr_stmt|;
name|rtn
operator|=
literal|1
expr_stmt|;
goto|goto
name|next_cmd
goto|;
block|}
if|if
condition|(
operator|!
name|elf_getshstrndx
argument_list|(
name|elf
argument_list|,
operator|&
name|shstrndx
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: cannot get str index"
argument_list|,
name|OBJNAME
argument_list|)
expr_stmt|;
name|rtn
operator|=
literal|1
expr_stmt|;
goto|goto
name|next_cmd
goto|;
block|}
comment|/* type_table for type determine */
if|if
condition|(
operator|(
name|type_table
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
name|shnum
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"%s: malloc"
argument_list|,
name|OBJNAME
argument_list|)
expr_stmt|;
name|rtn
operator|=
literal|1
expr_stmt|;
goto|goto
name|next_cmd
goto|;
block|}
comment|/* sec_table for section name to display in sysv format */
if|if
condition|(
operator|(
name|sec_table
operator|=
name|calloc
argument_list|(
name|shnum
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"%s: calloc"
argument_list|,
name|OBJNAME
argument_list|)
expr_stmt|;
name|rtn
operator|=
literal|1
expr_stmt|;
goto|goto
name|next_cmd
goto|;
block|}
name|type_table
index|[
literal|0
index|]
operator|=
literal|'U'
expr_stmt|;
if|if
condition|(
operator|(
name|sec_table
index|[
literal|0
index|]
operator|=
name|strdup
argument_list|(
literal|"*UND*"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"strdup"
argument_list|)
expr_stmt|;
goto|goto
name|next_cmd
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|shnum
condition|;
operator|++
name|i
control|)
block|{
name|type_table
index|[
name|i
index|]
operator|=
literal|'U'
expr_stmt|;
if|if
condition|(
operator|(
name|scn
operator|=
name|elf_getscn
argument_list|(
name|elf
argument_list|,
name|i
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|e_err
operator|=
name|elf_errno
argument_list|()
operator|)
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"%s: %s"
argument_list|,
name|OBJNAME
argument_list|,
name|elf_errmsg
argument_list|(
name|e_err
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
literal|"%s: cannot get section"
argument_list|,
name|OBJNAME
argument_list|)
expr_stmt|;
name|rtn
operator|=
literal|1
expr_stmt|;
goto|goto
name|next_cmd
goto|;
block|}
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|scn
argument_list|,
operator|&
name|shdr
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|next_cmd
goto|;
comment|/* 		 * Cannot test by type and attribute for dynstr, strtab 		 */
name|shname
operator|=
name|elf_strptr
argument_list|(
name|elf
argument_list|,
name|shstrndx
argument_list|,
operator|(
name|size_t
operator|)
name|shdr
operator|.
name|sh_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|shname
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|sec_table
index|[
name|i
index|]
operator|=
name|strdup
argument_list|(
name|shname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"strdup"
argument_list|)
expr_stmt|;
goto|goto
name|next_cmd
goto|;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|shname
argument_list|,
literal|".dynstr"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|dynndx
operator|=
name|elf_ndxscn
argument_list|(
name|scn
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynndx
operator|==
name|SHN_UNDEF
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: elf_ndxscn failed: %s"
argument_list|,
name|OBJNAME
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|next_cmd
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|shname
argument_list|,
literal|".strtab"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|strndx
operator|=
name|elf_ndxscn
argument_list|(
name|scn
argument_list|)
expr_stmt|;
if|if
condition|(
name|strndx
operator|==
name|SHN_UNDEF
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: elf_ndxscn failed: %s"
argument_list|,
name|OBJNAME
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|next_cmd
goto|;
block|}
block|}
block|}
else|else
block|{
name|sec_table
index|[
name|i
index|]
operator|=
name|strdup
argument_list|(
literal|"*UND*"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec_table
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"strdup"
argument_list|)
expr_stmt|;
goto|goto
name|next_cmd
goto|;
block|}
block|}
if|if
condition|(
name|is_sec_text
argument_list|(
operator|&
name|shdr
argument_list|)
condition|)
name|type_table
index|[
name|i
index|]
operator|=
literal|'T'
expr_stmt|;
elseif|else
if|if
condition|(
name|is_sec_data
argument_list|(
operator|&
name|shdr
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_sec_readonly
argument_list|(
operator|&
name|shdr
argument_list|)
condition|)
name|type_table
index|[
name|i
index|]
operator|=
literal|'R'
expr_stmt|;
else|else
name|type_table
index|[
name|i
index|]
operator|=
literal|'D'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_sec_nobits
argument_list|(
operator|&
name|shdr
argument_list|)
condition|)
name|type_table
index|[
name|i
index|]
operator|=
literal|'B'
expr_stmt|;
elseif|else
if|if
condition|(
name|is_sec_debug
argument_list|(
name|shname
argument_list|)
condition|)
name|type_table
index|[
name|i
index|]
operator|=
literal|'N'
expr_stmt|;
elseif|else
if|if
condition|(
name|is_sec_readonly
argument_list|(
operator|&
name|shdr
argument_list|)
operator|&&
operator|!
name|is_sec_nobits
argument_list|(
operator|&
name|shdr
argument_list|)
condition|)
name|type_table
index|[
name|i
index|]
operator|=
literal|'n'
expr_stmt|;
block|}
name|print_header
argument_list|(
name|filename
argument_list|,
name|objname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dynndx
operator|==
name|SHN_UNDEF
operator|&&
name|nm_opts
operator|.
name|print_symbol
operator|==
name|PRINT_SYM_DYN
operator|)
operator|||
operator|(
name|strndx
operator|==
name|SHN_UNDEF
operator|&&
name|nm_opts
operator|.
name|print_symbol
operator|==
name|PRINT_SYM_SYM
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: no symbols"
argument_list|,
name|OBJNAME
argument_list|)
expr_stmt|;
comment|/* This is not an error case */
goto|goto
name|next_cmd
goto|;
block|}
name|STAILQ_INIT
argument_list|(
operator|&
name|list_head
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nm_opts
operator|.
name|debug_line
condition|)
goto|goto
name|process_sym
goto|;
comment|/* 	 * Collect dwarf line number information. 	 */
if|if
condition|(
name|dwarf_elf_init
argument_list|(
name|elf
argument_list|,
name|DW_DLC_READ
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|dbg
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_elf_init failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|process_sym
goto|;
block|}
name|line_info
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|line_info_head
argument_list|)
argument_list|)
expr_stmt|;
name|func_info
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|func_info_head
argument_list|)
argument_list|)
expr_stmt|;
name|var_info
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|var_info_head
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_info
operator|==
name|NULL
operator|||
name|func_info
operator|==
name|NULL
operator|||
name|var_info
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dwarf_finish
argument_list|(
name|dbg
argument_list|,
operator|&
name|de
argument_list|)
expr_stmt|;
goto|goto
name|process_sym
goto|;
block|}
name|SLIST_INIT
argument_list|(
name|line_info
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
name|func_info
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
name|var_info
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ret
operator|=
name|dwarf_next_cu_header
argument_list|(
name|dbg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|de
argument_list|)
operator|)
operator|==
name|DW_DLV_OK
condition|)
block|{
name|die
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|dwarf_siblingof
argument_list|(
name|dbg
argument_list|,
name|die
argument_list|,
operator|&
name|die
argument_list|,
operator|&
name|de
argument_list|)
operator|==
name|DW_DLV_OK
condition|)
block|{
if|if
condition|(
name|dwarf_tag
argument_list|(
name|die
argument_list|,
operator|&
name|tag
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_tag failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* XXX: What about DW_TAG_partial_unit? */
if|if
condition|(
name|tag
operator|==
name|DW_TAG_compile_unit
condition|)
break|break;
block|}
if|if
condition|(
name|die
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"could not find DW_TAG_compile_unit die"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Retrieve source file list. */
name|ret
operator|=
name|dwarf_srcfiles
argument_list|(
name|die
argument_list|,
operator|&
name|src_files
argument_list|,
operator|&
name|filecount
argument_list|,
operator|&
name|de
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|DW_DLV_ERROR
condition|)
name|warnx
argument_list|(
literal|"dwarf_srclines: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|DW_DLV_OK
condition|)
continue|continue;
comment|/* 		 * Retrieve line number information from .debug_line section. 		 */
name|ret
operator|=
name|dwarf_srclines
argument_list|(
name|die
argument_list|,
operator|&
name|lbuf
argument_list|,
operator|&
name|lcount
argument_list|,
operator|&
name|de
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|DW_DLV_ERROR
condition|)
name|warnx
argument_list|(
literal|"dwarf_srclines: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|DW_DLV_OK
condition|)
goto|goto
name|line_attr
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|Dwarf_Signed
operator|)
name|i
operator|<
name|lcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dwarf_lineaddr
argument_list|(
name|lbuf
index|[
name|i
index|]
argument_list|,
operator|&
name|lineaddr
argument_list|,
operator|&
name|de
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_lineaddr: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dwarf_lineno
argument_list|(
name|lbuf
index|[
name|i
index|]
argument_list|,
operator|&
name|lineno
argument_list|,
operator|&
name|de
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_lineno: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dwarf_linesrc
argument_list|(
name|lbuf
index|[
name|i
index|]
argument_list|,
operator|&
name|sfile
argument_list|,
operator|&
name|de
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_linesrc: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|lie
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lie
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|lie
operator|->
name|addr
operator|=
name|lineaddr
expr_stmt|;
name|lie
operator|->
name|line
operator|=
name|lineno
expr_stmt|;
name|lie
operator|->
name|file
operator|=
name|strdup
argument_list|(
name|sfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|lie
operator|->
name|file
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"strdup"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lie
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
name|line_info
argument_list|,
name|lie
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
name|line_attr
label|:
comment|/* Retrieve line number information from DIEs. */
name|search_line_attr
argument_list|(
name|dbg
argument_list|,
name|func_info
argument_list|,
name|var_info
argument_list|,
name|die
argument_list|,
name|src_files
argument_list|,
name|filecount
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|dwarf_finish
argument_list|(
name|dbg
argument_list|,
operator|&
name|de
argument_list|)
expr_stmt|;
name|process_sym
label|:
name|p_data
operator|.
name|list_num
operator|=
name|get_sym
argument_list|(
name|elf
argument_list|,
operator|&
name|list_head
argument_list|,
name|shnum
argument_list|,
name|dynndx
argument_list|,
name|strndx
argument_list|,
name|type_table
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sec_table
argument_list|,
name|shnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_data
operator|.
name|list_num
operator|==
literal|0
condition|)
goto|goto
name|next_cmd
goto|;
name|p_data
operator|.
name|headp
operator|=
operator|&
name|list_head
expr_stmt|;
name|p_data
operator|.
name|sh_num
operator|=
name|shnum
expr_stmt|;
name|p_data
operator|.
name|t_table
operator|=
name|type_table
expr_stmt|;
name|p_data
operator|.
name|s_table
operator|=
operator|(
name|void
operator|*
operator|)
name|sec_table
expr_stmt|;
name|p_data
operator|.
name|filename
operator|=
name|filename
expr_stmt|;
name|p_data
operator|.
name|objname
operator|=
name|objname
expr_stmt|;
name|sym_list_print
argument_list|(
operator|&
name|p_data
argument_list|,
name|func_info
argument_list|,
name|var_info
argument_list|,
name|line_info
argument_list|)
expr_stmt|;
name|next_cmd
label|:
if|if
condition|(
name|nm_opts
operator|.
name|debug_line
condition|)
block|{
if|if
condition|(
name|func_info
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
name|func_info
argument_list|)
condition|)
block|{
name|func
operator|=
name|SLIST_FIRST
argument_list|(
name|func_info
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
name|func_info
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|func
operator|->
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|func
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|func
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|func_info
argument_list|)
expr_stmt|;
name|func_info
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|var_info
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
name|var_info
argument_list|)
condition|)
block|{
name|var
operator|=
name|SLIST_FIRST
argument_list|(
name|var_info
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
name|var_info
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|var
operator|->
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|var
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|var_info
argument_list|)
expr_stmt|;
name|var_info
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|line_info
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
name|line_info
argument_list|)
condition|)
block|{
name|lie
operator|=
name|SLIST_FIRST
argument_list|(
name|line_info
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
name|line_info
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lie
operator|->
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lie
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|line_info
argument_list|)
expr_stmt|;
name|line_info
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sec_table
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shnum
condition|;
operator|++
name|i
control|)
name|free
argument_list|(
name|sec_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sec_table
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|type_table
argument_list|)
expr_stmt|;
name|sym_list_dest
argument_list|(
operator|&
name|list_head
argument_list|)
expr_stmt|;
return|return
operator|(
name|rtn
operator|)
return|;
undef|#
directive|undef
name|OBJNAME
block|}
end_function

begin_function
specifier|static
name|int
name|read_object
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|Elf
modifier|*
name|elf
decl_stmt|,
modifier|*
name|arf
decl_stmt|;
name|Elf_Cmd
name|elf_cmd
decl_stmt|;
name|Elf_Kind
name|kind
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|rtn
decl_stmt|,
name|e_err
decl_stmt|;
name|assert
argument_list|(
name|filename
operator|!=
name|NULL
operator|&&
literal|"filename is null"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"'%s'"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|elf_cmd
operator|=
name|ELF_C_READ
expr_stmt|;
if|if
condition|(
operator|(
name|arf
operator|=
name|elf_begin
argument_list|(
name|fd
argument_list|,
name|elf_cmd
argument_list|,
operator|(
name|Elf
operator|*
operator|)
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|e_err
operator|=
name|elf_errno
argument_list|()
operator|)
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_begin error: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|e_err
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
literal|"elf_begin error"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|assert
argument_list|(
name|arf
operator|!=
name|NULL
operator|&&
literal|"arf is null."
argument_list|)
expr_stmt|;
name|rtn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|kind
operator|=
name|elf_kind
argument_list|(
name|arf
argument_list|)
operator|)
operator|==
name|ELF_K_NONE
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: File format not recognized"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|elf_end
argument_list|(
name|arf
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|kind
operator|==
name|ELF_K_AR
condition|)
block|{
if|if
condition|(
name|nm_opts
operator|.
name|print_name
operator|==
name|PRINT_NAME_MULTI
operator|&&
name|nm_opts
operator|.
name|elem_print_fn
operator|==
name|sym_elem_print_all
condition|)
name|printf
argument_list|(
literal|"\n%s:\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_opts
operator|.
name|print_armap
operator|==
name|true
condition|)
name|print_ar_index
argument_list|(
name|fd
argument_list|,
name|arf
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|elf
operator|=
name|elf_begin
argument_list|(
name|fd
argument_list|,
name|elf_cmd
argument_list|,
name|arf
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|rtn
operator||=
name|read_elf
argument_list|(
name|elf
argument_list|,
name|filename
argument_list|,
name|kind
argument_list|)
expr_stmt|;
comment|/* 		 * If file is not archive, elf_next return ELF_C_NULL and 		 * stop the loop. 		 */
name|elf_cmd
operator|=
name|elf_next
argument_list|(
name|elf
argument_list|)
expr_stmt|;
name|elf_end
argument_list|(
name|elf
argument_list|)
expr_stmt|;
block|}
name|elf_end
argument_list|(
name|arf
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|rtn
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_files
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|rtn
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|0
operator|||
name|argv
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
name|rtn
operator||=
name|read_object
argument_list|(
name|nm_info
operator|.
name|def_filename
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|nm_opts
operator|.
name|print_name
operator|==
name|PRINT_NAME_NONE
operator|&&
name|argc
operator|>
literal|1
condition|)
name|nm_opts
operator|.
name|print_name
operator|=
name|PRINT_NAME_MULTI
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|rtn
operator||=
name|read_object
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
operator|--
name|argc
expr_stmt|;
operator|++
name|argv
expr_stmt|;
block|}
block|}
return|return
operator|(
name|rtn
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_lineno
parameter_list|(
name|struct
name|sym_entry
modifier|*
name|ep
parameter_list|,
name|struct
name|func_info_head
modifier|*
name|func_info
parameter_list|,
name|struct
name|var_info_head
modifier|*
name|var_info
parameter_list|,
name|struct
name|line_info_head
modifier|*
name|line_info
parameter_list|)
block|{
name|struct
name|func_info_entry
modifier|*
name|func
decl_stmt|;
name|struct
name|var_info_entry
modifier|*
name|var
decl_stmt|;
name|struct
name|line_info_entry
modifier|*
name|lie
decl_stmt|;
comment|/* For function symbol, search the function line information list.  */
if|if
condition|(
operator|(
name|ep
operator|->
name|sym
operator|->
name|st_info
operator|&
literal|0xf
operator|)
operator|==
name|STT_FUNC
operator|&&
name|func_info
operator|!=
name|NULL
condition|)
block|{
name|SLIST_FOREACH
argument_list|(
argument|func
argument_list|,
argument|func_info
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ep
operator|->
name|name
argument_list|,
name|func
operator|->
name|name
argument_list|)
operator|&&
name|ep
operator|->
name|sym
operator|->
name|st_value
operator|>=
name|func
operator|->
name|lowpc
operator|&&
name|ep
operator|->
name|sym
operator|->
name|st_value
operator|<
name|func
operator|->
name|highpc
condition|)
block|{
name|printf
argument_list|(
literal|"\t%s:%"
name|PRIu64
argument_list|,
name|func
operator|->
name|file
argument_list|,
name|func
operator|->
name|line
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* For variable symbol, search the variable line information list.  */
if|if
condition|(
operator|(
name|ep
operator|->
name|sym
operator|->
name|st_info
operator|&
literal|0xf
operator|)
operator|==
name|STT_OBJECT
operator|&&
name|var_info
operator|!=
name|NULL
condition|)
block|{
name|SLIST_FOREACH
argument_list|(
argument|var
argument_list|,
argument|var_info
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ep
operator|->
name|name
argument_list|,
name|var
operator|->
name|name
argument_list|)
operator|&&
name|ep
operator|->
name|sym
operator|->
name|st_value
operator|==
name|var
operator|->
name|addr
condition|)
block|{
name|printf
argument_list|(
literal|"\t%s:%"
name|PRIu64
argument_list|,
name|var
operator|->
name|file
argument_list|,
name|var
operator|->
name|line
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* Otherwise search line number information the .debug_line section. */
if|if
condition|(
name|line_info
operator|!=
name|NULL
condition|)
block|{
name|SLIST_FOREACH
argument_list|(
argument|lie
argument_list|,
argument|line_info
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
name|ep
operator|->
name|sym
operator|->
name|st_value
operator|==
name|lie
operator|->
name|addr
condition|)
block|{
name|printf
argument_list|(
literal|"\t%s:%"
name|PRIu64
argument_list|,
name|lie
operator|->
name|file
argument_list|,
name|lie
operator|->
name|line
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|set_opt_value_print_fn
parameter_list|(
name|enum
name|radix
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|RADIX_OCT
case|:
name|nm_opts
operator|.
name|value_print_fn
operator|=
operator|&
name|sym_value_oct_print
expr_stmt|;
name|nm_opts
operator|.
name|size_print_fn
operator|=
operator|&
name|sym_size_oct_print
expr_stmt|;
break|break;
case|case
name|RADIX_DEC
case|:
name|nm_opts
operator|.
name|value_print_fn
operator|=
operator|&
name|sym_value_dec_print
expr_stmt|;
name|nm_opts
operator|.
name|size_print_fn
operator|=
operator|&
name|sym_size_dec_print
expr_stmt|;
break|break;
case|case
name|RADIX_HEX
case|:
default|default :
name|nm_opts
operator|.
name|value_print_fn
operator|=
operator|&
name|sym_value_hex_print
expr_stmt|;
name|nm_opts
operator|.
name|size_print_fn
operator|=
operator|&
name|sym_size_hex_print
expr_stmt|;
block|}
name|assert
argument_list|(
name|nm_opts
operator|.
name|value_print_fn
operator|!=
name|NULL
operator|&&
literal|"nm_opts.value_print_fn is null"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sym_elem_print_all
parameter_list|(
name|char
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|sec
parameter_list|,
specifier|const
name|GElf_Sym
modifier|*
name|sym
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
name|sym
operator|==
name|NULL
operator|||
name|name
operator|==
name|NULL
operator|||
name|nm_opts
operator|.
name|value_print_fn
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|IS_UNDEF_SYM_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|nm_opts
operator|.
name|t
operator|==
name|RADIX_HEX
operator|&&
name|nm_elfclass
operator|==
name|ELFCLASS32
condition|)
name|printf
argument_list|(
literal|"%-8s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%-16s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
operator|(
name|nm_opts
operator|.
name|sort_fn
operator|==
operator|&
name|cmp_size
condition|?
literal|2
else|:
literal|0
operator|)
operator|+
name|nm_opts
operator|.
name|print_size
condition|)
block|{
case|case
literal|3
case|:
if|if
condition|(
name|sym
operator|->
name|st_size
operator|!=
literal|0
condition|)
block|{
name|nm_opts
operator|.
name|value_print_fn
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|nm_opts
operator|.
name|size_print_fn
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|sym
operator|->
name|st_size
operator|!=
literal|0
condition|)
name|nm_opts
operator|.
name|size_print_fn
argument_list|(
name|sym
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|nm_opts
operator|.
name|value_print_fn
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|st_size
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|nm_opts
operator|.
name|size_print_fn
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0
case|:
default|default:
name|nm_opts
operator|.
name|value_print_fn
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|" %c "
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|PRINT_DEMANGLED_NAME
argument_list|(
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sym_elem_print_all_portable
parameter_list|(
name|char
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|sec
parameter_list|,
specifier|const
name|GElf_Sym
modifier|*
name|sym
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
name|sym
operator|==
name|NULL
operator|||
name|name
operator|==
name|NULL
operator|||
name|nm_opts
operator|.
name|value_print_fn
operator|==
name|NULL
condition|)
return|return;
name|PRINT_DEMANGLED_NAME
argument_list|(
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %c "
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_UNDEF_SYM_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|nm_opts
operator|.
name|value_print_fn
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|st_size
operator|!=
literal|0
condition|)
name|nm_opts
operator|.
name|size_print_fn
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"        "
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sym_elem_print_all_sysv
parameter_list|(
name|char
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|sec
parameter_list|,
specifier|const
name|GElf_Sym
modifier|*
name|sym
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
name|sym
operator|==
name|NULL
operator|||
name|name
operator|==
name|NULL
operator|||
name|nm_opts
operator|.
name|value_print_fn
operator|==
name|NULL
condition|)
return|return;
name|PRINT_DEMANGLED_NAME
argument_list|(
literal|"%-20s|"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_UNDEF_SYM_TYPE
argument_list|(
name|type
argument_list|)
condition|)
name|printf
argument_list|(
literal|"                "
argument_list|)
expr_stmt|;
else|else
name|nm_opts
operator|.
name|value_print_fn
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"|   %c  |"
argument_list|,
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sym
operator|->
name|st_info
operator|&
literal|0xf
condition|)
block|{
case|case
name|STT_OBJECT
case|:
name|printf
argument_list|(
literal|"%18s|"
argument_list|,
literal|"OBJECT"
argument_list|)
expr_stmt|;
break|break;
case|case
name|STT_FUNC
case|:
name|printf
argument_list|(
literal|"%18s|"
argument_list|,
literal|"FUNC"
argument_list|)
expr_stmt|;
break|break;
case|case
name|STT_SECTION
case|:
name|printf
argument_list|(
literal|"%18s|"
argument_list|,
literal|"SECTION"
argument_list|)
expr_stmt|;
break|break;
case|case
name|STT_FILE
case|:
name|printf
argument_list|(
literal|"%18s|"
argument_list|,
literal|"FILE"
argument_list|)
expr_stmt|;
break|break;
case|case
name|STT_LOPROC
case|:
name|printf
argument_list|(
literal|"%18s|"
argument_list|,
literal|"LOPROC"
argument_list|)
expr_stmt|;
break|break;
case|case
name|STT_HIPROC
case|:
name|printf
argument_list|(
literal|"%18s|"
argument_list|,
literal|"HIPROC"
argument_list|)
expr_stmt|;
break|break;
case|case
name|STT_NOTYPE
case|:
default|default:
name|printf
argument_list|(
literal|"%18s|"
argument_list|,
literal|"NOTYPE"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|sym
operator|->
name|st_size
operator|!=
literal|0
condition|)
name|nm_opts
operator|.
name|size_print_fn
argument_list|(
name|sym
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"                "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"|     |%s"
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sym_elem_def
parameter_list|(
name|char
name|type
parameter_list|,
specifier|const
name|GElf_Sym
modifier|*
name|sym
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|assert
argument_list|(
name|IS_SYM_TYPE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
name|IS_UNDEF_SYM_TYPE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|type
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sym_elem_global
parameter_list|(
name|char
name|type
parameter_list|,
specifier|const
name|GElf_Sym
modifier|*
name|sym
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|assert
argument_list|(
name|IS_SYM_TYPE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* weak symbols resemble global. */
return|return
operator|(
name|isupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|type
argument_list|)
operator|||
name|type
operator|==
literal|'w'
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sym_elem_global_static
parameter_list|(
name|char
name|type
parameter_list|,
specifier|const
name|GElf_Sym
modifier|*
name|sym
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|unsigned
name|char
name|info
decl_stmt|;
name|assert
argument_list|(
name|sym
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|info
operator|=
name|sym
operator|->
name|st_info
operator|>>
literal|4
expr_stmt|;
return|return
operator|(
name|info
operator|==
name|STB_LOCAL
operator|||
name|info
operator|==
name|STB_GLOBAL
operator|||
name|info
operator|==
name|STB_WEAK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sym_elem_nondebug
parameter_list|(
name|char
name|type
parameter_list|,
specifier|const
name|GElf_Sym
modifier|*
name|sym
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|assert
argument_list|(
name|sym
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|st_value
operator|==
literal|0
operator|&&
operator|(
name|sym
operator|->
name|st_info
operator|&
literal|0xf
operator|)
operator|==
name|STT_FILE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sym
operator|->
name|st_name
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sym_elem_nonzero_size
parameter_list|(
name|char
name|type
parameter_list|,
specifier|const
name|GElf_Sym
modifier|*
name|sym
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|assert
argument_list|(
name|sym
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|sym
operator|->
name|st_size
operator|>
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sym_elem_undef
parameter_list|(
name|char
name|type
parameter_list|,
specifier|const
name|GElf_Sym
modifier|*
name|sym
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|assert
argument_list|(
name|IS_SYM_TYPE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|IS_UNDEF_SYM_TYPE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|type
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sym_list_dest
parameter_list|(
name|struct
name|sym_head
modifier|*
name|headp
parameter_list|)
block|{
name|struct
name|sym_entry
modifier|*
name|ep
decl_stmt|,
modifier|*
name|ep_n
decl_stmt|;
if|if
condition|(
name|headp
operator|==
name|NULL
condition|)
return|return;
name|ep
operator|=
name|STAILQ_FIRST
argument_list|(
name|headp
argument_list|)
expr_stmt|;
while|while
condition|(
name|ep
operator|!=
name|NULL
condition|)
block|{
name|ep_n
operator|=
name|STAILQ_NEXT
argument_list|(
name|ep
argument_list|,
name|sym_entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ep
operator|->
name|sym
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ep
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|=
name|ep_n
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sym_list_insert
parameter_list|(
name|struct
name|sym_head
modifier|*
name|headp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|GElf_Sym
modifier|*
name|sym
parameter_list|)
block|{
name|struct
name|sym_entry
modifier|*
name|e
decl_stmt|;
if|if
condition|(
name|headp
operator|==
name|NULL
operator|||
name|name
operator|==
name|NULL
operator|||
name|sym
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|e
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sym_entry
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|e
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"strdup"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|e
operator|->
name|sym
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|GElf_Sym
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|e
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|e
operator|->
name|sym
argument_list|,
name|sym
argument_list|,
sizeof|sizeof
argument_list|(
name|GElf_Sym
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Display size instead of value for common symbol. */
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|e
operator|->
name|sym
operator|->
name|st_value
operator|=
name|sym
operator|->
name|st_size
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
name|headp
argument_list|,
name|e
argument_list|,
name|sym_entries
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If file has not .debug_info, line_info will be NULL */
end_comment

begin_function
specifier|static
name|void
name|sym_list_print
parameter_list|(
name|struct
name|sym_print_data
modifier|*
name|p
parameter_list|,
name|struct
name|func_info_head
modifier|*
name|func_info
parameter_list|,
name|struct
name|var_info_head
modifier|*
name|var_info
parameter_list|,
name|struct
name|line_info_head
modifier|*
name|line_info
parameter_list|)
block|{
name|struct
name|sym_entry
modifier|*
name|e_v
decl_stmt|;
name|size_t
name|si
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|CHECK_SYM_PRINT_DATA
argument_list|(
name|p
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|e_v
operator|=
name|sym_list_sort
argument_list|(
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|nm_opts
operator|.
name|sort_reverse
operator|==
name|false
condition|)
for|for
control|(
name|si
operator|=
literal|0
init|;
name|si
operator|!=
name|p
operator|->
name|list_num
condition|;
operator|++
name|si
control|)
name|sym_list_print_each
argument_list|(
operator|&
name|e_v
index|[
name|si
index|]
argument_list|,
name|p
argument_list|,
name|func_info
argument_list|,
name|var_info
argument_list|,
name|line_info
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
name|p
operator|->
name|list_num
operator|-
literal|1
init|;
name|i
operator|!=
operator|-
literal|1
condition|;
operator|--
name|i
control|)
name|sym_list_print_each
argument_list|(
operator|&
name|e_v
index|[
name|i
index|]
argument_list|,
name|p
argument_list|,
name|func_info
argument_list|,
name|var_info
argument_list|,
name|line_info
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|e_v
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If file has not .debug_info, line_info will be NULL */
end_comment

begin_function
specifier|static
name|void
name|sym_list_print_each
parameter_list|(
name|struct
name|sym_entry
modifier|*
name|ep
parameter_list|,
name|struct
name|sym_print_data
modifier|*
name|p
parameter_list|,
name|struct
name|func_info_head
modifier|*
name|func_info
parameter_list|,
name|struct
name|var_info_head
modifier|*
name|var_info
parameter_list|,
name|struct
name|line_info_head
modifier|*
name|line_info
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|sec
decl_stmt|;
name|char
name|type
decl_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
operator|||
name|CHECK_SYM_PRINT_DATA
argument_list|(
name|p
argument_list|)
condition|)
return|return;
name|assert
argument_list|(
name|ep
operator|->
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ep
operator|->
name|sym
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|type
operator|=
name|get_sym_type
argument_list|(
name|ep
operator|->
name|sym
argument_list|,
name|p
operator|->
name|t_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_opts
operator|.
name|print_name
operator|==
name|PRINT_NAME_FULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|p
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_opts
operator|.
name|elem_print_fn
operator|==
operator|&
name|sym_elem_print_all_portable
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|objname
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"[%s]"
argument_list|,
name|p
operator|->
name|objname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|->
name|objname
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|":%s"
argument_list|,
name|p
operator|->
name|objname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|ep
operator|->
name|sym
operator|->
name|st_shndx
condition|)
block|{
case|case
name|SHN_LOPROC
case|:
comment|/* LOPROC or LORESERVE */
name|sec
operator|=
literal|"*LOPROC*"
expr_stmt|;
break|break;
case|case
name|SHN_HIPROC
case|:
name|sec
operator|=
literal|"*HIPROC*"
expr_stmt|;
break|break;
case|case
name|SHN_LOOS
case|:
name|sec
operator|=
literal|"*LOOS*"
expr_stmt|;
break|break;
case|case
name|SHN_HIOS
case|:
name|sec
operator|=
literal|"*HIOS*"
expr_stmt|;
break|break;
case|case
name|SHN_ABS
case|:
name|sec
operator|=
literal|"*ABS*"
expr_stmt|;
break|break;
case|case
name|SHN_COMMON
case|:
name|sec
operator|=
literal|"*COM*"
expr_stmt|;
break|break;
case|case
name|SHN_HIRESERVE
case|:
comment|/* HIRESERVE or XINDEX */
name|sec
operator|=
literal|"*HIRESERVE*"
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ep
operator|->
name|sym
operator|->
name|st_shndx
operator|>
name|p
operator|->
name|sh_num
condition|)
return|return;
name|sec
operator|=
name|p
operator|->
name|s_table
index|[
name|ep
operator|->
name|sym
operator|->
name|st_shndx
index|]
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|nm_opts
operator|.
name|elem_print_fn
argument_list|(
name|type
argument_list|,
name|sec
argument_list|,
name|ep
operator|->
name|sym
argument_list|,
name|ep
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_opts
operator|.
name|debug_line
operator|==
name|true
operator|&&
operator|!
name|IS_UNDEF_SYM_TYPE
argument_list|(
name|type
argument_list|)
condition|)
name|print_lineno
argument_list|(
name|ep
argument_list|,
name|func_info
argument_list|,
name|var_info
argument_list|,
name|line_info
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sym_entry
modifier|*
name|sym_list_sort
parameter_list|(
name|struct
name|sym_print_data
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|sym_entry
modifier|*
name|ep
decl_stmt|,
modifier|*
name|e_v
decl_stmt|;
name|int
name|idx
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|CHECK_SYM_PRINT_DATA
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|e_v
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sym_entry
argument_list|)
operator|*
name|p
operator|->
name|list_num
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|idx
operator|=
literal|0
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|ep
argument_list|,
argument|p->headp
argument_list|,
argument|sym_entries
argument_list|)
block|{
if|if
condition|(
name|ep
operator|->
name|name
operator|!=
name|NULL
operator|&&
name|ep
operator|->
name|sym
operator|!=
name|NULL
condition|)
block|{
name|e_v
index|[
name|idx
index|]
operator|.
name|name
operator|=
name|ep
operator|->
name|name
expr_stmt|;
name|e_v
index|[
name|idx
index|]
operator|.
name|sym
operator|=
name|ep
operator|->
name|sym
expr_stmt|;
operator|++
name|idx
expr_stmt|;
block|}
block|}
name|assert
argument_list|(
operator|(
name|size_t
operator|)
name|idx
operator|==
name|p
operator|->
name|list_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_opts
operator|.
name|sort_fn
operator|!=
operator|&
name|cmp_none
condition|)
block|{
name|nm_print_data
operator|=
name|p
expr_stmt|;
name|assert
argument_list|(
name|nm_print_data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|e_v
argument_list|,
name|p
operator|->
name|list_num
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sym_entry
argument_list|)
argument_list|,
name|nm_opts
operator|.
name|sort_fn
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|e_v
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sym_size_oct_print
parameter_list|(
specifier|const
name|GElf_Sym
modifier|*
name|sym
parameter_list|)
block|{
name|assert
argument_list|(
name|sym
operator|!=
name|NULL
operator|&&
literal|"sym is null"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%016"
name|PRIo64
argument_list|,
name|sym
operator|->
name|st_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sym_size_hex_print
parameter_list|(
specifier|const
name|GElf_Sym
modifier|*
name|sym
parameter_list|)
block|{
name|assert
argument_list|(
name|sym
operator|!=
name|NULL
operator|&&
literal|"sym is null"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_elfclass
operator|==
name|ELFCLASS32
condition|)
name|printf
argument_list|(
literal|"%08"
name|PRIx64
argument_list|,
name|sym
operator|->
name|st_size
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%016"
name|PRIx64
argument_list|,
name|sym
operator|->
name|st_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sym_size_dec_print
parameter_list|(
specifier|const
name|GElf_Sym
modifier|*
name|sym
parameter_list|)
block|{
name|assert
argument_list|(
name|sym
operator|!=
name|NULL
operator|&&
literal|"sym is null"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%016"
name|PRId64
argument_list|,
name|sym
operator|->
name|st_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sym_value_oct_print
parameter_list|(
specifier|const
name|GElf_Sym
modifier|*
name|sym
parameter_list|)
block|{
name|assert
argument_list|(
name|sym
operator|!=
name|NULL
operator|&&
literal|"sym is null"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%016"
name|PRIo64
argument_list|,
name|sym
operator|->
name|st_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sym_value_hex_print
parameter_list|(
specifier|const
name|GElf_Sym
modifier|*
name|sym
parameter_list|)
block|{
name|assert
argument_list|(
name|sym
operator|!=
name|NULL
operator|&&
literal|"sym is null"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_elfclass
operator|==
name|ELFCLASS32
condition|)
name|printf
argument_list|(
literal|"%08"
name|PRIx64
argument_list|,
name|sym
operator|->
name|st_value
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%016"
name|PRIx64
argument_list|,
name|sym
operator|->
name|st_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sym_value_dec_print
parameter_list|(
specifier|const
name|GElf_Sym
modifier|*
name|sym
parameter_list|)
block|{
name|assert
argument_list|(
name|sym
operator|!=
name|NULL
operator|&&
literal|"sym is null"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%016"
name|PRId64
argument_list|,
name|sym
operator|->
name|st_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|int
name|exitcode
parameter_list|)
block|{
name|printf
argument_list|(
literal|"Usage: %s [options] file ...\ \n  Display symbolic information in file.\n\ \n  Options: \ \n  -A, --print-file-name     Write the full pathname or library name of an\ \n                            object on each line.\ \n  -a, --debug-syms          Display all symbols include debugger-only\ \n                            symbols."
argument_list|,
name|nm_info
operator|.
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ \n  -B                        Equivalent to specifying \"--format=bsd\".\ \n  -C, --demangle[=style]    Decode low-level symbol names.\ \n      --no-demangle         Do not demangle low-level symbol names.\ \n  -D, --dynamic             Display only dynamic symbols.\ \n  -e                        Display only global and static symbols."
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ \n  -f                        Produce full output (default).\ \n      --format=format       Display output in specific format.  Allowed\ \n                            formats are: \"bsd\", \"posix\" and \"sysv\".\ \n  -g                        Display only global symbol information.\ \n  -h, --help                Show this help message.\ \n  -l, --line-numbers        Display filename and linenumber using\ \n                            debugging information.\ \n  -n, --numeric-sort        Sort symbols numerically by value."
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ \n  -o                        Write numeric values in octal. Equivalent to\ \n                            specifying \"-t o\".\ \n  -p, --no-sort             Do not sort symbols.\ \n  -P                        Write information in a portable output format.\ \n                            Equivalent to specifying \"--format=posix\".\ \n  -r, --reverse-sort        Reverse the order of the sort.\ \n  -S, --print-size          Print symbol sizes instead values.\ \n  -s, --print-armap         Include an index of archive members.\ \n      --size-sort           Sort symbols by size."
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ \n  -t, --radix=format        Write each numeric value in the specified\ \n                            format:\ \n                               d   In decimal,\ \n                               o   In octal,\ \n                               x   In hexadecimal."
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ \n  -u, --undefined-only      Display only undefined symbols.\ \n      --defined-only        Display only defined symbols.\ \n  -V, --version             Show the version identifier for %s.\ \n  -v                        Sort output by value.\ \n  -x                        Write numeric values in hexadecimal.\ \n                            Equivalent to specifying \"-t x\"."
argument_list|,
name|nm_info
operator|.
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\ \n  The default options are: output in bsd format, use a hexadecimal radix,\ \n  sort by symbol name, do not demangle names.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exitcode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Display symbolic information in file.  * Return 0 at success,>0 at failed.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|rtn
decl_stmt|;
name|global_init
argument_list|()
expr_stmt|;
name|get_opt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|rtn
operator|=
name|read_files
argument_list|(
name|argc
operator|-
name|optind
argument_list|,
name|argv
operator|+
name|optind
argument_list|)
expr_stmt|;
name|global_dest
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|rtn
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

