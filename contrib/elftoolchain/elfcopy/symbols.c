begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007-2013 Kai Wang  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fnmatch.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"elfcopy.h"
end_include

begin_expr_stmt
name|ELFTC_VCSID
argument_list|(
literal|"$Id: symbols.c 3520 2017-04-17 01:47:52Z kaiwang27 $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Backwards compatibility for systems with older ELF definitions. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STB_GNU_UNIQUE
end_ifndef

begin_define
define|#
directive|define
name|STB_GNU_UNIQUE
value|10
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Symbol table buffer structure. */
end_comment

begin_struct
struct|struct
name|symbuf
block|{
name|Elf32_Sym
modifier|*
name|l32
decl_stmt|;
comment|/* 32bit local symbol */
name|Elf32_Sym
modifier|*
name|g32
decl_stmt|;
comment|/* 32bit global symbol */
name|Elf64_Sym
modifier|*
name|l64
decl_stmt|;
comment|/* 64bit local symbol */
name|Elf64_Sym
modifier|*
name|g64
decl_stmt|;
comment|/* 64bit global symbol */
name|size_t
name|ngs
decl_stmt|,
name|nls
decl_stmt|;
comment|/* number of each kind */
name|size_t
name|gcap
decl_stmt|,
name|lcap
decl_stmt|;
comment|/* buffer capacities. */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sthash
block|{
name|LIST_ENTRY
argument_list|(
argument|sthash
argument_list|)
name|sh_next
expr_stmt|;
name|size_t
name|sh_off
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|LIST_HEAD
argument_list|(
argument_list|,
argument|sthash
argument_list|)
name|hash_head
expr_stmt|;
end_typedef

begin_define
define|#
directive|define
name|STHASHSIZE
value|65536
end_define

begin_struct
struct|struct
name|strimpl
block|{
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* string table */
name|size_t
name|sz
decl_stmt|;
comment|/* entries */
name|size_t
name|cap
decl_stmt|;
comment|/* buffer capacity */
name|hash_head
name|hash
index|[
name|STHASHSIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* String table buffer structure. */
end_comment

begin_struct
struct|struct
name|strbuf
block|{
name|struct
name|strimpl
name|l
decl_stmt|;
comment|/* local symbols */
name|struct
name|strimpl
name|g
decl_stmt|;
comment|/* global symbols */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|is_debug_symbol
parameter_list|(
name|unsigned
name|char
name|st_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_global_symbol
parameter_list|(
name|unsigned
name|char
name|st_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_local_symbol
parameter_list|(
name|unsigned
name|char
name|st_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_local_label
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_needed_symbol
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|int
name|i
parameter_list|,
name|GElf_Sym
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_remove_symbol
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|size_t
name|sc
parameter_list|,
name|int
name|i
parameter_list|,
name|GElf_Sym
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_weak_symbol
parameter_list|(
name|unsigned
name|char
name|st_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lookup_exact_string
parameter_list|(
name|hash_head
modifier|*
name|hash
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|generate_symbols
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_reloc_symbols
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|size_t
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_section_group_symbols
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|size_t
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|uint32_t
name|str_hash
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Convenient bit vector operation macros. */
end_comment

begin_define
define|#
directive|define
name|BIT_SET
parameter_list|(
name|v
parameter_list|,
name|n
parameter_list|)
value|(v[(n)>>3] |= 1U<< ((n)& 7))
end_define

begin_define
define|#
directive|define
name|BIT_CLR
parameter_list|(
name|v
parameter_list|,
name|n
parameter_list|)
value|(v[(n)>>3]&= ~(1U<< ((n)& 7)))
end_define

begin_define
define|#
directive|define
name|BIT_ISSET
parameter_list|(
name|v
parameter_list|,
name|n
parameter_list|)
value|(v[(n)>>3]& (1U<< ((n)& 7)))
end_define

begin_function
specifier|static
name|int
name|is_debug_symbol
parameter_list|(
name|unsigned
name|char
name|st_info
parameter_list|)
block|{
if|if
condition|(
name|GELF_ST_TYPE
argument_list|(
name|st_info
argument_list|)
operator|==
name|STT_SECTION
operator|||
name|GELF_ST_TYPE
argument_list|(
name|st_info
argument_list|)
operator|==
name|STT_FILE
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_global_symbol
parameter_list|(
name|unsigned
name|char
name|st_info
parameter_list|)
block|{
if|if
condition|(
name|GELF_ST_BIND
argument_list|(
name|st_info
argument_list|)
operator|==
name|STB_GLOBAL
operator|||
name|GELF_ST_BIND
argument_list|(
name|st_info
argument_list|)
operator|==
name|STB_GNU_UNIQUE
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_weak_symbol
parameter_list|(
name|unsigned
name|char
name|st_info
parameter_list|)
block|{
if|if
condition|(
name|GELF_ST_BIND
argument_list|(
name|st_info
argument_list|)
operator|==
name|STB_WEAK
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_local_symbol
parameter_list|(
name|unsigned
name|char
name|st_info
parameter_list|)
block|{
if|if
condition|(
name|GELF_ST_BIND
argument_list|(
name|st_info
argument_list|)
operator|==
name|STB_LOCAL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_hidden_symbol
parameter_list|(
name|unsigned
name|char
name|st_other
parameter_list|)
block|{
if|if
condition|(
name|GELF_ST_VISIBILITY
argument_list|(
name|st_other
argument_list|)
operator|==
name|STV_HIDDEN
operator|||
name|GELF_ST_VISIBILITY
argument_list|(
name|st_other
argument_list|)
operator|==
name|STV_INTERNAL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_local_label
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* Compiler generated local symbols that start with .L */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'L'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Symbols related to relocation are needed.  */
end_comment

begin_function
specifier|static
name|int
name|is_needed_symbol
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|int
name|i
parameter_list|,
name|GElf_Sym
modifier|*
name|s
parameter_list|)
block|{
comment|/* If symbol involves relocation, it is needed. */
if|if
condition|(
name|BIT_ISSET
argument_list|(
name|ecp
operator|->
name|v_rel
argument_list|,
name|i
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Symbols referred by COMDAT sections are needed. */
if|if
condition|(
name|BIT_ISSET
argument_list|(
name|ecp
operator|->
name|v_grp
argument_list|,
name|i
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * For relocatable files (.o files), global and weak symbols 	 * are needed. 	 */
if|if
condition|(
name|ecp
operator|->
name|flags
operator|&
name|RELOCATABLE
condition|)
block|{
if|if
condition|(
name|is_global_symbol
argument_list|(
name|s
operator|->
name|st_info
argument_list|)
operator|||
name|is_weak_symbol
argument_list|(
name|s
operator|->
name|st_info
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_remove_symbol
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|size_t
name|sc
parameter_list|,
name|int
name|i
parameter_list|,
name|GElf_Sym
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|GElf_Sym
name|sym0
init|=
block|{
literal|0
block|,
comment|/* st_name */
literal|0
block|,
comment|/* st_value */
literal|0
block|,
comment|/* st_size */
literal|0
block|,
comment|/* st_info */
literal|0
block|,
comment|/* st_other */
name|SHN_UNDEF
block|,
comment|/* st_shndx */
block|}
decl_stmt|;
comment|/* 	 * Keep the first symbol if it is the special reserved symbol. 	 * XXX Should we generate one if it's missing? 	 */
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
operator|!
name|memcmp
argument_list|(
name|s
argument_list|,
operator|&
name|sym0
argument_list|,
sizeof|sizeof
argument_list|(
name|GElf_Sym
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Remove the symbol if the section it refers to was removed. */
if|if
condition|(
name|s
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|&&
name|s
operator|->
name|st_shndx
operator|<
name|SHN_LORESERVE
operator|&&
name|ecp
operator|->
name|secndx
index|[
name|s
operator|->
name|st_shndx
index|]
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Keep the symbol if specified by command line option -K. */
if|if
condition|(
name|lookup_symop_list
argument_list|(
name|ecp
argument_list|,
name|name
argument_list|,
name|SYMOP_KEEP
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ecp
operator|->
name|strip
operator|==
name|STRIP_ALL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Mark symbols used in relocation. */
if|if
condition|(
name|ecp
operator|->
name|v_rel
operator|==
name|NULL
condition|)
name|mark_reloc_symbols
argument_list|(
name|ecp
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Mark symbols used in section groups. */
if|if
condition|(
name|ecp
operator|->
name|v_grp
operator|==
name|NULL
condition|)
name|mark_section_group_symbols
argument_list|(
name|ecp
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Strip the symbol if specified by command line option -N, 	 * unless it's used in relocation. 	 */
if|if
condition|(
name|lookup_symop_list
argument_list|(
name|ecp
argument_list|,
name|name
argument_list|,
name|SYMOP_STRIP
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|BIT_ISSET
argument_list|(
name|ecp
operator|->
name|v_rel
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"not stripping symbol `%s' because it is named"
literal|" in a relocation"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|is_needed_symbol
argument_list|(
name|ecp
argument_list|,
name|i
argument_list|,
name|s
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ecp
operator|->
name|strip
operator|==
name|STRIP_UNNEEDED
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|ecp
operator|->
name|flags
operator|&
name|DISCARD_LOCAL
operator|)
operator|&&
name|is_local_symbol
argument_list|(
name|s
operator|->
name|st_info
argument_list|)
operator|&&
operator|!
name|is_debug_symbol
argument_list|(
name|s
operator|->
name|st_info
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|ecp
operator|->
name|flags
operator|&
name|DISCARD_LLABEL
operator|)
operator|&&
name|is_local_symbol
argument_list|(
name|s
operator|->
name|st_info
argument_list|)
operator|&&
operator|!
name|is_debug_symbol
argument_list|(
name|s
operator|->
name|st_info
argument_list|)
operator|&&
name|is_local_label
argument_list|(
name|name
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|ecp
operator|->
name|strip
operator|==
name|STRIP_DEBUG
operator|&&
name|is_debug_symbol
argument_list|(
name|s
operator|->
name|st_info
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mark symbols referred by relocation entries.  */
end_comment

begin_function
specifier|static
name|void
name|mark_reloc_symbols
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|size_t
name|sc
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|Elf_Data
modifier|*
name|d
decl_stmt|;
name|Elf_Scn
modifier|*
name|s
decl_stmt|;
name|GElf_Rel
name|r
decl_stmt|;
name|GElf_Rela
name|ra
decl_stmt|;
name|GElf_Shdr
name|sh
decl_stmt|;
name|size_t
name|n
decl_stmt|,
name|indx
decl_stmt|;
name|int
name|elferr
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|;
name|ecp
operator|->
name|v_rel
operator|=
name|calloc
argument_list|(
operator|(
name|sc
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|v_rel
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_getshstrndx
argument_list|(
name|ecp
operator|->
name|ein
argument_list|,
operator|&
name|indx
argument_list|)
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_getshstrndx failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|elf_nextscn
argument_list|(
name|ecp
operator|->
name|ein
argument_list|,
name|s
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|s
argument_list|,
operator|&
name|sh
argument_list|)
operator|!=
operator|&
name|sh
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_getshdr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh
operator|.
name|sh_type
operator|!=
name|SHT_REL
operator|&&
name|sh
operator|.
name|sh_type
operator|!=
name|SHT_RELA
condition|)
continue|continue;
comment|/* 		 * Skip if this reloc section won't appear in the 		 * output object. 		 */
if|if
condition|(
operator|(
name|name
operator|=
name|elf_strptr
argument_list|(
name|ecp
operator|->
name|ein
argument_list|,
name|indx
argument_list|,
name|sh
operator|.
name|sh_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_strptr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_remove_section
argument_list|(
name|ecp
argument_list|,
name|name
argument_list|)
operator|||
name|is_remove_reloc_sec
argument_list|(
name|ecp
argument_list|,
name|sh
operator|.
name|sh_info
argument_list|)
condition|)
continue|continue;
comment|/* Skip if it's not for .symtab */
if|if
condition|(
name|sh
operator|.
name|sh_link
operator|!=
name|elf_ndxscn
argument_list|(
name|ecp
operator|->
name|symtab
operator|->
name|is
argument_list|)
condition|)
continue|continue;
name|d
operator|=
name|NULL
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|n
operator|<
name|sh
operator|.
name|sh_size
operator|&&
operator|(
name|d
operator|=
name|elf_getdata
argument_list|(
name|s
argument_list|,
name|d
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|d
operator|->
name|d_size
operator|/
name|sh
operator|.
name|sh_entsize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sh
operator|.
name|sh_type
operator|==
name|SHT_REL
condition|)
block|{
if|if
condition|(
name|gelf_getrel
argument_list|(
name|d
argument_list|,
name|i
argument_list|,
operator|&
name|r
argument_list|)
operator|!=
operator|&
name|r
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_getrel failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|GELF_R_SYM
argument_list|(
name|r
operator|.
name|r_info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|gelf_getrela
argument_list|(
name|d
argument_list|,
name|i
argument_list|,
operator|&
name|ra
argument_list|)
operator|!=
operator|&
name|ra
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_getrela failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|GELF_R_SYM
argument_list|(
name|ra
operator|.
name|r_info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
name|n
operator|<
name|sc
condition|)
name|BIT_SET
argument_list|(
name|ecp
operator|->
name|v_rel
argument_list|,
name|n
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"invalid symbox index"
argument_list|)
expr_stmt|;
block|}
block|}
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_nextscn failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mark_section_group_symbols
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|size_t
name|sc
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|Elf_Scn
modifier|*
name|s
decl_stmt|;
name|GElf_Shdr
name|sh
decl_stmt|;
name|size_t
name|indx
decl_stmt|;
name|int
name|elferr
decl_stmt|;
name|ecp
operator|->
name|v_grp
operator|=
name|calloc
argument_list|(
operator|(
name|sc
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|v_grp
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_getshstrndx
argument_list|(
name|ecp
operator|->
name|ein
argument_list|,
operator|&
name|indx
argument_list|)
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_getshstrndx failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|elf_nextscn
argument_list|(
name|ecp
operator|->
name|ein
argument_list|,
name|s
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|s
argument_list|,
operator|&
name|sh
argument_list|)
operator|!=
operator|&
name|sh
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_getshdr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh
operator|.
name|sh_type
operator|!=
name|SHT_GROUP
condition|)
continue|continue;
if|if
condition|(
operator|(
name|name
operator|=
name|elf_strptr
argument_list|(
name|ecp
operator|->
name|ein
argument_list|,
name|indx
argument_list|,
name|sh
operator|.
name|sh_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_strptr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_remove_section
argument_list|(
name|ecp
argument_list|,
name|name
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|sh
operator|.
name|sh_info
operator|>
literal|0
operator|&&
name|sh
operator|.
name|sh_info
operator|<
name|sc
condition|)
name|BIT_SET
argument_list|(
name|ecp
operator|->
name|v_grp
argument_list|,
name|sh
operator|.
name|sh_info
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sh
operator|.
name|sh_info
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"invalid symbox index"
argument_list|)
expr_stmt|;
block|}
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_nextscn failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|generate_symbols
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|struct
name|symop
modifier|*
name|sp
decl_stmt|;
name|struct
name|symbuf
modifier|*
name|sy_buf
decl_stmt|;
name|struct
name|strbuf
modifier|*
name|st_buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|newname
decl_stmt|;
name|unsigned
name|char
modifier|*
name|gsym
decl_stmt|;
name|GElf_Shdr
name|ish
decl_stmt|;
name|GElf_Sym
name|sym
decl_stmt|;
name|Elf_Data
modifier|*
name|id
decl_stmt|;
name|Elf_Scn
modifier|*
name|is
decl_stmt|;
name|size_t
name|ishstrndx
decl_stmt|,
name|namelen
decl_stmt|,
name|ndx
decl_stmt|,
name|sc
decl_stmt|,
name|symndx
decl_stmt|;
name|int
name|ec
decl_stmt|,
name|elferr
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|elf_getshstrndx
argument_list|(
name|ecp
operator|->
name|ein
argument_list|,
operator|&
name|ishstrndx
argument_list|)
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_getshstrndx failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ec
operator|=
name|gelf_getclass
argument_list|(
name|ecp
operator|->
name|eout
argument_list|)
operator|)
operator|==
name|ELFCLASSNONE
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_getclass failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create buffers for .symtab and .strtab. */
if|if
condition|(
operator|(
name|sy_buf
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sy_buf
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|st_buf
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|st_buf
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
name|sy_buf
operator|->
name|gcap
operator|=
name|sy_buf
operator|->
name|lcap
operator|=
literal|64
expr_stmt|;
name|st_buf
operator|->
name|g
operator|.
name|cap
operator|=
literal|256
expr_stmt|;
name|st_buf
operator|->
name|l
operator|.
name|cap
operator|=
literal|64
expr_stmt|;
name|st_buf
operator|->
name|l
operator|.
name|sz
operator|=
literal|1
expr_stmt|;
comment|/* '\0' at start. */
name|st_buf
operator|->
name|g
operator|.
name|sz
operator|=
literal|0
expr_stmt|;
name|ecp
operator|->
name|symtab
operator|->
name|sz
operator|=
literal|0
expr_stmt|;
name|ecp
operator|->
name|strtab
operator|->
name|sz
operator|=
literal|0
expr_stmt|;
name|ecp
operator|->
name|symtab
operator|->
name|buf
operator|=
name|sy_buf
expr_stmt|;
name|ecp
operator|->
name|strtab
operator|->
name|buf
operator|=
name|st_buf
expr_stmt|;
name|gsym
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Create bit vector v_secsym, which is used to mark sections 	 * that already have corresponding STT_SECTION symbols. 	 */
name|ecp
operator|->
name|v_secsym
operator|=
name|calloc
argument_list|(
operator|(
name|ecp
operator|->
name|nos
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|v_secsym
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
comment|/* Locate .strtab of input object. */
name|symndx
operator|=
literal|0
expr_stmt|;
name|name
operator|=
name|NULL
expr_stmt|;
name|is
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|is
operator|=
name|elf_nextscn
argument_list|(
name|ecp
operator|->
name|ein
argument_list|,
name|is
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|is
argument_list|,
operator|&
name|ish
argument_list|)
operator|!=
operator|&
name|ish
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_getshdr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|=
name|elf_strptr
argument_list|(
name|ecp
operator|->
name|ein
argument_list|,
name|ishstrndx
argument_list|,
name|ish
operator|.
name|sh_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_strptr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".strtab"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|symndx
operator|=
name|elf_ndxscn
argument_list|(
name|is
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_nextscn failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Symbol table should exist if this function is called. */
if|if
condition|(
name|symndx
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"can't find .strtab section"
argument_list|)
expr_stmt|;
goto|goto
name|clean
goto|;
block|}
comment|/* Locate .symtab of input object. */
name|is
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|is
operator|=
name|elf_nextscn
argument_list|(
name|ecp
operator|->
name|ein
argument_list|,
name|is
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|is
argument_list|,
operator|&
name|ish
argument_list|)
operator|!=
operator|&
name|ish
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_getshdr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|=
name|elf_strptr
argument_list|(
name|ecp
operator|->
name|ein
argument_list|,
name|ishstrndx
argument_list|,
name|ish
operator|.
name|sh_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_strptr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".symtab"
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_nextscn failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"can't find .strtab section"
argument_list|)
expr_stmt|;
comment|/* 	 * Create bit vector gsym to mark global symbols, and symndx 	 * to keep track of symbol index changes from input object to 	 * output object, it is used by update_reloc() later to update 	 * relocation information. 	 */
name|sc
operator|=
name|ish
operator|.
name|sh_size
operator|/
name|ish
operator|.
name|sh_entsize
expr_stmt|;
if|if
condition|(
name|sc
operator|>
literal|0
condition|)
block|{
name|ecp
operator|->
name|symndx
operator|=
name|calloc
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ecp
operator|->
name|symndx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|symndx
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
name|gsym
operator|=
name|calloc
argument_list|(
operator|(
name|sc
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|gsym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gsym
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|id
operator|=
name|elf_getdata
argument_list|(
name|is
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|clean
goto|;
block|}
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Copy/Filter each symbol. */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|sc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|gelf_getsym
argument_list|(
name|id
argument_list|,
name|i
argument_list|,
operator|&
name|sym
argument_list|)
operator|!=
operator|&
name|sym
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_getsym failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|=
name|elf_strptr
argument_list|(
name|ecp
operator|->
name|ein
argument_list|,
name|symndx
argument_list|,
name|sym
operator|.
name|st_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_strptr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Symbol filtering. */
if|if
condition|(
name|is_remove_symbol
argument_list|(
name|ecp
argument_list|,
name|sc
argument_list|,
name|i
argument_list|,
operator|&
name|sym
argument_list|,
name|name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* Check if we need to change the binding of this symbol. */
if|if
condition|(
name|is_global_symbol
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|||
name|is_weak_symbol
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
condition|)
block|{
comment|/* 			 * XXX Binutils objcopy does not weaken certain 			 * symbols. 			 */
if|if
condition|(
name|ecp
operator|->
name|flags
operator|&
name|WEAKEN_ALL
operator|||
name|lookup_symop_list
argument_list|(
name|ecp
argument_list|,
name|name
argument_list|,
name|SYMOP_WEAKEN
argument_list|)
operator|!=
name|NULL
condition|)
name|sym
operator|.
name|st_info
operator|=
name|GELF_ST_INFO
argument_list|(
name|STB_WEAK
argument_list|,
name|GELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do not localize undefined symbols. */
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|&&
name|lookup_symop_list
argument_list|(
name|ecp
argument_list|,
name|name
argument_list|,
name|SYMOP_LOCALIZE
argument_list|)
operator|!=
name|NULL
condition|)
name|sym
operator|.
name|st_info
operator|=
name|GELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|GELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|flags
operator|&
name|KEEP_GLOBAL
operator|&&
name|sym
operator|.
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|&&
name|lookup_symop_list
argument_list|(
name|ecp
argument_list|,
name|name
argument_list|,
name|SYMOP_KEEPG
argument_list|)
operator|==
name|NULL
condition|)
name|sym
operator|.
name|st_info
operator|=
name|GELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|GELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|flags
operator|&
name|LOCALIZE_HIDDEN
operator|&&
name|sym
operator|.
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|&&
name|is_hidden_symbol
argument_list|(
name|sym
operator|.
name|st_other
argument_list|)
condition|)
name|sym
operator|.
name|st_info
operator|=
name|GELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|GELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* STB_LOCAL binding. */
if|if
condition|(
name|lookup_symop_list
argument_list|(
name|ecp
argument_list|,
name|name
argument_list|,
name|SYMOP_GLOBALIZE
argument_list|)
operator|!=
name|NULL
condition|)
name|sym
operator|.
name|st_info
operator|=
name|GELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|GELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX We should globalize weak symbol? */
block|}
comment|/* Check if we need to rename this symbol. */
if|if
condition|(
operator|(
name|sp
operator|=
name|lookup_symop_list
argument_list|(
name|ecp
argument_list|,
name|name
argument_list|,
name|SYMOP_REDEF
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|name
operator|=
name|sp
operator|->
name|newname
expr_stmt|;
comment|/* Check if we need to prefix the symbols. */
name|newname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|prefix_sym
operator|!=
name|NULL
operator|&&
name|name
operator|!=
name|NULL
operator|&&
operator|*
name|name
operator|!=
literal|'\0'
condition|)
block|{
name|namelen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|ecp
operator|->
name|prefix_sym
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|newname
operator|=
name|malloc
argument_list|(
name|namelen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|newname
argument_list|,
name|namelen
argument_list|,
literal|"%s%s"
argument_list|,
name|ecp
operator|->
name|prefix_sym
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|newname
expr_stmt|;
block|}
comment|/* Copy symbol, mark global/weak symbol and add to index map. */
if|if
condition|(
name|is_global_symbol
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|||
name|is_weak_symbol
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
condition|)
block|{
name|BIT_SET
argument_list|(
name|gsym
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ecp
operator|->
name|symndx
index|[
name|i
index|]
operator|=
name|sy_buf
operator|->
name|ngs
expr_stmt|;
block|}
else|else
name|ecp
operator|->
name|symndx
index|[
name|i
index|]
operator|=
name|sy_buf
operator|->
name|nls
expr_stmt|;
name|add_to_symtab
argument_list|(
name|ecp
argument_list|,
name|name
argument_list|,
name|sym
operator|.
name|st_value
argument_list|,
name|sym
operator|.
name|st_size
argument_list|,
name|sym
operator|.
name|st_shndx
argument_list|,
name|sym
operator|.
name|st_info
argument_list|,
name|sym
operator|.
name|st_other
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|newname
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|newname
argument_list|)
expr_stmt|;
comment|/* 		 * If the symbol is a STT_SECTION symbol, mark the section 		 * it points to. 		 */
if|if
condition|(
name|GELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|==
name|STT_SECTION
operator|&&
name|sym
operator|.
name|st_shndx
operator|<
name|SHN_LORESERVE
condition|)
block|{
name|assert
argument_list|(
name|ecp
operator|->
name|secndx
index|[
name|sym
operator|.
name|st_shndx
index|]
operator|<
operator|(
name|uint64_t
operator|)
name|ecp
operator|->
name|nos
argument_list|)
expr_stmt|;
name|BIT_SET
argument_list|(
name|ecp
operator|->
name|v_secsym
argument_list|,
name|ecp
operator|->
name|secndx
index|[
name|sym
operator|.
name|st_shndx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Give up if there is no real symbols inside the table. 	 * XXX The logic here needs to be improved. We need to 	 * check if that only local symbol is the reserved symbol. 	 */
if|if
condition|(
name|sy_buf
operator|->
name|nls
operator|<=
literal|1
operator|&&
name|sy_buf
operator|->
name|ngs
operator|==
literal|0
condition|)
goto|goto
name|clean
goto|;
comment|/* 	 * Create STT_SECTION symbols for sections that do not already 	 * got one. However, we do not create STT_SECTION symbol for 	 * .symtab, .strtab, .shstrtab and reloc sec of relocatables. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|s
argument_list|,
argument|&ecp->v_sec
argument_list|,
argument|sec_list
argument_list|)
block|{
if|if
condition|(
name|s
operator|->
name|pseudo
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|".symtab"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|".strtab"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|".shstrtab"
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ecp
operator|->
name|flags
operator|&
name|RELOCATABLE
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|s
operator|->
name|type
operator|==
name|SHT_REL
operator|)
operator|||
operator|(
name|s
operator|->
name|type
operator|==
name|SHT_RELA
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ndx
operator|=
name|elf_ndxscn
argument_list|(
name|s
operator|->
name|os
argument_list|)
operator|)
operator|==
name|SHN_UNDEF
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_ndxscn failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BIT_ISSET
argument_list|(
name|ecp
operator|->
name|v_secsym
argument_list|,
name|ndx
argument_list|)
condition|)
block|{
name|sym
operator|.
name|st_name
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_value
operator|=
name|s
operator|->
name|vma
expr_stmt|;
name|sym
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_info
operator|=
name|GELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
name|sym
operator|.
name|st_other
operator|=
name|STV_DEFAULT
expr_stmt|;
comment|/* 			 * Don't let add_to_symtab() touch sym.st_shndx. 			 * In this case, we know the index already. 			 */
name|add_to_symtab
argument_list|(
name|ecp
argument_list|,
name|NULL
argument_list|,
name|sym
operator|.
name|st_value
argument_list|,
name|sym
operator|.
name|st_size
argument_list|,
name|ndx
argument_list|,
name|sym
operator|.
name|st_info
argument_list|,
name|sym
operator|.
name|st_other
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Update st_name and index map for global/weak symbols. Note that 	 * global/weak symbols are put after local symbols. 	 */
if|if
condition|(
name|gsym
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|sc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|BIT_ISSET
argument_list|(
name|gsym
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
comment|/* Update st_name. */
if|if
condition|(
name|ec
operator|==
name|ELFCLASS32
condition|)
name|sy_buf
operator|->
name|g32
index|[
name|ecp
operator|->
name|symndx
index|[
name|i
index|]
index|]
operator|.
name|st_name
operator|+=
name|st_buf
operator|->
name|l
operator|.
name|sz
expr_stmt|;
else|else
name|sy_buf
operator|->
name|g64
index|[
name|ecp
operator|->
name|symndx
index|[
name|i
index|]
index|]
operator|.
name|st_name
operator|+=
name|st_buf
operator|->
name|l
operator|.
name|sz
expr_stmt|;
comment|/* Update index map. */
name|ecp
operator|->
name|symndx
index|[
name|i
index|]
operator|+=
name|sy_buf
operator|->
name|nls
expr_stmt|;
block|}
name|free
argument_list|(
name|gsym
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
name|clean
label|:
name|free
argument_list|(
name|gsym
argument_list|)
expr_stmt|;
name|free_symtab
argument_list|(
name|ecp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|create_symtab
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|,
modifier|*
name|sy
decl_stmt|,
modifier|*
name|st
decl_stmt|;
name|size_t
name|maxndx
decl_stmt|,
name|ndx
decl_stmt|;
name|sy
operator|=
name|ecp
operator|->
name|symtab
expr_stmt|;
name|st
operator|=
name|ecp
operator|->
name|strtab
expr_stmt|;
name|assert
argument_list|(
name|sy
operator|!=
name|NULL
operator|&&
name|st
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Set section index map for .symtab and .strtab. We need to set 	 * these map because otherwise symbols which refer to .symtab and 	 * .strtab will be removed by symbol filtering unconditionally. 	 * And we have to figure out scn index this way (instead of calling 	 * elf_ndxscn) because we can not create Elf_Scn before we're certain 	 * that .symtab and .strtab will exist in the output object. 	 */
name|maxndx
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|s
argument_list|,
argument|&ecp->v_sec
argument_list|,
argument|sec_list
argument_list|)
block|{
if|if
condition|(
name|s
operator|->
name|os
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ndx
operator|=
name|elf_ndxscn
argument_list|(
name|s
operator|->
name|os
argument_list|)
operator|)
operator|==
name|SHN_UNDEF
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_ndxscn failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndx
operator|>
name|maxndx
condition|)
name|maxndx
operator|=
name|ndx
expr_stmt|;
block|}
name|ecp
operator|->
name|secndx
index|[
name|elf_ndxscn
argument_list|(
name|sy
operator|->
name|is
argument_list|)
index|]
operator|=
name|maxndx
operator|+
literal|1
expr_stmt|;
name|ecp
operator|->
name|secndx
index|[
name|elf_ndxscn
argument_list|(
name|st
operator|->
name|is
argument_list|)
index|]
operator|=
name|maxndx
operator|+
literal|2
expr_stmt|;
comment|/* 	 * Generate symbols for output object if SYMTAB_INTACT is not set. 	 * If there is no symbol in the input object or all the symbols are 	 * stripped, then free all the resouces allotted for symbol table, 	 * and clear SYMTAB_EXIST flag. 	 */
if|if
condition|(
operator|(
operator|(
name|ecp
operator|->
name|flags
operator|&
name|SYMTAB_INTACT
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|!
name|generate_symbols
argument_list|(
name|ecp
argument_list|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ecp
operator|->
name|v_sec
argument_list|,
name|ecp
operator|->
name|symtab
argument_list|,
name|sec_list
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ecp
operator|->
name|v_sec
argument_list|,
name|ecp
operator|->
name|strtab
argument_list|,
name|sec_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ecp
operator|->
name|symtab
operator|->
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ecp
operator|->
name|symtab
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ecp
operator|->
name|strtab
operator|->
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ecp
operator|->
name|strtab
argument_list|)
expr_stmt|;
name|ecp
operator|->
name|symtab
operator|=
name|NULL
expr_stmt|;
name|ecp
operator|->
name|strtab
operator|=
name|NULL
expr_stmt|;
name|ecp
operator|->
name|flags
operator|&=
operator|~
name|SYMTAB_EXIST
expr_stmt|;
return|return;
block|}
comment|/* Create output Elf_Scn for .symtab and .strtab. */
if|if
condition|(
operator|(
name|sy
operator|->
name|os
operator|=
name|elf_newscn
argument_list|(
name|ecp
operator|->
name|eout
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|st
operator|->
name|os
operator|=
name|elf_newscn
argument_list|(
name|ecp
operator|->
name|eout
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_newscn failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update secndx anyway. */
name|ecp
operator|->
name|secndx
index|[
name|elf_ndxscn
argument_list|(
name|sy
operator|->
name|is
argument_list|)
index|]
operator|=
name|elf_ndxscn
argument_list|(
name|sy
operator|->
name|os
argument_list|)
expr_stmt|;
name|ecp
operator|->
name|secndx
index|[
name|elf_ndxscn
argument_list|(
name|st
operator|->
name|is
argument_list|)
index|]
operator|=
name|elf_ndxscn
argument_list|(
name|st
operator|->
name|os
argument_list|)
expr_stmt|;
comment|/* 	 * Copy .symtab and .strtab section headers from input to output 	 * object to start with, these will be overridden later if need. 	 */
name|copy_shdr
argument_list|(
name|ecp
argument_list|,
name|sy
argument_list|,
literal|".symtab"
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|copy_shdr
argument_list|(
name|ecp
argument_list|,
name|st
argument_list|,
literal|".strtab"
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Copy verbatim if symbol table is intact. */
if|if
condition|(
name|ecp
operator|->
name|flags
operator|&
name|SYMTAB_INTACT
condition|)
block|{
name|copy_data
argument_list|(
name|sy
argument_list|)
expr_stmt|;
name|copy_data
argument_list|(
name|st
argument_list|)
expr_stmt|;
return|return;
block|}
name|create_symtab_data
argument_list|(
name|ecp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|free_symtab
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|)
block|{
name|struct
name|symbuf
modifier|*
name|sy_buf
decl_stmt|;
name|struct
name|strbuf
modifier|*
name|st_buf
decl_stmt|;
name|struct
name|sthash
modifier|*
name|sh
decl_stmt|,
modifier|*
name|shtmp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ecp
operator|->
name|symtab
operator|!=
name|NULL
operator|&&
name|ecp
operator|->
name|symtab
operator|->
name|buf
operator|!=
name|NULL
condition|)
block|{
name|sy_buf
operator|=
name|ecp
operator|->
name|symtab
operator|->
name|buf
expr_stmt|;
if|if
condition|(
name|sy_buf
operator|->
name|l32
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sy_buf
operator|->
name|l32
argument_list|)
expr_stmt|;
if|if
condition|(
name|sy_buf
operator|->
name|g32
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sy_buf
operator|->
name|g32
argument_list|)
expr_stmt|;
if|if
condition|(
name|sy_buf
operator|->
name|l64
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sy_buf
operator|->
name|l64
argument_list|)
expr_stmt|;
if|if
condition|(
name|sy_buf
operator|->
name|g64
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sy_buf
operator|->
name|g64
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ecp
operator|->
name|strtab
operator|!=
name|NULL
operator|&&
name|ecp
operator|->
name|strtab
operator|->
name|buf
operator|!=
name|NULL
condition|)
block|{
name|st_buf
operator|=
name|ecp
operator|->
name|strtab
operator|->
name|buf
expr_stmt|;
if|if
condition|(
name|st_buf
operator|->
name|l
operator|.
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|st_buf
operator|->
name|l
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|st_buf
operator|->
name|g
operator|.
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|st_buf
operator|->
name|g
operator|.
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STHASHSIZE
condition|;
name|i
operator|++
control|)
block|{
name|LIST_FOREACH_SAFE
argument_list|(
argument|sh
argument_list|,
argument|&st_buf->l.hash[i]
argument_list|,
argument|sh_next
argument_list|,
argument|shtmp
argument_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|sh
argument_list|,
name|sh_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sh
argument_list|)
expr_stmt|;
block|}
name|LIST_FOREACH_SAFE
argument_list|(
argument|sh
argument_list|,
argument|&st_buf->g.hash[i]
argument_list|,
argument|sh_next
argument_list|,
argument|shtmp
argument_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|sh
argument_list|,
name|sh_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sh
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ecp
operator|->
name|symndx
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ecp
operator|->
name|symndx
argument_list|)
expr_stmt|;
name|ecp
operator|->
name|symndx
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ecp
operator|->
name|v_rel
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ecp
operator|->
name|v_rel
argument_list|)
expr_stmt|;
name|ecp
operator|->
name|v_rel
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ecp
operator|->
name|v_grp
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ecp
operator|->
name|v_grp
argument_list|)
expr_stmt|;
name|ecp
operator|->
name|v_grp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ecp
operator|->
name|v_secsym
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ecp
operator|->
name|v_secsym
argument_list|)
expr_stmt|;
name|ecp
operator|->
name|v_secsym
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|create_external_symtab
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|struct
name|symbuf
modifier|*
name|sy_buf
decl_stmt|;
name|struct
name|strbuf
modifier|*
name|st_buf
decl_stmt|;
name|GElf_Shdr
name|sh
decl_stmt|;
name|size_t
name|ndx
decl_stmt|;
if|if
condition|(
name|ecp
operator|->
name|oec
operator|==
name|ELFCLASS32
condition|)
name|ecp
operator|->
name|symtab
operator|=
name|create_external_section
argument_list|(
name|ecp
argument_list|,
literal|".symtab"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SHT_SYMTAB
argument_list|,
name|ELF_T_SYM
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|ecp
operator|->
name|symtab
operator|=
name|create_external_section
argument_list|(
name|ecp
argument_list|,
literal|".symtab"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SHT_SYMTAB
argument_list|,
name|ELF_T_SYM
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecp
operator|->
name|strtab
operator|=
name|create_external_section
argument_list|(
name|ecp
argument_list|,
literal|".strtab"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SHT_STRTAB
argument_list|,
name|ELF_T_BYTE
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Let sh_link field of .symtab section point to .strtab section. */
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|ecp
operator|->
name|symtab
operator|->
name|os
argument_list|,
operator|&
name|sh
argument_list|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_getshdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|sh
operator|.
name|sh_link
operator|=
name|elf_ndxscn
argument_list|(
name|ecp
operator|->
name|strtab
operator|->
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gelf_update_shdr
argument_list|(
name|ecp
operator|->
name|symtab
operator|->
name|os
argument_list|,
operator|&
name|sh
argument_list|)
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_update_shdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create buffers for .symtab and .strtab. */
if|if
condition|(
operator|(
name|sy_buf
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sy_buf
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|st_buf
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|st_buf
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
name|sy_buf
operator|->
name|gcap
operator|=
name|sy_buf
operator|->
name|lcap
operator|=
literal|64
expr_stmt|;
name|st_buf
operator|->
name|g
operator|.
name|cap
operator|=
literal|256
expr_stmt|;
name|st_buf
operator|->
name|l
operator|.
name|cap
operator|=
literal|64
expr_stmt|;
name|st_buf
operator|->
name|l
operator|.
name|sz
operator|=
literal|1
expr_stmt|;
comment|/* '\0' at start. */
name|st_buf
operator|->
name|g
operator|.
name|sz
operator|=
literal|0
expr_stmt|;
name|ecp
operator|->
name|symtab
operator|->
name|sz
operator|=
literal|0
expr_stmt|;
name|ecp
operator|->
name|strtab
operator|->
name|sz
operator|=
literal|0
expr_stmt|;
name|ecp
operator|->
name|symtab
operator|->
name|buf
operator|=
name|sy_buf
expr_stmt|;
name|ecp
operator|->
name|strtab
operator|->
name|buf
operator|=
name|st_buf
expr_stmt|;
comment|/* Always create the special symbol at the symtab beginning. */
name|add_to_symtab
argument_list|(
name|ecp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SHN_UNDEF
argument_list|,
name|ELF32_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|STT_NOTYPE
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Create STT_SECTION symbols. */
name|TAILQ_FOREACH
argument_list|(
argument|s
argument_list|,
argument|&ecp->v_sec
argument_list|,
argument|sec_list
argument_list|)
block|{
if|if
condition|(
name|s
operator|->
name|pseudo
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|".symtab"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|".strtab"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|".shstrtab"
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|ndx
operator|=
name|elf_ndxscn
argument_list|(
name|s
operator|->
name|os
argument_list|)
operator|)
operator|==
name|SHN_UNDEF
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_ndxscn failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|add_to_symtab
argument_list|(
name|ecp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ndx
argument_list|,
name|GELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|STT_SECTION
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|add_to_symtab
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|st_value
parameter_list|,
name|uint64_t
name|st_size
parameter_list|,
name|uint16_t
name|st_shndx
parameter_list|,
name|unsigned
name|char
name|st_info
parameter_list|,
name|unsigned
name|char
name|st_other
parameter_list|,
name|int
name|ndx_known
parameter_list|)
block|{
name|struct
name|symbuf
modifier|*
name|sy_buf
decl_stmt|;
name|struct
name|strbuf
modifier|*
name|st_buf
decl_stmt|;
name|struct
name|sthash
modifier|*
name|sh
decl_stmt|;
name|uint32_t
name|hash
decl_stmt|;
name|int
name|pos
decl_stmt|;
comment|/* 	 * Convenient macro for copying global/local 32/64 bit symbols 	 * from input object to the buffer created for output object. 	 * It handles buffer growing, st_name calculating and st_shndx 	 * updating for symbols with non-special section index. 	 */
define|#
directive|define
name|_ST_NAME_EMPTY_l
value|0
define|#
directive|define
name|_ST_NAME_EMPTY_g
value|-1
define|#
directive|define
name|_ADDSYM
parameter_list|(
name|B
parameter_list|,
name|SZ
parameter_list|)
value|do {						\ 	if (sy_buf->B##SZ == NULL) {					\ 		sy_buf->B##SZ = malloc(sy_buf->B##cap *			\ 		    sizeof(Elf##SZ##_Sym));				\ 		if (sy_buf->B##SZ == NULL)				\ 			err(EXIT_FAILURE, "malloc failed");		\ 	} else if (sy_buf->n##B##s>= sy_buf->B##cap) {			\ 		sy_buf->B##cap *= 2;					\ 		sy_buf->B##SZ = realloc(sy_buf->B##SZ, sy_buf->B##cap *	\ 		    sizeof(Elf##SZ##_Sym));				\ 		if (sy_buf->B##SZ == NULL)				\ 			err(EXIT_FAILURE, "realloc failed");		\ 	}								\ 	sy_buf->B##SZ[sy_buf->n##B##s].st_info	= st_info;		\ 	sy_buf->B##SZ[sy_buf->n##B##s].st_other	= st_other;		\ 	sy_buf->B##SZ[sy_buf->n##B##s].st_value	= st_value;		\ 	sy_buf->B##SZ[sy_buf->n##B##s].st_size	= st_size;		\ 	if (ndx_known)							\ 		sy_buf->B##SZ[sy_buf->n##B##s].st_shndx = st_shndx;	\ 	else if (st_shndx == SHN_UNDEF || st_shndx>= SHN_LORESERVE)	\ 		sy_buf->B##SZ[sy_buf->n##B##s].st_shndx = st_shndx;	\ 	else								\ 		sy_buf->B##SZ[sy_buf->n##B##s].st_shndx	=		\ 			ecp->secndx[st_shndx];				\ 	if (st_buf->B.buf == NULL) {					\ 		st_buf->B.buf = calloc(st_buf->B.cap,			\ 		    sizeof(*st_buf->B.buf));				\ 		if (st_buf->B.buf == NULL)				\ 			err(EXIT_FAILURE, "malloc failed");		\ 	}								\ 	if (name != NULL&& *name != '\0') {				\ 		pos = lookup_exact_string(st_buf->B.hash, st_buf->B.buf,\ 		    name);						\ 		if (pos != -1)						\ 			sy_buf->B##SZ[sy_buf->n##B##s].st_name = pos;	\ 		else {							\ 			sy_buf->B##SZ[sy_buf->n##B##s].st_name =	\ 			    st_buf->B.sz;				\ 			while (st_buf->B.sz + strlen(name)>=		\ 			    st_buf->B.cap - 1) {			\ 				st_buf->B.cap *= 2;			\ 				st_buf->B.buf = realloc(st_buf->B.buf,	\ 				    st_buf->B.cap);			\ 				if (st_buf->B.buf == NULL)		\ 					err(EXIT_FAILURE,		\ 					    "realloc failed");		\ 			}						\ 			if ((sh = malloc(sizeof(*sh))) == NULL)		\ 				err(EXIT_FAILURE, "malloc failed");	\ 			sh->sh_off = st_buf->B.sz;			\ 			hash = str_hash(name);				\ 			LIST_INSERT_HEAD(&st_buf->B.hash[hash], sh,	\ 			    sh_next);					\ 			strncpy(&st_buf->B.buf[st_buf->B.sz], name,	\ 			    strlen(name));				\ 			st_buf->B.buf[st_buf->B.sz + strlen(name)] = '\0'; \ 			st_buf->B.sz += strlen(name) + 1;		\ 		}							\ 	} else								\ 		sy_buf->B##SZ[sy_buf->n##B##s].st_name = 		\ 		    (Elf##SZ##_Word)_ST_NAME_EMPTY_##B;			\ 	sy_buf->n##B##s++;						\ } while (0)
name|sy_buf
operator|=
name|ecp
operator|->
name|symtab
operator|->
name|buf
expr_stmt|;
name|st_buf
operator|=
name|ecp
operator|->
name|strtab
operator|->
name|buf
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|oec
operator|==
name|ELFCLASS32
condition|)
block|{
if|if
condition|(
name|is_local_symbol
argument_list|(
name|st_info
argument_list|)
condition|)
name|_ADDSYM
argument_list|(
name|l
argument_list|,
literal|32
argument_list|)
expr_stmt|;
else|else
name|_ADDSYM
argument_list|(
name|g
argument_list|,
literal|32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|is_local_symbol
argument_list|(
name|st_info
argument_list|)
condition|)
name|_ADDSYM
argument_list|(
name|l
argument_list|,
literal|64
argument_list|)
expr_stmt|;
else|else
name|_ADDSYM
argument_list|(
name|g
argument_list|,
literal|64
argument_list|)
expr_stmt|;
block|}
comment|/* Update section size. */
name|ecp
operator|->
name|symtab
operator|->
name|sz
operator|=
operator|(
name|sy_buf
operator|->
name|nls
operator|+
name|sy_buf
operator|->
name|ngs
operator|)
operator|*
operator|(
name|ecp
operator|->
name|oec
operator|==
name|ELFCLASS32
condition|?
sizeof|sizeof
argument_list|(
name|Elf32_Sym
argument_list|)
else|:
sizeof|sizeof
argument_list|(
name|Elf64_Sym
argument_list|)
operator|)
expr_stmt|;
name|ecp
operator|->
name|strtab
operator|->
name|sz
operator|=
name|st_buf
operator|->
name|l
operator|.
name|sz
operator|+
name|st_buf
operator|->
name|g
operator|.
name|sz
expr_stmt|;
undef|#
directive|undef
name|_ADDSYM
undef|#
directive|undef
name|_ST_NAME_EMPTY_l
undef|#
directive|undef
name|_ST_NAME_EMPTY_g
block|}
end_function

begin_function
name|void
name|finalize_external_symtab
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|)
block|{
name|struct
name|symbuf
modifier|*
name|sy_buf
decl_stmt|;
name|struct
name|strbuf
modifier|*
name|st_buf
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Update st_name for global/weak symbols. (global/weak symbols 	 * are put after local symbols) 	 */
name|sy_buf
operator|=
name|ecp
operator|->
name|symtab
operator|->
name|buf
expr_stmt|;
name|st_buf
operator|=
name|ecp
operator|->
name|strtab
operator|->
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|sy_buf
operator|->
name|ngs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ecp
operator|->
name|oec
operator|==
name|ELFCLASS32
condition|)
block|{
if|if
condition|(
name|sy_buf
operator|->
name|g32
index|[
name|i
index|]
operator|.
name|st_name
operator|==
operator|(
name|Elf32_Word
operator|)
operator|-
literal|1
condition|)
name|sy_buf
operator|->
name|g32
index|[
name|i
index|]
operator|.
name|st_name
operator|=
literal|0
expr_stmt|;
else|else
name|sy_buf
operator|->
name|g32
index|[
name|i
index|]
operator|.
name|st_name
operator|+=
name|st_buf
operator|->
name|l
operator|.
name|sz
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sy_buf
operator|->
name|g64
index|[
name|i
index|]
operator|.
name|st_name
operator|==
operator|(
name|Elf64_Word
operator|)
operator|-
literal|1
condition|)
name|sy_buf
operator|->
name|g64
index|[
name|i
index|]
operator|.
name|st_name
operator|=
literal|0
expr_stmt|;
else|else
name|sy_buf
operator|->
name|g64
index|[
name|i
index|]
operator|.
name|st_name
operator|+=
name|st_buf
operator|->
name|l
operator|.
name|sz
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|create_symtab_data
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|sy
decl_stmt|,
modifier|*
name|st
decl_stmt|;
name|struct
name|symbuf
modifier|*
name|sy_buf
decl_stmt|;
name|struct
name|strbuf
modifier|*
name|st_buf
decl_stmt|;
name|Elf_Data
modifier|*
name|gsydata
decl_stmt|,
modifier|*
name|lsydata
decl_stmt|,
modifier|*
name|gstdata
decl_stmt|,
modifier|*
name|lstdata
decl_stmt|;
name|GElf_Shdr
name|shy
decl_stmt|,
name|sht
decl_stmt|;
name|sy
operator|=
name|ecp
operator|->
name|symtab
expr_stmt|;
name|st
operator|=
name|ecp
operator|->
name|strtab
expr_stmt|;
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|sy
operator|->
name|os
argument_list|,
operator|&
name|shy
argument_list|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_getshdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|st
operator|->
name|os
argument_list|,
operator|&
name|sht
argument_list|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_getshdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Create two Elf_Data for .symtab section of output object, one 	 * for local symbols and another for global symbols. Note that 	 * local symbols appear first in the .symtab. 	 */
name|sy_buf
operator|=
name|sy
operator|->
name|buf
expr_stmt|;
if|if
condition|(
name|sy_buf
operator|->
name|nls
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|lsydata
operator|=
name|elf_newdata
argument_list|(
name|sy
operator|->
name|os
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_newdata() failed: %s."
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|oec
operator|==
name|ELFCLASS32
condition|)
block|{
name|lsydata
operator|->
name|d_align
operator|=
literal|4
expr_stmt|;
name|lsydata
operator|->
name|d_off
operator|=
literal|0
expr_stmt|;
name|lsydata
operator|->
name|d_buf
operator|=
name|sy_buf
operator|->
name|l32
expr_stmt|;
name|lsydata
operator|->
name|d_size
operator|=
name|sy_buf
operator|->
name|nls
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_Sym
argument_list|)
expr_stmt|;
name|lsydata
operator|->
name|d_type
operator|=
name|ELF_T_SYM
expr_stmt|;
name|lsydata
operator|->
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
block|}
else|else
block|{
name|lsydata
operator|->
name|d_align
operator|=
literal|8
expr_stmt|;
name|lsydata
operator|->
name|d_off
operator|=
literal|0
expr_stmt|;
name|lsydata
operator|->
name|d_buf
operator|=
name|sy_buf
operator|->
name|l64
expr_stmt|;
name|lsydata
operator|->
name|d_size
operator|=
name|sy_buf
operator|->
name|nls
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_Sym
argument_list|)
expr_stmt|;
name|lsydata
operator|->
name|d_type
operator|=
name|ELF_T_SYM
expr_stmt|;
name|lsydata
operator|->
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sy_buf
operator|->
name|ngs
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|gsydata
operator|=
name|elf_newdata
argument_list|(
name|sy
operator|->
name|os
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_newdata() failed: %s."
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|oec
operator|==
name|ELFCLASS32
condition|)
block|{
name|gsydata
operator|->
name|d_align
operator|=
literal|4
expr_stmt|;
name|gsydata
operator|->
name|d_off
operator|=
name|sy_buf
operator|->
name|nls
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_Sym
argument_list|)
expr_stmt|;
name|gsydata
operator|->
name|d_buf
operator|=
name|sy_buf
operator|->
name|g32
expr_stmt|;
name|gsydata
operator|->
name|d_size
operator|=
name|sy_buf
operator|->
name|ngs
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_Sym
argument_list|)
expr_stmt|;
name|gsydata
operator|->
name|d_type
operator|=
name|ELF_T_SYM
expr_stmt|;
name|gsydata
operator|->
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
block|}
else|else
block|{
name|gsydata
operator|->
name|d_align
operator|=
literal|8
expr_stmt|;
name|gsydata
operator|->
name|d_off
operator|=
name|sy_buf
operator|->
name|nls
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_Sym
argument_list|)
expr_stmt|;
name|gsydata
operator|->
name|d_buf
operator|=
name|sy_buf
operator|->
name|g64
expr_stmt|;
name|gsydata
operator|->
name|d_size
operator|=
name|sy_buf
operator|->
name|ngs
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_Sym
argument_list|)
expr_stmt|;
name|gsydata
operator|->
name|d_type
operator|=
name|ELF_T_SYM
expr_stmt|;
name|gsydata
operator|->
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
block|}
block|}
comment|/* 	 * Create two Elf_Data for .strtab, one for local symbol name 	 * and another for globals. Same as .symtab, local symbol names 	 * appear first. 	 */
name|st_buf
operator|=
name|st
operator|->
name|buf
expr_stmt|;
if|if
condition|(
operator|(
name|lstdata
operator|=
name|elf_newdata
argument_list|(
name|st
operator|->
name|os
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_newdata() failed: %s."
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|lstdata
operator|->
name|d_align
operator|=
literal|1
expr_stmt|;
name|lstdata
operator|->
name|d_off
operator|=
literal|0
expr_stmt|;
name|lstdata
operator|->
name|d_buf
operator|=
name|st_buf
operator|->
name|l
operator|.
name|buf
expr_stmt|;
name|lstdata
operator|->
name|d_size
operator|=
name|st_buf
operator|->
name|l
operator|.
name|sz
expr_stmt|;
name|lstdata
operator|->
name|d_type
operator|=
name|ELF_T_BYTE
expr_stmt|;
name|lstdata
operator|->
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
if|if
condition|(
name|st_buf
operator|->
name|g
operator|.
name|sz
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|gstdata
operator|=
name|elf_newdata
argument_list|(
name|st
operator|->
name|os
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_newdata() failed: %s."
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|gstdata
operator|->
name|d_align
operator|=
literal|1
expr_stmt|;
name|gstdata
operator|->
name|d_off
operator|=
name|lstdata
operator|->
name|d_size
expr_stmt|;
name|gstdata
operator|->
name|d_buf
operator|=
name|st_buf
operator|->
name|g
operator|.
name|buf
expr_stmt|;
name|gstdata
operator|->
name|d_size
operator|=
name|st_buf
operator|->
name|g
operator|.
name|sz
expr_stmt|;
name|gstdata
operator|->
name|d_type
operator|=
name|ELF_T_BYTE
expr_stmt|;
name|gstdata
operator|->
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
block|}
name|shy
operator|.
name|sh_addr
operator|=
literal|0
expr_stmt|;
name|shy
operator|.
name|sh_addralign
operator|=
operator|(
name|ecp
operator|->
name|oec
operator|==
name|ELFCLASS32
condition|?
literal|4
else|:
literal|8
operator|)
expr_stmt|;
name|shy
operator|.
name|sh_size
operator|=
name|sy
operator|->
name|sz
expr_stmt|;
name|shy
operator|.
name|sh_type
operator|=
name|SHT_SYMTAB
expr_stmt|;
name|shy
operator|.
name|sh_flags
operator|=
literal|0
expr_stmt|;
name|shy
operator|.
name|sh_entsize
operator|=
name|gelf_fsize
argument_list|(
name|ecp
operator|->
name|eout
argument_list|,
name|ELF_T_SYM
argument_list|,
literal|1
argument_list|,
name|EV_CURRENT
argument_list|)
expr_stmt|;
comment|/* 	 * According to SYSV abi, here sh_info is one greater than 	 * the symbol table index of the last local symbol(binding 	 * STB_LOCAL). 	 */
name|shy
operator|.
name|sh_info
operator|=
name|sy_buf
operator|->
name|nls
expr_stmt|;
name|sht
operator|.
name|sh_addr
operator|=
literal|0
expr_stmt|;
name|sht
operator|.
name|sh_addralign
operator|=
literal|1
expr_stmt|;
name|sht
operator|.
name|sh_size
operator|=
name|st
operator|->
name|sz
expr_stmt|;
name|sht
operator|.
name|sh_type
operator|=
name|SHT_STRTAB
expr_stmt|;
name|sht
operator|.
name|sh_flags
operator|=
literal|0
expr_stmt|;
name|sht
operator|.
name|sh_entsize
operator|=
literal|0
expr_stmt|;
name|sht
operator|.
name|sh_info
operator|=
literal|0
expr_stmt|;
name|sht
operator|.
name|sh_link
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|gelf_update_shdr
argument_list|(
name|sy
operator|->
name|os
argument_list|,
operator|&
name|shy
argument_list|)
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_update_shdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gelf_update_shdr
argument_list|(
name|st
operator|->
name|os
argument_list|,
operator|&
name|sht
argument_list|)
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_update_shdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_to_symop_list
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|newname
parameter_list|,
name|unsigned
name|int
name|op
parameter_list|)
block|{
name|struct
name|symop
modifier|*
name|s
decl_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|s
argument_list|,
argument|&ecp->v_symop
argument_list|,
argument|symop_list
argument_list|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|s
operator|->
name|name
argument_list|)
condition|)
goto|goto
name|found
goto|;
if|if
condition|(
operator|(
name|s
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"not enough memory"
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ecp
operator|->
name|v_symop
argument_list|,
name|s
argument_list|,
name|symop_list
argument_list|)
expr_stmt|;
name|s
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|found
label|:
if|if
condition|(
name|op
operator|==
name|SYMOP_REDEF
condition|)
name|s
operator|->
name|newname
operator|=
name|newname
expr_stmt|;
name|s
operator|->
name|op
operator||=
name|op
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|symop
modifier|*
name|lookup_symop_list
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|op
parameter_list|)
block|{
name|struct
name|symop
modifier|*
name|s
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
specifier|const
name|char
modifier|*
name|pattern
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|s
argument_list|,
argument|&ecp->v_symop
argument_list|,
argument|symop_list
argument_list|)
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|op
operator|&
name|op
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|s
operator|->
name|name
argument_list|)
condition|)
return|return
operator|(
name|s
operator|)
return|;
if|if
condition|(
operator|(
name|ecp
operator|->
name|flags
operator|&
name|WILDCARD
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Handle wildcards. */
name|pattern
operator|=
name|s
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|pattern
index|[
literal|0
index|]
operator|==
literal|'!'
condition|)
block|{
comment|/* Negative match. */
name|pattern
operator|++
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* Regular wildcard match. */
name|ret
operator|=
name|s
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fnmatch
argument_list|(
name|pattern
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lookup_exact_string
parameter_list|(
name|hash_head
modifier|*
name|buckets
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|sthash
modifier|*
name|sh
decl_stmt|;
name|uint32_t
name|hash
decl_stmt|;
name|hash
operator|=
name|str_hash
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sh
argument_list|,
argument|&buckets[hash]
argument_list|,
argument|sh_next
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|buf
operator|+
name|sh
operator|->
name|sh_off
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
return|return
name|sh
operator|->
name|sh_off
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|str_hash
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|uint32_t
name|hash
decl_stmt|;
for|for
control|(
name|hash
operator|=
literal|2166136261UL
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
name|hash
operator|=
operator|(
name|hash
operator|^
operator|*
name|s
operator|)
operator|*
literal|16777619
expr_stmt|;
return|return
operator|(
name|hash
operator|&
operator|(
name|STHASHSIZE
operator|-
literal|1
operator|)
operator|)
return|;
block|}
end_function

end_unit

