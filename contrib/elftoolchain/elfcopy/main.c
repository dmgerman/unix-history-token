begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007-2013 Kai Wang  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<libelftc.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"elfcopy.h"
end_include

begin_expr_stmt
name|ELFTC_VCSID
argument_list|(
literal|"$Id: main.c 3520 2017-04-17 01:47:52Z kaiwang27 $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_enum
enum|enum
name|options
block|{
name|ECP_ADD_GNU_DEBUGLINK
block|,
name|ECP_ADD_SECTION
block|,
name|ECP_CHANGE_ADDR
block|,
name|ECP_CHANGE_SEC_ADDR
block|,
name|ECP_CHANGE_SEC_LMA
block|,
name|ECP_CHANGE_SEC_VMA
block|,
name|ECP_CHANGE_START
block|,
name|ECP_CHANGE_WARN
block|,
name|ECP_GAP_FILL
block|,
name|ECP_GLOBALIZE_SYMBOL
block|,
name|ECP_GLOBALIZE_SYMBOLS
block|,
name|ECP_KEEP_SYMBOLS
block|,
name|ECP_KEEP_GLOBAL_SYMBOLS
block|,
name|ECP_LOCALIZE_HIDDEN
block|,
name|ECP_LOCALIZE_SYMBOLS
block|,
name|ECP_NO_CHANGE_WARN
block|,
name|ECP_ONLY_DEBUG
block|,
name|ECP_ONLY_DWO
block|,
name|ECP_PAD_TO
block|,
name|ECP_PREFIX_ALLOC
block|,
name|ECP_PREFIX_SEC
block|,
name|ECP_PREFIX_SYM
block|,
name|ECP_REDEF_SYMBOL
block|,
name|ECP_REDEF_SYMBOLS
block|,
name|ECP_RENAME_SECTION
block|,
name|ECP_SET_OSABI
block|,
name|ECP_SET_SEC_FLAGS
block|,
name|ECP_SET_START
block|,
name|ECP_SREC_FORCE_S3
block|,
name|ECP_SREC_LEN
block|,
name|ECP_STRIP_DWO
block|,
name|ECP_STRIP_SYMBOLS
block|,
name|ECP_STRIP_UNNEEDED
block|,
name|ECP_WEAKEN_ALL
block|,
name|ECP_WEAKEN_SYMBOLS
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|struct
name|option
name|mcs_longopts
index|[]
init|=
block|{
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'h'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'V'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|option
name|strip_longopts
index|[]
init|=
block|{
block|{
literal|"discard-all"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'x'
block|}
block|,
block|{
literal|"discard-locals"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'X'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'h'
block|}
block|,
block|{
literal|"input-target"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'I'
block|}
block|,
block|{
literal|"keep-symbol"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'K'
block|}
block|,
block|{
literal|"only-keep-debug"
block|,
name|no_argument
block|,
name|NULL
block|,
name|ECP_ONLY_DEBUG
block|}
block|,
block|{
literal|"output-file"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'o'
block|}
block|,
block|{
literal|"output-target"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'O'
block|}
block|,
block|{
literal|"preserve-dates"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'p'
block|}
block|,
block|{
literal|"remove-section"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'R'
block|}
block|,
block|{
literal|"strip-all"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
literal|"strip-debug"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'S'
block|}
block|,
block|{
literal|"strip-symbol"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'N'
block|}
block|,
block|{
literal|"strip-unneeded"
block|,
name|no_argument
block|,
name|NULL
block|,
name|ECP_STRIP_UNNEEDED
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'V'
block|}
block|,
block|{
literal|"wildcard"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'w'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|option
name|elfcopy_longopts
index|[]
init|=
block|{
block|{
literal|"add-gnu-debuglink"
block|,
name|required_argument
block|,
name|NULL
block|,
name|ECP_ADD_GNU_DEBUGLINK
block|}
block|,
block|{
literal|"add-section"
block|,
name|required_argument
block|,
name|NULL
block|,
name|ECP_ADD_SECTION
block|}
block|,
block|{
literal|"adjust-section-vma"
block|,
name|required_argument
block|,
name|NULL
block|,
name|ECP_CHANGE_SEC_ADDR
block|}
block|,
block|{
literal|"adjust-vma"
block|,
name|required_argument
block|,
name|NULL
block|,
name|ECP_CHANGE_ADDR
block|}
block|,
block|{
literal|"adjust-start"
block|,
name|required_argument
block|,
name|NULL
block|,
name|ECP_CHANGE_START
block|}
block|,
block|{
literal|"adjust-warnings"
block|,
name|no_argument
block|,
name|NULL
block|,
name|ECP_CHANGE_WARN
block|}
block|,
block|{
literal|"binary-architecture"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'B'
block|}
block|,
block|{
literal|"change-addresses"
block|,
name|required_argument
block|,
name|NULL
block|,
name|ECP_CHANGE_ADDR
block|}
block|,
block|{
literal|"change-section-address"
block|,
name|required_argument
block|,
name|NULL
block|,
name|ECP_CHANGE_SEC_ADDR
block|}
block|,
block|{
literal|"change-section-lma"
block|,
name|required_argument
block|,
name|NULL
block|,
name|ECP_CHANGE_SEC_LMA
block|}
block|,
block|{
literal|"change-section-vma"
block|,
name|required_argument
block|,
name|NULL
block|,
name|ECP_CHANGE_SEC_VMA
block|}
block|,
block|{
literal|"change-start"
block|,
name|required_argument
block|,
name|NULL
block|,
name|ECP_CHANGE_START
block|}
block|,
block|{
literal|"change-warnings"
block|,
name|no_argument
block|,
name|NULL
block|,
name|ECP_CHANGE_WARN
block|}
block|,
block|{
literal|"discard-all"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'x'
block|}
block|,
block|{
literal|"discard-locals"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'X'
block|}
block|,
block|{
literal|"extract-dwo"
block|,
name|no_argument
block|,
name|NULL
block|,
name|ECP_ONLY_DWO
block|}
block|,
block|{
literal|"gap-fill"
block|,
name|required_argument
block|,
name|NULL
block|,
name|ECP_GAP_FILL
block|}
block|,
block|{
literal|"globalize-symbol"
block|,
name|required_argument
block|,
name|NULL
block|,
name|ECP_GLOBALIZE_SYMBOL
block|}
block|,
block|{
literal|"globalize-symbols"
block|,
name|required_argument
block|,
name|NULL
block|,
name|ECP_GLOBALIZE_SYMBOLS
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'h'
block|}
block|,
block|{
literal|"input-target"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'I'
block|}
block|,
block|{
literal|"keep-symbol"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'K'
block|}
block|,
block|{
literal|"keep-symbols"
block|,
name|required_argument
block|,
name|NULL
block|,
name|ECP_KEEP_SYMBOLS
block|}
block|,
block|{
literal|"keep-global-symbol"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'G'
block|}
block|,
block|{
literal|"keep-global-symbols"
block|,
name|required_argument
block|,
name|NULL
block|,
name|ECP_KEEP_GLOBAL_SYMBOLS
block|}
block|,
block|{
literal|"localize-hidden"
block|,
name|no_argument
block|,
name|NULL
block|,
name|ECP_LOCALIZE_HIDDEN
block|}
block|,
block|{
literal|"localize-symbol"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'L'
block|}
block|,
block|{
literal|"localize-symbols"
block|,
name|required_argument
block|,
name|NULL
block|,
name|ECP_LOCALIZE_SYMBOLS
block|}
block|,
block|{
literal|"no-adjust-warnings"
block|,
name|no_argument
block|,
name|NULL
block|,
name|ECP_NO_CHANGE_WARN
block|}
block|,
block|{
literal|"no-change-warnings"
block|,
name|no_argument
block|,
name|NULL
block|,
name|ECP_NO_CHANGE_WARN
block|}
block|,
block|{
literal|"only-keep-debug"
block|,
name|no_argument
block|,
name|NULL
block|,
name|ECP_ONLY_DEBUG
block|}
block|,
block|{
literal|"only-section"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'j'
block|}
block|,
block|{
literal|"osabi"
block|,
name|required_argument
block|,
name|NULL
block|,
name|ECP_SET_OSABI
block|}
block|,
block|{
literal|"output-target"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'O'
block|}
block|,
block|{
literal|"pad-to"
block|,
name|required_argument
block|,
name|NULL
block|,
name|ECP_PAD_TO
block|}
block|,
block|{
literal|"preserve-dates"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'p'
block|}
block|,
block|{
literal|"prefix-alloc-sections"
block|,
name|required_argument
block|,
name|NULL
block|,
name|ECP_PREFIX_ALLOC
block|}
block|,
block|{
literal|"prefix-sections"
block|,
name|required_argument
block|,
name|NULL
block|,
name|ECP_PREFIX_SEC
block|}
block|,
block|{
literal|"prefix-symbols"
block|,
name|required_argument
block|,
name|NULL
block|,
name|ECP_PREFIX_SYM
block|}
block|,
block|{
literal|"redefine-sym"
block|,
name|required_argument
block|,
name|NULL
block|,
name|ECP_REDEF_SYMBOL
block|}
block|,
block|{
literal|"redefine-syms"
block|,
name|required_argument
block|,
name|NULL
block|,
name|ECP_REDEF_SYMBOLS
block|}
block|,
block|{
literal|"remove-section"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'R'
block|}
block|,
block|{
literal|"rename-section"
block|,
name|required_argument
block|,
name|NULL
block|,
name|ECP_RENAME_SECTION
block|}
block|,
block|{
literal|"set-section-flags"
block|,
name|required_argument
block|,
name|NULL
block|,
name|ECP_SET_SEC_FLAGS
block|}
block|,
block|{
literal|"set-start"
block|,
name|required_argument
block|,
name|NULL
block|,
name|ECP_SET_START
block|}
block|,
block|{
literal|"srec-forceS3"
block|,
name|no_argument
block|,
name|NULL
block|,
name|ECP_SREC_FORCE_S3
block|}
block|,
block|{
literal|"srec-len"
block|,
name|required_argument
block|,
name|NULL
block|,
name|ECP_SREC_LEN
block|}
block|,
block|{
literal|"strip-all"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'S'
block|}
block|,
block|{
literal|"strip-debug"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'g'
block|}
block|,
block|{
literal|"strip-dwo"
block|,
name|no_argument
block|,
name|NULL
block|,
name|ECP_STRIP_DWO
block|}
block|,
block|{
literal|"strip-symbol"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'N'
block|}
block|,
block|{
literal|"strip-symbols"
block|,
name|required_argument
block|,
name|NULL
block|,
name|ECP_STRIP_SYMBOLS
block|}
block|,
block|{
literal|"strip-unneeded"
block|,
name|no_argument
block|,
name|NULL
block|,
name|ECP_STRIP_UNNEEDED
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'V'
block|}
block|,
block|{
literal|"weaken"
block|,
name|no_argument
block|,
name|NULL
block|,
name|ECP_WEAKEN_ALL
block|}
block|,
block|{
literal|"weaken-symbol"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'W'
block|}
block|,
block|{
literal|"weaken-symbols"
block|,
name|required_argument
block|,
name|NULL
block|,
name|ECP_WEAKEN_SYMBOLS
block|}
block|,
block|{
literal|"wildcard"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'w'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
name|sec_flags
index|[]
init|=
block|{
block|{
literal|"alloc"
block|,
name|SF_ALLOC
block|}
block|,
block|{
literal|"load"
block|,
name|SF_LOAD
block|}
block|,
block|{
literal|"noload"
block|,
name|SF_NOLOAD
block|}
block|,
block|{
literal|"readonly"
block|,
name|SF_READONLY
block|}
block|,
block|{
literal|"debug"
block|,
name|SF_DEBUG
block|}
block|,
block|{
literal|"code"
block|,
name|SF_CODE
block|}
block|,
block|{
literal|"data"
block|,
name|SF_DATA
block|}
block|,
block|{
literal|"rom"
block|,
name|SF_ROM
block|}
block|,
block|{
literal|"share"
block|,
name|SF_SHARED
block|}
block|,
block|{
literal|"contents"
block|,
name|SF_CONTENTS
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_struct
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|abi
decl_stmt|;
block|}
name|osabis
index|[]
init|=
block|{
block|{
literal|"sysv"
block|,
name|ELFOSABI_SYSV
block|}
block|,
block|{
literal|"hpus"
block|,
name|ELFOSABI_HPUX
block|}
block|,
block|{
literal|"netbsd"
block|,
name|ELFOSABI_NETBSD
block|}
block|,
block|{
literal|"linux"
block|,
name|ELFOSABI_LINUX
block|}
block|,
block|{
literal|"hurd"
block|,
name|ELFOSABI_HURD
block|}
block|,
block|{
literal|"86open"
block|,
name|ELFOSABI_86OPEN
block|}
block|,
block|{
literal|"solaris"
block|,
name|ELFOSABI_SOLARIS
block|}
block|,
block|{
literal|"aix"
block|,
name|ELFOSABI_AIX
block|}
block|,
block|{
literal|"irix"
block|,
name|ELFOSABI_IRIX
block|}
block|,
block|{
literal|"freebsd"
block|,
name|ELFOSABI_FREEBSD
block|}
block|,
block|{
literal|"tru64"
block|,
name|ELFOSABI_TRU64
block|}
block|,
block|{
literal|"modesto"
block|,
name|ELFOSABI_MODESTO
block|}
block|,
block|{
literal|"openbsd"
block|,
name|ELFOSABI_OPENBSD
block|}
block|,
block|{
literal|"openvms"
block|,
name|ELFOSABI_OPENVMS
block|}
block|,
block|{
literal|"nsk"
block|,
name|ELFOSABI_NSK
block|}
block|,
block|{
literal|"cloudabi"
block|,
name|ELFOSABI_CLOUDABI
block|}
block|,
block|{
literal|"arm"
block|,
name|ELFOSABI_ARM
block|}
block|,
block|{
literal|"standalone"
block|,
name|ELFOSABI_STANDALONE
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|copy_from_tempfile
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
specifier|const
name|char
modifier|*
name|dst
parameter_list|,
name|int
name|infd
parameter_list|,
name|int
modifier|*
name|outfd
parameter_list|,
name|int
name|in_place
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|create_file
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
specifier|const
name|char
modifier|*
name|dst
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elfcopy_main
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elfcopy_usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mcs_main
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mcs_usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_sec_address_op
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|int
name|optnum
parameter_list|,
specifier|const
name|char
modifier|*
name|optname
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_sec_flags
parameter_list|(
name|struct
name|sec_action
modifier|*
name|sac
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_symlist_file
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|,
name|unsigned
name|int
name|op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_version
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_input_target
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
specifier|const
name|char
modifier|*
name|target_name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_osabi
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
specifier|const
name|char
modifier|*
name|abi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_output_target
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
specifier|const
name|char
modifier|*
name|target_name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|strip_main
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|strip_usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * An ELF object usually has a structure described by the  * diagram below.  *  _____________  * |             |  * |     NULL    |<- always a SHT_NULL section  * |_____________|  * |             |  * |   .interp   |  * |_____________|  * |             |  * |     ...     |  * |_____________|  * |             |  * |    .text    |  * |_____________|  * |             |  * |     ...     |  * |_____________|  * |             |  * |  .comment   |<- above(include) this: normal sections  * |_____________|  * |             |  * | add sections|<- unloadable sections added by --add-section  * |_____________|  * |             |  * |  .shstrtab  |<- section name string table  * |_____________|  * |             |  * |    shdrs    |<- section header table  * |_____________|  * |             |  * |   .symtab   |<- symbol table, if any  * |_____________|  * |             |  * |   .strtab   |<- symbol name string table, if any  * |_____________|  * |             |  * |  .rel.text  |<- relocation info for .o files.  * |_____________|  */
end_comment

begin_function
name|void
name|create_elf
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|shtab
decl_stmt|;
name|GElf_Ehdr
name|ieh
decl_stmt|;
name|GElf_Ehdr
name|oeh
decl_stmt|;
name|size_t
name|ishnum
decl_stmt|;
name|ecp
operator|->
name|flags
operator||=
name|SYMTAB_INTACT
expr_stmt|;
name|ecp
operator|->
name|flags
operator|&=
operator|~
name|SYMTAB_EXIST
expr_stmt|;
comment|/* Create EHDR. */
if|if
condition|(
name|gelf_getehdr
argument_list|(
name|ecp
operator|->
name|ein
argument_list|,
operator|&
name|ieh
argument_list|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_getehdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ecp
operator|->
name|iec
operator|=
name|gelf_getclass
argument_list|(
name|ecp
operator|->
name|ein
argument_list|)
operator|)
operator|==
name|ELFCLASSNONE
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"getclass() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|oec
operator|==
name|ELFCLASSNONE
condition|)
name|ecp
operator|->
name|oec
operator|=
name|ecp
operator|->
name|iec
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|oed
operator|==
name|ELFDATANONE
condition|)
name|ecp
operator|->
name|oed
operator|=
name|ieh
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
expr_stmt|;
if|if
condition|(
name|gelf_newehdr
argument_list|(
name|ecp
operator|->
name|eout
argument_list|,
name|ecp
operator|->
name|oec
argument_list|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_newehdr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gelf_getehdr
argument_list|(
name|ecp
operator|->
name|eout
argument_list|,
operator|&
name|oeh
argument_list|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_getehdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|oeh
operator|.
name|e_ident
argument_list|,
name|ieh
operator|.
name|e_ident
argument_list|,
sizeof|sizeof
argument_list|(
name|ieh
operator|.
name|e_ident
argument_list|)
argument_list|)
expr_stmt|;
name|oeh
operator|.
name|e_ident
index|[
name|EI_CLASS
index|]
operator|=
name|ecp
operator|->
name|oec
expr_stmt|;
name|oeh
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
operator|=
name|ecp
operator|->
name|oed
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|abi
operator|!=
operator|-
literal|1
condition|)
name|oeh
operator|.
name|e_ident
index|[
name|EI_OSABI
index|]
operator|=
name|ecp
operator|->
name|abi
expr_stmt|;
name|oeh
operator|.
name|e_flags
operator|=
name|ieh
operator|.
name|e_flags
expr_stmt|;
name|oeh
operator|.
name|e_machine
operator|=
name|ieh
operator|.
name|e_machine
expr_stmt|;
name|oeh
operator|.
name|e_type
operator|=
name|ieh
operator|.
name|e_type
expr_stmt|;
name|oeh
operator|.
name|e_entry
operator|=
name|ieh
operator|.
name|e_entry
expr_stmt|;
name|oeh
operator|.
name|e_version
operator|=
name|ieh
operator|.
name|e_version
expr_stmt|;
name|ecp
operator|->
name|flags
operator|&=
operator|~
operator|(
name|EXECUTABLE
operator||
name|DYNAMIC
operator||
name|RELOCATABLE
operator|)
expr_stmt|;
if|if
condition|(
name|ieh
operator|.
name|e_type
operator|==
name|ET_EXEC
condition|)
name|ecp
operator|->
name|flags
operator||=
name|EXECUTABLE
expr_stmt|;
elseif|else
if|if
condition|(
name|ieh
operator|.
name|e_type
operator|==
name|ET_DYN
condition|)
name|ecp
operator|->
name|flags
operator||=
name|DYNAMIC
expr_stmt|;
elseif|else
if|if
condition|(
name|ieh
operator|.
name|e_type
operator|==
name|ET_REL
condition|)
name|ecp
operator|->
name|flags
operator||=
name|RELOCATABLE
expr_stmt|;
else|else
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"unsupported e_type"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_getshnum
argument_list|(
name|ecp
operator|->
name|ein
argument_list|,
operator|&
name|ishnum
argument_list|)
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_getshnum failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ishnum
operator|>
literal|0
operator|&&
operator|(
name|ecp
operator|->
name|secndx
operator|=
name|calloc
argument_list|(
name|ishnum
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ecp
operator|->
name|secndx
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
comment|/* Read input object program header. */
name|setup_phdr
argument_list|(
name|ecp
argument_list|)
expr_stmt|;
comment|/* 	 * Scan of input sections: we iterate through sections from input 	 * object, skip sections need to be stripped, allot Elf_Scn and 	 * create internal section structure for sections we want. 	 * (i.e., determine output sections) 	 */
name|create_scn
argument_list|(
name|ecp
argument_list|)
expr_stmt|;
comment|/* Apply section address changes, if any. */
name|adjust_addr
argument_list|(
name|ecp
argument_list|)
expr_stmt|;
comment|/* 	 * Determine if the symbol table needs to be changed based on 	 * command line options. 	 */
if|if
condition|(
name|ecp
operator|->
name|strip
operator|==
name|STRIP_DEBUG
operator|||
name|ecp
operator|->
name|strip
operator|==
name|STRIP_UNNEEDED
operator|||
name|ecp
operator|->
name|flags
operator|&
name|WEAKEN_ALL
operator|||
name|ecp
operator|->
name|flags
operator|&
name|LOCALIZE_HIDDEN
operator|||
name|ecp
operator|->
name|flags
operator|&
name|DISCARD_LOCAL
operator|||
name|ecp
operator|->
name|flags
operator|&
name|DISCARD_LLABEL
operator|||
name|ecp
operator|->
name|prefix_sym
operator|!=
name|NULL
operator|||
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|ecp
operator|->
name|v_symop
argument_list|)
condition|)
name|ecp
operator|->
name|flags
operator|&=
operator|~
name|SYMTAB_INTACT
expr_stmt|;
comment|/* 	 * Create symbol table. Symbols are filtered or stripped according to 	 * command line args specified by user, and later updated for the new 	 * layout of sections in the output object. 	 */
if|if
condition|(
operator|(
name|ecp
operator|->
name|flags
operator|&
name|SYMTAB_EXIST
operator|)
operator|!=
literal|0
condition|)
name|create_symtab
argument_list|(
name|ecp
argument_list|)
expr_stmt|;
comment|/* 	 * First processing of output sections: at this stage we copy the 	 * content of each section from input to output object.  Section 	 * content will be modified and printed (mcs) if need. Also content of 	 * relocation section probably will be filtered and updated according 	 * to symbol table changes. 	 */
name|copy_content
argument_list|(
name|ecp
argument_list|)
expr_stmt|;
comment|/* 	 * Write the underlying ehdr. Note that it should be called 	 * before elf_setshstrndx() since it will overwrite e->e_shstrndx. 	 */
if|if
condition|(
name|gelf_update_ehdr
argument_list|(
name|ecp
operator|->
name|eout
argument_list|,
operator|&
name|oeh
argument_list|)
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_update_ehdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Generate section name string table (.shstrtab). */
name|set_shstrtab
argument_list|(
name|ecp
argument_list|)
expr_stmt|;
comment|/* 	 * Second processing of output sections: Update section headers. 	 * At this stage we set name string index, update st_link and st_info 	 * for output sections. 	 */
name|update_shdr
argument_list|(
name|ecp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Renew oeh to get the updated e_shstrndx. */
if|if
condition|(
name|gelf_getehdr
argument_list|(
name|ecp
operator|->
name|eout
argument_list|,
operator|&
name|oeh
argument_list|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_getehdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Insert SHDR table into the internal section list as a "pseudo" 	 * section, so later it will get sorted and resynced just as "normal" 	 * sections. 	 * 	 * Under FreeBSD, Binutils objcopy always put the section header 	 * at the end of all the sections. We want to do the same here. 	 * 	 * However, note that the behaviour is still different with Binutils: 	 * elfcopy checks the FreeBSD OSABI tag to tell whether it needs to 	 * move the section headers, while Binutils is probably configured 	 * this way when it's compiled on FreeBSD. 	 */
if|if
condition|(
name|oeh
operator|.
name|e_ident
index|[
name|EI_OSABI
index|]
operator|==
name|ELFOSABI_FREEBSD
condition|)
name|shtab
operator|=
name|insert_shtab
argument_list|(
name|ecp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|shtab
operator|=
name|insert_shtab
argument_list|(
name|ecp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Resync section offsets in the output object. This is needed 	 * because probably sections are modified or new sections are added, 	 * as a result overlap/gap might appears. 	 */
name|resync_sections
argument_list|(
name|ecp
argument_list|)
expr_stmt|;
comment|/* Store SHDR offset in EHDR. */
name|oeh
operator|.
name|e_shoff
operator|=
name|shtab
operator|->
name|off
expr_stmt|;
comment|/* Put program header table immediately after the Elf header. */
if|if
condition|(
name|ecp
operator|->
name|ophnum
operator|>
literal|0
condition|)
block|{
name|oeh
operator|.
name|e_phoff
operator|=
name|gelf_fsize
argument_list|(
name|ecp
operator|->
name|eout
argument_list|,
name|ELF_T_EHDR
argument_list|,
literal|1
argument_list|,
name|EV_CURRENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|oeh
operator|.
name|e_phoff
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_fsize() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Update ELF object entry point if requested. 	 */
if|if
condition|(
name|ecp
operator|->
name|change_addr
operator|!=
literal|0
condition|)
name|oeh
operator|.
name|e_entry
operator|+=
name|ecp
operator|->
name|change_addr
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|flags
operator|&
name|SET_START
condition|)
name|oeh
operator|.
name|e_entry
operator|=
name|ecp
operator|->
name|set_start
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|change_start
operator|!=
literal|0
condition|)
name|oeh
operator|.
name|e_entry
operator|+=
name|ecp
operator|->
name|change_start
expr_stmt|;
comment|/* 	 * Update ehdr again before we call elf_update(), since we 	 * modified e_shoff and e_phoff. 	 */
if|if
condition|(
name|gelf_update_ehdr
argument_list|(
name|ecp
operator|->
name|eout
argument_list|,
operator|&
name|oeh
argument_list|)
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_update_ehdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|ophnum
operator|>
literal|0
condition|)
name|copy_phdr
argument_list|(
name|ecp
argument_list|)
expr_stmt|;
comment|/* Write out the output elf object. */
if|if
condition|(
name|elf_update
argument_list|(
name|ecp
operator|->
name|eout
argument_list|,
name|ELF_C_WRITE
argument_list|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_update() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Release allocated resource. */
name|free_elf
argument_list|(
name|ecp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|free_elf
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|)
block|{
name|struct
name|segment
modifier|*
name|seg
decl_stmt|,
modifier|*
name|seg_temp
decl_stmt|;
name|struct
name|section
modifier|*
name|sec
decl_stmt|,
modifier|*
name|sec_temp
decl_stmt|;
comment|/* Free internal segment list. */
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|ecp
operator|->
name|v_seg
argument_list|)
condition|)
block|{
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|seg
argument_list|,
argument|&ecp->v_seg
argument_list|,
argument|seg_list
argument_list|,
argument|seg_temp
argument_list|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|ecp
operator|->
name|v_seg
argument_list|,
name|seg
argument_list|,
name|segment
argument_list|,
name|seg_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|seg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Free symbol table buffers. */
name|free_symtab
argument_list|(
name|ecp
argument_list|)
expr_stmt|;
comment|/* Free internal section list. */
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ecp
operator|->
name|v_sec
argument_list|)
condition|)
block|{
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|sec
argument_list|,
argument|&ecp->v_sec
argument_list|,
argument|sec_list
argument_list|,
argument|sec_temp
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ecp
operator|->
name|v_sec
argument_list|,
name|sec
argument_list|,
name|sec_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sec
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|newname
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sec
operator|->
name|newname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|pad
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sec
operator|->
name|pad
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sec
argument_list|)
expr_stmt|;
block|}
block|}
name|ecp
operator|->
name|symtab
operator|=
name|NULL
expr_stmt|;
name|ecp
operator|->
name|strtab
operator|=
name|NULL
expr_stmt|;
name|ecp
operator|->
name|shstrtab
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|secndx
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ecp
operator|->
name|secndx
argument_list|)
expr_stmt|;
name|ecp
operator|->
name|secndx
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create a temporary file. */
end_comment

begin_function
name|void
name|create_tempfile
parameter_list|(
name|char
modifier|*
modifier|*
name|fn
parameter_list|,
name|int
modifier|*
name|fd
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|tmpdir
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|tmpf
decl_stmt|;
name|size_t
name|tlen
decl_stmt|,
name|plen
decl_stmt|;
define|#
directive|define
name|_TEMPFILE
value|"ecp.XXXXXXXX"
define|#
directive|define
name|_TEMPFILEPATH
value|"/tmp/ecp.XXXXXXXX"
if|if
condition|(
name|fn
operator|==
name|NULL
operator|||
name|fd
operator|==
name|NULL
condition|)
return|return;
comment|/* Repect TMPDIR environment variable. */
name|tmpdir
operator|=
name|getenv
argument_list|(
literal|"TMPDIR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpdir
operator|!=
name|NULL
operator|&&
operator|*
name|tmpdir
operator|!=
literal|'\0'
condition|)
block|{
name|tlen
operator|=
name|strlen
argument_list|(
name|tmpdir
argument_list|)
expr_stmt|;
name|plen
operator|=
name|strlen
argument_list|(
name|_TEMPFILE
argument_list|)
expr_stmt|;
name|tmpf
operator|=
name|malloc
argument_list|(
name|tlen
operator|+
name|plen
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpf
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|tmpf
argument_list|,
name|tmpdir
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|tmpf
index|[
name|tlen
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'/'
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'/'
expr_stmt|;
name|strncpy
argument_list|(
name|cp
argument_list|,
name|_TEMPFILE
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|cp
index|[
name|plen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|tmpf
operator|=
name|strdup
argument_list|(
name|_TEMPFILEPATH
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpf
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"strdup failed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|fd
operator|=
name|mkstemp
argument_list|(
name|tmpf
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"mkstemp %s failed"
argument_list|,
name|tmpf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fchmod
argument_list|(
operator|*
name|fd
argument_list|,
literal|0644
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"fchmod %s failed"
argument_list|,
name|tmpf
argument_list|)
expr_stmt|;
operator|*
name|fn
operator|=
name|tmpf
expr_stmt|;
undef|#
directive|undef
name|_TEMPFILE
undef|#
directive|undef
name|_TEMPFILEPATH
block|}
end_function

begin_comment
comment|/*  * Copy temporary file with path src and file descriptor infd to path dst.  * If in_place is set act as if editing the file in place, avoiding rename()  * to preserve hard and symbolic links. Output file remains open, with file  * descriptor returned in outfd.  */
end_comment

begin_function
specifier|static
name|int
name|copy_from_tempfile
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
specifier|const
name|char
modifier|*
name|dst
parameter_list|,
name|int
name|infd
parameter_list|,
name|int
modifier|*
name|outfd
parameter_list|,
name|int
name|in_place
parameter_list|)
block|{
name|int
name|tmpfd
decl_stmt|;
comment|/* 	 * First, check if we can use rename(). 	 */
if|if
condition|(
name|in_place
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rename
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
operator|>=
literal|0
condition|)
block|{
operator|*
name|outfd
operator|=
name|infd
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|!=
name|EXDEV
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 		 * If the rename() failed due to 'src' and 'dst' residing in 		 * two different file systems, invoke a helper function in 		 * libelftc to do the copy. 		 */
if|if
condition|(
name|unlink
argument_list|(
name|dst
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|tmpfd
operator|=
name|open
argument_list|(
name|dst
argument_list|,
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|O_WRONLY
argument_list|,
literal|0755
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|elftc_copyfile
argument_list|(
name|infd
argument_list|,
name|tmpfd
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Remove the temporary file from the file system 	 * namespace, and close its file descriptor. 	 */
if|if
condition|(
name|unlink
argument_list|(
name|src
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|infd
argument_list|)
expr_stmt|;
comment|/* 	 * Return the file descriptor for the destination. 	 */
operator|*
name|outfd
operator|=
name|tmpfd
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|create_file
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
specifier|const
name|char
modifier|*
name|dst
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|char
modifier|*
name|tempfile
decl_stmt|,
modifier|*
name|elftemp
decl_stmt|;
name|int
name|efd
decl_stmt|,
name|ifd
decl_stmt|,
name|ofd
decl_stmt|,
name|ofd0
decl_stmt|,
name|tfd
decl_stmt|;
name|int
name|in_place
decl_stmt|;
name|tempfile
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|src
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"internal: src == NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifd
operator|=
name|open
argument_list|(
name|src
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"open %s failed"
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|ifd
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"fstat %s failed"
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|NULL
condition|)
name|create_tempfile
argument_list|(
operator|&
name|tempfile
argument_list|,
operator|&
name|ofd
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ofd
operator|=
name|open
argument_list|(
name|dst
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|0755
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"open %s failed"
argument_list|,
name|dst
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|LIBELF_AR
comment|/* Detect and process ar(1) archive using libarchive. */
if|if
condition|(
name|ac_detect_ar
argument_list|(
name|ifd
argument_list|)
condition|)
block|{
name|ac_create_ar
argument_list|(
name|ecp
argument_list|,
name|ifd
argument_list|,
name|ofd
argument_list|)
expr_stmt|;
goto|goto
name|copy_done
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
name|lseek
argument_list|(
name|ifd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"lseek failed"
argument_list|)
expr_stmt|;
comment|/* 	 * If input object is not ELF file, convert it to an intermediate 	 * ELF object before processing. 	 */
if|if
condition|(
name|ecp
operator|->
name|itf
operator|!=
name|ETF_ELF
condition|)
block|{
comment|/* 		 * If the output object is not an ELF file, choose an arbitrary 		 * ELF format for the intermediate file. srec, ihex and binary 		 * formats are independent of class, endianness and machine 		 * type so these choices do not affect the output. 		 */
if|if
condition|(
name|ecp
operator|->
name|otf
operator|!=
name|ETF_ELF
condition|)
block|{
if|if
condition|(
name|ecp
operator|->
name|oec
operator|==
name|ELFCLASSNONE
condition|)
name|ecp
operator|->
name|oec
operator|=
name|ELFCLASS64
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|oed
operator|==
name|ELFDATANONE
condition|)
name|ecp
operator|->
name|oed
operator|=
name|ELFDATA2LSB
expr_stmt|;
block|}
name|create_tempfile
argument_list|(
operator|&
name|elftemp
argument_list|,
operator|&
name|efd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ecp
operator|->
name|eout
operator|=
name|elf_begin
argument_list|(
name|efd
argument_list|,
name|ELF_C_WRITE
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_begin() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|elf_flagelf
argument_list|(
name|ecp
operator|->
name|eout
argument_list|,
name|ELF_C_SET
argument_list|,
name|ELF_F_LAYOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|itf
operator|==
name|ETF_BINARY
condition|)
name|create_elf_from_binary
argument_list|(
name|ecp
argument_list|,
name|ifd
argument_list|,
name|src
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ecp
operator|->
name|itf
operator|==
name|ETF_IHEX
condition|)
name|create_elf_from_ihex
argument_list|(
name|ecp
argument_list|,
name|ifd
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ecp
operator|->
name|itf
operator|==
name|ETF_SREC
condition|)
name|create_elf_from_srec
argument_list|(
name|ecp
argument_list|,
name|ifd
argument_list|)
expr_stmt|;
else|else
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"Internal: invalid target flavour"
argument_list|)
expr_stmt|;
name|elf_end
argument_list|(
name|ecp
operator|->
name|eout
argument_list|)
expr_stmt|;
comment|/* Open intermediate ELF object as new input object. */
name|close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifd
operator|=
name|open
argument_list|(
name|elftemp
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"open %s failed"
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|efd
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|elftemp
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"unlink %s failed"
argument_list|,
name|elftemp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|elftemp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ecp
operator|->
name|ein
operator|=
name|elf_begin
argument_list|(
name|ifd
argument_list|,
name|ELF_C_READ
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_begin() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|elf_kind
argument_list|(
name|ecp
operator|->
name|ein
argument_list|)
condition|)
block|{
case|case
name|ELF_K_NONE
case|:
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"file format not recognized"
argument_list|)
expr_stmt|;
case|case
name|ELF_K_ELF
case|:
if|if
condition|(
operator|(
name|ecp
operator|->
name|eout
operator|=
name|elf_begin
argument_list|(
name|ofd
argument_list|,
name|ELF_C_WRITE
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_begin() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* elfcopy(1) manage ELF layout by itself. */
name|elf_flagelf
argument_list|(
name|ecp
operator|->
name|eout
argument_list|,
name|ELF_C_SET
argument_list|,
name|ELF_F_LAYOUT
argument_list|)
expr_stmt|;
comment|/* 		 * Create output ELF object. 		 */
name|create_elf
argument_list|(
name|ecp
argument_list|)
expr_stmt|;
name|elf_end
argument_list|(
name|ecp
operator|->
name|eout
argument_list|)
expr_stmt|;
comment|/* 		 * Convert the output ELF object to binary/srec/ihex if need. 		 */
if|if
condition|(
name|ecp
operator|->
name|otf
operator|!=
name|ETF_ELF
condition|)
block|{
comment|/* 			 * Create (another) tempfile for binary/srec/ihex 			 * output object. 			 */
if|if
condition|(
name|tempfile
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|unlink
argument_list|(
name|tempfile
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"unlink %s failed"
argument_list|,
name|tempfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
block|}
name|create_tempfile
argument_list|(
operator|&
name|tempfile
argument_list|,
operator|&
name|ofd0
argument_list|)
expr_stmt|;
comment|/* 			 * Rewind the file descriptor being processed. 			 */
if|if
condition|(
name|lseek
argument_list|(
name|ofd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"lseek failed for the output object"
argument_list|)
expr_stmt|;
comment|/* 			 * Call flavour-specific conversion routine. 			 */
switch|switch
condition|(
name|ecp
operator|->
name|otf
condition|)
block|{
case|case
name|ETF_BINARY
case|:
name|create_binary
argument_list|(
name|ofd
argument_list|,
name|ofd0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ETF_IHEX
case|:
name|create_ihex
argument_list|(
name|ofd
argument_list|,
name|ofd0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ETF_SREC
case|:
name|create_srec
argument_list|(
name|ecp
argument_list|,
name|ofd
argument_list|,
name|ofd0
argument_list|,
name|dst
operator|!=
name|NULL
condition|?
name|dst
else|:
name|src
argument_list|)
expr_stmt|;
break|break;
case|case
name|ETF_PE
case|:
case|case
name|ETF_EFI
case|:
if|#
directive|if
name|WITH_PE
name|create_pe
argument_list|(
name|ecp
argument_list|,
name|ofd
argument_list|,
name|ofd0
argument_list|)
expr_stmt|;
else|#
directive|else
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"PE/EFI support not enabled"
literal|" at compile time"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"Internal: unsupported"
literal|" output flavour %d"
argument_list|,
name|ecp
operator|->
name|oec
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|ofd
argument_list|)
expr_stmt|;
name|ofd
operator|=
name|ofd0
expr_stmt|;
block|}
break|break;
case|case
name|ELF_K_AR
case|:
comment|/* XXX: Not yet supported. */
break|break;
default|default:
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"file format not supported"
argument_list|)
expr_stmt|;
block|}
name|elf_end
argument_list|(
name|ecp
operator|->
name|ein
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|LIBELF_AR
name|copy_done
label|:
endif|#
directive|endif
if|if
condition|(
name|tempfile
operator|!=
name|NULL
condition|)
block|{
name|in_place
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|NULL
condition|)
block|{
name|dst
operator|=
name|src
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|dst
argument_list|,
operator|&
name|sb
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|sb
operator|.
name|st_nlink
operator|>
literal|1
operator|||
name|S_ISLNK
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
name|in_place
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|copy_from_tempfile
argument_list|(
name|tempfile
argument_list|,
name|dst
argument_list|,
name|ofd
argument_list|,
operator|&
name|tfd
argument_list|,
name|in_place
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"creation of %s failed"
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
name|tempfile
operator|=
name|NULL
expr_stmt|;
name|ofd
operator|=
name|tfd
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|dst
argument_list|,
literal|"/dev/null"
argument_list|)
operator|&&
name|fchmod
argument_list|(
name|ofd
argument_list|,
name|sb
operator|.
name|st_mode
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"fchmod %s failed"
argument_list|,
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ecp
operator|->
name|flags
operator|&
name|PRESERVE_DATE
operator|)
operator|&&
name|elftc_set_timestamps
argument_list|(
name|dst
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"setting timestamps failed"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ofd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elfcopy_main
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|sec_action
modifier|*
name|sac
decl_stmt|;
specifier|const
name|char
modifier|*
name|infile
decl_stmt|,
modifier|*
name|outfile
decl_stmt|;
name|char
modifier|*
name|fn
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|int
name|opt
decl_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"dB:gG:I:j:K:L:N:O:pR:s:SwW:xXV"
argument_list|,
name|elfcopy_longopts
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'B'
case|:
comment|/* ignored */
break|break;
case|case
literal|'R'
case|:
name|sac
operator|=
name|lookup_sec_act
argument_list|(
name|ecp
argument_list|,
name|optarg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sac
operator|->
name|copy
operator|!=
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"both copy and remove specified"
argument_list|)
expr_stmt|;
name|sac
operator|->
name|remove
operator|=
literal|1
expr_stmt|;
name|ecp
operator|->
name|flags
operator||=
name|SEC_REMOVE
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|ecp
operator|->
name|strip
operator|=
name|STRIP_ALL
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|ecp
operator|->
name|strip
operator|=
name|STRIP_DEBUG
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|ecp
operator|->
name|flags
operator||=
name|KEEP_GLOBAL
expr_stmt|;
name|add_to_symop_list
argument_list|(
name|ecp
argument_list|,
name|optarg
argument_list|,
name|NULL
argument_list|,
name|SYMOP_KEEPG
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
case|case
literal|'s'
case|:
name|set_input_target
argument_list|(
name|ecp
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|sac
operator|=
name|lookup_sec_act
argument_list|(
name|ecp
argument_list|,
name|optarg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sac
operator|->
name|remove
operator|!=
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"both copy and remove specified"
argument_list|)
expr_stmt|;
name|sac
operator|->
name|copy
operator|=
literal|1
expr_stmt|;
name|ecp
operator|->
name|flags
operator||=
name|SEC_COPY
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|add_to_symop_list
argument_list|(
name|ecp
argument_list|,
name|optarg
argument_list|,
name|NULL
argument_list|,
name|SYMOP_KEEP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|add_to_symop_list
argument_list|(
name|ecp
argument_list|,
name|optarg
argument_list|,
name|NULL
argument_list|,
name|SYMOP_LOCALIZE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|add_to_symop_list
argument_list|(
name|ecp
argument_list|,
name|optarg
argument_list|,
name|NULL
argument_list|,
name|SYMOP_STRIP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|set_output_target
argument_list|(
name|ecp
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|ecp
operator|->
name|flags
operator||=
name|PRESERVE_DATE
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|print_version
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|ecp
operator|->
name|flags
operator||=
name|WILDCARD
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|add_to_symop_list
argument_list|(
name|ecp
argument_list|,
name|optarg
argument_list|,
name|NULL
argument_list|,
name|SYMOP_WEAKEN
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|ecp
operator|->
name|flags
operator||=
name|DISCARD_LOCAL
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|ecp
operator|->
name|flags
operator||=
name|DISCARD_LLABEL
expr_stmt|;
break|break;
case|case
name|ECP_ADD_GNU_DEBUGLINK
case|:
name|ecp
operator|->
name|debuglink
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|ECP_ADD_SECTION
case|:
name|add_section
argument_list|(
name|ecp
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECP_CHANGE_ADDR
case|:
name|ecp
operator|->
name|change_addr
operator|=
operator|(
name|int64_t
operator|)
name|strtoll
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECP_CHANGE_SEC_ADDR
case|:
name|parse_sec_address_op
argument_list|(
name|ecp
argument_list|,
name|opt
argument_list|,
literal|"--change-section-addr"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECP_CHANGE_SEC_LMA
case|:
name|parse_sec_address_op
argument_list|(
name|ecp
argument_list|,
name|opt
argument_list|,
literal|"--change-section-lma"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECP_CHANGE_SEC_VMA
case|:
name|parse_sec_address_op
argument_list|(
name|ecp
argument_list|,
name|opt
argument_list|,
literal|"--change-section-vma"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECP_CHANGE_START
case|:
name|ecp
operator|->
name|change_start
operator|=
operator|(
name|int64_t
operator|)
name|strtoll
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECP_CHANGE_WARN
case|:
comment|/* default */
break|break;
case|case
name|ECP_GAP_FILL
case|:
name|ecp
operator|->
name|fill
operator|=
operator|(
name|uint8_t
operator|)
name|strtoul
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecp
operator|->
name|flags
operator||=
name|GAP_FILL
expr_stmt|;
break|break;
case|case
name|ECP_GLOBALIZE_SYMBOL
case|:
name|add_to_symop_list
argument_list|(
name|ecp
argument_list|,
name|optarg
argument_list|,
name|NULL
argument_list|,
name|SYMOP_GLOBALIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECP_GLOBALIZE_SYMBOLS
case|:
name|parse_symlist_file
argument_list|(
name|ecp
argument_list|,
name|optarg
argument_list|,
name|SYMOP_GLOBALIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECP_KEEP_SYMBOLS
case|:
name|parse_symlist_file
argument_list|(
name|ecp
argument_list|,
name|optarg
argument_list|,
name|SYMOP_KEEP
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECP_KEEP_GLOBAL_SYMBOLS
case|:
name|parse_symlist_file
argument_list|(
name|ecp
argument_list|,
name|optarg
argument_list|,
name|SYMOP_KEEPG
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECP_LOCALIZE_HIDDEN
case|:
name|ecp
operator|->
name|flags
operator||=
name|LOCALIZE_HIDDEN
expr_stmt|;
break|break;
case|case
name|ECP_LOCALIZE_SYMBOLS
case|:
name|parse_symlist_file
argument_list|(
name|ecp
argument_list|,
name|optarg
argument_list|,
name|SYMOP_LOCALIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECP_NO_CHANGE_WARN
case|:
name|ecp
operator|->
name|flags
operator||=
name|NO_CHANGE_WARN
expr_stmt|;
break|break;
case|case
name|ECP_ONLY_DEBUG
case|:
name|ecp
operator|->
name|strip
operator|=
name|STRIP_NONDEBUG
expr_stmt|;
break|break;
case|case
name|ECP_ONLY_DWO
case|:
name|ecp
operator|->
name|strip
operator|=
name|STRIP_NONDWO
expr_stmt|;
break|break;
case|case
name|ECP_PAD_TO
case|:
name|ecp
operator|->
name|pad_to
operator|=
operator|(
name|uint64_t
operator|)
name|strtoull
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECP_PREFIX_ALLOC
case|:
name|ecp
operator|->
name|prefix_alloc
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|ECP_PREFIX_SEC
case|:
name|ecp
operator|->
name|prefix_sec
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|ECP_PREFIX_SYM
case|:
name|ecp
operator|->
name|prefix_sym
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|ECP_REDEF_SYMBOL
case|:
if|if
condition|(
operator|(
name|s
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'='
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"illegal format for --redefine-sym"
argument_list|)
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|add_to_symop_list
argument_list|(
name|ecp
argument_list|,
name|optarg
argument_list|,
name|s
argument_list|,
name|SYMOP_REDEF
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECP_REDEF_SYMBOLS
case|:
name|parse_symlist_file
argument_list|(
name|ecp
argument_list|,
name|optarg
argument_list|,
name|SYMOP_REDEF
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECP_RENAME_SECTION
case|:
if|if
condition|(
operator|(
name|fn
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'='
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"illegal format for --rename-section"
argument_list|)
expr_stmt|;
operator|*
name|fn
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Check for optional flags. */
if|if
condition|(
operator|(
name|s
operator|=
name|strchr
argument_list|(
name|fn
argument_list|,
literal|','
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|sac
operator|=
name|lookup_sec_act
argument_list|(
name|ecp
argument_list|,
name|optarg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sac
operator|->
name|rename
operator|=
literal|1
expr_stmt|;
name|sac
operator|->
name|newname
operator|=
name|fn
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|parse_sec_flags
argument_list|(
name|sac
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECP_SET_OSABI
case|:
name|set_osabi
argument_list|(
name|ecp
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECP_SET_SEC_FLAGS
case|:
if|if
condition|(
operator|(
name|s
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'='
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"illegal format for --set-section-flags"
argument_list|)
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|sac
operator|=
name|lookup_sec_act
argument_list|(
name|ecp
argument_list|,
name|optarg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|parse_sec_flags
argument_list|(
name|sac
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECP_SET_START
case|:
name|ecp
operator|->
name|flags
operator||=
name|SET_START
expr_stmt|;
name|ecp
operator|->
name|set_start
operator|=
operator|(
name|uint64_t
operator|)
name|strtoull
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECP_SREC_FORCE_S3
case|:
name|ecp
operator|->
name|flags
operator||=
name|SREC_FORCE_S3
expr_stmt|;
break|break;
case|case
name|ECP_SREC_LEN
case|:
name|ecp
operator|->
name|flags
operator||=
name|SREC_FORCE_LEN
expr_stmt|;
name|ecp
operator|->
name|srec_len
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECP_STRIP_DWO
case|:
name|ecp
operator|->
name|strip
operator|=
name|STRIP_DWO
expr_stmt|;
break|break;
case|case
name|ECP_STRIP_SYMBOLS
case|:
name|parse_symlist_file
argument_list|(
name|ecp
argument_list|,
name|optarg
argument_list|,
name|SYMOP_STRIP
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECP_STRIP_UNNEEDED
case|:
name|ecp
operator|->
name|strip
operator|=
name|STRIP_UNNEEDED
expr_stmt|;
break|break;
case|case
name|ECP_WEAKEN_ALL
case|:
name|ecp
operator|->
name|flags
operator||=
name|WEAKEN_ALL
expr_stmt|;
break|break;
case|case
name|ECP_WEAKEN_SYMBOLS
case|:
name|parse_symlist_file
argument_list|(
name|ecp
argument_list|,
name|optarg
argument_list|,
name|SYMOP_WEAKEN
argument_list|)
expr_stmt|;
break|break;
default|default:
name|elfcopy_usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|optind
operator|==
name|argc
operator|||
name|optind
operator|+
literal|2
operator|<
name|argc
condition|)
name|elfcopy_usage
argument_list|()
expr_stmt|;
name|infile
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
name|outfile
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|optind
operator|+
literal|1
operator|<
name|argc
condition|)
name|outfile
operator|=
name|argv
index|[
name|optind
operator|+
literal|1
index|]
expr_stmt|;
name|create_file
argument_list|(
name|ecp
argument_list|,
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mcs_main
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|sec_action
modifier|*
name|sac
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|append
decl_stmt|,
name|delete
decl_stmt|,
name|compress
decl_stmt|,
name|name
decl_stmt|,
name|print
decl_stmt|;
name|int
name|opt
decl_stmt|,
name|i
decl_stmt|;
name|append
operator|=
name|delete
operator|=
name|compress
operator|=
name|name
operator|=
name|print
operator|=
literal|0
expr_stmt|;
name|string
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"a:cdhn:pV"
argument_list|,
name|mcs_longopts
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'a'
case|:
name|append
operator|=
literal|1
expr_stmt|;
name|string
operator|=
name|optarg
expr_stmt|;
comment|/* XXX multiple -a not supported */
break|break;
case|case
literal|'c'
case|:
name|compress
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|delete
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|name
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|lookup_sec_act
argument_list|(
name|ecp
argument_list|,
name|optarg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|print
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|print_version
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
default|default:
name|mcs_usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
name|mcs_usage
argument_list|()
expr_stmt|;
comment|/* Must specify one operation at least. */
if|if
condition|(
operator|!
name|append
operator|&&
operator|!
name|compress
operator|&&
operator|!
name|delete
operator|&&
operator|!
name|print
condition|)
name|mcs_usage
argument_list|()
expr_stmt|;
comment|/* 	 * If we are going to delete, ignore other operations. This is 	 * different from the Solaris implementation, which can print 	 * and delete a section at the same time, for example. Also, this 	 * implementation do not respect the order between operations that 	 * user specified, i.e., "mcs -pc a.out" equals to "mcs -cp a.out". 	 */
if|if
condition|(
name|delete
condition|)
block|{
name|append
operator|=
name|compress
operator|=
name|print
operator|=
literal|0
expr_stmt|;
name|ecp
operator|->
name|flags
operator||=
name|SEC_REMOVE
expr_stmt|;
block|}
if|if
condition|(
name|append
condition|)
name|ecp
operator|->
name|flags
operator||=
name|SEC_APPEND
expr_stmt|;
if|if
condition|(
name|compress
condition|)
name|ecp
operator|->
name|flags
operator||=
name|SEC_COMPRESS
expr_stmt|;
if|if
condition|(
name|print
condition|)
name|ecp
operator|->
name|flags
operator||=
name|SEC_PRINT
expr_stmt|;
comment|/* .comment is the default section to operate on. */
if|if
condition|(
operator|!
name|name
condition|)
operator|(
name|void
operator|)
name|lookup_sec_act
argument_list|(
name|ecp
argument_list|,
literal|".comment"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|sac
argument_list|,
argument|&ecp->v_sac
argument_list|,
argument|sac_list
argument_list|)
block|{
name|sac
operator|->
name|append
operator|=
name|append
expr_stmt|;
name|sac
operator|->
name|compress
operator|=
name|compress
expr_stmt|;
name|sac
operator|->
name|print
operator|=
name|print
expr_stmt|;
name|sac
operator|->
name|remove
operator|=
name|delete
expr_stmt|;
name|sac
operator|->
name|string
operator|=
name|string
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|optind
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
comment|/* If only -p is specified, output to /dev/null */
if|if
condition|(
name|print
operator|&&
operator|!
name|append
operator|&&
operator|!
name|compress
operator|&&
operator|!
name|delete
condition|)
name|create_file
argument_list|(
name|ecp
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
literal|"/dev/null"
argument_list|)
expr_stmt|;
else|else
name|create_file
argument_list|(
name|ecp
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|strip_main
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|sec_action
modifier|*
name|sac
decl_stmt|;
specifier|const
name|char
modifier|*
name|outfile
decl_stmt|;
name|int
name|opt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|outfile
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"hI:K:N:o:O:pR:sSdgVxXw"
argument_list|,
name|strip_longopts
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'R'
case|:
name|sac
operator|=
name|lookup_sec_act
argument_list|(
name|ecp
argument_list|,
name|optarg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sac
operator|->
name|remove
operator|=
literal|1
expr_stmt|;
name|ecp
operator|->
name|flags
operator||=
name|SEC_REMOVE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|ecp
operator|->
name|strip
operator|=
name|STRIP_ALL
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
case|case
literal|'g'
case|:
case|case
literal|'d'
case|:
name|ecp
operator|->
name|strip
operator|=
name|STRIP_DEBUG
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* ignored */
break|break;
case|case
literal|'K'
case|:
name|add_to_symop_list
argument_list|(
name|ecp
argument_list|,
name|optarg
argument_list|,
name|NULL
argument_list|,
name|SYMOP_KEEP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|add_to_symop_list
argument_list|(
name|ecp
argument_list|,
name|optarg
argument_list|,
name|NULL
argument_list|,
name|SYMOP_STRIP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|outfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|set_output_target
argument_list|(
name|ecp
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|ecp
operator|->
name|flags
operator||=
name|PRESERVE_DATE
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|print_version
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|ecp
operator|->
name|flags
operator||=
name|WILDCARD
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|ecp
operator|->
name|flags
operator||=
name|DISCARD_LOCAL
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|ecp
operator|->
name|flags
operator||=
name|DISCARD_LLABEL
expr_stmt|;
break|break;
case|case
name|ECP_ONLY_DEBUG
case|:
name|ecp
operator|->
name|strip
operator|=
name|STRIP_NONDEBUG
expr_stmt|;
break|break;
case|case
name|ECP_STRIP_UNNEEDED
case|:
name|ecp
operator|->
name|strip
operator|=
name|STRIP_UNNEEDED
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
default|default:
name|strip_usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ecp
operator|->
name|strip
operator|==
literal|0
operator|&&
operator|(
operator|(
name|ecp
operator|->
name|flags
operator|&
name|DISCARD_LOCAL
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|ecp
operator|->
name|flags
operator|&
name|DISCARD_LLABEL
operator|)
operator|==
literal|0
operator|)
operator|&&
name|lookup_symop_list
argument_list|(
name|ecp
argument_list|,
name|NULL
argument_list|,
name|SYMOP_STRIP
argument_list|)
operator|==
name|NULL
condition|)
name|ecp
operator|->
name|strip
operator|=
name|STRIP_ALL
expr_stmt|;
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
name|strip_usage
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|optind
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|create_file
argument_list|(
name|ecp
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_sec_flags
parameter_list|(
name|struct
name|sec_action
modifier|*
name|sac
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|flag
decl_stmt|;
name|int
name|found
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|flag
operator|=
name|strtok
argument_list|(
name|s
argument_list|,
literal|","
argument_list|)
init|;
name|flag
condition|;
name|flag
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
control|)
block|{
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|sec_flags
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|sec_flags
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|flag
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sac
operator|->
name|flags
operator||=
name|sec_flags
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"unrecognized section flag %s"
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|parse_sec_address_op
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|int
name|optnum
parameter_list|,
specifier|const
name|char
modifier|*
name|optname
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|sec_action
modifier|*
name|sac
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|v
decl_stmt|;
name|char
name|op
decl_stmt|;
name|name
operator|=
name|v
operator|=
name|s
expr_stmt|;
do|do
block|{
name|v
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|v
operator|!=
literal|'\0'
operator|&&
operator|*
name|v
operator|!=
literal|'='
operator|&&
operator|*
name|v
operator|!=
literal|'+'
operator|&&
operator|*
name|v
operator|!=
literal|'-'
condition|)
do|;
if|if
condition|(
operator|*
name|v
operator|==
literal|'\0'
operator|||
operator|*
operator|(
name|v
operator|+
literal|1
operator|)
operator|==
literal|'\0'
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"invalid format for %s"
argument_list|,
name|optname
argument_list|)
expr_stmt|;
name|op
operator|=
operator|*
name|v
expr_stmt|;
operator|*
name|v
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|sac
operator|=
name|lookup_sec_act
argument_list|(
name|ecp
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
literal|'='
case|:
if|if
condition|(
name|optnum
operator|==
name|ECP_CHANGE_SEC_LMA
operator|||
name|optnum
operator|==
name|ECP_CHANGE_SEC_ADDR
condition|)
block|{
name|sac
operator|->
name|setlma
operator|=
literal|1
expr_stmt|;
name|sac
operator|->
name|lma
operator|=
operator|(
name|uint64_t
operator|)
name|strtoull
argument_list|(
name|v
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|optnum
operator|==
name|ECP_CHANGE_SEC_VMA
operator|||
name|optnum
operator|==
name|ECP_CHANGE_SEC_ADDR
condition|)
block|{
name|sac
operator|->
name|setvma
operator|=
literal|1
expr_stmt|;
name|sac
operator|->
name|vma
operator|=
operator|(
name|uint64_t
operator|)
name|strtoull
argument_list|(
name|v
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'+'
case|:
if|if
condition|(
name|optnum
operator|==
name|ECP_CHANGE_SEC_LMA
operator|||
name|optnum
operator|==
name|ECP_CHANGE_SEC_ADDR
condition|)
name|sac
operator|->
name|lma_adjust
operator|=
operator|(
name|int64_t
operator|)
name|strtoll
argument_list|(
name|v
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|optnum
operator|==
name|ECP_CHANGE_SEC_VMA
operator|||
name|optnum
operator|==
name|ECP_CHANGE_SEC_ADDR
condition|)
name|sac
operator|->
name|vma_adjust
operator|=
operator|(
name|int64_t
operator|)
name|strtoll
argument_list|(
name|v
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
if|if
condition|(
name|optnum
operator|==
name|ECP_CHANGE_SEC_LMA
operator|||
name|optnum
operator|==
name|ECP_CHANGE_SEC_ADDR
condition|)
name|sac
operator|->
name|lma_adjust
operator|=
operator|(
name|int64_t
operator|)
operator|-
name|strtoll
argument_list|(
name|v
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|optnum
operator|==
name|ECP_CHANGE_SEC_VMA
operator|||
name|optnum
operator|==
name|ECP_CHANGE_SEC_ADDR
condition|)
name|sac
operator|->
name|vma_adjust
operator|=
operator|(
name|int64_t
operator|)
operator|-
name|strtoll
argument_list|(
name|v
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|parse_symlist_file
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|,
name|unsigned
name|int
name|op
parameter_list|)
block|{
name|struct
name|symfile
modifier|*
name|sf
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|line
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|e
decl_stmt|,
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|fn
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"stat %s failed"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
comment|/* Check if we already read and processed this file. */
name|STAILQ_FOREACH
argument_list|(
argument|sf
argument_list|,
argument|&ecp->v_symfile
argument_list|,
argument|symfile_list
argument_list|)
block|{
if|if
condition|(
name|sf
operator|->
name|dev
operator|==
name|sb
operator|.
name|st_dev
operator|&&
name|sf
operator|->
name|ino
operator|==
name|sb
operator|.
name|st_ino
condition|)
goto|goto
name|process_symfile
goto|;
block|}
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fn
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"can not open %s"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|=
name|malloc
argument_list|(
name|sb
operator|.
name|st_size
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|.
name|st_size
operator|>
literal|0
condition|)
if|if
condition|(
name|fread
argument_list|(
name|data
argument_list|,
name|sb
operator|.
name|st_size
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
operator|!=
literal|1
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"fread failed"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|data
index|[
name|sb
operator|.
name|st_size
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|sf
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sf
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|sf
operator|->
name|dev
operator|=
name|sb
operator|.
name|st_dev
expr_stmt|;
name|sf
operator|->
name|ino
operator|=
name|sb
operator|.
name|st_ino
expr_stmt|;
name|sf
operator|->
name|size
operator|=
name|sb
operator|.
name|st_size
operator|+
literal|1
expr_stmt|;
name|sf
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|process_symfile
label|:
comment|/* 	 * Basically what we do here is to convert EOL to '\0', and remove 	 * leading and trailing whitespaces for each line. 	 */
name|end
operator|=
name|sf
operator|->
name|data
operator|+
name|sf
operator|->
name|size
expr_stmt|;
name|line
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|sf
operator|->
name|data
init|;
name|p
operator|<
name|end
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|'\t'
operator|||
operator|*
name|p
operator|==
literal|' '
operator|)
operator|&&
name|line
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\r'
operator|||
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Skip comment. */
if|if
condition|(
operator|*
name|line
operator|==
literal|'#'
condition|)
block|{
name|line
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
name|e
operator|=
name|p
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|e
operator|!=
name|line
operator|&&
operator|(
operator|*
name|e
operator|==
literal|'\t'
operator|||
operator|*
name|e
operator|==
literal|' '
operator|)
condition|)
operator|*
name|e
operator|--
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|op
operator|!=
name|SYMOP_REDEF
condition|)
name|add_to_symop_list
argument_list|(
name|ecp
argument_list|,
name|line
argument_list|,
name|NULL
argument_list|,
name|op
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|strlen
argument_list|(
name|line
argument_list|)
operator|<
literal|3
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"illegal format for"
literal|" --redefine-sym"
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|line
operator|+
literal|1
init|;
name|n
operator|<
name|e
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|n
operator|==
literal|' '
operator|||
operator|*
name|n
operator|==
literal|'\t'
condition|)
block|{
while|while
condition|(
operator|*
name|n
operator|==
literal|' '
operator|||
operator|*
name|n
operator|==
literal|'\t'
condition|)
operator|*
name|n
operator|++
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|n
operator|>=
name|e
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"illegal format for"
literal|" --redefine-sym"
argument_list|)
expr_stmt|;
name|add_to_symop_list
argument_list|(
name|ecp
argument_list|,
name|line
argument_list|,
name|n
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
name|line
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
name|line
operator|=
name|p
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|set_input_target
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
specifier|const
name|char
modifier|*
name|target_name
parameter_list|)
block|{
name|Elftc_Bfd_Target
modifier|*
name|tgt
decl_stmt|;
if|if
condition|(
operator|(
name|tgt
operator|=
name|elftc_bfd_find_target
argument_list|(
name|target_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"%s: invalid target name"
argument_list|,
name|target_name
argument_list|)
expr_stmt|;
name|ecp
operator|->
name|itf
operator|=
name|elftc_bfd_target_flavor
argument_list|(
name|tgt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_output_target
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
specifier|const
name|char
modifier|*
name|target_name
parameter_list|)
block|{
name|Elftc_Bfd_Target
modifier|*
name|tgt
decl_stmt|;
if|if
condition|(
operator|(
name|tgt
operator|=
name|elftc_bfd_find_target
argument_list|(
name|target_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"%s: invalid target name"
argument_list|,
name|target_name
argument_list|)
expr_stmt|;
name|ecp
operator|->
name|otf
operator|=
name|elftc_bfd_target_flavor
argument_list|(
name|tgt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|otf
operator|==
name|ETF_ELF
condition|)
block|{
name|ecp
operator|->
name|oec
operator|=
name|elftc_bfd_target_class
argument_list|(
name|tgt
argument_list|)
expr_stmt|;
name|ecp
operator|->
name|oed
operator|=
name|elftc_bfd_target_byteorder
argument_list|(
name|tgt
argument_list|)
expr_stmt|;
name|ecp
operator|->
name|oem
operator|=
name|elftc_bfd_target_machine
argument_list|(
name|tgt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ecp
operator|->
name|otf
operator|==
name|ETF_EFI
operator|||
name|ecp
operator|->
name|otf
operator|==
name|ETF_PE
condition|)
name|ecp
operator|->
name|oem
operator|=
name|elftc_bfd_target_machine
argument_list|(
name|tgt
argument_list|)
expr_stmt|;
name|ecp
operator|->
name|otgt
operator|=
name|target_name
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_osabi
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
specifier|const
name|char
modifier|*
name|abi
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|found
decl_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|osabis
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|osabis
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|abi
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ecp
operator|->
name|abi
operator|=
name|osabis
index|[
name|i
index|]
operator|.
name|abi
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"unrecognized OSABI %s"
argument_list|,
name|abi
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|ELFCOPY_USAGE_MESSAGE
value|"\ Usage: %s [options] infile [outfile]\n\   Transform object files.\n\n\   Options:\n\   -d | -g | --strip-debug      Remove debugging information from the output.\n\   -j SECTION | --only-section=SECTION\n\                                Copy only the named section to the output.\n\   -p | --preserve-dates        Preserve access and modification times.\n\   -w | --wildcard              Use shell-style patterns to name symbols.\n\   -x | --discard-all           Do not copy non-globals to the output.\n\   -I FORMAT | --input-target=FORMAT\n\                                Specify object format for the input file.\n\   -K SYM | --keep-symbol=SYM   Copy symbol SYM to the output.\n\   -L SYM | --localize-symbol=SYM\n\                                Make symbol SYM local to the output file.\n\   -N SYM | --strip-symbol=SYM  Do not copy symbol SYM to the output.\n\   -O FORMAT | --output-target=FORMAT\n\                                Specify object format for the output file.\n\                                FORMAT should be a target name understood by\n\                                elftc_bfd_find_target(3).\n\   -R NAME | --remove-section=NAME\n\                                Remove the named section.\n\   -S | --strip-all             Remove all symbol and relocation information\n\                                from the output.\n\   -V | --version               Print a version identifier and exit.\n\   -W SYM | --weaken-symbol=SYM Mark symbol SYM as weak in the output.\n\   -X | --discard-locals        Do not copy compiler generated symbols to\n\                                the output.\n\   --add-section NAME=FILE      Add the contents of FILE to the ELF object as\n\                                a new section named NAME.\n\   --adjust-section-vma SECTION{=,+,-}VAL | \\\n\     --change-section-address SECTION{=,+,-}VAL\n\                                Set or adjust the VMA and the LMA of the\n\                                named section by VAL.\n\   --adjust-start=INCR | --change-start=INCR\n\                                Add INCR to the start address for the ELF\n\                                object.\n\   --adjust-vma=INCR | --change-addresses=INCR\n\                                Increase the VMA and LMA of all sections by\n\                                INCR.\n\   --adjust-warning | --change-warnings\n\                                Issue warnings for non-existent sections.\n\   --change-section-lma SECTION{=,+,-}VAL\n\                                Set or adjust the LMA address of the named\n\                                section by VAL.\n\   --change-section-vma SECTION{=,+,-}VAL\n\                                Set or adjust the VMA address of the named\n\                                section by VAL.\n\   --gap-fill=VAL               Fill the gaps between sections with bytes\n\                                of value VAL.\n\   --localize-hidden            Make all hidden symbols local to the output\n\                                file.\n\   --no-adjust-warning| --no-change-warnings\n\                                Do not issue warnings for non-existent\n\                                sections.\n\   --only-keep-debug            Copy only debugging information.\n\   --output-target=FORMAT       Use the specified format for the output.\n\   --pad-to=ADDRESS             Pad the output object up to the given address.\n\   --prefix-alloc-sections=STRING\n\                                Prefix the section names of all the allocated\n\                                sections with STRING.\n\   --prefix-sections=STRING     Prefix the section names of all the sections\n\                                with STRING.\n\   --prefix-symbols=STRING      Prefix the symbol names of all the symbols\n\                                with STRING.\n\   --rename-section OLDNAME=NEWNAME[,FLAGS]\n\                                Rename and optionally change section flags.\n\   --set-section-flags SECTION=FLAGS\n\                                Set section flags for the named section.\n\                                Supported flags are: 'alloc', 'code',\n\                                'contents', 'data', 'debug', 'load',\n\                                'noload', 'readonly', 'rom', and 'shared'.\n\   --set-start=ADDRESS          Set the start address of the ELF object.\n\   --srec-forceS3               Only generate S3 S-Records.\n\   --srec-len=LEN               Set the maximum length of a S-Record line.\n\   --strip-unneeded             Do not copy relocation information.\n"
end_define

begin_function
specifier|static
name|void
name|elfcopy_usage
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|ELFCOPY_USAGE_MESSAGE
argument_list|,
name|ELFTC_GETPROGNAME
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MCS_USAGE_MESSAGE
value|"\ Usage: %s [options] file...\n\   Manipulate the comment section in an ELF object.\n\n\   Options:\n\   -a STRING        Append 'STRING' to the comment section.\n\   -c               Remove duplicate entries from the comment section.\n\   -d               Delete the comment section.\n\   -h | --help      Print a help message and exit.\n\   -n NAME          Operate on the ELF section with name 'NAME'.\n\   -p               Print the contents of the comment section.\n\   -V | --version   Print a version identifier and exit.\n"
end_define

begin_function
specifier|static
name|void
name|mcs_usage
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|MCS_USAGE_MESSAGE
argument_list|,
name|ELFTC_GETPROGNAME
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|STRIP_USAGE_MESSAGE
value|"\ Usage: %s [options] file...\n\   Discard information from ELF objects.\n\n\   Options:\n\   -d | -g | -S | --strip-debug    Remove debugging symbols.\n\   -h | --help                     Print a help message.\n\   -o FILE | --output-file FILE    Write output to FILE.\n\   --only-keep-debug               Keep debugging information only.\n\   -p | --preserve-dates           Preserve access and modification times.\n\   -s | --strip-all                Remove all symbols.\n\   --strip-unneeded                Remove symbols not needed for relocation\n\                                   processing.\n\   -w | --wildcard                 Use shell-style patterns to name symbols.\n\   -x | --discard-all              Discard all non-global symbols.\n\   -I TGT| --input-target=TGT      (Accepted, but ignored).\n\   -K SYM | --keep-symbol=SYM      Keep symbol 'SYM' in the output.\n\   -N SYM | --strip-symbol=SYM     Remove symbol 'SYM' from the output.\n\   -O TGT | --output-target=TGT    Set the output file format to 'TGT'.\n\   -R SEC | --remove-section=SEC   Remove the section named 'SEC'.\n\   -V | --version                  Print a version identifier and exit.\n\   -X | --discard-locals           Remove compiler-generated local symbols.\n"
end_define

begin_function
specifier|static
name|void
name|strip_usage
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|STRIP_USAGE_MESSAGE
argument_list|,
name|ELFTC_GETPROGNAME
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_version
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s (%s)\n"
argument_list|,
name|ELFTC_GETPROGNAME
argument_list|()
argument_list|,
name|elftc_version
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compare the ending of s with end.  */
end_comment

begin_function
specifier|static
name|int
name|strrcmp
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
block|{
name|size_t
name|endlen
decl_stmt|,
name|slen
decl_stmt|;
name|slen
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|endlen
operator|=
name|strlen
argument_list|(
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|slen
operator|>=
name|endlen
condition|)
name|s
operator|+=
name|slen
operator|-
name|endlen
expr_stmt|;
return|return
operator|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|end
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|elfcopy
modifier|*
name|ecp
decl_stmt|;
if|if
condition|(
name|elf_version
argument_list|(
name|EV_CURRENT
argument_list|)
operator|==
name|EV_NONE
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"ELF library initialization failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ecp
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ecp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecp
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ecp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ecp
argument_list|)
argument_list|)
expr_stmt|;
name|ecp
operator|->
name|itf
operator|=
name|ecp
operator|->
name|otf
operator|=
name|ETF_ELF
expr_stmt|;
name|ecp
operator|->
name|iec
operator|=
name|ecp
operator|->
name|oec
operator|=
name|ELFCLASSNONE
expr_stmt|;
name|ecp
operator|->
name|oed
operator|=
name|ELFDATANONE
expr_stmt|;
name|ecp
operator|->
name|abi
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* There is always an empty section. */
name|ecp
operator|->
name|nos
operator|=
literal|1
expr_stmt|;
name|ecp
operator|->
name|fill
operator|=
literal|0
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|ecp
operator|->
name|v_seg
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|ecp
operator|->
name|v_sac
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|ecp
operator|->
name|v_sadd
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|ecp
operator|->
name|v_symop
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|ecp
operator|->
name|v_symfile
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|ecp
operator|->
name|v_arobj
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ecp
operator|->
name|v_sec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ecp
operator|->
name|progname
operator|=
name|ELFTC_GETPROGNAME
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|ecp
operator|->
name|progname
operator|=
literal|"elfcopy"
expr_stmt|;
if|if
condition|(
name|strrcmp
argument_list|(
name|ecp
operator|->
name|progname
argument_list|,
literal|"strip"
argument_list|)
operator|==
literal|0
condition|)
name|strip_main
argument_list|(
name|ecp
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strrcmp
argument_list|(
name|ecp
operator|->
name|progname
argument_list|,
literal|"mcs"
argument_list|)
operator|==
literal|0
condition|)
name|mcs_main
argument_list|(
name|ecp
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|strrcmp
argument_list|(
name|ecp
operator|->
name|progname
argument_list|,
literal|"elfcopy"
argument_list|)
operator|!=
literal|0
operator|&&
name|strrcmp
argument_list|(
name|ecp
operator|->
name|progname
argument_list|,
literal|"objcopy"
argument_list|)
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"program mode not known, defaulting to elfcopy"
argument_list|)
expr_stmt|;
name|elfcopy_main
argument_list|(
name|ecp
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
name|free_sec_add
argument_list|(
name|ecp
argument_list|)
expr_stmt|;
name|free_sec_act
argument_list|(
name|ecp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ecp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

