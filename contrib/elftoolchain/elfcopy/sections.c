begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007-2011,2014 Kai Wang  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"elfcopy.h"
end_include

begin_expr_stmt
name|ELFTC_VCSID
argument_list|(
literal|"$Id: sections.c 3346 2016-01-17 20:09:15Z kaiwang27 $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|add_gnu_debuglink
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|calc_crc32
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|uint32_t
name|crc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_section_rename
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|filter_reloc
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_section_flags
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|insert_sections
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|insert_to_strtab
parameter_list|(
name|struct
name|section
modifier|*
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_append_section
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_compress_section
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_debug_section
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_dwo_section
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_modify_section
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_print_section
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lookup_string
parameter_list|(
name|struct
name|section
modifier|*
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|modify_section
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_section
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_data
parameter_list|(
specifier|const
name|char
modifier|*
name|d
parameter_list|,
name|size_t
name|sz
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_section
parameter_list|(
name|struct
name|section
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|read_section
parameter_list|(
name|struct
name|section
modifier|*
name|s
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_reloc
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_section_group
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|is_remove_section
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* Always keep section name table */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".shstrtab"
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".symtab"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".strtab"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ecp
operator|->
name|strip
operator|==
name|STRIP_ALL
operator|&&
name|lookup_symop_list
argument_list|(
name|ecp
argument_list|,
name|NULL
argument_list|,
name|SYMOP_KEEP
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ecp
operator|->
name|strip
operator|==
name|STRIP_DWO
operator|&&
name|is_dwo_section
argument_list|(
name|name
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|ecp
operator|->
name|strip
operator|==
name|STRIP_NONDWO
operator|&&
operator|!
name|is_dwo_section
argument_list|(
name|name
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|is_debug_section
argument_list|(
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|ecp
operator|->
name|strip
operator|==
name|STRIP_ALL
operator|||
name|ecp
operator|->
name|strip
operator|==
name|STRIP_DEBUG
operator|||
name|ecp
operator|->
name|strip
operator|==
name|STRIP_UNNEEDED
operator|||
operator|(
name|ecp
operator|->
name|flags
operator|&
name|DISCARD_LOCAL
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|ecp
operator|->
name|strip
operator|==
name|STRIP_NONDEBUG
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ecp
operator|->
name|flags
operator|&
name|SEC_REMOVE
operator|)
operator|||
operator|(
name|ecp
operator|->
name|flags
operator|&
name|SEC_COPY
operator|)
condition|)
block|{
name|struct
name|sec_action
modifier|*
name|sac
decl_stmt|;
name|sac
operator|=
name|lookup_sec_act
argument_list|(
name|ecp
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ecp
operator|->
name|flags
operator|&
name|SEC_REMOVE
operator|)
operator|&&
name|sac
operator|!=
name|NULL
operator|&&
name|sac
operator|->
name|remove
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|ecp
operator|->
name|flags
operator|&
name|SEC_COPY
operator|)
operator|&&
operator|(
name|sac
operator|==
name|NULL
operator|||
operator|!
name|sac
operator|->
name|copy
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Relocation section needs to be removed if the section it applies to  * will be removed.  */
end_comment

begin_function
name|int
name|is_remove_reloc_sec
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|uint32_t
name|sh_info
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|GElf_Shdr
name|ish
decl_stmt|;
name|Elf_Scn
modifier|*
name|is
decl_stmt|;
name|size_t
name|indx
decl_stmt|;
name|int
name|elferr
decl_stmt|;
if|if
condition|(
name|elf_getshstrndx
argument_list|(
name|ecp
operator|->
name|ein
argument_list|,
operator|&
name|indx
argument_list|)
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_getshstrndx failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|is
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|is
operator|=
name|elf_nextscn
argument_list|(
name|ecp
operator|->
name|ein
argument_list|,
name|is
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sh_info
operator|==
name|elf_ndxscn
argument_list|(
name|is
argument_list|)
condition|)
block|{
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|is
argument_list|,
operator|&
name|ish
argument_list|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_getshdr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|=
name|elf_strptr
argument_list|(
name|ecp
operator|->
name|ein
argument_list|,
name|indx
argument_list|,
name|ish
operator|.
name|sh_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_strptr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_remove_section
argument_list|(
name|ecp
argument_list|,
name|name
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_nextscn failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove reloc section if we can't find the target section. */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_append_section
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|sec_action
modifier|*
name|sac
decl_stmt|;
name|sac
operator|=
name|lookup_sec_act
argument_list|(
name|ecp
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sac
operator|!=
name|NULL
operator|&&
name|sac
operator|->
name|append
operator|!=
literal|0
operator|&&
name|sac
operator|->
name|string
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_compress_section
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|sec_action
modifier|*
name|sac
decl_stmt|;
name|sac
operator|=
name|lookup_sec_act
argument_list|(
name|ecp
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sac
operator|!=
name|NULL
operator|&&
name|sac
operator|->
name|compress
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_section_rename
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|sec_action
modifier|*
name|sac
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
name|size_t
name|namelen
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|pseudo
condition|)
return|return;
name|sac
operator|=
name|lookup_sec_act
argument_list|(
name|ecp
argument_list|,
name|s
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sac
operator|!=
name|NULL
operator|&&
name|sac
operator|->
name|rename
condition|)
name|s
operator|->
name|name
operator|=
name|sac
operator|->
name|newname
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|".symtab"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|".strtab"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|".shstrtab"
argument_list|)
condition|)
return|return;
name|prefix
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|loadable
operator|&&
name|ecp
operator|->
name|prefix_alloc
operator|!=
name|NULL
condition|)
name|prefix
operator|=
name|ecp
operator|->
name|prefix_alloc
expr_stmt|;
elseif|else
if|if
condition|(
name|ecp
operator|->
name|prefix_sec
operator|!=
name|NULL
condition|)
name|prefix
operator|=
name|ecp
operator|->
name|prefix_sec
expr_stmt|;
if|if
condition|(
name|prefix
operator|!=
name|NULL
condition|)
block|{
name|namelen
operator|=
name|strlen
argument_list|(
name|s
operator|->
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|newname
operator|=
name|malloc
argument_list|(
name|namelen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|s
operator|->
name|newname
argument_list|,
name|namelen
argument_list|,
literal|"%s%s"
argument_list|,
name|prefix
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|s
operator|->
name|name
operator|=
name|s
operator|->
name|newname
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|get_section_flags
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|sec_action
modifier|*
name|sac
decl_stmt|;
name|sac
operator|=
name|lookup_sec_act
argument_list|(
name|ecp
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sac
operator|!=
name|NULL
operator|&&
name|sac
operator|->
name|flags
condition|)
return|return
name|sac
operator|->
name|flags
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine whether the section are debugging section.  * According to libbfd, debugging sections are recognized  * only by name.  */
end_comment

begin_function
specifier|static
name|int
name|is_debug_section
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|dbg_sec
index|[]
init|=
block|{
literal|".apple_"
block|,
literal|".debug"
block|,
literal|".gnu.linkonce.wi."
block|,
literal|".line"
block|,
literal|".stab"
block|,
name|NULL
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|dbg_sec
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
operator|*
name|p
argument_list|,
name|strlen
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_dwo_section
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|)
operator|>
literal|4
operator|&&
name|strcmp
argument_list|(
name|name
operator|+
name|len
operator|-
literal|4
argument_list|,
literal|".dwo"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_print_section
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|sec_action
modifier|*
name|sac
decl_stmt|;
name|sac
operator|=
name|lookup_sec_act
argument_list|(
name|ecp
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sac
operator|!=
name|NULL
operator|&&
name|sac
operator|->
name|print
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_modify_section
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|is_append_section
argument_list|(
name|ecp
argument_list|,
name|name
argument_list|)
operator|||
name|is_compress_section
argument_list|(
name|ecp
argument_list|,
name|name
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|sec_action
modifier|*
name|lookup_sec_act
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|add
parameter_list|)
block|{
name|struct
name|sec_action
modifier|*
name|sac
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|STAILQ_FOREACH
argument_list|(
argument|sac
argument_list|,
argument|&ecp->v_sac
argument_list|,
argument|sac_list
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|sac
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|sac
return|;
block|}
if|if
condition|(
name|add
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|sac
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sac
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"not enough memory"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sac
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sac
argument_list|)
argument_list|)
expr_stmt|;
name|sac
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ecp
operator|->
name|v_sac
argument_list|,
name|sac
argument_list|,
name|sac_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|sac
operator|)
return|;
block|}
end_function

begin_function
name|void
name|free_sec_act
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|)
block|{
name|struct
name|sec_action
modifier|*
name|sac
decl_stmt|,
modifier|*
name|sac_temp
decl_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|sac
argument_list|,
argument|&ecp->v_sac
argument_list|,
argument|sac_list
argument_list|,
argument|sac_temp
argument_list|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|ecp
operator|->
name|v_sac
argument_list|,
name|sac
argument_list|,
name|sec_action
argument_list|,
name|sac_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sac
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|insert_to_sec_list
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|struct
name|section
modifier|*
name|sec
parameter_list|,
name|int
name|tail
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|tail
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|s
argument_list|,
argument|&ecp->v_sec
argument_list|,
argument|sec_list
argument_list|)
block|{
if|if
condition|(
name|sec
operator|->
name|off
operator|<
name|s
operator|->
name|off
condition|)
block|{
name|TAILQ_INSERT_BEFORE
argument_list|(
name|s
argument_list|,
name|sec
argument_list|,
name|sec_list
argument_list|)
expr_stmt|;
goto|goto
name|inc_nos
goto|;
block|}
block|}
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ecp
operator|->
name|v_sec
argument_list|,
name|sec
argument_list|,
name|sec_list
argument_list|)
expr_stmt|;
name|inc_nos
label|:
if|if
condition|(
name|sec
operator|->
name|pseudo
operator|==
literal|0
condition|)
name|ecp
operator|->
name|nos
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * First step of section creation: create scn and internal section  * structure, discard sections to be removed.  */
end_comment

begin_function
name|void
name|create_scn
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|Elf_Scn
modifier|*
name|is
decl_stmt|;
name|GElf_Shdr
name|ish
decl_stmt|;
name|size_t
name|indx
decl_stmt|;
name|uint64_t
name|oldndx
decl_stmt|,
name|newndx
decl_stmt|;
name|int
name|elferr
decl_stmt|,
name|sec_flags
decl_stmt|;
comment|/* 	 * Insert a pseudo section that contains the ELF header 	 * and program header. Used as reference for section offset 	 * or load address adjustment. 	 */
if|if
condition|(
operator|(
name|s
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
name|s
operator|->
name|off
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|sz
operator|=
name|gelf_fsize
argument_list|(
name|ecp
operator|->
name|eout
argument_list|,
name|ELF_T_EHDR
argument_list|,
literal|1
argument_list|,
name|EV_CURRENT
argument_list|)
operator|+
name|gelf_fsize
argument_list|(
name|ecp
operator|->
name|eout
argument_list|,
name|ELF_T_PHDR
argument_list|,
name|ecp
operator|->
name|ophnum
argument_list|,
name|EV_CURRENT
argument_list|)
expr_stmt|;
name|s
operator|->
name|align
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|pseudo
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|loadable
operator|=
name|add_to_inseg_list
argument_list|(
name|ecp
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|insert_to_sec_list
argument_list|(
name|ecp
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Create internal .shstrtab section. */
name|init_shstrtab
argument_list|(
name|ecp
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_getshstrndx
argument_list|(
name|ecp
operator|->
name|ein
argument_list|,
operator|&
name|indx
argument_list|)
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_getshstrndx failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|is
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|is
operator|=
name|elf_nextscn
argument_list|(
name|ecp
operator|->
name|ein
argument_list|,
name|is
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|is
argument_list|,
operator|&
name|ish
argument_list|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_getshdr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|=
name|elf_strptr
argument_list|(
name|ecp
operator|->
name|ein
argument_list|,
name|indx
argument_list|,
name|ish
operator|.
name|sh_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_strptr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip sections to be removed. */
if|if
condition|(
name|is_remove_section
argument_list|(
name|ecp
argument_list|,
name|name
argument_list|)
condition|)
continue|continue;
comment|/* 		 * Relocation section need to be remove if the section 		 * it applies will be removed. 		 */
if|if
condition|(
name|ish
operator|.
name|sh_type
operator|==
name|SHT_REL
operator|||
name|ish
operator|.
name|sh_type
operator|==
name|SHT_RELA
condition|)
if|if
condition|(
name|ish
operator|.
name|sh_info
operator|!=
literal|0
operator|&&
name|is_remove_reloc_sec
argument_list|(
name|ecp
argument_list|,
name|ish
operator|.
name|sh_info
argument_list|)
condition|)
continue|continue;
comment|/* 		 * Section groups should be removed if symbol table will 		 * be removed. (section group's signature stored in symbol 		 * table) 		 */
if|if
condition|(
name|ish
operator|.
name|sh_type
operator|==
name|SHT_GROUP
operator|&&
name|ecp
operator|->
name|strip
operator|==
name|STRIP_ALL
condition|)
continue|continue;
comment|/* Get section flags set by user. */
name|sec_flags
operator|=
name|get_section_flags
argument_list|(
name|ecp
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Create internal section object. */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".shstrtab"
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
name|s
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|s
operator|->
name|is
operator|=
name|is
expr_stmt|;
name|s
operator|->
name|off
operator|=
name|ish
operator|.
name|sh_offset
expr_stmt|;
name|s
operator|->
name|sz
operator|=
name|ish
operator|.
name|sh_size
expr_stmt|;
name|s
operator|->
name|align
operator|=
name|ish
operator|.
name|sh_addralign
expr_stmt|;
name|s
operator|->
name|type
operator|=
name|ish
operator|.
name|sh_type
expr_stmt|;
name|s
operator|->
name|vma
operator|=
name|ish
operator|.
name|sh_addr
expr_stmt|;
comment|/* 			 * Search program headers to determine whether section 			 * is loadable, but if user explicitly set section flags 			 * while neither "load" nor "alloc" is set, we make the 			 * section unloadable. 			 * 			 * Sections in relocatable object is loadable if 			 * section flag SHF_ALLOC is set. 			 */
if|if
condition|(
name|sec_flags
operator|&&
operator|(
name|sec_flags
operator|&
operator|(
name|SF_LOAD
operator||
name|SF_ALLOC
operator|)
operator|)
operator|==
literal|0
condition|)
name|s
operator|->
name|loadable
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|s
operator|->
name|loadable
operator|=
name|add_to_inseg_list
argument_list|(
name|ecp
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ecp
operator|->
name|flags
operator|&
name|RELOCATABLE
operator|)
operator|&&
operator|(
name|ish
operator|.
name|sh_flags
operator|&
name|SHF_ALLOC
operator|)
condition|)
name|s
operator|->
name|loadable
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Assuming .shstrtab is "unloadable". */
name|s
operator|=
name|ecp
operator|->
name|shstrtab
expr_stmt|;
name|s
operator|->
name|off
operator|=
name|ish
operator|.
name|sh_offset
expr_stmt|;
block|}
name|oldndx
operator|=
name|newndx
operator|=
name|SHN_UNDEF
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".symtab"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".strtab"
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".shstrtab"
argument_list|)
condition|)
block|{
comment|/* 				 * Add sections specified by --add-section and 				 * gnu debuglink. we want these sections have 				 * smaller index than .shstrtab section. 				 */
if|if
condition|(
name|ecp
operator|->
name|debuglink
operator|!=
name|NULL
condition|)
name|add_gnu_debuglink
argument_list|(
name|ecp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|flags
operator|&
name|SEC_ADD
condition|)
name|insert_sections
argument_list|(
name|ecp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|s
operator|->
name|os
operator|=
name|elf_newscn
argument_list|(
name|ecp
operator|->
name|eout
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_newscn failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|newndx
operator|=
name|elf_ndxscn
argument_list|(
name|s
operator|->
name|os
argument_list|)
operator|)
operator|==
name|SHN_UNDEF
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_ndxscn failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|oldndx
operator|=
name|elf_ndxscn
argument_list|(
name|is
argument_list|)
operator|)
operator|==
name|SHN_UNDEF
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_ndxscn failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldndx
operator|!=
name|SHN_UNDEF
operator|&&
name|newndx
operator|!=
name|SHN_UNDEF
condition|)
name|ecp
operator|->
name|secndx
index|[
name|oldndx
index|]
operator|=
name|newndx
expr_stmt|;
comment|/* 		 * If strip action is STRIP_NONDEBUG(only keep debug), 		 * change sections type of loadable sections and section 		 * groups to SHT_NOBITS, and the content of those sections 		 * will be discarded. However, SHT_NOTE sections should 		 * be kept. 		 */
if|if
condition|(
name|ecp
operator|->
name|strip
operator|==
name|STRIP_NONDEBUG
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|ish
operator|.
name|sh_flags
operator|&
name|SHF_ALLOC
operator|)
operator|||
operator|(
name|ish
operator|.
name|sh_flags
operator|&
name|SHF_GROUP
operator|)
operator|)
operator|&&
name|ish
operator|.
name|sh_type
operator|!=
name|SHT_NOTE
condition|)
name|s
operator|->
name|type
operator|=
name|SHT_NOBITS
expr_stmt|;
block|}
name|check_section_rename
argument_list|(
name|ecp
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* create section header based on input object. */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".symtab"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".strtab"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".shstrtab"
argument_list|)
operator|!=
literal|0
condition|)
name|copy_shdr
argument_list|(
name|ecp
argument_list|,
name|s
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sec_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".symtab"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ecp
operator|->
name|flags
operator||=
name|SYMTAB_EXIST
expr_stmt|;
name|ecp
operator|->
name|symtab
operator|=
name|s
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".strtab"
argument_list|)
operator|==
literal|0
condition|)
name|ecp
operator|->
name|strtab
operator|=
name|s
expr_stmt|;
name|insert_to_sec_list
argument_list|(
name|ecp
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_nextscn failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|section
modifier|*
name|insert_shtab
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|int
name|tail
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|,
modifier|*
name|shtab
decl_stmt|;
name|GElf_Ehdr
name|ieh
decl_stmt|;
name|int
name|nsecs
decl_stmt|;
comment|/* 	 * Treat section header table as a "pseudo" section, insert it 	 * into section list, so later it will get sorted and resynced 	 * just as normal sections. 	 */
if|if
condition|(
operator|(
name|shtab
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|shtab
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tail
condition|)
block|{
comment|/* 		 * "shoff" of input object is used as a hint for section 		 * resync later. 		 */
if|if
condition|(
name|gelf_getehdr
argument_list|(
name|ecp
operator|->
name|ein
argument_list|,
operator|&
name|ieh
argument_list|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_getehdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|shtab
operator|->
name|off
operator|=
name|ieh
operator|.
name|e_shoff
expr_stmt|;
block|}
else|else
name|shtab
operator|->
name|off
operator|=
literal|0
expr_stmt|;
comment|/* Calculate number of sections in the output object. */
name|nsecs
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|s
argument_list|,
argument|&ecp->v_sec
argument_list|,
argument|sec_list
argument_list|)
block|{
if|if
condition|(
operator|!
name|s
operator|->
name|pseudo
condition|)
name|nsecs
operator|++
expr_stmt|;
block|}
comment|/* Remember there is always a null section, so we +1 here. */
name|shtab
operator|->
name|sz
operator|=
name|gelf_fsize
argument_list|(
name|ecp
operator|->
name|eout
argument_list|,
name|ELF_T_SHDR
argument_list|,
name|nsecs
operator|+
literal|1
argument_list|,
name|EV_CURRENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|shtab
operator|->
name|sz
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_fsize() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|shtab
operator|->
name|align
operator|=
operator|(
name|ecp
operator|->
name|oec
operator|==
name|ELFCLASS32
condition|?
literal|4
else|:
literal|8
operator|)
expr_stmt|;
name|shtab
operator|->
name|loadable
operator|=
literal|0
expr_stmt|;
name|shtab
operator|->
name|pseudo
operator|=
literal|1
expr_stmt|;
name|insert_to_sec_list
argument_list|(
name|ecp
argument_list|,
name|shtab
argument_list|,
name|tail
argument_list|)
expr_stmt|;
return|return
operator|(
name|shtab
operator|)
return|;
block|}
end_function

begin_function
name|void
name|copy_content
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|s
argument_list|,
argument|&ecp->v_sec
argument_list|,
argument|sec_list
argument_list|)
block|{
comment|/* Skip pseudo section. */
if|if
condition|(
name|s
operator|->
name|pseudo
condition|)
continue|continue;
comment|/* Skip special sections. */
if|if
condition|(
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|".symtab"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|".strtab"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|".shstrtab"
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * If strip action is STRIP_ALL, relocation info need 		 * to be stripped. Skip filtering otherwisw. 		 */
if|if
condition|(
name|ecp
operator|->
name|strip
operator|==
name|STRIP_ALL
operator|&&
operator|(
name|s
operator|->
name|type
operator|==
name|SHT_REL
operator|||
name|s
operator|->
name|type
operator|==
name|SHT_RELA
operator|)
condition|)
name|filter_reloc
argument_list|(
name|ecp
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* 		 * The section indices in the SHT_GROUP section needs 		 * to be updated since we might have stripped some 		 * sections and changed section numbering. 		 */
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|SHT_GROUP
condition|)
name|update_section_group
argument_list|(
name|ecp
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_modify_section
argument_list|(
name|ecp
argument_list|,
name|s
operator|->
name|name
argument_list|)
condition|)
name|modify_section
argument_list|(
name|ecp
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|copy_data
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 		 * If symbol table is modified, relocation info might 		 * need update, as symbol index may have changed. 		 */
if|if
condition|(
operator|(
name|ecp
operator|->
name|flags
operator|&
name|SYMTAB_INTACT
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ecp
operator|->
name|flags
operator|&
name|SYMTAB_EXIST
operator|)
operator|&&
operator|(
name|s
operator|->
name|type
operator|==
name|SHT_REL
operator|||
name|s
operator|->
name|type
operator|==
name|SHT_RELA
operator|)
condition|)
name|update_reloc
argument_list|(
name|ecp
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_print_section
argument_list|(
name|ecp
argument_list|,
name|s
operator|->
name|name
argument_list|)
condition|)
name|print_section
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Update section group section. The section indices in the SHT_GROUP  * section need update after section numbering changed.  */
end_comment

begin_function
specifier|static
name|void
name|update_section_group
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
block|{
name|GElf_Shdr
name|ish
decl_stmt|;
name|Elf_Data
modifier|*
name|id
decl_stmt|;
name|uint32_t
modifier|*
name|ws
decl_stmt|,
modifier|*
name|wd
decl_stmt|;
name|uint64_t
name|n
decl_stmt|;
name|size_t
name|ishnum
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|elf_getshnum
argument_list|(
name|ecp
operator|->
name|ein
argument_list|,
operator|&
name|ishnum
argument_list|)
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_getshnum failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|s
operator|->
name|is
argument_list|,
operator|&
name|ish
argument_list|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_getehdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|id
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|is
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_getdata() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ish
operator|.
name|sh_size
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|ish
operator|.
name|sh_entsize
operator|==
literal|0
condition|)
name|ish
operator|.
name|sh_entsize
operator|=
literal|4
expr_stmt|;
name|ws
operator|=
name|id
operator|->
name|d_buf
expr_stmt|;
comment|/* We only support COMDAT section. */
ifndef|#
directive|ifndef
name|GRP_COMDAT
define|#
directive|define
name|GRP_COMDAT
value|0x1
endif|#
directive|endif
if|if
condition|(
operator|(
operator|*
name|ws
operator|&
name|GRP_COMDAT
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|s
operator|->
name|buf
operator|=
name|malloc
argument_list|(
name|ish
operator|.
name|sh_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|s
operator|->
name|sz
operator|=
name|ish
operator|.
name|sh_size
expr_stmt|;
name|wd
operator|=
name|s
operator|->
name|buf
expr_stmt|;
comment|/* Copy the flag word as-is. */
operator|*
name|wd
operator|=
operator|*
name|ws
expr_stmt|;
comment|/* Update the section indices. */
name|n
operator|=
name|ish
operator|.
name|sh_size
operator|/
name|ish
operator|.
name|sh_entsize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|j
operator|=
literal|1
init|;
operator|(
name|uint64_t
operator|)
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ws
index|[
name|i
index|]
operator|!=
name|SHN_UNDEF
operator|&&
name|ws
index|[
name|i
index|]
operator|<
name|ishnum
operator|&&
name|ecp
operator|->
name|secndx
index|[
name|ws
index|[
name|i
index|]
index|]
operator|!=
literal|0
condition|)
name|wd
index|[
name|j
operator|++
index|]
operator|=
name|ecp
operator|->
name|secndx
index|[
name|ws
index|[
name|i
index|]
index|]
expr_stmt|;
else|else
name|s
operator|->
name|sz
operator|-=
literal|4
expr_stmt|;
block|}
name|s
operator|->
name|nocopy
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Filter relocation entries, only keep those entries whose  * symbol is in the keep list.  */
end_comment

begin_function
specifier|static
name|void
name|filter_reloc
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|GElf_Shdr
name|ish
decl_stmt|;
name|GElf_Rel
name|rel
decl_stmt|;
name|GElf_Rela
name|rela
decl_stmt|;
name|Elf32_Rel
modifier|*
name|rel32
decl_stmt|;
name|Elf64_Rel
modifier|*
name|rel64
decl_stmt|;
name|Elf32_Rela
modifier|*
name|rela32
decl_stmt|;
name|Elf64_Rela
modifier|*
name|rela64
decl_stmt|;
name|Elf_Data
modifier|*
name|id
decl_stmt|;
name|uint64_t
name|cap
decl_stmt|,
name|n
decl_stmt|,
name|nrels
decl_stmt|;
name|int
name|elferr
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|s
operator|->
name|is
argument_list|,
operator|&
name|ish
argument_list|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_getehdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We don't want to touch relocation info for dynamic symbols. */
if|if
condition|(
operator|(
name|ecp
operator|->
name|flags
operator|&
name|SYMTAB_EXIST
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ish
operator|.
name|sh_link
operator|==
literal|0
operator|||
name|ecp
operator|->
name|secndx
index|[
name|ish
operator|.
name|sh_link
index|]
operator|==
literal|0
condition|)
block|{
comment|/* 			 * This reloc section applies to the symbol table 			 * that was stripped, so discard whole section. 			 */
name|s
operator|->
name|nocopy
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|sz
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
else|else
block|{
comment|/* Symbol table exist, check if index equals. */
if|if
condition|(
name|ish
operator|.
name|sh_link
operator|!=
name|elf_ndxscn
argument_list|(
name|ecp
operator|->
name|symtab
operator|->
name|is
argument_list|)
condition|)
return|return;
block|}
define|#
directive|define
name|COPYREL
parameter_list|(
name|REL
parameter_list|,
name|SZ
parameter_list|)
value|do {					\ 	if (nrels == 0) {					\ 		if ((REL##SZ = malloc(cap *			\ 		    sizeof(Elf##SZ##_Rel))) == NULL)		\ 			err(EXIT_FAILURE, "malloc failed");	\ 	}							\ 	if (nrels>= cap) {					\ 		cap *= 2;					\ 		if ((REL##SZ = realloc(REL##SZ, cap *		\ 		    sizeof(Elf##SZ##_Rel))) == NULL)		\ 			err(EXIT_FAILURE, "realloc failed");	\ 	}							\ 	REL##SZ[nrels].r_offset = REL.r_offset;			\ 	REL##SZ[nrels].r_info	= REL.r_info;			\ 	if (s->type == SHT_RELA)				\ 		rela##SZ[nrels].r_addend = rela.r_addend;	\ 	nrels++;						\ } while (0)
name|nrels
operator|=
literal|0
expr_stmt|;
name|cap
operator|=
literal|4
expr_stmt|;
comment|/* keep list is usually small. */
name|rel32
operator|=
name|NULL
expr_stmt|;
name|rel64
operator|=
name|NULL
expr_stmt|;
name|rela32
operator|=
name|NULL
expr_stmt|;
name|rela64
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|id
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|is
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_getdata() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|ish
operator|.
name|sh_size
operator|/
name|ish
operator|.
name|sh_entsize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|uint64_t
operator|)
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|SHT_REL
condition|)
block|{
if|if
condition|(
name|gelf_getrel
argument_list|(
name|id
argument_list|,
name|i
argument_list|,
operator|&
name|rel
argument_list|)
operator|!=
operator|&
name|rel
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_getrel failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|gelf_getrela
argument_list|(
name|id
argument_list|,
name|i
argument_list|,
operator|&
name|rela
argument_list|)
operator|!=
operator|&
name|rela
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_getrel failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|elf_strptr
argument_list|(
name|ecp
operator|->
name|ein
argument_list|,
name|elf_ndxscn
argument_list|(
name|ecp
operator|->
name|strtab
operator|->
name|is
argument_list|)
argument_list|,
name|GELF_R_SYM
argument_list|(
name|rel
operator|.
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_strptr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup_symop_list
argument_list|(
name|ecp
argument_list|,
name|name
argument_list|,
name|SYMOP_KEEP
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ecp
operator|->
name|oec
operator|==
name|ELFCLASS32
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|SHT_REL
condition|)
name|COPYREL
argument_list|(
name|rel
argument_list|,
literal|32
argument_list|)
expr_stmt|;
else|else
name|COPYREL
argument_list|(
name|rela
argument_list|,
literal|32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|SHT_REL
condition|)
name|COPYREL
argument_list|(
name|rel
argument_list|,
literal|64
argument_list|)
expr_stmt|;
else|else
name|COPYREL
argument_list|(
name|rela
argument_list|,
literal|64
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_getdata() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|oec
operator|==
name|ELFCLASS32
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|SHT_REL
condition|)
name|s
operator|->
name|buf
operator|=
name|rel32
expr_stmt|;
else|else
name|s
operator|->
name|buf
operator|=
name|rela32
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|SHT_REL
condition|)
name|s
operator|->
name|buf
operator|=
name|rel64
expr_stmt|;
else|else
name|s
operator|->
name|buf
operator|=
name|rela64
expr_stmt|;
block|}
name|s
operator|->
name|sz
operator|=
name|gelf_fsize
argument_list|(
name|ecp
operator|->
name|eout
argument_list|,
operator|(
name|s
operator|->
name|type
operator|==
name|SHT_REL
condition|?
name|ELF_T_REL
else|:
name|ELF_T_RELA
operator|)
argument_list|,
name|nrels
argument_list|,
name|EV_CURRENT
argument_list|)
expr_stmt|;
name|s
operator|->
name|nocopy
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_reloc
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
block|{
name|GElf_Shdr
name|osh
decl_stmt|;
name|GElf_Rel
name|rel
decl_stmt|;
name|GElf_Rela
name|rela
decl_stmt|;
name|Elf_Data
modifier|*
name|od
decl_stmt|;
name|uint64_t
name|n
decl_stmt|;
name|int
name|i
decl_stmt|;
define|#
directive|define
name|UPDATEREL
parameter_list|(
name|REL
parameter_list|)
value|do {						\ 	if (gelf_get##REL(od, i,&REL) !=&REL)				\ 		errx(EXIT_FAILURE, "gelf_get##REL failed: %s",		\ 		    elf_errmsg(-1));					\ 	REL.r_info = GELF_R_INFO(ecp->symndx[GELF_R_SYM(REL.r_info)],	\ 	    GELF_R_TYPE(REL.r_info));					\ 	if (!gelf_update_##REL(od, i,&REL))				\ 		errx(EXIT_FAILURE, "gelf_update_##REL failed: %s",	\ 		    elf_errmsg(-1));					\ } while(0)
if|if
condition|(
name|s
operator|->
name|sz
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|s
operator|->
name|os
argument_list|,
operator|&
name|osh
argument_list|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_getehdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Only process .symtab reloc info. */
if|if
condition|(
name|osh
operator|.
name|sh_link
operator|!=
name|elf_ndxscn
argument_list|(
name|ecp
operator|->
name|symtab
operator|->
name|is
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|od
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|os
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_getdata() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|osh
operator|.
name|sh_size
operator|/
name|osh
operator|.
name|sh_entsize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|uint64_t
operator|)
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|SHT_REL
condition|)
name|UPDATEREL
argument_list|(
name|rel
argument_list|)
expr_stmt|;
else|else
name|UPDATEREL
argument_list|(
name|rela
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pad_section
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
block|{
name|GElf_Shdr
name|osh
decl_stmt|;
name|Elf_Data
modifier|*
name|od
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
name|s
operator|->
name|pad_sz
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|s
operator|->
name|pad
operator|=
name|malloc
argument_list|(
name|s
operator|->
name|pad_sz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|s
operator|->
name|pad
argument_list|,
name|ecp
operator|->
name|fill
argument_list|,
name|s
operator|->
name|pad_sz
argument_list|)
expr_stmt|;
comment|/* Create a new Elf_Data to contain the padding bytes. */
if|if
condition|(
operator|(
name|od
operator|=
name|elf_newdata
argument_list|(
name|s
operator|->
name|os
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_newdata() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|od
operator|->
name|d_align
operator|=
literal|1
expr_stmt|;
name|od
operator|->
name|d_off
operator|=
name|s
operator|->
name|sz
expr_stmt|;
name|od
operator|->
name|d_buf
operator|=
name|s
operator|->
name|pad
expr_stmt|;
name|od
operator|->
name|d_type
operator|=
name|ELF_T_BYTE
expr_stmt|;
name|od
operator|->
name|d_size
operator|=
name|s
operator|->
name|pad_sz
expr_stmt|;
name|od
operator|->
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
comment|/* Update section header. */
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|s
operator|->
name|os
argument_list|,
operator|&
name|osh
argument_list|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_getshdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|osh
operator|.
name|sh_size
operator|=
name|s
operator|->
name|sz
operator|+
name|s
operator|->
name|pad_sz
expr_stmt|;
if|if
condition|(
operator|!
name|gelf_update_shdr
argument_list|(
name|s
operator|->
name|os
argument_list|,
operator|&
name|osh
argument_list|)
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_update_shdr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|resync_sections
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|,
modifier|*
name|ps
decl_stmt|;
name|GElf_Shdr
name|osh
decl_stmt|;
name|uint64_t
name|off
decl_stmt|;
name|int
name|first
decl_stmt|;
name|ps
operator|=
name|NULL
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|s
argument_list|,
argument|&ecp->v_sec
argument_list|,
argument|sec_list
argument_list|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|off
operator|=
name|s
operator|->
name|off
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Ignore TLS sections with load address 0 and without 		 * content. We don't need to adjust their file offset or 		 * VMA, only the size matters. 		 */
if|if
condition|(
name|s
operator|->
name|seg_tls
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|type
operator|==
name|SHT_NOBITS
operator|&&
name|s
operator|->
name|off
operator|==
literal|0
condition|)
continue|continue;
comment|/* Align section offset. */
if|if
condition|(
name|s
operator|->
name|align
operator|==
literal|0
condition|)
name|s
operator|->
name|align
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|off
operator|<=
name|s
operator|->
name|off
condition|)
block|{
if|if
condition|(
operator|!
name|s
operator|->
name|loadable
operator|||
operator|(
name|ecp
operator|->
name|flags
operator|&
name|RELOCATABLE
operator|)
condition|)
name|s
operator|->
name|off
operator|=
name|roundup
argument_list|(
name|off
argument_list|,
name|s
operator|->
name|align
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|s
operator|->
name|loadable
operator|&&
operator|(
name|ecp
operator|->
name|flags
operator|&
name|RELOCATABLE
operator|)
operator|==
literal|0
condition|)
name|warnx
argument_list|(
literal|"moving loadable section %s, "
literal|"is this intentional?"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|s
operator|->
name|off
operator|=
name|roundup
argument_list|(
name|off
argument_list|,
name|s
operator|->
name|align
argument_list|)
expr_stmt|;
block|}
comment|/* Calculate next section offset. */
name|off
operator|=
name|s
operator|->
name|off
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|pseudo
operator|||
operator|(
name|s
operator|->
name|type
operator|!=
name|SHT_NOBITS
operator|&&
name|s
operator|->
name|type
operator|!=
name|SHT_NULL
operator|)
condition|)
name|off
operator|+=
name|s
operator|->
name|sz
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|pseudo
condition|)
block|{
name|ps
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
comment|/* Count padding bytes added through --pad-to. */
if|if
condition|(
name|s
operator|->
name|pad_sz
operator|>
literal|0
condition|)
name|off
operator|+=
name|s
operator|->
name|pad_sz
expr_stmt|;
comment|/* Update section header accordingly. */
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|s
operator|->
name|os
argument_list|,
operator|&
name|osh
argument_list|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_getshdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|osh
operator|.
name|sh_addr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
name|osh
operator|.
name|sh_offset
operator|=
name|s
operator|->
name|off
expr_stmt|;
name|osh
operator|.
name|sh_size
operator|=
name|s
operator|->
name|sz
expr_stmt|;
if|if
condition|(
operator|!
name|gelf_update_shdr
argument_list|(
name|s
operator|->
name|os
argument_list|,
operator|&
name|osh
argument_list|)
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_update_shdr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add padding for previous section, if need. */
if|if
condition|(
name|ps
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ps
operator|->
name|pad_sz
operator|>
literal|0
condition|)
block|{
comment|/* Apply padding added by --pad-to. */
name|pad_section
argument_list|(
name|ecp
argument_list|,
name|ps
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ecp
operator|->
name|flags
operator|&
name|GAP_FILL
operator|)
operator|&&
operator|(
name|ps
operator|->
name|off
operator|+
name|ps
operator|->
name|sz
operator|<
name|s
operator|->
name|off
operator|)
condition|)
block|{
comment|/* 				 * Fill the gap between sections by padding 				 * the section with lower address. 				 */
name|ps
operator|->
name|pad_sz
operator|=
name|s
operator|->
name|off
operator|-
operator|(
name|ps
operator|->
name|off
operator|+
name|ps
operator|->
name|sz
operator|)
expr_stmt|;
name|pad_section
argument_list|(
name|ecp
argument_list|,
name|ps
argument_list|)
expr_stmt|;
block|}
block|}
name|ps
operator|=
name|s
expr_stmt|;
block|}
comment|/* Pad the last section, if need. */
if|if
condition|(
name|ps
operator|!=
name|NULL
operator|&&
name|ps
operator|->
name|pad_sz
operator|>
literal|0
condition|)
name|pad_section
argument_list|(
name|ecp
argument_list|,
name|ps
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|modify_section
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|sec_action
modifier|*
name|sac
decl_stmt|;
name|size_t
name|srcsz
decl_stmt|,
name|dstsz
decl_stmt|,
name|p
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|d
decl_stmt|,
modifier|*
name|src
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|dupe
decl_stmt|;
name|src
operator|=
name|read_section
argument_list|(
name|s
argument_list|,
operator|&
name|srcsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|==
name|NULL
operator|||
name|srcsz
operator|==
literal|0
condition|)
block|{
comment|/* For empty section, we proceed if we need to append. */
if|if
condition|(
operator|!
name|is_append_section
argument_list|(
name|ecp
argument_list|,
name|s
operator|->
name|name
argument_list|)
condition|)
return|return;
block|}
comment|/* Allocate buffer needed for new section data. */
name|dstsz
operator|=
name|srcsz
expr_stmt|;
if|if
condition|(
name|is_append_section
argument_list|(
name|ecp
argument_list|,
name|s
operator|->
name|name
argument_list|)
condition|)
block|{
name|sac
operator|=
name|lookup_sec_act
argument_list|(
name|ecp
argument_list|,
name|s
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dstsz
operator|+=
name|strlen
argument_list|(
name|sac
operator|->
name|string
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|b
operator|=
name|malloc
argument_list|(
name|dstsz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|s
operator|->
name|buf
operator|=
name|b
expr_stmt|;
comment|/* Compress section. */
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_compress_section
argument_list|(
name|ecp
argument_list|,
name|s
operator|->
name|name
argument_list|)
condition|)
block|{
name|end
operator|=
name|src
operator|+
name|srcsz
expr_stmt|;
for|for
control|(
name|c
operator|=
name|src
init|;
name|c
operator|<
name|end
condition|;
control|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|+
name|len
operator|<
name|end
operator|&&
name|c
index|[
name|len
index|]
operator|!=
literal|'\0'
condition|)
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|+
name|len
operator|==
name|end
condition|)
block|{
comment|/* XXX should we warn here? */
name|strncpy
argument_list|(
operator|&
name|b
index|[
name|p
index|]
argument_list|,
name|c
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
break|break;
block|}
name|dupe
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|d
operator|=
name|b
init|;
name|d
operator|<
name|b
operator|+
name|p
condition|;
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|d
argument_list|,
name|c
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dupe
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|d
operator|+=
name|strlen
argument_list|(
name|d
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dupe
condition|)
block|{
name|strncpy
argument_list|(
operator|&
name|b
index|[
name|p
index|]
argument_list|,
name|c
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|b
index|[
name|p
operator|+
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
block|}
name|c
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|memcpy
argument_list|(
name|b
argument_list|,
name|src
argument_list|,
name|srcsz
argument_list|)
expr_stmt|;
name|p
operator|+=
name|srcsz
expr_stmt|;
block|}
comment|/* Append section. */
if|if
condition|(
name|is_append_section
argument_list|(
name|ecp
argument_list|,
name|s
operator|->
name|name
argument_list|)
condition|)
block|{
name|sac
operator|=
name|lookup_sec_act
argument_list|(
name|ecp
argument_list|,
name|s
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|sac
operator|->
name|string
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|&
name|b
index|[
name|p
index|]
argument_list|,
name|sac
operator|->
name|string
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|b
index|[
name|p
operator|+
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
block|}
name|s
operator|->
name|sz
operator|=
name|p
expr_stmt|;
name|s
operator|->
name|nocopy
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_data
parameter_list|(
specifier|const
name|char
modifier|*
name|d
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|d
init|;
name|c
operator|<
name|d
operator|+
name|sz
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|c
operator|==
literal|'\0'
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_section
parameter_list|(
name|struct
name|section
modifier|*
name|s
parameter_list|)
block|{
name|Elf_Data
modifier|*
name|id
decl_stmt|;
name|int
name|elferr
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|buf
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|sz
operator|>
literal|0
condition|)
block|{
name|print_data
argument_list|(
name|s
operator|->
name|buf
argument_list|,
name|s
operator|->
name|sz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|id
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|id
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|is
argument_list|,
name|id
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|id
operator|=
name|elf_rawdata
argument_list|(
name|s
operator|->
name|is
argument_list|,
name|id
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
name|print_data
argument_list|(
name|id
operator|->
name|d_buf
argument_list|,
name|id
operator|->
name|d_size
argument_list|)
expr_stmt|;
block|}
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_getdata() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|read_section
parameter_list|(
name|struct
name|section
modifier|*
name|s
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|Elf_Data
modifier|*
name|id
decl_stmt|;
name|char
modifier|*
name|b
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|int
name|elferr
decl_stmt|;
name|sz
operator|=
literal|0
expr_stmt|;
name|b
operator|=
name|NULL
expr_stmt|;
name|id
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|id
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|is
argument_list|,
name|id
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|id
operator|=
name|elf_rawdata
argument_list|(
name|s
operator|->
name|is
argument_list|,
name|id
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
name|b
operator|=
name|malloc
argument_list|(
name|id
operator|->
name|d_size
argument_list|)
expr_stmt|;
else|else
name|b
operator|=
name|malloc
argument_list|(
name|sz
operator|+
name|id
operator|->
name|d_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"malloc or realloc failed"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|b
index|[
name|sz
index|]
argument_list|,
name|id
operator|->
name|d_buf
argument_list|,
name|id
operator|->
name|d_size
argument_list|)
expr_stmt|;
name|sz
operator|+=
name|id
operator|->
name|d_size
expr_stmt|;
block|}
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_getdata() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|size
operator|=
name|sz
expr_stmt|;
return|return
operator|(
name|b
operator|)
return|;
block|}
end_function

begin_function
name|void
name|copy_shdr
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|copy
parameter_list|,
name|int
name|sec_flags
parameter_list|)
block|{
name|GElf_Shdr
name|ish
decl_stmt|,
name|osh
decl_stmt|;
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|s
operator|->
name|is
argument_list|,
operator|&
name|ish
argument_list|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_getshdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|s
operator|->
name|os
argument_list|,
operator|&
name|osh
argument_list|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_getshdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy
condition|)
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|&
name|osh
argument_list|,
operator|&
name|ish
argument_list|,
sizeof|sizeof
argument_list|(
name|ish
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|osh
operator|.
name|sh_type
operator|=
name|s
operator|->
name|type
expr_stmt|;
name|osh
operator|.
name|sh_addr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
name|osh
operator|.
name|sh_offset
operator|=
name|s
operator|->
name|off
expr_stmt|;
name|osh
operator|.
name|sh_size
operator|=
name|s
operator|->
name|sz
expr_stmt|;
name|osh
operator|.
name|sh_link
operator|=
name|ish
operator|.
name|sh_link
expr_stmt|;
name|osh
operator|.
name|sh_info
operator|=
name|ish
operator|.
name|sh_info
expr_stmt|;
name|osh
operator|.
name|sh_addralign
operator|=
name|s
operator|->
name|align
expr_stmt|;
name|osh
operator|.
name|sh_entsize
operator|=
name|ish
operator|.
name|sh_entsize
expr_stmt|;
if|if
condition|(
name|sec_flags
condition|)
block|{
name|osh
operator|.
name|sh_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sec_flags
operator|&
name|SF_ALLOC
condition|)
name|osh
operator|.
name|sh_flags
operator||=
name|SHF_ALLOC
expr_stmt|;
if|if
condition|(
operator|(
name|sec_flags
operator|&
name|SF_READONLY
operator|)
operator|==
literal|0
condition|)
name|osh
operator|.
name|sh_flags
operator||=
name|SHF_WRITE
expr_stmt|;
if|if
condition|(
name|sec_flags
operator|&
name|SF_CODE
condition|)
name|osh
operator|.
name|sh_flags
operator||=
name|SHF_EXECINSTR
expr_stmt|;
if|if
condition|(
operator|(
name|sec_flags
operator|&
name|SF_CONTENTS
operator|)
operator|&&
name|s
operator|->
name|type
operator|==
name|SHT_NOBITS
operator|&&
name|s
operator|->
name|sz
operator|>
literal|0
condition|)
block|{
comment|/* 				 * Convert SHT_NOBITS section to section with 				 * (zero'ed) content on file. 				 */
name|osh
operator|.
name|sh_type
operator|=
name|s
operator|->
name|type
operator|=
name|SHT_PROGBITS
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|buf
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|s
operator|->
name|sz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|s
operator|->
name|nocopy
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|osh
operator|.
name|sh_flags
operator|=
name|ish
operator|.
name|sh_flags
expr_stmt|;
comment|/* 			 * Newer binutils as(1) emits the section flag 			 * SHF_INFO_LINK for relocation sections. elfcopy 			 * emits this flag in the output section if it's 			 * missing in the input section, to remain compatible 			 * with binutils. 			 */
if|if
condition|(
name|ish
operator|.
name|sh_type
operator|==
name|SHT_REL
operator|||
name|ish
operator|.
name|sh_type
operator|==
name|SHT_RELA
condition|)
name|osh
operator|.
name|sh_flags
operator||=
name|SHF_INFO_LINK
expr_stmt|;
block|}
block|}
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|add_to_shstrtab
argument_list|(
name|ecp
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|add_to_shstrtab
argument_list|(
name|ecp
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gelf_update_shdr
argument_list|(
name|s
operator|->
name|os
argument_list|,
operator|&
name|osh
argument_list|)
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_update_shdr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|copy_data
parameter_list|(
name|struct
name|section
modifier|*
name|s
parameter_list|)
block|{
name|Elf_Data
modifier|*
name|id
decl_stmt|,
modifier|*
name|od
decl_stmt|;
name|int
name|elferr
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|nocopy
operator|&&
name|s
operator|->
name|buf
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|id
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|is
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|id
operator|=
name|elf_rawdata
argument_list|(
name|s
operator|->
name|is
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"failed to read section:"
literal|" %s"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|(
name|od
operator|=
name|elf_newdata
argument_list|(
name|s
operator|->
name|os
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_newdata() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|nocopy
condition|)
block|{
comment|/* Use s->buf as content if s->nocopy is set. */
name|od
operator|->
name|d_align
operator|=
name|id
operator|->
name|d_align
expr_stmt|;
name|od
operator|->
name|d_off
operator|=
literal|0
expr_stmt|;
name|od
operator|->
name|d_buf
operator|=
name|s
operator|->
name|buf
expr_stmt|;
name|od
operator|->
name|d_type
operator|=
name|id
operator|->
name|d_type
expr_stmt|;
name|od
operator|->
name|d_size
operator|=
name|s
operator|->
name|sz
expr_stmt|;
name|od
operator|->
name|d_version
operator|=
name|id
operator|->
name|d_version
expr_stmt|;
block|}
else|else
block|{
name|od
operator|->
name|d_align
operator|=
name|id
operator|->
name|d_align
expr_stmt|;
name|od
operator|->
name|d_off
operator|=
name|id
operator|->
name|d_off
expr_stmt|;
name|od
operator|->
name|d_buf
operator|=
name|id
operator|->
name|d_buf
expr_stmt|;
name|od
operator|->
name|d_type
operator|=
name|id
operator|->
name|d_type
expr_stmt|;
name|od
operator|->
name|d_size
operator|=
name|id
operator|->
name|d_size
expr_stmt|;
name|od
operator|->
name|d_version
operator|=
name|id
operator|->
name|d_version
expr_stmt|;
block|}
comment|/* 	 * Alignment Fixup. libelf does not allow the alignment for 	 * Elf_Data descriptor to be set to 0. In this case we workaround 	 * it by setting the alignment to 1. 	 * 	 * According to the ELF ABI, alignment 0 and 1 has the same 	 * meaning: the section has no alignment constraints. 	 */
if|if
condition|(
name|od
operator|->
name|d_align
operator|==
literal|0
condition|)
name|od
operator|->
name|d_align
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|section
modifier|*
name|create_external_section
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|newname
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|uint64_t
name|off
parameter_list|,
name|uint64_t
name|stype
parameter_list|,
name|Elf_Type
name|dtype
parameter_list|,
name|uint64_t
name|flags
parameter_list|,
name|uint64_t
name|align
parameter_list|,
name|uint64_t
name|vma
parameter_list|,
name|int
name|loadable
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|Elf_Scn
modifier|*
name|os
decl_stmt|;
name|Elf_Data
modifier|*
name|od
decl_stmt|;
name|GElf_Shdr
name|osh
decl_stmt|;
if|if
condition|(
operator|(
name|os
operator|=
name|elf_newscn
argument_list|(
name|ecp
operator|->
name|eout
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_newscn() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
name|s
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|s
operator|->
name|newname
operator|=
name|newname
expr_stmt|;
comment|/* needs to be free()'ed */
name|s
operator|->
name|off
operator|=
name|off
expr_stmt|;
name|s
operator|->
name|sz
operator|=
name|size
expr_stmt|;
name|s
operator|->
name|vma
operator|=
name|vma
expr_stmt|;
name|s
operator|->
name|align
operator|=
name|align
expr_stmt|;
name|s
operator|->
name|loadable
operator|=
name|loadable
expr_stmt|;
name|s
operator|->
name|is
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|os
operator|=
name|os
expr_stmt|;
name|s
operator|->
name|type
operator|=
name|stype
expr_stmt|;
name|s
operator|->
name|nocopy
operator|=
literal|1
expr_stmt|;
name|insert_to_sec_list
argument_list|(
name|ecp
argument_list|,
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|os
argument_list|,
operator|&
name|osh
argument_list|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_getshdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|osh
operator|.
name|sh_flags
operator|=
name|flags
expr_stmt|;
name|osh
operator|.
name|sh_type
operator|=
name|s
operator|->
name|type
expr_stmt|;
name|osh
operator|.
name|sh_addr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
name|osh
operator|.
name|sh_addralign
operator|=
name|s
operator|->
name|align
expr_stmt|;
if|if
condition|(
operator|!
name|gelf_update_shdr
argument_list|(
name|os
argument_list|,
operator|&
name|osh
argument_list|)
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_update_shdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|add_to_shstrtab
argument_list|(
name|ecp
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
operator|&&
name|size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|od
operator|=
name|elf_newdata
argument_list|(
name|os
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_newdata() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|od
operator|->
name|d_align
operator|=
name|align
expr_stmt|;
name|od
operator|->
name|d_off
operator|=
literal|0
expr_stmt|;
name|od
operator|->
name|d_buf
operator|=
name|buf
expr_stmt|;
name|od
operator|->
name|d_size
operator|=
name|size
expr_stmt|;
name|od
operator|->
name|d_type
operator|=
name|dtype
expr_stmt|;
name|od
operator|->
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
block|}
comment|/* 	 * Clear SYMTAB_INTACT, as we probably need to update/add new 	 * STT_SECTION symbols into the symbol table. 	 */
name|ecp
operator|->
name|flags
operator|&=
operator|~
name|SYMTAB_INTACT
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert sections specified by --add-section to the end of section list.  */
end_comment

begin_function
specifier|static
name|void
name|insert_sections
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|)
block|{
name|struct
name|sec_add
modifier|*
name|sa
decl_stmt|;
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|size_t
name|off
decl_stmt|;
name|uint64_t
name|stype
decl_stmt|;
comment|/* Put these sections in the end of current list. */
name|off
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|s
argument_list|,
argument|&ecp->v_sec
argument_list|,
argument|sec_list
argument_list|)
block|{
if|if
condition|(
name|s
operator|->
name|type
operator|!=
name|SHT_NOBITS
operator|&&
name|s
operator|->
name|type
operator|!=
name|SHT_NULL
condition|)
name|off
operator|=
name|s
operator|->
name|off
operator|+
name|s
operator|->
name|sz
expr_stmt|;
else|else
name|off
operator|=
name|s
operator|->
name|off
expr_stmt|;
block|}
name|STAILQ_FOREACH
argument_list|(
argument|sa
argument_list|,
argument|&ecp->v_sadd
argument_list|,
argument|sadd_list
argument_list|)
block|{
comment|/* TODO: Add section header vma/lma, flag changes here */
comment|/* 		 * The default section type for user added section is 		 * SHT_PROGBITS. If the section name match certain patterns, 		 * elfcopy will try to set a more appropriate section type. 		 * However, data type is always set to ELF_T_BYTE and no 		 * translation is performed by libelf. 		 */
name|stype
operator|=
name|SHT_PROGBITS
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|sa
operator|->
name|name
argument_list|,
literal|".note"
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|sa
operator|->
name|name
argument_list|,
literal|".note."
argument_list|,
name|strlen
argument_list|(
literal|".note."
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|stype
operator|=
name|SHT_NOTE
expr_stmt|;
operator|(
name|void
operator|)
name|create_external_section
argument_list|(
name|ecp
argument_list|,
name|sa
operator|->
name|name
argument_list|,
name|NULL
argument_list|,
name|sa
operator|->
name|content
argument_list|,
name|sa
operator|->
name|size
argument_list|,
name|off
argument_list|,
name|stype
argument_list|,
name|ELF_T_BYTE
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|add_to_shstrtab
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|ecp
operator|->
name|shstrtab
expr_stmt|;
name|insert_to_strtab
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|update_shdr
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
name|int
name|update_link
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|GElf_Shdr
name|osh
decl_stmt|;
name|int
name|elferr
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|s
argument_list|,
argument|&ecp->v_sec
argument_list|,
argument|sec_list
argument_list|)
block|{
if|if
condition|(
name|s
operator|->
name|pseudo
condition|)
continue|continue;
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|s
operator|->
name|os
argument_list|,
operator|&
name|osh
argument_list|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_getshdr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find section name in string table and set sh_name. */
name|osh
operator|.
name|sh_name
operator|=
name|lookup_string
argument_list|(
name|ecp
operator|->
name|shstrtab
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* 		 * sh_link needs to be updated, since the index of the 		 * linked section might have changed. 		 */
if|if
condition|(
name|update_link
operator|&&
name|osh
operator|.
name|sh_link
operator|!=
literal|0
condition|)
name|osh
operator|.
name|sh_link
operator|=
name|ecp
operator|->
name|secndx
index|[
name|osh
operator|.
name|sh_link
index|]
expr_stmt|;
comment|/* 		 * sh_info of relocation section links to the section to which 		 * its relocation info applies. So it may need update as well. 		 */
if|if
condition|(
operator|(
name|s
operator|->
name|type
operator|==
name|SHT_REL
operator|||
name|s
operator|->
name|type
operator|==
name|SHT_RELA
operator|)
operator|&&
name|osh
operator|.
name|sh_info
operator|!=
literal|0
condition|)
name|osh
operator|.
name|sh_info
operator|=
name|ecp
operator|->
name|secndx
index|[
name|osh
operator|.
name|sh_info
index|]
expr_stmt|;
comment|/* 		 * sh_info of SHT_GROUP section needs to point to the correct 		 * string in the symbol table. 		 */
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|SHT_GROUP
operator|&&
operator|(
name|ecp
operator|->
name|flags
operator|&
name|SYMTAB_EXIST
operator|)
operator|&&
operator|(
name|ecp
operator|->
name|flags
operator|&
name|SYMTAB_INTACT
operator|)
operator|==
literal|0
condition|)
name|osh
operator|.
name|sh_info
operator|=
name|ecp
operator|->
name|symndx
index|[
name|osh
operator|.
name|sh_info
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|gelf_update_shdr
argument_list|(
name|s
operator|->
name|os
argument_list|,
operator|&
name|osh
argument_list|)
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_update_shdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_nextscn failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_shstrtab
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|ecp
operator|->
name|shstrtab
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ecp
operator|->
name|shstrtab
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
name|s
operator|=
name|ecp
operator|->
name|shstrtab
expr_stmt|;
name|s
operator|->
name|name
operator|=
literal|".shstrtab"
expr_stmt|;
name|s
operator|->
name|is
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|sz
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|align
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|loadable
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|type
operator|=
name|SHT_STRTAB
expr_stmt|;
name|s
operator|->
name|vma
operator|=
literal|0
expr_stmt|;
name|insert_to_strtab
argument_list|(
name|s
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|insert_to_strtab
argument_list|(
name|s
argument_list|,
literal|".symtab"
argument_list|)
expr_stmt|;
name|insert_to_strtab
argument_list|(
name|s
argument_list|,
literal|".strtab"
argument_list|)
expr_stmt|;
name|insert_to_strtab
argument_list|(
name|s
argument_list|,
literal|".shstrtab"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_shstrtab
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|Elf_Data
modifier|*
name|data
decl_stmt|;
name|GElf_Shdr
name|sh
decl_stmt|;
name|s
operator|=
name|ecp
operator|->
name|shstrtab
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|os
operator|==
name|NULL
condition|)
block|{
comment|/* Input object does not contain .shstrtab section */
if|if
condition|(
operator|(
name|s
operator|->
name|os
operator|=
name|elf_newscn
argument_list|(
name|ecp
operator|->
name|eout
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_newscn failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|insert_to_sec_list
argument_list|(
name|ecp
argument_list|,
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|s
operator|->
name|os
argument_list|,
operator|&
name|sh
argument_list|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_getshdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|sh
operator|.
name|sh_addr
operator|=
literal|0
expr_stmt|;
name|sh
operator|.
name|sh_addralign
operator|=
literal|1
expr_stmt|;
name|sh
operator|.
name|sh_offset
operator|=
name|s
operator|->
name|off
expr_stmt|;
name|sh
operator|.
name|sh_type
operator|=
name|SHT_STRTAB
expr_stmt|;
name|sh
operator|.
name|sh_flags
operator|=
literal|0
expr_stmt|;
name|sh
operator|.
name|sh_entsize
operator|=
literal|0
expr_stmt|;
name|sh
operator|.
name|sh_info
operator|=
literal|0
expr_stmt|;
name|sh
operator|.
name|sh_link
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|=
name|elf_newdata
argument_list|(
name|s
operator|->
name|os
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_newdata() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we don't have a symbol table, skip those a few bytes 	 * which are reserved for this in the beginning of shstrtab. 	 */
if|if
condition|(
operator|!
operator|(
name|ecp
operator|->
name|flags
operator|&
name|SYMTAB_EXIST
operator|)
condition|)
block|{
name|s
operator|->
name|sz
operator|-=
sizeof|sizeof
argument_list|(
literal|".symtab\0.strtab"
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|s
operator|->
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|s
operator|->
name|buf
operator|+
sizeof|sizeof
argument_list|(
literal|".symtab\0.strtab"
argument_list|)
argument_list|,
name|s
operator|->
name|sz
argument_list|)
expr_stmt|;
block|}
name|sh
operator|.
name|sh_size
operator|=
name|s
operator|->
name|sz
expr_stmt|;
if|if
condition|(
operator|!
name|gelf_update_shdr
argument_list|(
name|s
operator|->
name|os
argument_list|,
operator|&
name|sh
argument_list|)
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"gelf_update_shdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|d_align
operator|=
literal|1
expr_stmt|;
name|data
operator|->
name|d_buf
operator|=
name|s
operator|->
name|buf
expr_stmt|;
name|data
operator|->
name|d_size
operator|=
name|s
operator|->
name|sz
expr_stmt|;
name|data
operator|->
name|d_off
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|d_type
operator|=
name|ELF_T_BYTE
expr_stmt|;
name|data
operator|->
name|d_version
operator|=
name|EV_CURRENT
expr_stmt|;
if|if
condition|(
operator|!
name|elf_setshstrndx
argument_list|(
name|ecp
operator|->
name|eout
argument_list|,
name|elf_ndxscn
argument_list|(
name|s
operator|->
name|os
argument_list|)
argument_list|)
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"elf_setshstrndx() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_section
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sec_add
modifier|*
name|sa
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|fn
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|strchr
argument_list|(
name|arg
argument_list|,
literal|'='
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"illegal format for --add-section option"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sa
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sa
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|len
operator|=
name|s
operator|-
name|arg
expr_stmt|;
if|if
condition|(
operator|(
name|sa
operator|->
name|name
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|sa
operator|->
name|name
argument_list|,
name|arg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sa
operator|->
name|name
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fn
operator|=
name|s
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|fn
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"stat failed"
argument_list|)
expr_stmt|;
name|sa
operator|->
name|size
operator|=
name|sb
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sa
operator|->
name|content
operator|=
name|malloc
argument_list|(
name|sa
operator|->
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fn
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"can not open %s"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|sa
operator|->
name|content
argument_list|,
literal|1
argument_list|,
name|sa
operator|->
name|size
argument_list|,
name|fp
argument_list|)
operator|==
literal|0
operator|||
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"fread failed"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
name|sa
operator|->
name|content
operator|=
name|NULL
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ecp
operator|->
name|v_sadd
argument_list|,
name|sa
argument_list|,
name|sadd_list
argument_list|)
expr_stmt|;
name|ecp
operator|->
name|flags
operator||=
name|SEC_ADD
expr_stmt|;
block|}
end_function

begin_function
name|void
name|free_sec_add
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|)
block|{
name|struct
name|sec_add
modifier|*
name|sa
decl_stmt|,
modifier|*
name|sa_temp
decl_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|sa
argument_list|,
argument|&ecp->v_sadd
argument_list|,
argument|sadd_list
argument_list|,
argument|sa_temp
argument_list|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|ecp
operator|->
name|v_sadd
argument_list|,
name|sa
argument_list|,
name|sec_add
argument_list|,
name|sadd_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sa
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sa
operator|->
name|content
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sa
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|add_gnu_debuglink
parameter_list|(
name|struct
name|elfcopy
modifier|*
name|ecp
parameter_list|)
block|{
name|struct
name|sec_add
modifier|*
name|sa
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|fnbase
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|int
name|crc_off
decl_stmt|;
name|int
name|crc
decl_stmt|;
if|if
condition|(
name|ecp
operator|->
name|debuglink
operator|==
name|NULL
condition|)
return|return;
comment|/* Read debug file content. */
if|if
condition|(
operator|(
name|sa
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sa
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sa
operator|->
name|name
operator|=
name|strdup
argument_list|(
literal|".gnu_debuglink"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"strdup failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|ecp
operator|->
name|debuglink
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"stat failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|.
name|st_size
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"empty debug link target %s"
argument_list|,
name|ecp
operator|->
name|debuglink
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|sb
operator|.
name|st_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|ecp
operator|->
name|debuglink
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"can not open %s"
argument_list|,
name|ecp
operator|->
name|debuglink
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|sb
operator|.
name|st_size
argument_list|,
name|fp
argument_list|)
operator|==
literal|0
operator|||
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"fread failed"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Calculate crc checksum.  */
name|crc
operator|=
name|calc_crc32
argument_list|(
name|buf
argument_list|,
name|sb
operator|.
name|st_size
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Calculate section size and the offset to store crc checksum. */
if|if
condition|(
operator|(
name|fnbase
operator|=
name|basename
argument_list|(
name|ecp
operator|->
name|debuglink
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"basename failed"
argument_list|)
expr_stmt|;
name|crc_off
operator|=
name|roundup
argument_list|(
name|strlen
argument_list|(
name|fnbase
argument_list|)
operator|+
literal|1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sa
operator|->
name|size
operator|=
name|crc_off
operator|+
literal|4
expr_stmt|;
comment|/* Section content. */
if|if
condition|(
operator|(
name|sa
operator|->
name|content
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|sa
operator|->
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|sa
operator|->
name|content
argument_list|,
name|fnbase
argument_list|,
name|strlen
argument_list|(
name|fnbase
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecp
operator|->
name|oed
operator|==
name|ELFDATA2LSB
condition|)
block|{
name|sa
operator|->
name|content
index|[
name|crc_off
index|]
operator|=
name|crc
operator|&
literal|0xFF
expr_stmt|;
name|sa
operator|->
name|content
index|[
name|crc_off
operator|+
literal|1
index|]
operator|=
operator|(
name|crc
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|sa
operator|->
name|content
index|[
name|crc_off
operator|+
literal|2
index|]
operator|=
operator|(
name|crc
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|sa
operator|->
name|content
index|[
name|crc_off
operator|+
literal|3
index|]
operator|=
name|crc
operator|>>
literal|24
expr_stmt|;
block|}
else|else
block|{
name|sa
operator|->
name|content
index|[
name|crc_off
index|]
operator|=
name|crc
operator|>>
literal|24
expr_stmt|;
name|sa
operator|->
name|content
index|[
name|crc_off
operator|+
literal|1
index|]
operator|=
operator|(
name|crc
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|sa
operator|->
name|content
index|[
name|crc_off
operator|+
literal|2
index|]
operator|=
operator|(
name|crc
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|sa
operator|->
name|content
index|[
name|crc_off
operator|+
literal|3
index|]
operator|=
name|crc
operator|&
literal|0xFF
expr_stmt|;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ecp
operator|->
name|v_sadd
argument_list|,
name|sa
argument_list|,
name|sadd_list
argument_list|)
expr_stmt|;
name|ecp
operator|->
name|flags
operator||=
name|SEC_ADD
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|insert_to_strtab
parameter_list|(
name|struct
name|section
modifier|*
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|r
decl_stmt|;
name|char
modifier|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|slen
decl_stmt|;
name|int
name|append
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|sz
operator|==
literal|0
condition|)
block|{
name|t
operator|->
name|cap
operator|=
literal|512
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|->
name|buf
operator|=
name|malloc
argument_list|(
name|t
operator|->
name|cap
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
block|}
name|slen
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|append
operator|=
literal|0
expr_stmt|;
name|b
operator|=
name|t
operator|->
name|buf
expr_stmt|;
for|for
control|(
name|c
operator|=
name|b
init|;
name|c
operator|<
name|b
operator|+
name|t
operator|->
name|sz
condition|;
control|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|append
operator|&&
name|len
operator|>=
name|slen
condition|)
block|{
name|r
operator|=
name|c
operator|+
operator|(
name|len
operator|-
name|slen
operator|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|r
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
name|len
operator|<
name|slen
operator|&&
name|len
operator|!=
literal|0
condition|)
block|{
name|r
operator|=
name|s
operator|+
operator|(
name|slen
operator|-
name|len
operator|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|c
argument_list|,
name|r
argument_list|)
operator|==
literal|0
condition|)
block|{
name|t
operator|->
name|sz
operator|-=
name|len
operator|+
literal|1
expr_stmt|;
name|memmove
argument_list|(
name|c
argument_list|,
name|c
operator|+
name|len
operator|+
literal|1
argument_list|,
name|t
operator|->
name|sz
operator|-
operator|(
name|c
operator|-
name|b
operator|)
argument_list|)
expr_stmt|;
name|append
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
name|c
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|t
operator|->
name|sz
operator|+
name|slen
operator|+
literal|1
operator|>=
name|t
operator|->
name|cap
condition|)
block|{
name|t
operator|->
name|cap
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|->
name|buf
operator|=
name|realloc
argument_list|(
name|t
operator|->
name|buf
argument_list|,
name|t
operator|->
name|cap
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"realloc failed"
argument_list|)
expr_stmt|;
block|}
name|b
operator|=
name|t
operator|->
name|buf
expr_stmt|;
name|strncpy
argument_list|(
operator|&
name|b
index|[
name|t
operator|->
name|sz
index|]
argument_list|,
name|s
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|b
index|[
name|t
operator|->
name|sz
operator|+
name|slen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|t
operator|->
name|sz
operator|+=
name|slen
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lookup_string
parameter_list|(
name|struct
name|section
modifier|*
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|slen
decl_stmt|;
name|slen
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|b
operator|=
name|t
operator|->
name|buf
expr_stmt|;
for|for
control|(
name|c
operator|=
name|b
init|;
name|c
operator|<
name|b
operator|+
name|t
operator|->
name|sz
condition|;
control|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|slen
condition|)
block|{
name|r
operator|=
name|c
operator|+
operator|(
name|len
operator|-
name|slen
operator|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|r
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|r
operator|-
name|b
operator|)
return|;
block|}
name|c
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|uint32_t
name|crctable
index|[
literal|256
index|]
init|=
block|{
literal|0x00000000L
block|,
literal|0x77073096L
block|,
literal|0xEE0E612CL
block|,
literal|0x990951BAL
block|,
literal|0x076DC419L
block|,
literal|0x706AF48FL
block|,
literal|0xE963A535L
block|,
literal|0x9E6495A3L
block|,
literal|0x0EDB8832L
block|,
literal|0x79DCB8A4L
block|,
literal|0xE0D5E91EL
block|,
literal|0x97D2D988L
block|,
literal|0x09B64C2BL
block|,
literal|0x7EB17CBDL
block|,
literal|0xE7B82D07L
block|,
literal|0x90BF1D91L
block|,
literal|0x1DB71064L
block|,
literal|0x6AB020F2L
block|,
literal|0xF3B97148L
block|,
literal|0x84BE41DEL
block|,
literal|0x1ADAD47DL
block|,
literal|0x6DDDE4EBL
block|,
literal|0xF4D4B551L
block|,
literal|0x83D385C7L
block|,
literal|0x136C9856L
block|,
literal|0x646BA8C0L
block|,
literal|0xFD62F97AL
block|,
literal|0x8A65C9ECL
block|,
literal|0x14015C4FL
block|,
literal|0x63066CD9L
block|,
literal|0xFA0F3D63L
block|,
literal|0x8D080DF5L
block|,
literal|0x3B6E20C8L
block|,
literal|0x4C69105EL
block|,
literal|0xD56041E4L
block|,
literal|0xA2677172L
block|,
literal|0x3C03E4D1L
block|,
literal|0x4B04D447L
block|,
literal|0xD20D85FDL
block|,
literal|0xA50AB56BL
block|,
literal|0x35B5A8FAL
block|,
literal|0x42B2986CL
block|,
literal|0xDBBBC9D6L
block|,
literal|0xACBCF940L
block|,
literal|0x32D86CE3L
block|,
literal|0x45DF5C75L
block|,
literal|0xDCD60DCFL
block|,
literal|0xABD13D59L
block|,
literal|0x26D930ACL
block|,
literal|0x51DE003AL
block|,
literal|0xC8D75180L
block|,
literal|0xBFD06116L
block|,
literal|0x21B4F4B5L
block|,
literal|0x56B3C423L
block|,
literal|0xCFBA9599L
block|,
literal|0xB8BDA50FL
block|,
literal|0x2802B89EL
block|,
literal|0x5F058808L
block|,
literal|0xC60CD9B2L
block|,
literal|0xB10BE924L
block|,
literal|0x2F6F7C87L
block|,
literal|0x58684C11L
block|,
literal|0xC1611DABL
block|,
literal|0xB6662D3DL
block|,
literal|0x76DC4190L
block|,
literal|0x01DB7106L
block|,
literal|0x98D220BCL
block|,
literal|0xEFD5102AL
block|,
literal|0x71B18589L
block|,
literal|0x06B6B51FL
block|,
literal|0x9FBFE4A5L
block|,
literal|0xE8B8D433L
block|,
literal|0x7807C9A2L
block|,
literal|0x0F00F934L
block|,
literal|0x9609A88EL
block|,
literal|0xE10E9818L
block|,
literal|0x7F6A0DBBL
block|,
literal|0x086D3D2DL
block|,
literal|0x91646C97L
block|,
literal|0xE6635C01L
block|,
literal|0x6B6B51F4L
block|,
literal|0x1C6C6162L
block|,
literal|0x856530D8L
block|,
literal|0xF262004EL
block|,
literal|0x6C0695EDL
block|,
literal|0x1B01A57BL
block|,
literal|0x8208F4C1L
block|,
literal|0xF50FC457L
block|,
literal|0x65B0D9C6L
block|,
literal|0x12B7E950L
block|,
literal|0x8BBEB8EAL
block|,
literal|0xFCB9887CL
block|,
literal|0x62DD1DDFL
block|,
literal|0x15DA2D49L
block|,
literal|0x8CD37CF3L
block|,
literal|0xFBD44C65L
block|,
literal|0x4DB26158L
block|,
literal|0x3AB551CEL
block|,
literal|0xA3BC0074L
block|,
literal|0xD4BB30E2L
block|,
literal|0x4ADFA541L
block|,
literal|0x3DD895D7L
block|,
literal|0xA4D1C46DL
block|,
literal|0xD3D6F4FBL
block|,
literal|0x4369E96AL
block|,
literal|0x346ED9FCL
block|,
literal|0xAD678846L
block|,
literal|0xDA60B8D0L
block|,
literal|0x44042D73L
block|,
literal|0x33031DE5L
block|,
literal|0xAA0A4C5FL
block|,
literal|0xDD0D7CC9L
block|,
literal|0x5005713CL
block|,
literal|0x270241AAL
block|,
literal|0xBE0B1010L
block|,
literal|0xC90C2086L
block|,
literal|0x5768B525L
block|,
literal|0x206F85B3L
block|,
literal|0xB966D409L
block|,
literal|0xCE61E49FL
block|,
literal|0x5EDEF90EL
block|,
literal|0x29D9C998L
block|,
literal|0xB0D09822L
block|,
literal|0xC7D7A8B4L
block|,
literal|0x59B33D17L
block|,
literal|0x2EB40D81L
block|,
literal|0xB7BD5C3BL
block|,
literal|0xC0BA6CADL
block|,
literal|0xEDB88320L
block|,
literal|0x9ABFB3B6L
block|,
literal|0x03B6E20CL
block|,
literal|0x74B1D29AL
block|,
literal|0xEAD54739L
block|,
literal|0x9DD277AFL
block|,
literal|0x04DB2615L
block|,
literal|0x73DC1683L
block|,
literal|0xE3630B12L
block|,
literal|0x94643B84L
block|,
literal|0x0D6D6A3EL
block|,
literal|0x7A6A5AA8L
block|,
literal|0xE40ECF0BL
block|,
literal|0x9309FF9DL
block|,
literal|0x0A00AE27L
block|,
literal|0x7D079EB1L
block|,
literal|0xF00F9344L
block|,
literal|0x8708A3D2L
block|,
literal|0x1E01F268L
block|,
literal|0x6906C2FEL
block|,
literal|0xF762575DL
block|,
literal|0x806567CBL
block|,
literal|0x196C3671L
block|,
literal|0x6E6B06E7L
block|,
literal|0xFED41B76L
block|,
literal|0x89D32BE0L
block|,
literal|0x10DA7A5AL
block|,
literal|0x67DD4ACCL
block|,
literal|0xF9B9DF6FL
block|,
literal|0x8EBEEFF9L
block|,
literal|0x17B7BE43L
block|,
literal|0x60B08ED5L
block|,
literal|0xD6D6A3E8L
block|,
literal|0xA1D1937EL
block|,
literal|0x38D8C2C4L
block|,
literal|0x4FDFF252L
block|,
literal|0xD1BB67F1L
block|,
literal|0xA6BC5767L
block|,
literal|0x3FB506DDL
block|,
literal|0x48B2364BL
block|,
literal|0xD80D2BDAL
block|,
literal|0xAF0A1B4CL
block|,
literal|0x36034AF6L
block|,
literal|0x41047A60L
block|,
literal|0xDF60EFC3L
block|,
literal|0xA867DF55L
block|,
literal|0x316E8EEFL
block|,
literal|0x4669BE79L
block|,
literal|0xCB61B38CL
block|,
literal|0xBC66831AL
block|,
literal|0x256FD2A0L
block|,
literal|0x5268E236L
block|,
literal|0xCC0C7795L
block|,
literal|0xBB0B4703L
block|,
literal|0x220216B9L
block|,
literal|0x5505262FL
block|,
literal|0xC5BA3BBEL
block|,
literal|0xB2BD0B28L
block|,
literal|0x2BB45A92L
block|,
literal|0x5CB36A04L
block|,
literal|0xC2D7FFA7L
block|,
literal|0xB5D0CF31L
block|,
literal|0x2CD99E8BL
block|,
literal|0x5BDEAE1DL
block|,
literal|0x9B64C2B0L
block|,
literal|0xEC63F226L
block|,
literal|0x756AA39CL
block|,
literal|0x026D930AL
block|,
literal|0x9C0906A9L
block|,
literal|0xEB0E363FL
block|,
literal|0x72076785L
block|,
literal|0x05005713L
block|,
literal|0x95BF4A82L
block|,
literal|0xE2B87A14L
block|,
literal|0x7BB12BAEL
block|,
literal|0x0CB61B38L
block|,
literal|0x92D28E9BL
block|,
literal|0xE5D5BE0DL
block|,
literal|0x7CDCEFB7L
block|,
literal|0x0BDBDF21L
block|,
literal|0x86D3D2D4L
block|,
literal|0xF1D4E242L
block|,
literal|0x68DDB3F8L
block|,
literal|0x1FDA836EL
block|,
literal|0x81BE16CDL
block|,
literal|0xF6B9265BL
block|,
literal|0x6FB077E1L
block|,
literal|0x18B74777L
block|,
literal|0x88085AE6L
block|,
literal|0xFF0F6A70L
block|,
literal|0x66063BCAL
block|,
literal|0x11010B5CL
block|,
literal|0x8F659EFFL
block|,
literal|0xF862AE69L
block|,
literal|0x616BFFD3L
block|,
literal|0x166CCF45L
block|,
literal|0xA00AE278L
block|,
literal|0xD70DD2EEL
block|,
literal|0x4E048354L
block|,
literal|0x3903B3C2L
block|,
literal|0xA7672661L
block|,
literal|0xD06016F7L
block|,
literal|0x4969474DL
block|,
literal|0x3E6E77DBL
block|,
literal|0xAED16A4AL
block|,
literal|0xD9D65ADCL
block|,
literal|0x40DF0B66L
block|,
literal|0x37D83BF0L
block|,
literal|0xA9BCAE53L
block|,
literal|0xDEBB9EC5L
block|,
literal|0x47B2CF7FL
block|,
literal|0x30B5FFE9L
block|,
literal|0xBDBDF21CL
block|,
literal|0xCABAC28AL
block|,
literal|0x53B39330L
block|,
literal|0x24B4A3A6L
block|,
literal|0xBAD03605L
block|,
literal|0xCDD70693L
block|,
literal|0x54DE5729L
block|,
literal|0x23D967BFL
block|,
literal|0xB3667A2EL
block|,
literal|0xC4614AB8L
block|,
literal|0x5D681B02L
block|,
literal|0x2A6F2B94L
block|,
literal|0xB40BBE37L
block|,
literal|0xC30C8EA1L
block|,
literal|0x5A05DF1BL
block|,
literal|0x2D02EF8DL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|uint32_t
name|calc_crc32
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|uint32_t
name|crc
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|crc
operator|=
name|crctable
index|[
operator|(
name|crc
operator|^
operator|*
name|p
operator|++
operator|)
operator|&
literal|0xFFL
index|]
operator|^
operator|(
name|crc
operator|>>
literal|8
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|crc
operator|^
literal|0xFFFFFFFF
operator|)
return|;
block|}
end_function

end_unit

