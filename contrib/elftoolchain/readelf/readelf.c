begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009-2015 Kai Wang  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<ar.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<dwarf.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<gelf.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<libdwarf.h>
end_include

begin_include
include|#
directive|include
file|<libelftc.h>
end_include

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"_elftc.h"
end_include

begin_expr_stmt
name|ELFTC_VCSID
argument_list|(
literal|"$Id: readelf.c 3519 2017-04-09 23:15:58Z kaiwang27 $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Backwards compatability for older FreeBSD releases. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STB_GNU_UNIQUE
end_ifndef

begin_define
define|#
directive|define
name|STB_GNU_UNIQUE
value|10
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STT_SPARC_REGISTER
end_ifndef

begin_define
define|#
directive|define
name|STT_SPARC_REGISTER
value|13
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * readelf(1) options.  */
end_comment

begin_define
define|#
directive|define
name|RE_AA
value|0x00000001
end_define

begin_define
define|#
directive|define
name|RE_C
value|0x00000002
end_define

begin_define
define|#
directive|define
name|RE_DD
value|0x00000004
end_define

begin_define
define|#
directive|define
name|RE_D
value|0x00000008
end_define

begin_define
define|#
directive|define
name|RE_G
value|0x00000010
end_define

begin_define
define|#
directive|define
name|RE_H
value|0x00000020
end_define

begin_define
define|#
directive|define
name|RE_II
value|0x00000040
end_define

begin_define
define|#
directive|define
name|RE_I
value|0x00000080
end_define

begin_define
define|#
directive|define
name|RE_L
value|0x00000100
end_define

begin_define
define|#
directive|define
name|RE_NN
value|0x00000200
end_define

begin_define
define|#
directive|define
name|RE_N
value|0x00000400
end_define

begin_define
define|#
directive|define
name|RE_P
value|0x00000800
end_define

begin_define
define|#
directive|define
name|RE_R
value|0x00001000
end_define

begin_define
define|#
directive|define
name|RE_SS
value|0x00002000
end_define

begin_define
define|#
directive|define
name|RE_S
value|0x00004000
end_define

begin_define
define|#
directive|define
name|RE_T
value|0x00008000
end_define

begin_define
define|#
directive|define
name|RE_U
value|0x00010000
end_define

begin_define
define|#
directive|define
name|RE_VV
value|0x00020000
end_define

begin_define
define|#
directive|define
name|RE_WW
value|0x00040000
end_define

begin_define
define|#
directive|define
name|RE_W
value|0x00080000
end_define

begin_define
define|#
directive|define
name|RE_X
value|0x00100000
end_define

begin_comment
comment|/*  * dwarf dump options.  */
end_comment

begin_define
define|#
directive|define
name|DW_A
value|0x00000001
end_define

begin_define
define|#
directive|define
name|DW_FF
value|0x00000002
end_define

begin_define
define|#
directive|define
name|DW_F
value|0x00000004
end_define

begin_define
define|#
directive|define
name|DW_I
value|0x00000008
end_define

begin_define
define|#
directive|define
name|DW_LL
value|0x00000010
end_define

begin_define
define|#
directive|define
name|DW_L
value|0x00000020
end_define

begin_define
define|#
directive|define
name|DW_M
value|0x00000040
end_define

begin_define
define|#
directive|define
name|DW_O
value|0x00000080
end_define

begin_define
define|#
directive|define
name|DW_P
value|0x00000100
end_define

begin_define
define|#
directive|define
name|DW_RR
value|0x00000200
end_define

begin_define
define|#
directive|define
name|DW_R
value|0x00000400
end_define

begin_define
define|#
directive|define
name|DW_S
value|0x00000800
end_define

begin_define
define|#
directive|define
name|DW_DEFAULT_OPTIONS
value|(DW_A | DW_F | DW_I | DW_L | DW_O | DW_P | \ 	    DW_R | DW_RR | DW_S)
end_define

begin_comment
comment|/*  * readelf(1) run control flags.  */
end_comment

begin_define
define|#
directive|define
name|DISPLAY_FILENAME
value|0x0001
end_define

begin_comment
comment|/*  * Internal data structure for sections.  */
end_comment

begin_struct
struct|struct
name|section
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* section name */
name|Elf_Scn
modifier|*
name|scn
decl_stmt|;
comment|/* section scn */
name|uint64_t
name|off
decl_stmt|;
comment|/* section offset */
name|uint64_t
name|sz
decl_stmt|;
comment|/* section size */
name|uint64_t
name|entsize
decl_stmt|;
comment|/* section entsize */
name|uint64_t
name|align
decl_stmt|;
comment|/* section alignment */
name|uint64_t
name|type
decl_stmt|;
comment|/* section type */
name|uint64_t
name|flags
decl_stmt|;
comment|/* section flags */
name|uint64_t
name|addr
decl_stmt|;
comment|/* section virtual addr */
name|uint32_t
name|link
decl_stmt|;
comment|/* section link ndx */
name|uint32_t
name|info
decl_stmt|;
comment|/* section info ndx */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dumpop
block|{
union|union
block|{
name|size_t
name|si
decl_stmt|;
comment|/* section index */
specifier|const
name|char
modifier|*
name|sn
decl_stmt|;
comment|/* section name */
block|}
name|u
union|;
enum|enum
block|{
name|DUMP_BY_INDEX
init|=
literal|0
block|,
name|DUMP_BY_NAME
block|}
name|type
enum|;
comment|/* dump type */
define|#
directive|define
name|HEX_DUMP
value|0x0001
define|#
directive|define
name|STR_DUMP
value|0x0002
name|int
name|op
decl_stmt|;
comment|/* dump operation */
name|STAILQ_ENTRY
argument_list|(
argument|dumpop
argument_list|)
name|dumpop_list
expr_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|symver
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Structure encapsulates the global data for readelf(1).  */
end_comment

begin_struct
struct|struct
name|readelf
block|{
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* current processing file. */
name|int
name|options
decl_stmt|;
comment|/* command line options. */
name|int
name|flags
decl_stmt|;
comment|/* run control flags. */
name|int
name|dop
decl_stmt|;
comment|/* dwarf dump options. */
name|Elf
modifier|*
name|elf
decl_stmt|;
comment|/* underlying ELF descriptor. */
name|Elf
modifier|*
name|ar
decl_stmt|;
comment|/* archive ELF descriptor. */
name|Dwarf_Debug
name|dbg
decl_stmt|;
comment|/* DWARF handle. */
name|Dwarf_Half
name|cu_psize
decl_stmt|;
comment|/* DWARF CU pointer size. */
name|Dwarf_Half
name|cu_osize
decl_stmt|;
comment|/* DWARF CU offset size. */
name|Dwarf_Half
name|cu_ver
decl_stmt|;
comment|/* DWARF CU version. */
name|GElf_Ehdr
name|ehdr
decl_stmt|;
comment|/* ELF header. */
name|int
name|ec
decl_stmt|;
comment|/* ELF class. */
name|size_t
name|shnum
decl_stmt|;
comment|/* #sections. */
name|struct
name|section
modifier|*
name|vd_s
decl_stmt|;
comment|/* Verdef section. */
name|struct
name|section
modifier|*
name|vn_s
decl_stmt|;
comment|/* Verneed section. */
name|struct
name|section
modifier|*
name|vs_s
decl_stmt|;
comment|/* Versym section. */
name|uint16_t
modifier|*
name|vs
decl_stmt|;
comment|/* Versym array. */
name|int
name|vs_sz
decl_stmt|;
comment|/* Versym array size. */
name|struct
name|symver
modifier|*
name|ver
decl_stmt|;
comment|/* Version array. */
name|int
name|ver_sz
decl_stmt|;
comment|/* Size of version array. */
name|struct
name|section
modifier|*
name|sl
decl_stmt|;
comment|/* list of sections. */
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|dumpop
argument_list|)
name|v_dumpop
expr_stmt|;
comment|/* list of dump ops. */
name|uint64_t
function_decl|(
modifier|*
name|dw_read
function_decl|)
parameter_list|(
name|Elf_Data
modifier|*
parameter_list|,
name|uint64_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|uint64_t
function_decl|(
modifier|*
name|dw_decode
function_decl|)
parameter_list|(
name|uint8_t
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|options
block|{
name|OPTION_DEBUG_DUMP
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|struct
name|option
name|longopts
index|[]
init|=
block|{
block|{
literal|"all"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'a'
block|}
block|,
block|{
literal|"arch-specific"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'A'
block|}
block|,
block|{
literal|"archive-index"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'c'
block|}
block|,
block|{
literal|"debug-dump"
block|,
name|optional_argument
block|,
name|NULL
block|,
name|OPTION_DEBUG_DUMP
block|}
block|,
block|{
literal|"dynamic"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'d'
block|}
block|,
block|{
literal|"file-header"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'h'
block|}
block|,
block|{
literal|"full-section-name"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'N'
block|}
block|,
block|{
literal|"headers"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'e'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'H'
block|}
block|,
block|{
literal|"hex-dump"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'x'
block|}
block|,
block|{
literal|"histogram"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'I'
block|}
block|,
block|{
literal|"notes"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'n'
block|}
block|,
block|{
literal|"program-headers"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'l'
block|}
block|,
block|{
literal|"relocs"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'r'
block|}
block|,
block|{
literal|"sections"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'S'
block|}
block|,
block|{
literal|"section-headers"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'S'
block|}
block|,
block|{
literal|"section-groups"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'g'
block|}
block|,
block|{
literal|"section-details"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'t'
block|}
block|,
block|{
literal|"segments"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'l'
block|}
block|,
block|{
literal|"string-dump"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'p'
block|}
block|,
block|{
literal|"symbols"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
literal|"syms"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
literal|"unwind"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'u'
block|}
block|,
block|{
literal|"use-dynamic"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'D'
block|}
block|,
block|{
literal|"version-info"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'V'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'v'
block|}
block|,
block|{
literal|"wide"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'W'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|eflags_desc
block|{
name|uint64_t
name|flag
decl_stmt|;
specifier|const
name|char
modifier|*
name|desc
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mips_option
block|{
name|uint64_t
name|flag
decl_stmt|;
specifier|const
name|char
modifier|*
name|desc
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|add_dumpop
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|size_t
name|si
parameter_list|,
specifier|const
name|char
modifier|*
name|sn
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_adv_simd_arch
parameter_list|(
name|uint64_t
name|simd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_align_needed
parameter_list|(
name|uint64_t
name|an
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_align_preserved
parameter_list|(
name|uint64_t
name|ap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_arm_isa
parameter_list|(
name|uint64_t
name|ai
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_cpu_arch
parameter_list|(
name|uint64_t
name|arch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_cpu_arch_profile
parameter_list|(
name|uint64_t
name|pf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_div
parameter_list|(
name|uint64_t
name|du
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_enum_size
parameter_list|(
name|uint64_t
name|es
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_fp_16bit_format
parameter_list|(
name|uint64_t
name|fp16
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_fp_arch
parameter_list|(
name|uint64_t
name|fp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_fp_denormal
parameter_list|(
name|uint64_t
name|fd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_fp_exceptions
parameter_list|(
name|uint64_t
name|fe
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_fp_hpext
parameter_list|(
name|uint64_t
name|fh
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_fp_number_model
parameter_list|(
name|uint64_t
name|fn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_fp_optm_goal
parameter_list|(
name|uint64_t
name|fog
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_fp_rounding
parameter_list|(
name|uint64_t
name|fr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_hardfp
parameter_list|(
name|uint64_t
name|hfp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_mpext
parameter_list|(
name|uint64_t
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_optm_goal
parameter_list|(
name|uint64_t
name|og
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_pcs_config
parameter_list|(
name|uint64_t
name|pcs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_pcs_got
parameter_list|(
name|uint64_t
name|got
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_pcs_r9
parameter_list|(
name|uint64_t
name|r9
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_pcs_ro
parameter_list|(
name|uint64_t
name|ro
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_pcs_rw
parameter_list|(
name|uint64_t
name|rw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_pcs_wchar_t
parameter_list|(
name|uint64_t
name|wt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_t2ee
parameter_list|(
name|uint64_t
name|t2ee
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_thumb_isa
parameter_list|(
name|uint64_t
name|ti
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_fp_user_exceptions
parameter_list|(
name|uint64_t
name|fu
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_unaligned_access
parameter_list|(
name|uint64_t
name|ua
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_vfp_args
parameter_list|(
name|uint64_t
name|va
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_virtual
parameter_list|(
name|uint64_t
name|vt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_wmmx_arch
parameter_list|(
name|uint64_t
name|wmmx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_wmmx_args
parameter_list|(
name|uint64_t
name|wa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|elf_class
parameter_list|(
name|unsigned
name|int
name|class
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|elf_endian
parameter_list|(
name|unsigned
name|int
name|endian
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|elf_machine
parameter_list|(
name|unsigned
name|int
name|mach
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|elf_osabi
parameter_list|(
name|unsigned
name|int
name|abi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|elf_type
parameter_list|(
name|unsigned
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|elf_ver
parameter_list|(
name|unsigned
name|int
name|ver
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|dt_type
parameter_list|(
name|unsigned
name|int
name|mach
parameter_list|,
name|unsigned
name|int
name|dtype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_ar
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_arm_attributes
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|uint8_t
modifier|*
name|p
parameter_list|,
name|uint8_t
modifier|*
name|pe
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_attributes
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
modifier|*
name|dump_compatibility_tag
parameter_list|(
name|uint8_t
modifier|*
name|p
parameter_list|,
name|uint8_t
modifier|*
name|pe
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_dwarf
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_dwarf_abbrev
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_dwarf_aranges
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_dwarf_block
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|uint8_t
modifier|*
name|b
parameter_list|,
name|Dwarf_Unsigned
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_dwarf_die
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|,
name|int
name|level
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_dwarf_frame
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|int
name|alt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_dwarf_frame_inst
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|Dwarf_Cie
name|cie
parameter_list|,
name|uint8_t
modifier|*
name|insts
parameter_list|,
name|Dwarf_Unsigned
name|len
parameter_list|,
name|Dwarf_Unsigned
name|caf
parameter_list|,
name|Dwarf_Signed
name|daf
parameter_list|,
name|Dwarf_Addr
name|pc
parameter_list|,
name|Dwarf_Debug
name|dbg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dump_dwarf_frame_regtable
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|Dwarf_Fde
name|fde
parameter_list|,
name|Dwarf_Addr
name|pc
parameter_list|,
name|Dwarf_Unsigned
name|func_len
parameter_list|,
name|Dwarf_Half
name|cie_ra
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_dwarf_frame_section
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|,
name|int
name|alt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_dwarf_info
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|Dwarf_Bool
name|is_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_dwarf_macinfo
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_dwarf_line
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_dwarf_line_decoded
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_dwarf_loc
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|Dwarf_Loc
modifier|*
name|lr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_dwarf_loclist
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_dwarf_pubnames
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_dwarf_ranges
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_dwarf_ranges_foreach
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|,
name|Dwarf_Addr
name|base
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_dwarf_str
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_eflags
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|uint64_t
name|e_flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_elf
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_dyn_val
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|GElf_Dyn
modifier|*
name|dyn
parameter_list|,
name|uint32_t
name|stab
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_dynamic
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_liblist
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_mips_abiflags
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_mips_attributes
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|uint8_t
modifier|*
name|p
parameter_list|,
name|uint8_t
modifier|*
name|pe
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_mips_odk_reginfo
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|uint8_t
modifier|*
name|p
parameter_list|,
name|size_t
name|sz
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_mips_options
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_mips_option_flags
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|mips_option
modifier|*
name|opt
parameter_list|,
name|uint64_t
name|info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_mips_reginfo
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_mips_specific_info
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_notes
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_notes_content
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|sz
parameter_list|,
name|off_t
name|off
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_svr4_hash
parameter_list|(
name|struct
name|section
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_svr4_hash64
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_gnu_hash
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_hash
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_phdr
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_ppc_attributes
parameter_list|(
name|uint8_t
modifier|*
name|p
parameter_list|,
name|uint8_t
modifier|*
name|pe
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_section_groups
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_symtab
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|int
name|i
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_symtabs
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
modifier|*
name|dump_unknown_tag
parameter_list|(
name|uint64_t
name|tag
parameter_list|,
name|uint8_t
modifier|*
name|p
parameter_list|,
name|uint8_t
modifier|*
name|pe
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_ver
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_verdef
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|int
name|dump
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_verneed
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|int
name|dump
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_versym
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_reg
parameter_list|(
name|unsigned
name|int
name|mach
parameter_list|,
name|unsigned
name|int
name|reg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_regname
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|unsigned
name|int
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|dumpop
modifier|*
name|find_dumpop
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|size_t
name|si
parameter_list|,
specifier|const
name|char
modifier|*
name|sn
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_ent_count
parameter_list|(
name|struct
name|section
modifier|*
name|s
parameter_list|,
name|int
modifier|*
name|ent_count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_mips_register_size
parameter_list|(
name|uint8_t
name|flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|get_regoff_str
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|Dwarf_Half
name|reg
parameter_list|,
name|Dwarf_Addr
name|off
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|get_string
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|int
name|strtab
parameter_list|,
name|size_t
name|off
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|get_symbol_name
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|int
name|symtab
parameter_list|,
name|int
name|i
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|get_symbol_value
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|int
name|symtab
parameter_list|,
name|int
name|i
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|load_sections
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|mips_abi_fp
parameter_list|(
name|uint64_t
name|fp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|note_type
parameter_list|(
specifier|const
name|char
modifier|*
name|note_name
parameter_list|,
name|unsigned
name|int
name|et
parameter_list|,
name|unsigned
name|int
name|nt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|note_type_freebsd
parameter_list|(
name|unsigned
name|int
name|nt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|note_type_freebsd_core
parameter_list|(
name|unsigned
name|int
name|nt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|note_type_linux_core
parameter_list|(
name|unsigned
name|int
name|nt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|note_type_gnu
parameter_list|(
name|unsigned
name|int
name|nt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|note_type_netbsd
parameter_list|(
name|unsigned
name|int
name|nt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|note_type_openbsd
parameter_list|(
name|unsigned
name|int
name|nt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|note_type_unknown
parameter_list|(
name|unsigned
name|int
name|nt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|note_type_xen
parameter_list|(
name|unsigned
name|int
name|nt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|option_kind
parameter_list|(
name|uint8_t
name|kind
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|phdr_type
parameter_list|(
name|unsigned
name|int
name|mach
parameter_list|,
name|unsigned
name|int
name|ptype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|ppc_abi_fp
parameter_list|(
name|uint64_t
name|fp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|ppc_abi_vector
parameter_list|(
name|uint64_t
name|vec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|readelf_usage
parameter_list|(
name|int
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|readelf_version
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|search_loclist_at
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|,
name|Dwarf_Unsigned
name|lowpc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|search_ver
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|section_type
parameter_list|(
name|unsigned
name|int
name|mach
parameter_list|,
name|unsigned
name|int
name|stype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_cu_context
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|Dwarf_Half
name|psize
parameter_list|,
name|Dwarf_Half
name|osize
parameter_list|,
name|Dwarf_Half
name|ver
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|st_bind
parameter_list|(
name|unsigned
name|int
name|sbind
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|st_shndx
parameter_list|(
name|unsigned
name|int
name|shndx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|st_type
parameter_list|(
name|unsigned
name|int
name|mach
parameter_list|,
name|unsigned
name|int
name|os
parameter_list|,
name|unsigned
name|int
name|stype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|st_vis
parameter_list|(
name|unsigned
name|int
name|svis
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|top_tag
parameter_list|(
name|unsigned
name|int
name|tag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unload_sections
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|_read_lsb
parameter_list|(
name|Elf_Data
modifier|*
name|d
parameter_list|,
name|uint64_t
modifier|*
name|offsetp
parameter_list|,
name|int
name|bytes_to_read
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|_read_msb
parameter_list|(
name|Elf_Data
modifier|*
name|d
parameter_list|,
name|uint64_t
modifier|*
name|offsetp
parameter_list|,
name|int
name|bytes_to_read
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|_decode_lsb
parameter_list|(
name|uint8_t
modifier|*
modifier|*
name|data
parameter_list|,
name|int
name|bytes_to_read
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|_decode_msb
parameter_list|(
name|uint8_t
modifier|*
modifier|*
name|data
parameter_list|,
name|int
name|bytes_to_read
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|_decode_sleb128
parameter_list|(
name|uint8_t
modifier|*
modifier|*
name|dp
parameter_list|,
name|uint8_t
modifier|*
name|dpe
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|_decode_uleb128
parameter_list|(
name|uint8_t
modifier|*
modifier|*
name|dp
parameter_list|,
name|uint8_t
modifier|*
name|dpe
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|eflags_desc
name|arm_eflags_desc
index|[]
init|=
block|{
block|{
name|EF_ARM_RELEXEC
block|,
literal|"relocatable executable"
block|}
block|,
block|{
name|EF_ARM_HASENTRY
block|,
literal|"has entry point"
block|}
block|,
block|{
name|EF_ARM_SYMSARESORTED
block|,
literal|"sorted symbol tables"
block|}
block|,
block|{
name|EF_ARM_DYNSYMSUSESEGIDX
block|,
literal|"dynamic symbols use segment index"
block|}
block|,
block|{
name|EF_ARM_MAPSYMSFIRST
block|,
literal|"mapping symbols precede others"
block|}
block|,
block|{
name|EF_ARM_BE8
block|,
literal|"BE8"
block|}
block|,
block|{
name|EF_ARM_LE8
block|,
literal|"LE8"
block|}
block|,
block|{
name|EF_ARM_INTERWORK
block|,
literal|"interworking enabled"
block|}
block|,
block|{
name|EF_ARM_APCS_26
block|,
literal|"uses APCS/26"
block|}
block|,
block|{
name|EF_ARM_APCS_FLOAT
block|,
literal|"uses APCS/float"
block|}
block|,
block|{
name|EF_ARM_PIC
block|,
literal|"position independent"
block|}
block|,
block|{
name|EF_ARM_ALIGN8
block|,
literal|"8 bit structure alignment"
block|}
block|,
block|{
name|EF_ARM_NEW_ABI
block|,
literal|"uses new ABI"
block|}
block|,
block|{
name|EF_ARM_OLD_ABI
block|,
literal|"uses old ABI"
block|}
block|,
block|{
name|EF_ARM_SOFT_FLOAT
block|,
literal|"software FP"
block|}
block|,
block|{
name|EF_ARM_VFP_FLOAT
block|,
literal|"VFP"
block|}
block|,
block|{
name|EF_ARM_MAVERICK_FLOAT
block|,
literal|"Maverick FP"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|eflags_desc
name|mips_eflags_desc
index|[]
init|=
block|{
block|{
name|EF_MIPS_NOREORDER
block|,
literal|"noreorder"
block|}
block|,
block|{
name|EF_MIPS_PIC
block|,
literal|"pic"
block|}
block|,
block|{
name|EF_MIPS_CPIC
block|,
literal|"cpic"
block|}
block|,
block|{
name|EF_MIPS_UCODE
block|,
literal|"ugen_reserved"
block|}
block|,
block|{
name|EF_MIPS_ABI2
block|,
literal|"abi2"
block|}
block|,
block|{
name|EF_MIPS_OPTIONS_FIRST
block|,
literal|"odk first"
block|}
block|,
block|{
name|EF_MIPS_ARCH_ASE_MDMX
block|,
literal|"mdmx"
block|}
block|,
block|{
name|EF_MIPS_ARCH_ASE_M16
block|,
literal|"mips16"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|eflags_desc
name|powerpc_eflags_desc
index|[]
init|=
block|{
block|{
name|EF_PPC_EMB
block|,
literal|"emb"
block|}
block|,
block|{
name|EF_PPC_RELOCATABLE
block|,
literal|"relocatable"
block|}
block|,
block|{
name|EF_PPC_RELOCATABLE_LIB
block|,
literal|"relocatable-lib"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|eflags_desc
name|sparc_eflags_desc
index|[]
init|=
block|{
block|{
name|EF_SPARC_32PLUS
block|,
literal|"v8+"
block|}
block|,
block|{
name|EF_SPARC_SUN_US1
block|,
literal|"ultrasparcI"
block|}
block|,
block|{
name|EF_SPARC_HAL_R1
block|,
literal|"halr1"
block|}
block|,
block|{
name|EF_SPARC_SUN_US3
block|,
literal|"ultrasparcIII"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|elf_osabi
parameter_list|(
name|unsigned
name|int
name|abi
parameter_list|)
block|{
specifier|static
name|char
name|s_abi
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|abi
condition|)
block|{
case|case
name|ELFOSABI_NONE
case|:
return|return
literal|"NONE"
return|;
case|case
name|ELFOSABI_HPUX
case|:
return|return
literal|"HPUX"
return|;
case|case
name|ELFOSABI_NETBSD
case|:
return|return
literal|"NetBSD"
return|;
case|case
name|ELFOSABI_GNU
case|:
return|return
literal|"GNU"
return|;
case|case
name|ELFOSABI_HURD
case|:
return|return
literal|"HURD"
return|;
case|case
name|ELFOSABI_86OPEN
case|:
return|return
literal|"86OPEN"
return|;
case|case
name|ELFOSABI_SOLARIS
case|:
return|return
literal|"Solaris"
return|;
case|case
name|ELFOSABI_AIX
case|:
return|return
literal|"AIX"
return|;
case|case
name|ELFOSABI_IRIX
case|:
return|return
literal|"IRIX"
return|;
case|case
name|ELFOSABI_FREEBSD
case|:
return|return
literal|"FreeBSD"
return|;
case|case
name|ELFOSABI_TRU64
case|:
return|return
literal|"TRU64"
return|;
case|case
name|ELFOSABI_MODESTO
case|:
return|return
literal|"MODESTO"
return|;
case|case
name|ELFOSABI_OPENBSD
case|:
return|return
literal|"OpenBSD"
return|;
case|case
name|ELFOSABI_OPENVMS
case|:
return|return
literal|"OpenVMS"
return|;
case|case
name|ELFOSABI_NSK
case|:
return|return
literal|"NSK"
return|;
case|case
name|ELFOSABI_CLOUDABI
case|:
return|return
literal|"CloudABI"
return|;
case|case
name|ELFOSABI_ARM_AEABI
case|:
return|return
literal|"ARM EABI"
return|;
case|case
name|ELFOSABI_ARM
case|:
return|return
literal|"ARM"
return|;
case|case
name|ELFOSABI_STANDALONE
case|:
return|return
literal|"StandAlone"
return|;
default|default:
name|snprintf
argument_list|(
name|s_abi
argument_list|,
sizeof|sizeof
argument_list|(
name|s_abi
argument_list|)
argument_list|,
literal|"<unknown: %#x>"
argument_list|,
name|abi
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_abi
operator|)
return|;
block|}
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|elf_machine
parameter_list|(
name|unsigned
name|int
name|mach
parameter_list|)
block|{
specifier|static
name|char
name|s_mach
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|mach
condition|)
block|{
case|case
name|EM_NONE
case|:
return|return
literal|"Unknown machine"
return|;
case|case
name|EM_M32
case|:
return|return
literal|"AT&T WE32100"
return|;
case|case
name|EM_SPARC
case|:
return|return
literal|"Sun SPARC"
return|;
case|case
name|EM_386
case|:
return|return
literal|"Intel i386"
return|;
case|case
name|EM_68K
case|:
return|return
literal|"Motorola 68000"
return|;
case|case
name|EM_IAMCU
case|:
return|return
literal|"Intel MCU"
return|;
case|case
name|EM_88K
case|:
return|return
literal|"Motorola 88000"
return|;
case|case
name|EM_860
case|:
return|return
literal|"Intel i860"
return|;
case|case
name|EM_MIPS
case|:
return|return
literal|"MIPS R3000 Big-Endian only"
return|;
case|case
name|EM_S370
case|:
return|return
literal|"IBM System/370"
return|;
case|case
name|EM_MIPS_RS3_LE
case|:
return|return
literal|"MIPS R3000 Little-Endian"
return|;
case|case
name|EM_PARISC
case|:
return|return
literal|"HP PA-RISC"
return|;
case|case
name|EM_VPP500
case|:
return|return
literal|"Fujitsu VPP500"
return|;
case|case
name|EM_SPARC32PLUS
case|:
return|return
literal|"SPARC v8plus"
return|;
case|case
name|EM_960
case|:
return|return
literal|"Intel 80960"
return|;
case|case
name|EM_PPC
case|:
return|return
literal|"PowerPC 32-bit"
return|;
case|case
name|EM_PPC64
case|:
return|return
literal|"PowerPC 64-bit"
return|;
case|case
name|EM_S390
case|:
return|return
literal|"IBM System/390"
return|;
case|case
name|EM_V800
case|:
return|return
literal|"NEC V800"
return|;
case|case
name|EM_FR20
case|:
return|return
literal|"Fujitsu FR20"
return|;
case|case
name|EM_RH32
case|:
return|return
literal|"TRW RH-32"
return|;
case|case
name|EM_RCE
case|:
return|return
literal|"Motorola RCE"
return|;
case|case
name|EM_ARM
case|:
return|return
literal|"ARM"
return|;
case|case
name|EM_SH
case|:
return|return
literal|"Hitachi SH"
return|;
case|case
name|EM_SPARCV9
case|:
return|return
literal|"SPARC v9 64-bit"
return|;
case|case
name|EM_TRICORE
case|:
return|return
literal|"Siemens TriCore embedded processor"
return|;
case|case
name|EM_ARC
case|:
return|return
literal|"Argonaut RISC Core"
return|;
case|case
name|EM_H8_300
case|:
return|return
literal|"Hitachi H8/300"
return|;
case|case
name|EM_H8_300H
case|:
return|return
literal|"Hitachi H8/300H"
return|;
case|case
name|EM_H8S
case|:
return|return
literal|"Hitachi H8S"
return|;
case|case
name|EM_H8_500
case|:
return|return
literal|"Hitachi H8/500"
return|;
case|case
name|EM_IA_64
case|:
return|return
literal|"Intel IA-64 Processor"
return|;
case|case
name|EM_MIPS_X
case|:
return|return
literal|"Stanford MIPS-X"
return|;
case|case
name|EM_COLDFIRE
case|:
return|return
literal|"Motorola ColdFire"
return|;
case|case
name|EM_68HC12
case|:
return|return
literal|"Motorola M68HC12"
return|;
case|case
name|EM_MMA
case|:
return|return
literal|"Fujitsu MMA"
return|;
case|case
name|EM_PCP
case|:
return|return
literal|"Siemens PCP"
return|;
case|case
name|EM_NCPU
case|:
return|return
literal|"Sony nCPU"
return|;
case|case
name|EM_NDR1
case|:
return|return
literal|"Denso NDR1 microprocessor"
return|;
case|case
name|EM_STARCORE
case|:
return|return
literal|"Motorola Star*Core processor"
return|;
case|case
name|EM_ME16
case|:
return|return
literal|"Toyota ME16 processor"
return|;
case|case
name|EM_ST100
case|:
return|return
literal|"STMicroelectronics ST100 processor"
return|;
case|case
name|EM_TINYJ
case|:
return|return
literal|"Advanced Logic Corp. TinyJ processor"
return|;
case|case
name|EM_X86_64
case|:
return|return
literal|"Advanced Micro Devices x86-64"
return|;
case|case
name|EM_PDSP
case|:
return|return
literal|"Sony DSP Processor"
return|;
case|case
name|EM_FX66
case|:
return|return
literal|"Siemens FX66 microcontroller"
return|;
case|case
name|EM_ST9PLUS
case|:
return|return
literal|"STMicroelectronics ST9+ 8/16 microcontroller"
return|;
case|case
name|EM_ST7
case|:
return|return
literal|"STmicroelectronics ST7 8-bit microcontroller"
return|;
case|case
name|EM_68HC16
case|:
return|return
literal|"Motorola MC68HC16 microcontroller"
return|;
case|case
name|EM_68HC11
case|:
return|return
literal|"Motorola MC68HC11 microcontroller"
return|;
case|case
name|EM_68HC08
case|:
return|return
literal|"Motorola MC68HC08 microcontroller"
return|;
case|case
name|EM_68HC05
case|:
return|return
literal|"Motorola MC68HC05 microcontroller"
return|;
case|case
name|EM_SVX
case|:
return|return
literal|"Silicon Graphics SVx"
return|;
case|case
name|EM_ST19
case|:
return|return
literal|"STMicroelectronics ST19 8-bit mc"
return|;
case|case
name|EM_VAX
case|:
return|return
literal|"Digital VAX"
return|;
case|case
name|EM_CRIS
case|:
return|return
literal|"Axis Communications 32-bit embedded processor"
return|;
case|case
name|EM_JAVELIN
case|:
return|return
literal|"Infineon Tech. 32bit embedded processor"
return|;
case|case
name|EM_FIREPATH
case|:
return|return
literal|"Element 14 64-bit DSP Processor"
return|;
case|case
name|EM_ZSP
case|:
return|return
literal|"LSI Logic 16-bit DSP Processor"
return|;
case|case
name|EM_MMIX
case|:
return|return
literal|"Donald Knuth's educational 64-bit proc"
return|;
case|case
name|EM_HUANY
case|:
return|return
literal|"Harvard University MI object files"
return|;
case|case
name|EM_PRISM
case|:
return|return
literal|"SiTera Prism"
return|;
case|case
name|EM_AVR
case|:
return|return
literal|"Atmel AVR 8-bit microcontroller"
return|;
case|case
name|EM_FR30
case|:
return|return
literal|"Fujitsu FR30"
return|;
case|case
name|EM_D10V
case|:
return|return
literal|"Mitsubishi D10V"
return|;
case|case
name|EM_D30V
case|:
return|return
literal|"Mitsubishi D30V"
return|;
case|case
name|EM_V850
case|:
return|return
literal|"NEC v850"
return|;
case|case
name|EM_M32R
case|:
return|return
literal|"Mitsubishi M32R"
return|;
case|case
name|EM_MN10300
case|:
return|return
literal|"Matsushita MN10300"
return|;
case|case
name|EM_MN10200
case|:
return|return
literal|"Matsushita MN10200"
return|;
case|case
name|EM_PJ
case|:
return|return
literal|"picoJava"
return|;
case|case
name|EM_OPENRISC
case|:
return|return
literal|"OpenRISC 32-bit embedded processor"
return|;
case|case
name|EM_ARC_A5
case|:
return|return
literal|"ARC Cores Tangent-A5"
return|;
case|case
name|EM_XTENSA
case|:
return|return
literal|"Tensilica Xtensa Architecture"
return|;
case|case
name|EM_VIDEOCORE
case|:
return|return
literal|"Alphamosaic VideoCore processor"
return|;
case|case
name|EM_TMM_GPP
case|:
return|return
literal|"Thompson Multimedia General Purpose Processor"
return|;
case|case
name|EM_NS32K
case|:
return|return
literal|"National Semiconductor 32000 series"
return|;
case|case
name|EM_TPC
case|:
return|return
literal|"Tenor Network TPC processor"
return|;
case|case
name|EM_SNP1K
case|:
return|return
literal|"Trebia SNP 1000 processor"
return|;
case|case
name|EM_ST200
case|:
return|return
literal|"STMicroelectronics ST200 microcontroller"
return|;
case|case
name|EM_IP2K
case|:
return|return
literal|"Ubicom IP2xxx microcontroller family"
return|;
case|case
name|EM_MAX
case|:
return|return
literal|"MAX Processor"
return|;
case|case
name|EM_CR
case|:
return|return
literal|"National Semiconductor CompactRISC microprocessor"
return|;
case|case
name|EM_F2MC16
case|:
return|return
literal|"Fujitsu F2MC16"
return|;
case|case
name|EM_MSP430
case|:
return|return
literal|"TI embedded microcontroller msp430"
return|;
case|case
name|EM_BLACKFIN
case|:
return|return
literal|"Analog Devices Blackfin (DSP) processor"
return|;
case|case
name|EM_SE_C33
case|:
return|return
literal|"S1C33 Family of Seiko Epson processors"
return|;
case|case
name|EM_SEP
case|:
return|return
literal|"Sharp embedded microprocessor"
return|;
case|case
name|EM_ARCA
case|:
return|return
literal|"Arca RISC Microprocessor"
return|;
case|case
name|EM_UNICORE
case|:
return|return
literal|"Microprocessor series from PKU-Unity Ltd"
return|;
case|case
name|EM_AARCH64
case|:
return|return
literal|"AArch64"
return|;
case|case
name|EM_RISCV
case|:
return|return
literal|"RISC-V"
return|;
default|default:
name|snprintf
argument_list|(
name|s_mach
argument_list|,
sizeof|sizeof
argument_list|(
name|s_mach
argument_list|)
argument_list|,
literal|"<unknown: %#x>"
argument_list|,
name|mach
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_mach
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|elf_class
parameter_list|(
name|unsigned
name|int
name|class
parameter_list|)
block|{
specifier|static
name|char
name|s_class
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|ELFCLASSNONE
case|:
return|return
literal|"none"
return|;
case|case
name|ELFCLASS32
case|:
return|return
literal|"ELF32"
return|;
case|case
name|ELFCLASS64
case|:
return|return
literal|"ELF64"
return|;
default|default:
name|snprintf
argument_list|(
name|s_class
argument_list|,
sizeof|sizeof
argument_list|(
name|s_class
argument_list|)
argument_list|,
literal|"<unknown: %#x>"
argument_list|,
name|class
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_class
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|elf_endian
parameter_list|(
name|unsigned
name|int
name|endian
parameter_list|)
block|{
specifier|static
name|char
name|s_endian
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|endian
condition|)
block|{
case|case
name|ELFDATANONE
case|:
return|return
literal|"none"
return|;
case|case
name|ELFDATA2LSB
case|:
return|return
literal|"2's complement, little endian"
return|;
case|case
name|ELFDATA2MSB
case|:
return|return
literal|"2's complement, big endian"
return|;
default|default:
name|snprintf
argument_list|(
name|s_endian
argument_list|,
sizeof|sizeof
argument_list|(
name|s_endian
argument_list|)
argument_list|,
literal|"<unknown: %#x>"
argument_list|,
name|endian
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_endian
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|elf_type
parameter_list|(
name|unsigned
name|int
name|type
parameter_list|)
block|{
specifier|static
name|char
name|s_type
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ET_NONE
case|:
return|return
literal|"NONE (None)"
return|;
case|case
name|ET_REL
case|:
return|return
literal|"REL (Relocatable file)"
return|;
case|case
name|ET_EXEC
case|:
return|return
literal|"EXEC (Executable file)"
return|;
case|case
name|ET_DYN
case|:
return|return
literal|"DYN (Shared object file)"
return|;
case|case
name|ET_CORE
case|:
return|return
literal|"CORE (Core file)"
return|;
default|default:
if|if
condition|(
name|type
operator|>=
name|ET_LOPROC
condition|)
name|snprintf
argument_list|(
name|s_type
argument_list|,
sizeof|sizeof
argument_list|(
name|s_type
argument_list|)
argument_list|,
literal|"<proc: %#x>"
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|>=
name|ET_LOOS
operator|&&
name|type
operator|<=
name|ET_HIOS
condition|)
name|snprintf
argument_list|(
name|s_type
argument_list|,
sizeof|sizeof
argument_list|(
name|s_type
argument_list|)
argument_list|,
literal|"<os: %#x>"
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|s_type
argument_list|,
sizeof|sizeof
argument_list|(
name|s_type
argument_list|)
argument_list|,
literal|"<unknown: %#x>"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_type
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|elf_ver
parameter_list|(
name|unsigned
name|int
name|ver
parameter_list|)
block|{
specifier|static
name|char
name|s_ver
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|ver
condition|)
block|{
case|case
name|EV_CURRENT
case|:
return|return
literal|"(current)"
return|;
case|case
name|EV_NONE
case|:
return|return
literal|"(none)"
return|;
default|default:
name|snprintf
argument_list|(
name|s_ver
argument_list|,
sizeof|sizeof
argument_list|(
name|s_ver
argument_list|)
argument_list|,
literal|"<unknown: %#x>"
argument_list|,
name|ver
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_ver
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|phdr_type
parameter_list|(
name|unsigned
name|int
name|mach
parameter_list|,
name|unsigned
name|int
name|ptype
parameter_list|)
block|{
specifier|static
name|char
name|s_ptype
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
name|ptype
operator|>=
name|PT_LOPROC
operator|&&
name|ptype
operator|<=
name|PT_HIPROC
condition|)
block|{
switch|switch
condition|(
name|mach
condition|)
block|{
case|case
name|EM_ARM
case|:
switch|switch
condition|(
name|ptype
condition|)
block|{
case|case
name|PT_ARM_ARCHEXT
case|:
return|return
literal|"ARM_ARCHEXT"
return|;
case|case
name|PT_ARM_EXIDX
case|:
return|return
literal|"ARM_EXIDX"
return|;
block|}
break|break;
block|}
name|snprintf
argument_list|(
name|s_ptype
argument_list|,
sizeof|sizeof
argument_list|(
name|s_ptype
argument_list|)
argument_list|,
literal|"LOPROC+%#x"
argument_list|,
name|ptype
operator|-
name|PT_LOPROC
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_ptype
operator|)
return|;
block|}
switch|switch
condition|(
name|ptype
condition|)
block|{
case|case
name|PT_NULL
case|:
return|return
literal|"NULL"
return|;
case|case
name|PT_LOAD
case|:
return|return
literal|"LOAD"
return|;
case|case
name|PT_DYNAMIC
case|:
return|return
literal|"DYNAMIC"
return|;
case|case
name|PT_INTERP
case|:
return|return
literal|"INTERP"
return|;
case|case
name|PT_NOTE
case|:
return|return
literal|"NOTE"
return|;
case|case
name|PT_SHLIB
case|:
return|return
literal|"SHLIB"
return|;
case|case
name|PT_PHDR
case|:
return|return
literal|"PHDR"
return|;
case|case
name|PT_TLS
case|:
return|return
literal|"TLS"
return|;
case|case
name|PT_GNU_EH_FRAME
case|:
return|return
literal|"GNU_EH_FRAME"
return|;
case|case
name|PT_GNU_STACK
case|:
return|return
literal|"GNU_STACK"
return|;
case|case
name|PT_GNU_RELRO
case|:
return|return
literal|"GNU_RELRO"
return|;
default|default:
if|if
condition|(
name|ptype
operator|>=
name|PT_LOOS
operator|&&
name|ptype
operator|<=
name|PT_HIOS
condition|)
name|snprintf
argument_list|(
name|s_ptype
argument_list|,
sizeof|sizeof
argument_list|(
name|s_ptype
argument_list|)
argument_list|,
literal|"LOOS+%#x"
argument_list|,
name|ptype
operator|-
name|PT_LOOS
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|s_ptype
argument_list|,
sizeof|sizeof
argument_list|(
name|s_ptype
argument_list|)
argument_list|,
literal|"<unknown: %#x>"
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_ptype
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|section_type
parameter_list|(
name|unsigned
name|int
name|mach
parameter_list|,
name|unsigned
name|int
name|stype
parameter_list|)
block|{
specifier|static
name|char
name|s_stype
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
name|stype
operator|>=
name|SHT_LOPROC
operator|&&
name|stype
operator|<=
name|SHT_HIPROC
condition|)
block|{
switch|switch
condition|(
name|mach
condition|)
block|{
case|case
name|EM_ARM
case|:
switch|switch
condition|(
name|stype
condition|)
block|{
case|case
name|SHT_ARM_EXIDX
case|:
return|return
literal|"ARM_EXIDX"
return|;
case|case
name|SHT_ARM_PREEMPTMAP
case|:
return|return
literal|"ARM_PREEMPTMAP"
return|;
case|case
name|SHT_ARM_ATTRIBUTES
case|:
return|return
literal|"ARM_ATTRIBUTES"
return|;
case|case
name|SHT_ARM_DEBUGOVERLAY
case|:
return|return
literal|"ARM_DEBUGOVERLAY"
return|;
case|case
name|SHT_ARM_OVERLAYSECTION
case|:
return|return
literal|"ARM_OVERLAYSECTION"
return|;
block|}
break|break;
case|case
name|EM_X86_64
case|:
switch|switch
condition|(
name|stype
condition|)
block|{
case|case
name|SHT_X86_64_UNWIND
case|:
return|return
literal|"X86_64_UNWIND"
return|;
default|default:
break|break;
block|}
break|break;
case|case
name|EM_MIPS
case|:
case|case
name|EM_MIPS_RS3_LE
case|:
switch|switch
condition|(
name|stype
condition|)
block|{
case|case
name|SHT_MIPS_LIBLIST
case|:
return|return
literal|"MIPS_LIBLIST"
return|;
case|case
name|SHT_MIPS_MSYM
case|:
return|return
literal|"MIPS_MSYM"
return|;
case|case
name|SHT_MIPS_CONFLICT
case|:
return|return
literal|"MIPS_CONFLICT"
return|;
case|case
name|SHT_MIPS_GPTAB
case|:
return|return
literal|"MIPS_GPTAB"
return|;
case|case
name|SHT_MIPS_UCODE
case|:
return|return
literal|"MIPS_UCODE"
return|;
case|case
name|SHT_MIPS_DEBUG
case|:
return|return
literal|"MIPS_DEBUG"
return|;
case|case
name|SHT_MIPS_REGINFO
case|:
return|return
literal|"MIPS_REGINFO"
return|;
case|case
name|SHT_MIPS_PACKAGE
case|:
return|return
literal|"MIPS_PACKAGE"
return|;
case|case
name|SHT_MIPS_PACKSYM
case|:
return|return
literal|"MIPS_PACKSYM"
return|;
case|case
name|SHT_MIPS_RELD
case|:
return|return
literal|"MIPS_RELD"
return|;
case|case
name|SHT_MIPS_IFACE
case|:
return|return
literal|"MIPS_IFACE"
return|;
case|case
name|SHT_MIPS_CONTENT
case|:
return|return
literal|"MIPS_CONTENT"
return|;
case|case
name|SHT_MIPS_OPTIONS
case|:
return|return
literal|"MIPS_OPTIONS"
return|;
case|case
name|SHT_MIPS_DELTASYM
case|:
return|return
literal|"MIPS_DELTASYM"
return|;
case|case
name|SHT_MIPS_DELTAINST
case|:
return|return
literal|"MIPS_DELTAINST"
return|;
case|case
name|SHT_MIPS_DELTACLASS
case|:
return|return
literal|"MIPS_DELTACLASS"
return|;
case|case
name|SHT_MIPS_DWARF
case|:
return|return
literal|"MIPS_DWARF"
return|;
case|case
name|SHT_MIPS_DELTADECL
case|:
return|return
literal|"MIPS_DELTADECL"
return|;
case|case
name|SHT_MIPS_SYMBOL_LIB
case|:
return|return
literal|"MIPS_SYMBOL_LIB"
return|;
case|case
name|SHT_MIPS_EVENTS
case|:
return|return
literal|"MIPS_EVENTS"
return|;
case|case
name|SHT_MIPS_TRANSLATE
case|:
return|return
literal|"MIPS_TRANSLATE"
return|;
case|case
name|SHT_MIPS_PIXIE
case|:
return|return
literal|"MIPS_PIXIE"
return|;
case|case
name|SHT_MIPS_XLATE
case|:
return|return
literal|"MIPS_XLATE"
return|;
case|case
name|SHT_MIPS_XLATE_DEBUG
case|:
return|return
literal|"MIPS_XLATE_DEBUG"
return|;
case|case
name|SHT_MIPS_WHIRL
case|:
return|return
literal|"MIPS_WHIRL"
return|;
case|case
name|SHT_MIPS_EH_REGION
case|:
return|return
literal|"MIPS_EH_REGION"
return|;
case|case
name|SHT_MIPS_XLATE_OLD
case|:
return|return
literal|"MIPS_XLATE_OLD"
return|;
case|case
name|SHT_MIPS_PDR_EXCEPTION
case|:
return|return
literal|"MIPS_PDR_EXCEPTION"
return|;
case|case
name|SHT_MIPS_ABIFLAGS
case|:
return|return
literal|"MIPS_ABIFLAGS"
return|;
default|default:
break|break;
block|}
break|break;
default|default:
break|break;
block|}
name|snprintf
argument_list|(
name|s_stype
argument_list|,
sizeof|sizeof
argument_list|(
name|s_stype
argument_list|)
argument_list|,
literal|"LOPROC+%#x"
argument_list|,
name|stype
operator|-
name|SHT_LOPROC
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_stype
operator|)
return|;
block|}
switch|switch
condition|(
name|stype
condition|)
block|{
case|case
name|SHT_NULL
case|:
return|return
literal|"NULL"
return|;
case|case
name|SHT_PROGBITS
case|:
return|return
literal|"PROGBITS"
return|;
case|case
name|SHT_SYMTAB
case|:
return|return
literal|"SYMTAB"
return|;
case|case
name|SHT_STRTAB
case|:
return|return
literal|"STRTAB"
return|;
case|case
name|SHT_RELA
case|:
return|return
literal|"RELA"
return|;
case|case
name|SHT_HASH
case|:
return|return
literal|"HASH"
return|;
case|case
name|SHT_DYNAMIC
case|:
return|return
literal|"DYNAMIC"
return|;
case|case
name|SHT_NOTE
case|:
return|return
literal|"NOTE"
return|;
case|case
name|SHT_NOBITS
case|:
return|return
literal|"NOBITS"
return|;
case|case
name|SHT_REL
case|:
return|return
literal|"REL"
return|;
case|case
name|SHT_SHLIB
case|:
return|return
literal|"SHLIB"
return|;
case|case
name|SHT_DYNSYM
case|:
return|return
literal|"DYNSYM"
return|;
case|case
name|SHT_INIT_ARRAY
case|:
return|return
literal|"INIT_ARRAY"
return|;
case|case
name|SHT_FINI_ARRAY
case|:
return|return
literal|"FINI_ARRAY"
return|;
case|case
name|SHT_PREINIT_ARRAY
case|:
return|return
literal|"PREINIT_ARRAY"
return|;
case|case
name|SHT_GROUP
case|:
return|return
literal|"GROUP"
return|;
case|case
name|SHT_SYMTAB_SHNDX
case|:
return|return
literal|"SYMTAB_SHNDX"
return|;
case|case
name|SHT_SUNW_dof
case|:
return|return
literal|"SUNW_dof"
return|;
case|case
name|SHT_SUNW_cap
case|:
return|return
literal|"SUNW_cap"
return|;
case|case
name|SHT_GNU_HASH
case|:
return|return
literal|"GNU_HASH"
return|;
case|case
name|SHT_SUNW_ANNOTATE
case|:
return|return
literal|"SUNW_ANNOTATE"
return|;
case|case
name|SHT_SUNW_DEBUGSTR
case|:
return|return
literal|"SUNW_DEBUGSTR"
return|;
case|case
name|SHT_SUNW_DEBUG
case|:
return|return
literal|"SUNW_DEBUG"
return|;
case|case
name|SHT_SUNW_move
case|:
return|return
literal|"SUNW_move"
return|;
case|case
name|SHT_SUNW_COMDAT
case|:
return|return
literal|"SUNW_COMDAT"
return|;
case|case
name|SHT_SUNW_syminfo
case|:
return|return
literal|"SUNW_syminfo"
return|;
case|case
name|SHT_SUNW_verdef
case|:
return|return
literal|"SUNW_verdef"
return|;
case|case
name|SHT_SUNW_verneed
case|:
return|return
literal|"SUNW_verneed"
return|;
case|case
name|SHT_SUNW_versym
case|:
return|return
literal|"SUNW_versym"
return|;
default|default:
if|if
condition|(
name|stype
operator|>=
name|SHT_LOOS
operator|&&
name|stype
operator|<=
name|SHT_HIOS
condition|)
name|snprintf
argument_list|(
name|s_stype
argument_list|,
sizeof|sizeof
argument_list|(
name|s_stype
argument_list|)
argument_list|,
literal|"LOOS+%#x"
argument_list|,
name|stype
operator|-
name|SHT_LOOS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|stype
operator|>=
name|SHT_LOUSER
condition|)
name|snprintf
argument_list|(
name|s_stype
argument_list|,
sizeof|sizeof
argument_list|(
name|s_stype
argument_list|)
argument_list|,
literal|"LOUSER+%#x"
argument_list|,
name|stype
operator|-
name|SHT_LOUSER
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|s_stype
argument_list|,
sizeof|sizeof
argument_list|(
name|s_stype
argument_list|)
argument_list|,
literal|"<unknown: %#x>"
argument_list|,
name|stype
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_stype
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dt_type
parameter_list|(
name|unsigned
name|int
name|mach
parameter_list|,
name|unsigned
name|int
name|dtype
parameter_list|)
block|{
specifier|static
name|char
name|s_dtype
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|dtype
condition|)
block|{
case|case
name|DT_NULL
case|:
return|return
literal|"NULL"
return|;
case|case
name|DT_NEEDED
case|:
return|return
literal|"NEEDED"
return|;
case|case
name|DT_PLTRELSZ
case|:
return|return
literal|"PLTRELSZ"
return|;
case|case
name|DT_PLTGOT
case|:
return|return
literal|"PLTGOT"
return|;
case|case
name|DT_HASH
case|:
return|return
literal|"HASH"
return|;
case|case
name|DT_STRTAB
case|:
return|return
literal|"STRTAB"
return|;
case|case
name|DT_SYMTAB
case|:
return|return
literal|"SYMTAB"
return|;
case|case
name|DT_RELA
case|:
return|return
literal|"RELA"
return|;
case|case
name|DT_RELASZ
case|:
return|return
literal|"RELASZ"
return|;
case|case
name|DT_RELAENT
case|:
return|return
literal|"RELAENT"
return|;
case|case
name|DT_STRSZ
case|:
return|return
literal|"STRSZ"
return|;
case|case
name|DT_SYMENT
case|:
return|return
literal|"SYMENT"
return|;
case|case
name|DT_INIT
case|:
return|return
literal|"INIT"
return|;
case|case
name|DT_FINI
case|:
return|return
literal|"FINI"
return|;
case|case
name|DT_SONAME
case|:
return|return
literal|"SONAME"
return|;
case|case
name|DT_RPATH
case|:
return|return
literal|"RPATH"
return|;
case|case
name|DT_SYMBOLIC
case|:
return|return
literal|"SYMBOLIC"
return|;
case|case
name|DT_REL
case|:
return|return
literal|"REL"
return|;
case|case
name|DT_RELSZ
case|:
return|return
literal|"RELSZ"
return|;
case|case
name|DT_RELENT
case|:
return|return
literal|"RELENT"
return|;
case|case
name|DT_PLTREL
case|:
return|return
literal|"PLTREL"
return|;
case|case
name|DT_DEBUG
case|:
return|return
literal|"DEBUG"
return|;
case|case
name|DT_TEXTREL
case|:
return|return
literal|"TEXTREL"
return|;
case|case
name|DT_JMPREL
case|:
return|return
literal|"JMPREL"
return|;
case|case
name|DT_BIND_NOW
case|:
return|return
literal|"BIND_NOW"
return|;
case|case
name|DT_INIT_ARRAY
case|:
return|return
literal|"INIT_ARRAY"
return|;
case|case
name|DT_FINI_ARRAY
case|:
return|return
literal|"FINI_ARRAY"
return|;
case|case
name|DT_INIT_ARRAYSZ
case|:
return|return
literal|"INIT_ARRAYSZ"
return|;
case|case
name|DT_FINI_ARRAYSZ
case|:
return|return
literal|"FINI_ARRAYSZ"
return|;
case|case
name|DT_RUNPATH
case|:
return|return
literal|"RUNPATH"
return|;
case|case
name|DT_FLAGS
case|:
return|return
literal|"FLAGS"
return|;
case|case
name|DT_PREINIT_ARRAY
case|:
return|return
literal|"PREINIT_ARRAY"
return|;
case|case
name|DT_PREINIT_ARRAYSZ
case|:
return|return
literal|"PREINIT_ARRAYSZ"
return|;
case|case
name|DT_MAXPOSTAGS
case|:
return|return
literal|"MAXPOSTAGS"
return|;
case|case
name|DT_SUNW_AUXILIARY
case|:
return|return
literal|"SUNW_AUXILIARY"
return|;
case|case
name|DT_SUNW_RTLDINF
case|:
return|return
literal|"SUNW_RTLDINF"
return|;
case|case
name|DT_SUNW_FILTER
case|:
return|return
literal|"SUNW_FILTER"
return|;
case|case
name|DT_SUNW_CAP
case|:
return|return
literal|"SUNW_CAP"
return|;
case|case
name|DT_CHECKSUM
case|:
return|return
literal|"CHECKSUM"
return|;
case|case
name|DT_PLTPADSZ
case|:
return|return
literal|"PLTPADSZ"
return|;
case|case
name|DT_MOVEENT
case|:
return|return
literal|"MOVEENT"
return|;
case|case
name|DT_MOVESZ
case|:
return|return
literal|"MOVESZ"
return|;
case|case
name|DT_FEATURE
case|:
return|return
literal|"FEATURE"
return|;
case|case
name|DT_POSFLAG_1
case|:
return|return
literal|"POSFLAG_1"
return|;
case|case
name|DT_SYMINSZ
case|:
return|return
literal|"SYMINSZ"
return|;
case|case
name|DT_SYMINENT
case|:
return|return
literal|"SYMINENT"
return|;
case|case
name|DT_GNU_HASH
case|:
return|return
literal|"GNU_HASH"
return|;
case|case
name|DT_TLSDESC_PLT
case|:
return|return
literal|"DT_TLSDESC_PLT"
return|;
case|case
name|DT_TLSDESC_GOT
case|:
return|return
literal|"DT_TLSDESC_GOT"
return|;
case|case
name|DT_GNU_CONFLICT
case|:
return|return
literal|"GNU_CONFLICT"
return|;
case|case
name|DT_GNU_LIBLIST
case|:
return|return
literal|"GNU_LIBLIST"
return|;
case|case
name|DT_CONFIG
case|:
return|return
literal|"CONFIG"
return|;
case|case
name|DT_DEPAUDIT
case|:
return|return
literal|"DEPAUDIT"
return|;
case|case
name|DT_AUDIT
case|:
return|return
literal|"AUDIT"
return|;
case|case
name|DT_PLTPAD
case|:
return|return
literal|"PLTPAD"
return|;
case|case
name|DT_MOVETAB
case|:
return|return
literal|"MOVETAB"
return|;
case|case
name|DT_SYMINFO
case|:
return|return
literal|"SYMINFO"
return|;
case|case
name|DT_VERSYM
case|:
return|return
literal|"VERSYM"
return|;
case|case
name|DT_RELACOUNT
case|:
return|return
literal|"RELACOUNT"
return|;
case|case
name|DT_RELCOUNT
case|:
return|return
literal|"RELCOUNT"
return|;
case|case
name|DT_FLAGS_1
case|:
return|return
literal|"FLAGS_1"
return|;
case|case
name|DT_VERDEF
case|:
return|return
literal|"VERDEF"
return|;
case|case
name|DT_VERDEFNUM
case|:
return|return
literal|"VERDEFNUM"
return|;
case|case
name|DT_VERNEED
case|:
return|return
literal|"VERNEED"
return|;
case|case
name|DT_VERNEEDNUM
case|:
return|return
literal|"VERNEEDNUM"
return|;
case|case
name|DT_AUXILIARY
case|:
return|return
literal|"AUXILIARY"
return|;
case|case
name|DT_USED
case|:
return|return
literal|"USED"
return|;
case|case
name|DT_FILTER
case|:
return|return
literal|"FILTER"
return|;
case|case
name|DT_GNU_PRELINKED
case|:
return|return
literal|"GNU_PRELINKED"
return|;
case|case
name|DT_GNU_CONFLICTSZ
case|:
return|return
literal|"GNU_CONFLICTSZ"
return|;
case|case
name|DT_GNU_LIBLISTSZ
case|:
return|return
literal|"GNU_LIBLISTSZ"
return|;
block|}
if|if
condition|(
name|dtype
operator|>=
name|DT_LOPROC
operator|&&
name|dtype
operator|<=
name|DT_HIPROC
condition|)
block|{
switch|switch
condition|(
name|mach
condition|)
block|{
case|case
name|EM_ARM
case|:
switch|switch
condition|(
name|dtype
condition|)
block|{
case|case
name|DT_ARM_SYMTABSZ
case|:
return|return
literal|"ARM_SYMTABSZ"
return|;
default|default:
break|break;
block|}
break|break;
case|case
name|EM_MIPS
case|:
case|case
name|EM_MIPS_RS3_LE
case|:
switch|switch
condition|(
name|dtype
condition|)
block|{
case|case
name|DT_MIPS_RLD_VERSION
case|:
return|return
literal|"MIPS_RLD_VERSION"
return|;
case|case
name|DT_MIPS_TIME_STAMP
case|:
return|return
literal|"MIPS_TIME_STAMP"
return|;
case|case
name|DT_MIPS_ICHECKSUM
case|:
return|return
literal|"MIPS_ICHECKSUM"
return|;
case|case
name|DT_MIPS_IVERSION
case|:
return|return
literal|"MIPS_IVERSION"
return|;
case|case
name|DT_MIPS_FLAGS
case|:
return|return
literal|"MIPS_FLAGS"
return|;
case|case
name|DT_MIPS_BASE_ADDRESS
case|:
return|return
literal|"MIPS_BASE_ADDRESS"
return|;
case|case
name|DT_MIPS_CONFLICT
case|:
return|return
literal|"MIPS_CONFLICT"
return|;
case|case
name|DT_MIPS_LIBLIST
case|:
return|return
literal|"MIPS_LIBLIST"
return|;
case|case
name|DT_MIPS_LOCAL_GOTNO
case|:
return|return
literal|"MIPS_LOCAL_GOTNO"
return|;
case|case
name|DT_MIPS_CONFLICTNO
case|:
return|return
literal|"MIPS_CONFLICTNO"
return|;
case|case
name|DT_MIPS_LIBLISTNO
case|:
return|return
literal|"MIPS_LIBLISTNO"
return|;
case|case
name|DT_MIPS_SYMTABNO
case|:
return|return
literal|"MIPS_SYMTABNO"
return|;
case|case
name|DT_MIPS_UNREFEXTNO
case|:
return|return
literal|"MIPS_UNREFEXTNO"
return|;
case|case
name|DT_MIPS_GOTSYM
case|:
return|return
literal|"MIPS_GOTSYM"
return|;
case|case
name|DT_MIPS_HIPAGENO
case|:
return|return
literal|"MIPS_HIPAGENO"
return|;
case|case
name|DT_MIPS_RLD_MAP
case|:
return|return
literal|"MIPS_RLD_MAP"
return|;
case|case
name|DT_MIPS_DELTA_CLASS
case|:
return|return
literal|"MIPS_DELTA_CLASS"
return|;
case|case
name|DT_MIPS_DELTA_CLASS_NO
case|:
return|return
literal|"MIPS_DELTA_CLASS_NO"
return|;
case|case
name|DT_MIPS_DELTA_INSTANCE
case|:
return|return
literal|"MIPS_DELTA_INSTANCE"
return|;
case|case
name|DT_MIPS_DELTA_INSTANCE_NO
case|:
return|return
literal|"MIPS_DELTA_INSTANCE_NO"
return|;
case|case
name|DT_MIPS_DELTA_RELOC
case|:
return|return
literal|"MIPS_DELTA_RELOC"
return|;
case|case
name|DT_MIPS_DELTA_RELOC_NO
case|:
return|return
literal|"MIPS_DELTA_RELOC_NO"
return|;
case|case
name|DT_MIPS_DELTA_SYM
case|:
return|return
literal|"MIPS_DELTA_SYM"
return|;
case|case
name|DT_MIPS_DELTA_SYM_NO
case|:
return|return
literal|"MIPS_DELTA_SYM_NO"
return|;
case|case
name|DT_MIPS_DELTA_CLASSSYM
case|:
return|return
literal|"MIPS_DELTA_CLASSSYM"
return|;
case|case
name|DT_MIPS_DELTA_CLASSSYM_NO
case|:
return|return
literal|"MIPS_DELTA_CLASSSYM_NO"
return|;
case|case
name|DT_MIPS_CXX_FLAGS
case|:
return|return
literal|"MIPS_CXX_FLAGS"
return|;
case|case
name|DT_MIPS_PIXIE_INIT
case|:
return|return
literal|"MIPS_PIXIE_INIT"
return|;
case|case
name|DT_MIPS_SYMBOL_LIB
case|:
return|return
literal|"MIPS_SYMBOL_LIB"
return|;
case|case
name|DT_MIPS_LOCALPAGE_GOTIDX
case|:
return|return
literal|"MIPS_LOCALPAGE_GOTIDX"
return|;
case|case
name|DT_MIPS_LOCAL_GOTIDX
case|:
return|return
literal|"MIPS_LOCAL_GOTIDX"
return|;
case|case
name|DT_MIPS_HIDDEN_GOTIDX
case|:
return|return
literal|"MIPS_HIDDEN_GOTIDX"
return|;
case|case
name|DT_MIPS_PROTECTED_GOTIDX
case|:
return|return
literal|"MIPS_PROTECTED_GOTIDX"
return|;
case|case
name|DT_MIPS_OPTIONS
case|:
return|return
literal|"MIPS_OPTIONS"
return|;
case|case
name|DT_MIPS_INTERFACE
case|:
return|return
literal|"MIPS_INTERFACE"
return|;
case|case
name|DT_MIPS_DYNSTR_ALIGN
case|:
return|return
literal|"MIPS_DYNSTR_ALIGN"
return|;
case|case
name|DT_MIPS_INTERFACE_SIZE
case|:
return|return
literal|"MIPS_INTERFACE_SIZE"
return|;
case|case
name|DT_MIPS_RLD_TEXT_RESOLVE_ADDR
case|:
return|return
literal|"MIPS_RLD_TEXT_RESOLVE_ADDR"
return|;
case|case
name|DT_MIPS_PERF_SUFFIX
case|:
return|return
literal|"MIPS_PERF_SUFFIX"
return|;
case|case
name|DT_MIPS_COMPACT_SIZE
case|:
return|return
literal|"MIPS_COMPACT_SIZE"
return|;
case|case
name|DT_MIPS_GP_VALUE
case|:
return|return
literal|"MIPS_GP_VALUE"
return|;
case|case
name|DT_MIPS_AUX_DYNAMIC
case|:
return|return
literal|"MIPS_AUX_DYNAMIC"
return|;
case|case
name|DT_MIPS_PLTGOT
case|:
return|return
literal|"MIPS_PLTGOT"
return|;
case|case
name|DT_MIPS_RLD_OBJ_UPDATE
case|:
return|return
literal|"MIPS_RLD_OBJ_UPDATE"
return|;
case|case
name|DT_MIPS_RWPLT
case|:
return|return
literal|"MIPS_RWPLT"
return|;
default|default:
break|break;
block|}
break|break;
case|case
name|EM_SPARC
case|:
case|case
name|EM_SPARC32PLUS
case|:
case|case
name|EM_SPARCV9
case|:
switch|switch
condition|(
name|dtype
condition|)
block|{
case|case
name|DT_SPARC_REGISTER
case|:
return|return
literal|"DT_SPARC_REGISTER"
return|;
default|default:
break|break;
block|}
break|break;
default|default:
break|break;
block|}
block|}
name|snprintf
argument_list|(
name|s_dtype
argument_list|,
sizeof|sizeof
argument_list|(
name|s_dtype
argument_list|)
argument_list|,
literal|"<unknown: %#x>"
argument_list|,
name|dtype
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_dtype
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|st_bind
parameter_list|(
name|unsigned
name|int
name|sbind
parameter_list|)
block|{
specifier|static
name|char
name|s_sbind
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|sbind
condition|)
block|{
case|case
name|STB_LOCAL
case|:
return|return
literal|"LOCAL"
return|;
case|case
name|STB_GLOBAL
case|:
return|return
literal|"GLOBAL"
return|;
case|case
name|STB_WEAK
case|:
return|return
literal|"WEAK"
return|;
case|case
name|STB_GNU_UNIQUE
case|:
return|return
literal|"UNIQUE"
return|;
default|default:
if|if
condition|(
name|sbind
operator|>=
name|STB_LOOS
operator|&&
name|sbind
operator|<=
name|STB_HIOS
condition|)
return|return
literal|"OS"
return|;
elseif|else
if|if
condition|(
name|sbind
operator|>=
name|STB_LOPROC
operator|&&
name|sbind
operator|<=
name|STB_HIPROC
condition|)
return|return
literal|"PROC"
return|;
else|else
name|snprintf
argument_list|(
name|s_sbind
argument_list|,
sizeof|sizeof
argument_list|(
name|s_sbind
argument_list|)
argument_list|,
literal|"<unknown: %#x>"
argument_list|,
name|sbind
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_sbind
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|st_type
parameter_list|(
name|unsigned
name|int
name|mach
parameter_list|,
name|unsigned
name|int
name|os
parameter_list|,
name|unsigned
name|int
name|stype
parameter_list|)
block|{
specifier|static
name|char
name|s_stype
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|stype
condition|)
block|{
case|case
name|STT_NOTYPE
case|:
return|return
literal|"NOTYPE"
return|;
case|case
name|STT_OBJECT
case|:
return|return
literal|"OBJECT"
return|;
case|case
name|STT_FUNC
case|:
return|return
literal|"FUNC"
return|;
case|case
name|STT_SECTION
case|:
return|return
literal|"SECTION"
return|;
case|case
name|STT_FILE
case|:
return|return
literal|"FILE"
return|;
case|case
name|STT_COMMON
case|:
return|return
literal|"COMMON"
return|;
case|case
name|STT_TLS
case|:
return|return
literal|"TLS"
return|;
default|default:
if|if
condition|(
name|stype
operator|>=
name|STT_LOOS
operator|&&
name|stype
operator|<=
name|STT_HIOS
condition|)
block|{
if|if
condition|(
operator|(
name|os
operator|==
name|ELFOSABI_GNU
operator|||
name|os
operator|==
name|ELFOSABI_FREEBSD
operator|)
operator|&&
name|stype
operator|==
name|STT_GNU_IFUNC
condition|)
return|return
literal|"IFUNC"
return|;
name|snprintf
argument_list|(
name|s_stype
argument_list|,
sizeof|sizeof
argument_list|(
name|s_stype
argument_list|)
argument_list|,
literal|"OS+%#x"
argument_list|,
name|stype
operator|-
name|STT_LOOS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stype
operator|>=
name|STT_LOPROC
operator|&&
name|stype
operator|<=
name|STT_HIPROC
condition|)
block|{
if|if
condition|(
name|mach
operator|==
name|EM_SPARCV9
operator|&&
name|stype
operator|==
name|STT_SPARC_REGISTER
condition|)
return|return
literal|"REGISTER"
return|;
name|snprintf
argument_list|(
name|s_stype
argument_list|,
sizeof|sizeof
argument_list|(
name|s_stype
argument_list|)
argument_list|,
literal|"PROC+%#x"
argument_list|,
name|stype
operator|-
name|STT_LOPROC
argument_list|)
expr_stmt|;
block|}
else|else
name|snprintf
argument_list|(
name|s_stype
argument_list|,
sizeof|sizeof
argument_list|(
name|s_stype
argument_list|)
argument_list|,
literal|"<unknown: %#x>"
argument_list|,
name|stype
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_stype
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|st_vis
parameter_list|(
name|unsigned
name|int
name|svis
parameter_list|)
block|{
specifier|static
name|char
name|s_svis
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|svis
condition|)
block|{
case|case
name|STV_DEFAULT
case|:
return|return
literal|"DEFAULT"
return|;
case|case
name|STV_INTERNAL
case|:
return|return
literal|"INTERNAL"
return|;
case|case
name|STV_HIDDEN
case|:
return|return
literal|"HIDDEN"
return|;
case|case
name|STV_PROTECTED
case|:
return|return
literal|"PROTECTED"
return|;
default|default:
name|snprintf
argument_list|(
name|s_svis
argument_list|,
sizeof|sizeof
argument_list|(
name|s_svis
argument_list|)
argument_list|,
literal|"<unknown: %#x>"
argument_list|,
name|svis
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_svis
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|st_shndx
parameter_list|(
name|unsigned
name|int
name|shndx
parameter_list|)
block|{
specifier|static
name|char
name|s_shndx
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|shndx
condition|)
block|{
case|case
name|SHN_UNDEF
case|:
return|return
literal|"UND"
return|;
case|case
name|SHN_ABS
case|:
return|return
literal|"ABS"
return|;
case|case
name|SHN_COMMON
case|:
return|return
literal|"COM"
return|;
default|default:
if|if
condition|(
name|shndx
operator|>=
name|SHN_LOPROC
operator|&&
name|shndx
operator|<=
name|SHN_HIPROC
condition|)
return|return
literal|"PRC"
return|;
elseif|else
if|if
condition|(
name|shndx
operator|>=
name|SHN_LOOS
operator|&&
name|shndx
operator|<=
name|SHN_HIOS
condition|)
return|return
literal|"OS"
return|;
else|else
name|snprintf
argument_list|(
name|s_shndx
argument_list|,
sizeof|sizeof
argument_list|(
name|s_shndx
argument_list|)
argument_list|,
literal|"%u"
argument_list|,
name|shndx
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_shndx
operator|)
return|;
block|}
block|}
end_function

begin_struct
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|ln
decl_stmt|;
name|char
name|sn
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
name|section_flag
index|[]
init|=
block|{
block|{
literal|"WRITE"
block|,
literal|'W'
block|,
name|SHF_WRITE
block|}
block|,
block|{
literal|"ALLOC"
block|,
literal|'A'
block|,
name|SHF_ALLOC
block|}
block|,
block|{
literal|"EXEC"
block|,
literal|'X'
block|,
name|SHF_EXECINSTR
block|}
block|,
block|{
literal|"MERGE"
block|,
literal|'M'
block|,
name|SHF_MERGE
block|}
block|,
block|{
literal|"STRINGS"
block|,
literal|'S'
block|,
name|SHF_STRINGS
block|}
block|,
block|{
literal|"INFO LINK"
block|,
literal|'I'
block|,
name|SHF_INFO_LINK
block|}
block|,
block|{
literal|"OS NONCONF"
block|,
literal|'O'
block|,
name|SHF_OS_NONCONFORMING
block|}
block|,
block|{
literal|"GROUP"
block|,
literal|'G'
block|,
name|SHF_GROUP
block|}
block|,
block|{
literal|"TLS"
block|,
literal|'T'
block|,
name|SHF_TLS
block|}
block|,
block|{
literal|"COMPRESSED"
block|,
literal|'C'
block|,
name|SHF_COMPRESSED
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|note_type
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|et
parameter_list|,
name|unsigned
name|int
name|nt
parameter_list|)
block|{
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"CORE"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"LINUX"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|et
operator|==
name|ET_CORE
condition|)
return|return
name|note_type_linux_core
argument_list|(
name|nt
argument_list|)
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"FreeBSD"
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|et
operator|==
name|ET_CORE
condition|)
return|return
name|note_type_freebsd_core
argument_list|(
name|nt
argument_list|)
return|;
else|else
return|return
name|note_type_freebsd
argument_list|(
name|nt
argument_list|)
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"GNU"
argument_list|)
operator|==
literal|0
operator|&&
name|et
operator|!=
name|ET_CORE
condition|)
return|return
name|note_type_gnu
argument_list|(
name|nt
argument_list|)
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"NetBSD"
argument_list|)
operator|==
literal|0
operator|&&
name|et
operator|!=
name|ET_CORE
condition|)
return|return
name|note_type_netbsd
argument_list|(
name|nt
argument_list|)
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"OpenBSD"
argument_list|)
operator|==
literal|0
operator|&&
name|et
operator|!=
name|ET_CORE
condition|)
return|return
name|note_type_openbsd
argument_list|(
name|nt
argument_list|)
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"Xen"
argument_list|)
operator|==
literal|0
operator|&&
name|et
operator|!=
name|ET_CORE
condition|)
return|return
name|note_type_xen
argument_list|(
name|nt
argument_list|)
return|;
return|return
name|note_type_unknown
argument_list|(
name|nt
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|note_type_freebsd
parameter_list|(
name|unsigned
name|int
name|nt
parameter_list|)
block|{
switch|switch
condition|(
name|nt
condition|)
block|{
case|case
literal|1
case|:
return|return
literal|"NT_FREEBSD_ABI_TAG"
return|;
case|case
literal|2
case|:
return|return
literal|"NT_FREEBSD_NOINIT_TAG"
return|;
case|case
literal|3
case|:
return|return
literal|"NT_FREEBSD_ARCH_TAG"
return|;
default|default:
return|return
operator|(
name|note_type_unknown
argument_list|(
name|nt
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|note_type_freebsd_core
parameter_list|(
name|unsigned
name|int
name|nt
parameter_list|)
block|{
switch|switch
condition|(
name|nt
condition|)
block|{
case|case
literal|1
case|:
return|return
literal|"NT_PRSTATUS"
return|;
case|case
literal|2
case|:
return|return
literal|"NT_FPREGSET"
return|;
case|case
literal|3
case|:
return|return
literal|"NT_PRPSINFO"
return|;
case|case
literal|7
case|:
return|return
literal|"NT_THRMISC"
return|;
case|case
literal|8
case|:
return|return
literal|"NT_PROCSTAT_PROC"
return|;
case|case
literal|9
case|:
return|return
literal|"NT_PROCSTAT_FILES"
return|;
case|case
literal|10
case|:
return|return
literal|"NT_PROCSTAT_VMMAP"
return|;
case|case
literal|11
case|:
return|return
literal|"NT_PROCSTAT_GROUPS"
return|;
case|case
literal|12
case|:
return|return
literal|"NT_PROCSTAT_UMASK"
return|;
case|case
literal|13
case|:
return|return
literal|"NT_PROCSTAT_RLIMIT"
return|;
case|case
literal|14
case|:
return|return
literal|"NT_PROCSTAT_OSREL"
return|;
case|case
literal|15
case|:
return|return
literal|"NT_PROCSTAT_PSSTRINGS"
return|;
case|case
literal|16
case|:
return|return
literal|"NT_PROCSTAT_AUXV"
return|;
case|case
literal|0x202
case|:
return|return
literal|"NT_X86_XSTATE (x86 XSAVE extended state)"
return|;
default|default:
return|return
operator|(
name|note_type_unknown
argument_list|(
name|nt
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|note_type_linux_core
parameter_list|(
name|unsigned
name|int
name|nt
parameter_list|)
block|{
switch|switch
condition|(
name|nt
condition|)
block|{
case|case
literal|1
case|:
return|return
literal|"NT_PRSTATUS (Process status)"
return|;
case|case
literal|2
case|:
return|return
literal|"NT_FPREGSET (Floating point information)"
return|;
case|case
literal|3
case|:
return|return
literal|"NT_PRPSINFO (Process information)"
return|;
case|case
literal|4
case|:
return|return
literal|"NT_TASKSTRUCT (Task structure)"
return|;
case|case
literal|6
case|:
return|return
literal|"NT_AUXV (Auxiliary vector)"
return|;
case|case
literal|10
case|:
return|return
literal|"NT_PSTATUS (Linux process status)"
return|;
case|case
literal|12
case|:
return|return
literal|"NT_FPREGS (Linux floating point regset)"
return|;
case|case
literal|13
case|:
return|return
literal|"NT_PSINFO (Linux process information)"
return|;
case|case
literal|16
case|:
return|return
literal|"NT_LWPSTATUS (Linux lwpstatus_t type)"
return|;
case|case
literal|17
case|:
return|return
literal|"NT_LWPSINFO (Linux lwpinfo_t type)"
return|;
case|case
literal|18
case|:
return|return
literal|"NT_WIN32PSTATUS (win32_pstatus structure)"
return|;
case|case
literal|0x100
case|:
return|return
literal|"NT_PPC_VMX (ppc Altivec registers)"
return|;
case|case
literal|0x102
case|:
return|return
literal|"NT_PPC_VSX (ppc VSX registers)"
return|;
case|case
literal|0x202
case|:
return|return
literal|"NT_X86_XSTATE (x86 XSAVE extended state)"
return|;
case|case
literal|0x300
case|:
return|return
literal|"NT_S390_HIGH_GPRS (s390 upper register halves)"
return|;
case|case
literal|0x301
case|:
return|return
literal|"NT_S390_TIMER (s390 timer register)"
return|;
case|case
literal|0x302
case|:
return|return
literal|"NT_S390_TODCMP (s390 TOD comparator register)"
return|;
case|case
literal|0x303
case|:
return|return
literal|"NT_S390_TODPREG (s390 TOD programmable register)"
return|;
case|case
literal|0x304
case|:
return|return
literal|"NT_S390_CTRS (s390 control registers)"
return|;
case|case
literal|0x305
case|:
return|return
literal|"NT_S390_PREFIX (s390 prefix register)"
return|;
case|case
literal|0x400
case|:
return|return
literal|"NT_ARM_VFP (arm VFP registers)"
return|;
case|case
literal|0x46494c45UL
case|:
return|return
literal|"NT_FILE (mapped files)"
return|;
case|case
literal|0x46E62B7FUL
case|:
return|return
literal|"NT_PRXFPREG (Linux user_xfpregs structure)"
return|;
case|case
literal|0x53494749UL
case|:
return|return
literal|"NT_SIGINFO (siginfo_t data)"
return|;
default|default:
return|return
operator|(
name|note_type_unknown
argument_list|(
name|nt
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|note_type_gnu
parameter_list|(
name|unsigned
name|int
name|nt
parameter_list|)
block|{
switch|switch
condition|(
name|nt
condition|)
block|{
case|case
literal|1
case|:
return|return
literal|"NT_GNU_ABI_TAG"
return|;
case|case
literal|2
case|:
return|return
literal|"NT_GNU_HWCAP (Hardware capabilities)"
return|;
case|case
literal|3
case|:
return|return
literal|"NT_GNU_BUILD_ID (Build id set by ld(1))"
return|;
case|case
literal|4
case|:
return|return
literal|"NT_GNU_GOLD_VERSION (GNU gold version)"
return|;
default|default:
return|return
operator|(
name|note_type_unknown
argument_list|(
name|nt
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|note_type_netbsd
parameter_list|(
name|unsigned
name|int
name|nt
parameter_list|)
block|{
switch|switch
condition|(
name|nt
condition|)
block|{
case|case
literal|1
case|:
return|return
literal|"NT_NETBSD_IDENT"
return|;
default|default:
return|return
operator|(
name|note_type_unknown
argument_list|(
name|nt
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|note_type_openbsd
parameter_list|(
name|unsigned
name|int
name|nt
parameter_list|)
block|{
switch|switch
condition|(
name|nt
condition|)
block|{
case|case
literal|1
case|:
return|return
literal|"NT_OPENBSD_IDENT"
return|;
default|default:
return|return
operator|(
name|note_type_unknown
argument_list|(
name|nt
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|note_type_unknown
parameter_list|(
name|unsigned
name|int
name|nt
parameter_list|)
block|{
specifier|static
name|char
name|s_nt
index|[
literal|32
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|s_nt
argument_list|,
sizeof|sizeof
argument_list|(
name|s_nt
argument_list|)
argument_list|,
name|nt
operator|>=
literal|0x100
condition|?
literal|"<unknown: 0x%x>"
else|:
literal|"<unknown: %u>"
argument_list|,
name|nt
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_nt
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|note_type_xen
parameter_list|(
name|unsigned
name|int
name|nt
parameter_list|)
block|{
switch|switch
condition|(
name|nt
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"XEN_ELFNOTE_INFO"
return|;
case|case
literal|1
case|:
return|return
literal|"XEN_ELFNOTE_ENTRY"
return|;
case|case
literal|2
case|:
return|return
literal|"XEN_ELFNOTE_HYPERCALL_PAGE"
return|;
case|case
literal|3
case|:
return|return
literal|"XEN_ELFNOTE_VIRT_BASE"
return|;
case|case
literal|4
case|:
return|return
literal|"XEN_ELFNOTE_PADDR_OFFSET"
return|;
case|case
literal|5
case|:
return|return
literal|"XEN_ELFNOTE_XEN_VERSION"
return|;
case|case
literal|6
case|:
return|return
literal|"XEN_ELFNOTE_GUEST_OS"
return|;
case|case
literal|7
case|:
return|return
literal|"XEN_ELFNOTE_GUEST_VERSION"
return|;
case|case
literal|8
case|:
return|return
literal|"XEN_ELFNOTE_LOADER"
return|;
case|case
literal|9
case|:
return|return
literal|"XEN_ELFNOTE_PAE_MODE"
return|;
case|case
literal|10
case|:
return|return
literal|"XEN_ELFNOTE_FEATURES"
return|;
case|case
literal|11
case|:
return|return
literal|"XEN_ELFNOTE_BSD_SYMTAB"
return|;
case|case
literal|12
case|:
return|return
literal|"XEN_ELFNOTE_HV_START_LOW"
return|;
case|case
literal|13
case|:
return|return
literal|"XEN_ELFNOTE_L1_MFN_VALID"
return|;
case|case
literal|14
case|:
return|return
literal|"XEN_ELFNOTE_SUSPEND_CANCEL"
return|;
case|case
literal|15
case|:
return|return
literal|"XEN_ELFNOTE_INIT_P2M"
return|;
case|case
literal|16
case|:
return|return
literal|"XEN_ELFNOTE_MOD_START_PFN"
return|;
case|case
literal|17
case|:
return|return
literal|"XEN_ELFNOTE_SUPPORTED_FEATURES"
return|;
default|default:
return|return
operator|(
name|note_type_unknown
argument_list|(
name|nt
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_struct
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
name|l_flag
index|[]
init|=
block|{
block|{
literal|"EXACT_MATCH"
block|,
name|LL_EXACT_MATCH
block|}
block|,
block|{
literal|"IGNORE_INT_VER"
block|,
name|LL_IGNORE_INT_VER
block|}
block|,
block|{
literal|"REQUIRE_MINOR"
block|,
name|LL_REQUIRE_MINOR
block|}
block|,
block|{
literal|"EXPORTS"
block|,
name|LL_EXPORTS
block|}
block|,
block|{
literal|"DELAY_LOAD"
block|,
name|LL_DELAY_LOAD
block|}
block|,
block|{
literal|"DELTA"
block|,
name|LL_DELTA
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|mips_option
name|mips_exceptions_option
index|[]
init|=
block|{
block|{
name|OEX_PAGE0
block|,
literal|"PAGE0"
block|}
block|,
block|{
name|OEX_SMM
block|,
literal|"SMM"
block|}
block|,
block|{
name|OEX_PRECISEFP
block|,
literal|"PRECISEFP"
block|}
block|,
block|{
name|OEX_DISMISS
block|,
literal|"DISMISS"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mips_option
name|mips_pad_option
index|[]
init|=
block|{
block|{
name|OPAD_PREFIX
block|,
literal|"PREFIX"
block|}
block|,
block|{
name|OPAD_POSTFIX
block|,
literal|"POSTFIX"
block|}
block|,
block|{
name|OPAD_SYMBOL
block|,
literal|"SYMBOL"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mips_option
name|mips_hwpatch_option
index|[]
init|=
block|{
block|{
name|OHW_R4KEOP
block|,
literal|"R4KEOP"
block|}
block|,
block|{
name|OHW_R8KPFETCH
block|,
literal|"R8KPFETCH"
block|}
block|,
block|{
name|OHW_R5KEOP
block|,
literal|"R5KEOP"
block|}
block|,
block|{
name|OHW_R5KCVTL
block|,
literal|"R5KCVTL"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mips_option
name|mips_hwa_option
index|[]
init|=
block|{
block|{
name|OHWA0_R4KEOP_CHECKED
block|,
literal|"R4KEOP_CHECKED"
block|}
block|,
block|{
name|OHWA0_R4KEOP_CLEAN
block|,
literal|"R4KEOP_CLEAN"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mips_option
name|mips_hwo_option
index|[]
init|=
block|{
block|{
name|OHWO0_FIXADE
block|,
literal|"FIXADE"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|option_kind
parameter_list|(
name|uint8_t
name|kind
parameter_list|)
block|{
specifier|static
name|char
name|s_kind
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|ODK_NULL
case|:
return|return
literal|"NULL"
return|;
case|case
name|ODK_REGINFO
case|:
return|return
literal|"REGINFO"
return|;
case|case
name|ODK_EXCEPTIONS
case|:
return|return
literal|"EXCEPTIONS"
return|;
case|case
name|ODK_PAD
case|:
return|return
literal|"PAD"
return|;
case|case
name|ODK_HWPATCH
case|:
return|return
literal|"HWPATCH"
return|;
case|case
name|ODK_FILL
case|:
return|return
literal|"FILL"
return|;
case|case
name|ODK_TAGS
case|:
return|return
literal|"TAGS"
return|;
case|case
name|ODK_HWAND
case|:
return|return
literal|"HWAND"
return|;
case|case
name|ODK_HWOR
case|:
return|return
literal|"HWOR"
return|;
case|case
name|ODK_GP_GROUP
case|:
return|return
literal|"GP_GROUP"
return|;
case|case
name|ODK_IDENT
case|:
return|return
literal|"IDENT"
return|;
default|default:
name|snprintf
argument_list|(
name|s_kind
argument_list|,
sizeof|sizeof
argument_list|(
name|s_kind
argument_list|)
argument_list|,
literal|"<unknown: %u>"
argument_list|,
name|kind
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_kind
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|top_tag
parameter_list|(
name|unsigned
name|int
name|tag
parameter_list|)
block|{
specifier|static
name|char
name|s_top_tag
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
literal|1
case|:
return|return
literal|"File Attributes"
return|;
case|case
literal|2
case|:
return|return
literal|"Section Attributes"
return|;
case|case
literal|3
case|:
return|return
literal|"Symbol Attributes"
return|;
default|default:
name|snprintf
argument_list|(
name|s_top_tag
argument_list|,
sizeof|sizeof
argument_list|(
name|s_top_tag
argument_list|)
argument_list|,
literal|"Unknown tag: %u"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_top_tag
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_cpu_arch
parameter_list|(
name|uint64_t
name|arch
parameter_list|)
block|{
specifier|static
name|char
name|s_cpu_arch
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|arch
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"Pre-V4"
return|;
case|case
literal|1
case|:
return|return
literal|"ARM v4"
return|;
case|case
literal|2
case|:
return|return
literal|"ARM v4T"
return|;
case|case
literal|3
case|:
return|return
literal|"ARM v5T"
return|;
case|case
literal|4
case|:
return|return
literal|"ARM v5TE"
return|;
case|case
literal|5
case|:
return|return
literal|"ARM v5TEJ"
return|;
case|case
literal|6
case|:
return|return
literal|"ARM v6"
return|;
case|case
literal|7
case|:
return|return
literal|"ARM v6KZ"
return|;
case|case
literal|8
case|:
return|return
literal|"ARM v6T2"
return|;
case|case
literal|9
case|:
return|return
literal|"ARM v6K"
return|;
case|case
literal|10
case|:
return|return
literal|"ARM v7"
return|;
case|case
literal|11
case|:
return|return
literal|"ARM v6-M"
return|;
case|case
literal|12
case|:
return|return
literal|"ARM v6S-M"
return|;
case|case
literal|13
case|:
return|return
literal|"ARM v7E-M"
return|;
default|default:
name|snprintf
argument_list|(
name|s_cpu_arch
argument_list|,
sizeof|sizeof
argument_list|(
name|s_cpu_arch
argument_list|)
argument_list|,
literal|"Unknown (%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|arch
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_cpu_arch
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_cpu_arch_profile
parameter_list|(
name|uint64_t
name|pf
parameter_list|)
block|{
specifier|static
name|char
name|s_arch_profile
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|pf
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"Not applicable"
return|;
case|case
literal|0x41
case|:
comment|/* 'A' */
return|return
literal|"Application Profile"
return|;
case|case
literal|0x52
case|:
comment|/* 'R' */
return|return
literal|"Real-Time Profile"
return|;
case|case
literal|0x4D
case|:
comment|/* 'M' */
return|return
literal|"Microcontroller Profile"
return|;
case|case
literal|0x53
case|:
comment|/* 'S' */
return|return
literal|"Application or Real-Time Profile"
return|;
default|default:
name|snprintf
argument_list|(
name|s_arch_profile
argument_list|,
sizeof|sizeof
argument_list|(
name|s_arch_profile
argument_list|)
argument_list|,
literal|"Unknown (%ju)\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|pf
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_arch_profile
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_arm_isa
parameter_list|(
name|uint64_t
name|ai
parameter_list|)
block|{
specifier|static
name|char
name|s_ai
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|ai
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"No"
return|;
case|case
literal|1
case|:
return|return
literal|"Yes"
return|;
default|default:
name|snprintf
argument_list|(
name|s_ai
argument_list|,
sizeof|sizeof
argument_list|(
name|s_ai
argument_list|)
argument_list|,
literal|"Unknown (%ju)\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ai
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_ai
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_thumb_isa
parameter_list|(
name|uint64_t
name|ti
parameter_list|)
block|{
specifier|static
name|char
name|s_ti
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|ti
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"No"
return|;
case|case
literal|1
case|:
return|return
literal|"16-bit Thumb"
return|;
case|case
literal|2
case|:
return|return
literal|"32-bit Thumb"
return|;
default|default:
name|snprintf
argument_list|(
name|s_ti
argument_list|,
sizeof|sizeof
argument_list|(
name|s_ti
argument_list|)
argument_list|,
literal|"Unknown (%ju)\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ti
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_ti
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_fp_arch
parameter_list|(
name|uint64_t
name|fp
parameter_list|)
block|{
specifier|static
name|char
name|s_fp_arch
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|fp
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"No"
return|;
case|case
literal|1
case|:
return|return
literal|"VFPv1"
return|;
case|case
literal|2
case|:
return|return
literal|"VFPv2"
return|;
case|case
literal|3
case|:
return|return
literal|"VFPv3"
return|;
case|case
literal|4
case|:
return|return
literal|"VFPv3-D16"
return|;
case|case
literal|5
case|:
return|return
literal|"VFPv4"
return|;
case|case
literal|6
case|:
return|return
literal|"VFPv4-D16"
return|;
default|default:
name|snprintf
argument_list|(
name|s_fp_arch
argument_list|,
sizeof|sizeof
argument_list|(
name|s_fp_arch
argument_list|)
argument_list|,
literal|"Unknown (%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_fp_arch
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_wmmx_arch
parameter_list|(
name|uint64_t
name|wmmx
parameter_list|)
block|{
specifier|static
name|char
name|s_wmmx
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|wmmx
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"No"
return|;
case|case
literal|1
case|:
return|return
literal|"WMMXv1"
return|;
case|case
literal|2
case|:
return|return
literal|"WMMXv2"
return|;
default|default:
name|snprintf
argument_list|(
name|s_wmmx
argument_list|,
sizeof|sizeof
argument_list|(
name|s_wmmx
argument_list|)
argument_list|,
literal|"Unknown (%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|wmmx
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_wmmx
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_adv_simd_arch
parameter_list|(
name|uint64_t
name|simd
parameter_list|)
block|{
specifier|static
name|char
name|s_simd
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|simd
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"No"
return|;
case|case
literal|1
case|:
return|return
literal|"NEONv1"
return|;
case|case
literal|2
case|:
return|return
literal|"NEONv2"
return|;
default|default:
name|snprintf
argument_list|(
name|s_simd
argument_list|,
sizeof|sizeof
argument_list|(
name|s_simd
argument_list|)
argument_list|,
literal|"Unknown (%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|simd
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_simd
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_pcs_config
parameter_list|(
name|uint64_t
name|pcs
parameter_list|)
block|{
specifier|static
name|char
name|s_pcs
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|pcs
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"None"
return|;
case|case
literal|1
case|:
return|return
literal|"Bare platform"
return|;
case|case
literal|2
case|:
return|return
literal|"Linux"
return|;
case|case
literal|3
case|:
return|return
literal|"Linux DSO"
return|;
case|case
literal|4
case|:
return|return
literal|"Palm OS 2004"
return|;
case|case
literal|5
case|:
return|return
literal|"Palm OS (future)"
return|;
case|case
literal|6
case|:
return|return
literal|"Symbian OS 2004"
return|;
case|case
literal|7
case|:
return|return
literal|"Symbian OS (future)"
return|;
default|default:
name|snprintf
argument_list|(
name|s_pcs
argument_list|,
sizeof|sizeof
argument_list|(
name|s_pcs
argument_list|)
argument_list|,
literal|"Unknown (%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|pcs
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_pcs
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_pcs_r9
parameter_list|(
name|uint64_t
name|r9
parameter_list|)
block|{
specifier|static
name|char
name|s_r9
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|r9
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"V6"
return|;
case|case
literal|1
case|:
return|return
literal|"SB"
return|;
case|case
literal|2
case|:
return|return
literal|"TLS pointer"
return|;
case|case
literal|3
case|:
return|return
literal|"Unused"
return|;
default|default:
name|snprintf
argument_list|(
name|s_r9
argument_list|,
sizeof|sizeof
argument_list|(
name|s_r9
argument_list|)
argument_list|,
literal|"Unknown (%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|r9
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_r9
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_pcs_rw
parameter_list|(
name|uint64_t
name|rw
parameter_list|)
block|{
specifier|static
name|char
name|s_rw
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|rw
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"Absolute"
return|;
case|case
literal|1
case|:
return|return
literal|"PC-relative"
return|;
case|case
literal|2
case|:
return|return
literal|"SB-relative"
return|;
case|case
literal|3
case|:
return|return
literal|"None"
return|;
default|default:
name|snprintf
argument_list|(
name|s_rw
argument_list|,
sizeof|sizeof
argument_list|(
name|s_rw
argument_list|)
argument_list|,
literal|"Unknown (%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|rw
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_rw
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_pcs_ro
parameter_list|(
name|uint64_t
name|ro
parameter_list|)
block|{
specifier|static
name|char
name|s_ro
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|ro
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"Absolute"
return|;
case|case
literal|1
case|:
return|return
literal|"PC-relative"
return|;
case|case
literal|2
case|:
return|return
literal|"None"
return|;
default|default:
name|snprintf
argument_list|(
name|s_ro
argument_list|,
sizeof|sizeof
argument_list|(
name|s_ro
argument_list|)
argument_list|,
literal|"Unknown (%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ro
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_ro
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_pcs_got
parameter_list|(
name|uint64_t
name|got
parameter_list|)
block|{
specifier|static
name|char
name|s_got
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|got
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"None"
return|;
case|case
literal|1
case|:
return|return
literal|"direct"
return|;
case|case
literal|2
case|:
return|return
literal|"indirect via GOT"
return|;
default|default:
name|snprintf
argument_list|(
name|s_got
argument_list|,
sizeof|sizeof
argument_list|(
name|s_got
argument_list|)
argument_list|,
literal|"Unknown (%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|got
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_got
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_pcs_wchar_t
parameter_list|(
name|uint64_t
name|wt
parameter_list|)
block|{
specifier|static
name|char
name|s_wt
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|wt
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"None"
return|;
case|case
literal|2
case|:
return|return
literal|"wchar_t size 2"
return|;
case|case
literal|4
case|:
return|return
literal|"wchar_t size 4"
return|;
default|default:
name|snprintf
argument_list|(
name|s_wt
argument_list|,
sizeof|sizeof
argument_list|(
name|s_wt
argument_list|)
argument_list|,
literal|"Unknown (%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|wt
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_wt
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_enum_size
parameter_list|(
name|uint64_t
name|es
parameter_list|)
block|{
specifier|static
name|char
name|s_es
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|es
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"None"
return|;
case|case
literal|1
case|:
return|return
literal|"smallest"
return|;
case|case
literal|2
case|:
return|return
literal|"32-bit"
return|;
case|case
literal|3
case|:
return|return
literal|"visible 32-bit"
return|;
default|default:
name|snprintf
argument_list|(
name|s_es
argument_list|,
sizeof|sizeof
argument_list|(
name|s_es
argument_list|)
argument_list|,
literal|"Unknown (%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|es
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_es
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_align_needed
parameter_list|(
name|uint64_t
name|an
parameter_list|)
block|{
specifier|static
name|char
name|s_align_n
index|[
literal|64
index|]
decl_stmt|;
switch|switch
condition|(
name|an
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"No"
return|;
case|case
literal|1
case|:
return|return
literal|"8-byte align"
return|;
case|case
literal|2
case|:
return|return
literal|"4-byte align"
return|;
case|case
literal|3
case|:
return|return
literal|"Reserved"
return|;
default|default:
if|if
condition|(
name|an
operator|>=
literal|4
operator|&&
name|an
operator|<=
literal|12
condition|)
name|snprintf
argument_list|(
name|s_align_n
argument_list|,
sizeof|sizeof
argument_list|(
name|s_align_n
argument_list|)
argument_list|,
literal|"8-byte align"
literal|" and up to 2^%ju-byte extended align"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|an
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|s_align_n
argument_list|,
sizeof|sizeof
argument_list|(
name|s_align_n
argument_list|)
argument_list|,
literal|"Unknown (%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|an
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_align_n
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_align_preserved
parameter_list|(
name|uint64_t
name|ap
parameter_list|)
block|{
specifier|static
name|char
name|s_align_p
index|[
literal|128
index|]
decl_stmt|;
switch|switch
condition|(
name|ap
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"No"
return|;
case|case
literal|1
case|:
return|return
literal|"8-byte align"
return|;
case|case
literal|2
case|:
return|return
literal|"8-byte align and SP % 8 == 0"
return|;
case|case
literal|3
case|:
return|return
literal|"Reserved"
return|;
default|default:
if|if
condition|(
name|ap
operator|>=
literal|4
operator|&&
name|ap
operator|<=
literal|12
condition|)
name|snprintf
argument_list|(
name|s_align_p
argument_list|,
sizeof|sizeof
argument_list|(
name|s_align_p
argument_list|)
argument_list|,
literal|"8-byte align"
literal|" and SP %% 8 == 0 and up to 2^%ju-byte extended"
literal|" align"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ap
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|s_align_p
argument_list|,
sizeof|sizeof
argument_list|(
name|s_align_p
argument_list|)
argument_list|,
literal|"Unknown (%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_align_p
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_fp_rounding
parameter_list|(
name|uint64_t
name|fr
parameter_list|)
block|{
specifier|static
name|char
name|s_fp_r
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|fr
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"Unused"
return|;
case|case
literal|1
case|:
return|return
literal|"Needed"
return|;
default|default:
name|snprintf
argument_list|(
name|s_fp_r
argument_list|,
sizeof|sizeof
argument_list|(
name|s_fp_r
argument_list|)
argument_list|,
literal|"Unknown (%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fr
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_fp_r
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_fp_denormal
parameter_list|(
name|uint64_t
name|fd
parameter_list|)
block|{
specifier|static
name|char
name|s_fp_d
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|fd
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"Unused"
return|;
case|case
literal|1
case|:
return|return
literal|"Needed"
return|;
case|case
literal|2
case|:
return|return
literal|"Sign Only"
return|;
default|default:
name|snprintf
argument_list|(
name|s_fp_d
argument_list|,
sizeof|sizeof
argument_list|(
name|s_fp_d
argument_list|)
argument_list|,
literal|"Unknown (%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_fp_d
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_fp_exceptions
parameter_list|(
name|uint64_t
name|fe
parameter_list|)
block|{
specifier|static
name|char
name|s_fp_e
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|fe
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"Unused"
return|;
case|case
literal|1
case|:
return|return
literal|"Needed"
return|;
default|default:
name|snprintf
argument_list|(
name|s_fp_e
argument_list|,
sizeof|sizeof
argument_list|(
name|s_fp_e
argument_list|)
argument_list|,
literal|"Unknown (%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fe
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_fp_e
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_fp_user_exceptions
parameter_list|(
name|uint64_t
name|fu
parameter_list|)
block|{
specifier|static
name|char
name|s_fp_u
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|fu
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"Unused"
return|;
case|case
literal|1
case|:
return|return
literal|"Needed"
return|;
default|default:
name|snprintf
argument_list|(
name|s_fp_u
argument_list|,
sizeof|sizeof
argument_list|(
name|s_fp_u
argument_list|)
argument_list|,
literal|"Unknown (%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fu
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_fp_u
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_fp_number_model
parameter_list|(
name|uint64_t
name|fn
parameter_list|)
block|{
specifier|static
name|char
name|s_fp_n
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|fn
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"Unused"
return|;
case|case
literal|1
case|:
return|return
literal|"IEEE 754 normal"
return|;
case|case
literal|2
case|:
return|return
literal|"RTABI"
return|;
case|case
literal|3
case|:
return|return
literal|"IEEE 754"
return|;
default|default:
name|snprintf
argument_list|(
name|s_fp_n
argument_list|,
sizeof|sizeof
argument_list|(
name|s_fp_n
argument_list|)
argument_list|,
literal|"Unknown (%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fn
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_fp_n
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_fp_16bit_format
parameter_list|(
name|uint64_t
name|fp16
parameter_list|)
block|{
specifier|static
name|char
name|s_fp_16
index|[
literal|64
index|]
decl_stmt|;
switch|switch
condition|(
name|fp16
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"None"
return|;
case|case
literal|1
case|:
return|return
literal|"IEEE 754"
return|;
case|case
literal|2
case|:
return|return
literal|"VFPv3/Advanced SIMD (alternative format)"
return|;
default|default:
name|snprintf
argument_list|(
name|s_fp_16
argument_list|,
sizeof|sizeof
argument_list|(
name|s_fp_16
argument_list|)
argument_list|,
literal|"Unknown (%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fp16
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_fp_16
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_mpext
parameter_list|(
name|uint64_t
name|mp
parameter_list|)
block|{
specifier|static
name|char
name|s_mp
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|mp
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"Not allowed"
return|;
case|case
literal|1
case|:
return|return
literal|"Allowed"
return|;
default|default:
name|snprintf
argument_list|(
name|s_mp
argument_list|,
sizeof|sizeof
argument_list|(
name|s_mp
argument_list|)
argument_list|,
literal|"Unknown (%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_mp
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_div
parameter_list|(
name|uint64_t
name|du
parameter_list|)
block|{
specifier|static
name|char
name|s_du
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|du
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"Yes (V7-R/V7-M)"
return|;
case|case
literal|1
case|:
return|return
literal|"No"
return|;
case|case
literal|2
case|:
return|return
literal|"Yes (V7-A)"
return|;
default|default:
name|snprintf
argument_list|(
name|s_du
argument_list|,
sizeof|sizeof
argument_list|(
name|s_du
argument_list|)
argument_list|,
literal|"Unknown (%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|du
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_du
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_t2ee
parameter_list|(
name|uint64_t
name|t2ee
parameter_list|)
block|{
specifier|static
name|char
name|s_t2ee
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|t2ee
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"Not allowed"
return|;
case|case
literal|1
case|:
return|return
literal|"Allowed"
return|;
default|default:
name|snprintf
argument_list|(
name|s_t2ee
argument_list|,
sizeof|sizeof
argument_list|(
name|s_t2ee
argument_list|)
argument_list|,
literal|"Unknown(%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|t2ee
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_t2ee
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_hardfp
parameter_list|(
name|uint64_t
name|hfp
parameter_list|)
block|{
specifier|static
name|char
name|s_hfp
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|hfp
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"Tag_FP_arch"
return|;
case|case
literal|1
case|:
return|return
literal|"only SP"
return|;
case|case
literal|2
case|:
return|return
literal|"only DP"
return|;
case|case
literal|3
case|:
return|return
literal|"both SP and DP"
return|;
default|default:
name|snprintf
argument_list|(
name|s_hfp
argument_list|,
sizeof|sizeof
argument_list|(
name|s_hfp
argument_list|)
argument_list|,
literal|"Unknown (%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|hfp
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_hfp
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_vfp_args
parameter_list|(
name|uint64_t
name|va
parameter_list|)
block|{
specifier|static
name|char
name|s_va
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|va
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"AAPCS (base variant)"
return|;
case|case
literal|1
case|:
return|return
literal|"AAPCS (VFP variant)"
return|;
case|case
literal|2
case|:
return|return
literal|"toolchain-specific"
return|;
default|default:
name|snprintf
argument_list|(
name|s_va
argument_list|,
sizeof|sizeof
argument_list|(
name|s_va
argument_list|)
argument_list|,
literal|"Unknown (%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|va
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_va
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_wmmx_args
parameter_list|(
name|uint64_t
name|wa
parameter_list|)
block|{
specifier|static
name|char
name|s_wa
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|wa
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"AAPCS (base variant)"
return|;
case|case
literal|1
case|:
return|return
literal|"Intel WMMX"
return|;
case|case
literal|2
case|:
return|return
literal|"toolchain-specific"
return|;
default|default:
name|snprintf
argument_list|(
name|s_wa
argument_list|,
sizeof|sizeof
argument_list|(
name|s_wa
argument_list|)
argument_list|,
literal|"Unknown(%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|wa
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_wa
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_unaligned_access
parameter_list|(
name|uint64_t
name|ua
parameter_list|)
block|{
specifier|static
name|char
name|s_ua
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|ua
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"Not allowed"
return|;
case|case
literal|1
case|:
return|return
literal|"Allowed"
return|;
default|default:
name|snprintf
argument_list|(
name|s_ua
argument_list|,
sizeof|sizeof
argument_list|(
name|s_ua
argument_list|)
argument_list|,
literal|"Unknown(%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ua
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_ua
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_fp_hpext
parameter_list|(
name|uint64_t
name|fh
parameter_list|)
block|{
specifier|static
name|char
name|s_fh
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|fh
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"Not allowed"
return|;
case|case
literal|1
case|:
return|return
literal|"Allowed"
return|;
default|default:
name|snprintf
argument_list|(
name|s_fh
argument_list|,
sizeof|sizeof
argument_list|(
name|s_fh
argument_list|)
argument_list|,
literal|"Unknown(%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fh
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_fh
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_optm_goal
parameter_list|(
name|uint64_t
name|og
parameter_list|)
block|{
specifier|static
name|char
name|s_og
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|og
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"None"
return|;
case|case
literal|1
case|:
return|return
literal|"Speed"
return|;
case|case
literal|2
case|:
return|return
literal|"Speed aggressive"
return|;
case|case
literal|3
case|:
return|return
literal|"Space"
return|;
case|case
literal|4
case|:
return|return
literal|"Space aggressive"
return|;
case|case
literal|5
case|:
return|return
literal|"Debugging"
return|;
case|case
literal|6
case|:
return|return
literal|"Best Debugging"
return|;
default|default:
name|snprintf
argument_list|(
name|s_og
argument_list|,
sizeof|sizeof
argument_list|(
name|s_og
argument_list|)
argument_list|,
literal|"Unknown(%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|og
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_og
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_fp_optm_goal
parameter_list|(
name|uint64_t
name|fog
parameter_list|)
block|{
specifier|static
name|char
name|s_fog
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|fog
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"None"
return|;
case|case
literal|1
case|:
return|return
literal|"Speed"
return|;
case|case
literal|2
case|:
return|return
literal|"Speed aggressive"
return|;
case|case
literal|3
case|:
return|return
literal|"Space"
return|;
case|case
literal|4
case|:
return|return
literal|"Space aggressive"
return|;
case|case
literal|5
case|:
return|return
literal|"Accurary"
return|;
case|case
literal|6
case|:
return|return
literal|"Best Accurary"
return|;
default|default:
name|snprintf
argument_list|(
name|s_fog
argument_list|,
sizeof|sizeof
argument_list|(
name|s_fog
argument_list|)
argument_list|,
literal|"Unknown(%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fog
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_fog
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aeabi_virtual
parameter_list|(
name|uint64_t
name|vt
parameter_list|)
block|{
specifier|static
name|char
name|s_virtual
index|[
literal|64
index|]
decl_stmt|;
switch|switch
condition|(
name|vt
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"No"
return|;
case|case
literal|1
case|:
return|return
literal|"TrustZone"
return|;
case|case
literal|2
case|:
return|return
literal|"Virtualization extension"
return|;
case|case
literal|3
case|:
return|return
literal|"TrustZone and virtualization extension"
return|;
default|default:
name|snprintf
argument_list|(
name|s_virtual
argument_list|,
sizeof|sizeof
argument_list|(
name|s_virtual
argument_list|)
argument_list|,
literal|"Unknown(%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|vt
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_virtual
operator|)
return|;
block|}
block|}
end_function

begin_struct
specifier|static
struct|struct
block|{
name|uint64_t
name|tag
decl_stmt|;
specifier|const
name|char
modifier|*
name|s_tag
decl_stmt|;
specifier|const
name|char
modifier|*
function_decl|(
modifier|*
name|get_desc
function_decl|)
parameter_list|(
name|uint64_t
name|val
parameter_list|)
function_decl|;
block|}
name|aeabi_tags
index|[]
init|=
block|{
block|{
literal|4
block|,
literal|"Tag_CPU_raw_name"
block|,
name|NULL
block|}
block|,
block|{
literal|5
block|,
literal|"Tag_CPU_name"
block|,
name|NULL
block|}
block|,
block|{
literal|6
block|,
literal|"Tag_CPU_arch"
block|,
name|aeabi_cpu_arch
block|}
block|,
block|{
literal|7
block|,
literal|"Tag_CPU_arch_profile"
block|,
name|aeabi_cpu_arch_profile
block|}
block|,
block|{
literal|8
block|,
literal|"Tag_ARM_ISA_use"
block|,
name|aeabi_arm_isa
block|}
block|,
block|{
literal|9
block|,
literal|"Tag_THUMB_ISA_use"
block|,
name|aeabi_thumb_isa
block|}
block|,
block|{
literal|10
block|,
literal|"Tag_FP_arch"
block|,
name|aeabi_fp_arch
block|}
block|,
block|{
literal|11
block|,
literal|"Tag_WMMX_arch"
block|,
name|aeabi_wmmx_arch
block|}
block|,
block|{
literal|12
block|,
literal|"Tag_Advanced_SIMD_arch"
block|,
name|aeabi_adv_simd_arch
block|}
block|,
block|{
literal|13
block|,
literal|"Tag_PCS_config"
block|,
name|aeabi_pcs_config
block|}
block|,
block|{
literal|14
block|,
literal|"Tag_ABI_PCS_R9_use"
block|,
name|aeabi_pcs_r9
block|}
block|,
block|{
literal|15
block|,
literal|"Tag_ABI_PCS_RW_data"
block|,
name|aeabi_pcs_rw
block|}
block|,
block|{
literal|16
block|,
literal|"Tag_ABI_PCS_RO_data"
block|,
name|aeabi_pcs_ro
block|}
block|,
block|{
literal|17
block|,
literal|"Tag_ABI_PCS_GOT_use"
block|,
name|aeabi_pcs_got
block|}
block|,
block|{
literal|18
block|,
literal|"Tag_ABI_PCS_wchar_t"
block|,
name|aeabi_pcs_wchar_t
block|}
block|,
block|{
literal|19
block|,
literal|"Tag_ABI_FP_rounding"
block|,
name|aeabi_fp_rounding
block|}
block|,
block|{
literal|20
block|,
literal|"Tag_ABI_FP_denormal"
block|,
name|aeabi_fp_denormal
block|}
block|,
block|{
literal|21
block|,
literal|"Tag_ABI_FP_exceptions"
block|,
name|aeabi_fp_exceptions
block|}
block|,
block|{
literal|22
block|,
literal|"Tag_ABI_FP_user_exceptions"
block|,
name|aeabi_fp_user_exceptions
block|}
block|,
block|{
literal|23
block|,
literal|"Tag_ABI_FP_number_model"
block|,
name|aeabi_fp_number_model
block|}
block|,
block|{
literal|24
block|,
literal|"Tag_ABI_align_needed"
block|,
name|aeabi_align_needed
block|}
block|,
block|{
literal|25
block|,
literal|"Tag_ABI_align_preserved"
block|,
name|aeabi_align_preserved
block|}
block|,
block|{
literal|26
block|,
literal|"Tag_ABI_enum_size"
block|,
name|aeabi_enum_size
block|}
block|,
block|{
literal|27
block|,
literal|"Tag_ABI_HardFP_use"
block|,
name|aeabi_hardfp
block|}
block|,
block|{
literal|28
block|,
literal|"Tag_ABI_VFP_args"
block|,
name|aeabi_vfp_args
block|}
block|,
block|{
literal|29
block|,
literal|"Tag_ABI_WMMX_args"
block|,
name|aeabi_wmmx_args
block|}
block|,
block|{
literal|30
block|,
literal|"Tag_ABI_optimization_goals"
block|,
name|aeabi_optm_goal
block|}
block|,
block|{
literal|31
block|,
literal|"Tag_ABI_FP_optimization_goals"
block|,
name|aeabi_fp_optm_goal
block|}
block|,
block|{
literal|32
block|,
literal|"Tag_compatibility"
block|,
name|NULL
block|}
block|,
block|{
literal|34
block|,
literal|"Tag_CPU_unaligned_access"
block|,
name|aeabi_unaligned_access
block|}
block|,
block|{
literal|36
block|,
literal|"Tag_FP_HP_extension"
block|,
name|aeabi_fp_hpext
block|}
block|,
block|{
literal|38
block|,
literal|"Tag_ABI_FP_16bit_format"
block|,
name|aeabi_fp_16bit_format
block|}
block|,
block|{
literal|42
block|,
literal|"Tag_MPextension_use"
block|,
name|aeabi_mpext
block|}
block|,
block|{
literal|44
block|,
literal|"Tag_DIV_use"
block|,
name|aeabi_div
block|}
block|,
block|{
literal|64
block|,
literal|"Tag_nodefaults"
block|,
name|NULL
block|}
block|,
block|{
literal|65
block|,
literal|"Tag_also_compatible_with"
block|,
name|NULL
block|}
block|,
block|{
literal|66
block|,
literal|"Tag_T2EE_use"
block|,
name|aeabi_t2ee
block|}
block|,
block|{
literal|67
block|,
literal|"Tag_conformance"
block|,
name|NULL
block|}
block|,
block|{
literal|68
block|,
literal|"Tag_Virtualization_use"
block|,
name|aeabi_virtual
block|}
block|,
block|{
literal|70
block|,
literal|"Tag_MPextension_use"
block|,
name|aeabi_mpext
block|}
block|, }
struct|;
end_struct

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|mips_abi_fp
parameter_list|(
name|uint64_t
name|fp
parameter_list|)
block|{
specifier|static
name|char
name|s_mips_abi_fp
index|[
literal|64
index|]
decl_stmt|;
switch|switch
condition|(
name|fp
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"N/A"
return|;
case|case
literal|1
case|:
return|return
literal|"Hard float (double precision)"
return|;
case|case
literal|2
case|:
return|return
literal|"Hard float (single precision)"
return|;
case|case
literal|3
case|:
return|return
literal|"Soft float"
return|;
case|case
literal|4
case|:
return|return
literal|"64-bit float (-mips32r2 -mfp64)"
return|;
default|default:
name|snprintf
argument_list|(
name|s_mips_abi_fp
argument_list|,
sizeof|sizeof
argument_list|(
name|s_mips_abi_fp
argument_list|)
argument_list|,
literal|"Unknown(%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_mips_abi_fp
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ppc_abi_fp
parameter_list|(
name|uint64_t
name|fp
parameter_list|)
block|{
specifier|static
name|char
name|s_ppc_abi_fp
index|[
literal|64
index|]
decl_stmt|;
switch|switch
condition|(
name|fp
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"N/A"
return|;
case|case
literal|1
case|:
return|return
literal|"Hard float (double precision)"
return|;
case|case
literal|2
case|:
return|return
literal|"Soft float"
return|;
case|case
literal|3
case|:
return|return
literal|"Hard float (single precision)"
return|;
default|default:
name|snprintf
argument_list|(
name|s_ppc_abi_fp
argument_list|,
sizeof|sizeof
argument_list|(
name|s_ppc_abi_fp
argument_list|)
argument_list|,
literal|"Unknown(%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_ppc_abi_fp
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ppc_abi_vector
parameter_list|(
name|uint64_t
name|vec
parameter_list|)
block|{
specifier|static
name|char
name|s_vec
index|[
literal|64
index|]
decl_stmt|;
switch|switch
condition|(
name|vec
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"N/A"
return|;
case|case
literal|1
case|:
return|return
literal|"Generic purpose registers"
return|;
case|case
literal|2
case|:
return|return
literal|"AltiVec registers"
return|;
case|case
literal|3
case|:
return|return
literal|"SPE registers"
return|;
default|default:
name|snprintf
argument_list|(
name|s_vec
argument_list|,
sizeof|sizeof
argument_list|(
name|s_vec
argument_list|)
argument_list|,
literal|"Unknown(%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|vec
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_vec
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_reg
parameter_list|(
name|unsigned
name|int
name|mach
parameter_list|,
name|unsigned
name|int
name|reg
parameter_list|)
block|{
switch|switch
condition|(
name|mach
condition|)
block|{
case|case
name|EM_386
case|:
case|case
name|EM_IAMCU
case|:
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"eax"
return|;
case|case
literal|1
case|:
return|return
literal|"ecx"
return|;
case|case
literal|2
case|:
return|return
literal|"edx"
return|;
case|case
literal|3
case|:
return|return
literal|"ebx"
return|;
case|case
literal|4
case|:
return|return
literal|"esp"
return|;
case|case
literal|5
case|:
return|return
literal|"ebp"
return|;
case|case
literal|6
case|:
return|return
literal|"esi"
return|;
case|case
literal|7
case|:
return|return
literal|"edi"
return|;
case|case
literal|8
case|:
return|return
literal|"eip"
return|;
case|case
literal|9
case|:
return|return
literal|"eflags"
return|;
case|case
literal|11
case|:
return|return
literal|"st0"
return|;
case|case
literal|12
case|:
return|return
literal|"st1"
return|;
case|case
literal|13
case|:
return|return
literal|"st2"
return|;
case|case
literal|14
case|:
return|return
literal|"st3"
return|;
case|case
literal|15
case|:
return|return
literal|"st4"
return|;
case|case
literal|16
case|:
return|return
literal|"st5"
return|;
case|case
literal|17
case|:
return|return
literal|"st6"
return|;
case|case
literal|18
case|:
return|return
literal|"st7"
return|;
case|case
literal|21
case|:
return|return
literal|"xmm0"
return|;
case|case
literal|22
case|:
return|return
literal|"xmm1"
return|;
case|case
literal|23
case|:
return|return
literal|"xmm2"
return|;
case|case
literal|24
case|:
return|return
literal|"xmm3"
return|;
case|case
literal|25
case|:
return|return
literal|"xmm4"
return|;
case|case
literal|26
case|:
return|return
literal|"xmm5"
return|;
case|case
literal|27
case|:
return|return
literal|"xmm6"
return|;
case|case
literal|28
case|:
return|return
literal|"xmm7"
return|;
case|case
literal|29
case|:
return|return
literal|"mm0"
return|;
case|case
literal|30
case|:
return|return
literal|"mm1"
return|;
case|case
literal|31
case|:
return|return
literal|"mm2"
return|;
case|case
literal|32
case|:
return|return
literal|"mm3"
return|;
case|case
literal|33
case|:
return|return
literal|"mm4"
return|;
case|case
literal|34
case|:
return|return
literal|"mm5"
return|;
case|case
literal|35
case|:
return|return
literal|"mm6"
return|;
case|case
literal|36
case|:
return|return
literal|"mm7"
return|;
case|case
literal|37
case|:
return|return
literal|"fcw"
return|;
case|case
literal|38
case|:
return|return
literal|"fsw"
return|;
case|case
literal|39
case|:
return|return
literal|"mxcsr"
return|;
case|case
literal|40
case|:
return|return
literal|"es"
return|;
case|case
literal|41
case|:
return|return
literal|"cs"
return|;
case|case
literal|42
case|:
return|return
literal|"ss"
return|;
case|case
literal|43
case|:
return|return
literal|"ds"
return|;
case|case
literal|44
case|:
return|return
literal|"fs"
return|;
case|case
literal|45
case|:
return|return
literal|"gs"
return|;
case|case
literal|48
case|:
return|return
literal|"tr"
return|;
case|case
literal|49
case|:
return|return
literal|"ldtr"
return|;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
case|case
name|EM_X86_64
case|:
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"rax"
return|;
case|case
literal|1
case|:
return|return
literal|"rdx"
return|;
case|case
literal|2
case|:
return|return
literal|"rcx"
return|;
case|case
literal|3
case|:
return|return
literal|"rbx"
return|;
case|case
literal|4
case|:
return|return
literal|"rsi"
return|;
case|case
literal|5
case|:
return|return
literal|"rdi"
return|;
case|case
literal|6
case|:
return|return
literal|"rbp"
return|;
case|case
literal|7
case|:
return|return
literal|"rsp"
return|;
case|case
literal|16
case|:
return|return
literal|"rip"
return|;
case|case
literal|17
case|:
return|return
literal|"xmm0"
return|;
case|case
literal|18
case|:
return|return
literal|"xmm1"
return|;
case|case
literal|19
case|:
return|return
literal|"xmm2"
return|;
case|case
literal|20
case|:
return|return
literal|"xmm3"
return|;
case|case
literal|21
case|:
return|return
literal|"xmm4"
return|;
case|case
literal|22
case|:
return|return
literal|"xmm5"
return|;
case|case
literal|23
case|:
return|return
literal|"xmm6"
return|;
case|case
literal|24
case|:
return|return
literal|"xmm7"
return|;
case|case
literal|25
case|:
return|return
literal|"xmm8"
return|;
case|case
literal|26
case|:
return|return
literal|"xmm9"
return|;
case|case
literal|27
case|:
return|return
literal|"xmm10"
return|;
case|case
literal|28
case|:
return|return
literal|"xmm11"
return|;
case|case
literal|29
case|:
return|return
literal|"xmm12"
return|;
case|case
literal|30
case|:
return|return
literal|"xmm13"
return|;
case|case
literal|31
case|:
return|return
literal|"xmm14"
return|;
case|case
literal|32
case|:
return|return
literal|"xmm15"
return|;
case|case
literal|33
case|:
return|return
literal|"st0"
return|;
case|case
literal|34
case|:
return|return
literal|"st1"
return|;
case|case
literal|35
case|:
return|return
literal|"st2"
return|;
case|case
literal|36
case|:
return|return
literal|"st3"
return|;
case|case
literal|37
case|:
return|return
literal|"st4"
return|;
case|case
literal|38
case|:
return|return
literal|"st5"
return|;
case|case
literal|39
case|:
return|return
literal|"st6"
return|;
case|case
literal|40
case|:
return|return
literal|"st7"
return|;
case|case
literal|41
case|:
return|return
literal|"mm0"
return|;
case|case
literal|42
case|:
return|return
literal|"mm1"
return|;
case|case
literal|43
case|:
return|return
literal|"mm2"
return|;
case|case
literal|44
case|:
return|return
literal|"mm3"
return|;
case|case
literal|45
case|:
return|return
literal|"mm4"
return|;
case|case
literal|46
case|:
return|return
literal|"mm5"
return|;
case|case
literal|47
case|:
return|return
literal|"mm6"
return|;
case|case
literal|48
case|:
return|return
literal|"mm7"
return|;
case|case
literal|49
case|:
return|return
literal|"rflags"
return|;
case|case
literal|50
case|:
return|return
literal|"es"
return|;
case|case
literal|51
case|:
return|return
literal|"cs"
return|;
case|case
literal|52
case|:
return|return
literal|"ss"
return|;
case|case
literal|53
case|:
return|return
literal|"ds"
return|;
case|case
literal|54
case|:
return|return
literal|"fs"
return|;
case|case
literal|55
case|:
return|return
literal|"gs"
return|;
case|case
literal|58
case|:
return|return
literal|"fs.base"
return|;
case|case
literal|59
case|:
return|return
literal|"gs.base"
return|;
case|case
literal|62
case|:
return|return
literal|"tr"
return|;
case|case
literal|63
case|:
return|return
literal|"ldtr"
return|;
case|case
literal|64
case|:
return|return
literal|"mxcsr"
return|;
case|case
literal|65
case|:
return|return
literal|"fcw"
return|;
case|case
literal|66
case|:
return|return
literal|"fsw"
return|;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_ehdr
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
name|size_t
name|phnum
decl_stmt|,
name|shnum
decl_stmt|,
name|shstrndx
decl_stmt|;
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"ELF Header:\n"
argument_list|)
expr_stmt|;
comment|/* e_ident[]. */
name|printf
argument_list|(
literal|"  Magic:   "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EI_NIDENT
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%.2x "
argument_list|,
name|re
operator|->
name|ehdr
operator|.
name|e_ident
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* EI_CLASS. */
name|printf
argument_list|(
literal|"%-37s%s\n"
argument_list|,
literal|"  Class:"
argument_list|,
name|elf_class
argument_list|(
name|re
operator|->
name|ehdr
operator|.
name|e_ident
index|[
name|EI_CLASS
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* EI_DATA. */
name|printf
argument_list|(
literal|"%-37s%s\n"
argument_list|,
literal|"  Data:"
argument_list|,
name|elf_endian
argument_list|(
name|re
operator|->
name|ehdr
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* EI_VERSION. */
name|printf
argument_list|(
literal|"%-37s%d %s\n"
argument_list|,
literal|"  Version:"
argument_list|,
name|re
operator|->
name|ehdr
operator|.
name|e_ident
index|[
name|EI_VERSION
index|]
argument_list|,
name|elf_ver
argument_list|(
name|re
operator|->
name|ehdr
operator|.
name|e_ident
index|[
name|EI_VERSION
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* EI_OSABI. */
name|printf
argument_list|(
literal|"%-37s%s\n"
argument_list|,
literal|"  OS/ABI:"
argument_list|,
name|elf_osabi
argument_list|(
name|re
operator|->
name|ehdr
operator|.
name|e_ident
index|[
name|EI_OSABI
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* EI_ABIVERSION. */
name|printf
argument_list|(
literal|"%-37s%d\n"
argument_list|,
literal|"  ABI Version:"
argument_list|,
name|re
operator|->
name|ehdr
operator|.
name|e_ident
index|[
name|EI_ABIVERSION
index|]
argument_list|)
expr_stmt|;
comment|/* e_type. */
name|printf
argument_list|(
literal|"%-37s%s\n"
argument_list|,
literal|"  Type:"
argument_list|,
name|elf_type
argument_list|(
name|re
operator|->
name|ehdr
operator|.
name|e_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* e_machine. */
name|printf
argument_list|(
literal|"%-37s%s\n"
argument_list|,
literal|"  Machine:"
argument_list|,
name|elf_machine
argument_list|(
name|re
operator|->
name|ehdr
operator|.
name|e_machine
argument_list|)
argument_list|)
expr_stmt|;
comment|/* e_version. */
name|printf
argument_list|(
literal|"%-37s%#x\n"
argument_list|,
literal|"  Version:"
argument_list|,
name|re
operator|->
name|ehdr
operator|.
name|e_version
argument_list|)
expr_stmt|;
comment|/* e_entry. */
name|printf
argument_list|(
literal|"%-37s%#jx\n"
argument_list|,
literal|"  Entry point address:"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|re
operator|->
name|ehdr
operator|.
name|e_entry
argument_list|)
expr_stmt|;
comment|/* e_phoff. */
name|printf
argument_list|(
literal|"%-37s%ju (bytes into file)\n"
argument_list|,
literal|"  Start of program headers:"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|re
operator|->
name|ehdr
operator|.
name|e_phoff
argument_list|)
expr_stmt|;
comment|/* e_shoff. */
name|printf
argument_list|(
literal|"%-37s%ju (bytes into file)\n"
argument_list|,
literal|"  Start of section headers:"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|re
operator|->
name|ehdr
operator|.
name|e_shoff
argument_list|)
expr_stmt|;
comment|/* e_flags. */
name|printf
argument_list|(
literal|"%-37s%#x"
argument_list|,
literal|"  Flags:"
argument_list|,
name|re
operator|->
name|ehdr
operator|.
name|e_flags
argument_list|)
expr_stmt|;
name|dump_eflags
argument_list|(
name|re
argument_list|,
name|re
operator|->
name|ehdr
operator|.
name|e_flags
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* e_ehsize. */
name|printf
argument_list|(
literal|"%-37s%u (bytes)\n"
argument_list|,
literal|"  Size of this header:"
argument_list|,
name|re
operator|->
name|ehdr
operator|.
name|e_ehsize
argument_list|)
expr_stmt|;
comment|/* e_phentsize. */
name|printf
argument_list|(
literal|"%-37s%u (bytes)\n"
argument_list|,
literal|"  Size of program headers:"
argument_list|,
name|re
operator|->
name|ehdr
operator|.
name|e_phentsize
argument_list|)
expr_stmt|;
comment|/* e_phnum. */
name|printf
argument_list|(
literal|"%-37s%u"
argument_list|,
literal|"  Number of program headers:"
argument_list|,
name|re
operator|->
name|ehdr
operator|.
name|e_phnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|ehdr
operator|.
name|e_phnum
operator|==
name|PN_XNUM
condition|)
block|{
comment|/* Extended program header numbering is in use. */
if|if
condition|(
name|elf_getphnum
argument_list|(
name|re
operator|->
name|elf
argument_list|,
operator|&
name|phnum
argument_list|)
condition|)
name|printf
argument_list|(
literal|" (%zu)"
argument_list|,
name|phnum
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* e_shentsize. */
name|printf
argument_list|(
literal|"%-37s%u (bytes)\n"
argument_list|,
literal|"  Size of section headers:"
argument_list|,
name|re
operator|->
name|ehdr
operator|.
name|e_shentsize
argument_list|)
expr_stmt|;
comment|/* e_shnum. */
name|printf
argument_list|(
literal|"%-37s%u"
argument_list|,
literal|"  Number of section headers:"
argument_list|,
name|re
operator|->
name|ehdr
operator|.
name|e_shnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|ehdr
operator|.
name|e_shnum
operator|==
name|SHN_UNDEF
condition|)
block|{
comment|/* Extended section numbering is in use. */
if|if
condition|(
name|elf_getshnum
argument_list|(
name|re
operator|->
name|elf
argument_list|,
operator|&
name|shnum
argument_list|)
condition|)
name|printf
argument_list|(
literal|" (%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|shnum
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* e_shstrndx. */
name|printf
argument_list|(
literal|"%-37s%u"
argument_list|,
literal|"  Section header string table index:"
argument_list|,
name|re
operator|->
name|ehdr
operator|.
name|e_shstrndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|ehdr
operator|.
name|e_shstrndx
operator|==
name|SHN_XINDEX
condition|)
block|{
comment|/* Extended section numbering is in use. */
if|if
condition|(
name|elf_getshstrndx
argument_list|(
name|re
operator|->
name|elf
argument_list|,
operator|&
name|shstrndx
argument_list|)
condition|)
name|printf
argument_list|(
literal|" (%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|shstrndx
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_eflags
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|uint64_t
name|e_flags
parameter_list|)
block|{
name|struct
name|eflags_desc
modifier|*
name|edesc
decl_stmt|;
name|int
name|arm_eabi
decl_stmt|;
name|edesc
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|re
operator|->
name|ehdr
operator|.
name|e_machine
condition|)
block|{
case|case
name|EM_ARM
case|:
name|arm_eabi
operator|=
operator|(
name|e_flags
operator|&
name|EF_ARM_EABIMASK
operator|)
operator|>>
literal|24
expr_stmt|;
if|if
condition|(
name|arm_eabi
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|", GNU EABI"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arm_eabi
operator|<=
literal|5
condition|)
name|printf
argument_list|(
literal|", Version%d EABI"
argument_list|,
name|arm_eabi
argument_list|)
expr_stmt|;
name|edesc
operator|=
name|arm_eflags_desc
expr_stmt|;
break|break;
case|case
name|EM_MIPS
case|:
case|case
name|EM_MIPS_RS3_LE
case|:
switch|switch
condition|(
operator|(
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|>>
literal|28
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|", mips1"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf
argument_list|(
literal|", mips2"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|", mips3"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|printf
argument_list|(
literal|", mips4"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|printf
argument_list|(
literal|", mips5"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|printf
argument_list|(
literal|", mips32"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|printf
argument_list|(
literal|", mips64"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|printf
argument_list|(
literal|", mips32r2"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|printf
argument_list|(
literal|", mips64r2"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
operator|(
name|e_flags
operator|&
literal|0x00FF0000
operator|)
operator|>>
literal|16
condition|)
block|{
case|case
literal|0x81
case|:
name|printf
argument_list|(
literal|", 3900"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x82
case|:
name|printf
argument_list|(
literal|", 4010"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x83
case|:
name|printf
argument_list|(
literal|", 4100"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x85
case|:
name|printf
argument_list|(
literal|", 4650"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x87
case|:
name|printf
argument_list|(
literal|", 4120"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x88
case|:
name|printf
argument_list|(
literal|", 4111"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x8a
case|:
name|printf
argument_list|(
literal|", sb1"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x8b
case|:
name|printf
argument_list|(
literal|", octeon"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x8c
case|:
name|printf
argument_list|(
literal|", xlr"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x91
case|:
name|printf
argument_list|(
literal|", 5400"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x98
case|:
name|printf
argument_list|(
literal|", 5500"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x99
case|:
name|printf
argument_list|(
literal|", 9000"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xa0
case|:
name|printf
argument_list|(
literal|", loongson-2e"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xa1
case|:
name|printf
argument_list|(
literal|", loongson-2f"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
operator|(
name|e_flags
operator|&
literal|0x0000F000
operator|)
operator|>>
literal|12
condition|)
block|{
case|case
literal|1
case|:
name|printf
argument_list|(
literal|", o32"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|", o64"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|printf
argument_list|(
literal|", eabi32"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|printf
argument_list|(
literal|", eabi64"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|edesc
operator|=
name|mips_eflags_desc
expr_stmt|;
break|break;
case|case
name|EM_PPC
case|:
case|case
name|EM_PPC64
case|:
name|edesc
operator|=
name|powerpc_eflags_desc
expr_stmt|;
break|break;
case|case
name|EM_SPARC
case|:
case|case
name|EM_SPARC32PLUS
case|:
case|case
name|EM_SPARCV9
case|:
switch|switch
condition|(
operator|(
name|e_flags
operator|&
name|EF_SPARCV9_MM
operator|)
condition|)
block|{
case|case
name|EF_SPARCV9_TSO
case|:
name|printf
argument_list|(
literal|", tso"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_SPARCV9_PSO
case|:
name|printf
argument_list|(
literal|", pso"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_SPARCV9_MM
case|:
name|printf
argument_list|(
literal|", rmo"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|edesc
operator|=
name|sparc_eflags_desc
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|edesc
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|edesc
operator|->
name|desc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|e_flags
operator|&
name|edesc
operator|->
name|flag
condition|)
name|printf
argument_list|(
literal|", %s"
argument_list|,
name|edesc
operator|->
name|desc
argument_list|)
expr_stmt|;
name|edesc
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_phdr
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|rawfile
decl_stmt|;
name|GElf_Phdr
name|phdr
decl_stmt|;
name|size_t
name|phnum
decl_stmt|,
name|size
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
define|#
directive|define
name|PH_HDR
value|"Type", "Offset", "VirtAddr", "PhysAddr", "FileSiz",	\ 		"MemSiz", "Flg", "Align"
define|#
directive|define
name|PH_CT
value|phdr_type(re->ehdr.e_machine, phdr.p_type),		\ 		(uintmax_t)phdr.p_offset, (uintmax_t)phdr.p_vaddr,	\ 		(uintmax_t)phdr.p_paddr, (uintmax_t)phdr.p_filesz,	\ 		(uintmax_t)phdr.p_memsz,				\ 		phdr.p_flags& PF_R ? 'R' : ' ',			\ 		phdr.p_flags& PF_W ? 'W' : ' ',			\ 		phdr.p_flags& PF_X ? 'E' : ' ',			\ 		(uintmax_t)phdr.p_align
if|if
condition|(
name|elf_getphnum
argument_list|(
name|re
operator|->
name|elf
argument_list|,
operator|&
name|phnum
argument_list|)
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_getphnum failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|phnum
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\nThere are no program headers in this file.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"\nElf file type is %s"
argument_list|,
name|elf_type
argument_list|(
name|re
operator|->
name|ehdr
operator|.
name|e_type
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nEntry point 0x%jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|re
operator|->
name|ehdr
operator|.
name|e_entry
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"There are %ju program headers, starting at offset %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|phnum
argument_list|,
operator|(
name|uintmax_t
operator|)
name|re
operator|->
name|ehdr
operator|.
name|e_phoff
argument_list|)
expr_stmt|;
comment|/* Dump program headers. */
name|printf
argument_list|(
literal|"\nProgram Headers:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|ec
operator|==
name|ELFCLASS32
condition|)
name|printf
argument_list|(
literal|"  %-15s%-9s%-11s%-11s%-8s%-8s%-4s%s\n"
argument_list|,
name|PH_HDR
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_WW
condition|)
name|printf
argument_list|(
literal|"  %-15s%-9s%-19s%-19s%-9s%-9s%-4s%s\n"
argument_list|,
name|PH_HDR
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  %-15s%-19s%-19s%s\n                 %-19s%-20s"
literal|"%-7s%s\n"
argument_list|,
name|PH_HDR
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|phnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|gelf_getphdr
argument_list|(
name|re
operator|->
name|elf
argument_list|,
name|i
argument_list|,
operator|&
name|phdr
argument_list|)
operator|!=
operator|&
name|phdr
condition|)
block|{
name|warnx
argument_list|(
literal|"gelf_getphdr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* TODO: Add arch-specific segment type dump. */
if|if
condition|(
name|re
operator|->
name|ec
operator|==
name|ELFCLASS32
condition|)
name|printf
argument_list|(
literal|"  %-14.14s 0x%6.6jx 0x%8.8jx 0x%8.8jx "
literal|"0x%5.5jx 0x%5.5jx %c%c%c %#jx\n"
argument_list|,
name|PH_CT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_WW
condition|)
name|printf
argument_list|(
literal|"  %-14.14s 0x%6.6jx 0x%16.16jx 0x%16.16jx "
literal|"0x%6.6jx 0x%6.6jx %c%c%c %#jx\n"
argument_list|,
name|PH_CT
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  %-14.14s 0x%16.16jx 0x%16.16jx 0x%16.16jx\n"
literal|"                 0x%16.16jx 0x%16.16jx  %c%c%c"
literal|"    %#jx\n"
argument_list|,
name|PH_CT
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|.
name|p_type
operator|==
name|PT_INTERP
condition|)
block|{
if|if
condition|(
operator|(
name|rawfile
operator|=
name|elf_rawfile
argument_list|(
name|re
operator|->
name|elf
argument_list|,
operator|&
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_rawfile failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|phdr
operator|.
name|p_offset
operator|>=
name|size
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid program header offset"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"      [Requesting program interpreter: %s]\n"
argument_list|,
name|rawfile
operator|+
name|phdr
operator|.
name|p_offset
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Dump section to segment mapping. */
if|if
condition|(
name|re
operator|->
name|shnum
operator|==
literal|0
condition|)
return|return;
name|printf
argument_list|(
literal|"\n Section to Segment mapping:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Segment Sections...\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|phnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|gelf_getphdr
argument_list|(
name|re
operator|->
name|elf
argument_list|,
name|i
argument_list|,
operator|&
name|phdr
argument_list|)
operator|!=
operator|&
name|phdr
condition|)
block|{
name|warnx
argument_list|(
literal|"gelf_getphdr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"   %2.2d     "
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* skip NULL section. */
for|for
control|(
name|j
operator|=
literal|1
init|;
operator|(
name|size_t
operator|)
name|j
operator|<
name|re
operator|->
name|shnum
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|re
operator|->
name|sl
index|[
name|j
index|]
operator|.
name|addr
operator|>=
name|phdr
operator|.
name|p_vaddr
operator|&&
name|re
operator|->
name|sl
index|[
name|j
index|]
operator|.
name|addr
operator|+
name|re
operator|->
name|sl
index|[
name|j
index|]
operator|.
name|sz
operator|<=
name|phdr
operator|.
name|p_vaddr
operator|+
name|phdr
operator|.
name|p_memsz
condition|)
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|re
operator|->
name|sl
index|[
name|j
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|PH_HDR
undef|#
directive|undef
name|PH_CT
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|section_flags
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
block|{
define|#
directive|define
name|BUF_SZ
value|256
specifier|static
name|char
name|buf
index|[
name|BUF_SZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|p
decl_stmt|,
name|nb
decl_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
name|nb
operator|=
name|re
operator|->
name|ec
operator|==
name|ELFCLASS32
condition|?
literal|8
else|:
literal|16
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_T
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
name|BUF_SZ
argument_list|,
literal|"[%*.*jx]: "
argument_list|,
name|nb
argument_list|,
name|nb
argument_list|,
operator|(
name|uintmax_t
operator|)
name|s
operator|->
name|flags
argument_list|)
expr_stmt|;
name|p
operator|+=
name|nb
operator|+
literal|4
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|section_flag
index|[
name|i
index|]
operator|.
name|ln
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|section_flag
index|[
name|i
index|]
operator|.
name|value
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_T
condition|)
block|{
name|snprintf
argument_list|(
operator|&
name|buf
index|[
name|p
index|]
argument_list|,
name|BUF_SZ
operator|-
name|p
argument_list|,
literal|"%s, "
argument_list|,
name|section_flag
index|[
name|i
index|]
operator|.
name|ln
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|section_flag
index|[
name|i
index|]
operator|.
name|ln
argument_list|)
operator|+
literal|2
expr_stmt|;
block|}
else|else
name|buf
index|[
name|p
operator|++
index|]
operator|=
name|section_flag
index|[
name|i
index|]
operator|.
name|sn
expr_stmt|;
block|}
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_T
operator|&&
name|p
operator|>
name|nb
operator|+
literal|4
condition|)
name|p
operator|-=
literal|2
expr_stmt|;
name|buf
index|[
name|p
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_shdr
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
define|#
directive|define
name|S_HDR
value|"[Nr] Name", "Type", "Addr", "Off", "Size", "ES",	\ 		"Flg", "Lk", "Inf", "Al"
define|#
directive|define
name|S_HDRL
value|"[Nr] Name", "Type", "Address", "Offset", "Size",	\ 		"EntSize", "Flags", "Link", "Info", "Align"
define|#
directive|define
name|ST_HDR
value|"[Nr] Name", "Type", "Addr", "Off", "Size", "ES",	\ 		"Lk", "Inf", "Al", "Flags"
define|#
directive|define
name|ST_HDRL
value|"[Nr] Name", "Type", "Address", "Offset", "Link",	\ 		"Size", "EntSize", "Info", "Align", "Flags"
define|#
directive|define
name|S_CT
value|i, s->name, section_type(re->ehdr.e_machine, s->type),	\ 		(uintmax_t)s->addr, (uintmax_t)s->off, (uintmax_t)s->sz,\ 		(uintmax_t)s->entsize, section_flags(re, s),		\ 		s->link, s->info, (uintmax_t)s->align
define|#
directive|define
name|ST_CT
value|i, s->name, section_type(re->ehdr.e_machine, s->type),  \ 		(uintmax_t)s->addr, (uintmax_t)s->off, (uintmax_t)s->sz,\ 		(uintmax_t)s->entsize, s->link, s->info,		\ 		(uintmax_t)s->align, section_flags(re, s)
define|#
directive|define
name|ST_CTL
value|i, s->name, section_type(re->ehdr.e_machine, s->type),  \ 		(uintmax_t)s->addr, (uintmax_t)s->off, s->link,		\ 		(uintmax_t)s->sz, (uintmax_t)s->entsize, s->info,	\ 		(uintmax_t)s->align, section_flags(re, s)
if|if
condition|(
name|re
operator|->
name|shnum
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\nThere are no sections in this file.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"There are %ju section headers, starting at offset 0x%jx:\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|re
operator|->
name|shnum
argument_list|,
operator|(
name|uintmax_t
operator|)
name|re
operator|->
name|ehdr
operator|.
name|e_shoff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nSection Headers:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|ec
operator|==
name|ELFCLASS32
condition|)
block|{
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_T
condition|)
name|printf
argument_list|(
literal|"  %s\n       %-16s%-9s%-7s%-7s%-5s%-3s%-4s%s\n"
literal|"%12s\n"
argument_list|,
name|ST_HDR
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  %-23s%-16s%-9s%-7s%-7s%-3s%-4s%-3s%-4s%s\n"
argument_list|,
name|S_HDR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_WW
condition|)
block|{
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_T
condition|)
name|printf
argument_list|(
literal|"  %s\n       %-16s%-17s%-7s%-7s%-5s%-3s%-4s%s\n"
literal|"%12s\n"
argument_list|,
name|ST_HDR
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  %-23s%-16s%-17s%-7s%-7s%-3s%-4s%-3s%-4s%s\n"
argument_list|,
name|S_HDR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_T
condition|)
name|printf
argument_list|(
literal|"  %s\n       %-18s%-17s%-18s%s\n       %-18s"
literal|"%-17s%-18s%s\n%12s\n"
argument_list|,
name|ST_HDRL
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  %-23s%-17s%-18s%s\n       %-18s%-17s%-7s%"
literal|"-6s%-6s%s\n"
argument_list|,
name|S_HDRL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|re
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|re
operator|->
name|sl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|ec
operator|==
name|ELFCLASS32
condition|)
block|{
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_T
condition|)
name|printf
argument_list|(
literal|"  [%2d] %s\n       %-15.15s %8.8jx"
literal|" %6.6jx %6.6jx %2.2jx  %2u %3u %2ju\n"
literal|"       %s\n"
argument_list|,
name|ST_CT
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  [%2d] %-17.17s %-15.15s %8.8jx"
literal|" %6.6jx %6.6jx %2.2jx %3s %2u %3u %2ju\n"
argument_list|,
name|S_CT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_WW
condition|)
block|{
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_T
condition|)
name|printf
argument_list|(
literal|"  [%2d] %s\n       %-15.15s %16.16jx"
literal|" %6.6jx %6.6jx %2.2jx  %2u %3u %2ju\n"
literal|"       %s\n"
argument_list|,
name|ST_CT
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  [%2d] %-17.17s %-15.15s %16.16jx"
literal|" %6.6jx %6.6jx %2.2jx %3s %2u %3u %2ju\n"
argument_list|,
name|S_CT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_T
condition|)
name|printf
argument_list|(
literal|"  [%2d] %s\n       %-15.15s  %16.16jx"
literal|"  %16.16jx  %u\n       %16.16jx %16.16jx"
literal|"  %-16u  %ju\n       %s\n"
argument_list|,
name|ST_CTL
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  [%2d] %-17.17s %-15.15s  %16.16jx"
literal|"  %8.8jx\n       %16.16jx  %16.16jx "
literal|"%3s      %2u   %3u     %ju\n"
argument_list|,
name|S_CT
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|re
operator|->
name|options
operator|&
name|RE_T
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"Key to Flags:\n  W (write), A (alloc),"
literal|" X (execute), M (merge), S (strings)\n"
literal|"  I (info), L (link order), G (group), x (unknown)\n"
literal|"  O (extra OS processing required)"
literal|" o (OS specific), p (processor specific)\n"
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|S_HDR
undef|#
directive|undef
name|S_HDRL
undef|#
directive|undef
name|ST_HDR
undef|#
directive|undef
name|ST_HDRL
undef|#
directive|undef
name|S_CT
undef|#
directive|undef
name|ST_CT
undef|#
directive|undef
name|ST_CTL
block|}
end_function

begin_comment
comment|/*  * Return number of entries in the given section. We'd prefer ent_count be a  * size_t *, but libelf APIs already use int for section indices.  */
end_comment

begin_function
specifier|static
name|int
name|get_ent_count
parameter_list|(
name|struct
name|section
modifier|*
name|s
parameter_list|,
name|int
modifier|*
name|ent_count
parameter_list|)
block|{
if|if
condition|(
name|s
operator|->
name|entsize
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"section %s has entry size 0"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|sz
operator|/
name|s
operator|->
name|entsize
operator|>
name|INT_MAX
condition|)
block|{
name|warnx
argument_list|(
literal|"section %s has invalid section count"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|ent_count
operator|=
call|(
name|int
call|)
argument_list|(
name|s
operator|->
name|sz
operator|/
name|s
operator|->
name|entsize
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_dynamic
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
name|GElf_Dyn
name|dyn
decl_stmt|;
name|Elf_Data
modifier|*
name|d
decl_stmt|;
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|int
name|elferr
decl_stmt|,
name|i
decl_stmt|,
name|is_dynamic
decl_stmt|,
name|j
decl_stmt|,
name|jmax
decl_stmt|,
name|nentries
decl_stmt|;
name|is_dynamic
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|re
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|re
operator|->
name|sl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|!=
name|SHT_DYNAMIC
condition|)
continue|continue;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|d
operator|->
name|d_size
operator|<=
literal|0
condition|)
continue|continue;
name|is_dynamic
operator|=
literal|1
expr_stmt|;
comment|/* Determine the actual number of table entries. */
name|nentries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|get_ent_count
argument_list|(
name|s
argument_list|,
operator|&
name|jmax
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|jmax
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|gelf_getdyn
argument_list|(
name|d
argument_list|,
name|j
argument_list|,
operator|&
name|dyn
argument_list|)
operator|!=
operator|&
name|dyn
condition|)
block|{
name|warnx
argument_list|(
literal|"gelf_getdyn failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|nentries
operator|++
expr_stmt|;
if|if
condition|(
name|dyn
operator|.
name|d_tag
operator|==
name|DT_NULL
condition|)
break|break;
block|}
name|printf
argument_list|(
literal|"\nDynamic section at offset 0x%jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|s
operator|->
name|off
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" contains %u entries:\n"
argument_list|,
name|nentries
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|ec
operator|==
name|ELFCLASS32
condition|)
name|printf
argument_list|(
literal|"%5s%12s%28s\n"
argument_list|,
literal|"Tag"
argument_list|,
literal|"Type"
argument_list|,
literal|"Name/Value"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%5s%20s%28s\n"
argument_list|,
literal|"Tag"
argument_list|,
literal|"Type"
argument_list|,
literal|"Name/Value"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nentries
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|gelf_getdyn
argument_list|(
name|d
argument_list|,
name|j
argument_list|,
operator|&
name|dyn
argument_list|)
operator|!=
operator|&
name|dyn
condition|)
continue|continue;
comment|/* Dump dynamic entry type. */
if|if
condition|(
name|re
operator|->
name|ec
operator|==
name|ELFCLASS32
condition|)
name|printf
argument_list|(
literal|" 0x%8.8jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dyn
operator|.
name|d_tag
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" 0x%16.16jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dyn
operator|.
name|d_tag
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %-20s"
argument_list|,
name|dt_type
argument_list|(
name|re
operator|->
name|ehdr
operator|.
name|e_machine
argument_list|,
name|dyn
operator|.
name|d_tag
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Dump dynamic entry value. */
name|dump_dyn_val
argument_list|(
name|re
argument_list|,
operator|&
name|dyn
argument_list|,
name|s
operator|->
name|link
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|is_dynamic
condition|)
name|printf
argument_list|(
literal|"\nThere is no dynamic section in this file.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|timestamp
parameter_list|(
name|time_t
name|ti
parameter_list|)
block|{
specifier|static
name|char
name|ts
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|tm
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|gmtime
argument_list|(
operator|&
name|ti
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|ts
argument_list|,
sizeof|sizeof
argument_list|(
name|ts
argument_list|)
argument_list|,
literal|"%04d-%02d-%02dT%02d:%02d:%02d"
argument_list|,
name|t
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|t
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|t
operator|->
name|tm_mday
argument_list|,
name|t
operator|->
name|tm_hour
argument_list|,
name|t
operator|->
name|tm_min
argument_list|,
name|t
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
return|return
operator|(
name|ts
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dyn_str
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|uint32_t
name|stab
parameter_list|,
name|uint64_t
name|d_val
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|stab
operator|==
name|SHN_UNDEF
condition|)
name|name
operator|=
literal|"ERROR"
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|name
operator|=
name|elf_strptr
argument_list|(
name|re
operator|->
name|elf
argument_list|,
name|stab
argument_list|,
name|d_val
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
comment|/* clear error */
name|name
operator|=
literal|"ERROR"
expr_stmt|;
block|}
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_arch_dyn_val
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|GElf_Dyn
modifier|*
name|dyn
parameter_list|,
name|uint32_t
name|stab
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
switch|switch
condition|(
name|re
operator|->
name|ehdr
operator|.
name|e_machine
condition|)
block|{
case|case
name|EM_MIPS
case|:
case|case
name|EM_MIPS_RS3_LE
case|:
switch|switch
condition|(
name|dyn
operator|->
name|d_tag
condition|)
block|{
case|case
name|DT_MIPS_RLD_VERSION
case|:
case|case
name|DT_MIPS_LOCAL_GOTNO
case|:
case|case
name|DT_MIPS_CONFLICTNO
case|:
case|case
name|DT_MIPS_LIBLISTNO
case|:
case|case
name|DT_MIPS_SYMTABNO
case|:
case|case
name|DT_MIPS_UNREFEXTNO
case|:
case|case
name|DT_MIPS_GOTSYM
case|:
case|case
name|DT_MIPS_HIPAGENO
case|:
case|case
name|DT_MIPS_DELTA_CLASS_NO
case|:
case|case
name|DT_MIPS_DELTA_INSTANCE_NO
case|:
case|case
name|DT_MIPS_DELTA_RELOC_NO
case|:
case|case
name|DT_MIPS_DELTA_SYM_NO
case|:
case|case
name|DT_MIPS_DELTA_CLASSSYM_NO
case|:
case|case
name|DT_MIPS_LOCALPAGE_GOTIDX
case|:
case|case
name|DT_MIPS_LOCAL_GOTIDX
case|:
case|case
name|DT_MIPS_HIDDEN_GOTIDX
case|:
case|case
name|DT_MIPS_PROTECTED_GOTIDX
case|:
name|printf
argument_list|(
literal|" %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dyn
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_MIPS_ICHECKSUM
case|:
case|case
name|DT_MIPS_FLAGS
case|:
case|case
name|DT_MIPS_BASE_ADDRESS
case|:
case|case
name|DT_MIPS_CONFLICT
case|:
case|case
name|DT_MIPS_LIBLIST
case|:
case|case
name|DT_MIPS_RLD_MAP
case|:
case|case
name|DT_MIPS_DELTA_CLASS
case|:
case|case
name|DT_MIPS_DELTA_INSTANCE
case|:
case|case
name|DT_MIPS_DELTA_RELOC
case|:
case|case
name|DT_MIPS_DELTA_SYM
case|:
case|case
name|DT_MIPS_DELTA_CLASSSYM
case|:
case|case
name|DT_MIPS_CXX_FLAGS
case|:
case|case
name|DT_MIPS_PIXIE_INIT
case|:
case|case
name|DT_MIPS_SYMBOL_LIB
case|:
case|case
name|DT_MIPS_OPTIONS
case|:
case|case
name|DT_MIPS_INTERFACE
case|:
case|case
name|DT_MIPS_DYNSTR_ALIGN
case|:
case|case
name|DT_MIPS_INTERFACE_SIZE
case|:
case|case
name|DT_MIPS_RLD_TEXT_RESOLVE_ADDR
case|:
case|case
name|DT_MIPS_COMPACT_SIZE
case|:
case|case
name|DT_MIPS_GP_VALUE
case|:
case|case
name|DT_MIPS_AUX_DYNAMIC
case|:
case|case
name|DT_MIPS_PLTGOT
case|:
case|case
name|DT_MIPS_RLD_OBJ_UPDATE
case|:
case|case
name|DT_MIPS_RWPLT
case|:
name|printf
argument_list|(
literal|" 0x%jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dyn
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_MIPS_IVERSION
case|:
case|case
name|DT_MIPS_PERF_SUFFIX
case|:
case|case
name|DT_AUXILIARY
case|:
case|case
name|DT_FILTER
case|:
name|name
operator|=
name|dyn_str
argument_list|(
name|re
argument_list|,
name|stab
argument_list|,
name|dyn
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_MIPS_TIME_STAMP
case|:
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|timestamp
argument_list|(
name|dyn
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_dyn_val
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|GElf_Dyn
modifier|*
name|dyn
parameter_list|,
name|uint32_t
name|stab
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|dyn
operator|->
name|d_tag
operator|>=
name|DT_LOPROC
operator|&&
name|dyn
operator|->
name|d_tag
operator|<=
name|DT_HIPROC
condition|)
block|{
name|dump_arch_dyn_val
argument_list|(
name|re
argument_list|,
name|dyn
argument_list|,
name|stab
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* These entry values are index into the string table. */
name|name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dyn
operator|->
name|d_tag
operator|==
name|DT_NEEDED
operator|||
name|dyn
operator|->
name|d_tag
operator|==
name|DT_SONAME
operator|||
name|dyn
operator|->
name|d_tag
operator|==
name|DT_RPATH
operator|||
name|dyn
operator|->
name|d_tag
operator|==
name|DT_RUNPATH
condition|)
name|name
operator|=
name|dyn_str
argument_list|(
name|re
argument_list|,
name|stab
argument_list|,
name|dyn
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|->
name|d_tag
condition|)
block|{
case|case
name|DT_NULL
case|:
case|case
name|DT_PLTGOT
case|:
case|case
name|DT_HASH
case|:
case|case
name|DT_STRTAB
case|:
case|case
name|DT_SYMTAB
case|:
case|case
name|DT_RELA
case|:
case|case
name|DT_INIT
case|:
case|case
name|DT_SYMBOLIC
case|:
case|case
name|DT_REL
case|:
case|case
name|DT_DEBUG
case|:
case|case
name|DT_TEXTREL
case|:
case|case
name|DT_JMPREL
case|:
case|case
name|DT_FINI
case|:
case|case
name|DT_VERDEF
case|:
case|case
name|DT_VERNEED
case|:
case|case
name|DT_VERSYM
case|:
case|case
name|DT_GNU_HASH
case|:
case|case
name|DT_GNU_LIBLIST
case|:
case|case
name|DT_GNU_CONFLICT
case|:
name|printf
argument_list|(
literal|" 0x%jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dyn
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
case|case
name|DT_RELASZ
case|:
case|case
name|DT_RELAENT
case|:
case|case
name|DT_STRSZ
case|:
case|case
name|DT_SYMENT
case|:
case|case
name|DT_RELSZ
case|:
case|case
name|DT_RELENT
case|:
case|case
name|DT_INIT_ARRAYSZ
case|:
case|case
name|DT_FINI_ARRAYSZ
case|:
case|case
name|DT_GNU_CONFLICTSZ
case|:
case|case
name|DT_GNU_LIBLISTSZ
case|:
name|printf
argument_list|(
literal|" %ju (bytes)\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dyn
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_RELACOUNT
case|:
case|case
name|DT_RELCOUNT
case|:
case|case
name|DT_VERDEFNUM
case|:
case|case
name|DT_VERNEEDNUM
case|:
name|printf
argument_list|(
literal|" %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dyn
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NEEDED
case|:
name|printf
argument_list|(
literal|" Shared library: [%s]\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_SONAME
case|:
name|printf
argument_list|(
literal|" Library soname: [%s]\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_RPATH
case|:
name|printf
argument_list|(
literal|" Library rpath: [%s]\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_RUNPATH
case|:
name|printf
argument_list|(
literal|" Library runpath: [%s]\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_PLTREL
case|:
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|dt_type
argument_list|(
name|re
operator|->
name|ehdr
operator|.
name|e_machine
argument_list|,
name|dyn
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_GNU_PRELINKED
case|:
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|timestamp
argument_list|(
name|dyn
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_rel
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|,
name|Elf_Data
modifier|*
name|d
parameter_list|)
block|{
name|GElf_Rel
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|symname
decl_stmt|;
name|uint64_t
name|symval
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|uint32_t
name|type
decl_stmt|;
name|uint8_t
name|type2
decl_stmt|,
name|type3
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|link
operator|>=
name|re
operator|->
name|shnum
condition|)
return|return;
define|#
directive|define
name|REL_HDR
value|"r_offset", "r_info", "r_type", "st_value", "st_name"
define|#
directive|define
name|REL_CT32
value|(uintmax_t)r.r_offset, (uintmax_t)r.r_info,	    \ 		elftc_reloc_type_str(re->ehdr.e_machine,	    \ 		ELF32_R_TYPE(r.r_info)), (uintmax_t)symval, symname
define|#
directive|define
name|REL_CT64
value|(uintmax_t)r.r_offset, (uintmax_t)r.r_info,	    \ 		elftc_reloc_type_str(re->ehdr.e_machine, type),	    \ 		(uintmax_t)symval, symname
name|printf
argument_list|(
literal|"\nRelocation section (%s):\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|ec
operator|==
name|ELFCLASS32
condition|)
name|printf
argument_list|(
literal|"%-8s %-8s %-19s %-8s %s\n"
argument_list|,
name|REL_HDR
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_WW
condition|)
name|printf
argument_list|(
literal|"%-16s %-16s %-24s %-16s %s\n"
argument_list|,
name|REL_HDR
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%-12s %-12s %-19s %-16s %s\n"
argument_list|,
name|REL_HDR
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|d
operator|->
name|d_size
operator|==
name|s
operator|->
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_ent_count
argument_list|(
name|s
argument_list|,
operator|&
name|len
argument_list|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|gelf_getrel
argument_list|(
name|d
argument_list|,
name|i
argument_list|,
operator|&
name|r
argument_list|)
operator|!=
operator|&
name|r
condition|)
block|{
name|warnx
argument_list|(
literal|"gelf_getrel failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|symname
operator|=
name|get_symbol_name
argument_list|(
name|re
argument_list|,
name|s
operator|->
name|link
argument_list|,
name|GELF_R_SYM
argument_list|(
name|r
operator|.
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
name|symval
operator|=
name|get_symbol_value
argument_list|(
name|re
argument_list|,
name|s
operator|->
name|link
argument_list|,
name|GELF_R_SYM
argument_list|(
name|r
operator|.
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|ec
operator|==
name|ELFCLASS32
condition|)
block|{
name|r
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF64_R_SYM
argument_list|(
name|r
operator|.
name|r_info
argument_list|)
argument_list|,
name|ELF64_R_TYPE
argument_list|(
name|r
operator|.
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%8.8jx %8.8jx %-19.19s %8.8jx %s\n"
argument_list|,
name|REL_CT32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|r
operator|.
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|ehdr
operator|.
name|e_machine
operator|==
name|EM_MIPS
condition|)
block|{
name|type2
operator|=
operator|(
name|type
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|type3
operator|=
operator|(
name|type
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|type
operator|=
name|type
operator|&
literal|0xFF
expr_stmt|;
block|}
else|else
block|{
name|type2
operator|=
name|type3
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_WW
condition|)
name|printf
argument_list|(
literal|"%16.16jx %16.16jx %-24.24s"
literal|" %16.16jx %s\n"
argument_list|,
name|REL_CT64
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%12.12jx %12.12jx %-19.19s"
literal|" %16.16jx %s\n"
argument_list|,
name|REL_CT64
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|ehdr
operator|.
name|e_machine
operator|==
name|EM_MIPS
condition|)
block|{
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_WW
condition|)
block|{
name|printf
argument_list|(
literal|"%32s: %s\n"
argument_list|,
literal|"Type2"
argument_list|,
name|elftc_reloc_type_str
argument_list|(
name|EM_MIPS
argument_list|,
name|type2
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%32s: %s\n"
argument_list|,
literal|"Type3"
argument_list|,
name|elftc_reloc_type_str
argument_list|(
name|EM_MIPS
argument_list|,
name|type3
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%24s: %s\n"
argument_list|,
literal|"Type2"
argument_list|,
name|elftc_reloc_type_str
argument_list|(
name|EM_MIPS
argument_list|,
name|type2
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%24s: %s\n"
argument_list|,
literal|"Type3"
argument_list|,
name|elftc_reloc_type_str
argument_list|(
name|EM_MIPS
argument_list|,
name|type3
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
undef|#
directive|undef
name|REL_HDR
undef|#
directive|undef
name|REL_CT
block|}
end_function

begin_function
specifier|static
name|void
name|dump_rela
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|,
name|Elf_Data
modifier|*
name|d
parameter_list|)
block|{
name|GElf_Rela
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|symname
decl_stmt|;
name|uint64_t
name|symval
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|uint32_t
name|type
decl_stmt|;
name|uint8_t
name|type2
decl_stmt|,
name|type3
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|link
operator|>=
name|re
operator|->
name|shnum
condition|)
return|return;
define|#
directive|define
name|RELA_HDR
value|"r_offset", "r_info", "r_type", "st_value", \ 		"st_name + r_addend"
define|#
directive|define
name|RELA_CT32
value|(uintmax_t)r.r_offset, (uintmax_t)r.r_info,	    \ 		elftc_reloc_type_str(re->ehdr.e_machine,	    \ 		ELF32_R_TYPE(r.r_info)), (uintmax_t)symval, symname
define|#
directive|define
name|RELA_CT64
value|(uintmax_t)r.r_offset, (uintmax_t)r.r_info,	    \ 		elftc_reloc_type_str(re->ehdr.e_machine, type),	    \ 		(uintmax_t)symval, symname
name|printf
argument_list|(
literal|"\nRelocation section with addend (%s):\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|ec
operator|==
name|ELFCLASS32
condition|)
name|printf
argument_list|(
literal|"%-8s %-8s %-19s %-8s %s\n"
argument_list|,
name|RELA_HDR
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_WW
condition|)
name|printf
argument_list|(
literal|"%-16s %-16s %-24s %-16s %s\n"
argument_list|,
name|RELA_HDR
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%-12s %-12s %-19s %-16s %s\n"
argument_list|,
name|RELA_HDR
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|d
operator|->
name|d_size
operator|==
name|s
operator|->
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_ent_count
argument_list|(
name|s
argument_list|,
operator|&
name|len
argument_list|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|gelf_getrela
argument_list|(
name|d
argument_list|,
name|i
argument_list|,
operator|&
name|r
argument_list|)
operator|!=
operator|&
name|r
condition|)
block|{
name|warnx
argument_list|(
literal|"gelf_getrel failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|symname
operator|=
name|get_symbol_name
argument_list|(
name|re
argument_list|,
name|s
operator|->
name|link
argument_list|,
name|GELF_R_SYM
argument_list|(
name|r
operator|.
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
name|symval
operator|=
name|get_symbol_value
argument_list|(
name|re
argument_list|,
name|s
operator|->
name|link
argument_list|,
name|GELF_R_SYM
argument_list|(
name|r
operator|.
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|ec
operator|==
name|ELFCLASS32
condition|)
block|{
name|r
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF64_R_SYM
argument_list|(
name|r
operator|.
name|r_info
argument_list|)
argument_list|,
name|ELF64_R_TYPE
argument_list|(
name|r
operator|.
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%8.8jx %8.8jx %-19.19s %8.8jx %s"
argument_list|,
name|RELA_CT32
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" + %x\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|r
operator|.
name|r_addend
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|r
operator|.
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|ehdr
operator|.
name|e_machine
operator|==
name|EM_MIPS
condition|)
block|{
name|type2
operator|=
operator|(
name|type
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|type3
operator|=
operator|(
name|type
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|type
operator|=
name|type
operator|&
literal|0xFF
expr_stmt|;
block|}
else|else
block|{
name|type2
operator|=
name|type3
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_WW
condition|)
name|printf
argument_list|(
literal|"%16.16jx %16.16jx %-24.24s"
literal|" %16.16jx %s"
argument_list|,
name|RELA_CT64
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%12.12jx %12.12jx %-19.19s"
literal|" %16.16jx %s"
argument_list|,
name|RELA_CT64
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" + %jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|r
operator|.
name|r_addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|ehdr
operator|.
name|e_machine
operator|==
name|EM_MIPS
condition|)
block|{
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_WW
condition|)
block|{
name|printf
argument_list|(
literal|"%32s: %s\n"
argument_list|,
literal|"Type2"
argument_list|,
name|elftc_reloc_type_str
argument_list|(
name|EM_MIPS
argument_list|,
name|type2
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%32s: %s\n"
argument_list|,
literal|"Type3"
argument_list|,
name|elftc_reloc_type_str
argument_list|(
name|EM_MIPS
argument_list|,
name|type3
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%24s: %s\n"
argument_list|,
literal|"Type2"
argument_list|,
name|elftc_reloc_type_str
argument_list|(
name|EM_MIPS
argument_list|,
name|type2
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%24s: %s\n"
argument_list|,
literal|"Type3"
argument_list|,
name|elftc_reloc_type_str
argument_list|(
name|EM_MIPS
argument_list|,
name|type3
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
undef|#
directive|undef
name|RELA_HDR
undef|#
directive|undef
name|RELA_CT
block|}
end_function

begin_function
specifier|static
name|void
name|dump_reloc
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|Elf_Data
modifier|*
name|d
decl_stmt|;
name|int
name|i
decl_stmt|,
name|elferr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|re
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|re
operator|->
name|sl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|SHT_REL
operator|||
name|s
operator|->
name|type
operator|==
name|SHT_RELA
condition|)
block|{
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|SHT_REL
condition|)
name|dump_rel
argument_list|(
name|re
argument_list|,
name|s
argument_list|,
name|d
argument_list|)
expr_stmt|;
else|else
name|dump_rela
argument_list|(
name|re
argument_list|,
name|s
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_symtab
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|Elf_Data
modifier|*
name|d
decl_stmt|;
name|GElf_Sym
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|uint32_t
name|stab
decl_stmt|;
name|int
name|elferr
decl_stmt|,
name|j
decl_stmt|,
name|len
decl_stmt|;
name|uint16_t
name|vs
decl_stmt|;
name|s
operator|=
operator|&
name|re
operator|->
name|sl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|link
operator|>=
name|re
operator|->
name|shnum
condition|)
return|return;
name|stab
operator|=
name|s
operator|->
name|link
expr_stmt|;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|d_size
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|get_ent_count
argument_list|(
name|s
argument_list|,
operator|&
name|len
argument_list|)
condition|)
return|return;
name|printf
argument_list|(
literal|"Symbol table (%s)"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" contains %d entries:\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%7s%9s%14s%5s%8s%6s%9s%5s\n"
argument_list|,
literal|"Num:"
argument_list|,
literal|"Value"
argument_list|,
literal|"Size"
argument_list|,
literal|"Type"
argument_list|,
literal|"Bind"
argument_list|,
literal|"Vis"
argument_list|,
literal|"Ndx"
argument_list|,
literal|"Name"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|gelf_getsym
argument_list|(
name|d
argument_list|,
name|j
argument_list|,
operator|&
name|sym
argument_list|)
operator|!=
operator|&
name|sym
condition|)
block|{
name|warnx
argument_list|(
literal|"gelf_getsym failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"%6d:"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %16.16jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sym
operator|.
name|st_value
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %5ju"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sym
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %-7s"
argument_list|,
name|st_type
argument_list|(
name|re
operator|->
name|ehdr
operator|.
name|e_machine
argument_list|,
name|re
operator|->
name|ehdr
operator|.
name|e_ident
index|[
name|EI_OSABI
index|]
argument_list|,
name|GELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %-6s"
argument_list|,
name|st_bind
argument_list|(
name|GELF_ST_BIND
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %-8s"
argument_list|,
name|st_vis
argument_list|(
name|GELF_ST_VISIBILITY
argument_list|(
name|sym
operator|.
name|st_other
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3s"
argument_list|,
name|st_shndx
argument_list|(
name|sym
operator|.
name|st_shndx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|=
name|elf_strptr
argument_list|(
name|re
operator|->
name|elf
argument_list|,
name|stab
argument_list|,
name|sym
operator|.
name|st_name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Append symbol version string for SHT_DYNSYM symbol table. */
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|SHT_DYNSYM
operator|&&
name|re
operator|->
name|ver
operator|!=
name|NULL
operator|&&
name|re
operator|->
name|vs
operator|!=
name|NULL
operator|&&
name|re
operator|->
name|vs
index|[
name|j
index|]
operator|>
literal|1
condition|)
block|{
name|vs
operator|=
name|re
operator|->
name|vs
index|[
name|j
index|]
operator|&
name|VERSYM_VERSION
expr_stmt|;
if|if
condition|(
name|vs
operator|>=
name|re
operator|->
name|ver_sz
operator|||
name|re
operator|->
name|ver
index|[
name|vs
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid versym version index %u"
argument_list|,
name|vs
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|re
operator|->
name|vs
index|[
name|j
index|]
operator|&
name|VERSYM_HIDDEN
operator|||
name|re
operator|->
name|ver
index|[
name|vs
index|]
operator|.
name|type
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"@%s (%d)"
argument_list|,
name|re
operator|->
name|ver
index|[
name|vs
index|]
operator|.
name|name
argument_list|,
name|vs
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"@@%s (%d)"
argument_list|,
name|re
operator|->
name|ver
index|[
name|vs
index|]
operator|.
name|name
argument_list|,
name|vs
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_symtabs
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
name|GElf_Dyn
name|dyn
decl_stmt|;
name|Elf_Data
modifier|*
name|d
decl_stmt|;
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|uint64_t
name|dyn_off
decl_stmt|;
name|int
name|elferr
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|;
comment|/* 	 * If -D is specified, only dump the symbol table specified by 	 * the DT_SYMTAB entry in the .dynamic section. 	 */
name|dyn_off
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_DD
condition|)
block|{
name|s
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|re
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|re
operator|->
name|sl
index|[
name|i
index|]
operator|.
name|type
operator|==
name|SHT_DYNAMIC
condition|)
block|{
name|s
operator|=
operator|&
name|re
operator|->
name|sl
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|d_size
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|get_ent_count
argument_list|(
name|s
argument_list|,
operator|&
name|len
argument_list|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|gelf_getdyn
argument_list|(
name|d
argument_list|,
name|i
argument_list|,
operator|&
name|dyn
argument_list|)
operator|!=
operator|&
name|dyn
condition|)
block|{
name|warnx
argument_list|(
literal|"gelf_getdyn failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dyn
operator|.
name|d_tag
operator|==
name|DT_SYMTAB
condition|)
block|{
name|dyn_off
operator|=
name|dyn
operator|.
name|d_un
operator|.
name|d_val
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Find and dump symbol tables. */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|re
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|re
operator|->
name|sl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|SHT_SYMTAB
operator|||
name|s
operator|->
name|type
operator|==
name|SHT_DYNSYM
condition|)
block|{
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_DD
condition|)
block|{
if|if
condition|(
name|dyn_off
operator|==
name|s
operator|->
name|addr
condition|)
block|{
name|dump_symtab
argument_list|(
name|re
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
name|dump_symtab
argument_list|(
name|re
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_svr4_hash
parameter_list|(
name|struct
name|section
modifier|*
name|s
parameter_list|)
block|{
name|Elf_Data
modifier|*
name|d
decl_stmt|;
name|uint32_t
modifier|*
name|buf
decl_stmt|;
name|uint32_t
name|nbucket
decl_stmt|,
name|nchain
decl_stmt|;
name|uint32_t
modifier|*
name|bucket
decl_stmt|,
modifier|*
name|chain
decl_stmt|;
name|uint32_t
modifier|*
name|bl
decl_stmt|,
modifier|*
name|c
decl_stmt|,
name|maxl
decl_stmt|,
name|total
decl_stmt|;
name|int
name|elferr
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Read and parse the content of .hash section. */
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|d_size
operator|<
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|".hash section too small"
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf
operator|=
name|d
operator|->
name|d_buf
expr_stmt|;
name|nbucket
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|nchain
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|nbucket
operator|<=
literal|0
operator|||
name|nchain
operator|<=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Malformed .hash section"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|d_size
operator|!=
operator|(
name|nbucket
operator|+
name|nchain
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Malformed .hash section"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bucket
operator|=
operator|&
name|buf
index|[
literal|2
index|]
expr_stmt|;
name|chain
operator|=
operator|&
name|buf
index|[
literal|2
operator|+
name|nbucket
index|]
expr_stmt|;
name|maxl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|bl
operator|=
name|calloc
argument_list|(
name|nbucket
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bl
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|uint32_t
operator|)
name|i
operator|<
name|nbucket
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
name|bucket
index|[
name|i
index|]
init|;
name|j
operator|>
literal|0
operator|&&
operator|(
name|uint32_t
operator|)
name|j
operator|<
name|nchain
condition|;
name|j
operator|=
name|chain
index|[
name|j
index|]
control|)
if|if
condition|(
operator|++
name|bl
index|[
name|i
index|]
operator|>
name|maxl
condition|)
name|maxl
operator|=
name|bl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|calloc
argument_list|(
name|maxl
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|uint32_t
operator|)
name|i
operator|<
name|nbucket
condition|;
name|i
operator|++
control|)
name|c
index|[
name|bl
index|[
name|i
index|]
index|]
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"\nHistogram for bucket list length (total of %u buckets):\n"
argument_list|,
name|nbucket
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Length\tNumber\t\t%% of total\tCoverage\n"
argument_list|)
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|uint32_t
operator|)
name|i
operator|<=
name|maxl
condition|;
name|i
operator|++
control|)
block|{
name|total
operator|+=
name|c
index|[
name|i
index|]
operator|*
name|i
expr_stmt|;
name|printf
argument_list|(
literal|"%7u\t%-10u\t(%5.1f%%)\t%5.1f%%\n"
argument_list|,
name|i
argument_list|,
name|c
index|[
name|i
index|]
argument_list|,
name|c
index|[
name|i
index|]
operator|*
literal|100.0
operator|/
name|nbucket
argument_list|,
name|total
operator|*
literal|100.0
operator|/
operator|(
name|nchain
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_svr4_hash64
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
block|{
name|Elf_Data
modifier|*
name|d
decl_stmt|,
name|dst
decl_stmt|;
name|uint64_t
modifier|*
name|buf
decl_stmt|;
name|uint64_t
name|nbucket
decl_stmt|,
name|nchain
decl_stmt|;
name|uint64_t
modifier|*
name|bucket
decl_stmt|,
modifier|*
name|chain
decl_stmt|;
name|uint64_t
modifier|*
name|bl
decl_stmt|,
modifier|*
name|c
decl_stmt|,
name|maxl
decl_stmt|,
name|total
decl_stmt|;
name|int
name|elferr
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* 	 * ALPHA uses 64-bit hash entries. Since libelf assumes that 	 * .hash section contains only 32-bit entry, an explicit 	 * gelf_xlatetom is needed here. 	 */
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|elf_rawdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_rawdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|d_type
operator|=
name|ELF_T_XWORD
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|dst
argument_list|,
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gelf_xlatetom
argument_list|(
name|re
operator|->
name|elf
argument_list|,
operator|&
name|dst
argument_list|,
name|d
argument_list|,
name|re
operator|->
name|ehdr
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
argument_list|)
operator|!=
operator|&
name|dst
condition|)
block|{
name|warnx
argument_list|(
literal|"gelf_xlatetom failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dst
operator|.
name|d_size
operator|<
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|".hash section too small"
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf
operator|=
name|dst
operator|.
name|d_buf
expr_stmt|;
name|nbucket
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|nchain
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|nbucket
operator|<=
literal|0
operator|||
name|nchain
operator|<=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Malformed .hash section"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|d_size
operator|!=
operator|(
name|nbucket
operator|+
name|nchain
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Malformed .hash section"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bucket
operator|=
operator|&
name|buf
index|[
literal|2
index|]
expr_stmt|;
name|chain
operator|=
operator|&
name|buf
index|[
literal|2
operator|+
name|nbucket
index|]
expr_stmt|;
name|maxl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|bl
operator|=
name|calloc
argument_list|(
name|nbucket
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bl
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|uint32_t
operator|)
name|i
operator|<
name|nbucket
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
name|bucket
index|[
name|i
index|]
init|;
name|j
operator|>
literal|0
operator|&&
operator|(
name|uint32_t
operator|)
name|j
operator|<
name|nchain
condition|;
name|j
operator|=
name|chain
index|[
name|j
index|]
control|)
if|if
condition|(
operator|++
name|bl
index|[
name|i
index|]
operator|>
name|maxl
condition|)
name|maxl
operator|=
name|bl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|calloc
argument_list|(
name|maxl
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|uint64_t
operator|)
name|i
operator|<
name|nbucket
condition|;
name|i
operator|++
control|)
name|c
index|[
name|bl
index|[
name|i
index|]
index|]
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"Histogram for bucket list length (total of %ju buckets):\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|nbucket
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Length\tNumber\t\t%% of total\tCoverage\n"
argument_list|)
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|uint64_t
operator|)
name|i
operator|<=
name|maxl
condition|;
name|i
operator|++
control|)
block|{
name|total
operator|+=
name|c
index|[
name|i
index|]
operator|*
name|i
expr_stmt|;
name|printf
argument_list|(
literal|"%7u\t%-10ju\t(%5.1f%%)\t%5.1f%%\n"
argument_list|,
name|i
argument_list|,
operator|(
name|uintmax_t
operator|)
name|c
index|[
name|i
index|]
argument_list|,
name|c
index|[
name|i
index|]
operator|*
literal|100.0
operator|/
name|nbucket
argument_list|,
name|total
operator|*
literal|100.0
operator|/
operator|(
name|nchain
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_gnu_hash
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|ds
decl_stmt|;
name|Elf_Data
modifier|*
name|d
decl_stmt|;
name|uint32_t
modifier|*
name|buf
decl_stmt|;
name|uint32_t
modifier|*
name|bucket
decl_stmt|,
modifier|*
name|chain
decl_stmt|;
name|uint32_t
name|nbucket
decl_stmt|,
name|nchain
decl_stmt|,
name|symndx
decl_stmt|,
name|maskwords
decl_stmt|;
name|uint32_t
modifier|*
name|bl
decl_stmt|,
modifier|*
name|c
decl_stmt|,
name|maxl
decl_stmt|,
name|total
decl_stmt|;
name|int
name|elferr
decl_stmt|,
name|dynsymcount
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|d_size
operator|<
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|".gnu.hash section too small"
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf
operator|=
name|d
operator|->
name|d_buf
expr_stmt|;
name|nbucket
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|symndx
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|maskwords
operator|=
name|buf
index|[
literal|2
index|]
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|link
operator|>=
name|re
operator|->
name|shnum
condition|)
return|return;
name|ds
operator|=
operator|&
name|re
operator|->
name|sl
index|[
name|s
operator|->
name|link
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|get_ent_count
argument_list|(
name|ds
argument_list|,
operator|&
name|dynsymcount
argument_list|)
condition|)
return|return;
if|if
condition|(
name|symndx
operator|>=
operator|(
name|uint32_t
operator|)
name|dynsymcount
condition|)
block|{
name|warnx
argument_list|(
literal|"Malformed .gnu.hash section (symndx out of range)"
argument_list|)
expr_stmt|;
return|return;
block|}
name|nchain
operator|=
name|dynsymcount
operator|-
name|symndx
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|d_size
operator|!=
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
name|maskwords
operator|*
operator|(
name|re
operator|->
name|ec
operator|==
name|ELFCLASS32
condition|?
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
else|:
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|)
operator|+
operator|(
name|nbucket
operator|+
name|nchain
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Malformed .gnu.hash section"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bucket
operator|=
name|buf
operator|+
operator|(
name|re
operator|->
name|ec
operator|==
name|ELFCLASS32
condition|?
name|maskwords
else|:
name|maskwords
operator|*
literal|2
operator|)
expr_stmt|;
name|chain
operator|=
name|bucket
operator|+
name|nbucket
expr_stmt|;
name|maxl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|bl
operator|=
name|calloc
argument_list|(
name|nbucket
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bl
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|uint32_t
operator|)
name|i
operator|<
name|nbucket
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
name|bucket
index|[
name|i
index|]
init|;
name|j
operator|>
literal|0
operator|&&
operator|(
name|uint32_t
operator|)
name|j
operator|-
name|symndx
operator|<
name|nchain
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|++
name|bl
index|[
name|i
index|]
operator|>
name|maxl
condition|)
name|maxl
operator|=
name|bl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|chain
index|[
name|j
operator|-
name|symndx
index|]
operator|&
literal|1
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|c
operator|=
name|calloc
argument_list|(
name|maxl
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|uint32_t
operator|)
name|i
operator|<
name|nbucket
condition|;
name|i
operator|++
control|)
name|c
index|[
name|bl
index|[
name|i
index|]
index|]
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"Histogram for bucket list length (total of %u buckets):\n"
argument_list|,
name|nbucket
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Length\tNumber\t\t%% of total\tCoverage\n"
argument_list|)
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|uint32_t
operator|)
name|i
operator|<=
name|maxl
condition|;
name|i
operator|++
control|)
block|{
name|total
operator|+=
name|c
index|[
name|i
index|]
operator|*
name|i
expr_stmt|;
name|printf
argument_list|(
literal|"%7u\t%-10u\t(%5.1f%%)\t%5.1f%%\n"
argument_list|,
name|i
argument_list|,
name|c
index|[
name|i
index|]
argument_list|,
name|c
index|[
name|i
index|]
operator|*
literal|100.0
operator|/
name|nbucket
argument_list|,
name|total
operator|*
literal|100.0
operator|/
operator|(
name|nchain
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_hash
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|re
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|re
operator|->
name|sl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|SHT_HASH
operator|||
name|s
operator|->
name|type
operator|==
name|SHT_GNU_HASH
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|SHT_GNU_HASH
condition|)
name|dump_gnu_hash
argument_list|(
name|re
argument_list|,
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|re
operator|->
name|ehdr
operator|.
name|e_machine
operator|==
name|EM_ALPHA
operator|&&
name|s
operator|->
name|entsize
operator|==
literal|8
condition|)
name|dump_svr4_hash64
argument_list|(
name|re
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|dump_svr4_hash
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_notes
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|rawfile
decl_stmt|;
name|GElf_Phdr
name|phdr
decl_stmt|;
name|Elf_Data
modifier|*
name|d
decl_stmt|;
name|size_t
name|filesize
decl_stmt|,
name|phnum
decl_stmt|;
name|int
name|i
decl_stmt|,
name|elferr
decl_stmt|;
if|if
condition|(
name|re
operator|->
name|ehdr
operator|.
name|e_type
operator|==
name|ET_CORE
condition|)
block|{
comment|/* 		 * Search program headers in the core file for 		 * PT_NOTE entry. 		 */
if|if
condition|(
name|elf_getphnum
argument_list|(
name|re
operator|->
name|elf
argument_list|,
operator|&
name|phnum
argument_list|)
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_getphnum failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|phnum
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|rawfile
operator|=
name|elf_rawfile
argument_list|(
name|re
operator|->
name|elf
argument_list|,
operator|&
name|filesize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_rawfile failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|phnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|gelf_getphdr
argument_list|(
name|re
operator|->
name|elf
argument_list|,
name|i
argument_list|,
operator|&
name|phdr
argument_list|)
operator|!=
operator|&
name|phdr
condition|)
block|{
name|warnx
argument_list|(
literal|"gelf_getphdr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|phdr
operator|.
name|p_type
operator|==
name|PT_NOTE
condition|)
block|{
if|if
condition|(
name|phdr
operator|.
name|p_offset
operator|>=
name|filesize
operator|||
name|phdr
operator|.
name|p_filesz
operator|>
name|filesize
operator|-
name|phdr
operator|.
name|p_offset
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid PHDR offset"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|dump_notes_content
argument_list|(
name|re
argument_list|,
name|rawfile
operator|+
name|phdr
operator|.
name|p_offset
argument_list|,
name|phdr
operator|.
name|p_filesz
argument_list|,
name|phdr
operator|.
name|p_offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * For objects other than core files, Search for 		 * SHT_NOTE sections. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|re
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|re
operator|->
name|sl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|SHT_NOTE
condition|)
block|{
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|dump_notes_content
argument_list|(
name|re
argument_list|,
name|d
operator|->
name|d_buf
argument_list|,
name|d
operator|->
name|d_size
argument_list|,
name|s
operator|->
name|off
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_notes_content
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|sz
parameter_list|,
name|off_t
name|off
parameter_list|)
block|{
name|Elf_Note
modifier|*
name|note
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|printf
argument_list|(
literal|"\nNotes at offset %#010jx with length %#010jx:\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|off
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sz
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %-13s %-15s %s\n"
argument_list|,
literal|"Owner"
argument_list|,
literal|"Data size"
argument_list|,
literal|"Description"
argument_list|)
expr_stmt|;
name|end
operator|=
name|buf
operator|+
name|sz
expr_stmt|;
while|while
condition|(
name|buf
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|buf
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|note
argument_list|)
operator|>
name|end
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid note header"
argument_list|)
expr_stmt|;
return|return;
block|}
name|note
operator|=
operator|(
name|Elf_Note
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|buf
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|note
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * The name field is required to be nul-terminated, and 		 * n_namesz includes the terminating nul in observed 		 * implementations (contrary to the ELF-64 spec). A special 		 * case is needed for cores generated by some older Linux 		 * versions, which write a note named "CORE" without a nul 		 * terminator and n_namesz = 4. 		 */
if|if
condition|(
name|note
operator|->
name|n_namesz
operator|==
literal|0
condition|)
name|name
operator|=
literal|""
expr_stmt|;
elseif|else
if|if
condition|(
name|note
operator|->
name|n_namesz
operator|==
literal|4
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"CORE"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|name
operator|=
literal|"CORE"
expr_stmt|;
elseif|else
if|if
condition|(
name|strnlen
argument_list|(
name|name
argument_list|,
name|note
operator|->
name|n_namesz
argument_list|)
operator|>=
name|note
operator|->
name|n_namesz
condition|)
name|name
operator|=
literal|"<invalid>"
expr_stmt|;
name|printf
argument_list|(
literal|"  %-13s %#010jx"
argument_list|,
name|name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|note
operator|->
name|n_descsz
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      %s\n"
argument_list|,
name|note_type
argument_list|(
name|name
argument_list|,
name|re
operator|->
name|ehdr
operator|.
name|e_type
argument_list|,
name|note
operator|->
name|n_type
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_Note
argument_list|)
operator|+
name|roundup2
argument_list|(
name|note
operator|->
name|n_namesz
argument_list|,
literal|4
argument_list|)
operator|+
name|roundup2
argument_list|(
name|note
operator|->
name|n_descsz
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Symbol versioning sections are the same for 32bit and 64bit  * ELF objects.  */
end_comment

begin_define
define|#
directive|define
name|Elf_Verdef
value|Elf32_Verdef
end_define

begin_define
define|#
directive|define
name|Elf_Verdaux
value|Elf32_Verdaux
end_define

begin_define
define|#
directive|define
name|Elf_Verneed
value|Elf32_Verneed
end_define

begin_define
define|#
directive|define
name|Elf_Vernaux
value|Elf32_Vernaux
end_define

begin_define
define|#
directive|define
name|SAVE_VERSION_NAME
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|,
name|t
parameter_list|)
define|\
value|do {								\ 		while (x>= re->ver_sz) {				\ 			nv = realloc(re->ver,				\ 			    sizeof(*re->ver) * re->ver_sz * 2);		\ 			if (nv == NULL) {				\ 				warn("realloc failed");			\ 				free(re->ver);				\ 				return;					\ 			}						\ 			re->ver = nv;					\ 			for (i = re->ver_sz; i< re->ver_sz * 2; i++) {	\ 				re->ver[i].name = NULL;			\ 				re->ver[i].type = 0;			\ 			}						\ 			re->ver_sz *= 2;				\ 		}							\ 		if (x> 1) {						\ 			re->ver[x].name = n;				\ 			re->ver[x].type = t;				\ 		}							\ 	} while (0)
end_define

begin_function
specifier|static
name|void
name|dump_verdef
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|int
name|dump
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|struct
name|symver
modifier|*
name|nv
decl_stmt|;
name|Elf_Data
modifier|*
name|d
decl_stmt|;
name|Elf_Verdef
modifier|*
name|vd
decl_stmt|;
name|Elf_Verdaux
modifier|*
name|vda
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|buf2
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|elferr
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|re
operator|->
name|vd_s
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|s
operator|->
name|link
operator|>=
name|re
operator|->
name|shnum
condition|)
return|return;
if|if
condition|(
name|re
operator|->
name|ver
operator|==
name|NULL
condition|)
block|{
name|re
operator|->
name|ver_sz
operator|=
literal|16
expr_stmt|;
if|if
condition|(
operator|(
name|re
operator|->
name|ver
operator|=
name|calloc
argument_list|(
name|re
operator|->
name|ver_sz
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|re
operator|->
name|ver
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"calloc failed"
argument_list|)
expr_stmt|;
return|return;
block|}
name|re
operator|->
name|ver
index|[
literal|0
index|]
operator|.
name|name
operator|=
literal|"*local*"
expr_stmt|;
name|re
operator|->
name|ver
index|[
literal|1
index|]
operator|.
name|name
operator|=
literal|"*global*"
expr_stmt|;
block|}
if|if
condition|(
name|dump
condition|)
name|printf
argument_list|(
literal|"\nVersion definition section (%s):\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|d_size
operator|==
literal|0
condition|)
return|return;
name|buf
operator|=
name|d
operator|->
name|d_buf
expr_stmt|;
name|end
operator|=
name|buf
operator|+
name|d
operator|->
name|d_size
expr_stmt|;
while|while
condition|(
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Verdef
argument_list|)
operator|<=
name|end
condition|)
block|{
name|vd
operator|=
operator|(
name|Elf_Verdef
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|buf
expr_stmt|;
if|if
condition|(
name|dump
condition|)
block|{
name|printf
argument_list|(
literal|"  0x%4.4lx"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|buf
operator|-
operator|(
name|uint8_t
operator|*
operator|)
name|d
operator|->
name|d_buf
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" vd_version: %u vd_flags: %d"
literal|" vd_ndx: %u vd_cnt: %u"
argument_list|,
name|vd
operator|->
name|vd_version
argument_list|,
name|vd
operator|->
name|vd_flags
argument_list|,
name|vd
operator|->
name|vd_ndx
argument_list|,
name|vd
operator|->
name|vd_cnt
argument_list|)
expr_stmt|;
block|}
name|buf2
operator|=
name|buf
operator|+
name|vd
operator|->
name|vd_aux
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|buf2
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Verdaux
argument_list|)
operator|<=
name|end
operator|&&
name|j
operator|<
name|vd
operator|->
name|vd_cnt
condition|)
block|{
name|vda
operator|=
operator|(
name|Elf_Verdaux
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|buf2
expr_stmt|;
name|name
operator|=
name|get_string
argument_list|(
name|re
argument_list|,
name|s
operator|->
name|link
argument_list|,
name|vda
operator|->
name|vda_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dump
condition|)
name|printf
argument_list|(
literal|" vda_name: %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|SAVE_VERSION_NAME
argument_list|(
operator|(
name|int
operator|)
name|vd
operator|->
name|vd_ndx
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dump
condition|)
name|printf
argument_list|(
literal|"  0x%4.4lx parent: %s\n"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|buf2
operator|-
operator|(
name|uint8_t
operator|*
operator|)
name|d
operator|->
name|d_buf
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|vda
operator|->
name|vda_next
operator|==
literal|0
condition|)
break|break;
name|buf2
operator|+=
name|vda
operator|->
name|vda_next
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|vd
operator|->
name|vd_next
operator|==
literal|0
condition|)
break|break;
name|buf
operator|+=
name|vd
operator|->
name|vd_next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_verneed
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|int
name|dump
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|struct
name|symver
modifier|*
name|nv
decl_stmt|;
name|Elf_Data
modifier|*
name|d
decl_stmt|;
name|Elf_Verneed
modifier|*
name|vn
decl_stmt|;
name|Elf_Vernaux
modifier|*
name|vna
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|buf2
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|elferr
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|re
operator|->
name|vn_s
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|s
operator|->
name|link
operator|>=
name|re
operator|->
name|shnum
condition|)
return|return;
if|if
condition|(
name|re
operator|->
name|ver
operator|==
name|NULL
condition|)
block|{
name|re
operator|->
name|ver_sz
operator|=
literal|16
expr_stmt|;
if|if
condition|(
operator|(
name|re
operator|->
name|ver
operator|=
name|calloc
argument_list|(
name|re
operator|->
name|ver_sz
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|re
operator|->
name|ver
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"calloc failed"
argument_list|)
expr_stmt|;
return|return;
block|}
name|re
operator|->
name|ver
index|[
literal|0
index|]
operator|.
name|name
operator|=
literal|"*local*"
expr_stmt|;
name|re
operator|->
name|ver
index|[
literal|1
index|]
operator|.
name|name
operator|=
literal|"*global*"
expr_stmt|;
block|}
if|if
condition|(
name|dump
condition|)
name|printf
argument_list|(
literal|"\nVersion needed section (%s):\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|d_size
operator|==
literal|0
condition|)
return|return;
name|buf
operator|=
name|d
operator|->
name|d_buf
expr_stmt|;
name|end
operator|=
name|buf
operator|+
name|d
operator|->
name|d_size
expr_stmt|;
while|while
condition|(
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Verneed
argument_list|)
operator|<=
name|end
condition|)
block|{
name|vn
operator|=
operator|(
name|Elf_Verneed
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|buf
expr_stmt|;
if|if
condition|(
name|dump
condition|)
block|{
name|printf
argument_list|(
literal|"  0x%4.4lx"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|buf
operator|-
operator|(
name|uint8_t
operator|*
operator|)
name|d
operator|->
name|d_buf
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" vn_version: %u vn_file: %s vn_cnt: %u\n"
argument_list|,
name|vn
operator|->
name|vn_version
argument_list|,
name|get_string
argument_list|(
name|re
argument_list|,
name|s
operator|->
name|link
argument_list|,
name|vn
operator|->
name|vn_file
argument_list|)
argument_list|,
name|vn
operator|->
name|vn_cnt
argument_list|)
expr_stmt|;
block|}
name|buf2
operator|=
name|buf
operator|+
name|vn
operator|->
name|vn_aux
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|buf2
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Vernaux
argument_list|)
operator|<=
name|end
operator|&&
name|j
operator|<
name|vn
operator|->
name|vn_cnt
condition|)
block|{
name|vna
operator|=
operator|(
name|Elf32_Vernaux
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|buf2
expr_stmt|;
if|if
condition|(
name|dump
condition|)
name|printf
argument_list|(
literal|"  0x%4.4lx"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|buf2
operator|-
operator|(
name|uint8_t
operator|*
operator|)
name|d
operator|->
name|d_buf
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|get_string
argument_list|(
name|re
argument_list|,
name|s
operator|->
name|link
argument_list|,
name|vna
operator|->
name|vna_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump
condition|)
name|printf
argument_list|(
literal|"   vna_name: %s vna_flags: %u"
literal|" vna_other: %u\n"
argument_list|,
name|name
argument_list|,
name|vna
operator|->
name|vna_flags
argument_list|,
name|vna
operator|->
name|vna_other
argument_list|)
expr_stmt|;
name|SAVE_VERSION_NAME
argument_list|(
operator|(
name|int
operator|)
name|vna
operator|->
name|vna_other
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vna
operator|->
name|vna_next
operator|==
literal|0
condition|)
break|break;
name|buf2
operator|+=
name|vna
operator|->
name|vna_next
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|vn
operator|->
name|vn_next
operator|==
literal|0
condition|)
break|break;
name|buf
operator|+=
name|vn
operator|->
name|vn_next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_versym
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint16_t
name|vs
decl_stmt|;
if|if
condition|(
name|re
operator|->
name|vs_s
operator|==
name|NULL
operator|||
name|re
operator|->
name|ver
operator|==
name|NULL
operator|||
name|re
operator|->
name|vs
operator|==
name|NULL
condition|)
return|return;
name|printf
argument_list|(
literal|"\nVersion symbol section (%s):\n"
argument_list|,
name|re
operator|->
name|vs_s
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|re
operator|->
name|vs_sz
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %03x:"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|vs
operator|=
name|re
operator|->
name|vs
index|[
name|i
index|]
operator|&
name|VERSYM_VERSION
expr_stmt|;
if|if
condition|(
name|vs
operator|>=
name|re
operator|->
name|ver_sz
operator|||
name|re
operator|->
name|ver
index|[
name|vs
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid versym version index %u"
argument_list|,
name|re
operator|->
name|vs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|re
operator|->
name|vs
index|[
name|i
index|]
operator|&
name|VERSYM_HIDDEN
condition|)
name|printf
argument_list|(
literal|" %3xh %-12s "
argument_list|,
name|vs
argument_list|,
name|re
operator|->
name|ver
index|[
name|re
operator|->
name|vs
index|[
name|i
index|]
operator|&
name|VERSYM_VERSION
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %3x %-12s "
argument_list|,
name|vs
argument_list|,
name|re
operator|->
name|ver
index|[
name|re
operator|->
name|vs
index|[
name|i
index|]
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_ver
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
if|if
condition|(
name|re
operator|->
name|vs_s
operator|&&
name|re
operator|->
name|ver
operator|&&
name|re
operator|->
name|vs
condition|)
name|dump_versym
argument_list|(
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|vd_s
condition|)
name|dump_verdef
argument_list|(
name|re
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|vn_s
condition|)
name|dump_verneed
argument_list|(
name|re
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|search_ver
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|Elf_Data
modifier|*
name|d
decl_stmt|;
name|int
name|elferr
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|re
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|re
operator|->
name|sl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|SHT_SUNW_versym
condition|)
name|re
operator|->
name|vs_s
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|SHT_SUNW_verneed
condition|)
name|re
operator|->
name|vn_s
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|SHT_SUNW_verdef
condition|)
name|re
operator|->
name|vd_s
operator|=
name|s
expr_stmt|;
block|}
if|if
condition|(
name|re
operator|->
name|vd_s
condition|)
name|dump_verdef
argument_list|(
name|re
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|vn_s
condition|)
name|dump_verneed
argument_list|(
name|re
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|vs_s
operator|&&
name|re
operator|->
name|ver
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|elf_getdata
argument_list|(
name|re
operator|->
name|vs_s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|d_size
operator|==
literal|0
condition|)
return|return;
name|re
operator|->
name|vs
operator|=
name|d
operator|->
name|d_buf
expr_stmt|;
name|re
operator|->
name|vs_sz
operator|=
name|d
operator|->
name|d_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_Half
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_undef
undef|#
directive|undef
name|Elf_Verdef
end_undef

begin_undef
undef|#
directive|undef
name|Elf_Verdaux
end_undef

begin_undef
undef|#
directive|undef
name|Elf_Verneed
end_undef

begin_undef
undef|#
directive|undef
name|Elf_Vernaux
end_undef

begin_undef
undef|#
directive|undef
name|SAVE_VERSION_NAME
end_undef

begin_comment
comment|/*  * Elf32_Lib and Elf64_Lib are identical.  */
end_comment

begin_define
define|#
directive|define
name|Elf_Lib
value|Elf32_Lib
end_define

begin_function
specifier|static
name|void
name|dump_liblist
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|struct
name|tm
modifier|*
name|t
decl_stmt|;
name|time_t
name|ti
decl_stmt|;
name|char
name|tbuf
index|[
literal|20
index|]
decl_stmt|;
name|Elf_Data
modifier|*
name|d
decl_stmt|;
name|Elf_Lib
modifier|*
name|lib
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|elferr
decl_stmt|,
name|first
decl_stmt|,
name|len
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|re
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|re
operator|->
name|sl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|!=
name|SHT_GNU_LIBLIST
condition|)
continue|continue;
if|if
condition|(
name|s
operator|->
name|link
operator|>=
name|re
operator|->
name|shnum
condition|)
continue|continue;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|d
operator|->
name|d_size
operator|<=
literal|0
condition|)
continue|continue;
name|lib
operator|=
name|d
operator|->
name|d_buf
expr_stmt|;
if|if
condition|(
operator|!
name|get_ent_count
argument_list|(
name|s
argument_list|,
operator|&
name|len
argument_list|)
condition|)
continue|continue;
name|printf
argument_list|(
literal|"\nLibrary list section '%s' "
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"contains %d entries:\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%12s%24s%18s%10s%6s\n"
argument_list|,
literal|"Library"
argument_list|,
literal|"Time Stamp"
argument_list|,
literal|"Checksum"
argument_list|,
literal|"Version"
argument_list|,
literal|"Flags"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|uint64_t
operator|)
name|j
operator|<
name|s
operator|->
name|sz
operator|/
name|s
operator|->
name|entsize
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%3d: "
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-20.20s "
argument_list|,
name|get_string
argument_list|(
name|re
argument_list|,
name|s
operator|->
name|link
argument_list|,
name|lib
operator|->
name|l_name
argument_list|)
argument_list|)
expr_stmt|;
name|ti
operator|=
name|lib
operator|->
name|l_time_stamp
expr_stmt|;
name|t
operator|=
name|gmtime
argument_list|(
operator|&
name|ti
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|"%04d-%02d-%02dT%02d:%02d"
literal|":%2d"
argument_list|,
name|t
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|t
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|t
operator|->
name|tm_mday
argument_list|,
name|t
operator|->
name|tm_hour
argument_list|,
name|t
operator|->
name|tm_min
argument_list|,
name|t
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-19.19s "
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%08x "
argument_list|,
name|lib
operator|->
name|l_checksum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-7d %#x"
argument_list|,
name|lib
operator|->
name|l_version
argument_list|,
name|lib
operator|->
name|l_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|lib
operator|->
name|l_flags
operator|!=
literal|0
condition|)
block|{
name|first
operator|=
literal|1
expr_stmt|;
name|putchar
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|l_flag
index|[
name|k
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|l_flag
index|[
name|k
index|]
operator|.
name|value
operator|&
name|lib
operator|->
name|l_flags
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|first
condition|)
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
else|else
name|first
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|l_flag
index|[
name|k
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|lib
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_undef
undef|#
directive|undef
name|Elf_Lib
end_undef

begin_function
specifier|static
name|void
name|dump_section_groups
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|symname
decl_stmt|;
name|Elf_Data
modifier|*
name|d
decl_stmt|;
name|uint32_t
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|elferr
decl_stmt|;
name|size_t
name|n
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|re
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|re
operator|->
name|sl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|!=
name|SHT_GROUP
condition|)
continue|continue;
if|if
condition|(
name|s
operator|->
name|link
operator|>=
name|re
operator|->
name|shnum
condition|)
continue|continue;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|d
operator|->
name|d_size
operator|<=
literal|0
condition|)
continue|continue;
name|w
operator|=
name|d
operator|->
name|d_buf
expr_stmt|;
comment|/* We only support COMDAT section. */
ifndef|#
directive|ifndef
name|GRP_COMDAT
define|#
directive|define
name|GRP_COMDAT
value|0x1
endif|#
directive|endif
if|if
condition|(
operator|(
operator|*
name|w
operator|++
operator|&
name|GRP_COMDAT
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|s
operator|->
name|entsize
operator|==
literal|0
condition|)
name|s
operator|->
name|entsize
operator|=
literal|4
expr_stmt|;
name|symname
operator|=
name|get_symbol_name
argument_list|(
name|re
argument_list|,
name|s
operator|->
name|link
argument_list|,
name|s
operator|->
name|info
argument_list|)
expr_stmt|;
name|n
operator|=
name|s
operator|->
name|sz
operator|/
name|s
operator|->
name|entsize
expr_stmt|;
if|if
condition|(
name|n
operator|--
operator|<
literal|1
condition|)
return|return;
name|printf
argument_list|(
literal|"\nCOMDAT group section [%5d] `%s' [%s] contains %ju"
literal|" sections:\n"
argument_list|,
name|i
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|symname
argument_list|,
operator|(
name|uintmax_t
operator|)
name|n
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   %-10.10s %s\n"
argument_list|,
literal|"[Index]"
argument_list|,
literal|"Name"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|j
operator|<
name|n
condition|;
name|j
operator|++
operator|,
name|w
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|w
operator|>=
name|re
operator|->
name|shnum
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid section index: %u"
argument_list|,
operator|*
name|w
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"   [%5u]   %s\n"
argument_list|,
operator|*
name|w
argument_list|,
name|re
operator|->
name|sl
index|[
operator|*
name|w
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|uint8_t
modifier|*
name|dump_unknown_tag
parameter_list|(
name|uint64_t
name|tag
parameter_list|,
name|uint8_t
modifier|*
name|p
parameter_list|,
name|uint8_t
modifier|*
name|pe
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
comment|/* 	 * According to ARM EABI: For tags> 32, even numbered tags have 	 * a ULEB128 param and odd numbered ones have NUL-terminated 	 * string param. This rule probably also applies for tags<= 32 	 * if the object arch is not ARM. 	 */
name|printf
argument_list|(
literal|"  Tag_unknown_%ju: "
argument_list|,
operator|(
name|uintmax_t
operator|)
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|&
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|_decode_uleb128
argument_list|(
operator|&
name|p
argument_list|,
name|pe
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
modifier|*
name|dump_compatibility_tag
parameter_list|(
name|uint8_t
modifier|*
name|p
parameter_list|,
name|uint8_t
modifier|*
name|pe
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
name|val
operator|=
name|_decode_uleb128
argument_list|(
operator|&
name|p
argument_list|,
name|pe
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"flag = %ju, vendor = %s\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|val
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_arm_attributes
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|uint8_t
modifier|*
name|p
parameter_list|,
name|uint8_t
modifier|*
name|pe
parameter_list|)
block|{
name|uint64_t
name|tag
decl_stmt|,
name|val
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
name|found
decl_stmt|,
name|desc
decl_stmt|;
operator|(
name|void
operator|)
name|re
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|pe
condition|)
block|{
name|tag
operator|=
name|_decode_uleb128
argument_list|(
operator|&
name|p
argument_list|,
name|pe
argument_list|)
expr_stmt|;
name|found
operator|=
name|desc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|aeabi_tags
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|aeabi_tags
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tag
operator|==
name|aeabi_tags
index|[
name|i
index|]
operator|.
name|tag
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"  %s: "
argument_list|,
name|aeabi_tags
index|[
name|i
index|]
operator|.
name|s_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|aeabi_tags
index|[
name|i
index|]
operator|.
name|get_desc
condition|)
block|{
name|desc
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|_decode_uleb128
argument_list|(
operator|&
name|p
argument_list|,
name|pe
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|aeabi_tags
index|[
name|i
index|]
operator|.
name|get_desc
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|tag
operator|<
name|aeabi_tags
index|[
name|i
index|]
operator|.
name|tag
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|p
operator|=
name|dump_unknown_tag
argument_list|(
name|tag
argument_list|,
name|p
argument_list|,
name|pe
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|desc
condition|)
continue|continue;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
literal|4
case|:
comment|/* Tag_CPU_raw_name */
case|case
literal|5
case|:
comment|/* Tag_CPU_name */
case|case
literal|67
case|:
comment|/* Tag_conformance */
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|32
case|:
comment|/* Tag_compatibility */
name|p
operator|=
name|dump_compatibility_tag
argument_list|(
name|p
argument_list|,
name|pe
argument_list|)
expr_stmt|;
break|break;
case|case
literal|64
case|:
comment|/* Tag_nodefaults */
comment|/* ignored, written as 0. */
operator|(
name|void
operator|)
name|_decode_uleb128
argument_list|(
operator|&
name|p
argument_list|,
name|pe
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"True\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|65
case|:
comment|/* Tag_also_compatible_with */
name|val
operator|=
name|_decode_uleb128
argument_list|(
operator|&
name|p
argument_list|,
name|pe
argument_list|)
expr_stmt|;
comment|/* Must be Tag_CPU_arch */
if|if
condition|(
name|val
operator|!=
literal|6
condition|)
block|{
name|printf
argument_list|(
literal|"unknown\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|val
operator|=
name|_decode_uleb128
argument_list|(
operator|&
name|p
argument_list|,
name|pe
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|aeabi_cpu_arch
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip NUL terminator. */
name|p
operator|++
expr_stmt|;
break|break;
default|default:
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|Tag_GNU_MIPS_ABI_FP
end_ifndef

begin_define
define|#
directive|define
name|Tag_GNU_MIPS_ABI_FP
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|dump_mips_attributes
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|uint8_t
modifier|*
name|p
parameter_list|,
name|uint8_t
modifier|*
name|pe
parameter_list|)
block|{
name|uint64_t
name|tag
decl_stmt|,
name|val
decl_stmt|;
operator|(
name|void
operator|)
name|re
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|pe
condition|)
block|{
name|tag
operator|=
name|_decode_uleb128
argument_list|(
operator|&
name|p
argument_list|,
name|pe
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|Tag_GNU_MIPS_ABI_FP
case|:
name|val
operator|=
name|_decode_uleb128
argument_list|(
operator|&
name|p
argument_list|,
name|pe
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Tag_GNU_MIPS_ABI_FP: %s\n"
argument_list|,
name|mips_abi_fp
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|32
case|:
comment|/* Tag_compatibility */
name|p
operator|=
name|dump_compatibility_tag
argument_list|(
name|p
argument_list|,
name|pe
argument_list|)
expr_stmt|;
break|break;
default|default:
name|p
operator|=
name|dump_unknown_tag
argument_list|(
name|tag
argument_list|,
name|p
argument_list|,
name|pe
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|Tag_GNU_Power_ABI_FP
end_ifndef

begin_define
define|#
directive|define
name|Tag_GNU_Power_ABI_FP
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|Tag_GNU_Power_ABI_Vector
end_ifndef

begin_define
define|#
directive|define
name|Tag_GNU_Power_ABI_Vector
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|dump_ppc_attributes
parameter_list|(
name|uint8_t
modifier|*
name|p
parameter_list|,
name|uint8_t
modifier|*
name|pe
parameter_list|)
block|{
name|uint64_t
name|tag
decl_stmt|,
name|val
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|pe
condition|)
block|{
name|tag
operator|=
name|_decode_uleb128
argument_list|(
operator|&
name|p
argument_list|,
name|pe
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|Tag_GNU_Power_ABI_FP
case|:
name|val
operator|=
name|_decode_uleb128
argument_list|(
operator|&
name|p
argument_list|,
name|pe
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Tag_GNU_Power_ABI_FP: %s\n"
argument_list|,
name|ppc_abi_fp
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Tag_GNU_Power_ABI_Vector
case|:
name|val
operator|=
name|_decode_uleb128
argument_list|(
operator|&
name|p
argument_list|,
name|pe
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Tag_GNU_Power_ABI_Vector: %s\n"
argument_list|,
name|ppc_abi_vector
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|32
case|:
comment|/* Tag_compatibility */
name|p
operator|=
name|dump_compatibility_tag
argument_list|(
name|p
argument_list|,
name|pe
argument_list|)
expr_stmt|;
break|break;
default|default:
name|p
operator|=
name|dump_unknown_tag
argument_list|(
name|tag
argument_list|,
name|p
argument_list|,
name|pe
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_attributes
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|Elf_Data
modifier|*
name|d
decl_stmt|;
name|uint8_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|pe
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|seclen
decl_stmt|,
name|nlen
decl_stmt|,
name|sublen
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|int
name|tag
decl_stmt|,
name|i
decl_stmt|,
name|elferr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|re
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|re
operator|->
name|sl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|!=
name|SHT_GNU_ATTRIBUTES
operator|&&
operator|(
name|re
operator|->
name|ehdr
operator|.
name|e_machine
operator|!=
name|EM_ARM
operator|||
name|s
operator|->
name|type
operator|!=
name|SHT_LOPROC
operator|+
literal|3
operator|)
condition|)
continue|continue;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|elf_rawdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_rawdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|d
operator|->
name|d_size
operator|<=
literal|0
condition|)
continue|continue;
name|p
operator|=
name|d
operator|->
name|d_buf
expr_stmt|;
name|pe
operator|=
name|p
operator|+
name|d
operator|->
name|d_size
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'A'
condition|)
block|{
name|printf
argument_list|(
literal|"Unknown Attribute Section Format: %c\n"
argument_list|,
operator|(
name|char
operator|)
operator|*
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|len
operator|=
name|d
operator|->
name|d_size
operator|-
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|<
literal|4
condition|)
block|{
name|warnx
argument_list|(
literal|"truncated attribute section length"
argument_list|)
expr_stmt|;
return|return;
block|}
name|seclen
operator|=
name|re
operator|->
name|dw_decode
argument_list|(
operator|&
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|seclen
operator|>
name|len
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid attribute section length"
argument_list|)
expr_stmt|;
return|return;
block|}
name|len
operator|-=
name|seclen
expr_stmt|;
name|nlen
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|nlen
operator|+
literal|4
operator|>
name|seclen
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid attribute section name"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"Attribute Section: %s\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|nlen
expr_stmt|;
name|seclen
operator|-=
name|nlen
operator|+
literal|4
expr_stmt|;
while|while
condition|(
name|seclen
operator|>
literal|0
condition|)
block|{
name|sp
operator|=
name|p
expr_stmt|;
name|tag
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|sublen
operator|=
name|re
operator|->
name|dw_decode
argument_list|(
operator|&
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|sublen
operator|>
name|seclen
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid attribute sub-section"
literal|" length"
argument_list|)
expr_stmt|;
return|return;
block|}
name|seclen
operator|-=
name|sublen
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|top_tag
argument_list|(
name|tag
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|==
literal|2
operator|||
name|tag
operator|==
literal|3
condition|)
block|{
name|putchar
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|val
operator|=
name|_decode_uleb128
argument_list|(
operator|&
name|p
argument_list|,
name|pe
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
break|break;
name|printf
argument_list|(
literal|" %ju"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|ehdr
operator|.
name|e_machine
operator|==
name|EM_ARM
operator|&&
name|s
operator|->
name|type
operator|==
name|SHT_LOPROC
operator|+
literal|3
condition|)
name|dump_arm_attributes
argument_list|(
name|re
argument_list|,
name|p
argument_list|,
name|sp
operator|+
name|sublen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|re
operator|->
name|ehdr
operator|.
name|e_machine
operator|==
name|EM_MIPS
operator|||
name|re
operator|->
name|ehdr
operator|.
name|e_machine
operator|==
name|EM_MIPS_RS3_LE
condition|)
name|dump_mips_attributes
argument_list|(
name|re
argument_list|,
name|p
argument_list|,
name|sp
operator|+
name|sublen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|re
operator|->
name|ehdr
operator|.
name|e_machine
operator|==
name|EM_PPC
condition|)
name|dump_ppc_attributes
argument_list|(
name|p
argument_list|,
name|sp
operator|+
name|sublen
argument_list|)
expr_stmt|;
name|p
operator|=
name|sp
operator|+
name|sublen
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_mips_specific_info
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|s
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|re
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|re
operator|->
name|sl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|name
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|".MIPS.options"
argument_list|)
operator|||
operator|(
name|s
operator|->
name|type
operator|==
name|SHT_MIPS_OPTIONS
operator|)
operator|)
condition|)
block|{
name|dump_mips_options
argument_list|(
name|re
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|s
operator|->
name|name
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|".MIPS.abiflags"
argument_list|)
operator|||
operator|(
name|s
operator|->
name|type
operator|==
name|SHT_MIPS_ABIFLAGS
operator|)
operator|)
condition|)
name|dump_mips_abiflags
argument_list|(
name|re
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Dump .reginfo if present (although it will be ignored by an OS if a 	 * .MIPS.options section is present, according to SGI mips64 spec). 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|re
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|re
operator|->
name|sl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|name
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|".reginfo"
argument_list|)
operator|||
operator|(
name|s
operator|->
name|type
operator|==
name|SHT_MIPS_REGINFO
operator|)
operator|)
condition|)
name|dump_mips_reginfo
argument_list|(
name|re
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_mips_abiflags
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
block|{
name|Elf_Data
modifier|*
name|d
decl_stmt|;
name|uint8_t
modifier|*
name|p
decl_stmt|;
name|int
name|elferr
decl_stmt|;
name|uint32_t
name|isa_ext
decl_stmt|,
name|ases
decl_stmt|,
name|flags1
decl_stmt|,
name|flags2
decl_stmt|;
name|uint16_t
name|version
decl_stmt|;
name|uint8_t
name|isa_level
decl_stmt|,
name|isa_rev
decl_stmt|,
name|gpr_size
decl_stmt|,
name|cpr1_size
decl_stmt|,
name|cpr2_size
decl_stmt|,
name|fp_abi
decl_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|elf_rawdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_rawdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|d_size
operator|!=
literal|24
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid MIPS abiflags section size"
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|=
name|d
operator|->
name|d_buf
expr_stmt|;
name|version
operator|=
name|re
operator|->
name|dw_decode
argument_list|(
operator|&
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"MIPS ABI Flags Version: %u"
argument_list|,
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" (unknown)\n\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
name|isa_level
operator|=
name|re
operator|->
name|dw_decode
argument_list|(
operator|&
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|isa_rev
operator|=
name|re
operator|->
name|dw_decode
argument_list|(
operator|&
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gpr_size
operator|=
name|re
operator|->
name|dw_decode
argument_list|(
operator|&
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cpr1_size
operator|=
name|re
operator|->
name|dw_decode
argument_list|(
operator|&
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cpr2_size
operator|=
name|re
operator|->
name|dw_decode
argument_list|(
operator|&
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fp_abi
operator|=
name|re
operator|->
name|dw_decode
argument_list|(
operator|&
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|isa_ext
operator|=
name|re
operator|->
name|dw_decode
argument_list|(
operator|&
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ases
operator|=
name|re
operator|->
name|dw_decode
argument_list|(
operator|&
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|flags1
operator|=
name|re
operator|->
name|dw_decode
argument_list|(
operator|&
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|flags2
operator|=
name|re
operator|->
name|dw_decode
argument_list|(
operator|&
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ISA: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|isa_rev
operator|<=
literal|1
condition|)
name|printf
argument_list|(
literal|"MIPS%u\n"
argument_list|,
name|isa_level
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"MIPS%ur%u\n"
argument_list|,
name|isa_level
argument_list|,
name|isa_rev
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"GPR size: %d\n"
argument_list|,
name|get_mips_register_size
argument_list|(
name|gpr_size
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"CPR1 size: %d\n"
argument_list|,
name|get_mips_register_size
argument_list|(
name|cpr1_size
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"CPR2 size: %d\n"
argument_list|,
name|get_mips_register_size
argument_list|(
name|cpr2_size
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"FP ABI: "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fp_abi
condition|)
block|{
case|case
literal|3
case|:
name|printf
argument_list|(
literal|"Soft float"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%u"
argument_list|,
name|fp_abi
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"\nISA Extension: %u\n"
argument_list|,
name|isa_ext
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ASEs: %u\n"
argument_list|,
name|ases
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"FLAGS 1: %08x\n"
argument_list|,
name|flags1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"FLAGS 2: %08x\n"
argument_list|,
name|flags2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_mips_register_size
parameter_list|(
name|uint8_t
name|flag
parameter_list|)
block|{
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|0
return|;
case|case
literal|1
case|:
return|return
literal|32
return|;
case|case
literal|2
case|:
return|return
literal|64
return|;
case|case
literal|3
case|:
return|return
literal|128
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_mips_reginfo
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
block|{
name|Elf_Data
modifier|*
name|d
decl_stmt|;
name|int
name|elferr
decl_stmt|,
name|len
decl_stmt|;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|elf_rawdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_rawdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|d_size
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|get_ent_count
argument_list|(
name|s
argument_list|,
operator|&
name|len
argument_list|)
condition|)
return|return;
name|printf
argument_list|(
literal|"\nSection '%s' contains %d entries:\n"
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dump_mips_odk_reginfo
argument_list|(
name|re
argument_list|,
name|d
operator|->
name|d_buf
argument_list|,
name|d
operator|->
name|d_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_mips_options
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|)
block|{
name|Elf_Data
modifier|*
name|d
decl_stmt|;
name|uint32_t
name|info
decl_stmt|;
name|uint16_t
name|sndx
decl_stmt|;
name|uint8_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|pe
decl_stmt|;
name|uint8_t
name|kind
decl_stmt|,
name|size
decl_stmt|;
name|int
name|elferr
decl_stmt|;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|elf_rawdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_rawdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|d_size
operator|==
literal|0
condition|)
return|return;
name|printf
argument_list|(
literal|"\nSection %s contains:\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|p
operator|=
name|d
operator|->
name|d_buf
expr_stmt|;
name|pe
operator|=
name|p
operator|+
name|d
operator|->
name|d_size
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|pe
condition|)
block|{
if|if
condition|(
name|pe
operator|-
name|p
operator|<
literal|8
condition|)
block|{
name|warnx
argument_list|(
literal|"Truncated MIPS option header"
argument_list|)
expr_stmt|;
return|return;
block|}
name|kind
operator|=
name|re
operator|->
name|dw_decode
argument_list|(
operator|&
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|size
operator|=
name|re
operator|->
name|dw_decode
argument_list|(
operator|&
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sndx
operator|=
name|re
operator|->
name|dw_decode
argument_list|(
operator|&
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|info
operator|=
name|re
operator|->
name|dw_decode
argument_list|(
operator|&
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|8
operator|||
name|size
operator|-
literal|8
operator|>
name|pe
operator|-
name|p
condition|)
block|{
name|warnx
argument_list|(
literal|"Malformed MIPS option header"
argument_list|)
expr_stmt|;
return|return;
block|}
name|size
operator|-=
literal|8
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|ODK_REGINFO
case|:
name|dump_mips_odk_reginfo
argument_list|(
name|re
argument_list|,
name|p
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODK_EXCEPTIONS
case|:
name|printf
argument_list|(
literal|" EXCEPTIONS FPU_MIN: %#x\n"
argument_list|,
name|info
operator|&
name|OEX_FPU_MIN
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%11.11s FPU_MAX: %#x\n"
argument_list|,
literal|""
argument_list|,
name|info
operator|&
name|OEX_FPU_MAX
argument_list|)
expr_stmt|;
name|dump_mips_option_flags
argument_list|(
literal|""
argument_list|,
name|mips_exceptions_option
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODK_PAD
case|:
name|printf
argument_list|(
literal|" %-10.10s section: %ju\n"
argument_list|,
literal|"OPAD"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sndx
argument_list|)
expr_stmt|;
name|dump_mips_option_flags
argument_list|(
literal|""
argument_list|,
name|mips_pad_option
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODK_HWPATCH
case|:
name|dump_mips_option_flags
argument_list|(
literal|"HWPATCH"
argument_list|,
name|mips_hwpatch_option
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODK_HWAND
case|:
name|dump_mips_option_flags
argument_list|(
literal|"HWAND"
argument_list|,
name|mips_hwa_option
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODK_HWOR
case|:
name|dump_mips_option_flags
argument_list|(
literal|"HWOR"
argument_list|,
name|mips_hwo_option
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODK_FILL
case|:
name|printf
argument_list|(
literal|" %-10.10s %#jx\n"
argument_list|,
literal|"FILL"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODK_TAGS
case|:
name|printf
argument_list|(
literal|" %-10.10s\n"
argument_list|,
literal|"TAGS"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODK_GP_GROUP
case|:
name|printf
argument_list|(
literal|" %-10.10s GP group number: %#x\n"
argument_list|,
literal|"GP_GROUP"
argument_list|,
name|info
operator|&
literal|0xFFFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|&
literal|0x10000
condition|)
name|printf
argument_list|(
literal|" %-10.10s GP group is "
literal|"self-contained\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODK_IDENT
case|:
name|printf
argument_list|(
literal|" %-10.10s default GP group number: %#x\n"
argument_list|,
literal|"IDENT"
argument_list|,
name|info
operator|&
literal|0xFFFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|&
literal|0x10000
condition|)
name|printf
argument_list|(
literal|" %-10.10s default GP group is "
literal|"self-contained\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODK_PAGESIZE
case|:
name|printf
argument_list|(
literal|" %-10.10s\n"
argument_list|,
literal|"PAGESIZE"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|p
operator|+=
name|size
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_mips_option_flags
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|mips_option
modifier|*
name|opt
parameter_list|,
name|uint64_t
name|info
parameter_list|)
block|{
name|int
name|first
decl_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
name|opt
operator|->
name|desc
operator|!=
name|NULL
condition|;
name|opt
operator|++
control|)
block|{
if|if
condition|(
name|info
operator|&
name|opt
operator|->
name|flag
condition|)
block|{
name|printf
argument_list|(
literal|" %-10.10s %s\n"
argument_list|,
name|first
condition|?
name|name
else|:
literal|""
argument_list|,
name|opt
operator|->
name|desc
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_mips_odk_reginfo
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|uint8_t
modifier|*
name|p
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
name|uint32_t
name|ri_gprmask
decl_stmt|;
name|uint32_t
name|ri_cprmask
index|[
literal|4
index|]
decl_stmt|;
name|uint64_t
name|ri_gp_value
decl_stmt|;
name|uint8_t
modifier|*
name|pe
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pe
operator|=
name|p
operator|+
name|sz
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|pe
condition|)
block|{
name|ri_gprmask
operator|=
name|re
operator|->
name|dw_decode
argument_list|(
operator|&
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Skip ri_pad padding field for mips64. */
if|if
condition|(
name|re
operator|->
name|ec
operator|==
name|ELFCLASS64
condition|)
name|re
operator|->
name|dw_decode
argument_list|(
operator|&
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|ri_cprmask
index|[
name|i
index|]
operator|=
name|re
operator|->
name|dw_decode
argument_list|(
operator|&
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|ec
operator|==
name|ELFCLASS32
condition|)
name|ri_gp_value
operator|=
name|re
operator|->
name|dw_decode
argument_list|(
operator|&
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|ri_gp_value
operator|=
name|re
operator|->
name|dw_decode
argument_list|(
operator|&
name|p
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s    "
argument_list|,
name|option_kind
argument_list|(
name|ODK_REGINFO
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ri_gprmask:    0x%08jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ri_gprmask
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%11.11s ri_cprmask[%d]: 0x%08jx\n"
argument_list|,
literal|""
argument_list|,
name|i
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ri_cprmask
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%12.12s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ri_gp_value:   %#jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ri_gp_value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_arch_specific_info
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
name|dump_liblist
argument_list|(
name|re
argument_list|)
expr_stmt|;
name|dump_attributes
argument_list|(
name|re
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|re
operator|->
name|ehdr
operator|.
name|e_machine
condition|)
block|{
case|case
name|EM_MIPS
case|:
case|case
name|EM_MIPS_RS3_LE
case|:
name|dump_mips_specific_info
argument_list|(
name|re
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_regname
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|unsigned
name|int
name|num
parameter_list|)
block|{
specifier|static
name|char
name|rx
index|[
literal|32
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|rn
decl_stmt|;
if|if
condition|(
operator|(
name|rn
operator|=
name|dwarf_reg
argument_list|(
name|re
operator|->
name|ehdr
operator|.
name|e_machine
argument_list|,
name|num
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|rn
operator|)
return|;
name|snprintf
argument_list|(
name|rx
argument_list|,
sizeof|sizeof
argument_list|(
name|rx
argument_list|)
argument_list|,
literal|"r%u"
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
operator|(
name|rx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_dwarf_line
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|Dwarf_Die
name|die
decl_stmt|;
name|Dwarf_Error
name|de
decl_stmt|;
name|Dwarf_Half
name|tag
decl_stmt|,
name|version
decl_stmt|,
name|pointer_size
decl_stmt|;
name|Dwarf_Unsigned
name|offset
decl_stmt|,
name|endoff
decl_stmt|,
name|length
decl_stmt|,
name|hdrlen
decl_stmt|,
name|dirndx
decl_stmt|,
name|mtime
decl_stmt|,
name|fsize
decl_stmt|;
name|Dwarf_Small
name|minlen
decl_stmt|,
name|defstmt
decl_stmt|,
name|lrange
decl_stmt|,
name|opbase
decl_stmt|,
name|oplen
decl_stmt|;
name|Elf_Data
modifier|*
name|d
decl_stmt|;
name|char
modifier|*
name|pn
decl_stmt|;
name|uint64_t
name|address
decl_stmt|,
name|file
decl_stmt|,
name|line
decl_stmt|,
name|column
decl_stmt|,
name|isa
decl_stmt|,
name|opsize
decl_stmt|,
name|udelta
decl_stmt|;
name|int64_t
name|sdelta
decl_stmt|;
name|uint8_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|pe
decl_stmt|;
name|int8_t
name|lbase
decl_stmt|;
name|int
name|i
decl_stmt|,
name|is_stmt
decl_stmt|,
name|dwarf_size
decl_stmt|,
name|elferr
decl_stmt|,
name|ret
decl_stmt|;
name|printf
argument_list|(
literal|"\nDump of debug contents of section .debug_line:\n"
argument_list|)
expr_stmt|;
name|s
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|re
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|re
operator|->
name|sl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|name
operator|!=
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|".debug_line"
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|size_t
operator|)
name|i
operator|>=
name|re
operator|->
name|shnum
condition|)
return|return;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|d_size
operator|<=
literal|0
condition|)
return|return;
while|while
condition|(
operator|(
name|ret
operator|=
name|dwarf_next_cu_header
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|de
argument_list|)
operator|)
operator|==
name|DW_DLV_OK
condition|)
block|{
name|die
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|dwarf_siblingof
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
name|die
argument_list|,
operator|&
name|die
argument_list|,
operator|&
name|de
argument_list|)
operator|==
name|DW_DLV_OK
condition|)
block|{
if|if
condition|(
name|dwarf_tag
argument_list|(
name|die
argument_list|,
operator|&
name|tag
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_tag failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* XXX: What about DW_TAG_partial_unit? */
if|if
condition|(
name|tag
operator|==
name|DW_TAG_compile_unit
condition|)
break|break;
block|}
if|if
condition|(
name|die
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"could not find DW_TAG_compile_unit die"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dwarf_attrval_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_stmt_list
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
continue|continue;
name|length
operator|=
name|re
operator|->
name|dw_read
argument_list|(
name|d
argument_list|,
operator|&
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0xffffffff
condition|)
block|{
name|dwarf_size
operator|=
literal|8
expr_stmt|;
name|length
operator|=
name|re
operator|->
name|dw_read
argument_list|(
name|d
argument_list|,
operator|&
name|offset
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
name|dwarf_size
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|length
operator|>
name|d
operator|->
name|d_size
operator|-
name|offset
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid .dwarf_line section"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|endoff
operator|=
name|offset
operator|+
name|length
expr_stmt|;
name|pe
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|d
operator|->
name|d_buf
operator|+
name|endoff
expr_stmt|;
name|version
operator|=
name|re
operator|->
name|dw_read
argument_list|(
name|d
argument_list|,
operator|&
name|offset
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|hdrlen
operator|=
name|re
operator|->
name|dw_read
argument_list|(
name|d
argument_list|,
operator|&
name|offset
argument_list|,
name|dwarf_size
argument_list|)
expr_stmt|;
name|minlen
operator|=
name|re
operator|->
name|dw_read
argument_list|(
name|d
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|defstmt
operator|=
name|re
operator|->
name|dw_read
argument_list|(
name|d
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lbase
operator|=
name|re
operator|->
name|dw_read
argument_list|(
name|d
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lrange
operator|=
name|re
operator|->
name|dw_read
argument_list|(
name|d
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|opbase
operator|=
name|re
operator|->
name|dw_read
argument_list|(
name|d
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Length:\t\t\t%ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|length
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  DWARF version:\t\t%u\n"
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Prologue Length:\t\t%ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|hdrlen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Minimum Instruction Length:\t%u\n"
argument_list|,
name|minlen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Initial value of 'is_stmt':\t%u\n"
argument_list|,
name|defstmt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Line Base:\t\t\t%d\n"
argument_list|,
name|lbase
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Line Range:\t\t\t%u\n"
argument_list|,
name|lrange
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Opcode Base:\t\t\t%u\n"
argument_list|,
name|opbase
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dwarf_get_address_size
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
operator|&
name|pointer_size
argument_list|,
operator|&
name|de
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  (Pointer size:\t\t%u)\n"
argument_list|,
name|pointer_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Opcodes:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|opbase
condition|;
name|i
operator|++
control|)
block|{
name|oplen
operator|=
name|re
operator|->
name|dw_read
argument_list|(
name|d
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Opcode %d has %u args\n"
argument_list|,
name|i
argument_list|,
name|oplen
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" The Directory Table:\n"
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|d
operator|->
name|d_buf
operator|+
name|offset
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"  %s\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" The File Name Table:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Entry\tDir\tTime\tSize\tName\n"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|pn
operator|=
operator|(
name|char
operator|*
operator|)
name|p
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|pn
argument_list|)
operator|+
literal|1
expr_stmt|;
name|dirndx
operator|=
name|_decode_uleb128
argument_list|(
operator|&
name|p
argument_list|,
name|pe
argument_list|)
expr_stmt|;
name|mtime
operator|=
name|_decode_uleb128
argument_list|(
operator|&
name|p
argument_list|,
name|pe
argument_list|)
expr_stmt|;
name|fsize
operator|=
name|_decode_uleb128
argument_list|(
operator|&
name|p
argument_list|,
name|pe
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %d\t%ju\t%ju\t%ju\t%s\n"
argument_list|,
name|i
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dirndx
argument_list|,
operator|(
name|uintmax_t
operator|)
name|mtime
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fsize
argument_list|,
name|pn
argument_list|)
expr_stmt|;
block|}
define|#
directive|define
name|RESET_REGISTERS
define|\
value|do {							\ 		address	       = 0;				\ 		file	       = 1;				\ 		line	       = 1;				\ 		column	       = 0;				\ 		is_stmt	       = defstmt;			\ 	} while(0)
define|#
directive|define
name|LINE
parameter_list|(
name|x
parameter_list|)
value|(lbase + (((x) - opbase) % lrange))
define|#
directive|define
name|ADDRESS
parameter_list|(
name|x
parameter_list|)
value|((((x) - opbase) / lrange) * minlen)
name|p
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Line Number Statements:\n"
argument_list|)
expr_stmt|;
name|RESET_REGISTERS
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|pe
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Extended Opcodes. 				 */
name|p
operator|++
expr_stmt|;
name|opsize
operator|=
name|_decode_uleb128
argument_list|(
operator|&
name|p
argument_list|,
name|pe
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Extended opcode %u: "
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
name|DW_LNE_end_sequence
case|:
name|p
operator|++
expr_stmt|;
name|RESET_REGISTERS
expr_stmt|;
name|printf
argument_list|(
literal|"End of Sequence\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNE_set_address
case|:
name|p
operator|++
expr_stmt|;
name|address
operator|=
name|re
operator|->
name|dw_decode
argument_list|(
operator|&
name|p
argument_list|,
name|pointer_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"set Address to %#jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|address
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNE_define_file
case|:
name|p
operator|++
expr_stmt|;
name|pn
operator|=
operator|(
name|char
operator|*
operator|)
name|p
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|pn
argument_list|)
operator|+
literal|1
expr_stmt|;
name|dirndx
operator|=
name|_decode_uleb128
argument_list|(
operator|&
name|p
argument_list|,
name|pe
argument_list|)
expr_stmt|;
name|mtime
operator|=
name|_decode_uleb128
argument_list|(
operator|&
name|p
argument_list|,
name|pe
argument_list|)
expr_stmt|;
name|fsize
operator|=
name|_decode_uleb128
argument_list|(
operator|&
name|p
argument_list|,
name|pe
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"define new file: %s\n"
argument_list|,
name|pn
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Unrecognized extened opcodes. */
name|p
operator|+=
name|opsize
expr_stmt|;
name|printf
argument_list|(
literal|"unknown opcode\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|>
literal|0
operator|&&
operator|*
name|p
operator|<
name|opbase
condition|)
block|{
comment|/* 				 * Standard Opcodes. 				 */
switch|switch
condition|(
operator|*
name|p
operator|++
condition|)
block|{
case|case
name|DW_LNS_copy
case|:
name|printf
argument_list|(
literal|"  Copy\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_advance_pc
case|:
name|udelta
operator|=
name|_decode_uleb128
argument_list|(
operator|&
name|p
argument_list|,
name|pe
argument_list|)
operator|*
name|minlen
expr_stmt|;
name|address
operator|+=
name|udelta
expr_stmt|;
name|printf
argument_list|(
literal|"  Advance PC by %ju to %#jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|udelta
argument_list|,
operator|(
name|uintmax_t
operator|)
name|address
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_advance_line
case|:
name|sdelta
operator|=
name|_decode_sleb128
argument_list|(
operator|&
name|p
argument_list|,
name|pe
argument_list|)
expr_stmt|;
name|line
operator|+=
name|sdelta
expr_stmt|;
name|printf
argument_list|(
literal|"  Advance Line by %jd to %ju\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|sdelta
argument_list|,
operator|(
name|uintmax_t
operator|)
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_set_file
case|:
name|file
operator|=
name|_decode_uleb128
argument_list|(
operator|&
name|p
argument_list|,
name|pe
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Set File to %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_set_column
case|:
name|column
operator|=
name|_decode_uleb128
argument_list|(
operator|&
name|p
argument_list|,
name|pe
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Set Column to %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|column
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_negate_stmt
case|:
name|is_stmt
operator|=
operator|!
name|is_stmt
expr_stmt|;
name|printf
argument_list|(
literal|"  Set is_stmt to %d\n"
argument_list|,
name|is_stmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_set_basic_block
case|:
name|printf
argument_list|(
literal|"  Set basic block flag\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_const_add_pc
case|:
name|address
operator|+=
name|ADDRESS
argument_list|(
literal|255
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Advance PC by constant %ju"
literal|" to %#jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ADDRESS
argument_list|(
literal|255
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|address
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_fixed_advance_pc
case|:
name|udelta
operator|=
name|re
operator|->
name|dw_decode
argument_list|(
operator|&
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|address
operator|+=
name|udelta
expr_stmt|;
name|printf
argument_list|(
literal|"  Advance PC by fixed value "
literal|"%ju to %#jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|udelta
argument_list|,
operator|(
name|uintmax_t
operator|)
name|address
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_set_prologue_end
case|:
name|printf
argument_list|(
literal|"  Set prologue end flag\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_set_epilogue_begin
case|:
name|printf
argument_list|(
literal|"  Set epilogue begin flag\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_set_isa
case|:
name|isa
operator|=
name|_decode_uleb128
argument_list|(
operator|&
name|p
argument_list|,
name|pe
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Set isa to %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|isa
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Unrecognized extended opcodes. */
name|printf
argument_list|(
literal|"  Unknown extended opcode %u\n"
argument_list|,
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* 				 * Special Opcodes. 				 */
name|line
operator|+=
name|LINE
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|address
operator|+=
name|ADDRESS
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Special opcode %u: advance Address "
literal|"by %ju to %#jx and Line by %jd to %ju\n"
argument_list|,
operator|*
name|p
operator|-
name|opbase
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ADDRESS
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|address
argument_list|,
operator|(
name|intmax_t
operator|)
name|LINE
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|line
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ret
operator|==
name|DW_DLV_ERROR
condition|)
name|warnx
argument_list|(
literal|"dwarf_next_cu_header: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|RESET_REGISTERS
undef|#
directive|undef
name|LINE
undef|#
directive|undef
name|ADDRESS
block|}
end_function

begin_function
specifier|static
name|void
name|dump_dwarf_line_decoded
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
name|Dwarf_Die
name|die
decl_stmt|;
name|Dwarf_Line
modifier|*
name|linebuf
decl_stmt|,
name|ln
decl_stmt|;
name|Dwarf_Addr
name|lineaddr
decl_stmt|;
name|Dwarf_Signed
name|linecount
decl_stmt|,
name|srccount
decl_stmt|;
name|Dwarf_Unsigned
name|lineno
decl_stmt|,
name|fn
decl_stmt|;
name|Dwarf_Error
name|de
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir
decl_stmt|,
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
modifier|*
name|srcfiles
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|printf
argument_list|(
literal|"Decoded dump of debug contents of section .debug_line:\n\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ret
operator|=
name|dwarf_next_cu_header
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|de
argument_list|)
operator|)
operator|==
name|DW_DLV_OK
condition|)
block|{
if|if
condition|(
name|dwarf_siblingof
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
name|NULL
argument_list|,
operator|&
name|die
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
continue|continue;
if|if
condition|(
name|dwarf_attrval_string
argument_list|(
name|die
argument_list|,
name|DW_AT_name
argument_list|,
operator|&
name|file
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
name|file
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dwarf_attrval_string
argument_list|(
name|die
argument_list|,
name|DW_AT_comp_dir
argument_list|,
operator|&
name|dir
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
name|dir
operator|=
name|NULL
expr_stmt|;
name|printf
argument_list|(
literal|"CU: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|&&
name|file
condition|)
name|printf
argument_list|(
literal|"%s/"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-37s %11s   %s\n"
argument_list|,
literal|"Filename"
argument_list|,
literal|"Line Number"
argument_list|,
literal|"Starting Address"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf_srclines
argument_list|(
name|die
argument_list|,
operator|&
name|linebuf
argument_list|,
operator|&
name|linecount
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
continue|continue;
if|if
condition|(
name|dwarf_srcfiles
argument_list|(
name|die
argument_list|,
operator|&
name|srcfiles
argument_list|,
operator|&
name|srccount
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|linecount
condition|;
name|i
operator|++
control|)
block|{
name|ln
operator|=
name|linebuf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|dwarf_line_srcfileno
argument_list|(
name|ln
argument_list|,
operator|&
name|fn
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
continue|continue;
if|if
condition|(
name|dwarf_lineno
argument_list|(
name|ln
argument_list|,
operator|&
name|lineno
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
continue|continue;
if|if
condition|(
name|dwarf_lineaddr
argument_list|(
name|ln
argument_list|,
operator|&
name|lineaddr
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
continue|continue;
name|printf
argument_list|(
literal|"%-37s %11ju %#18jx\n"
argument_list|,
name|basename
argument_list|(
name|srcfiles
index|[
name|fn
operator|-
literal|1
index|]
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lineno
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lineaddr
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_dwarf_die
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|Dwarf_Attribute
modifier|*
name|attr_list
decl_stmt|;
name|Dwarf_Die
name|ret_die
decl_stmt|;
name|Dwarf_Off
name|dieoff
decl_stmt|,
name|cuoff
decl_stmt|,
name|culen
decl_stmt|,
name|attroff
decl_stmt|;
name|Dwarf_Unsigned
name|ate
decl_stmt|,
name|lang
decl_stmt|,
name|v_udata
decl_stmt|,
name|v_sig
decl_stmt|;
name|Dwarf_Signed
name|attr_count
decl_stmt|,
name|v_sdata
decl_stmt|;
name|Dwarf_Off
name|v_off
decl_stmt|;
name|Dwarf_Addr
name|v_addr
decl_stmt|;
name|Dwarf_Half
name|tag
decl_stmt|,
name|attr
decl_stmt|,
name|form
decl_stmt|;
name|Dwarf_Block
modifier|*
name|v_block
decl_stmt|;
name|Dwarf_Bool
name|v_bool
decl_stmt|,
name|is_info
decl_stmt|;
name|Dwarf_Sig8
name|v_sig8
decl_stmt|;
name|Dwarf_Error
name|de
decl_stmt|;
name|Dwarf_Ptr
name|v_expr
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag_str
decl_stmt|,
modifier|*
name|attr_str
decl_stmt|,
modifier|*
name|ate_str
decl_stmt|,
modifier|*
name|lang_str
decl_stmt|;
name|char
name|unk_tag
index|[
literal|32
index|]
decl_stmt|,
name|unk_attr
index|[
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|v_str
decl_stmt|;
name|uint8_t
modifier|*
name|b
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|abc
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
name|dwarf_dieoffset
argument_list|(
name|die
argument_list|,
operator|&
name|dieoff
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_dieoffset failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cont_search
goto|;
block|}
name|printf
argument_list|(
literal|"<%d><%jx>: "
argument_list|,
name|level
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dieoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf_die_CU_offset_range
argument_list|(
name|die
argument_list|,
operator|&
name|cuoff
argument_list|,
operator|&
name|culen
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_die_CU_offset_range failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
name|cuoff
operator|=
literal|0
expr_stmt|;
block|}
name|abc
operator|=
name|dwarf_die_abbrev_code
argument_list|(
name|die
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf_tag
argument_list|(
name|die
argument_list|,
operator|&
name|tag
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_tag failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cont_search
goto|;
block|}
if|if
condition|(
name|dwarf_get_TAG_name
argument_list|(
name|tag
argument_list|,
operator|&
name|tag_str
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|snprintf
argument_list|(
name|unk_tag
argument_list|,
sizeof|sizeof
argument_list|(
name|unk_tag
argument_list|)
argument_list|,
literal|"[Unknown Tag: %#x]"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|tag_str
operator|=
name|unk_tag
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Abbrev Number: %d (%s)\n"
argument_list|,
name|abc
argument_list|,
name|tag_str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|dwarf_attrlist
argument_list|(
name|die
argument_list|,
operator|&
name|attr_list
argument_list|,
operator|&
name|attr_count
argument_list|,
operator|&
name|de
argument_list|)
operator|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
if|if
condition|(
name|ret
operator|==
name|DW_DLV_ERROR
condition|)
name|warnx
argument_list|(
literal|"dwarf_attrlist failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cont_search
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|attr_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dwarf_whatform
argument_list|(
name|attr_list
index|[
name|i
index|]
argument_list|,
operator|&
name|form
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_whatform failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dwarf_whatattr
argument_list|(
name|attr_list
index|[
name|i
index|]
argument_list|,
operator|&
name|attr
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_whatattr failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dwarf_get_AT_name
argument_list|(
name|attr
argument_list|,
operator|&
name|attr_str
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|snprintf
argument_list|(
name|unk_attr
argument_list|,
sizeof|sizeof
argument_list|(
name|unk_attr
argument_list|)
argument_list|,
literal|"[Unknown AT: %#x]"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|attr_str
operator|=
name|unk_attr
expr_stmt|;
block|}
if|if
condition|(
name|dwarf_attroffset
argument_list|(
name|attr_list
index|[
name|i
index|]
argument_list|,
operator|&
name|attroff
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_attroffset failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
name|attroff
operator|=
literal|0
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"<%jx>   %-18s: "
argument_list|,
operator|(
name|uintmax_t
operator|)
name|attroff
argument_list|,
name|attr_str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|form
condition|)
block|{
case|case
name|DW_FORM_ref_addr
case|:
case|case
name|DW_FORM_sec_offset
case|:
if|if
condition|(
name|dwarf_global_formref
argument_list|(
name|attr_list
index|[
name|i
index|]
argument_list|,
operator|&
name|v_off
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_global_formref failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|form
operator|==
name|DW_FORM_ref_addr
condition|)
name|printf
argument_list|(
literal|"<0x%jx>"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|v_off
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"0x%jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|v_off
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref1
case|:
case|case
name|DW_FORM_ref2
case|:
case|case
name|DW_FORM_ref4
case|:
case|case
name|DW_FORM_ref8
case|:
case|case
name|DW_FORM_ref_udata
case|:
if|if
condition|(
name|dwarf_formref
argument_list|(
name|attr_list
index|[
name|i
index|]
argument_list|,
operator|&
name|v_off
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_formref failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|v_off
operator|+=
name|cuoff
expr_stmt|;
name|printf
argument_list|(
literal|"<0x%jx>"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|v_off
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_addr
case|:
if|if
condition|(
name|dwarf_formaddr
argument_list|(
name|attr_list
index|[
name|i
index|]
argument_list|,
operator|&
name|v_addr
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_formaddr failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"%#jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|v_addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_data1
case|:
case|case
name|DW_FORM_data2
case|:
case|case
name|DW_FORM_data4
case|:
case|case
name|DW_FORM_data8
case|:
case|case
name|DW_FORM_udata
case|:
if|if
condition|(
name|dwarf_formudata
argument_list|(
name|attr_list
index|[
name|i
index|]
argument_list|,
operator|&
name|v_udata
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_formudata failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|attr
operator|==
name|DW_AT_high_pc
condition|)
name|printf
argument_list|(
literal|"0x%jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|v_udata
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%ju"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|v_udata
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_sdata
case|:
if|if
condition|(
name|dwarf_formsdata
argument_list|(
name|attr_list
index|[
name|i
index|]
argument_list|,
operator|&
name|v_sdata
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_formudata failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"%jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|v_sdata
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_flag
case|:
if|if
condition|(
name|dwarf_formflag
argument_list|(
name|attr_list
index|[
name|i
index|]
argument_list|,
operator|&
name|v_bool
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_formflag failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"%jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|v_bool
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_flag_present
case|:
name|putchar
argument_list|(
literal|'1'
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_string
case|:
case|case
name|DW_FORM_strp
case|:
if|if
condition|(
name|dwarf_formstring
argument_list|(
name|attr_list
index|[
name|i
index|]
argument_list|,
operator|&
name|v_str
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_formstring failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|form
operator|==
name|DW_FORM_string
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|v_str
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"(indirect string) %s"
argument_list|,
name|v_str
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_block
case|:
case|case
name|DW_FORM_block1
case|:
case|case
name|DW_FORM_block2
case|:
case|case
name|DW_FORM_block4
case|:
if|if
condition|(
name|dwarf_formblock
argument_list|(
name|attr_list
index|[
name|i
index|]
argument_list|,
operator|&
name|v_block
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_formblock failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"%ju byte block:"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|v_block
operator|->
name|bl_len
argument_list|)
expr_stmt|;
name|b
operator|=
name|v_block
operator|->
name|bl_data
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|Dwarf_Unsigned
operator|)
name|j
operator|<
name|v_block
operator|->
name|bl_len
condition|;
name|j
operator|++
control|)
name|printf
argument_list|(
literal|" %x"
argument_list|,
name|b
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t("
argument_list|)
expr_stmt|;
name|dump_dwarf_block
argument_list|(
name|re
argument_list|,
name|v_block
operator|->
name|bl_data
argument_list|,
name|v_block
operator|->
name|bl_len
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_exprloc
case|:
if|if
condition|(
name|dwarf_formexprloc
argument_list|(
name|attr_list
index|[
name|i
index|]
argument_list|,
operator|&
name|v_udata
argument_list|,
operator|&
name|v_expr
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_formexprloc failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"%ju byte block:"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|v_udata
argument_list|)
expr_stmt|;
name|b
operator|=
name|v_expr
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|Dwarf_Unsigned
operator|)
name|j
operator|<
name|v_udata
condition|;
name|j
operator|++
control|)
name|printf
argument_list|(
literal|" %x"
argument_list|,
name|b
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t("
argument_list|)
expr_stmt|;
name|dump_dwarf_block
argument_list|(
name|re
argument_list|,
name|v_expr
argument_list|,
name|v_udata
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref_sig8
case|:
if|if
condition|(
name|dwarf_formsig8
argument_list|(
name|attr_list
index|[
name|i
index|]
argument_list|,
operator|&
name|v_sig8
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_formsig8 failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|p
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|&
name|v_sig8
operator|.
name|signature
index|[
literal|0
index|]
expr_stmt|;
name|v_sig
operator|=
name|re
operator|->
name|dw_decode
argument_list|(
operator|&
name|p
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"signature: 0x%jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|v_sig
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|attr
condition|)
block|{
case|case
name|DW_AT_encoding
case|:
if|if
condition|(
name|dwarf_attrval_unsigned
argument_list|(
name|die
argument_list|,
name|attr
argument_list|,
operator|&
name|ate
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
break|break;
if|if
condition|(
name|dwarf_get_ATE_name
argument_list|(
name|ate
argument_list|,
operator|&
name|ate_str
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
name|ate_str
operator|=
literal|"DW_ATE_UNKNOWN"
expr_stmt|;
name|printf
argument_list|(
literal|"\t(%s)"
argument_list|,
operator|&
name|ate_str
index|[
name|strlen
argument_list|(
literal|"DW_ATE_"
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_language
case|:
if|if
condition|(
name|dwarf_attrval_unsigned
argument_list|(
name|die
argument_list|,
name|attr
argument_list|,
operator|&
name|lang
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
break|break;
if|if
condition|(
name|dwarf_get_LANG_name
argument_list|(
name|lang
argument_list|,
operator|&
name|lang_str
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
break|break;
name|printf
argument_list|(
literal|"\t(%s)"
argument_list|,
operator|&
name|lang_str
index|[
name|strlen
argument_list|(
literal|"DW_LANG_"
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_location
case|:
case|case
name|DW_AT_string_length
case|:
case|case
name|DW_AT_return_addr
case|:
case|case
name|DW_AT_data_member_location
case|:
case|case
name|DW_AT_frame_base
case|:
case|case
name|DW_AT_segment
case|:
case|case
name|DW_AT_static_link
case|:
case|case
name|DW_AT_use_location
case|:
case|case
name|DW_AT_vtable_elem_location
case|:
switch|switch
condition|(
name|form
condition|)
block|{
case|case
name|DW_FORM_data4
case|:
case|case
name|DW_FORM_data8
case|:
case|case
name|DW_FORM_sec_offset
case|:
name|printf
argument_list|(
literal|"\t(location list)"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
default|default:
break|break;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|cont_search
label|:
comment|/* Search children. */
name|ret
operator|=
name|dwarf_child
argument_list|(
name|die
argument_list|,
operator|&
name|ret_die
argument_list|,
operator|&
name|de
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|DW_DLV_ERROR
condition|)
name|warnx
argument_list|(
literal|"dwarf_child: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
name|DW_DLV_OK
condition|)
name|dump_dwarf_die
argument_list|(
name|re
argument_list|,
name|ret_die
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Search sibling. */
name|is_info
operator|=
name|dwarf_get_die_infotypes_flag
argument_list|(
name|die
argument_list|)
expr_stmt|;
name|ret
operator|=
name|dwarf_siblingof_b
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
name|die
argument_list|,
operator|&
name|ret_die
argument_list|,
name|is_info
argument_list|,
operator|&
name|de
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|DW_DLV_ERROR
condition|)
name|warnx
argument_list|(
literal|"dwarf_siblingof: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
name|DW_DLV_OK
condition|)
name|dump_dwarf_die
argument_list|(
name|re
argument_list|,
name|ret_die
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|dwarf_dealloc
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
name|die
argument_list|,
name|DW_DLA_DIE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_cu_context
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|Dwarf_Half
name|psize
parameter_list|,
name|Dwarf_Half
name|osize
parameter_list|,
name|Dwarf_Half
name|ver
parameter_list|)
block|{
name|re
operator|->
name|cu_psize
operator|=
name|psize
expr_stmt|;
name|re
operator|->
name|cu_osize
operator|=
name|osize
expr_stmt|;
name|re
operator|->
name|cu_ver
operator|=
name|ver
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_dwarf_info
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|Dwarf_Bool
name|is_info
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|Dwarf_Die
name|die
decl_stmt|;
name|Dwarf_Error
name|de
decl_stmt|;
name|Dwarf_Half
name|tag
decl_stmt|,
name|version
decl_stmt|,
name|pointer_size
decl_stmt|,
name|off_size
decl_stmt|;
name|Dwarf_Off
name|cu_offset
decl_stmt|,
name|cu_length
decl_stmt|;
name|Dwarf_Off
name|aboff
decl_stmt|;
name|Dwarf_Unsigned
name|typeoff
decl_stmt|;
name|Dwarf_Sig8
name|sig8
decl_stmt|;
name|Dwarf_Unsigned
name|sig
decl_stmt|;
name|uint8_t
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|sn
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|sn
operator|=
name|is_info
condition|?
literal|".debug_info"
else|:
literal|".debug_types"
expr_stmt|;
name|s
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|re
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|re
operator|->
name|sl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|name
operator|!=
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
name|sn
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|size_t
operator|)
name|i
operator|>=
name|re
operator|->
name|shnum
condition|)
return|return;
do|do
block|{
name|printf
argument_list|(
literal|"\nDump of debug contents of section %s:\n"
argument_list|,
name|sn
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ret
operator|=
name|dwarf_next_cu_header_c
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
name|is_info
argument_list|,
name|NULL
argument_list|,
operator|&
name|version
argument_list|,
operator|&
name|aboff
argument_list|,
operator|&
name|pointer_size
argument_list|,
operator|&
name|off_size
argument_list|,
name|NULL
argument_list|,
operator|&
name|sig8
argument_list|,
operator|&
name|typeoff
argument_list|,
name|NULL
argument_list|,
operator|&
name|de
argument_list|)
operator|)
operator|==
name|DW_DLV_OK
condition|)
block|{
name|set_cu_context
argument_list|(
name|re
argument_list|,
name|pointer_size
argument_list|,
name|off_size
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|die
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|dwarf_siblingof_b
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
name|die
argument_list|,
operator|&
name|die
argument_list|,
name|is_info
argument_list|,
operator|&
name|de
argument_list|)
operator|==
name|DW_DLV_OK
condition|)
block|{
if|if
condition|(
name|dwarf_tag
argument_list|(
name|die
argument_list|,
operator|&
name|tag
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_tag failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* XXX: What about DW_TAG_partial_unit? */
if|if
condition|(
operator|(
name|is_info
operator|&&
name|tag
operator|==
name|DW_TAG_compile_unit
operator|)
operator|||
operator|(
operator|!
name|is_info
operator|&&
name|tag
operator|==
name|DW_TAG_type_unit
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|die
operator|==
name|NULL
operator|&&
name|is_info
condition|)
block|{
name|warnx
argument_list|(
literal|"could not find DW_TAG_compile_unit "
literal|"die"
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|die
operator|==
name|NULL
operator|&&
operator|!
name|is_info
condition|)
block|{
name|warnx
argument_list|(
literal|"could not find DW_TAG_type_unit die"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dwarf_die_CU_offset_range
argument_list|(
name|die
argument_list|,
operator|&
name|cu_offset
argument_list|,
operator|&
name|cu_length
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_die_CU_offset failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|cu_length
operator|-=
name|off_size
operator|==
literal|4
condition|?
literal|4
else|:
literal|12
expr_stmt|;
name|sig
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|is_info
condition|)
block|{
name|p
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|&
name|sig8
operator|.
name|signature
index|[
literal|0
index|]
expr_stmt|;
name|sig
operator|=
name|re
operator|->
name|dw_decode
argument_list|(
operator|&
name|p
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n  Type Unit @ offset 0x%jx:\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|cu_offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    Length:\t\t%#jx (%d-bit)\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|cu_length
argument_list|,
name|off_size
operator|==
literal|4
condition|?
literal|32
else|:
literal|64
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    Version:\t\t%u\n"
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    Abbrev Offset:\t0x%jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|aboff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    Pointer Size:\t%u\n"
argument_list|,
name|pointer_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_info
condition|)
block|{
name|printf
argument_list|(
literal|"    Signature:\t\t0x%016jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sig
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    Type Offset:\t0x%jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|typeoff
argument_list|)
expr_stmt|;
block|}
name|dump_dwarf_die
argument_list|(
name|re
argument_list|,
name|die
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|DW_DLV_ERROR
condition|)
name|warnx
argument_list|(
literal|"dwarf_next_cu_header: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_info
condition|)
break|break;
block|}
do|while
condition|(
name|dwarf_next_types_section
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
operator|&
name|de
argument_list|)
operator|==
name|DW_DLV_OK
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_dwarf_abbrev
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
name|Dwarf_Abbrev
name|ab
decl_stmt|;
name|Dwarf_Off
name|aboff
decl_stmt|,
name|atoff
decl_stmt|;
name|Dwarf_Unsigned
name|length
decl_stmt|,
name|attr_count
decl_stmt|;
name|Dwarf_Signed
name|flag
decl_stmt|,
name|form
decl_stmt|;
name|Dwarf_Half
name|tag
decl_stmt|,
name|attr
decl_stmt|;
name|Dwarf_Error
name|de
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag_str
decl_stmt|,
modifier|*
name|attr_str
decl_stmt|,
modifier|*
name|form_str
decl_stmt|;
name|char
name|unk_tag
index|[
literal|32
index|]
decl_stmt|,
name|unk_attr
index|[
literal|32
index|]
decl_stmt|,
name|unk_form
index|[
literal|32
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|ret
decl_stmt|;
name|printf
argument_list|(
literal|"\nContents of section .debug_abbrev:\n\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ret
operator|=
name|dwarf_next_cu_header
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|aboff
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|de
argument_list|)
operator|)
operator|==
name|DW_DLV_OK
condition|)
block|{
name|printf
argument_list|(
literal|"  Number TAG\n"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ret
operator|=
name|dwarf_get_abbrev
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
name|aboff
argument_list|,
operator|&
name|ab
argument_list|,
operator|&
name|length
argument_list|,
operator|&
name|attr_count
argument_list|,
operator|&
name|de
argument_list|)
operator|)
operator|==
name|DW_DLV_OK
condition|)
block|{
if|if
condition|(
name|length
operator|==
literal|1
condition|)
block|{
name|dwarf_dealloc
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
name|ab
argument_list|,
name|DW_DLA_ABBREV
argument_list|)
expr_stmt|;
break|break;
block|}
name|aboff
operator|+=
name|length
expr_stmt|;
name|printf
argument_list|(
literal|"%4d"
argument_list|,
operator|++
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf_get_abbrev_tag
argument_list|(
name|ab
argument_list|,
operator|&
name|tag
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_get_abbrev_tag failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|next_abbrev
goto|;
block|}
if|if
condition|(
name|dwarf_get_TAG_name
argument_list|(
name|tag
argument_list|,
operator|&
name|tag_str
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|snprintf
argument_list|(
name|unk_tag
argument_list|,
sizeof|sizeof
argument_list|(
name|unk_tag
argument_list|)
argument_list|,
literal|"[Unknown Tag: %#x]"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|tag_str
operator|=
name|unk_tag
expr_stmt|;
block|}
if|if
condition|(
name|dwarf_get_abbrev_children_flag
argument_list|(
name|ab
argument_list|,
operator|&
name|flag
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_get_abbrev_children_flag failed:"
literal|" %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|next_abbrev
goto|;
block|}
name|printf
argument_list|(
literal|"      %s    %s\n"
argument_list|,
name|tag_str
argument_list|,
name|flag
condition|?
literal|"[has children]"
else|:
literal|"[no children]"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|Dwarf_Unsigned
operator|)
name|j
operator|<
name|attr_count
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|dwarf_get_abbrev_entry
argument_list|(
name|ab
argument_list|,
operator|(
name|Dwarf_Signed
operator|)
name|j
argument_list|,
operator|&
name|attr
argument_list|,
operator|&
name|form
argument_list|,
operator|&
name|atoff
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_get_abbrev_entry failed:"
literal|" %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dwarf_get_AT_name
argument_list|(
name|attr
argument_list|,
operator|&
name|attr_str
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|snprintf
argument_list|(
name|unk_attr
argument_list|,
sizeof|sizeof
argument_list|(
name|unk_attr
argument_list|)
argument_list|,
literal|"[Unknown AT: %#x]"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|attr_str
operator|=
name|unk_attr
expr_stmt|;
block|}
if|if
condition|(
name|dwarf_get_FORM_name
argument_list|(
name|form
argument_list|,
operator|&
name|form_str
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|snprintf
argument_list|(
name|unk_form
argument_list|,
sizeof|sizeof
argument_list|(
name|unk_form
argument_list|)
argument_list|,
literal|"[Unknown Form: %#x]"
argument_list|,
operator|(
name|Dwarf_Half
operator|)
name|form
argument_list|)
expr_stmt|;
name|form_str
operator|=
name|unk_form
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"    %-18s %s\n"
argument_list|,
name|attr_str
argument_list|,
name|form_str
argument_list|)
expr_stmt|;
block|}
name|next_abbrev
label|:
name|dwarf_dealloc
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
name|ab
argument_list|,
name|DW_DLA_ABBREV
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|!=
name|DW_DLV_OK
condition|)
name|warnx
argument_list|(
literal|"dwarf_get_abbrev: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|DW_DLV_ERROR
condition|)
name|warnx
argument_list|(
literal|"dwarf_next_cu_header: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_dwarf_pubnames
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|Dwarf_Off
name|die_off
decl_stmt|;
name|Dwarf_Unsigned
name|offset
decl_stmt|,
name|length
decl_stmt|,
name|nt_cu_offset
decl_stmt|,
name|nt_cu_length
decl_stmt|;
name|Dwarf_Signed
name|cnt
decl_stmt|;
name|Dwarf_Global
modifier|*
name|globs
decl_stmt|;
name|Dwarf_Half
name|nt_version
decl_stmt|;
name|Dwarf_Error
name|de
decl_stmt|;
name|Elf_Data
modifier|*
name|d
decl_stmt|;
name|char
modifier|*
name|glob_name
decl_stmt|;
name|int
name|i
decl_stmt|,
name|dwarf_size
decl_stmt|,
name|elferr
decl_stmt|;
name|printf
argument_list|(
literal|"\nContents of the .debug_pubnames section:\n"
argument_list|)
expr_stmt|;
name|s
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|re
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|re
operator|->
name|sl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|name
operator|!=
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|".debug_pubnames"
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|size_t
operator|)
name|i
operator|>=
name|re
operator|->
name|shnum
condition|)
return|return;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|d_size
operator|<=
literal|0
condition|)
return|return;
comment|/* Read in .debug_pubnames section table header. */
name|offset
operator|=
literal|0
expr_stmt|;
name|length
operator|=
name|re
operator|->
name|dw_read
argument_list|(
name|d
argument_list|,
operator|&
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0xffffffff
condition|)
block|{
name|dwarf_size
operator|=
literal|8
expr_stmt|;
name|length
operator|=
name|re
operator|->
name|dw_read
argument_list|(
name|d
argument_list|,
operator|&
name|offset
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
name|dwarf_size
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|length
operator|>
name|d
operator|->
name|d_size
operator|-
name|offset
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid .dwarf_pubnames section"
argument_list|)
expr_stmt|;
return|return;
block|}
name|nt_version
operator|=
name|re
operator|->
name|dw_read
argument_list|(
name|d
argument_list|,
operator|&
name|offset
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|nt_cu_offset
operator|=
name|re
operator|->
name|dw_read
argument_list|(
name|d
argument_list|,
operator|&
name|offset
argument_list|,
name|dwarf_size
argument_list|)
expr_stmt|;
name|nt_cu_length
operator|=
name|re
operator|->
name|dw_read
argument_list|(
name|d
argument_list|,
operator|&
name|offset
argument_list|,
name|dwarf_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Length:\t\t\t\t%ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|length
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Version:\t\t\t\t%u\n"
argument_list|,
name|nt_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Offset into .debug_info section:\t%ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|nt_cu_offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Size of area in .debug_info section:\t%ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|nt_cu_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf_get_globals
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
operator|&
name|globs
argument_list|,
operator|&
name|cnt
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_get_globals failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"\n    Offset      Name\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dwarf_globname
argument_list|(
name|globs
index|[
name|i
index|]
argument_list|,
operator|&
name|glob_name
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_globname failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dwarf_global_die_offset
argument_list|(
name|globs
index|[
name|i
index|]
argument_list|,
operator|&
name|die_off
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_global_die_offset failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"    %-11ju %s\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|die_off
argument_list|,
name|glob_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_dwarf_aranges
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|Dwarf_Arange
modifier|*
name|aranges
decl_stmt|;
name|Dwarf_Addr
name|start
decl_stmt|;
name|Dwarf_Unsigned
name|offset
decl_stmt|,
name|length
decl_stmt|,
name|as_cu_offset
decl_stmt|;
name|Dwarf_Off
name|die_off
decl_stmt|;
name|Dwarf_Signed
name|cnt
decl_stmt|;
name|Dwarf_Half
name|as_version
decl_stmt|,
name|as_addrsz
decl_stmt|,
name|as_segsz
decl_stmt|;
name|Dwarf_Error
name|de
decl_stmt|;
name|Elf_Data
modifier|*
name|d
decl_stmt|;
name|int
name|i
decl_stmt|,
name|dwarf_size
decl_stmt|,
name|elferr
decl_stmt|;
name|printf
argument_list|(
literal|"\nContents of section .debug_aranges:\n"
argument_list|)
expr_stmt|;
name|s
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|re
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|re
operator|->
name|sl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|name
operator|!=
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|".debug_aranges"
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|size_t
operator|)
name|i
operator|>=
name|re
operator|->
name|shnum
condition|)
return|return;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|d_size
operator|<=
literal|0
condition|)
return|return;
comment|/* Read in the .debug_aranges section table header. */
name|offset
operator|=
literal|0
expr_stmt|;
name|length
operator|=
name|re
operator|->
name|dw_read
argument_list|(
name|d
argument_list|,
operator|&
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0xffffffff
condition|)
block|{
name|dwarf_size
operator|=
literal|8
expr_stmt|;
name|length
operator|=
name|re
operator|->
name|dw_read
argument_list|(
name|d
argument_list|,
operator|&
name|offset
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
name|dwarf_size
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|length
operator|>
name|d
operator|->
name|d_size
operator|-
name|offset
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid .dwarf_aranges section"
argument_list|)
expr_stmt|;
return|return;
block|}
name|as_version
operator|=
name|re
operator|->
name|dw_read
argument_list|(
name|d
argument_list|,
operator|&
name|offset
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|as_cu_offset
operator|=
name|re
operator|->
name|dw_read
argument_list|(
name|d
argument_list|,
operator|&
name|offset
argument_list|,
name|dwarf_size
argument_list|)
expr_stmt|;
name|as_addrsz
operator|=
name|re
operator|->
name|dw_read
argument_list|(
name|d
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|as_segsz
operator|=
name|re
operator|->
name|dw_read
argument_list|(
name|d
argument_list|,
operator|&
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Length:\t\t\t%ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|length
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Version:\t\t\t%u\n"
argument_list|,
name|as_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Offset into .debug_info:\t%ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|as_cu_offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Pointer Size:\t\t\t%u\n"
argument_list|,
name|as_addrsz
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Segment Size:\t\t\t%u\n"
argument_list|,
name|as_segsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf_get_aranges
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
operator|&
name|aranges
argument_list|,
operator|&
name|cnt
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_get_aranges failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"\n    Address  Length\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dwarf_get_arange_info
argument_list|(
name|aranges
index|[
name|i
index|]
argument_list|,
operator|&
name|start
argument_list|,
operator|&
name|length
argument_list|,
operator|&
name|die_off
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_get_arange_info failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"    %08jx %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|start
argument_list|,
operator|(
name|uintmax_t
operator|)
name|length
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_dwarf_ranges_foreach
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|,
name|Dwarf_Addr
name|base
parameter_list|)
block|{
name|Dwarf_Attribute
modifier|*
name|attr_list
decl_stmt|;
name|Dwarf_Ranges
modifier|*
name|ranges
decl_stmt|;
name|Dwarf_Die
name|ret_die
decl_stmt|;
name|Dwarf_Error
name|de
decl_stmt|;
name|Dwarf_Addr
name|base0
decl_stmt|;
name|Dwarf_Half
name|attr
decl_stmt|;
name|Dwarf_Signed
name|attr_count
decl_stmt|,
name|cnt
decl_stmt|;
name|Dwarf_Unsigned
name|off
decl_stmt|,
name|bytecnt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|dwarf_attrlist
argument_list|(
name|die
argument_list|,
operator|&
name|attr_list
argument_list|,
operator|&
name|attr_count
argument_list|,
operator|&
name|de
argument_list|)
operator|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
if|if
condition|(
name|ret
operator|==
name|DW_DLV_ERROR
condition|)
name|warnx
argument_list|(
literal|"dwarf_attrlist failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cont_search
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|attr_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dwarf_whatattr
argument_list|(
name|attr_list
index|[
name|i
index|]
argument_list|,
operator|&
name|attr
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_whatattr failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|attr
operator|!=
name|DW_AT_ranges
condition|)
continue|continue;
if|if
condition|(
name|dwarf_formudata
argument_list|(
name|attr_list
index|[
name|i
index|]
argument_list|,
operator|&
name|off
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_formudata failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dwarf_get_ranges
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
operator|(
name|Dwarf_Off
operator|)
name|off
argument_list|,
operator|&
name|ranges
argument_list|,
operator|&
name|cnt
argument_list|,
operator|&
name|bytecnt
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
continue|continue;
name|base0
operator|=
name|base
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|cnt
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"    %08jx "
argument_list|,
operator|(
name|uintmax_t
operator|)
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|ranges
index|[
name|j
index|]
operator|.
name|dwr_type
operator|==
name|DW_RANGES_END
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
literal|"<End of list>"
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ranges
index|[
name|j
index|]
operator|.
name|dwr_type
operator|==
name|DW_RANGES_ADDRESS_SELECTION
condition|)
block|{
name|base0
operator|=
name|ranges
index|[
name|j
index|]
operator|.
name|dwr_addr2
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|re
operator|->
name|ec
operator|==
name|ELFCLASS32
condition|)
name|printf
argument_list|(
literal|"%08jx %08jx\n"
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
name|ranges
index|[
name|j
index|]
operator|.
name|dwr_addr1
operator|+
name|base0
argument_list|)
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
name|ranges
index|[
name|j
index|]
operator|.
name|dwr_addr2
operator|+
name|base0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%016jx %016jx\n"
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
name|ranges
index|[
name|j
index|]
operator|.
name|dwr_addr1
operator|+
name|base0
argument_list|)
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
name|ranges
index|[
name|j
index|]
operator|.
name|dwr_addr2
operator|+
name|base0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|cont_search
label|:
comment|/* Search children. */
name|ret
operator|=
name|dwarf_child
argument_list|(
name|die
argument_list|,
operator|&
name|ret_die
argument_list|,
operator|&
name|de
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|DW_DLV_ERROR
condition|)
name|warnx
argument_list|(
literal|"dwarf_child: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
name|DW_DLV_OK
condition|)
name|dump_dwarf_ranges_foreach
argument_list|(
name|re
argument_list|,
name|ret_die
argument_list|,
name|base
argument_list|)
expr_stmt|;
comment|/* Search sibling. */
name|ret
operator|=
name|dwarf_siblingof
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
name|die
argument_list|,
operator|&
name|ret_die
argument_list|,
operator|&
name|de
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|DW_DLV_ERROR
condition|)
name|warnx
argument_list|(
literal|"dwarf_siblingof: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
name|DW_DLV_OK
condition|)
name|dump_dwarf_ranges_foreach
argument_list|(
name|re
argument_list|,
name|ret_die
argument_list|,
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_dwarf_ranges
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
name|Dwarf_Ranges
modifier|*
name|ranges
decl_stmt|;
name|Dwarf_Die
name|die
decl_stmt|;
name|Dwarf_Signed
name|cnt
decl_stmt|;
name|Dwarf_Unsigned
name|bytecnt
decl_stmt|;
name|Dwarf_Half
name|tag
decl_stmt|;
name|Dwarf_Error
name|de
decl_stmt|;
name|Dwarf_Unsigned
name|lowpc
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|dwarf_get_ranges
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
literal|0
argument_list|,
operator|&
name|ranges
argument_list|,
operator|&
name|cnt
argument_list|,
operator|&
name|bytecnt
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
return|return;
name|printf
argument_list|(
literal|"Contents of the .debug_ranges section:\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|ec
operator|==
name|ELFCLASS32
condition|)
name|printf
argument_list|(
literal|"    %-8s %-8s %s\n"
argument_list|,
literal|"Offset"
argument_list|,
literal|"Begin"
argument_list|,
literal|"End"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"    %-8s %-16s %s\n"
argument_list|,
literal|"Offset"
argument_list|,
literal|"Begin"
argument_list|,
literal|"End"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ret
operator|=
name|dwarf_next_cu_header
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|de
argument_list|)
operator|)
operator|==
name|DW_DLV_OK
condition|)
block|{
name|die
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dwarf_siblingof
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
name|die
argument_list|,
operator|&
name|die
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
continue|continue;
if|if
condition|(
name|dwarf_tag
argument_list|(
name|die
argument_list|,
operator|&
name|tag
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_tag failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* XXX: What about DW_TAG_partial_unit? */
name|lowpc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|DW_TAG_compile_unit
condition|)
block|{
if|if
condition|(
name|dwarf_attrval_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_low_pc
argument_list|,
operator|&
name|lowpc
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
name|lowpc
operator|=
literal|0
expr_stmt|;
block|}
name|dump_dwarf_ranges_foreach
argument_list|(
name|re
argument_list|,
name|die
argument_list|,
operator|(
name|Dwarf_Addr
operator|)
name|lowpc
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_dwarf_macinfo
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
name|Dwarf_Unsigned
name|offset
decl_stmt|;
name|Dwarf_Signed
name|cnt
decl_stmt|;
name|Dwarf_Macro_Details
modifier|*
name|md
decl_stmt|;
name|Dwarf_Error
name|de
decl_stmt|;
specifier|const
name|char
modifier|*
name|mi_str
decl_stmt|;
name|char
name|unk_mi
index|[
literal|32
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
define|#
directive|define
name|_MAX_MACINFO_ENTRY
value|65535
name|printf
argument_list|(
literal|"\nContents of section .debug_macinfo:\n\n"
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|dwarf_get_macro_details
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
name|offset
argument_list|,
name|_MAX_MACINFO_ENTRY
argument_list|,
operator|&
name|cnt
argument_list|,
operator|&
name|md
argument_list|,
operator|&
name|de
argument_list|)
operator|==
name|DW_DLV_OK
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|offset
operator|=
name|md
index|[
name|i
index|]
operator|.
name|dmd_offset
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|md
index|[
name|i
index|]
operator|.
name|dmd_type
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|dwarf_get_MACINFO_name
argument_list|(
name|md
index|[
name|i
index|]
operator|.
name|dmd_type
argument_list|,
operator|&
name|mi_str
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|snprintf
argument_list|(
name|unk_mi
argument_list|,
sizeof|sizeof
argument_list|(
name|unk_mi
argument_list|)
argument_list|,
literal|"[Unknown MACINFO: %#x]"
argument_list|,
name|md
index|[
name|i
index|]
operator|.
name|dmd_type
argument_list|)
expr_stmt|;
name|mi_str
operator|=
name|unk_mi
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|mi_str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|md
index|[
name|i
index|]
operator|.
name|dmd_type
condition|)
block|{
case|case
name|DW_MACINFO_define
case|:
case|case
name|DW_MACINFO_undef
case|:
name|printf
argument_list|(
literal|" - lineno : %jd macro : %s\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|md
index|[
name|i
index|]
operator|.
name|dmd_lineno
argument_list|,
name|md
index|[
name|i
index|]
operator|.
name|dmd_macro
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_MACINFO_start_file
case|:
name|printf
argument_list|(
literal|" - lineno : %jd filenum : %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|md
index|[
name|i
index|]
operator|.
name|dmd_lineno
argument_list|,
operator|(
name|intmax_t
operator|)
name|md
index|[
name|i
index|]
operator|.
name|dmd_fileindex
argument_list|)
expr_stmt|;
break|break;
default|default:
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
undef|#
directive|undef
name|_MAX_MACINFO_ENTRY
block|}
end_function

begin_function
specifier|static
name|void
name|dump_dwarf_frame_inst
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|Dwarf_Cie
name|cie
parameter_list|,
name|uint8_t
modifier|*
name|insts
parameter_list|,
name|Dwarf_Unsigned
name|len
parameter_list|,
name|Dwarf_Unsigned
name|caf
parameter_list|,
name|Dwarf_Signed
name|daf
parameter_list|,
name|Dwarf_Addr
name|pc
parameter_list|,
name|Dwarf_Debug
name|dbg
parameter_list|)
block|{
name|Dwarf_Frame_Op
modifier|*
name|oplist
decl_stmt|;
name|Dwarf_Signed
name|opcnt
decl_stmt|,
name|delta
decl_stmt|;
name|Dwarf_Small
name|op
decl_stmt|;
name|Dwarf_Error
name|de
decl_stmt|;
specifier|const
name|char
modifier|*
name|op_str
decl_stmt|;
name|char
name|unk_op
index|[
literal|32
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dwarf_expand_frame_instructions
argument_list|(
name|cie
argument_list|,
name|insts
argument_list|,
name|len
argument_list|,
operator|&
name|oplist
argument_list|,
operator|&
name|opcnt
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_expand_frame_instructions failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opcnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|oplist
index|[
name|i
index|]
operator|.
name|fp_base_op
operator|!=
literal|0
condition|)
name|op
operator|=
name|oplist
index|[
name|i
index|]
operator|.
name|fp_base_op
operator|<<
literal|6
expr_stmt|;
else|else
name|op
operator|=
name|oplist
index|[
name|i
index|]
operator|.
name|fp_extended_op
expr_stmt|;
if|if
condition|(
name|dwarf_get_CFA_name
argument_list|(
name|op
argument_list|,
operator|&
name|op_str
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|snprintf
argument_list|(
name|unk_op
argument_list|,
sizeof|sizeof
argument_list|(
name|unk_op
argument_list|)
argument_list|,
literal|"[Unknown CFA: %#x]"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|op_str
operator|=
name|unk_op
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  %s"
argument_list|,
name|op_str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DW_CFA_advance_loc
case|:
name|delta
operator|=
name|oplist
index|[
name|i
index|]
operator|.
name|fp_offset
operator|*
name|caf
expr_stmt|;
name|pc
operator|+=
name|delta
expr_stmt|;
name|printf
argument_list|(
literal|": %ju to %08jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|delta
argument_list|,
operator|(
name|uintmax_t
operator|)
name|pc
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_offset
case|:
case|case
name|DW_CFA_offset_extended
case|:
case|case
name|DW_CFA_offset_extended_sf
case|:
name|delta
operator|=
name|oplist
index|[
name|i
index|]
operator|.
name|fp_offset
operator|*
name|daf
expr_stmt|;
name|printf
argument_list|(
literal|": r%u (%s) at cfa%+jd"
argument_list|,
name|oplist
index|[
name|i
index|]
operator|.
name|fp_register
argument_list|,
name|dwarf_regname
argument_list|(
name|re
argument_list|,
name|oplist
index|[
name|i
index|]
operator|.
name|fp_register
argument_list|)
argument_list|,
operator|(
name|intmax_t
operator|)
name|delta
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_restore
case|:
name|printf
argument_list|(
literal|": r%u (%s)"
argument_list|,
name|oplist
index|[
name|i
index|]
operator|.
name|fp_register
argument_list|,
name|dwarf_regname
argument_list|(
name|re
argument_list|,
name|oplist
index|[
name|i
index|]
operator|.
name|fp_register
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_set_loc
case|:
name|pc
operator|=
name|oplist
index|[
name|i
index|]
operator|.
name|fp_offset
expr_stmt|;
name|printf
argument_list|(
literal|": to %08jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|pc
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc1
case|:
case|case
name|DW_CFA_advance_loc2
case|:
case|case
name|DW_CFA_advance_loc4
case|:
name|pc
operator|+=
name|oplist
index|[
name|i
index|]
operator|.
name|fp_offset
expr_stmt|;
name|printf
argument_list|(
literal|": %jd to %08jx"
argument_list|,
operator|(
name|intmax_t
operator|)
name|oplist
index|[
name|i
index|]
operator|.
name|fp_offset
argument_list|,
operator|(
name|uintmax_t
operator|)
name|pc
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa
case|:
name|printf
argument_list|(
literal|": r%u (%s) ofs %ju"
argument_list|,
name|oplist
index|[
name|i
index|]
operator|.
name|fp_register
argument_list|,
name|dwarf_regname
argument_list|(
name|re
argument_list|,
name|oplist
index|[
name|i
index|]
operator|.
name|fp_register
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|oplist
index|[
name|i
index|]
operator|.
name|fp_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_sf
case|:
name|printf
argument_list|(
literal|": r%u (%s) ofs %jd"
argument_list|,
name|oplist
index|[
name|i
index|]
operator|.
name|fp_register
argument_list|,
name|dwarf_regname
argument_list|(
name|re
argument_list|,
name|oplist
index|[
name|i
index|]
operator|.
name|fp_register
argument_list|)
argument_list|,
call|(
name|intmax_t
call|)
argument_list|(
name|oplist
index|[
name|i
index|]
operator|.
name|fp_offset
operator|*
name|daf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_register
case|:
name|printf
argument_list|(
literal|": r%u (%s)"
argument_list|,
name|oplist
index|[
name|i
index|]
operator|.
name|fp_register
argument_list|,
name|dwarf_regname
argument_list|(
name|re
argument_list|,
name|oplist
index|[
name|i
index|]
operator|.
name|fp_register
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_offset
case|:
name|printf
argument_list|(
literal|": %ju"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|oplist
index|[
name|i
index|]
operator|.
name|fp_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_offset_sf
case|:
name|printf
argument_list|(
literal|": %jd"
argument_list|,
call|(
name|intmax_t
call|)
argument_list|(
name|oplist
index|[
name|i
index|]
operator|.
name|fp_offset
operator|*
name|daf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|dwarf_dealloc
argument_list|(
name|dbg
argument_list|,
name|oplist
argument_list|,
name|DW_DLA_FRAME_BLOCK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_regoff_str
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|Dwarf_Half
name|reg
parameter_list|,
name|Dwarf_Addr
name|off
parameter_list|)
block|{
specifier|static
name|char
name|rs
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
name|reg
operator|==
name|DW_FRAME_UNDEFINED_VAL
operator|||
name|reg
operator|==
name|DW_FRAME_REG_INITIAL_VALUE
condition|)
name|snprintf
argument_list|(
name|rs
argument_list|,
sizeof|sizeof
argument_list|(
name|rs
argument_list|)
argument_list|,
literal|"%c"
argument_list|,
literal|'u'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|==
name|DW_FRAME_CFA_COL
condition|)
name|snprintf
argument_list|(
name|rs
argument_list|,
sizeof|sizeof
argument_list|(
name|rs
argument_list|)
argument_list|,
literal|"c%+jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|off
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|rs
argument_list|,
sizeof|sizeof
argument_list|(
name|rs
argument_list|)
argument_list|,
literal|"%s%+jd"
argument_list|,
name|dwarf_regname
argument_list|(
name|re
argument_list|,
name|reg
argument_list|)
argument_list|,
operator|(
name|intmax_t
operator|)
name|off
argument_list|)
expr_stmt|;
return|return
operator|(
name|rs
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dump_dwarf_frame_regtable
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|Dwarf_Fde
name|fde
parameter_list|,
name|Dwarf_Addr
name|pc
parameter_list|,
name|Dwarf_Unsigned
name|func_len
parameter_list|,
name|Dwarf_Half
name|cie_ra
parameter_list|)
block|{
name|Dwarf_Regtable
name|rt
decl_stmt|;
name|Dwarf_Addr
name|row_pc
decl_stmt|,
name|end_pc
decl_stmt|,
name|pre_pc
decl_stmt|,
name|cur_pc
decl_stmt|;
name|Dwarf_Error
name|de
decl_stmt|;
name|char
modifier|*
name|vec
decl_stmt|;
name|int
name|i
decl_stmt|;
define|#
directive|define
name|BIT_SET
parameter_list|(
name|v
parameter_list|,
name|n
parameter_list|)
value|(v[(n)>>3] |= 1U<< ((n)& 7))
define|#
directive|define
name|BIT_CLR
parameter_list|(
name|v
parameter_list|,
name|n
parameter_list|)
value|(v[(n)>>3]&= ~(1U<< ((n)& 7)))
define|#
directive|define
name|BIT_ISSET
parameter_list|(
name|v
parameter_list|,
name|n
parameter_list|)
value|(v[(n)>>3]& (1U<< ((n)& 7)))
define|#
directive|define
name|RT
parameter_list|(
name|x
parameter_list|)
value|rt.rules[(x)]
name|vec
operator|=
name|calloc
argument_list|(
operator|(
name|DW_REG_TABLE_SIZE
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|vec
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
name|pre_pc
operator|=
operator|~
operator|(
operator|(
name|Dwarf_Addr
operator|)
literal|0
operator|)
expr_stmt|;
name|cur_pc
operator|=
name|pc
expr_stmt|;
name|end_pc
operator|=
name|pc
operator|+
name|func_len
expr_stmt|;
for|for
control|(
init|;
name|cur_pc
operator|<
name|end_pc
condition|;
name|cur_pc
operator|++
control|)
block|{
if|if
condition|(
name|dwarf_get_fde_info_for_all_regs
argument_list|(
name|fde
argument_list|,
name|cur_pc
argument_list|,
operator|&
name|rt
argument_list|,
operator|&
name|row_pc
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_get_fde_info_for_all_regs failed: %s\n"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|row_pc
operator|==
name|pre_pc
condition|)
continue|continue;
name|pre_pc
operator|=
name|row_pc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|DW_REG_TABLE_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rt
operator|.
name|rules
index|[
name|i
index|]
operator|.
name|dw_regnum
operator|!=
name|DW_FRAME_REG_INITIAL_VALUE
condition|)
name|BIT_SET
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"   LOC   CFA      "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|DW_REG_TABLE_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|BIT_ISSET
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|Dwarf_Half
operator|)
name|i
operator|==
name|cie_ra
condition|)
name|printf
argument_list|(
literal|"ra   "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%-5s"
argument_list|,
name|dwarf_regname
argument_list|(
name|re
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|pre_pc
operator|=
operator|~
operator|(
operator|(
name|Dwarf_Addr
operator|)
literal|0
operator|)
expr_stmt|;
name|cur_pc
operator|=
name|pc
expr_stmt|;
name|end_pc
operator|=
name|pc
operator|+
name|func_len
expr_stmt|;
for|for
control|(
init|;
name|cur_pc
operator|<
name|end_pc
condition|;
name|cur_pc
operator|++
control|)
block|{
if|if
condition|(
name|dwarf_get_fde_info_for_all_regs
argument_list|(
name|fde
argument_list|,
name|cur_pc
argument_list|,
operator|&
name|rt
argument_list|,
operator|&
name|row_pc
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_get_fde_info_for_all_regs failed: %s\n"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|row_pc
operator|==
name|pre_pc
condition|)
continue|continue;
name|pre_pc
operator|=
name|row_pc
expr_stmt|;
name|printf
argument_list|(
literal|"%08jx "
argument_list|,
operator|(
name|uintmax_t
operator|)
name|row_pc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-8s "
argument_list|,
name|get_regoff_str
argument_list|(
name|re
argument_list|,
name|RT
argument_list|(
literal|0
argument_list|)
operator|.
name|dw_regnum
argument_list|,
name|RT
argument_list|(
literal|0
argument_list|)
operator|.
name|dw_offset
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|DW_REG_TABLE_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|BIT_ISSET
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%-5s"
argument_list|,
name|get_regoff_str
argument_list|(
name|re
argument_list|,
name|RT
argument_list|(
name|i
argument_list|)
operator|.
name|dw_regnum
argument_list|,
name|RT
argument_list|(
name|i
argument_list|)
operator|.
name|dw_offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|vec
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
undef|#
directive|undef
name|BIT_SET
undef|#
directive|undef
name|BIT_CLR
undef|#
directive|undef
name|BIT_ISSET
undef|#
directive|undef
name|RT
block|}
end_function

begin_function
specifier|static
name|void
name|dump_dwarf_frame_section
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|struct
name|section
modifier|*
name|s
parameter_list|,
name|int
name|alt
parameter_list|)
block|{
name|Dwarf_Cie
modifier|*
name|cie_list
decl_stmt|,
name|cie
decl_stmt|,
name|pre_cie
decl_stmt|;
name|Dwarf_Fde
modifier|*
name|fde_list
decl_stmt|,
name|fde
decl_stmt|;
name|Dwarf_Off
name|cie_offset
decl_stmt|,
name|fde_offset
decl_stmt|;
name|Dwarf_Unsigned
name|cie_length
decl_stmt|,
name|fde_instlen
decl_stmt|;
name|Dwarf_Unsigned
name|cie_caf
decl_stmt|,
name|cie_daf
decl_stmt|,
name|cie_instlen
decl_stmt|,
name|func_len
decl_stmt|,
name|fde_length
decl_stmt|;
name|Dwarf_Signed
name|cie_count
decl_stmt|,
name|fde_count
decl_stmt|,
name|cie_index
decl_stmt|;
name|Dwarf_Addr
name|low_pc
decl_stmt|;
name|Dwarf_Half
name|cie_ra
decl_stmt|;
name|Dwarf_Small
name|cie_version
decl_stmt|;
name|Dwarf_Ptr
name|fde_addr
decl_stmt|,
name|fde_inst
decl_stmt|,
name|cie_inst
decl_stmt|;
name|char
modifier|*
name|cie_aug
decl_stmt|,
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|eh_frame
decl_stmt|;
name|Dwarf_Error
name|de
decl_stmt|;
name|printf
argument_list|(
literal|"\nThe section %s contains:\n\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|".debug_frame"
argument_list|)
condition|)
block|{
name|eh_frame
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dwarf_get_fde_list
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
operator|&
name|cie_list
argument_list|,
operator|&
name|cie_count
argument_list|,
operator|&
name|fde_list
argument_list|,
operator|&
name|fde_count
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_get_fde_list failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|".eh_frame"
argument_list|)
condition|)
block|{
name|eh_frame
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dwarf_get_fde_list_eh
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
operator|&
name|cie_list
argument_list|,
operator|&
name|cie_count
argument_list|,
operator|&
name|fde_list
argument_list|,
operator|&
name|fde_count
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_get_fde_list_eh failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
return|return;
name|pre_cie
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fde_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dwarf_get_fde_n
argument_list|(
name|fde_list
argument_list|,
name|i
argument_list|,
operator|&
name|fde
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_get_fde_n failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dwarf_get_cie_of_fde
argument_list|(
name|fde
argument_list|,
operator|&
name|cie
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_get_fde_n failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dwarf_get_fde_range
argument_list|(
name|fde
argument_list|,
operator|&
name|low_pc
argument_list|,
operator|&
name|func_len
argument_list|,
operator|&
name|fde_addr
argument_list|,
operator|&
name|fde_length
argument_list|,
operator|&
name|cie_offset
argument_list|,
operator|&
name|cie_index
argument_list|,
operator|&
name|fde_offset
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_get_fde_range failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dwarf_get_fde_instr_bytes
argument_list|(
name|fde
argument_list|,
operator|&
name|fde_inst
argument_list|,
operator|&
name|fde_instlen
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_get_fde_instr_bytes failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pre_cie
operator|==
name|NULL
operator|||
name|cie
operator|!=
name|pre_cie
condition|)
block|{
name|pre_cie
operator|=
name|cie
expr_stmt|;
if|if
condition|(
name|dwarf_get_cie_info
argument_list|(
name|cie
argument_list|,
operator|&
name|cie_length
argument_list|,
operator|&
name|cie_version
argument_list|,
operator|&
name|cie_aug
argument_list|,
operator|&
name|cie_caf
argument_list|,
operator|&
name|cie_daf
argument_list|,
operator|&
name|cie_ra
argument_list|,
operator|&
name|cie_inst
argument_list|,
operator|&
name|cie_instlen
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_get_cie_info failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"%08jx %08jx %8.8jx CIE"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|cie_offset
argument_list|,
operator|(
name|uintmax_t
operator|)
name|cie_length
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
name|eh_frame
condition|?
literal|0
else|:
operator|~
literal|0U
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|alt
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Version:\t\t\t%u\n"
argument_list|,
name|cie_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Augmentation:\t\t\t\""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|cie_aug
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Code alignment factor:\t%ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|cie_caf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Data alignment factor:\t%jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|cie_daf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Return address column:\t%ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|cie_ra
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|dump_dwarf_frame_inst
argument_list|(
name|re
argument_list|,
name|cie
argument_list|,
name|cie_inst
argument_list|,
name|cie_instlen
argument_list|,
name|cie_caf
argument_list|,
name|cie_daf
argument_list|,
literal|0
argument_list|,
name|re
operator|->
name|dbg
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" \""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|cie_aug
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" cf=%ju df=%jd ra=%ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|cie_caf
argument_list|,
operator|(
name|uintmax_t
operator|)
name|cie_daf
argument_list|,
operator|(
name|uintmax_t
operator|)
name|cie_ra
argument_list|)
expr_stmt|;
name|dump_dwarf_frame_regtable
argument_list|(
name|re
argument_list|,
name|fde
argument_list|,
name|low_pc
argument_list|,
literal|1
argument_list|,
name|cie_ra
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"%08jx %08jx %08jx FDE cie=%08jx pc=%08jx..%08jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fde_offset
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fde_length
argument_list|,
operator|(
name|uintmax_t
operator|)
name|cie_offset
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
name|eh_frame
condition|?
name|fde_offset
operator|+
literal|4
operator|-
name|cie_offset
else|:
name|cie_offset
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|low_pc
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
name|low_pc
operator|+
name|func_len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|alt
condition|)
name|dump_dwarf_frame_inst
argument_list|(
name|re
argument_list|,
name|cie
argument_list|,
name|fde_inst
argument_list|,
name|fde_instlen
argument_list|,
name|cie_caf
argument_list|,
name|cie_daf
argument_list|,
name|low_pc
argument_list|,
name|re
operator|->
name|dbg
argument_list|)
expr_stmt|;
else|else
name|dump_dwarf_frame_regtable
argument_list|(
name|re
argument_list|,
name|fde
argument_list|,
name|low_pc
argument_list|,
name|func_len
argument_list|,
name|cie_ra
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_dwarf_frame
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|int
name|alt
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|dwarf_set_frame_cfa_value
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
name|DW_FRAME_CFA_COL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|re
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|re
operator|->
name|sl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|name
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|".debug_frame"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|".eh_frame"
argument_list|)
operator|)
condition|)
name|dump_dwarf_frame_section
argument_list|(
name|re
argument_list|,
name|s
argument_list|,
name|alt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_dwarf_str
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|Elf_Data
modifier|*
name|d
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|elferr
decl_stmt|,
name|end
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|printf
argument_list|(
literal|"\nContents of section .debug_str:\n"
argument_list|)
expr_stmt|;
name|s
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|re
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|re
operator|->
name|sl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|name
operator|!=
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|".debug_str"
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|size_t
operator|)
name|i
operator|>=
name|re
operator|->
name|shnum
condition|)
return|return;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|d_size
operator|<=
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|d
operator|->
name|d_buf
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|d
operator|->
name|d_size
condition|;
name|i
operator|+=
literal|16
control|)
block|{
name|printf
argument_list|(
literal|"  0x%08x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|i
operator|+
literal|16
operator|>
name|d
operator|->
name|d_size
condition|)
name|end
operator|=
name|d
operator|->
name|d_size
expr_stmt|;
else|else
name|end
operator|=
name|i
operator|+
literal|16
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|i
operator|+
literal|16
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|j
operator|-
name|i
operator|)
operator|%
literal|4
operator|==
literal|0
condition|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|end
condition|)
block|{
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"%02x"
argument_list|,
operator|(
name|uint8_t
operator|)
name|p
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|end
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|isprint
argument_list|(
name|p
index|[
name|j
index|]
argument_list|)
condition|)
name|putchar
argument_list|(
name|p
index|[
name|j
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
name|j
index|]
operator|==
literal|0
condition|)
name|putchar
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_struct
struct|struct
name|loc_at
block|{
name|Dwarf_Attribute
name|la_at
decl_stmt|;
name|Dwarf_Unsigned
name|la_off
decl_stmt|;
name|Dwarf_Unsigned
name|la_lowpc
decl_stmt|;
name|Dwarf_Half
name|la_cu_psize
decl_stmt|;
name|Dwarf_Half
name|la_cu_osize
decl_stmt|;
name|Dwarf_Half
name|la_cu_ver
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|loc_at
argument_list|)
name|la_next
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|loc_at
argument_list|)
name|lalist
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|lalist
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|search_loclist_at
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|Dwarf_Die
name|die
parameter_list|,
name|Dwarf_Unsigned
name|lowpc
parameter_list|)
block|{
name|Dwarf_Attribute
modifier|*
name|attr_list
decl_stmt|;
name|Dwarf_Die
name|ret_die
decl_stmt|;
name|Dwarf_Unsigned
name|off
decl_stmt|;
name|Dwarf_Off
name|ref
decl_stmt|;
name|Dwarf_Signed
name|attr_count
decl_stmt|;
name|Dwarf_Half
name|attr
decl_stmt|,
name|form
decl_stmt|;
name|Dwarf_Bool
name|is_info
decl_stmt|;
name|Dwarf_Error
name|de
decl_stmt|;
name|struct
name|loc_at
modifier|*
name|la
decl_stmt|,
modifier|*
name|nla
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|is_info
operator|=
name|dwarf_get_die_infotypes_flag
argument_list|(
name|die
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|dwarf_attrlist
argument_list|(
name|die
argument_list|,
operator|&
name|attr_list
argument_list|,
operator|&
name|attr_count
argument_list|,
operator|&
name|de
argument_list|)
operator|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
if|if
condition|(
name|ret
operator|==
name|DW_DLV_ERROR
condition|)
name|warnx
argument_list|(
literal|"dwarf_attrlist failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cont_search
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|attr_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dwarf_whatattr
argument_list|(
name|attr_list
index|[
name|i
index|]
argument_list|,
operator|&
name|attr
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_whatattr failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|attr
operator|!=
name|DW_AT_location
operator|&&
name|attr
operator|!=
name|DW_AT_string_length
operator|&&
name|attr
operator|!=
name|DW_AT_return_addr
operator|&&
name|attr
operator|!=
name|DW_AT_data_member_location
operator|&&
name|attr
operator|!=
name|DW_AT_frame_base
operator|&&
name|attr
operator|!=
name|DW_AT_segment
operator|&&
name|attr
operator|!=
name|DW_AT_static_link
operator|&&
name|attr
operator|!=
name|DW_AT_use_location
operator|&&
name|attr
operator|!=
name|DW_AT_vtable_elem_location
condition|)
continue|continue;
if|if
condition|(
name|dwarf_whatform
argument_list|(
name|attr_list
index|[
name|i
index|]
argument_list|,
operator|&
name|form
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_whatform failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|form
operator|==
name|DW_FORM_data4
operator|||
name|form
operator|==
name|DW_FORM_data8
condition|)
block|{
if|if
condition|(
name|dwarf_formudata
argument_list|(
name|attr_list
index|[
name|i
index|]
argument_list|,
operator|&
name|off
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_formudata failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|form
operator|==
name|DW_FORM_sec_offset
condition|)
block|{
if|if
condition|(
name|dwarf_global_formref
argument_list|(
name|attr_list
index|[
name|i
index|]
argument_list|,
operator|&
name|ref
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_global_formref failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|off
operator|=
name|ref
expr_stmt|;
block|}
else|else
continue|continue;
name|TAILQ_FOREACH
argument_list|(
argument|la
argument_list|,
argument|&lalist
argument_list|,
argument|la_next
argument_list|)
block|{
if|if
condition|(
name|off
operator|==
name|la
operator|->
name|la_off
condition|)
break|break;
if|if
condition|(
name|off
operator|<
name|la
operator|->
name|la_off
condition|)
block|{
if|if
condition|(
operator|(
name|nla
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|nla
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|nla
operator|->
name|la_at
operator|=
name|attr_list
index|[
name|i
index|]
expr_stmt|;
name|nla
operator|->
name|la_off
operator|=
name|off
expr_stmt|;
name|nla
operator|->
name|la_lowpc
operator|=
name|lowpc
expr_stmt|;
name|nla
operator|->
name|la_cu_psize
operator|=
name|re
operator|->
name|cu_psize
expr_stmt|;
name|nla
operator|->
name|la_cu_osize
operator|=
name|re
operator|->
name|cu_osize
expr_stmt|;
name|nla
operator|->
name|la_cu_ver
operator|=
name|re
operator|->
name|cu_ver
expr_stmt|;
name|TAILQ_INSERT_BEFORE
argument_list|(
name|la
argument_list|,
name|nla
argument_list|,
name|la_next
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|la
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|nla
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|nla
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|nla
operator|->
name|la_at
operator|=
name|attr_list
index|[
name|i
index|]
expr_stmt|;
name|nla
operator|->
name|la_off
operator|=
name|off
expr_stmt|;
name|nla
operator|->
name|la_lowpc
operator|=
name|lowpc
expr_stmt|;
name|nla
operator|->
name|la_cu_psize
operator|=
name|re
operator|->
name|cu_psize
expr_stmt|;
name|nla
operator|->
name|la_cu_osize
operator|=
name|re
operator|->
name|cu_osize
expr_stmt|;
name|nla
operator|->
name|la_cu_ver
operator|=
name|re
operator|->
name|cu_ver
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|lalist
argument_list|,
name|nla
argument_list|,
name|la_next
argument_list|)
expr_stmt|;
block|}
block|}
name|cont_search
label|:
comment|/* Search children. */
name|ret
operator|=
name|dwarf_child
argument_list|(
name|die
argument_list|,
operator|&
name|ret_die
argument_list|,
operator|&
name|de
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|DW_DLV_ERROR
condition|)
name|warnx
argument_list|(
literal|"dwarf_child: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
name|DW_DLV_OK
condition|)
name|search_loclist_at
argument_list|(
name|re
argument_list|,
name|ret_die
argument_list|,
name|lowpc
argument_list|)
expr_stmt|;
comment|/* Search sibling. */
name|ret
operator|=
name|dwarf_siblingof_b
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
name|die
argument_list|,
operator|&
name|ret_die
argument_list|,
name|is_info
argument_list|,
operator|&
name|de
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|DW_DLV_ERROR
condition|)
name|warnx
argument_list|(
literal|"dwarf_siblingof: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
name|DW_DLV_OK
condition|)
name|search_loclist_at
argument_list|(
name|re
argument_list|,
name|ret_die
argument_list|,
name|lowpc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_dwarf_loc
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|Dwarf_Loc
modifier|*
name|lr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|op_str
decl_stmt|;
name|char
name|unk_op
index|[
literal|32
index|]
decl_stmt|;
name|uint8_t
modifier|*
name|b
decl_stmt|,
name|n
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dwarf_get_OP_name
argument_list|(
name|lr
operator|->
name|lr_atom
argument_list|,
operator|&
name|op_str
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|snprintf
argument_list|(
name|unk_op
argument_list|,
sizeof|sizeof
argument_list|(
name|unk_op
argument_list|)
argument_list|,
literal|"[Unknown OP: %#x]"
argument_list|,
name|lr
operator|->
name|lr_atom
argument_list|)
expr_stmt|;
name|op_str
operator|=
name|unk_op
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|op_str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lr
operator|->
name|lr_atom
condition|)
block|{
case|case
name|DW_OP_reg0
case|:
case|case
name|DW_OP_reg1
case|:
case|case
name|DW_OP_reg2
case|:
case|case
name|DW_OP_reg3
case|:
case|case
name|DW_OP_reg4
case|:
case|case
name|DW_OP_reg5
case|:
case|case
name|DW_OP_reg6
case|:
case|case
name|DW_OP_reg7
case|:
case|case
name|DW_OP_reg8
case|:
case|case
name|DW_OP_reg9
case|:
case|case
name|DW_OP_reg10
case|:
case|case
name|DW_OP_reg11
case|:
case|case
name|DW_OP_reg12
case|:
case|case
name|DW_OP_reg13
case|:
case|case
name|DW_OP_reg14
case|:
case|case
name|DW_OP_reg15
case|:
case|case
name|DW_OP_reg16
case|:
case|case
name|DW_OP_reg17
case|:
case|case
name|DW_OP_reg18
case|:
case|case
name|DW_OP_reg19
case|:
case|case
name|DW_OP_reg20
case|:
case|case
name|DW_OP_reg21
case|:
case|case
name|DW_OP_reg22
case|:
case|case
name|DW_OP_reg23
case|:
case|case
name|DW_OP_reg24
case|:
case|case
name|DW_OP_reg25
case|:
case|case
name|DW_OP_reg26
case|:
case|case
name|DW_OP_reg27
case|:
case|case
name|DW_OP_reg28
case|:
case|case
name|DW_OP_reg29
case|:
case|case
name|DW_OP_reg30
case|:
case|case
name|DW_OP_reg31
case|:
name|printf
argument_list|(
literal|" (%s)"
argument_list|,
name|dwarf_regname
argument_list|(
name|re
argument_list|,
name|lr
operator|->
name|lr_atom
operator|-
name|DW_OP_reg0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_deref
case|:
case|case
name|DW_OP_lit0
case|:
case|case
name|DW_OP_lit1
case|:
case|case
name|DW_OP_lit2
case|:
case|case
name|DW_OP_lit3
case|:
case|case
name|DW_OP_lit4
case|:
case|case
name|DW_OP_lit5
case|:
case|case
name|DW_OP_lit6
case|:
case|case
name|DW_OP_lit7
case|:
case|case
name|DW_OP_lit8
case|:
case|case
name|DW_OP_lit9
case|:
case|case
name|DW_OP_lit10
case|:
case|case
name|DW_OP_lit11
case|:
case|case
name|DW_OP_lit12
case|:
case|case
name|DW_OP_lit13
case|:
case|case
name|DW_OP_lit14
case|:
case|case
name|DW_OP_lit15
case|:
case|case
name|DW_OP_lit16
case|:
case|case
name|DW_OP_lit17
case|:
case|case
name|DW_OP_lit18
case|:
case|case
name|DW_OP_lit19
case|:
case|case
name|DW_OP_lit20
case|:
case|case
name|DW_OP_lit21
case|:
case|case
name|DW_OP_lit22
case|:
case|case
name|DW_OP_lit23
case|:
case|case
name|DW_OP_lit24
case|:
case|case
name|DW_OP_lit25
case|:
case|case
name|DW_OP_lit26
case|:
case|case
name|DW_OP_lit27
case|:
case|case
name|DW_OP_lit28
case|:
case|case
name|DW_OP_lit29
case|:
case|case
name|DW_OP_lit30
case|:
case|case
name|DW_OP_lit31
case|:
case|case
name|DW_OP_dup
case|:
case|case
name|DW_OP_drop
case|:
case|case
name|DW_OP_over
case|:
case|case
name|DW_OP_swap
case|:
case|case
name|DW_OP_rot
case|:
case|case
name|DW_OP_xderef
case|:
case|case
name|DW_OP_abs
case|:
case|case
name|DW_OP_and
case|:
case|case
name|DW_OP_div
case|:
case|case
name|DW_OP_minus
case|:
case|case
name|DW_OP_mod
case|:
case|case
name|DW_OP_mul
case|:
case|case
name|DW_OP_neg
case|:
case|case
name|DW_OP_not
case|:
case|case
name|DW_OP_or
case|:
case|case
name|DW_OP_plus
case|:
case|case
name|DW_OP_shl
case|:
case|case
name|DW_OP_shr
case|:
case|case
name|DW_OP_shra
case|:
case|case
name|DW_OP_xor
case|:
case|case
name|DW_OP_eq
case|:
case|case
name|DW_OP_ge
case|:
case|case
name|DW_OP_gt
case|:
case|case
name|DW_OP_le
case|:
case|case
name|DW_OP_lt
case|:
case|case
name|DW_OP_ne
case|:
case|case
name|DW_OP_nop
case|:
case|case
name|DW_OP_push_object_address
case|:
case|case
name|DW_OP_form_tls_address
case|:
case|case
name|DW_OP_call_frame_cfa
case|:
case|case
name|DW_OP_stack_value
case|:
case|case
name|DW_OP_GNU_push_tls_address
case|:
case|case
name|DW_OP_GNU_uninit
case|:
break|break;
case|case
name|DW_OP_const1u
case|:
case|case
name|DW_OP_pick
case|:
case|case
name|DW_OP_deref_size
case|:
case|case
name|DW_OP_xderef_size
case|:
case|case
name|DW_OP_const2u
case|:
case|case
name|DW_OP_bra
case|:
case|case
name|DW_OP_skip
case|:
case|case
name|DW_OP_const4u
case|:
case|case
name|DW_OP_const8u
case|:
case|case
name|DW_OP_constu
case|:
case|case
name|DW_OP_plus_uconst
case|:
case|case
name|DW_OP_regx
case|:
case|case
name|DW_OP_piece
case|:
name|printf
argument_list|(
literal|": %ju"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lr
operator|->
name|lr_number
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_const1s
case|:
case|case
name|DW_OP_const2s
case|:
case|case
name|DW_OP_const4s
case|:
case|case
name|DW_OP_const8s
case|:
case|case
name|DW_OP_consts
case|:
name|printf
argument_list|(
literal|": %jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|lr
operator|->
name|lr_number
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_breg0
case|:
case|case
name|DW_OP_breg1
case|:
case|case
name|DW_OP_breg2
case|:
case|case
name|DW_OP_breg3
case|:
case|case
name|DW_OP_breg4
case|:
case|case
name|DW_OP_breg5
case|:
case|case
name|DW_OP_breg6
case|:
case|case
name|DW_OP_breg7
case|:
case|case
name|DW_OP_breg8
case|:
case|case
name|DW_OP_breg9
case|:
case|case
name|DW_OP_breg10
case|:
case|case
name|DW_OP_breg11
case|:
case|case
name|DW_OP_breg12
case|:
case|case
name|DW_OP_breg13
case|:
case|case
name|DW_OP_breg14
case|:
case|case
name|DW_OP_breg15
case|:
case|case
name|DW_OP_breg16
case|:
case|case
name|DW_OP_breg17
case|:
case|case
name|DW_OP_breg18
case|:
case|case
name|DW_OP_breg19
case|:
case|case
name|DW_OP_breg20
case|:
case|case
name|DW_OP_breg21
case|:
case|case
name|DW_OP_breg22
case|:
case|case
name|DW_OP_breg23
case|:
case|case
name|DW_OP_breg24
case|:
case|case
name|DW_OP_breg25
case|:
case|case
name|DW_OP_breg26
case|:
case|case
name|DW_OP_breg27
case|:
case|case
name|DW_OP_breg28
case|:
case|case
name|DW_OP_breg29
case|:
case|case
name|DW_OP_breg30
case|:
case|case
name|DW_OP_breg31
case|:
name|printf
argument_list|(
literal|" (%s): %jd"
argument_list|,
name|dwarf_regname
argument_list|(
name|re
argument_list|,
name|lr
operator|->
name|lr_atom
operator|-
name|DW_OP_breg0
argument_list|)
argument_list|,
operator|(
name|intmax_t
operator|)
name|lr
operator|->
name|lr_number
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_fbreg
case|:
name|printf
argument_list|(
literal|": %jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|lr
operator|->
name|lr_number
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_bregx
case|:
name|printf
argument_list|(
literal|": %ju (%s) %jd"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lr
operator|->
name|lr_number
argument_list|,
name|dwarf_regname
argument_list|(
name|re
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|lr
operator|->
name|lr_number
argument_list|)
argument_list|,
operator|(
name|intmax_t
operator|)
name|lr
operator|->
name|lr_number2
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_addr
case|:
case|case
name|DW_OP_GNU_encoded_addr
case|:
name|printf
argument_list|(
literal|": %#jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lr
operator|->
name|lr_number
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_GNU_implicit_pointer
case|:
name|printf
argument_list|(
literal|":<0x%jx> %jd"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lr
operator|->
name|lr_number
argument_list|,
operator|(
name|intmax_t
operator|)
name|lr
operator|->
name|lr_number2
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_implicit_value
case|:
name|printf
argument_list|(
literal|": %ju byte block:"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lr
operator|->
name|lr_number
argument_list|)
expr_stmt|;
name|b
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|lr
operator|->
name|lr_number2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|Dwarf_Unsigned
operator|)
name|i
operator|<
name|lr
operator|->
name|lr_number
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %x"
argument_list|,
name|b
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_GNU_entry_value
case|:
name|printf
argument_list|(
literal|": ("
argument_list|)
expr_stmt|;
name|dump_dwarf_block
argument_list|(
name|re
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|lr
operator|->
name|lr_number2
argument_list|,
name|lr
operator|->
name|lr_number
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_GNU_const_type
case|:
name|printf
argument_list|(
literal|":<0x%jx> "
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lr
operator|->
name|lr_number
argument_list|)
expr_stmt|;
name|b
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|lr
operator|->
name|lr_number2
expr_stmt|;
name|n
operator|=
operator|*
name|b
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|(
name|uint8_t
operator|)
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %x"
argument_list|,
name|b
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_GNU_regval_type
case|:
name|printf
argument_list|(
literal|": %ju (%s)<0x%jx>"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lr
operator|->
name|lr_number
argument_list|,
name|dwarf_regname
argument_list|(
name|re
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|lr
operator|->
name|lr_number
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lr
operator|->
name|lr_number2
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_GNU_convert
case|:
case|case
name|DW_OP_GNU_deref_type
case|:
case|case
name|DW_OP_GNU_parameter_ref
case|:
case|case
name|DW_OP_GNU_reinterpret
case|:
name|printf
argument_list|(
literal|":<0x%jx>"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lr
operator|->
name|lr_number
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_dwarf_block
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|uint8_t
modifier|*
name|b
parameter_list|,
name|Dwarf_Unsigned
name|len
parameter_list|)
block|{
name|Dwarf_Locdesc
modifier|*
name|llbuf
decl_stmt|;
name|Dwarf_Signed
name|lcnt
decl_stmt|;
name|Dwarf_Error
name|de
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dwarf_loclist_from_expr_b
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
name|b
argument_list|,
name|len
argument_list|,
name|re
operator|->
name|cu_psize
argument_list|,
name|re
operator|->
name|cu_osize
argument_list|,
name|re
operator|->
name|cu_ver
argument_list|,
operator|&
name|llbuf
argument_list|,
operator|&
name|lcnt
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_loclist_form_expr_b: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|Dwarf_Half
operator|)
name|i
operator|<
name|llbuf
operator|->
name|ld_cents
condition|;
name|i
operator|++
control|)
block|{
name|dump_dwarf_loc
argument_list|(
name|re
argument_list|,
operator|&
name|llbuf
operator|->
name|ld_s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|llbuf
operator|->
name|ld_cents
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"; "
argument_list|)
expr_stmt|;
block|}
name|dwarf_dealloc
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
name|llbuf
operator|->
name|ld_s
argument_list|,
name|DW_DLA_LOC_BLOCK
argument_list|)
expr_stmt|;
name|dwarf_dealloc
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
name|llbuf
argument_list|,
name|DW_DLA_LOCDESC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_dwarf_loclist
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
name|Dwarf_Die
name|die
decl_stmt|;
name|Dwarf_Locdesc
modifier|*
modifier|*
name|llbuf
decl_stmt|;
name|Dwarf_Unsigned
name|lowpc
decl_stmt|;
name|Dwarf_Signed
name|lcnt
decl_stmt|;
name|Dwarf_Half
name|tag
decl_stmt|,
name|version
decl_stmt|,
name|pointer_size
decl_stmt|,
name|off_size
decl_stmt|;
name|Dwarf_Error
name|de
decl_stmt|;
name|struct
name|loc_at
modifier|*
name|la
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|ret
decl_stmt|,
name|has_content
decl_stmt|;
comment|/* Search .debug_info section. */
while|while
condition|(
operator|(
name|ret
operator|=
name|dwarf_next_cu_header_b
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
name|NULL
argument_list|,
operator|&
name|version
argument_list|,
name|NULL
argument_list|,
operator|&
name|pointer_size
argument_list|,
operator|&
name|off_size
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|de
argument_list|)
operator|)
operator|==
name|DW_DLV_OK
condition|)
block|{
name|set_cu_context
argument_list|(
name|re
argument_list|,
name|pointer_size
argument_list|,
name|off_size
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|die
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dwarf_siblingof
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
name|die
argument_list|,
operator|&
name|die
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
continue|continue;
if|if
condition|(
name|dwarf_tag
argument_list|(
name|die
argument_list|,
operator|&
name|tag
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_tag failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* XXX: What about DW_TAG_partial_unit? */
name|lowpc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|DW_TAG_compile_unit
condition|)
block|{
if|if
condition|(
name|dwarf_attrval_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_low_pc
argument_list|,
operator|&
name|lowpc
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
name|lowpc
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Search attributes for reference to .debug_loc section. */
name|search_loclist_at
argument_list|(
name|re
argument_list|,
name|die
argument_list|,
name|lowpc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|DW_DLV_ERROR
condition|)
name|warnx
argument_list|(
literal|"dwarf_next_cu_header: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Search .debug_types section. */
do|do
block|{
while|while
condition|(
operator|(
name|ret
operator|=
name|dwarf_next_cu_header_c
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|version
argument_list|,
name|NULL
argument_list|,
operator|&
name|pointer_size
argument_list|,
operator|&
name|off_size
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|de
argument_list|)
operator|)
operator|==
name|DW_DLV_OK
condition|)
block|{
name|set_cu_context
argument_list|(
name|re
argument_list|,
name|pointer_size
argument_list|,
name|off_size
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|die
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dwarf_siblingof
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
name|die
argument_list|,
operator|&
name|die
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
continue|continue;
if|if
condition|(
name|dwarf_tag
argument_list|(
name|die
argument_list|,
operator|&
name|tag
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"dwarf_tag failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|lowpc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|DW_TAG_type_unit
condition|)
block|{
if|if
condition|(
name|dwarf_attrval_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_low_pc
argument_list|,
operator|&
name|lowpc
argument_list|,
operator|&
name|de
argument_list|)
operator|!=
name|DW_DLV_OK
condition|)
name|lowpc
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 			 * Search attributes for reference to .debug_loc 			 * section. 			 */
name|search_loclist_at
argument_list|(
name|re
argument_list|,
name|die
argument_list|,
name|lowpc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|DW_DLV_ERROR
condition|)
name|warnx
argument_list|(
literal|"dwarf_next_cu_header: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|dwarf_next_types_section
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
operator|&
name|de
argument_list|)
operator|==
name|DW_DLV_OK
condition|)
do|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|lalist
argument_list|)
condition|)
return|return;
name|has_content
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|la
argument_list|,
argument|&lalist
argument_list|,
argument|la_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|dwarf_loclist_n
argument_list|(
name|la
operator|->
name|la_at
argument_list|,
operator|&
name|llbuf
argument_list|,
operator|&
name|lcnt
argument_list|,
operator|&
name|de
argument_list|)
operator|)
operator|!=
name|DW_DLV_OK
condition|)
block|{
if|if
condition|(
name|ret
operator|!=
name|DW_DLV_NO_ENTRY
condition|)
name|warnx
argument_list|(
literal|"dwarf_loclist_n failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|has_content
condition|)
block|{
name|has_content
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"\nContents of section .debug_loc:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    Offset   Begin    End      Expression\n"
argument_list|)
expr_stmt|;
block|}
name|set_cu_context
argument_list|(
name|re
argument_list|,
name|la
operator|->
name|la_cu_psize
argument_list|,
name|la
operator|->
name|la_cu_osize
argument_list|,
name|la
operator|->
name|la_cu_ver
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lcnt
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"    %8.8jx "
argument_list|,
operator|(
name|uintmax_t
operator|)
name|la
operator|->
name|la_off
argument_list|)
expr_stmt|;
if|if
condition|(
name|llbuf
index|[
name|i
index|]
operator|->
name|ld_lopc
operator|==
literal|0
operator|&&
name|llbuf
index|[
name|i
index|]
operator|->
name|ld_hipc
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"<End of list>\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* TODO: handle base selection entry. */
name|printf
argument_list|(
literal|"%8.8jx %8.8jx "
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
name|la
operator|->
name|la_lowpc
operator|+
name|llbuf
index|[
name|i
index|]
operator|->
name|ld_lopc
argument_list|)
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
name|la
operator|->
name|la_lowpc
operator|+
name|llbuf
index|[
name|i
index|]
operator|->
name|ld_hipc
argument_list|)
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|Dwarf_Half
operator|)
name|j
operator|<
name|llbuf
index|[
name|i
index|]
operator|->
name|ld_cents
condition|;
name|j
operator|++
control|)
block|{
name|dump_dwarf_loc
argument_list|(
name|re
argument_list|,
operator|&
name|llbuf
index|[
name|i
index|]
operator|->
name|ld_s
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|llbuf
index|[
name|i
index|]
operator|->
name|ld_cents
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"; "
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|llbuf
index|[
name|i
index|]
operator|->
name|ld_lopc
operator|==
name|llbuf
index|[
name|i
index|]
operator|->
name|ld_hipc
condition|)
name|printf
argument_list|(
literal|" (start == end)"
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lcnt
condition|;
name|i
operator|++
control|)
block|{
name|dwarf_dealloc
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
name|llbuf
index|[
name|i
index|]
operator|->
name|ld_s
argument_list|,
name|DW_DLA_LOC_BLOCK
argument_list|)
expr_stmt|;
name|dwarf_dealloc
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
name|llbuf
index|[
name|i
index|]
argument_list|,
name|DW_DLA_LOCDESC
argument_list|)
expr_stmt|;
block|}
name|dwarf_dealloc
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
name|llbuf
argument_list|,
name|DW_DLA_LIST
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|has_content
condition|)
name|printf
argument_list|(
literal|"\nSection '.debug_loc' has no debugging data.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Retrieve a string using string table section index and the string offset.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_string
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|int
name|strtab
parameter_list|,
name|size_t
name|off
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|(
name|name
operator|=
name|elf_strptr
argument_list|(
name|re
operator|->
name|elf
argument_list|,
name|strtab
argument_list|,
name|off
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|""
operator|)
return|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve the name of a symbol using the section index of the symbol  * table and the index of the symbol within that table.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_symbol_name
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|int
name|symtab
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|GElf_Sym
name|sym
decl_stmt|;
name|Elf_Data
modifier|*
name|data
decl_stmt|;
name|int
name|elferr
decl_stmt|;
name|s
operator|=
operator|&
name|re
operator|->
name|sl
index|[
name|symtab
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|!=
name|SHT_SYMTAB
operator|&&
name|s
operator|->
name|type
operator|!=
name|SHT_DYNSYM
condition|)
return|return
operator|(
literal|""
operator|)
return|;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|""
operator|)
return|;
block|}
if|if
condition|(
name|gelf_getsym
argument_list|(
name|data
argument_list|,
name|i
argument_list|,
operator|&
name|sym
argument_list|)
operator|!=
operator|&
name|sym
condition|)
return|return
operator|(
literal|""
operator|)
return|;
comment|/* Return section name for STT_SECTION symbol. */
if|if
condition|(
name|GELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|<
name|re
operator|->
name|shnum
operator|&&
name|re
operator|->
name|sl
index|[
name|sym
operator|.
name|st_shndx
index|]
operator|.
name|name
operator|!=
name|NULL
condition|)
return|return
operator|(
name|re
operator|->
name|sl
index|[
name|sym
operator|.
name|st_shndx
index|]
operator|.
name|name
operator|)
return|;
return|return
operator|(
literal|""
operator|)
return|;
block|}
if|if
condition|(
name|s
operator|->
name|link
operator|>=
name|re
operator|->
name|shnum
operator|||
operator|(
name|name
operator|=
name|elf_strptr
argument_list|(
name|re
operator|->
name|elf
argument_list|,
name|s
operator|->
name|link
argument_list|,
name|sym
operator|.
name|st_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|""
operator|)
return|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|get_symbol_value
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|int
name|symtab
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|GElf_Sym
name|sym
decl_stmt|;
name|Elf_Data
modifier|*
name|data
decl_stmt|;
name|int
name|elferr
decl_stmt|;
name|s
operator|=
operator|&
name|re
operator|->
name|sl
index|[
name|symtab
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|!=
name|SHT_SYMTAB
operator|&&
name|s
operator|->
name|type
operator|!=
name|SHT_DYNSYM
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|gelf_getsym
argument_list|(
name|data
argument_list|,
name|i
argument_list|,
operator|&
name|sym
argument_list|)
operator|!=
operator|&
name|sym
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|sym
operator|.
name|st_value
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hex_dump
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|Elf_Data
modifier|*
name|d
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|;
name|size_t
name|sz
decl_stmt|,
name|nbytes
decl_stmt|;
name|uint64_t
name|addr
decl_stmt|;
name|int
name|elferr
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|re
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|re
operator|->
name|sl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|find_dumpop
argument_list|(
name|re
argument_list|,
operator|(
name|size_t
operator|)
name|i
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|HEX_DUMP
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|d
operator|=
name|elf_rawdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|d_size
operator|<=
literal|0
operator|||
name|d
operator|->
name|d_buf
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"\nSection '%s' has no data to dump.\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|buf
operator|=
name|d
operator|->
name|d_buf
expr_stmt|;
name|sz
operator|=
name|d
operator|->
name|d_size
expr_stmt|;
name|addr
operator|=
name|s
operator|->
name|addr
expr_stmt|;
name|printf
argument_list|(
literal|"\nHex dump of section '%s':\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
name|sz
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"  0x%8.8jx "
argument_list|,
operator|(
name|uintmax_t
operator|)
name|addr
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|sz
operator|>
literal|16
condition|?
literal|16
else|:
name|sz
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|size_t
operator|)
name|j
operator|<
name|nbytes
condition|)
name|printf
argument_list|(
literal|"%2.2x"
argument_list|,
name|buf
index|[
name|j
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|&
literal|3
operator|)
operator|==
literal|3
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|j
operator|<
name|nbytes
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|isprint
argument_list|(
name|buf
index|[
name|j
index|]
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|buf
index|[
name|j
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|nbytes
expr_stmt|;
name|addr
operator|+=
name|nbytes
expr_stmt|;
name|sz
operator|-=
name|nbytes
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|str_dump
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
name|Elf_Data
modifier|*
name|d
decl_stmt|;
name|unsigned
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|buf_end
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|elferr
decl_stmt|,
name|found
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|re
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|re
operator|->
name|sl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|find_dumpop
argument_list|(
name|re
argument_list|,
operator|(
name|size_t
operator|)
name|i
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|STR_DUMP
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|elf_getdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|d
operator|=
name|elf_rawdata
argument_list|(
name|s
operator|->
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_getdata failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|d_size
operator|<=
literal|0
operator|||
name|d
operator|->
name|d_buf
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"\nSection '%s' has no data to dump.\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|buf_end
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|d
operator|->
name|d_buf
operator|+
name|d
operator|->
name|d_size
expr_stmt|;
name|start
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|d
operator|->
name|d_buf
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"\nString dump of section '%s':\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|start
operator|<
name|buf_end
operator|&&
operator|!
name|isprint
argument_list|(
operator|*
name|start
argument_list|)
condition|)
name|start
operator|++
expr_stmt|;
if|if
condition|(
name|start
operator|>=
name|buf_end
condition|)
break|break;
name|end
operator|=
name|start
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|end
operator|<
name|buf_end
operator|&&
name|isprint
argument_list|(
operator|*
name|end
argument_list|)
condition|)
name|end
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"  [%6lx]  "
argument_list|,
call|(
name|long
call|)
argument_list|(
name|start
operator|-
operator|(
name|unsigned
name|char
operator|*
operator|)
name|d
operator|->
name|d_buf
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|end
operator|-
name|start
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|unsigned
name|int
operator|)
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
name|putchar
argument_list|(
name|start
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|end
operator|>=
name|buf_end
condition|)
break|break;
name|start
operator|=
name|end
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|printf
argument_list|(
literal|"  No strings found in this section."
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|load_sections
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
name|struct
name|section
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|Elf_Scn
modifier|*
name|scn
decl_stmt|;
name|GElf_Shdr
name|sh
decl_stmt|;
name|size_t
name|shstrndx
decl_stmt|,
name|ndx
decl_stmt|;
name|int
name|elferr
decl_stmt|;
comment|/* Allocate storage for internal section list. */
if|if
condition|(
operator|!
name|elf_getshnum
argument_list|(
name|re
operator|->
name|elf
argument_list|,
operator|&
name|re
operator|->
name|shnum
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_getshnum failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|re
operator|->
name|sl
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|re
operator|->
name|sl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|re
operator|->
name|sl
operator|=
name|calloc
argument_list|(
name|re
operator|->
name|shnum
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|re
operator|->
name|sl
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
comment|/* Get the index of .shstrtab section. */
if|if
condition|(
operator|!
name|elf_getshstrndx
argument_list|(
name|re
operator|->
name|elf
argument_list|,
operator|&
name|shstrndx
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_getshstrndx failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|scn
operator|=
name|elf_getscn
argument_list|(
name|re
operator|->
name|elf
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
do|do
block|{
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|scn
argument_list|,
operator|&
name|sh
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"gelf_getshdr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|name
operator|=
name|elf_strptr
argument_list|(
name|re
operator|->
name|elf
argument_list|,
name|shstrndx
argument_list|,
name|sh
operator|.
name|sh_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
name|name
operator|=
literal|"<no-name>"
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ndx
operator|=
name|elf_ndxscn
argument_list|(
name|scn
argument_list|)
operator|)
operator|==
name|SHN_UNDEF
condition|)
block|{
if|if
condition|(
operator|(
name|elferr
operator|=
name|elf_errno
argument_list|()
operator|)
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_ndxscn failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|ndx
operator|>=
name|re
operator|->
name|shnum
condition|)
block|{
name|warnx
argument_list|(
literal|"section index of '%s' out of range"
argument_list|,
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sh
operator|.
name|sh_link
operator|>=
name|re
operator|->
name|shnum
condition|)
name|warnx
argument_list|(
literal|"section link %llu of '%s' out of range"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|sh
operator|.
name|sh_link
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|s
operator|=
operator|&
name|re
operator|->
name|sl
index|[
name|ndx
index|]
expr_stmt|;
name|s
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|s
operator|->
name|scn
operator|=
name|scn
expr_stmt|;
name|s
operator|->
name|off
operator|=
name|sh
operator|.
name|sh_offset
expr_stmt|;
name|s
operator|->
name|sz
operator|=
name|sh
operator|.
name|sh_size
expr_stmt|;
name|s
operator|->
name|entsize
operator|=
name|sh
operator|.
name|sh_entsize
expr_stmt|;
name|s
operator|->
name|align
operator|=
name|sh
operator|.
name|sh_addralign
expr_stmt|;
name|s
operator|->
name|type
operator|=
name|sh
operator|.
name|sh_type
expr_stmt|;
name|s
operator|->
name|flags
operator|=
name|sh
operator|.
name|sh_flags
expr_stmt|;
name|s
operator|->
name|addr
operator|=
name|sh
operator|.
name|sh_addr
expr_stmt|;
name|s
operator|->
name|link
operator|=
name|sh
operator|.
name|sh_link
expr_stmt|;
name|s
operator|->
name|info
operator|=
name|sh
operator|.
name|sh_info
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|scn
operator|=
name|elf_nextscn
argument_list|(
name|re
operator|->
name|elf
argument_list|,
name|scn
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
do|;
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"elf_nextscn failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unload_sections
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
if|if
condition|(
name|re
operator|->
name|sl
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|re
operator|->
name|sl
argument_list|)
expr_stmt|;
name|re
operator|->
name|sl
operator|=
name|NULL
expr_stmt|;
block|}
name|re
operator|->
name|shnum
operator|=
literal|0
expr_stmt|;
name|re
operator|->
name|vd_s
operator|=
name|NULL
expr_stmt|;
name|re
operator|->
name|vn_s
operator|=
name|NULL
expr_stmt|;
name|re
operator|->
name|vs_s
operator|=
name|NULL
expr_stmt|;
name|re
operator|->
name|vs
operator|=
name|NULL
expr_stmt|;
name|re
operator|->
name|vs_sz
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|ver
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|re
operator|->
name|ver
argument_list|)
expr_stmt|;
name|re
operator|->
name|ver
operator|=
name|NULL
expr_stmt|;
name|re
operator|->
name|ver_sz
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_elf
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
comment|/* Fetch ELF header. No need to continue if it fails. */
if|if
condition|(
name|gelf_getehdr
argument_list|(
name|re
operator|->
name|elf
argument_list|,
operator|&
name|re
operator|->
name|ehdr
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"gelf_getehdr failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|re
operator|->
name|ec
operator|=
name|gelf_getclass
argument_list|(
name|re
operator|->
name|elf
argument_list|)
operator|)
operator|==
name|ELFCLASSNONE
condition|)
block|{
name|warnx
argument_list|(
literal|"gelf_getclass failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|re
operator|->
name|ehdr
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
operator|==
name|ELFDATA2MSB
condition|)
block|{
name|re
operator|->
name|dw_read
operator|=
name|_read_msb
expr_stmt|;
name|re
operator|->
name|dw_decode
operator|=
name|_decode_msb
expr_stmt|;
block|}
else|else
block|{
name|re
operator|->
name|dw_read
operator|=
name|_read_lsb
expr_stmt|;
name|re
operator|->
name|dw_decode
operator|=
name|_decode_lsb
expr_stmt|;
block|}
if|if
condition|(
name|re
operator|->
name|options
operator|&
operator|~
name|RE_H
condition|)
name|load_sections
argument_list|(
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|re
operator|->
name|options
operator|&
name|RE_VV
operator|)
operator|||
operator|(
name|re
operator|->
name|options
operator|&
name|RE_S
operator|)
condition|)
name|search_ver
argument_list|(
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_H
condition|)
name|dump_ehdr
argument_list|(
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_L
condition|)
name|dump_phdr
argument_list|(
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_SS
condition|)
name|dump_shdr
argument_list|(
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_G
condition|)
name|dump_section_groups
argument_list|(
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_D
condition|)
name|dump_dynamic
argument_list|(
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_R
condition|)
name|dump_reloc
argument_list|(
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_S
condition|)
name|dump_symtabs
argument_list|(
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_N
condition|)
name|dump_notes
argument_list|(
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_II
condition|)
name|dump_hash
argument_list|(
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_X
condition|)
name|hex_dump
argument_list|(
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_P
condition|)
name|str_dump
argument_list|(
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_VV
condition|)
name|dump_ver
argument_list|(
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_AA
condition|)
name|dump_arch_specific_info
argument_list|(
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_W
condition|)
name|dump_dwarf
argument_list|(
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|options
operator|&
operator|~
name|RE_H
condition|)
name|unload_sections
argument_list|(
name|re
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_dwarf
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
name|struct
name|loc_at
modifier|*
name|la
decl_stmt|,
modifier|*
name|_la
decl_stmt|;
name|Dwarf_Error
name|de
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|dwarf_elf_init
argument_list|(
name|re
operator|->
name|elf
argument_list|,
name|DW_DLC_READ
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|re
operator|->
name|dbg
argument_list|,
operator|&
name|de
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|dwarf_errno
argument_list|(
name|de
argument_list|)
operator|)
operator|!=
name|DW_DLE_DEBUG_INFO_NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"dwarf_elf_init failed: %s"
argument_list|,
name|dwarf_errmsg
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|re
operator|->
name|dop
operator|&
name|DW_A
condition|)
name|dump_dwarf_abbrev
argument_list|(
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|dop
operator|&
name|DW_L
condition|)
name|dump_dwarf_line
argument_list|(
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|dop
operator|&
name|DW_LL
condition|)
name|dump_dwarf_line_decoded
argument_list|(
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|dop
operator|&
name|DW_I
condition|)
block|{
name|dump_dwarf_info
argument_list|(
name|re
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dump_dwarf_info
argument_list|(
name|re
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|re
operator|->
name|dop
operator|&
name|DW_P
condition|)
name|dump_dwarf_pubnames
argument_list|(
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|dop
operator|&
name|DW_R
condition|)
name|dump_dwarf_aranges
argument_list|(
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|dop
operator|&
name|DW_RR
condition|)
name|dump_dwarf_ranges
argument_list|(
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|dop
operator|&
name|DW_M
condition|)
name|dump_dwarf_macinfo
argument_list|(
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|dop
operator|&
name|DW_F
condition|)
name|dump_dwarf_frame
argument_list|(
name|re
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|re
operator|->
name|dop
operator|&
name|DW_FF
condition|)
name|dump_dwarf_frame
argument_list|(
name|re
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|dop
operator|&
name|DW_S
condition|)
name|dump_dwarf_str
argument_list|(
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|dop
operator|&
name|DW_O
condition|)
name|dump_dwarf_loclist
argument_list|(
name|re
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|la
argument_list|,
argument|&lalist
argument_list|,
argument|la_next
argument_list|,
argument|_la
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lalist
argument_list|,
name|la
argument_list|,
name|la_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|la
argument_list|)
expr_stmt|;
block|}
name|dwarf_finish
argument_list|(
name|re
operator|->
name|dbg
argument_list|,
operator|&
name|de
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_ar
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|Elf_Arsym
modifier|*
name|arsym
decl_stmt|;
name|Elf_Arhdr
modifier|*
name|arhdr
decl_stmt|;
name|Elf_Cmd
name|cmd
decl_stmt|;
name|Elf
modifier|*
name|e
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|off_t
name|off
decl_stmt|;
name|int
name|i
decl_stmt|;
name|re
operator|->
name|ar
operator|=
name|re
operator|->
name|elf
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|options
operator|&
name|RE_C
condition|)
block|{
if|if
condition|(
operator|(
name|arsym
operator|=
name|elf_getarsym
argument_list|(
name|re
operator|->
name|ar
argument_list|,
operator|&
name|sz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_getarsym() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|process_members
goto|;
block|}
name|printf
argument_list|(
literal|"Index of archive %s: (%ju entries)\n"
argument_list|,
name|re
operator|->
name|filename
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sz
operator|-
literal|1
argument_list|)
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|arsym
index|[
name|i
index|]
operator|.
name|as_name
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|arsym
index|[
name|i
index|]
operator|.
name|as_off
operator|!=
name|off
condition|)
block|{
name|off
operator|=
name|arsym
index|[
name|i
index|]
operator|.
name|as_off
expr_stmt|;
if|if
condition|(
name|elf_rand
argument_list|(
name|re
operator|->
name|ar
argument_list|,
name|off
argument_list|)
operator|!=
name|off
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_rand() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|e
operator|=
name|elf_begin
argument_list|(
name|fd
argument_list|,
name|ELF_C_READ
argument_list|,
name|re
operator|->
name|ar
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_begin() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|arhdr
operator|=
name|elf_getarhdr
argument_list|(
name|e
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_getarhdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|elf_end
argument_list|(
name|e
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"Binary %s(%s) contains:\n"
argument_list|,
name|re
operator|->
name|filename
argument_list|,
name|arhdr
operator|->
name|ar_name
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\t%s\n"
argument_list|,
name|arsym
index|[
name|i
index|]
operator|.
name|as_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|elf_rand
argument_list|(
name|re
operator|->
name|ar
argument_list|,
name|SARMAG
argument_list|)
operator|!=
name|SARMAG
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_rand() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|process_members
label|:
if|if
condition|(
operator|(
name|re
operator|->
name|options
operator|&
operator|~
name|RE_C
operator|)
operator|==
literal|0
condition|)
return|return;
name|cmd
operator|=
name|ELF_C_READ
expr_stmt|;
while|while
condition|(
operator|(
name|re
operator|->
name|elf
operator|=
name|elf_begin
argument_list|(
name|fd
argument_list|,
name|cmd
argument_list|,
name|re
operator|->
name|ar
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|arhdr
operator|=
name|elf_getarhdr
argument_list|(
name|re
operator|->
name|elf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_getarhdr() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|next_member
goto|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|arhdr
operator|->
name|ar_name
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arhdr
operator|->
name|ar_name
argument_list|,
literal|"//"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arhdr
operator|->
name|ar_name
argument_list|,
literal|"__.SYMDEF"
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|next_member
goto|;
name|printf
argument_list|(
literal|"\nFile: %s(%s)\n"
argument_list|,
name|re
operator|->
name|filename
argument_list|,
name|arhdr
operator|->
name|ar_name
argument_list|)
expr_stmt|;
name|dump_elf
argument_list|(
name|re
argument_list|)
expr_stmt|;
name|next_member
label|:
name|cmd
operator|=
name|elf_next
argument_list|(
name|re
operator|->
name|elf
argument_list|)
expr_stmt|;
name|elf_end
argument_list|(
name|re
operator|->
name|elf
argument_list|)
expr_stmt|;
block|}
name|re
operator|->
name|elf
operator|=
name|re
operator|->
name|ar
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_object
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|re
operator|->
name|filename
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"open %s failed"
argument_list|,
name|re
operator|->
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|re
operator|->
name|flags
operator|&
name|DISPLAY_FILENAME
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"\nFile: %s\n"
argument_list|,
name|re
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|re
operator|->
name|elf
operator|=
name|elf_begin
argument_list|(
name|fd
argument_list|,
name|ELF_C_READ
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"elf_begin() failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|elf_kind
argument_list|(
name|re
operator|->
name|elf
argument_list|)
condition|)
block|{
case|case
name|ELF_K_NONE
case|:
name|warnx
argument_list|(
literal|"Not an ELF file."
argument_list|)
expr_stmt|;
return|return;
case|case
name|ELF_K_ELF
case|:
name|dump_elf
argument_list|(
name|re
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELF_K_AR
case|:
name|dump_ar
argument_list|(
name|re
argument_list|,
name|fd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|warnx
argument_list|(
literal|"Internal: libelf returned unknown elf kind."
argument_list|)
expr_stmt|;
return|return;
block|}
name|elf_end
argument_list|(
name|re
operator|->
name|elf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_dumpop
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|size_t
name|si
parameter_list|,
specifier|const
name|char
modifier|*
name|sn
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|t
parameter_list|)
block|{
name|struct
name|dumpop
modifier|*
name|d
decl_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|find_dumpop
argument_list|(
name|re
argument_list|,
name|si
argument_list|,
name|sn
argument_list|,
operator|-
literal|1
argument_list|,
name|t
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|d
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|d
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|DUMP_BY_INDEX
condition|)
name|d
operator|->
name|u
operator|.
name|si
operator|=
name|si
expr_stmt|;
else|else
name|d
operator|->
name|u
operator|.
name|sn
operator|=
name|sn
expr_stmt|;
name|d
operator|->
name|type
operator|=
name|t
expr_stmt|;
name|d
operator|->
name|op
operator|=
name|op
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|re
operator|->
name|v_dumpop
argument_list|,
name|d
argument_list|,
name|dumpop_list
argument_list|)
expr_stmt|;
block|}
else|else
name|d
operator|->
name|op
operator||=
name|op
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|dumpop
modifier|*
name|find_dumpop
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
name|size_t
name|si
parameter_list|,
specifier|const
name|char
modifier|*
name|sn
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|t
parameter_list|)
block|{
name|struct
name|dumpop
modifier|*
name|d
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|d
argument_list|,
argument|&re->v_dumpop
argument_list|,
argument|dumpop_list
argument_list|)
block|{
if|if
condition|(
operator|(
name|op
operator|==
operator|-
literal|1
operator|||
name|op
operator|&
name|d
operator|->
name|op
operator|)
operator|&&
operator|(
name|t
operator|==
operator|-
literal|1
operator|||
operator|(
name|unsigned
operator|)
name|t
operator|==
name|d
operator|->
name|type
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|d
operator|->
name|type
operator|==
name|DUMP_BY_INDEX
operator|&&
name|d
operator|->
name|u
operator|.
name|si
operator|==
name|si
operator|)
operator|||
operator|(
name|d
operator|->
name|type
operator|==
name|DUMP_BY_NAME
operator|&&
operator|!
name|strcmp
argument_list|(
name|d
operator|->
name|u
operator|.
name|sn
argument_list|,
name|sn
argument_list|)
operator|)
condition|)
return|return
operator|(
name|d
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_struct
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|ln
decl_stmt|;
name|char
name|sn
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
name|dwarf_op
index|[]
init|=
block|{
block|{
literal|"rawline"
block|,
literal|'l'
block|,
name|DW_L
block|}
block|,
block|{
literal|"decodedline"
block|,
literal|'L'
block|,
name|DW_LL
block|}
block|,
block|{
literal|"info"
block|,
literal|'i'
block|,
name|DW_I
block|}
block|,
block|{
literal|"abbrev"
block|,
literal|'a'
block|,
name|DW_A
block|}
block|,
block|{
literal|"pubnames"
block|,
literal|'p'
block|,
name|DW_P
block|}
block|,
block|{
literal|"aranges"
block|,
literal|'r'
block|,
name|DW_R
block|}
block|,
block|{
literal|"ranges"
block|,
literal|'r'
block|,
name|DW_R
block|}
block|,
block|{
literal|"Ranges"
block|,
literal|'R'
block|,
name|DW_RR
block|}
block|,
block|{
literal|"macro"
block|,
literal|'m'
block|,
name|DW_M
block|}
block|,
block|{
literal|"frames"
block|,
literal|'f'
block|,
name|DW_F
block|}
block|,
block|{
literal|"frames-interp"
block|,
literal|'F'
block|,
name|DW_FF
block|}
block|,
block|{
literal|"str"
block|,
literal|'s'
block|,
name|DW_S
block|}
block|,
block|{
literal|"loc"
block|,
literal|'o'
block|,
name|DW_O
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|parse_dwarf_op_short
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
specifier|const
name|char
modifier|*
name|op
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|NULL
condition|)
block|{
name|re
operator|->
name|dop
operator||=
name|DW_DEFAULT_OPTIONS
expr_stmt|;
return|return;
block|}
for|for
control|(
init|;
operator|*
name|op
operator|!=
literal|'\0'
condition|;
name|op
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|dwarf_op
index|[
name|i
index|]
operator|.
name|ln
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dwarf_op
index|[
name|i
index|]
operator|.
name|sn
operator|==
operator|*
name|op
condition|)
block|{
name|re
operator|->
name|dop
operator||=
name|dwarf_op
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|parse_dwarf_op_long
parameter_list|(
name|struct
name|readelf
modifier|*
name|re
parameter_list|,
specifier|const
name|char
modifier|*
name|op
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|token
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|NULL
condition|)
block|{
name|re
operator|->
name|dop
operator||=
name|DW_DEFAULT_OPTIONS
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|strdup
argument_list|(
name|op
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"strdup failed"
argument_list|)
expr_stmt|;
name|bp
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|(
name|token
operator|=
name|strsep
argument_list|(
operator|&
name|p
argument_list|,
literal|","
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|dwarf_op
index|[
name|i
index|]
operator|.
name|ln
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|token
argument_list|,
name|dwarf_op
index|[
name|i
index|]
operator|.
name|ln
argument_list|)
condition|)
block|{
name|re
operator|->
name|dop
operator||=
name|dwarf_op
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
break|break;
block|}
block|}
block|}
name|free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|_read_lsb
parameter_list|(
name|Elf_Data
modifier|*
name|d
parameter_list|,
name|uint64_t
modifier|*
name|offsetp
parameter_list|,
name|int
name|bytes_to_read
parameter_list|)
block|{
name|uint64_t
name|ret
decl_stmt|;
name|uint8_t
modifier|*
name|src
decl_stmt|;
name|src
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|d
operator|->
name|d_buf
operator|+
operator|*
name|offsetp
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|bytes_to_read
condition|)
block|{
case|case
literal|8
case|:
name|ret
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|4
index|]
operator|)
operator|<<
literal|32
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|5
index|]
operator|)
operator|<<
literal|40
expr_stmt|;
name|ret
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|6
index|]
operator|)
operator|<<
literal|48
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|7
index|]
operator|)
operator|<<
literal|56
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|4
case|:
name|ret
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|2
index|]
operator|)
operator|<<
literal|16
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|3
index|]
operator|)
operator|<<
literal|24
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|2
case|:
name|ret
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
name|ret
operator||=
name|src
index|[
literal|0
index|]
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|offsetp
operator|+=
name|bytes_to_read
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|_read_msb
parameter_list|(
name|Elf_Data
modifier|*
name|d
parameter_list|,
name|uint64_t
modifier|*
name|offsetp
parameter_list|,
name|int
name|bytes_to_read
parameter_list|)
block|{
name|uint64_t
name|ret
decl_stmt|;
name|uint8_t
modifier|*
name|src
decl_stmt|;
name|src
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|d
operator|->
name|d_buf
operator|+
operator|*
name|offsetp
expr_stmt|;
switch|switch
condition|(
name|bytes_to_read
condition|)
block|{
case|case
literal|1
case|:
name|ret
operator|=
name|src
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ret
operator|=
name|src
index|[
literal|1
index|]
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|0
index|]
operator|)
operator|<<
literal|8
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|ret
operator|=
name|src
index|[
literal|3
index|]
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|2
index|]
operator|)
operator|<<
literal|8
expr_stmt|;
name|ret
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|1
index|]
operator|)
operator|<<
literal|16
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|0
index|]
operator|)
operator|<<
literal|24
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|ret
operator|=
name|src
index|[
literal|7
index|]
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
expr_stmt|;
name|ret
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|5
index|]
operator|)
operator|<<
literal|16
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|4
index|]
operator|)
operator|<<
literal|24
expr_stmt|;
name|ret
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|3
index|]
operator|)
operator|<<
literal|32
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|2
index|]
operator|)
operator|<<
literal|40
expr_stmt|;
name|ret
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|1
index|]
operator|)
operator|<<
literal|48
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|0
index|]
operator|)
operator|<<
literal|56
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|offsetp
operator|+=
name|bytes_to_read
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|_decode_lsb
parameter_list|(
name|uint8_t
modifier|*
modifier|*
name|data
parameter_list|,
name|int
name|bytes_to_read
parameter_list|)
block|{
name|uint64_t
name|ret
decl_stmt|;
name|uint8_t
modifier|*
name|src
decl_stmt|;
name|src
operator|=
operator|*
name|data
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|bytes_to_read
condition|)
block|{
case|case
literal|8
case|:
name|ret
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|4
index|]
operator|)
operator|<<
literal|32
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|5
index|]
operator|)
operator|<<
literal|40
expr_stmt|;
name|ret
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|6
index|]
operator|)
operator|<<
literal|48
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|7
index|]
operator|)
operator|<<
literal|56
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|4
case|:
name|ret
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|2
index|]
operator|)
operator|<<
literal|16
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|3
index|]
operator|)
operator|<<
literal|24
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|2
case|:
name|ret
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
name|ret
operator||=
name|src
index|[
literal|0
index|]
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|data
operator|+=
name|bytes_to_read
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|_decode_msb
parameter_list|(
name|uint8_t
modifier|*
modifier|*
name|data
parameter_list|,
name|int
name|bytes_to_read
parameter_list|)
block|{
name|uint64_t
name|ret
decl_stmt|;
name|uint8_t
modifier|*
name|src
decl_stmt|;
name|src
operator|=
operator|*
name|data
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|bytes_to_read
condition|)
block|{
case|case
literal|1
case|:
name|ret
operator|=
name|src
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ret
operator|=
name|src
index|[
literal|1
index|]
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|0
index|]
operator|)
operator|<<
literal|8
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|ret
operator|=
name|src
index|[
literal|3
index|]
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|2
index|]
operator|)
operator|<<
literal|8
expr_stmt|;
name|ret
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|1
index|]
operator|)
operator|<<
literal|16
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|0
index|]
operator|)
operator|<<
literal|24
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|ret
operator|=
name|src
index|[
literal|7
index|]
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
expr_stmt|;
name|ret
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|5
index|]
operator|)
operator|<<
literal|16
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|4
index|]
operator|)
operator|<<
literal|24
expr_stmt|;
name|ret
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|3
index|]
operator|)
operator|<<
literal|32
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|2
index|]
operator|)
operator|<<
literal|40
expr_stmt|;
name|ret
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|1
index|]
operator|)
operator|<<
literal|48
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|src
index|[
literal|0
index|]
operator|)
operator|<<
literal|56
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
break|break;
block|}
operator|*
name|data
operator|+=
name|bytes_to_read
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int64_t
name|_decode_sleb128
parameter_list|(
name|uint8_t
modifier|*
modifier|*
name|dp
parameter_list|,
name|uint8_t
modifier|*
name|dpe
parameter_list|)
block|{
name|int64_t
name|ret
init|=
literal|0
decl_stmt|;
name|uint8_t
name|b
init|=
literal|0
decl_stmt|;
name|int
name|shift
init|=
literal|0
decl_stmt|;
name|uint8_t
modifier|*
name|src
init|=
operator|*
name|dp
decl_stmt|;
do|do
block|{
if|if
condition|(
name|src
operator|>=
name|dpe
condition|)
break|break;
name|b
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|ret
operator||=
operator|(
operator|(
name|b
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
operator|)
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|b
operator|&
literal|0x80
operator|)
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|shift
operator|<
literal|32
operator|&&
operator|(
name|b
operator|&
literal|0x40
operator|)
operator|!=
literal|0
condition|)
name|ret
operator||=
operator|(
operator|-
literal|1
operator|<<
name|shift
operator|)
expr_stmt|;
operator|*
name|dp
operator|=
name|src
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|_decode_uleb128
parameter_list|(
name|uint8_t
modifier|*
modifier|*
name|dp
parameter_list|,
name|uint8_t
modifier|*
name|dpe
parameter_list|)
block|{
name|uint64_t
name|ret
init|=
literal|0
decl_stmt|;
name|uint8_t
name|b
decl_stmt|;
name|int
name|shift
init|=
literal|0
decl_stmt|;
name|uint8_t
modifier|*
name|src
init|=
operator|*
name|dp
decl_stmt|;
do|do
block|{
if|if
condition|(
name|src
operator|>=
name|dpe
condition|)
break|break;
name|b
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|ret
operator||=
operator|(
operator|(
name|b
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
operator|)
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|b
operator|&
literal|0x80
operator|)
operator|!=
literal|0
condition|)
do|;
operator|*
name|dp
operator|=
name|src
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|readelf_version
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s (%s)\n"
argument_list|,
name|ELFTC_GETPROGNAME
argument_list|()
argument_list|,
name|elftc_version
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|USAGE_MESSAGE
value|"\ Usage: %s [options] file...\n\   Display information about ELF objects and ar(1) archives.\n\n\   Options:\n\   -a | --all               Equivalent to specifying options '-dhIlrsASV'.\n\   -c | --archive-index     Print the archive symbol table for archives.\n\   -d | --dynamic           Print the contents of SHT_DYNAMIC sections.\n\   -e | --headers           Print all headers in the object.\n\   -g | --section-groups    Print the contents of the section groups.\n\   -h | --file-header       Print the file header for the object.\n\   -l | --program-headers   Print the PHDR table for the object.\n\   -n | --notes             Print the contents of SHT_NOTE sections.\n\   -p INDEX | --string-dump=INDEX\n\                            Print the contents of section at index INDEX.\n\   -r | --relocs            Print relocation information.\n\   -s | --syms | --symbols  Print symbol tables.\n\   -t | --section-details   Print additional information about sections.\n\   -v | --version           Print a version identifier and exit.\n\   -w[afilmoprsFLR] | --debug-dump={abbrev,aranges,decodedline,frames,\n\                                frames-interp,info,loc,macro,pubnames,\n\                                ranges,Ranges,rawline,str}\n\                            Display DWARF information.\n\   -x INDEX | --hex-dump=INDEX\n\                            Display contents of a section as hexadecimal.\n\   -A | --arch-specific     (accepted, but ignored)\n\   -D | --use-dynamic       Print the symbol table specified by the DT_SYMTAB\n\                            entry in the \".dynamic\" section.\n\   -H | --help              Print a help message.\n\   -I | --histogram         Print information on bucket list lengths for \n\                            hash sections.\n\   -N | --full-section-name (accepted, but ignored)\n\   -S | --sections | --section-headers\n\                            Print information about section headers.\n\   -V | --version-info      Print symbol versoning information.\n\   -W | --wide              Print information without wrapping long lines.\n"
end_define

begin_function
specifier|static
name|void
name|readelf_usage
parameter_list|(
name|int
name|status
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|USAGE_MESSAGE
argument_list|,
name|ELFTC_GETPROGNAME
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|readelf
modifier|*
name|re
decl_stmt|,
name|re_storage
decl_stmt|;
name|unsigned
name|long
name|si
decl_stmt|;
name|int
name|opt
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|re
operator|=
operator|&
name|re_storage
expr_stmt|;
name|memset
argument_list|(
name|re
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|re
argument_list|)
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|re
operator|->
name|v_dumpop
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"AacDdegHhIi:lNnp:rSstuVvWw::x:"
argument_list|,
name|longopts
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'?'
case|:
name|readelf_usage
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|re
operator|->
name|options
operator||=
name|RE_AA
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|re
operator|->
name|options
operator||=
name|RE_AA
operator||
name|RE_D
operator||
name|RE_G
operator||
name|RE_H
operator||
name|RE_II
operator||
name|RE_L
operator||
name|RE_R
operator||
name|RE_SS
operator||
name|RE_S
operator||
name|RE_VV
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|re
operator|->
name|options
operator||=
name|RE_C
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|re
operator|->
name|options
operator||=
name|RE_DD
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|re
operator|->
name|options
operator||=
name|RE_D
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|re
operator|->
name|options
operator||=
name|RE_H
operator||
name|RE_L
operator||
name|RE_SS
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|re
operator|->
name|options
operator||=
name|RE_G
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|readelf_usage
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|re
operator|->
name|options
operator||=
name|RE_H
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|re
operator|->
name|options
operator||=
name|RE_II
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* Not implemented yet. */
break|break;
case|case
literal|'l'
case|:
name|re
operator|->
name|options
operator||=
name|RE_L
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|re
operator|->
name|options
operator||=
name|RE_NN
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|re
operator|->
name|options
operator||=
name|RE_N
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|re
operator|->
name|options
operator||=
name|RE_P
expr_stmt|;
name|si
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ep
operator|==
literal|'\0'
condition|)
name|add_dumpop
argument_list|(
name|re
argument_list|,
operator|(
name|size_t
operator|)
name|si
argument_list|,
name|NULL
argument_list|,
name|STR_DUMP
argument_list|,
name|DUMP_BY_INDEX
argument_list|)
expr_stmt|;
else|else
name|add_dumpop
argument_list|(
name|re
argument_list|,
literal|0
argument_list|,
name|optarg
argument_list|,
name|STR_DUMP
argument_list|,
name|DUMP_BY_NAME
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|re
operator|->
name|options
operator||=
name|RE_R
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|re
operator|->
name|options
operator||=
name|RE_SS
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|re
operator|->
name|options
operator||=
name|RE_S
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|re
operator|->
name|options
operator||=
name|RE_T
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|re
operator|->
name|options
operator||=
name|RE_U
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|re
operator|->
name|options
operator||=
name|RE_VV
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|readelf_version
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|re
operator|->
name|options
operator||=
name|RE_WW
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|re
operator|->
name|options
operator||=
name|RE_W
expr_stmt|;
name|parse_dwarf_op_short
argument_list|(
name|re
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|re
operator|->
name|options
operator||=
name|RE_X
expr_stmt|;
name|si
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ep
operator|==
literal|'\0'
condition|)
name|add_dumpop
argument_list|(
name|re
argument_list|,
operator|(
name|size_t
operator|)
name|si
argument_list|,
name|NULL
argument_list|,
name|HEX_DUMP
argument_list|,
name|DUMP_BY_INDEX
argument_list|)
expr_stmt|;
else|else
name|add_dumpop
argument_list|(
name|re
argument_list|,
literal|0
argument_list|,
name|optarg
argument_list|,
name|HEX_DUMP
argument_list|,
name|DUMP_BY_NAME
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_DEBUG_DUMP
case|:
name|re
operator|->
name|options
operator||=
name|RE_W
expr_stmt|;
name|parse_dwarf_op_long
argument_list|(
name|re
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
block|}
block|}
name|argv
operator|+=
name|optind
expr_stmt|;
name|argc
operator|-=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
operator|||
name|re
operator|->
name|options
operator|==
literal|0
condition|)
name|readelf_usage
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|re
operator|->
name|flags
operator||=
name|DISPLAY_FILENAME
expr_stmt|;
if|if
condition|(
name|elf_version
argument_list|(
name|EV_CURRENT
argument_list|)
operator|==
name|EV_NONE
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"ELF library initialization failed: %s"
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|re
operator|->
name|filename
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|dump_object
argument_list|(
name|re
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

