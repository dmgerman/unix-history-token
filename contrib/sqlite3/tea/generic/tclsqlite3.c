begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifdef
ifdef|#
directive|ifdef
name|USE_SYSTEM_SQLITE
end_ifdef

begin_include
include|#
directive|include
file|<sqlite3.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"sqlite3.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** 2001 September 15 ** ** The author disclaims copyright to this source code.  In place of ** a legal notice, here is a blessing: ** **    May you do good and not evil. **    May you find forgiveness for yourself and forgive others. **    May you share freely, never taking more than you give. ** ************************************************************************* ** A TCL Interface to SQLite.  Append this file to sqlite3.c and ** compile the whole thing to build a TCL-enabled version of SQLite. ** ** Compile-time options: ** **  -DTCLSH=1             Add a "main()" routine that works as a tclsh. ** **  -DSQLITE_TCLMD5       When used in conjuction with -DTCLSH=1, add **                        four new commands to the TCL interpreter for **                        generating MD5 checksums:  md5, md5file, **                        md5-10x8, and md5file-10x8. ** **  -DSQLITE_TEST         When used in conjuction with -DTCLSH=1, add **                        hundreds of new commands used for testing **                        SQLite.  This option implies -DSQLITE_TCLMD5. */
end_comment

begin_comment
comment|/* ** If requested, include the SQLite compiler options file for MSVC. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INCLUDE_MSVC_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|"msvc.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INCLUDE_SQLITE_TCL_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|"sqlite_tcl.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"tcl.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SQLITE_TCLAPI
end_ifndef

begin_define
define|#
directive|define
name|SQLITE_TCLAPI
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* ** Some additional include files are needed if this file is not ** appended to the amalgamation. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SQLITE_AMALGAMATION
end_ifndef

begin_include
include|#
directive|include
file|"sqlite3.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_typedef
typedef|typedef
name|unsigned
name|char
name|u8
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* Used to get the current process ID */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_define
define|#
directive|define
name|GETPID
value|getpid
end_define

begin_elif
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|_WIN32_WCE
argument_list|)
end_elif

begin_ifndef
ifndef|#
directive|ifndef
name|SQLITE_AMALGAMATION
end_ifndef

begin_define
define|#
directive|define
name|WIN32_LEAN_AND_MEAN
end_define

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|GETPID
value|(int)GetCurrentProcessId
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Windows needs to know which symbols to export.  Unix does not.  * BUILD_sqlite should be undefined for Unix.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BUILD_sqlite
end_ifdef

begin_undef
undef|#
directive|undef
name|TCL_STORAGE_CLASS
end_undef

begin_define
define|#
directive|define
name|TCL_STORAGE_CLASS
value|DLLEXPORT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BUILD_sqlite */
end_comment

begin_define
define|#
directive|define
name|NUM_PREPARED_STMTS
value|10
end_define

begin_define
define|#
directive|define
name|MAX_PREPARED_STMTS
value|100
end_define

begin_comment
comment|/* Forward declaration */
end_comment

begin_typedef
typedef|typedef
name|struct
name|SqliteDb
name|SqliteDb
typedef|;
end_typedef

begin_comment
comment|/* ** New SQL functions can be created as TCL scripts.  Each such function ** is described by an instance of the following structure. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|SqlFunc
name|SqlFunc
typedef|;
end_typedef

begin_struct
struct|struct
name|SqlFunc
block|{
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The TCL interpret to execute the function */
name|Tcl_Obj
modifier|*
name|pScript
decl_stmt|;
comment|/* The Tcl_Obj representation of the script */
name|SqliteDb
modifier|*
name|pDb
decl_stmt|;
comment|/* Database connection that owns this function */
name|int
name|useEvalObjv
decl_stmt|;
comment|/* True if it is safe to use Tcl_EvalObjv */
name|char
modifier|*
name|zName
decl_stmt|;
comment|/* Name of this function */
name|SqlFunc
modifier|*
name|pNext
decl_stmt|;
comment|/* Next function on the list of them all */
block|}
struct|;
end_struct

begin_comment
comment|/* ** New collation sequences function can be created as TCL scripts.  Each such ** function is described by an instance of the following structure. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|SqlCollate
name|SqlCollate
typedef|;
end_typedef

begin_struct
struct|struct
name|SqlCollate
block|{
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The TCL interpret to execute the function */
name|char
modifier|*
name|zScript
decl_stmt|;
comment|/* The script to be run */
name|SqlCollate
modifier|*
name|pNext
decl_stmt|;
comment|/* Next function on the list of them all */
block|}
struct|;
end_struct

begin_comment
comment|/* ** Prepared statements are cached for faster execution.  Each prepared ** statement is described by an instance of the following structure. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|SqlPreparedStmt
name|SqlPreparedStmt
typedef|;
end_typedef

begin_struct
struct|struct
name|SqlPreparedStmt
block|{
name|SqlPreparedStmt
modifier|*
name|pNext
decl_stmt|;
comment|/* Next in linked list */
name|SqlPreparedStmt
modifier|*
name|pPrev
decl_stmt|;
comment|/* Previous on the list */
name|sqlite3_stmt
modifier|*
name|pStmt
decl_stmt|;
comment|/* The prepared statement */
name|int
name|nSql
decl_stmt|;
comment|/* chars in zSql[] */
specifier|const
name|char
modifier|*
name|zSql
decl_stmt|;
comment|/* Text of the SQL statement */
name|int
name|nParm
decl_stmt|;
comment|/* Size of apParm array */
name|Tcl_Obj
modifier|*
modifier|*
name|apParm
decl_stmt|;
comment|/* Array of referenced object pointers */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|IncrblobChannel
name|IncrblobChannel
typedef|;
end_typedef

begin_comment
comment|/* ** There is one instance of this structure for each SQLite database ** that has been opened by the SQLite TCL interface. ** ** If this module is built with SQLITE_TEST defined (to create the SQLite ** testfixture executable), then it may be configured to use either ** sqlite3_prepare_v2() or sqlite3_prepare() to prepare SQL statements. ** If SqliteDb.bLegacyPrepare is true, sqlite3_prepare() is used. */
end_comment

begin_struct
struct|struct
name|SqliteDb
block|{
name|sqlite3
modifier|*
name|db
decl_stmt|;
comment|/* The "real" database structure. MUST BE FIRST */
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
comment|/* The interpreter used for this database */
name|char
modifier|*
name|zBusy
decl_stmt|;
comment|/* The busy callback routine */
name|char
modifier|*
name|zCommit
decl_stmt|;
comment|/* The commit hook callback routine */
name|char
modifier|*
name|zTrace
decl_stmt|;
comment|/* The trace callback routine */
name|char
modifier|*
name|zTraceV2
decl_stmt|;
comment|/* The trace_v2 callback routine */
name|char
modifier|*
name|zProfile
decl_stmt|;
comment|/* The profile callback routine */
name|char
modifier|*
name|zProgress
decl_stmt|;
comment|/* The progress callback routine */
name|char
modifier|*
name|zAuth
decl_stmt|;
comment|/* The authorization callback routine */
name|int
name|disableAuth
decl_stmt|;
comment|/* Disable the authorizer if it exists */
name|char
modifier|*
name|zNull
decl_stmt|;
comment|/* Text to substitute for an SQL NULL value */
name|SqlFunc
modifier|*
name|pFunc
decl_stmt|;
comment|/* List of SQL functions */
name|Tcl_Obj
modifier|*
name|pUpdateHook
decl_stmt|;
comment|/* Update hook script (if any) */
name|Tcl_Obj
modifier|*
name|pPreUpdateHook
decl_stmt|;
comment|/* Pre-update hook script (if any) */
name|Tcl_Obj
modifier|*
name|pRollbackHook
decl_stmt|;
comment|/* Rollback hook script (if any) */
name|Tcl_Obj
modifier|*
name|pWalHook
decl_stmt|;
comment|/* WAL hook script (if any) */
name|Tcl_Obj
modifier|*
name|pUnlockNotify
decl_stmt|;
comment|/* Unlock notify script (if any) */
name|SqlCollate
modifier|*
name|pCollate
decl_stmt|;
comment|/* List of SQL collation functions */
name|int
name|rc
decl_stmt|;
comment|/* Return code of most recent sqlite3_exec() */
name|Tcl_Obj
modifier|*
name|pCollateNeeded
decl_stmt|;
comment|/* Collation needed script */
name|SqlPreparedStmt
modifier|*
name|stmtList
decl_stmt|;
comment|/* List of prepared statements*/
name|SqlPreparedStmt
modifier|*
name|stmtLast
decl_stmt|;
comment|/* Last statement in the list */
name|int
name|maxStmt
decl_stmt|;
comment|/* The next maximum number of stmtList */
name|int
name|nStmt
decl_stmt|;
comment|/* Number of statements in stmtList */
name|IncrblobChannel
modifier|*
name|pIncrblob
decl_stmt|;
comment|/* Linked list of open incrblob channels */
name|int
name|nStep
decl_stmt|,
name|nSort
decl_stmt|,
name|nIndex
decl_stmt|;
comment|/* Statistics for most recent operation */
name|int
name|nTransaction
decl_stmt|;
comment|/* Number of nested [transaction] methods */
name|int
name|openFlags
decl_stmt|;
comment|/* Flags used to open.  (SQLITE_OPEN_URI) */
ifdef|#
directive|ifdef
name|SQLITE_TEST
name|int
name|bLegacyPrepare
decl_stmt|;
comment|/* True to use sqlite3_prepare() */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_struct
struct|struct
name|IncrblobChannel
block|{
name|sqlite3_blob
modifier|*
name|pBlob
decl_stmt|;
comment|/* sqlite3 blob handle */
name|SqliteDb
modifier|*
name|pDb
decl_stmt|;
comment|/* Associated database connection */
name|int
name|iSeek
decl_stmt|;
comment|/* Current seek offset */
name|Tcl_Channel
name|channel
decl_stmt|;
comment|/* Channel identifier */
name|IncrblobChannel
modifier|*
name|pNext
decl_stmt|;
comment|/* Linked list of all open incrblob channels */
name|IncrblobChannel
modifier|*
name|pPrev
decl_stmt|;
comment|/* Linked list of all open incrblob channels */
block|}
struct|;
end_struct

begin_comment
comment|/* ** Compute a string length that is limited to what can be stored in ** lower 30 bits of a 32-bit signed integer. */
end_comment

begin_function
specifier|static
name|int
name|strlen30
parameter_list|(
specifier|const
name|char
modifier|*
name|z
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|z2
init|=
name|z
decl_stmt|;
while|while
condition|(
operator|*
name|z2
condition|)
block|{
name|z2
operator|++
expr_stmt|;
block|}
return|return
literal|0x3fffffff
operator|&
call|(
name|int
call|)
argument_list|(
name|z2
operator|-
name|z
argument_list|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SQLITE_OMIT_INCRBLOB
end_ifndef

begin_comment
comment|/* ** Close all incrblob channels opened using database connection pDb. ** This is called when shutting down the database connection. */
end_comment

begin_function
specifier|static
name|void
name|closeIncrblobChannels
parameter_list|(
name|SqliteDb
modifier|*
name|pDb
parameter_list|)
block|{
name|IncrblobChannel
modifier|*
name|p
decl_stmt|;
name|IncrblobChannel
modifier|*
name|pNext
decl_stmt|;
for|for
control|(
name|p
operator|=
name|pDb
operator|->
name|pIncrblob
init|;
name|p
condition|;
name|p
operator|=
name|pNext
control|)
block|{
name|pNext
operator|=
name|p
operator|->
name|pNext
expr_stmt|;
comment|/* Note: Calling unregister here call Tcl_Close on the incrblob channel,     ** which deletes the IncrblobChannel structure at *p. So do not     ** call Tcl_Free() here.     */
name|Tcl_UnregisterChannel
argument_list|(
name|pDb
operator|->
name|interp
argument_list|,
name|p
operator|->
name|channel
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** Close an incremental blob channel. */
end_comment

begin_function
specifier|static
name|int
name|SQLITE_TCLAPI
name|incrblobClose
parameter_list|(
name|ClientData
name|instanceData
parameter_list|,
name|Tcl_Interp
modifier|*
name|interp
parameter_list|)
block|{
name|IncrblobChannel
modifier|*
name|p
init|=
operator|(
name|IncrblobChannel
operator|*
operator|)
name|instanceData
decl_stmt|;
name|int
name|rc
init|=
name|sqlite3_blob_close
argument_list|(
name|p
operator|->
name|pBlob
argument_list|)
decl_stmt|;
name|sqlite3
modifier|*
name|db
init|=
name|p
operator|->
name|pDb
operator|->
name|db
decl_stmt|;
comment|/* Remove the channel from the SqliteDb.pIncrblob list. */
if|if
condition|(
name|p
operator|->
name|pNext
condition|)
block|{
name|p
operator|->
name|pNext
operator|->
name|pPrev
operator|=
name|p
operator|->
name|pPrev
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|pPrev
condition|)
block|{
name|p
operator|->
name|pPrev
operator|->
name|pNext
operator|=
name|p
operator|->
name|pNext
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|pDb
operator|->
name|pIncrblob
operator|==
name|p
condition|)
block|{
name|p
operator|->
name|pDb
operator|->
name|pIncrblob
operator|=
name|p
operator|->
name|pNext
expr_stmt|;
block|}
comment|/* Free the IncrblobChannel structure */
name|Tcl_Free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sqlite3_errmsg
argument_list|(
name|db
argument_list|)
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_comment
comment|/* ** Read data from an incremental blob channel. */
end_comment

begin_function
specifier|static
name|int
name|SQLITE_TCLAPI
name|incrblobInput
parameter_list|(
name|ClientData
name|instanceData
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|bufSize
parameter_list|,
name|int
modifier|*
name|errorCodePtr
parameter_list|)
block|{
name|IncrblobChannel
modifier|*
name|p
init|=
operator|(
name|IncrblobChannel
operator|*
operator|)
name|instanceData
decl_stmt|;
name|int
name|nRead
init|=
name|bufSize
decl_stmt|;
comment|/* Number of bytes to read */
name|int
name|nBlob
decl_stmt|;
comment|/* Total size of the blob */
name|int
name|rc
decl_stmt|;
comment|/* sqlite error code */
name|nBlob
operator|=
name|sqlite3_blob_bytes
argument_list|(
name|p
operator|->
name|pBlob
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|iSeek
operator|+
name|nRead
operator|)
operator|>
name|nBlob
condition|)
block|{
name|nRead
operator|=
name|nBlob
operator|-
name|p
operator|->
name|iSeek
expr_stmt|;
block|}
if|if
condition|(
name|nRead
operator|<=
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|rc
operator|=
name|sqlite3_blob_read
argument_list|(
name|p
operator|->
name|pBlob
argument_list|,
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|,
name|nRead
argument_list|,
name|p
operator|->
name|iSeek
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
condition|)
block|{
operator|*
name|errorCodePtr
operator|=
name|rc
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p
operator|->
name|iSeek
operator|+=
name|nRead
expr_stmt|;
return|return
name|nRead
return|;
block|}
end_function

begin_comment
comment|/* ** Write data to an incremental blob channel. */
end_comment

begin_function
specifier|static
name|int
name|SQLITE_TCLAPI
name|incrblobOutput
parameter_list|(
name|ClientData
name|instanceData
parameter_list|,
name|CONST
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|toWrite
parameter_list|,
name|int
modifier|*
name|errorCodePtr
parameter_list|)
block|{
name|IncrblobChannel
modifier|*
name|p
init|=
operator|(
name|IncrblobChannel
operator|*
operator|)
name|instanceData
decl_stmt|;
name|int
name|nWrite
init|=
name|toWrite
decl_stmt|;
comment|/* Number of bytes to write */
name|int
name|nBlob
decl_stmt|;
comment|/* Total size of the blob */
name|int
name|rc
decl_stmt|;
comment|/* sqlite error code */
name|nBlob
operator|=
name|sqlite3_blob_bytes
argument_list|(
name|p
operator|->
name|pBlob
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|iSeek
operator|+
name|nWrite
operator|)
operator|>
name|nBlob
condition|)
block|{
operator|*
name|errorCodePtr
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|nWrite
operator|<=
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|rc
operator|=
name|sqlite3_blob_write
argument_list|(
name|p
operator|->
name|pBlob
argument_list|,
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|,
name|nWrite
argument_list|,
name|p
operator|->
name|iSeek
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
condition|)
block|{
operator|*
name|errorCodePtr
operator|=
name|EIO
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p
operator|->
name|iSeek
operator|+=
name|nWrite
expr_stmt|;
return|return
name|nWrite
return|;
block|}
end_function

begin_comment
comment|/* ** Seek an incremental blob channel. */
end_comment

begin_function
specifier|static
name|int
name|SQLITE_TCLAPI
name|incrblobSeek
parameter_list|(
name|ClientData
name|instanceData
parameter_list|,
name|long
name|offset
parameter_list|,
name|int
name|seekMode
parameter_list|,
name|int
modifier|*
name|errorCodePtr
parameter_list|)
block|{
name|IncrblobChannel
modifier|*
name|p
init|=
operator|(
name|IncrblobChannel
operator|*
operator|)
name|instanceData
decl_stmt|;
switch|switch
condition|(
name|seekMode
condition|)
block|{
case|case
name|SEEK_SET
case|:
name|p
operator|->
name|iSeek
operator|=
name|offset
expr_stmt|;
break|break;
case|case
name|SEEK_CUR
case|:
name|p
operator|->
name|iSeek
operator|+=
name|offset
expr_stmt|;
break|break;
case|case
name|SEEK_END
case|:
name|p
operator|->
name|iSeek
operator|=
name|sqlite3_blob_bytes
argument_list|(
name|p
operator|->
name|pBlob
argument_list|)
operator|+
name|offset
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
operator|!
literal|"Bad seekMode"
argument_list|)
expr_stmt|;
block|}
return|return
name|p
operator|->
name|iSeek
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|SQLITE_TCLAPI
name|incrblobWatch
parameter_list|(
name|ClientData
name|instanceData
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
comment|/* NO-OP */
block|}
end_function

begin_function
specifier|static
name|int
name|SQLITE_TCLAPI
name|incrblobHandle
parameter_list|(
name|ClientData
name|instanceData
parameter_list|,
name|int
name|dir
parameter_list|,
name|ClientData
modifier|*
name|hPtr
parameter_list|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|Tcl_ChannelType
name|IncrblobChannelType
init|=
block|{
literal|"incrblob"
block|,
comment|/* typeName                             */
name|TCL_CHANNEL_VERSION_2
block|,
comment|/* version                              */
name|incrblobClose
block|,
comment|/* closeProc                            */
name|incrblobInput
block|,
comment|/* inputProc                            */
name|incrblobOutput
block|,
comment|/* outputProc                           */
name|incrblobSeek
block|,
comment|/* seekProc                             */
literal|0
block|,
comment|/* setOptionProc                        */
literal|0
block|,
comment|/* getOptionProc                        */
name|incrblobWatch
block|,
comment|/* watchProc (this is a no-op)          */
name|incrblobHandle
block|,
comment|/* getHandleProc (always returns error) */
literal|0
block|,
comment|/* close2Proc                           */
literal|0
block|,
comment|/* blockModeProc                        */
literal|0
block|,
comment|/* flushProc                            */
literal|0
block|,
comment|/* handlerProc                          */
literal|0
block|,
comment|/* wideSeekProc                         */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** Create a new incrblob channel. */
end_comment

begin_function
specifier|static
name|int
name|createIncrblobChannel
parameter_list|(
name|Tcl_Interp
modifier|*
name|interp
parameter_list|,
name|SqliteDb
modifier|*
name|pDb
parameter_list|,
specifier|const
name|char
modifier|*
name|zDb
parameter_list|,
specifier|const
name|char
modifier|*
name|zTable
parameter_list|,
specifier|const
name|char
modifier|*
name|zColumn
parameter_list|,
name|sqlite_int64
name|iRow
parameter_list|,
name|int
name|isReadonly
parameter_list|)
block|{
name|IncrblobChannel
modifier|*
name|p
decl_stmt|;
name|sqlite3
modifier|*
name|db
init|=
name|pDb
operator|->
name|db
decl_stmt|;
name|sqlite3_blob
modifier|*
name|pBlob
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|int
name|flags
init|=
name|TCL_READABLE
operator||
operator|(
name|isReadonly
condition|?
literal|0
else|:
name|TCL_WRITABLE
operator|)
decl_stmt|;
comment|/* This variable is used to name the channels: "incrblob_[incr count]" */
specifier|static
name|int
name|count
init|=
literal|0
decl_stmt|;
name|char
name|zChannel
index|[
literal|64
index|]
decl_stmt|;
name|rc
operator|=
name|sqlite3_blob_open
argument_list|(
name|db
argument_list|,
name|zDb
argument_list|,
name|zTable
argument_list|,
name|zColumn
argument_list|,
name|iRow
argument_list|,
operator|!
name|isReadonly
argument_list|,
operator|&
name|pBlob
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sqlite3_errmsg
argument_list|(
name|pDb
operator|->
name|db
argument_list|)
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|p
operator|=
operator|(
name|IncrblobChannel
operator|*
operator|)
name|Tcl_Alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|IncrblobChannel
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|iSeek
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|pBlob
operator|=
name|pBlob
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|zChannel
argument_list|)
argument_list|,
name|zChannel
argument_list|,
literal|"incrblob_%d"
argument_list|,
operator|++
name|count
argument_list|)
expr_stmt|;
name|p
operator|->
name|channel
operator|=
name|Tcl_CreateChannel
argument_list|(
operator|&
name|IncrblobChannelType
argument_list|,
name|zChannel
argument_list|,
name|p
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|Tcl_RegisterChannel
argument_list|(
name|interp
argument_list|,
name|p
operator|->
name|channel
argument_list|)
expr_stmt|;
comment|/* Link the new channel into the SqliteDb.pIncrblob list. */
name|p
operator|->
name|pNext
operator|=
name|pDb
operator|->
name|pIncrblob
expr_stmt|;
name|p
operator|->
name|pPrev
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|pNext
condition|)
block|{
name|p
operator|->
name|pNext
operator|->
name|pPrev
operator|=
name|p
expr_stmt|;
block|}
name|pDb
operator|->
name|pIncrblob
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|pDb
operator|=
name|pDb
expr_stmt|;
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Tcl_GetChannelName
argument_list|(
name|p
operator|->
name|channel
argument_list|)
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* else clause for "#ifndef SQLITE_OMIT_INCRBLOB" */
end_comment

begin_define
define|#
directive|define
name|closeIncrblobChannels
parameter_list|(
name|pDb
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** Look at the script prefix in pCmd.  We will be executing this script ** after first appending one or more arguments.  This routine analyzes ** the script to see if it is safe to use Tcl_EvalObjv() on the script ** rather than the more general Tcl_EvalEx().  Tcl_EvalObjv() is much ** faster. ** ** Scripts that are safe to use with Tcl_EvalObjv() consists of a ** command name followed by zero or more arguments with no [...] or $ ** or {...} or ; to be seen anywhere.  Most callback scripts consist ** of just a single procedure name and they meet this requirement. */
end_comment

begin_function
specifier|static
name|int
name|safeToUseEvalObjv
parameter_list|(
name|Tcl_Interp
modifier|*
name|interp
parameter_list|,
name|Tcl_Obj
modifier|*
name|pCmd
parameter_list|)
block|{
comment|/* We could try to do something with Tcl_Parse().  But we will instead   ** just do a search for forbidden characters.  If any of the forbidden   ** characters appear in pCmd, we will report the string as unsafe.   */
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
name|int
name|n
decl_stmt|;
name|z
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|pCmd
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
name|int
name|c
init|=
operator|*
operator|(
name|z
operator|++
operator|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'$'
operator|||
name|c
operator|==
literal|'['
operator|||
name|c
operator|==
literal|';'
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ** Find an SqlFunc structure with the given name.  Or create a new ** one if an existing one cannot be found.  Return a pointer to the ** structure. */
end_comment

begin_function
specifier|static
name|SqlFunc
modifier|*
name|findSqlFunc
parameter_list|(
name|SqliteDb
modifier|*
name|pDb
parameter_list|,
specifier|const
name|char
modifier|*
name|zName
parameter_list|)
block|{
name|SqlFunc
modifier|*
name|p
decl_stmt|,
modifier|*
name|pNew
decl_stmt|;
name|int
name|nName
init|=
name|strlen30
argument_list|(
name|zName
argument_list|)
decl_stmt|;
name|pNew
operator|=
operator|(
name|SqlFunc
operator|*
operator|)
name|Tcl_Alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pNew
argument_list|)
operator|+
name|nName
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pNew
operator|->
name|zName
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|pNew
index|[
literal|1
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|pNew
operator|->
name|zName
argument_list|,
name|zName
argument_list|,
name|nName
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|pDb
operator|->
name|pFunc
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|pNext
control|)
block|{
if|if
condition|(
name|sqlite3_stricmp
argument_list|(
name|p
operator|->
name|zName
argument_list|,
name|pNew
operator|->
name|zName
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_Free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pNew
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
block|}
name|pNew
operator|->
name|interp
operator|=
name|pDb
operator|->
name|interp
expr_stmt|;
name|pNew
operator|->
name|pDb
operator|=
name|pDb
expr_stmt|;
name|pNew
operator|->
name|pScript
operator|=
literal|0
expr_stmt|;
name|pNew
operator|->
name|pNext
operator|=
name|pDb
operator|->
name|pFunc
expr_stmt|;
name|pDb
operator|->
name|pFunc
operator|=
name|pNew
expr_stmt|;
return|return
name|pNew
return|;
block|}
end_function

begin_comment
comment|/* ** Free a single SqlPreparedStmt object. */
end_comment

begin_function
specifier|static
name|void
name|dbFreeStmt
parameter_list|(
name|SqlPreparedStmt
modifier|*
name|pStmt
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SQLITE_TEST
if|if
condition|(
name|sqlite3_sql
argument_list|(
name|pStmt
operator|->
name|pStmt
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_Free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pStmt
operator|->
name|zSql
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sqlite3_finalize
argument_list|(
name|pStmt
operator|->
name|pStmt
argument_list|)
expr_stmt|;
name|Tcl_Free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pStmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Finalize and free a list of prepared statements */
end_comment

begin_function
specifier|static
name|void
name|flushStmtCache
parameter_list|(
name|SqliteDb
modifier|*
name|pDb
parameter_list|)
block|{
name|SqlPreparedStmt
modifier|*
name|pPreStmt
decl_stmt|;
name|SqlPreparedStmt
modifier|*
name|pNext
decl_stmt|;
for|for
control|(
name|pPreStmt
operator|=
name|pDb
operator|->
name|stmtList
init|;
name|pPreStmt
condition|;
name|pPreStmt
operator|=
name|pNext
control|)
block|{
name|pNext
operator|=
name|pPreStmt
operator|->
name|pNext
expr_stmt|;
name|dbFreeStmt
argument_list|(
name|pPreStmt
argument_list|)
expr_stmt|;
block|}
name|pDb
operator|->
name|nStmt
operator|=
literal|0
expr_stmt|;
name|pDb
operator|->
name|stmtLast
operator|=
literal|0
expr_stmt|;
name|pDb
operator|->
name|stmtList
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** TCL calls this procedure when an sqlite3 database command is ** deleted. */
end_comment

begin_function
specifier|static
name|void
name|SQLITE_TCLAPI
name|DbDeleteCmd
parameter_list|(
name|void
modifier|*
name|db
parameter_list|)
block|{
name|SqliteDb
modifier|*
name|pDb
init|=
operator|(
name|SqliteDb
operator|*
operator|)
name|db
decl_stmt|;
name|flushStmtCache
argument_list|(
name|pDb
argument_list|)
expr_stmt|;
name|closeIncrblobChannels
argument_list|(
name|pDb
argument_list|)
expr_stmt|;
name|sqlite3_close
argument_list|(
name|pDb
operator|->
name|db
argument_list|)
expr_stmt|;
while|while
condition|(
name|pDb
operator|->
name|pFunc
condition|)
block|{
name|SqlFunc
modifier|*
name|pFunc
init|=
name|pDb
operator|->
name|pFunc
decl_stmt|;
name|pDb
operator|->
name|pFunc
operator|=
name|pFunc
operator|->
name|pNext
expr_stmt|;
name|assert
argument_list|(
name|pFunc
operator|->
name|pDb
operator|==
name|pDb
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|pFunc
operator|->
name|pScript
argument_list|)
expr_stmt|;
name|Tcl_Free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pFunc
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|pDb
operator|->
name|pCollate
condition|)
block|{
name|SqlCollate
modifier|*
name|pCollate
init|=
name|pDb
operator|->
name|pCollate
decl_stmt|;
name|pDb
operator|->
name|pCollate
operator|=
name|pCollate
operator|->
name|pNext
expr_stmt|;
name|Tcl_Free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pCollate
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pDb
operator|->
name|zBusy
condition|)
block|{
name|Tcl_Free
argument_list|(
name|pDb
operator|->
name|zBusy
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pDb
operator|->
name|zTrace
condition|)
block|{
name|Tcl_Free
argument_list|(
name|pDb
operator|->
name|zTrace
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pDb
operator|->
name|zTraceV2
condition|)
block|{
name|Tcl_Free
argument_list|(
name|pDb
operator|->
name|zTraceV2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pDb
operator|->
name|zProfile
condition|)
block|{
name|Tcl_Free
argument_list|(
name|pDb
operator|->
name|zProfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pDb
operator|->
name|zAuth
condition|)
block|{
name|Tcl_Free
argument_list|(
name|pDb
operator|->
name|zAuth
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pDb
operator|->
name|zNull
condition|)
block|{
name|Tcl_Free
argument_list|(
name|pDb
operator|->
name|zNull
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pDb
operator|->
name|pUpdateHook
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|pDb
operator|->
name|pUpdateHook
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pDb
operator|->
name|pPreUpdateHook
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|pDb
operator|->
name|pPreUpdateHook
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pDb
operator|->
name|pRollbackHook
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|pDb
operator|->
name|pRollbackHook
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pDb
operator|->
name|pWalHook
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|pDb
operator|->
name|pWalHook
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pDb
operator|->
name|pCollateNeeded
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|pDb
operator|->
name|pCollateNeeded
argument_list|)
expr_stmt|;
block|}
name|Tcl_Free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pDb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** This routine is called when a database file is locked while trying ** to execute SQL. */
end_comment

begin_function
specifier|static
name|int
name|DbBusyHandler
parameter_list|(
name|void
modifier|*
name|cd
parameter_list|,
name|int
name|nTries
parameter_list|)
block|{
name|SqliteDb
modifier|*
name|pDb
init|=
operator|(
name|SqliteDb
operator|*
operator|)
name|cd
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|char
name|zVal
index|[
literal|30
index|]
decl_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|zVal
argument_list|)
argument_list|,
name|zVal
argument_list|,
literal|"%d"
argument_list|,
name|nTries
argument_list|)
expr_stmt|;
name|rc
operator|=
name|Tcl_VarEval
argument_list|(
name|pDb
operator|->
name|interp
argument_list|,
name|pDb
operator|->
name|zBusy
argument_list|,
literal|" "
argument_list|,
name|zVal
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|TCL_OK
operator|||
name|atoi
argument_list|(
name|Tcl_GetStringResult
argument_list|(
name|pDb
operator|->
name|interp
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SQLITE_OMIT_PROGRESS_CALLBACK
end_ifndef

begin_comment
comment|/* ** This routine is invoked as the 'progress callback' for the database. */
end_comment

begin_function
specifier|static
name|int
name|DbProgressHandler
parameter_list|(
name|void
modifier|*
name|cd
parameter_list|)
block|{
name|SqliteDb
modifier|*
name|pDb
init|=
operator|(
name|SqliteDb
operator|*
operator|)
name|cd
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|assert
argument_list|(
name|pDb
operator|->
name|zProgress
argument_list|)
expr_stmt|;
name|rc
operator|=
name|Tcl_Eval
argument_list|(
name|pDb
operator|->
name|interp
argument_list|,
name|pDb
operator|->
name|zProgress
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|TCL_OK
operator|||
name|atoi
argument_list|(
name|Tcl_GetStringResult
argument_list|(
name|pDb
operator|->
name|interp
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SQLITE_OMIT_TRACE
end_ifndef

begin_comment
comment|/* ** This routine is called by the SQLite trace handler whenever a new ** block of SQL is executed.  The TCL script in pDb->zTrace is executed. */
end_comment

begin_function
specifier|static
name|void
name|DbTraceHandler
parameter_list|(
name|void
modifier|*
name|cd
parameter_list|,
specifier|const
name|char
modifier|*
name|zSql
parameter_list|)
block|{
name|SqliteDb
modifier|*
name|pDb
init|=
operator|(
name|SqliteDb
operator|*
operator|)
name|cd
decl_stmt|;
name|Tcl_DString
name|str
decl_stmt|;
name|Tcl_DStringInit
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|str
argument_list|,
name|pDb
operator|->
name|zTrace
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_DStringAppendElement
argument_list|(
operator|&
name|str
argument_list|,
name|zSql
argument_list|)
expr_stmt|;
name|Tcl_Eval
argument_list|(
name|pDb
operator|->
name|interp
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|pDb
operator|->
name|interp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SQLITE_OMIT_TRACE
end_ifndef

begin_comment
comment|/* ** This routine is called by the SQLite trace_v2 handler whenever a new ** supported event is generated.  Unsupported event types are ignored. ** The TCL script in pDb->zTraceV2 is executed, with the arguments for ** the event appended to it (as list elements). */
end_comment

begin_function
specifier|static
name|int
name|DbTraceV2Handler
parameter_list|(
name|unsigned
name|type
parameter_list|,
comment|/* One of the SQLITE_TRACE_* event types. */
name|void
modifier|*
name|cd
parameter_list|,
comment|/* The original context data pointer. */
name|void
modifier|*
name|pd
parameter_list|,
comment|/* Primary event data, depends on event type. */
name|void
modifier|*
name|xd
comment|/* Extra event data, depends on event type. */
parameter_list|)
block|{
name|SqliteDb
modifier|*
name|pDb
init|=
operator|(
name|SqliteDb
operator|*
operator|)
name|cd
decl_stmt|;
name|Tcl_Obj
modifier|*
name|pCmd
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SQLITE_TRACE_STMT
case|:
block|{
name|sqlite3_stmt
modifier|*
name|pStmt
init|=
operator|(
name|sqlite3_stmt
operator|*
operator|)
name|pd
decl_stmt|;
name|char
modifier|*
name|zSql
init|=
operator|(
name|char
operator|*
operator|)
name|xd
decl_stmt|;
name|pCmd
operator|=
name|Tcl_NewStringObj
argument_list|(
name|pDb
operator|->
name|zTraceV2
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|pCmd
argument_list|)
expr_stmt|;
name|Tcl_ListObjAppendElement
argument_list|(
name|pDb
operator|->
name|interp
argument_list|,
name|pCmd
argument_list|,
name|Tcl_NewWideIntObj
argument_list|(
operator|(
name|Tcl_WideInt
operator|)
name|pStmt
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_ListObjAppendElement
argument_list|(
name|pDb
operator|->
name|interp
argument_list|,
name|pCmd
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|zSql
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_EvalObjEx
argument_list|(
name|pDb
operator|->
name|interp
argument_list|,
name|pCmd
argument_list|,
name|TCL_EVAL_DIRECT
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|pCmd
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|pDb
operator|->
name|interp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SQLITE_TRACE_PROFILE
case|:
block|{
name|sqlite3_stmt
modifier|*
name|pStmt
init|=
operator|(
name|sqlite3_stmt
operator|*
operator|)
name|pd
decl_stmt|;
name|sqlite3_int64
name|ns
init|=
operator|(
name|sqlite3_int64
operator|)
name|xd
decl_stmt|;
name|pCmd
operator|=
name|Tcl_NewStringObj
argument_list|(
name|pDb
operator|->
name|zTraceV2
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|pCmd
argument_list|)
expr_stmt|;
name|Tcl_ListObjAppendElement
argument_list|(
name|pDb
operator|->
name|interp
argument_list|,
name|pCmd
argument_list|,
name|Tcl_NewWideIntObj
argument_list|(
operator|(
name|Tcl_WideInt
operator|)
name|pStmt
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_ListObjAppendElement
argument_list|(
name|pDb
operator|->
name|interp
argument_list|,
name|pCmd
argument_list|,
name|Tcl_NewWideIntObj
argument_list|(
operator|(
name|Tcl_WideInt
operator|)
name|ns
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_EvalObjEx
argument_list|(
name|pDb
operator|->
name|interp
argument_list|,
name|pCmd
argument_list|,
name|TCL_EVAL_DIRECT
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|pCmd
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|pDb
operator|->
name|interp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SQLITE_TRACE_ROW
case|:
block|{
name|sqlite3_stmt
modifier|*
name|pStmt
init|=
operator|(
name|sqlite3_stmt
operator|*
operator|)
name|pd
decl_stmt|;
name|pCmd
operator|=
name|Tcl_NewStringObj
argument_list|(
name|pDb
operator|->
name|zTraceV2
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|pCmd
argument_list|)
expr_stmt|;
name|Tcl_ListObjAppendElement
argument_list|(
name|pDb
operator|->
name|interp
argument_list|,
name|pCmd
argument_list|,
name|Tcl_NewWideIntObj
argument_list|(
operator|(
name|Tcl_WideInt
operator|)
name|pStmt
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_EvalObjEx
argument_list|(
name|pDb
operator|->
name|interp
argument_list|,
name|pCmd
argument_list|,
name|TCL_EVAL_DIRECT
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|pCmd
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|pDb
operator|->
name|interp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SQLITE_TRACE_CLOSE
case|:
block|{
name|sqlite3
modifier|*
name|db
init|=
operator|(
name|sqlite3
operator|*
operator|)
name|pd
decl_stmt|;
name|pCmd
operator|=
name|Tcl_NewStringObj
argument_list|(
name|pDb
operator|->
name|zTraceV2
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|pCmd
argument_list|)
expr_stmt|;
name|Tcl_ListObjAppendElement
argument_list|(
name|pDb
operator|->
name|interp
argument_list|,
name|pCmd
argument_list|,
name|Tcl_NewWideIntObj
argument_list|(
operator|(
name|Tcl_WideInt
operator|)
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_EvalObjEx
argument_list|(
name|pDb
operator|->
name|interp
argument_list|,
name|pCmd
argument_list|,
name|TCL_EVAL_DIRECT
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|pCmd
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|pDb
operator|->
name|interp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|SQLITE_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SQLITE_OMIT_TRACE
end_ifndef

begin_comment
comment|/* ** This routine is called by the SQLite profile handler after a statement ** SQL has executed.  The TCL script in pDb->zProfile is evaluated. */
end_comment

begin_function
specifier|static
name|void
name|DbProfileHandler
parameter_list|(
name|void
modifier|*
name|cd
parameter_list|,
specifier|const
name|char
modifier|*
name|zSql
parameter_list|,
name|sqlite_uint64
name|tm
parameter_list|)
block|{
name|SqliteDb
modifier|*
name|pDb
init|=
operator|(
name|SqliteDb
operator|*
operator|)
name|cd
decl_stmt|;
name|Tcl_DString
name|str
decl_stmt|;
name|char
name|zTm
index|[
literal|100
index|]
decl_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|zTm
argument_list|)
operator|-
literal|1
argument_list|,
name|zTm
argument_list|,
literal|"%lld"
argument_list|,
name|tm
argument_list|)
expr_stmt|;
name|Tcl_DStringInit
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|str
argument_list|,
name|pDb
operator|->
name|zProfile
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_DStringAppendElement
argument_list|(
operator|&
name|str
argument_list|,
name|zSql
argument_list|)
expr_stmt|;
name|Tcl_DStringAppendElement
argument_list|(
operator|&
name|str
argument_list|,
name|zTm
argument_list|)
expr_stmt|;
name|Tcl_Eval
argument_list|(
name|pDb
operator|->
name|interp
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|pDb
operator|->
name|interp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** This routine is called when a transaction is committed.  The ** TCL script in pDb->zCommit is executed.  If it returns non-zero or ** if it throws an exception, the transaction is rolled back instead ** of being committed. */
end_comment

begin_function
specifier|static
name|int
name|DbCommitHandler
parameter_list|(
name|void
modifier|*
name|cd
parameter_list|)
block|{
name|SqliteDb
modifier|*
name|pDb
init|=
operator|(
name|SqliteDb
operator|*
operator|)
name|cd
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|Tcl_Eval
argument_list|(
name|pDb
operator|->
name|interp
argument_list|,
name|pDb
operator|->
name|zCommit
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|TCL_OK
operator|||
name|atoi
argument_list|(
name|Tcl_GetStringResult
argument_list|(
name|pDb
operator|->
name|interp
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|DbRollbackHandler
parameter_list|(
name|void
modifier|*
name|clientData
parameter_list|)
block|{
name|SqliteDb
modifier|*
name|pDb
init|=
operator|(
name|SqliteDb
operator|*
operator|)
name|clientData
decl_stmt|;
name|assert
argument_list|(
name|pDb
operator|->
name|pRollbackHook
argument_list|)
expr_stmt|;
if|if
condition|(
name|TCL_OK
operator|!=
name|Tcl_EvalObjEx
argument_list|(
name|pDb
operator|->
name|interp
argument_list|,
name|pDb
operator|->
name|pRollbackHook
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|Tcl_BackgroundError
argument_list|(
name|pDb
operator|->
name|interp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** This procedure handles wal_hook callbacks. */
end_comment

begin_function
specifier|static
name|int
name|DbWalHandler
parameter_list|(
name|void
modifier|*
name|clientData
parameter_list|,
name|sqlite3
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|zDb
parameter_list|,
name|int
name|nEntry
parameter_list|)
block|{
name|int
name|ret
init|=
name|SQLITE_OK
decl_stmt|;
name|Tcl_Obj
modifier|*
name|p
decl_stmt|;
name|SqliteDb
modifier|*
name|pDb
init|=
operator|(
name|SqliteDb
operator|*
operator|)
name|clientData
decl_stmt|;
name|Tcl_Interp
modifier|*
name|interp
init|=
name|pDb
operator|->
name|interp
decl_stmt|;
name|assert
argument_list|(
name|pDb
operator|->
name|pWalHook
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|db
operator|==
name|pDb
operator|->
name|db
argument_list|)
expr_stmt|;
name|p
operator|=
name|Tcl_DuplicateObj
argument_list|(
name|pDb
operator|->
name|pWalHook
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|p
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|zDb
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|p
argument_list|,
name|Tcl_NewIntObj
argument_list|(
name|nEntry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TCL_OK
operator|!=
name|Tcl_EvalObjEx
argument_list|(
name|interp
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
operator|||
name|TCL_OK
operator|!=
name|Tcl_GetIntFromObj
argument_list|(
name|interp
argument_list|,
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|,
operator|&
name|ret
argument_list|)
condition|)
block|{
name|Tcl_BackgroundError
argument_list|(
name|interp
argument_list|)
expr_stmt|;
block|}
name|Tcl_DecrRefCount
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_TEST
argument_list|)
operator|&&
name|defined
argument_list|(
name|SQLITE_ENABLE_UNLOCK_NOTIFY
argument_list|)
end_if

begin_function
specifier|static
name|void
name|setTestUnlockNotifyVars
parameter_list|(
name|Tcl_Interp
modifier|*
name|interp
parameter_list|,
name|int
name|iArg
parameter_list|,
name|int
name|nArg
parameter_list|)
block|{
name|char
name|zBuf
index|[
literal|64
index|]
decl_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|zBuf
argument_list|)
argument_list|,
name|zBuf
argument_list|,
literal|"%d"
argument_list|,
name|iArg
argument_list|)
expr_stmt|;
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
literal|"sqlite_unlock_notify_arg"
argument_list|,
name|zBuf
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|zBuf
argument_list|)
argument_list|,
name|zBuf
argument_list|,
literal|"%d"
argument_list|,
name|nArg
argument_list|)
expr_stmt|;
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
literal|"sqlite_unlock_notify_argcount"
argument_list|,
name|zBuf
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|setTestUnlockNotifyVars
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SQLITE_ENABLE_UNLOCK_NOTIFY
end_ifdef

begin_function
specifier|static
name|void
name|DbUnlockNotify
parameter_list|(
name|void
modifier|*
modifier|*
name|apArg
parameter_list|,
name|int
name|nArg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|int
name|flags
init|=
operator|(
name|TCL_EVAL_GLOBAL
operator||
name|TCL_EVAL_DIRECT
operator|)
decl_stmt|;
name|SqliteDb
modifier|*
name|pDb
init|=
operator|(
name|SqliteDb
operator|*
operator|)
name|apArg
index|[
name|i
index|]
decl_stmt|;
name|setTestUnlockNotifyVars
argument_list|(
name|pDb
operator|->
name|interp
argument_list|,
name|i
argument_list|,
name|nArg
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pDb
operator|->
name|pUnlockNotify
argument_list|)
expr_stmt|;
name|Tcl_EvalObjEx
argument_list|(
name|pDb
operator|->
name|interp
argument_list|,
name|pDb
operator|->
name|pUnlockNotify
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|pDb
operator|->
name|pUnlockNotify
argument_list|)
expr_stmt|;
name|pDb
operator|->
name|pUnlockNotify
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SQLITE_ENABLE_PREUPDATE_HOOK
end_ifdef

begin_comment
comment|/* ** Pre-update hook callback. */
end_comment

begin_function
specifier|static
name|void
name|DbPreUpdateHandler
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|sqlite3
modifier|*
name|db
parameter_list|,
name|int
name|op
parameter_list|,
specifier|const
name|char
modifier|*
name|zDb
parameter_list|,
specifier|const
name|char
modifier|*
name|zTbl
parameter_list|,
name|sqlite_int64
name|iKey1
parameter_list|,
name|sqlite_int64
name|iKey2
parameter_list|)
block|{
name|SqliteDb
modifier|*
name|pDb
init|=
operator|(
name|SqliteDb
operator|*
operator|)
name|p
decl_stmt|;
name|Tcl_Obj
modifier|*
name|pCmd
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|azStr
index|[]
init|=
block|{
literal|"DELETE"
block|,
literal|"INSERT"
block|,
literal|"UPDATE"
block|}
decl_stmt|;
name|assert
argument_list|(
operator|(
name|SQLITE_DELETE
operator|-
literal|1
operator|)
operator|/
literal|9
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|SQLITE_INSERT
operator|-
literal|1
operator|)
operator|/
literal|9
operator|==
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|SQLITE_UPDATE
operator|-
literal|1
operator|)
operator|/
literal|9
operator|==
literal|2
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pDb
operator|->
name|pPreUpdateHook
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|db
operator|==
name|pDb
operator|->
name|db
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|op
operator|==
name|SQLITE_INSERT
operator|||
name|op
operator|==
name|SQLITE_UPDATE
operator|||
name|op
operator|==
name|SQLITE_DELETE
argument_list|)
expr_stmt|;
name|pCmd
operator|=
name|Tcl_DuplicateObj
argument_list|(
name|pDb
operator|->
name|pPreUpdateHook
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|pCmd
argument_list|)
expr_stmt|;
name|Tcl_ListObjAppendElement
argument_list|(
literal|0
argument_list|,
name|pCmd
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|azStr
index|[
operator|(
name|op
operator|-
literal|1
operator|)
operator|/
literal|9
index|]
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_ListObjAppendElement
argument_list|(
literal|0
argument_list|,
name|pCmd
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|zDb
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_ListObjAppendElement
argument_list|(
literal|0
argument_list|,
name|pCmd
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|zTbl
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_ListObjAppendElement
argument_list|(
literal|0
argument_list|,
name|pCmd
argument_list|,
name|Tcl_NewWideIntObj
argument_list|(
name|iKey1
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_ListObjAppendElement
argument_list|(
literal|0
argument_list|,
name|pCmd
argument_list|,
name|Tcl_NewWideIntObj
argument_list|(
name|iKey2
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_EvalObjEx
argument_list|(
name|pDb
operator|->
name|interp
argument_list|,
name|pCmd
argument_list|,
name|TCL_EVAL_DIRECT
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|pCmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SQLITE_ENABLE_PREUPDATE_HOOK */
end_comment

begin_function
specifier|static
name|void
name|DbUpdateHandler
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|int
name|op
parameter_list|,
specifier|const
name|char
modifier|*
name|zDb
parameter_list|,
specifier|const
name|char
modifier|*
name|zTbl
parameter_list|,
name|sqlite_int64
name|rowid
parameter_list|)
block|{
name|SqliteDb
modifier|*
name|pDb
init|=
operator|(
name|SqliteDb
operator|*
operator|)
name|p
decl_stmt|;
name|Tcl_Obj
modifier|*
name|pCmd
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|azStr
index|[]
init|=
block|{
literal|"DELETE"
block|,
literal|"INSERT"
block|,
literal|"UPDATE"
block|}
decl_stmt|;
name|assert
argument_list|(
operator|(
name|SQLITE_DELETE
operator|-
literal|1
operator|)
operator|/
literal|9
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|SQLITE_INSERT
operator|-
literal|1
operator|)
operator|/
literal|9
operator|==
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|SQLITE_UPDATE
operator|-
literal|1
operator|)
operator|/
literal|9
operator|==
literal|2
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pDb
operator|->
name|pUpdateHook
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|op
operator|==
name|SQLITE_INSERT
operator|||
name|op
operator|==
name|SQLITE_UPDATE
operator|||
name|op
operator|==
name|SQLITE_DELETE
argument_list|)
expr_stmt|;
name|pCmd
operator|=
name|Tcl_DuplicateObj
argument_list|(
name|pDb
operator|->
name|pUpdateHook
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|pCmd
argument_list|)
expr_stmt|;
name|Tcl_ListObjAppendElement
argument_list|(
literal|0
argument_list|,
name|pCmd
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|azStr
index|[
operator|(
name|op
operator|-
literal|1
operator|)
operator|/
literal|9
index|]
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_ListObjAppendElement
argument_list|(
literal|0
argument_list|,
name|pCmd
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|zDb
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_ListObjAppendElement
argument_list|(
literal|0
argument_list|,
name|pCmd
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|zTbl
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_ListObjAppendElement
argument_list|(
literal|0
argument_list|,
name|pCmd
argument_list|,
name|Tcl_NewWideIntObj
argument_list|(
name|rowid
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_EvalObjEx
argument_list|(
name|pDb
operator|->
name|interp
argument_list|,
name|pCmd
argument_list|,
name|TCL_EVAL_DIRECT
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|pCmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tclCollateNeeded
parameter_list|(
name|void
modifier|*
name|pCtx
parameter_list|,
name|sqlite3
modifier|*
name|db
parameter_list|,
name|int
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|zName
parameter_list|)
block|{
name|SqliteDb
modifier|*
name|pDb
init|=
operator|(
name|SqliteDb
operator|*
operator|)
name|pCtx
decl_stmt|;
name|Tcl_Obj
modifier|*
name|pScript
init|=
name|Tcl_DuplicateObj
argument_list|(
name|pDb
operator|->
name|pCollateNeeded
argument_list|)
decl_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|pScript
argument_list|)
expr_stmt|;
name|Tcl_ListObjAppendElement
argument_list|(
literal|0
argument_list|,
name|pScript
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|zName
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_EvalObjEx
argument_list|(
name|pDb
operator|->
name|interp
argument_list|,
name|pScript
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|pScript
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** This routine is called to evaluate an SQL collation function implemented ** using TCL script. */
end_comment

begin_function
specifier|static
name|int
name|tclSqlCollate
parameter_list|(
name|void
modifier|*
name|pCtx
parameter_list|,
name|int
name|nA
parameter_list|,
specifier|const
name|void
modifier|*
name|zA
parameter_list|,
name|int
name|nB
parameter_list|,
specifier|const
name|void
modifier|*
name|zB
parameter_list|)
block|{
name|SqlCollate
modifier|*
name|p
init|=
operator|(
name|SqlCollate
operator|*
operator|)
name|pCtx
decl_stmt|;
name|Tcl_Obj
modifier|*
name|pCmd
decl_stmt|;
name|pCmd
operator|=
name|Tcl_NewStringObj
argument_list|(
name|p
operator|->
name|zScript
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|pCmd
argument_list|)
expr_stmt|;
name|Tcl_ListObjAppendElement
argument_list|(
name|p
operator|->
name|interp
argument_list|,
name|pCmd
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|zA
argument_list|,
name|nA
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_ListObjAppendElement
argument_list|(
name|p
operator|->
name|interp
argument_list|,
name|pCmd
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|zB
argument_list|,
name|nB
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_EvalObjEx
argument_list|(
name|p
operator|->
name|interp
argument_list|,
name|pCmd
argument_list|,
name|TCL_EVAL_DIRECT
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|pCmd
argument_list|)
expr_stmt|;
return|return
operator|(
name|atoi
argument_list|(
name|Tcl_GetStringResult
argument_list|(
name|p
operator|->
name|interp
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** This routine is called to evaluate an SQL function implemented ** using TCL script. */
end_comment

begin_function
specifier|static
name|void
name|tclSqlFunc
parameter_list|(
name|sqlite3_context
modifier|*
name|context
parameter_list|,
name|int
name|argc
parameter_list|,
name|sqlite3_value
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|SqlFunc
modifier|*
name|p
init|=
name|sqlite3_user_data
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|Tcl_Obj
modifier|*
name|pCmd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
comment|/* If there are no arguments to the function, call Tcl_EvalObjEx on the     ** script object directly.  This allows the TCL compiler to generate     ** bytecode for the command on the first invocation and thus make     ** subsequent invocations much faster. */
name|pCmd
operator|=
name|p
operator|->
name|pScript
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|pCmd
argument_list|)
expr_stmt|;
name|rc
operator|=
name|Tcl_EvalObjEx
argument_list|(
name|p
operator|->
name|interp
argument_list|,
name|pCmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|pCmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If there are arguments to the function, make a shallow copy of the     ** script object, lappend the arguments, then evaluate the copy.     **     ** By "shallow" copy, we mean only the outer list Tcl_Obj is duplicated.     ** The new Tcl_Obj contains pointers to the original list elements.     ** That way, when Tcl_EvalObjv() is run and shimmers the first element     ** of the list to tclCmdNameType, that alternate representation will     ** be preserved and reused on the next invocation.     */
name|Tcl_Obj
modifier|*
modifier|*
name|aArg
decl_stmt|;
name|int
name|nArg
decl_stmt|;
if|if
condition|(
name|Tcl_ListObjGetElements
argument_list|(
name|p
operator|->
name|interp
argument_list|,
name|p
operator|->
name|pScript
argument_list|,
operator|&
name|nArg
argument_list|,
operator|&
name|aArg
argument_list|)
condition|)
block|{
name|sqlite3_result_error
argument_list|(
name|context
argument_list|,
name|Tcl_GetStringResult
argument_list|(
name|p
operator|->
name|interp
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|pCmd
operator|=
name|Tcl_NewListObj
argument_list|(
name|nArg
argument_list|,
name|aArg
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|pCmd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|sqlite3_value
modifier|*
name|pIn
init|=
name|argv
index|[
name|i
index|]
decl_stmt|;
name|Tcl_Obj
modifier|*
name|pVal
decl_stmt|;
comment|/* Set pVal to contain the i'th column of this row. */
switch|switch
condition|(
name|sqlite3_value_type
argument_list|(
name|pIn
argument_list|)
condition|)
block|{
case|case
name|SQLITE_BLOB
case|:
block|{
name|int
name|bytes
init|=
name|sqlite3_value_bytes
argument_list|(
name|pIn
argument_list|)
decl_stmt|;
name|pVal
operator|=
name|Tcl_NewByteArrayObj
argument_list|(
name|sqlite3_value_blob
argument_list|(
name|pIn
argument_list|)
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SQLITE_INTEGER
case|:
block|{
name|sqlite_int64
name|v
init|=
name|sqlite3_value_int64
argument_list|(
name|pIn
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|>=
operator|-
literal|2147483647
operator|&&
name|v
operator|<=
literal|2147483647
condition|)
block|{
name|pVal
operator|=
name|Tcl_NewIntObj
argument_list|(
operator|(
name|int
operator|)
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pVal
operator|=
name|Tcl_NewWideIntObj
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SQLITE_FLOAT
case|:
block|{
name|double
name|r
init|=
name|sqlite3_value_double
argument_list|(
name|pIn
argument_list|)
decl_stmt|;
name|pVal
operator|=
name|Tcl_NewDoubleObj
argument_list|(
name|r
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SQLITE_NULL
case|:
block|{
name|pVal
operator|=
name|Tcl_NewStringObj
argument_list|(
name|p
operator|->
name|pDb
operator|->
name|zNull
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
name|int
name|bytes
init|=
name|sqlite3_value_bytes
argument_list|(
name|pIn
argument_list|)
decl_stmt|;
name|pVal
operator|=
name|Tcl_NewStringObj
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sqlite3_value_text
argument_list|(
name|pIn
argument_list|)
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|rc
operator|=
name|Tcl_ListObjAppendElement
argument_list|(
name|p
operator|->
name|interp
argument_list|,
name|pCmd
argument_list|,
name|pVal
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|pCmd
argument_list|)
expr_stmt|;
name|sqlite3_result_error
argument_list|(
name|context
argument_list|,
name|Tcl_GetStringResult
argument_list|(
name|p
operator|->
name|interp
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|p
operator|->
name|useEvalObjv
condition|)
block|{
comment|/* Tcl_EvalObjEx() will automatically call Tcl_EvalObjv() if pCmd       ** is a list without a string representation.  To prevent this from       ** happening, make sure pCmd has a valid string representation */
name|Tcl_GetString
argument_list|(
name|pCmd
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|Tcl_EvalObjEx
argument_list|(
name|p
operator|->
name|interp
argument_list|,
name|pCmd
argument_list|,
name|TCL_EVAL_DIRECT
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|pCmd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|&&
name|rc
operator|!=
name|TCL_RETURN
condition|)
block|{
name|sqlite3_result_error
argument_list|(
name|context
argument_list|,
name|Tcl_GetStringResult
argument_list|(
name|p
operator|->
name|interp
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_Obj
modifier|*
name|pVar
init|=
name|Tcl_GetObjResult
argument_list|(
name|p
operator|->
name|interp
argument_list|)
decl_stmt|;
name|int
name|n
decl_stmt|;
name|u8
modifier|*
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|zType
init|=
operator|(
name|pVar
operator|->
name|typePtr
condition|?
name|pVar
operator|->
name|typePtr
operator|->
name|name
else|:
literal|""
operator|)
decl_stmt|;
name|char
name|c
init|=
name|zType
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'b'
operator|&&
name|strcmp
argument_list|(
name|zType
argument_list|,
literal|"bytearray"
argument_list|)
operator|==
literal|0
operator|&&
name|pVar
operator|->
name|bytes
operator|==
literal|0
condition|)
block|{
comment|/* Only return a BLOB type if the Tcl variable is a bytearray and       ** has no string representation. */
name|data
operator|=
name|Tcl_GetByteArrayFromObj
argument_list|(
name|pVar
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|sqlite3_result_blob
argument_list|(
name|context
argument_list|,
name|data
argument_list|,
name|n
argument_list|,
name|SQLITE_TRANSIENT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'b'
operator|&&
name|strcmp
argument_list|(
name|zType
argument_list|,
literal|"boolean"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_GetIntFromObj
argument_list|(
literal|0
argument_list|,
name|pVar
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|sqlite3_result_int
argument_list|(
name|context
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'d'
operator|&&
name|strcmp
argument_list|(
name|zType
argument_list|,
literal|"double"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|double
name|r
decl_stmt|;
name|Tcl_GetDoubleFromObj
argument_list|(
literal|0
argument_list|,
name|pVar
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|sqlite3_result_double
argument_list|(
name|context
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'w'
operator|&&
name|strcmp
argument_list|(
name|zType
argument_list|,
literal|"wideInt"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|c
operator|==
literal|'i'
operator|&&
name|strcmp
argument_list|(
name|zType
argument_list|,
literal|"int"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|Tcl_WideInt
name|v
decl_stmt|;
name|Tcl_GetWideIntFromObj
argument_list|(
literal|0
argument_list|,
name|pVar
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
name|sqlite3_result_int64
argument_list|(
name|context
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|Tcl_GetStringFromObj
argument_list|(
name|pVar
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|sqlite3_result_text
argument_list|(
name|context
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|n
argument_list|,
name|SQLITE_TRANSIENT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SQLITE_OMIT_AUTHORIZATION
end_ifndef

begin_comment
comment|/* ** This is the authentication function.  It appends the authentication ** type code and the two arguments to zCmd[] then invokes the result ** on the interpreter.  The reply is examined to determine if the ** authentication fails or succeeds. */
end_comment

begin_function
specifier|static
name|int
name|auth_callback
parameter_list|(
name|void
modifier|*
name|pArg
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|zArg1
parameter_list|,
specifier|const
name|char
modifier|*
name|zArg2
parameter_list|,
specifier|const
name|char
modifier|*
name|zArg3
parameter_list|,
specifier|const
name|char
modifier|*
name|zArg4
ifdef|#
directive|ifdef
name|SQLITE_USER_AUTHENTICATION
parameter_list|,
specifier|const
name|char
modifier|*
name|zArg5
endif|#
directive|endif
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|zCode
decl_stmt|;
name|Tcl_DString
name|str
decl_stmt|;
name|int
name|rc
decl_stmt|;
specifier|const
name|char
modifier|*
name|zReply
decl_stmt|;
name|SqliteDb
modifier|*
name|pDb
init|=
operator|(
name|SqliteDb
operator|*
operator|)
name|pArg
decl_stmt|;
if|if
condition|(
name|pDb
operator|->
name|disableAuth
condition|)
return|return
name|SQLITE_OK
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SQLITE_COPY
case|:
name|zCode
operator|=
literal|"SQLITE_COPY"
expr_stmt|;
break|break;
case|case
name|SQLITE_CREATE_INDEX
case|:
name|zCode
operator|=
literal|"SQLITE_CREATE_INDEX"
expr_stmt|;
break|break;
case|case
name|SQLITE_CREATE_TABLE
case|:
name|zCode
operator|=
literal|"SQLITE_CREATE_TABLE"
expr_stmt|;
break|break;
case|case
name|SQLITE_CREATE_TEMP_INDEX
case|:
name|zCode
operator|=
literal|"SQLITE_CREATE_TEMP_INDEX"
expr_stmt|;
break|break;
case|case
name|SQLITE_CREATE_TEMP_TABLE
case|:
name|zCode
operator|=
literal|"SQLITE_CREATE_TEMP_TABLE"
expr_stmt|;
break|break;
case|case
name|SQLITE_CREATE_TEMP_TRIGGER
case|:
name|zCode
operator|=
literal|"SQLITE_CREATE_TEMP_TRIGGER"
expr_stmt|;
break|break;
case|case
name|SQLITE_CREATE_TEMP_VIEW
case|:
name|zCode
operator|=
literal|"SQLITE_CREATE_TEMP_VIEW"
expr_stmt|;
break|break;
case|case
name|SQLITE_CREATE_TRIGGER
case|:
name|zCode
operator|=
literal|"SQLITE_CREATE_TRIGGER"
expr_stmt|;
break|break;
case|case
name|SQLITE_CREATE_VIEW
case|:
name|zCode
operator|=
literal|"SQLITE_CREATE_VIEW"
expr_stmt|;
break|break;
case|case
name|SQLITE_DELETE
case|:
name|zCode
operator|=
literal|"SQLITE_DELETE"
expr_stmt|;
break|break;
case|case
name|SQLITE_DROP_INDEX
case|:
name|zCode
operator|=
literal|"SQLITE_DROP_INDEX"
expr_stmt|;
break|break;
case|case
name|SQLITE_DROP_TABLE
case|:
name|zCode
operator|=
literal|"SQLITE_DROP_TABLE"
expr_stmt|;
break|break;
case|case
name|SQLITE_DROP_TEMP_INDEX
case|:
name|zCode
operator|=
literal|"SQLITE_DROP_TEMP_INDEX"
expr_stmt|;
break|break;
case|case
name|SQLITE_DROP_TEMP_TABLE
case|:
name|zCode
operator|=
literal|"SQLITE_DROP_TEMP_TABLE"
expr_stmt|;
break|break;
case|case
name|SQLITE_DROP_TEMP_TRIGGER
case|:
name|zCode
operator|=
literal|"SQLITE_DROP_TEMP_TRIGGER"
expr_stmt|;
break|break;
case|case
name|SQLITE_DROP_TEMP_VIEW
case|:
name|zCode
operator|=
literal|"SQLITE_DROP_TEMP_VIEW"
expr_stmt|;
break|break;
case|case
name|SQLITE_DROP_TRIGGER
case|:
name|zCode
operator|=
literal|"SQLITE_DROP_TRIGGER"
expr_stmt|;
break|break;
case|case
name|SQLITE_DROP_VIEW
case|:
name|zCode
operator|=
literal|"SQLITE_DROP_VIEW"
expr_stmt|;
break|break;
case|case
name|SQLITE_INSERT
case|:
name|zCode
operator|=
literal|"SQLITE_INSERT"
expr_stmt|;
break|break;
case|case
name|SQLITE_PRAGMA
case|:
name|zCode
operator|=
literal|"SQLITE_PRAGMA"
expr_stmt|;
break|break;
case|case
name|SQLITE_READ
case|:
name|zCode
operator|=
literal|"SQLITE_READ"
expr_stmt|;
break|break;
case|case
name|SQLITE_SELECT
case|:
name|zCode
operator|=
literal|"SQLITE_SELECT"
expr_stmt|;
break|break;
case|case
name|SQLITE_TRANSACTION
case|:
name|zCode
operator|=
literal|"SQLITE_TRANSACTION"
expr_stmt|;
break|break;
case|case
name|SQLITE_UPDATE
case|:
name|zCode
operator|=
literal|"SQLITE_UPDATE"
expr_stmt|;
break|break;
case|case
name|SQLITE_ATTACH
case|:
name|zCode
operator|=
literal|"SQLITE_ATTACH"
expr_stmt|;
break|break;
case|case
name|SQLITE_DETACH
case|:
name|zCode
operator|=
literal|"SQLITE_DETACH"
expr_stmt|;
break|break;
case|case
name|SQLITE_ALTER_TABLE
case|:
name|zCode
operator|=
literal|"SQLITE_ALTER_TABLE"
expr_stmt|;
break|break;
case|case
name|SQLITE_REINDEX
case|:
name|zCode
operator|=
literal|"SQLITE_REINDEX"
expr_stmt|;
break|break;
case|case
name|SQLITE_ANALYZE
case|:
name|zCode
operator|=
literal|"SQLITE_ANALYZE"
expr_stmt|;
break|break;
case|case
name|SQLITE_CREATE_VTABLE
case|:
name|zCode
operator|=
literal|"SQLITE_CREATE_VTABLE"
expr_stmt|;
break|break;
case|case
name|SQLITE_DROP_VTABLE
case|:
name|zCode
operator|=
literal|"SQLITE_DROP_VTABLE"
expr_stmt|;
break|break;
case|case
name|SQLITE_FUNCTION
case|:
name|zCode
operator|=
literal|"SQLITE_FUNCTION"
expr_stmt|;
break|break;
case|case
name|SQLITE_SAVEPOINT
case|:
name|zCode
operator|=
literal|"SQLITE_SAVEPOINT"
expr_stmt|;
break|break;
case|case
name|SQLITE_RECURSIVE
case|:
name|zCode
operator|=
literal|"SQLITE_RECURSIVE"
expr_stmt|;
break|break;
default|default                       :
name|zCode
operator|=
literal|"????"
expr_stmt|;
break|break;
block|}
name|Tcl_DStringInit
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
name|Tcl_DStringAppend
argument_list|(
operator|&
name|str
argument_list|,
name|pDb
operator|->
name|zAuth
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_DStringAppendElement
argument_list|(
operator|&
name|str
argument_list|,
name|zCode
argument_list|)
expr_stmt|;
name|Tcl_DStringAppendElement
argument_list|(
operator|&
name|str
argument_list|,
name|zArg1
condition|?
name|zArg1
else|:
literal|""
argument_list|)
expr_stmt|;
name|Tcl_DStringAppendElement
argument_list|(
operator|&
name|str
argument_list|,
name|zArg2
condition|?
name|zArg2
else|:
literal|""
argument_list|)
expr_stmt|;
name|Tcl_DStringAppendElement
argument_list|(
operator|&
name|str
argument_list|,
name|zArg3
condition|?
name|zArg3
else|:
literal|""
argument_list|)
expr_stmt|;
name|Tcl_DStringAppendElement
argument_list|(
operator|&
name|str
argument_list|,
name|zArg4
condition|?
name|zArg4
else|:
literal|""
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SQLITE_USER_AUTHENTICATION
name|Tcl_DStringAppendElement
argument_list|(
operator|&
name|str
argument_list|,
name|zArg5
condition|?
name|zArg5
else|:
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rc
operator|=
name|Tcl_GlobalEval
argument_list|(
name|pDb
operator|->
name|interp
argument_list|,
name|Tcl_DStringValue
argument_list|(
operator|&
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
name|zReply
operator|=
name|rc
operator|==
name|TCL_OK
condition|?
name|Tcl_GetStringResult
argument_list|(
name|pDb
operator|->
name|interp
argument_list|)
else|:
literal|"SQLITE_DENY"
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|zReply
argument_list|,
literal|"SQLITE_OK"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|SQLITE_OK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|zReply
argument_list|,
literal|"SQLITE_DENY"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|SQLITE_DENY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|zReply
argument_list|,
literal|"SQLITE_IGNORE"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|SQLITE_IGNORE
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
literal|999
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SQLITE_OMIT_AUTHORIZATION */
end_comment

begin_comment
comment|/* ** This routine reads a line of text from FILE in, stores ** the text in memory obtained from malloc() and returns a pointer ** to the text.  NULL is returned at end of file, or if malloc() ** fails. ** ** The interface is like "readline" but no command-line editing ** is done. ** ** copied from shell.c from '.import' command */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|local_getline
parameter_list|(
name|char
modifier|*
name|zPrompt
parameter_list|,
name|FILE
modifier|*
name|in
parameter_list|)
block|{
name|char
modifier|*
name|zLine
decl_stmt|;
name|int
name|nLine
decl_stmt|;
name|int
name|n
decl_stmt|;
name|nLine
operator|=
literal|100
expr_stmt|;
name|zLine
operator|=
name|malloc
argument_list|(
name|nLine
argument_list|)
expr_stmt|;
if|if
condition|(
name|zLine
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|n
operator|+
literal|100
operator|>
name|nLine
condition|)
block|{
name|nLine
operator|=
name|nLine
operator|*
literal|2
operator|+
literal|100
expr_stmt|;
name|zLine
operator|=
name|realloc
argument_list|(
name|zLine
argument_list|,
name|nLine
argument_list|)
expr_stmt|;
if|if
condition|(
name|zLine
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fgets
argument_list|(
operator|&
name|zLine
index|[
name|n
index|]
argument_list|,
name|nLine
operator|-
name|n
argument_list|,
name|in
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|zLine
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|zLine
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|zLine
index|[
name|n
index|]
condition|)
block|{
name|n
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
name|zLine
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|n
operator|--
expr_stmt|;
name|zLine
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|zLine
operator|=
name|realloc
argument_list|(
name|zLine
argument_list|,
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|zLine
return|;
block|}
end_function

begin_comment
comment|/* ** This function is part of the implementation of the command: ** **   $db transaction [-deferred|-immediate|-exclusive] SCRIPT ** ** It is invoked after evaluating the script SCRIPT to commit or rollback ** the transaction or savepoint opened by the [transaction] command. */
end_comment

begin_function
specifier|static
name|int
name|SQLITE_TCLAPI
name|DbTransPostCmd
parameter_list|(
name|ClientData
name|data
index|[]
parameter_list|,
comment|/* data[0] is the Sqlite3Db* for $db */
name|Tcl_Interp
modifier|*
name|interp
parameter_list|,
comment|/* Tcl interpreter */
name|int
name|result
comment|/* Result of evaluating SCRIPT */
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|azEnd
index|[]
init|=
block|{
literal|"RELEASE _tcl_transaction"
block|,
comment|/* rc==TCL_ERROR, nTransaction!=0 */
literal|"COMMIT"
block|,
comment|/* rc!=TCL_ERROR, nTransaction==0 */
literal|"ROLLBACK TO _tcl_transaction ; RELEASE _tcl_transaction"
block|,
literal|"ROLLBACK"
comment|/* rc==TCL_ERROR, nTransaction==0 */
block|}
decl_stmt|;
name|SqliteDb
modifier|*
name|pDb
init|=
operator|(
name|SqliteDb
operator|*
operator|)
name|data
index|[
literal|0
index|]
decl_stmt|;
name|int
name|rc
init|=
name|result
decl_stmt|;
specifier|const
name|char
modifier|*
name|zEnd
decl_stmt|;
name|pDb
operator|->
name|nTransaction
operator|--
expr_stmt|;
name|zEnd
operator|=
name|azEnd
index|[
operator|(
name|rc
operator|==
name|TCL_ERROR
operator|)
operator|*
literal|2
operator|+
operator|(
name|pDb
operator|->
name|nTransaction
operator|==
literal|0
operator|)
index|]
expr_stmt|;
name|pDb
operator|->
name|disableAuth
operator|++
expr_stmt|;
if|if
condition|(
name|sqlite3_exec
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
name|zEnd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* This is a tricky scenario to handle. The most likely cause of an       ** error is that the exec() above was an attempt to commit the       ** top-level transaction that returned SQLITE_BUSY. Or, less likely,       ** that an IO-error has occurred. In either case, throw a Tcl exception       ** and try to rollback the transaction.       **       ** But it could also be that the user executed one or more BEGIN,       ** COMMIT, SAVEPOINT, RELEASE or ROLLBACK commands that are confusing       ** this method's logic. Not clear how this would be best handled.       */
if|if
condition|(
name|rc
operator|!=
name|TCL_ERROR
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|pDb
operator|->
name|db
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
name|sqlite3_exec
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
literal|"ROLLBACK"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|pDb
operator|->
name|disableAuth
operator|--
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* ** Unless SQLITE_TEST is defined, this function is a simple wrapper around ** sqlite3_prepare_v2(). If SQLITE_TEST is defined, then it uses either ** sqlite3_prepare_v2() or legacy interface sqlite3_prepare(), depending ** on whether or not the [db_use_legacy_prepare] command has been used to ** configure the connection. */
end_comment

begin_function
specifier|static
name|int
name|dbPrepare
parameter_list|(
name|SqliteDb
modifier|*
name|pDb
parameter_list|,
comment|/* Database object */
specifier|const
name|char
modifier|*
name|zSql
parameter_list|,
comment|/* SQL to compile */
name|sqlite3_stmt
modifier|*
modifier|*
name|ppStmt
parameter_list|,
comment|/* OUT: Prepared statement */
specifier|const
name|char
modifier|*
modifier|*
name|pzOut
comment|/* OUT: Pointer to next SQL statement */
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SQLITE_TEST
if|if
condition|(
name|pDb
operator|->
name|bLegacyPrepare
condition|)
block|{
return|return
name|sqlite3_prepare
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
name|zSql
argument_list|,
operator|-
literal|1
argument_list|,
name|ppStmt
argument_list|,
name|pzOut
argument_list|)
return|;
block|}
endif|#
directive|endif
return|return
name|sqlite3_prepare_v2
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
name|zSql
argument_list|,
operator|-
literal|1
argument_list|,
name|ppStmt
argument_list|,
name|pzOut
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ** Search the cache for a prepared-statement object that implements the ** first SQL statement in the buffer pointed to by parameter zIn. If ** no such prepared-statement can be found, allocate and prepare a new ** one. In either case, bind the current values of the relevant Tcl ** variables to any $var, :var or @var variables in the statement. Before ** returning, set *ppPreStmt to point to the prepared-statement object. ** ** Output parameter *pzOut is set to point to the next SQL statement in ** buffer zIn, or to the '\0' byte at the end of zIn if there is no ** next statement. ** ** If successful, TCL_OK is returned. Otherwise, TCL_ERROR is returned ** and an error message loaded into interpreter pDb->interp. */
end_comment

begin_function
specifier|static
name|int
name|dbPrepareAndBind
parameter_list|(
name|SqliteDb
modifier|*
name|pDb
parameter_list|,
comment|/* Database object */
name|char
specifier|const
modifier|*
name|zIn
parameter_list|,
comment|/* SQL to compile */
name|char
specifier|const
modifier|*
modifier|*
name|pzOut
parameter_list|,
comment|/* OUT: Pointer to next SQL statement */
name|SqlPreparedStmt
modifier|*
modifier|*
name|ppPreStmt
comment|/* OUT: Object used to cache statement */
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|zSql
init|=
name|zIn
decl_stmt|;
comment|/* Pointer to first SQL statement in zIn */
name|sqlite3_stmt
modifier|*
name|pStmt
init|=
literal|0
decl_stmt|;
comment|/* Prepared statement object */
name|SqlPreparedStmt
modifier|*
name|pPreStmt
decl_stmt|;
comment|/* Pointer to cached statement */
name|int
name|nSql
decl_stmt|;
comment|/* Length of zSql in bytes */
name|int
name|nVar
init|=
literal|0
decl_stmt|;
comment|/* Number of variables in statement */
name|int
name|iParm
init|=
literal|0
decl_stmt|;
comment|/* Next free entry in apParm */
name|char
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|Tcl_Interp
modifier|*
name|interp
init|=
name|pDb
operator|->
name|interp
decl_stmt|;
operator|*
name|ppPreStmt
operator|=
literal|0
expr_stmt|;
comment|/* Trim spaces from the start of zSql and calculate the remaining length. */
while|while
condition|(
operator|(
name|c
operator|=
name|zSql
index|[
literal|0
index|]
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\r'
operator|||
name|c
operator|==
literal|'\n'
condition|)
block|{
name|zSql
operator|++
expr_stmt|;
block|}
name|nSql
operator|=
name|strlen30
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
for|for
control|(
name|pPreStmt
operator|=
name|pDb
operator|->
name|stmtList
init|;
name|pPreStmt
condition|;
name|pPreStmt
operator|=
name|pPreStmt
operator|->
name|pNext
control|)
block|{
name|int
name|n
init|=
name|pPreStmt
operator|->
name|nSql
decl_stmt|;
if|if
condition|(
name|nSql
operator|>=
name|n
operator|&&
name|memcmp
argument_list|(
name|pPreStmt
operator|->
name|zSql
argument_list|,
name|zSql
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|zSql
index|[
name|n
index|]
operator|==
literal|0
operator|||
name|zSql
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|';'
operator|)
condition|)
block|{
name|pStmt
operator|=
name|pPreStmt
operator|->
name|pStmt
expr_stmt|;
operator|*
name|pzOut
operator|=
operator|&
name|zSql
index|[
name|pPreStmt
operator|->
name|nSql
index|]
expr_stmt|;
comment|/* When a prepared statement is found, unlink it from the       ** cache list.  It will later be added back to the beginning       ** of the cache list in order to implement LRU replacement.       */
if|if
condition|(
name|pPreStmt
operator|->
name|pPrev
condition|)
block|{
name|pPreStmt
operator|->
name|pPrev
operator|->
name|pNext
operator|=
name|pPreStmt
operator|->
name|pNext
expr_stmt|;
block|}
else|else
block|{
name|pDb
operator|->
name|stmtList
operator|=
name|pPreStmt
operator|->
name|pNext
expr_stmt|;
block|}
if|if
condition|(
name|pPreStmt
operator|->
name|pNext
condition|)
block|{
name|pPreStmt
operator|->
name|pNext
operator|->
name|pPrev
operator|=
name|pPreStmt
operator|->
name|pPrev
expr_stmt|;
block|}
else|else
block|{
name|pDb
operator|->
name|stmtLast
operator|=
name|pPreStmt
operator|->
name|pPrev
expr_stmt|;
block|}
name|pDb
operator|->
name|nStmt
operator|--
expr_stmt|;
name|nVar
operator|=
name|sqlite3_bind_parameter_count
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* If no prepared statement was found. Compile the SQL text. Also allocate   ** a new SqlPreparedStmt structure.  */
if|if
condition|(
name|pPreStmt
operator|==
literal|0
condition|)
block|{
name|int
name|nByte
decl_stmt|;
if|if
condition|(
name|SQLITE_OK
operator|!=
name|dbPrepare
argument_list|(
name|pDb
argument_list|,
name|zSql
argument_list|,
operator|&
name|pStmt
argument_list|,
name|pzOut
argument_list|)
condition|)
block|{
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|sqlite3_errmsg
argument_list|(
name|pDb
operator|->
name|db
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|pStmt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|SQLITE_OK
operator|!=
name|sqlite3_errcode
argument_list|(
name|pDb
operator|->
name|db
argument_list|)
condition|)
block|{
comment|/* A compile-time error in the statement. */
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|sqlite3_errmsg
argument_list|(
name|pDb
operator|->
name|db
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
else|else
block|{
comment|/* The statement was a no-op.  Continue to the next statement         ** in the SQL string.         */
return|return
name|TCL_OK
return|;
block|}
block|}
name|assert
argument_list|(
name|pPreStmt
operator|==
literal|0
argument_list|)
expr_stmt|;
name|nVar
operator|=
name|sqlite3_bind_parameter_count
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|nByte
operator|=
sizeof|sizeof
argument_list|(
name|SqlPreparedStmt
argument_list|)
operator|+
name|nVar
operator|*
sizeof|sizeof
argument_list|(
name|Tcl_Obj
operator|*
argument_list|)
expr_stmt|;
name|pPreStmt
operator|=
operator|(
name|SqlPreparedStmt
operator|*
operator|)
name|Tcl_Alloc
argument_list|(
name|nByte
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|pPreStmt
argument_list|,
literal|0
argument_list|,
name|nByte
argument_list|)
expr_stmt|;
name|pPreStmt
operator|->
name|pStmt
operator|=
name|pStmt
expr_stmt|;
name|pPreStmt
operator|->
name|nSql
operator|=
call|(
name|int
call|)
argument_list|(
operator|*
name|pzOut
operator|-
name|zSql
argument_list|)
expr_stmt|;
name|pPreStmt
operator|->
name|zSql
operator|=
name|sqlite3_sql
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|pPreStmt
operator|->
name|apParm
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
operator|&
name|pPreStmt
index|[
literal|1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|SQLITE_TEST
if|if
condition|(
name|pPreStmt
operator|->
name|zSql
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|zCopy
init|=
name|Tcl_Alloc
argument_list|(
name|pPreStmt
operator|->
name|nSql
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|zCopy
argument_list|,
name|zSql
argument_list|,
name|pPreStmt
operator|->
name|nSql
argument_list|)
expr_stmt|;
name|zCopy
index|[
name|pPreStmt
operator|->
name|nSql
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pPreStmt
operator|->
name|zSql
operator|=
name|zCopy
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|assert
argument_list|(
name|pPreStmt
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strlen30
argument_list|(
name|pPreStmt
operator|->
name|zSql
argument_list|)
operator|==
name|pPreStmt
operator|->
name|nSql
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|0
operator|==
name|memcmp
argument_list|(
name|pPreStmt
operator|->
name|zSql
argument_list|,
name|zSql
argument_list|,
name|pPreStmt
operator|->
name|nSql
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Bind values to parameters that begin with $ or : */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nVar
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|zVar
init|=
name|sqlite3_bind_parameter_name
argument_list|(
name|pStmt
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|zVar
operator|!=
literal|0
operator|&&
operator|(
name|zVar
index|[
literal|0
index|]
operator|==
literal|'$'
operator|||
name|zVar
index|[
literal|0
index|]
operator|==
literal|':'
operator|||
name|zVar
index|[
literal|0
index|]
operator|==
literal|'@'
operator|)
condition|)
block|{
name|Tcl_Obj
modifier|*
name|pVar
init|=
name|Tcl_GetVar2Ex
argument_list|(
name|interp
argument_list|,
operator|&
name|zVar
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|pVar
condition|)
block|{
name|int
name|n
decl_stmt|;
name|u8
modifier|*
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|zType
init|=
operator|(
name|pVar
operator|->
name|typePtr
condition|?
name|pVar
operator|->
name|typePtr
operator|->
name|name
else|:
literal|""
operator|)
decl_stmt|;
name|c
operator|=
name|zType
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|zVar
index|[
literal|0
index|]
operator|==
literal|'@'
operator|||
operator|(
name|c
operator|==
literal|'b'
operator|&&
name|strcmp
argument_list|(
name|zType
argument_list|,
literal|"bytearray"
argument_list|)
operator|==
literal|0
operator|&&
name|pVar
operator|->
name|bytes
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Load a BLOB type if the Tcl variable is a bytearray and           ** it has no string representation or the host           ** parameter name begins with "@". */
name|data
operator|=
name|Tcl_GetByteArrayFromObj
argument_list|(
name|pVar
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|sqlite3_bind_blob
argument_list|(
name|pStmt
argument_list|,
name|i
argument_list|,
name|data
argument_list|,
name|n
argument_list|,
name|SQLITE_STATIC
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|pVar
argument_list|)
expr_stmt|;
name|pPreStmt
operator|->
name|apParm
index|[
name|iParm
operator|++
index|]
operator|=
name|pVar
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'b'
operator|&&
name|strcmp
argument_list|(
name|zType
argument_list|,
literal|"boolean"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_GetIntFromObj
argument_list|(
name|interp
argument_list|,
name|pVar
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|sqlite3_bind_int
argument_list|(
name|pStmt
argument_list|,
name|i
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'d'
operator|&&
name|strcmp
argument_list|(
name|zType
argument_list|,
literal|"double"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|double
name|r
decl_stmt|;
name|Tcl_GetDoubleFromObj
argument_list|(
name|interp
argument_list|,
name|pVar
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|sqlite3_bind_double
argument_list|(
name|pStmt
argument_list|,
name|i
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'w'
operator|&&
name|strcmp
argument_list|(
name|zType
argument_list|,
literal|"wideInt"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|c
operator|==
literal|'i'
operator|&&
name|strcmp
argument_list|(
name|zType
argument_list|,
literal|"int"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|Tcl_WideInt
name|v
decl_stmt|;
name|Tcl_GetWideIntFromObj
argument_list|(
name|interp
argument_list|,
name|pVar
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
name|sqlite3_bind_int64
argument_list|(
name|pStmt
argument_list|,
name|i
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|Tcl_GetStringFromObj
argument_list|(
name|pVar
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|sqlite3_bind_text
argument_list|(
name|pStmt
argument_list|,
name|i
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|n
argument_list|,
name|SQLITE_STATIC
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|pVar
argument_list|)
expr_stmt|;
name|pPreStmt
operator|->
name|apParm
index|[
name|iParm
operator|++
index|]
operator|=
name|pVar
expr_stmt|;
block|}
block|}
else|else
block|{
name|sqlite3_bind_null
argument_list|(
name|pStmt
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|pPreStmt
operator|->
name|nParm
operator|=
name|iParm
expr_stmt|;
operator|*
name|ppPreStmt
operator|=
name|pPreStmt
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_comment
comment|/* ** Release a statement reference obtained by calling dbPrepareAndBind(). ** There should be exactly one call to this function for each call to ** dbPrepareAndBind(). ** ** If the discard parameter is non-zero, then the statement is deleted ** immediately. Otherwise it is added to the LRU list and may be returned ** by a subsequent call to dbPrepareAndBind(). */
end_comment

begin_function
specifier|static
name|void
name|dbReleaseStmt
parameter_list|(
name|SqliteDb
modifier|*
name|pDb
parameter_list|,
comment|/* Database handle */
name|SqlPreparedStmt
modifier|*
name|pPreStmt
parameter_list|,
comment|/* Prepared statement handle to release */
name|int
name|discard
comment|/* True to delete (not cache) the pPreStmt */
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Free the bound string and blob parameters */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pPreStmt
operator|->
name|nParm
condition|;
name|i
operator|++
control|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|pPreStmt
operator|->
name|apParm
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|pPreStmt
operator|->
name|nParm
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pDb
operator|->
name|maxStmt
operator|<=
literal|0
operator|||
name|discard
condition|)
block|{
comment|/* If the cache is turned off, deallocated the statement */
name|dbFreeStmt
argument_list|(
name|pPreStmt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Add the prepared statement to the beginning of the cache list. */
name|pPreStmt
operator|->
name|pNext
operator|=
name|pDb
operator|->
name|stmtList
expr_stmt|;
name|pPreStmt
operator|->
name|pPrev
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pDb
operator|->
name|stmtList
condition|)
block|{
name|pDb
operator|->
name|stmtList
operator|->
name|pPrev
operator|=
name|pPreStmt
expr_stmt|;
block|}
name|pDb
operator|->
name|stmtList
operator|=
name|pPreStmt
expr_stmt|;
if|if
condition|(
name|pDb
operator|->
name|stmtLast
operator|==
literal|0
condition|)
block|{
name|assert
argument_list|(
name|pDb
operator|->
name|nStmt
operator|==
literal|0
argument_list|)
expr_stmt|;
name|pDb
operator|->
name|stmtLast
operator|=
name|pPreStmt
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|pDb
operator|->
name|nStmt
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
name|pDb
operator|->
name|nStmt
operator|++
expr_stmt|;
comment|/* If we have too many statement in cache, remove the surplus from     ** the end of the cache list.  */
while|while
condition|(
name|pDb
operator|->
name|nStmt
operator|>
name|pDb
operator|->
name|maxStmt
condition|)
block|{
name|SqlPreparedStmt
modifier|*
name|pLast
init|=
name|pDb
operator|->
name|stmtLast
decl_stmt|;
name|pDb
operator|->
name|stmtLast
operator|=
name|pLast
operator|->
name|pPrev
expr_stmt|;
name|pDb
operator|->
name|stmtLast
operator|->
name|pNext
operator|=
literal|0
expr_stmt|;
name|pDb
operator|->
name|nStmt
operator|--
expr_stmt|;
name|dbFreeStmt
argument_list|(
name|pLast
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ** Structure used with dbEvalXXX() functions: ** **   dbEvalInit() **   dbEvalStep() **   dbEvalFinalize() **   dbEvalRowInfo() **   dbEvalColumnValue() */
end_comment

begin_typedef
typedef|typedef
name|struct
name|DbEvalContext
name|DbEvalContext
typedef|;
end_typedef

begin_struct
struct|struct
name|DbEvalContext
block|{
name|SqliteDb
modifier|*
name|pDb
decl_stmt|;
comment|/* Database handle */
name|Tcl_Obj
modifier|*
name|pSql
decl_stmt|;
comment|/* Object holding string zSql */
specifier|const
name|char
modifier|*
name|zSql
decl_stmt|;
comment|/* Remaining SQL to execute */
name|SqlPreparedStmt
modifier|*
name|pPreStmt
decl_stmt|;
comment|/* Current statement */
name|int
name|nCol
decl_stmt|;
comment|/* Number of columns returned by pStmt */
name|Tcl_Obj
modifier|*
name|pArray
decl_stmt|;
comment|/* Name of array variable */
name|Tcl_Obj
modifier|*
modifier|*
name|apColName
decl_stmt|;
comment|/* Array of column names */
block|}
struct|;
end_struct

begin_comment
comment|/* ** Release any cache of column names currently held as part of ** the DbEvalContext structure passed as the first argument. */
end_comment

begin_function
specifier|static
name|void
name|dbReleaseColumnNames
parameter_list|(
name|DbEvalContext
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|apColName
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|nCol
condition|;
name|i
operator|++
control|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|p
operator|->
name|apColName
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|Tcl_Free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|apColName
argument_list|)
expr_stmt|;
name|p
operator|->
name|apColName
operator|=
literal|0
expr_stmt|;
block|}
name|p
operator|->
name|nCol
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Initialize a DbEvalContext structure. ** ** If pArray is not NULL, then it contains the name of a Tcl array ** variable. The "*" member of this array is set to a list containing ** the names of the columns returned by the statement as part of each ** call to dbEvalStep(), in order from left to right. e.g. if the names ** of the returned columns are a, b and c, it does the equivalent of the ** tcl command: ** **     set ${pArray}(*) {a b c} */
end_comment

begin_function
specifier|static
name|void
name|dbEvalInit
parameter_list|(
name|DbEvalContext
modifier|*
name|p
parameter_list|,
comment|/* Pointer to structure to initialize */
name|SqliteDb
modifier|*
name|pDb
parameter_list|,
comment|/* Database handle */
name|Tcl_Obj
modifier|*
name|pSql
parameter_list|,
comment|/* Object containing SQL script */
name|Tcl_Obj
modifier|*
name|pArray
comment|/* Name of Tcl array to set (*) element of */
parameter_list|)
block|{
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|DbEvalContext
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|pDb
operator|=
name|pDb
expr_stmt|;
name|p
operator|->
name|zSql
operator|=
name|Tcl_GetString
argument_list|(
name|pSql
argument_list|)
expr_stmt|;
name|p
operator|->
name|pSql
operator|=
name|pSql
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|pSql
argument_list|)
expr_stmt|;
if|if
condition|(
name|pArray
condition|)
block|{
name|p
operator|->
name|pArray
operator|=
name|pArray
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|pArray
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** Obtain information about the row that the DbEvalContext passed as the ** first argument currently points to. */
end_comment

begin_function
specifier|static
name|void
name|dbEvalRowInfo
parameter_list|(
name|DbEvalContext
modifier|*
name|p
parameter_list|,
comment|/* Evaluation context */
name|int
modifier|*
name|pnCol
parameter_list|,
comment|/* OUT: Number of column names */
name|Tcl_Obj
modifier|*
modifier|*
modifier|*
name|papColName
comment|/* OUT: Array of column names */
parameter_list|)
block|{
comment|/* Compute column names */
if|if
condition|(
literal|0
operator|==
name|p
operator|->
name|apColName
condition|)
block|{
name|sqlite3_stmt
modifier|*
name|pStmt
init|=
name|p
operator|->
name|pPreStmt
operator|->
name|pStmt
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Iterator variable */
name|int
name|nCol
decl_stmt|;
comment|/* Number of columns returned by pStmt */
name|Tcl_Obj
modifier|*
modifier|*
name|apColName
init|=
literal|0
decl_stmt|;
comment|/* Array of column names */
name|p
operator|->
name|nCol
operator|=
name|nCol
operator|=
name|sqlite3_column_count
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|nCol
operator|>
literal|0
operator|&&
operator|(
name|papColName
operator|||
name|p
operator|->
name|pArray
operator|)
condition|)
block|{
name|apColName
operator|=
operator|(
name|Tcl_Obj
operator|*
operator|*
operator|)
name|Tcl_Alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Tcl_Obj
operator|*
argument_list|)
operator|*
name|nCol
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nCol
condition|;
name|i
operator|++
control|)
block|{
name|apColName
index|[
name|i
index|]
operator|=
name|Tcl_NewStringObj
argument_list|(
name|sqlite3_column_name
argument_list|(
name|pStmt
argument_list|,
name|i
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|apColName
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|apColName
operator|=
name|apColName
expr_stmt|;
block|}
comment|/* If results are being stored in an array variable, then create     ** the array(*) entry for that array     */
if|if
condition|(
name|p
operator|->
name|pArray
condition|)
block|{
name|Tcl_Interp
modifier|*
name|interp
init|=
name|p
operator|->
name|pDb
operator|->
name|interp
decl_stmt|;
name|Tcl_Obj
modifier|*
name|pColList
init|=
name|Tcl_NewObj
argument_list|()
decl_stmt|;
name|Tcl_Obj
modifier|*
name|pStar
init|=
name|Tcl_NewStringObj
argument_list|(
literal|"*"
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nCol
condition|;
name|i
operator|++
control|)
block|{
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|pColList
argument_list|,
name|apColName
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|Tcl_IncrRefCount
argument_list|(
name|pStar
argument_list|)
expr_stmt|;
name|Tcl_ObjSetVar2
argument_list|(
name|interp
argument_list|,
name|p
operator|->
name|pArray
argument_list|,
name|pStar
argument_list|,
name|pColList
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|pStar
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|papColName
condition|)
block|{
operator|*
name|papColName
operator|=
name|p
operator|->
name|apColName
expr_stmt|;
block|}
if|if
condition|(
name|pnCol
condition|)
block|{
operator|*
name|pnCol
operator|=
name|p
operator|->
name|nCol
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** Return one of TCL_OK, TCL_BREAK or TCL_ERROR. If TCL_ERROR is ** returned, then an error message is stored in the interpreter before ** returning. ** ** A return value of TCL_OK means there is a row of data available. The ** data may be accessed using dbEvalRowInfo() and dbEvalColumnValue(). This ** is analogous to a return of SQLITE_ROW from sqlite3_step(). If TCL_BREAK ** is returned, then the SQL script has finished executing and there are ** no further rows available. This is similar to SQLITE_DONE. */
end_comment

begin_function
specifier|static
name|int
name|dbEvalStep
parameter_list|(
name|DbEvalContext
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|zPrevSql
init|=
literal|0
decl_stmt|;
comment|/* Previous value of p->zSql */
while|while
condition|(
name|p
operator|->
name|zSql
index|[
literal|0
index|]
operator|||
name|p
operator|->
name|pPreStmt
condition|)
block|{
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|pPreStmt
operator|==
literal|0
condition|)
block|{
name|zPrevSql
operator|=
operator|(
name|p
operator|->
name|zSql
operator|==
name|zPrevSql
condition|?
literal|0
else|:
name|p
operator|->
name|zSql
operator|)
expr_stmt|;
name|rc
operator|=
name|dbPrepareAndBind
argument_list|(
name|p
operator|->
name|pDb
argument_list|,
name|p
operator|->
name|zSql
argument_list|,
operator|&
name|p
operator|->
name|zSql
argument_list|,
operator|&
name|p
operator|->
name|pPreStmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|TCL_OK
condition|)
return|return
name|rc
return|;
block|}
else|else
block|{
name|int
name|rcs
decl_stmt|;
name|SqliteDb
modifier|*
name|pDb
init|=
name|p
operator|->
name|pDb
decl_stmt|;
name|SqlPreparedStmt
modifier|*
name|pPreStmt
init|=
name|p
operator|->
name|pPreStmt
decl_stmt|;
name|sqlite3_stmt
modifier|*
name|pStmt
init|=
name|pPreStmt
operator|->
name|pStmt
decl_stmt|;
name|rcs
operator|=
name|sqlite3_step
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|==
name|SQLITE_ROW
condition|)
block|{
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|p
operator|->
name|pArray
condition|)
block|{
name|dbEvalRowInfo
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|rcs
operator|=
name|sqlite3_reset
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|pDb
operator|->
name|nStep
operator|=
name|sqlite3_stmt_status
argument_list|(
name|pStmt
argument_list|,
name|SQLITE_STMTSTATUS_FULLSCAN_STEP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pDb
operator|->
name|nSort
operator|=
name|sqlite3_stmt_status
argument_list|(
name|pStmt
argument_list|,
name|SQLITE_STMTSTATUS_SORT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pDb
operator|->
name|nIndex
operator|=
name|sqlite3_stmt_status
argument_list|(
name|pStmt
argument_list|,
name|SQLITE_STMTSTATUS_AUTOINDEX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dbReleaseColumnNames
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|pPreStmt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rcs
operator|!=
name|SQLITE_OK
condition|)
block|{
comment|/* If a run-time error occurs, report the error and stop reading         ** the SQL.  */
name|dbReleaseStmt
argument_list|(
name|pDb
argument_list|,
name|pPreStmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|SQLITE_TEST
if|if
condition|(
name|p
operator|->
name|pDb
operator|->
name|bLegacyPrepare
operator|&&
name|rcs
operator|==
name|SQLITE_SCHEMA
operator|&&
name|zPrevSql
condition|)
block|{
comment|/* If the runtime error was an SQLITE_SCHEMA, and the database           ** handle is configured to use the legacy sqlite3_prepare()           ** interface, retry prepare()/step() on the same SQL statement.           ** This only happens once. If there is a second SQLITE_SCHEMA           ** error, the error will be returned to the caller. */
name|p
operator|->
name|zSql
operator|=
name|zPrevSql
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
name|Tcl_SetObjResult
argument_list|(
name|pDb
operator|->
name|interp
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|sqlite3_errmsg
argument_list|(
name|pDb
operator|->
name|db
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
else|else
block|{
name|dbReleaseStmt
argument_list|(
name|pDb
argument_list|,
name|pPreStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Finished */
return|return
name|TCL_BREAK
return|;
block|}
end_function

begin_comment
comment|/* ** Free all resources currently held by the DbEvalContext structure passed ** as the first argument. There should be exactly one call to this function ** for each call to dbEvalInit(). */
end_comment

begin_function
specifier|static
name|void
name|dbEvalFinalize
parameter_list|(
name|DbEvalContext
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|pPreStmt
condition|)
block|{
name|sqlite3_reset
argument_list|(
name|p
operator|->
name|pPreStmt
operator|->
name|pStmt
argument_list|)
expr_stmt|;
name|dbReleaseStmt
argument_list|(
name|p
operator|->
name|pDb
argument_list|,
name|p
operator|->
name|pPreStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|pPreStmt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|pArray
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|p
operator|->
name|pArray
argument_list|)
expr_stmt|;
name|p
operator|->
name|pArray
operator|=
literal|0
expr_stmt|;
block|}
name|Tcl_DecrRefCount
argument_list|(
name|p
operator|->
name|pSql
argument_list|)
expr_stmt|;
name|dbReleaseColumnNames
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Return a pointer to a Tcl_Obj structure with ref-count 0 that contains ** the value for the iCol'th column of the row currently pointed to by ** the DbEvalContext structure passed as the first argument. */
end_comment

begin_function
specifier|static
name|Tcl_Obj
modifier|*
name|dbEvalColumnValue
parameter_list|(
name|DbEvalContext
modifier|*
name|p
parameter_list|,
name|int
name|iCol
parameter_list|)
block|{
name|sqlite3_stmt
modifier|*
name|pStmt
init|=
name|p
operator|->
name|pPreStmt
operator|->
name|pStmt
decl_stmt|;
switch|switch
condition|(
name|sqlite3_column_type
argument_list|(
name|pStmt
argument_list|,
name|iCol
argument_list|)
condition|)
block|{
case|case
name|SQLITE_BLOB
case|:
block|{
name|int
name|bytes
init|=
name|sqlite3_column_bytes
argument_list|(
name|pStmt
argument_list|,
name|iCol
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|zBlob
init|=
name|sqlite3_column_blob
argument_list|(
name|pStmt
argument_list|,
name|iCol
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|zBlob
condition|)
name|bytes
operator|=
literal|0
expr_stmt|;
return|return
name|Tcl_NewByteArrayObj
argument_list|(
operator|(
name|u8
operator|*
operator|)
name|zBlob
argument_list|,
name|bytes
argument_list|)
return|;
block|}
case|case
name|SQLITE_INTEGER
case|:
block|{
name|sqlite_int64
name|v
init|=
name|sqlite3_column_int64
argument_list|(
name|pStmt
argument_list|,
name|iCol
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|>=
operator|-
literal|2147483647
operator|&&
name|v
operator|<=
literal|2147483647
condition|)
block|{
return|return
name|Tcl_NewIntObj
argument_list|(
operator|(
name|int
operator|)
name|v
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Tcl_NewWideIntObj
argument_list|(
name|v
argument_list|)
return|;
block|}
block|}
case|case
name|SQLITE_FLOAT
case|:
block|{
return|return
name|Tcl_NewDoubleObj
argument_list|(
name|sqlite3_column_double
argument_list|(
name|pStmt
argument_list|,
name|iCol
argument_list|)
argument_list|)
return|;
block|}
case|case
name|SQLITE_NULL
case|:
block|{
return|return
name|Tcl_NewStringObj
argument_list|(
name|p
operator|->
name|pDb
operator|->
name|zNull
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
block|}
return|return
name|Tcl_NewStringObj
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pStmt
argument_list|,
name|iCol
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ** If using Tcl version 8.6 or greater, use the NR functions to avoid ** recursive evalution of scripts by the [db eval] and [db trans] ** commands. Even if the headers used while compiling the extension ** are 8.6 or newer, the code still tests the Tcl version at runtime. ** This allows stubs-enabled builds to be used with older Tcl libraries. */
end_comment

begin_if
if|#
directive|if
name|TCL_MAJOR_VERSION
operator|>
literal|8
operator|||
operator|(
name|TCL_MAJOR_VERSION
operator|==
literal|8
operator|&&
name|TCL_MINOR_VERSION
operator|>=
literal|6
operator|)
end_if

begin_define
define|#
directive|define
name|SQLITE_TCL_NRE
value|1
end_define

begin_function
specifier|static
name|int
name|DbUseNre
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|major
decl_stmt|,
name|minor
decl_stmt|;
name|Tcl_GetVersion
argument_list|(
operator|&
name|major
argument_list|,
operator|&
name|minor
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|major
operator|==
literal|8
operator|&&
name|minor
operator|>=
literal|6
operator|)
operator|||
name|major
operator|>
literal|8
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ** Compiling using headers earlier than 8.6. In this case NR cannot be ** used, so DbUseNre() to always return zero. Add #defines for the other ** Tcl_NRxxx() functions to prevent them from causing compilation errors, ** even though the only invocations of them are within conditional blocks ** of the form: ** **   if( DbUseNre() ) { ... } */
end_comment

begin_define
define|#
directive|define
name|SQLITE_TCL_NRE
value|0
end_define

begin_define
define|#
directive|define
name|DbUseNre
parameter_list|()
value|0
end_define

begin_define
define|#
directive|define
name|Tcl_NRAddCallback
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|f
parameter_list|)
value|(void)0
end_define

begin_define
define|#
directive|define
name|Tcl_NREvalObj
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|Tcl_NRCreateCommand
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|f
parameter_list|)
value|(void)0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** This function is part of the implementation of the command: ** **   $db eval SQL ?ARRAYNAME? SCRIPT */
end_comment

begin_function
specifier|static
name|int
name|SQLITE_TCLAPI
name|DbEvalNextCmd
parameter_list|(
name|ClientData
name|data
index|[]
parameter_list|,
comment|/* data[0] is the (DbEvalContext*) */
name|Tcl_Interp
modifier|*
name|interp
parameter_list|,
comment|/* Tcl interpreter */
name|int
name|result
comment|/* Result so far */
parameter_list|)
block|{
name|int
name|rc
init|=
name|result
decl_stmt|;
comment|/* Return code */
comment|/* The first element of the data[] array is a pointer to a DbEvalContext   ** structure allocated using Tcl_Alloc(). The second element of data[]   ** is a pointer to a Tcl_Obj containing the script to run for each row   ** returned by the queries encapsulated in data[0]. */
name|DbEvalContext
modifier|*
name|p
init|=
operator|(
name|DbEvalContext
operator|*
operator|)
name|data
index|[
literal|0
index|]
decl_stmt|;
name|Tcl_Obj
modifier|*
name|pScript
init|=
operator|(
name|Tcl_Obj
operator|*
operator|)
name|data
index|[
literal|1
index|]
decl_stmt|;
name|Tcl_Obj
modifier|*
name|pArray
init|=
name|p
operator|->
name|pArray
decl_stmt|;
while|while
condition|(
operator|(
name|rc
operator|==
name|TCL_OK
operator|||
name|rc
operator|==
name|TCL_CONTINUE
operator|)
operator|&&
name|TCL_OK
operator|==
operator|(
name|rc
operator|=
name|dbEvalStep
argument_list|(
name|p
argument_list|)
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|nCol
decl_stmt|;
name|Tcl_Obj
modifier|*
modifier|*
name|apColName
decl_stmt|;
name|dbEvalRowInfo
argument_list|(
name|p
argument_list|,
operator|&
name|nCol
argument_list|,
operator|&
name|apColName
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nCol
condition|;
name|i
operator|++
control|)
block|{
name|Tcl_Obj
modifier|*
name|pVal
init|=
name|dbEvalColumnValue
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|pArray
operator|==
literal|0
condition|)
block|{
name|Tcl_ObjSetVar2
argument_list|(
name|interp
argument_list|,
name|apColName
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|pVal
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_ObjSetVar2
argument_list|(
name|interp
argument_list|,
name|pArray
argument_list|,
name|apColName
index|[
name|i
index|]
argument_list|,
name|pVal
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The required interpreter variables are now populated with the data     ** from the current row. If using NRE, schedule callbacks to evaluate     ** script pScript, then to invoke this function again to fetch the next     ** row (or clean up if there is no next row or the script throws an     ** exception). After scheduling the callbacks, return control to the     ** caller.     **     ** If not using NRE, evaluate pScript directly and continue with the     ** next iteration of this while(...) loop.  */
if|if
condition|(
name|DbUseNre
argument_list|()
condition|)
block|{
name|Tcl_NRAddCallback
argument_list|(
name|interp
argument_list|,
name|DbEvalNextCmd
argument_list|,
operator|(
name|void
operator|*
operator|)
name|p
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pScript
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|Tcl_NREvalObj
argument_list|(
name|interp
argument_list|,
name|pScript
argument_list|,
literal|0
argument_list|)
return|;
block|}
else|else
block|{
name|rc
operator|=
name|Tcl_EvalObjEx
argument_list|(
name|interp
argument_list|,
name|pScript
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|Tcl_DecrRefCount
argument_list|(
name|pScript
argument_list|)
expr_stmt|;
name|dbEvalFinalize
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|Tcl_Free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|TCL_OK
operator|||
name|rc
operator|==
name|TCL_BREAK
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|rc
operator|=
name|TCL_OK
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* ** This function is used by the implementations of the following database ** handle sub-commands: ** **   $db update_hook ?SCRIPT? **   $db wal_hook ?SCRIPT? **   $db commit_hook ?SCRIPT? **   $db preupdate hook ?SCRIPT? */
end_comment

begin_function
specifier|static
name|void
name|DbHookCmd
parameter_list|(
name|Tcl_Interp
modifier|*
name|interp
parameter_list|,
comment|/* Tcl interpreter */
name|SqliteDb
modifier|*
name|pDb
parameter_list|,
comment|/* Database handle */
name|Tcl_Obj
modifier|*
name|pArg
parameter_list|,
comment|/* SCRIPT argument (or NULL) */
name|Tcl_Obj
modifier|*
modifier|*
name|ppHook
comment|/* Pointer to member of SqliteDb */
parameter_list|)
block|{
name|sqlite3
modifier|*
name|db
init|=
name|pDb
operator|->
name|db
decl_stmt|;
if|if
condition|(
operator|*
name|ppHook
condition|)
block|{
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
operator|*
name|ppHook
argument_list|)
expr_stmt|;
if|if
condition|(
name|pArg
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
operator|*
name|ppHook
argument_list|)
expr_stmt|;
operator|*
name|ppHook
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pArg
condition|)
block|{
name|assert
argument_list|(
operator|!
operator|(
operator|*
name|ppHook
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tcl_GetCharLength
argument_list|(
name|pArg
argument_list|)
operator|>
literal|0
condition|)
block|{
operator|*
name|ppHook
operator|=
name|pArg
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
operator|*
name|ppHook
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SQLITE_ENABLE_PREUPDATE_HOOK
name|sqlite3_preupdate_hook
argument_list|(
name|db
argument_list|,
operator|(
name|pDb
operator|->
name|pPreUpdateHook
condition|?
name|DbPreUpdateHandler
else|:
literal|0
operator|)
argument_list|,
name|pDb
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sqlite3_update_hook
argument_list|(
name|db
argument_list|,
operator|(
name|pDb
operator|->
name|pUpdateHook
condition|?
name|DbUpdateHandler
else|:
literal|0
operator|)
argument_list|,
name|pDb
argument_list|)
expr_stmt|;
name|sqlite3_rollback_hook
argument_list|(
name|db
argument_list|,
operator|(
name|pDb
operator|->
name|pRollbackHook
condition|?
name|DbRollbackHandler
else|:
literal|0
operator|)
argument_list|,
name|pDb
argument_list|)
expr_stmt|;
name|sqlite3_wal_hook
argument_list|(
name|db
argument_list|,
operator|(
name|pDb
operator|->
name|pWalHook
condition|?
name|DbWalHandler
else|:
literal|0
operator|)
argument_list|,
name|pDb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** The "sqlite" command below creates a new Tcl command for each ** connection it opens to an SQLite database.  This routine is invoked ** whenever one of those connection-specific commands is executed ** in Tcl.  For example, if you run Tcl code like this: ** **       sqlite3 db1  "my_database" **       db1 close ** ** The first command opens a connection to the "my_database" database ** and calls that connection "db1".  The second command causes this ** subroutine to be invoked. */
end_comment

begin_function
specifier|static
name|int
name|SQLITE_TCLAPI
name|DbObjCmd
parameter_list|(
name|void
modifier|*
name|cd
parameter_list|,
name|Tcl_Interp
modifier|*
name|interp
parameter_list|,
name|int
name|objc
parameter_list|,
name|Tcl_Obj
modifier|*
specifier|const
modifier|*
name|objv
parameter_list|)
block|{
name|SqliteDb
modifier|*
name|pDb
init|=
operator|(
name|SqliteDb
operator|*
operator|)
name|cd
decl_stmt|;
name|int
name|choice
decl_stmt|;
name|int
name|rc
init|=
name|TCL_OK
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|DB_strs
index|[]
init|=
block|{
literal|"authorizer"
block|,
literal|"backup"
block|,
literal|"busy"
block|,
literal|"cache"
block|,
literal|"changes"
block|,
literal|"close"
block|,
literal|"collate"
block|,
literal|"collation_needed"
block|,
literal|"commit_hook"
block|,
literal|"complete"
block|,
literal|"copy"
block|,
literal|"enable_load_extension"
block|,
literal|"errorcode"
block|,
literal|"eval"
block|,
literal|"exists"
block|,
literal|"function"
block|,
literal|"incrblob"
block|,
literal|"interrupt"
block|,
literal|"last_insert_rowid"
block|,
literal|"nullvalue"
block|,
literal|"onecolumn"
block|,
literal|"preupdate"
block|,
literal|"profile"
block|,
literal|"progress"
block|,
literal|"rekey"
block|,
literal|"restore"
block|,
literal|"rollback_hook"
block|,
literal|"status"
block|,
literal|"timeout"
block|,
literal|"total_changes"
block|,
literal|"trace"
block|,
literal|"trace_v2"
block|,
literal|"transaction"
block|,
literal|"unlock_notify"
block|,
literal|"update_hook"
block|,
literal|"version"
block|,
literal|"wal_hook"
block|,
literal|0
block|}
decl_stmt|;
enum|enum
name|DB_enum
block|{
name|DB_AUTHORIZER
block|,
name|DB_BACKUP
block|,
name|DB_BUSY
block|,
name|DB_CACHE
block|,
name|DB_CHANGES
block|,
name|DB_CLOSE
block|,
name|DB_COLLATE
block|,
name|DB_COLLATION_NEEDED
block|,
name|DB_COMMIT_HOOK
block|,
name|DB_COMPLETE
block|,
name|DB_COPY
block|,
name|DB_ENABLE_LOAD_EXTENSION
block|,
name|DB_ERRORCODE
block|,
name|DB_EVAL
block|,
name|DB_EXISTS
block|,
name|DB_FUNCTION
block|,
name|DB_INCRBLOB
block|,
name|DB_INTERRUPT
block|,
name|DB_LAST_INSERT_ROWID
block|,
name|DB_NULLVALUE
block|,
name|DB_ONECOLUMN
block|,
name|DB_PREUPDATE
block|,
name|DB_PROFILE
block|,
name|DB_PROGRESS
block|,
name|DB_REKEY
block|,
name|DB_RESTORE
block|,
name|DB_ROLLBACK_HOOK
block|,
name|DB_STATUS
block|,
name|DB_TIMEOUT
block|,
name|DB_TOTAL_CHANGES
block|,
name|DB_TRACE
block|,
name|DB_TRACE_V2
block|,
name|DB_TRANSACTION
block|,
name|DB_UNLOCK_NOTIFY
block|,
name|DB_UPDATE_HOOK
block|,
name|DB_VERSION
block|,
name|DB_WAL_HOOK
block|,   }
enum|;
comment|/* don't leave trailing commas on DB_enum, it confuses the AIX xlc compiler */
if|if
condition|(
name|objc
operator|<
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"SUBCOMMAND ..."
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetIndexFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|1
index|]
argument_list|,
name|DB_strs
argument_list|,
literal|"option"
argument_list|,
literal|0
argument_list|,
operator|&
name|choice
argument_list|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
switch|switch
condition|(
operator|(
expr|enum
name|DB_enum
operator|)
name|choice
condition|)
block|{
comment|/*    $db authorizer ?CALLBACK?   **   ** Invoke the given callback to authorize each SQL operation as it is   ** compiled.  5 arguments are appended to the callback before it is   ** invoked:   **   **   (1) The authorization type (ex: SQLITE_CREATE_TABLE, SQLITE_INSERT, ...)   **   (2) First descriptive name (depends on authorization type)   **   (3) Second descriptive name   **   (4) Name of the database (ex: "main", "temp")   **   (5) Name of trigger that is doing the access   **   ** The callback should return on of the following strings: SQLITE_OK,   ** SQLITE_IGNORE, or SQLITE_DENY.  Any other return value is an error.   **   ** If this method is invoked with no arguments, the current authorization   ** callback string is returned.   */
case|case
name|DB_AUTHORIZER
case|:
block|{
ifdef|#
directive|ifdef
name|SQLITE_OMIT_AUTHORIZATION
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"authorization not available in this build"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
else|#
directive|else
if|if
condition|(
name|objc
operator|>
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?CALLBACK?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|objc
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|pDb
operator|->
name|zAuth
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|pDb
operator|->
name|zAuth
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|zAuth
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|pDb
operator|->
name|zAuth
condition|)
block|{
name|Tcl_Free
argument_list|(
name|pDb
operator|->
name|zAuth
argument_list|)
expr_stmt|;
block|}
name|zAuth
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|zAuth
operator|&&
name|len
operator|>
literal|0
condition|)
block|{
name|pDb
operator|->
name|zAuth
operator|=
name|Tcl_Alloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pDb
operator|->
name|zAuth
argument_list|,
name|zAuth
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pDb
operator|->
name|zAuth
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pDb
operator|->
name|zAuth
condition|)
block|{
typedef|typedef
name|int
function_decl|(
modifier|*
name|sqlite3_auth_cb
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|pDb
operator|->
name|interp
operator|=
name|interp
expr_stmt|;
name|sqlite3_set_authorizer
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
operator|(
name|sqlite3_auth_cb
operator|)
name|auth_callback
argument_list|,
name|pDb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sqlite3_set_authorizer
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
break|break;
block|}
comment|/*    $db backup ?DATABASE? FILENAME   **   ** Open or create a database file named FILENAME.  Transfer the   ** content of local database DATABASE (default: "main") into the   ** FILENAME database.   */
case|case
name|DB_BACKUP
case|:
block|{
specifier|const
name|char
modifier|*
name|zDestFile
decl_stmt|;
specifier|const
name|char
modifier|*
name|zSrcDb
decl_stmt|;
name|sqlite3
modifier|*
name|pDest
decl_stmt|;
name|sqlite3_backup
modifier|*
name|pBackup
decl_stmt|;
if|if
condition|(
name|objc
operator|==
literal|3
condition|)
block|{
name|zSrcDb
operator|=
literal|"main"
expr_stmt|;
name|zDestFile
operator|=
name|Tcl_GetString
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|objc
operator|==
literal|4
condition|)
block|{
name|zSrcDb
operator|=
name|Tcl_GetString
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|zDestFile
operator|=
name|Tcl_GetString
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?DATABASE? FILENAME"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|rc
operator|=
name|sqlite3_open_v2
argument_list|(
name|zDestFile
argument_list|,
operator|&
name|pDest
argument_list|,
name|SQLITE_OPEN_READWRITE
operator||
name|SQLITE_OPEN_CREATE
operator||
name|pDb
operator|->
name|openFlags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"cannot open target database: "
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|pDest
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_close
argument_list|(
name|pDest
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|pBackup
operator|=
name|sqlite3_backup_init
argument_list|(
name|pDest
argument_list|,
literal|"main"
argument_list|,
name|pDb
operator|->
name|db
argument_list|,
name|zSrcDb
argument_list|)
expr_stmt|;
if|if
condition|(
name|pBackup
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"backup failed: "
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|pDest
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_close
argument_list|(
name|pDest
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
while|while
condition|(
operator|(
name|rc
operator|=
name|sqlite3_backup_step
argument_list|(
name|pBackup
argument_list|,
literal|100
argument_list|)
operator|)
operator|==
name|SQLITE_OK
condition|)
block|{}
name|sqlite3_backup_finish
argument_list|(
name|pBackup
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|SQLITE_DONE
condition|)
block|{
name|rc
operator|=
name|TCL_OK
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"backup failed: "
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|pDest
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
name|sqlite3_close
argument_list|(
name|pDest
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*    $db busy ?CALLBACK?   **   ** Invoke the given callback if an SQL statement attempts to open   ** a locked database file.   */
case|case
name|DB_BUSY
case|:
block|{
if|if
condition|(
name|objc
operator|>
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"CALLBACK"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|objc
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|pDb
operator|->
name|zBusy
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|pDb
operator|->
name|zBusy
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|zBusy
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|pDb
operator|->
name|zBusy
condition|)
block|{
name|Tcl_Free
argument_list|(
name|pDb
operator|->
name|zBusy
argument_list|)
expr_stmt|;
block|}
name|zBusy
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|zBusy
operator|&&
name|len
operator|>
literal|0
condition|)
block|{
name|pDb
operator|->
name|zBusy
operator|=
name|Tcl_Alloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pDb
operator|->
name|zBusy
argument_list|,
name|zBusy
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pDb
operator|->
name|zBusy
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pDb
operator|->
name|zBusy
condition|)
block|{
name|pDb
operator|->
name|interp
operator|=
name|interp
expr_stmt|;
name|sqlite3_busy_handler
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
name|DbBusyHandler
argument_list|,
name|pDb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sqlite3_busy_handler
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
comment|/*     $db cache flush   **     $db cache size n   **   ** Flush the prepared statement cache, or set the maximum number of   ** cached statements.   */
case|case
name|DB_CACHE
case|:
block|{
name|char
modifier|*
name|subCmd
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|objc
operator|<=
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"cache option ?arg?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|subCmd
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|subCmd
operator|==
literal|'f'
operator|&&
name|strcmp
argument_list|(
name|subCmd
argument_list|,
literal|"flush"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"flush"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
else|else
block|{
name|flushStmtCache
argument_list|(
name|pDb
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|subCmd
operator|==
literal|'s'
operator|&&
name|strcmp
argument_list|(
name|subCmd
argument_list|,
literal|"size"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|objc
operator|!=
literal|4
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"size n"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
else|else
block|{
if|if
condition|(
name|TCL_ERROR
operator|==
name|Tcl_GetIntFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|n
argument_list|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"cannot convert \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"\" to integer"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
else|else
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|flushStmtCache
argument_list|(
name|pDb
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|>
name|MAX_PREPARED_STMTS
condition|)
block|{
name|n
operator|=
name|MAX_PREPARED_STMTS
expr_stmt|;
block|}
name|pDb
operator|->
name|maxStmt
operator|=
name|n
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"\": must be flush or size"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
break|break;
block|}
comment|/*     $db changes   **   ** Return the number of rows that were modified, inserted, or deleted by   ** the most recent INSERT, UPDATE or DELETE statement, not including   ** any changes made by trigger programs.   */
case|case
name|DB_CHANGES
case|:
block|{
name|Tcl_Obj
modifier|*
name|pResult
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|pResult
operator|=
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_SetIntObj
argument_list|(
name|pResult
argument_list|,
name|sqlite3_changes
argument_list|(
name|pDb
operator|->
name|db
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*    $db close   **   ** Shutdown the database   */
case|case
name|DB_CLOSE
case|:
block|{
name|Tcl_DeleteCommand
argument_list|(
name|interp
argument_list|,
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*   **     $db collate NAME SCRIPT   **   ** Create a new SQL collation function called NAME.  Whenever   ** that function is called, invoke SCRIPT to evaluate the function.   */
case|case
name|DB_COLLATE
case|:
block|{
name|SqlCollate
modifier|*
name|pCollate
decl_stmt|;
name|char
modifier|*
name|zName
decl_stmt|;
name|char
modifier|*
name|zScript
decl_stmt|;
name|int
name|nScript
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|4
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"NAME SCRIPT"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|zName
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zScript
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|nScript
argument_list|)
expr_stmt|;
name|pCollate
operator|=
operator|(
name|SqlCollate
operator|*
operator|)
name|Tcl_Alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pCollate
argument_list|)
operator|+
name|nScript
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pCollate
operator|==
literal|0
condition|)
return|return
name|TCL_ERROR
return|;
name|pCollate
operator|->
name|interp
operator|=
name|interp
expr_stmt|;
name|pCollate
operator|->
name|pNext
operator|=
name|pDb
operator|->
name|pCollate
expr_stmt|;
name|pCollate
operator|->
name|zScript
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|pCollate
index|[
literal|1
index|]
expr_stmt|;
name|pDb
operator|->
name|pCollate
operator|=
name|pCollate
expr_stmt|;
name|memcpy
argument_list|(
name|pCollate
operator|->
name|zScript
argument_list|,
name|zScript
argument_list|,
name|nScript
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sqlite3_create_collation
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
name|zName
argument_list|,
name|SQLITE_UTF8
argument_list|,
name|pCollate
argument_list|,
name|tclSqlCollate
argument_list|)
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sqlite3_errmsg
argument_list|(
name|pDb
operator|->
name|db
argument_list|)
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
break|break;
block|}
comment|/*   **     $db collation_needed SCRIPT   **   ** Create a new SQL collation function called NAME.  Whenever   ** that function is called, invoke SCRIPT to evaluate the function.   */
case|case
name|DB_COLLATION_NEEDED
case|:
block|{
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"SCRIPT"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|pDb
operator|->
name|pCollateNeeded
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|pDb
operator|->
name|pCollateNeeded
argument_list|)
expr_stmt|;
block|}
name|pDb
operator|->
name|pCollateNeeded
operator|=
name|Tcl_DuplicateObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|pDb
operator|->
name|pCollateNeeded
argument_list|)
expr_stmt|;
name|sqlite3_collation_needed
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
name|pDb
argument_list|,
name|tclCollateNeeded
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*    $db commit_hook ?CALLBACK?   **   ** Invoke the given callback just before committing every SQL transaction.   ** If the callback throws an exception or returns non-zero, then the   ** transaction is aborted.  If CALLBACK is an empty string, the callback   ** is disabled.   */
case|case
name|DB_COMMIT_HOOK
case|:
block|{
if|if
condition|(
name|objc
operator|>
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?CALLBACK?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|objc
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|pDb
operator|->
name|zCommit
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|pDb
operator|->
name|zCommit
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|zCommit
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|pDb
operator|->
name|zCommit
condition|)
block|{
name|Tcl_Free
argument_list|(
name|pDb
operator|->
name|zCommit
argument_list|)
expr_stmt|;
block|}
name|zCommit
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|zCommit
operator|&&
name|len
operator|>
literal|0
condition|)
block|{
name|pDb
operator|->
name|zCommit
operator|=
name|Tcl_Alloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pDb
operator|->
name|zCommit
argument_list|,
name|zCommit
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pDb
operator|->
name|zCommit
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pDb
operator|->
name|zCommit
condition|)
block|{
name|pDb
operator|->
name|interp
operator|=
name|interp
expr_stmt|;
name|sqlite3_commit_hook
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
name|DbCommitHandler
argument_list|,
name|pDb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sqlite3_commit_hook
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
comment|/*    $db complete SQL   **   ** Return TRUE if SQL is a complete SQL statement.  Return FALSE if   ** additional lines of input are needed.  This is similar to the   ** built-in "info complete" command of Tcl.   */
case|case
name|DB_COMPLETE
case|:
block|{
ifndef|#
directive|ifndef
name|SQLITE_OMIT_COMPLETE
name|Tcl_Obj
modifier|*
name|pResult
decl_stmt|;
name|int
name|isComplete
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"SQL"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|isComplete
operator|=
name|sqlite3_complete
argument_list|(
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pResult
operator|=
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_SetBooleanObj
argument_list|(
name|pResult
argument_list|,
name|isComplete
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
comment|/*    $db copy conflict-algorithm table filename ?SEPARATOR? ?NULLINDICATOR?   **   ** Copy data into table from filename, optionally using SEPARATOR   ** as column separators.  If a column contains a null string, or the   ** value of NULLINDICATOR, a NULL is inserted for the column.   ** conflict-algorithm is one of the sqlite conflict algorithms:   **    rollback, abort, fail, ignore, replace   ** On success, return the number of lines processed, not necessarily same   ** as 'db changes' due to conflict-algorithm selected.   **   ** This code is basically an implementation/enhancement of   ** the sqlite3 shell.c ".import" command.   **   ** This command usage is equivalent to the sqlite2.x COPY statement,   ** which imports file data into a table using the PostgreSQL COPY file format:   **   $db copy $conflit_algo $table_name $filename \t \\N   */
case|case
name|DB_COPY
case|:
block|{
name|char
modifier|*
name|zTable
decl_stmt|;
comment|/* Insert data into this table */
name|char
modifier|*
name|zFile
decl_stmt|;
comment|/* The file from which to extract data */
name|char
modifier|*
name|zConflict
decl_stmt|;
comment|/* The conflict algorithm to use */
name|sqlite3_stmt
modifier|*
name|pStmt
decl_stmt|;
comment|/* A statement */
name|int
name|nCol
decl_stmt|;
comment|/* Number of columns in the table */
name|int
name|nByte
decl_stmt|;
comment|/* Number of bytes in an SQL string */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Loop counters */
name|int
name|nSep
decl_stmt|;
comment|/* Number of bytes in zSep[] */
name|int
name|nNull
decl_stmt|;
comment|/* Number of bytes in zNull[] */
name|char
modifier|*
name|zSql
decl_stmt|;
comment|/* An SQL statement */
name|char
modifier|*
name|zLine
decl_stmt|;
comment|/* A single line of input from the file */
name|char
modifier|*
modifier|*
name|azCol
decl_stmt|;
comment|/* zLine[] broken up into columns */
specifier|const
name|char
modifier|*
name|zCommit
decl_stmt|;
comment|/* How to commit changes */
name|FILE
modifier|*
name|in
decl_stmt|;
comment|/* The input file */
name|int
name|lineno
init|=
literal|0
decl_stmt|;
comment|/* Line number of input file */
name|char
name|zLineNum
index|[
literal|80
index|]
decl_stmt|;
comment|/* Line number print buffer */
name|Tcl_Obj
modifier|*
name|pResult
decl_stmt|;
comment|/* interp result */
specifier|const
name|char
modifier|*
name|zSep
decl_stmt|;
specifier|const
name|char
modifier|*
name|zNull
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|5
operator|||
name|objc
operator|>
literal|7
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"CONFLICT-ALGORITHM TABLE FILENAME ?SEPARATOR? ?NULLINDICATOR?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|objc
operator|>=
literal|6
condition|)
block|{
name|zSep
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|5
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zSep
operator|=
literal|"\t"
expr_stmt|;
block|}
if|if
condition|(
name|objc
operator|>=
literal|7
condition|)
block|{
name|zNull
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|6
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zNull
operator|=
literal|""
expr_stmt|;
block|}
name|zConflict
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zTable
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zFile
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|4
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nSep
operator|=
name|strlen30
argument_list|(
name|zSep
argument_list|)
expr_stmt|;
name|nNull
operator|=
name|strlen30
argument_list|(
name|zNull
argument_list|)
expr_stmt|;
if|if
condition|(
name|nSep
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"Error: non-null separator required for copy"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|zConflict
argument_list|,
literal|"rollback"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|zConflict
argument_list|,
literal|"abort"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|zConflict
argument_list|,
literal|"fail"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|zConflict
argument_list|,
literal|"ignore"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|zConflict
argument_list|,
literal|"replace"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"Error: \""
argument_list|,
name|zConflict
argument_list|,
literal|"\", conflict-algorithm must be one of: rollback, "
literal|"abort, fail, ignore, or replace"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|zSql
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"SELECT * FROM '%q'"
argument_list|,
name|zTable
argument_list|)
expr_stmt|;
if|if
condition|(
name|zSql
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"Error: no such table: "
argument_list|,
name|zTable
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|nByte
operator|=
name|strlen30
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_prepare
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
name|zSql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"Error: "
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|pDb
operator|->
name|db
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|nCol
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|nCol
operator|=
name|sqlite3_column_count
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
block|}
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|nCol
operator|==
literal|0
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|zSql
operator|=
name|malloc
argument_list|(
name|nByte
operator|+
literal|50
operator|+
name|nCol
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|zSql
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"Error: can't malloc()"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|sqlite3_snprintf
argument_list|(
name|nByte
operator|+
literal|50
argument_list|,
name|zSql
argument_list|,
literal|"INSERT OR %q INTO '%q' VALUES(?"
argument_list|,
name|zConflict
argument_list|,
name|zTable
argument_list|)
expr_stmt|;
name|j
operator|=
name|strlen30
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nCol
condition|;
name|i
operator|++
control|)
block|{
name|zSql
index|[
name|j
operator|++
index|]
operator|=
literal|','
expr_stmt|;
name|zSql
index|[
name|j
operator|++
index|]
operator|=
literal|'?'
expr_stmt|;
block|}
name|zSql
index|[
name|j
operator|++
index|]
operator|=
literal|')'
expr_stmt|;
name|zSql
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|sqlite3_prepare
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
name|zSql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"Error: "
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|pDb
operator|->
name|db
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|in
operator|=
name|fopen
argument_list|(
name|zFile
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"Error: cannot open file: "
argument_list|,
name|zFile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|azCol
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|azCol
index|[
literal|0
index|]
argument_list|)
operator|*
operator|(
name|nCol
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|azCol
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"Error: can't malloc()"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
operator|(
name|void
operator|)
name|sqlite3_exec
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
literal|"BEGIN"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zCommit
operator|=
literal|"COMMIT"
expr_stmt|;
while|while
condition|(
operator|(
name|zLine
operator|=
name|local_getline
argument_list|(
literal|0
argument_list|,
name|in
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|z
decl_stmt|;
name|lineno
operator|++
expr_stmt|;
name|azCol
index|[
literal|0
index|]
operator|=
name|zLine
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|z
operator|=
name|zLine
init|;
operator|*
name|z
condition|;
name|z
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|z
operator|==
name|zSep
index|[
literal|0
index|]
operator|&&
name|strncmp
argument_list|(
name|z
argument_list|,
name|zSep
argument_list|,
name|nSep
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|z
operator|=
literal|0
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|nCol
condition|)
block|{
name|azCol
index|[
name|i
index|]
operator|=
operator|&
name|z
index|[
name|nSep
index|]
expr_stmt|;
name|z
operator|+=
name|nSep
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|i
operator|+
literal|1
operator|!=
name|nCol
condition|)
block|{
name|char
modifier|*
name|zErr
decl_stmt|;
name|int
name|nErr
init|=
name|strlen30
argument_list|(
name|zFile
argument_list|)
operator|+
literal|200
decl_stmt|;
name|zErr
operator|=
name|malloc
argument_list|(
name|nErr
argument_list|)
expr_stmt|;
if|if
condition|(
name|zErr
condition|)
block|{
name|sqlite3_snprintf
argument_list|(
name|nErr
argument_list|,
name|zErr
argument_list|,
literal|"Error: %s line %d: expected %d columns of data but found %d"
argument_list|,
name|zFile
argument_list|,
name|lineno
argument_list|,
name|nCol
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|zErr
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zErr
argument_list|)
expr_stmt|;
block|}
name|zCommit
operator|=
literal|"ROLLBACK"
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nCol
condition|;
name|i
operator|++
control|)
block|{
comment|/* check for null data, if so, bind as null */
if|if
condition|(
operator|(
name|nNull
operator|>
literal|0
operator|&&
name|strcmp
argument_list|(
name|azCol
index|[
name|i
index|]
argument_list|,
name|zNull
argument_list|)
operator|==
literal|0
operator|)
operator|||
name|strlen30
argument_list|(
name|azCol
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sqlite3_bind_null
argument_list|(
name|pStmt
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sqlite3_bind_text
argument_list|(
name|pStmt
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|azCol
index|[
name|i
index|]
argument_list|,
operator|-
literal|1
argument_list|,
name|SQLITE_STATIC
argument_list|)
expr_stmt|;
block|}
block|}
name|sqlite3_step
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_reset
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zLine
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"Error: "
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|pDb
operator|->
name|db
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|zCommit
operator|=
literal|"ROLLBACK"
expr_stmt|;
break|break;
block|}
block|}
name|free
argument_list|(
name|azCol
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sqlite3_exec
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
name|zCommit
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zCommit
index|[
literal|0
index|]
operator|==
literal|'C'
condition|)
block|{
comment|/* success, set result as number of lines processed */
name|pResult
operator|=
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_SetIntObj
argument_list|(
name|pResult
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|rc
operator|=
name|TCL_OK
expr_stmt|;
block|}
else|else
block|{
comment|/* failure, append lineno where failed */
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|zLineNum
argument_list|)
argument_list|,
name|zLineNum
argument_list|,
literal|"%d"
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|", failed while processing line: "
argument_list|,
name|zLineNum
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
break|break;
block|}
comment|/*   **    $db enable_load_extension BOOLEAN   **   ** Turn the extension loading feature on or off.  It if off by   ** default.   */
case|case
name|DB_ENABLE_LOAD_EXTENSION
case|:
block|{
ifndef|#
directive|ifndef
name|SQLITE_OMIT_LOAD_EXTENSION
name|int
name|onoff
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"BOOLEAN"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetBooleanFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|onoff
argument_list|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|sqlite3_enable_load_extension
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
name|onoff
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"extension loading is turned off at compile-time"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
endif|#
directive|endif
block|}
comment|/*   **    $db errorcode   **   ** Return the numeric error code that was returned by the most recent   ** call to sqlite3_exec().   */
case|case
name|DB_ERRORCODE
case|:
block|{
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|Tcl_NewIntObj
argument_list|(
name|sqlite3_errcode
argument_list|(
name|pDb
operator|->
name|db
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*   **    $db exists $sql   **    $db onecolumn $sql   **   ** The onecolumn method is the equivalent of:   **     lindex [$db eval $sql] 0   */
case|case
name|DB_EXISTS
case|:
case|case
name|DB_ONECOLUMN
case|:
block|{
name|Tcl_Obj
modifier|*
name|pResult
init|=
literal|0
decl_stmt|;
name|DbEvalContext
name|sEval
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"SQL"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|dbEvalInit
argument_list|(
operator|&
name|sEval
argument_list|,
name|pDb
argument_list|,
name|objv
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|dbEvalStep
argument_list|(
operator|&
name|sEval
argument_list|)
expr_stmt|;
if|if
condition|(
name|choice
operator|==
name|DB_ONECOLUMN
condition|)
block|{
if|if
condition|(
name|rc
operator|==
name|TCL_OK
condition|)
block|{
name|pResult
operator|=
name|dbEvalColumnValue
argument_list|(
operator|&
name|sEval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|==
name|TCL_BREAK
condition|)
block|{
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rc
operator|==
name|TCL_BREAK
operator|||
name|rc
operator|==
name|TCL_OK
condition|)
block|{
name|pResult
operator|=
name|Tcl_NewBooleanObj
argument_list|(
name|rc
operator|==
name|TCL_OK
argument_list|)
expr_stmt|;
block|}
name|dbEvalFinalize
argument_list|(
operator|&
name|sEval
argument_list|)
expr_stmt|;
if|if
condition|(
name|pResult
condition|)
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|pResult
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|TCL_BREAK
condition|)
block|{
name|rc
operator|=
name|TCL_OK
expr_stmt|;
block|}
break|break;
block|}
comment|/*   **    $db eval $sql ?array? ?{  ...code... }?   **   ** The SQL statement in $sql is evaluated.  For each row, the values are   ** placed in elements of the array named "array" and ...code... is executed.   ** If "array" and "code" are omitted, then no callback is every invoked.   ** If "array" is an empty string, then the values are placed in variables   ** that have the same name as the fields extracted by the query.   */
case|case
name|DB_EVAL
case|:
block|{
if|if
condition|(
name|objc
operator|<
literal|3
operator|||
name|objc
operator|>
literal|5
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"SQL ?ARRAY-NAME? ?SCRIPT?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|objc
operator|==
literal|3
condition|)
block|{
name|DbEvalContext
name|sEval
decl_stmt|;
name|Tcl_Obj
modifier|*
name|pRet
init|=
name|Tcl_NewObj
argument_list|()
decl_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|pRet
argument_list|)
expr_stmt|;
name|dbEvalInit
argument_list|(
operator|&
name|sEval
argument_list|,
name|pDb
argument_list|,
name|objv
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|TCL_OK
operator|==
operator|(
name|rc
operator|=
name|dbEvalStep
argument_list|(
operator|&
name|sEval
argument_list|)
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|nCol
decl_stmt|;
name|dbEvalRowInfo
argument_list|(
operator|&
name|sEval
argument_list|,
operator|&
name|nCol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nCol
condition|;
name|i
operator|++
control|)
block|{
name|Tcl_ListObjAppendElement
argument_list|(
name|interp
argument_list|,
name|pRet
argument_list|,
name|dbEvalColumnValue
argument_list|(
operator|&
name|sEval
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|dbEvalFinalize
argument_list|(
operator|&
name|sEval
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|TCL_BREAK
condition|)
block|{
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|pRet
argument_list|)
expr_stmt|;
name|rc
operator|=
name|TCL_OK
expr_stmt|;
block|}
name|Tcl_DecrRefCount
argument_list|(
name|pRet
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ClientData
name|cd2
index|[
literal|2
index|]
decl_stmt|;
name|DbEvalContext
modifier|*
name|p
decl_stmt|;
name|Tcl_Obj
modifier|*
name|pArray
init|=
literal|0
decl_stmt|;
name|Tcl_Obj
modifier|*
name|pScript
decl_stmt|;
if|if
condition|(
name|objc
operator|==
literal|5
operator|&&
operator|*
operator|(
name|char
operator|*
operator|)
name|Tcl_GetString
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
name|pArray
operator|=
name|objv
index|[
literal|3
index|]
expr_stmt|;
block|}
name|pScript
operator|=
name|objv
index|[
name|objc
operator|-
literal|1
index|]
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|pScript
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|DbEvalContext
operator|*
operator|)
name|Tcl_Alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DbEvalContext
argument_list|)
argument_list|)
expr_stmt|;
name|dbEvalInit
argument_list|(
name|p
argument_list|,
name|pDb
argument_list|,
name|objv
index|[
literal|2
index|]
argument_list|,
name|pArray
argument_list|)
expr_stmt|;
name|cd2
index|[
literal|0
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|p
expr_stmt|;
name|cd2
index|[
literal|1
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|pScript
expr_stmt|;
name|rc
operator|=
name|DbEvalNextCmd
argument_list|(
name|cd2
argument_list|,
name|interp
argument_list|,
name|TCL_OK
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/*   **     $db function NAME [-argcount N] [-deterministic] SCRIPT   **   ** Create a new SQL function called NAME.  Whenever that function is   ** called, invoke SCRIPT to evaluate the function.   */
case|case
name|DB_FUNCTION
case|:
block|{
name|int
name|flags
init|=
name|SQLITE_UTF8
decl_stmt|;
name|SqlFunc
modifier|*
name|pFunc
decl_stmt|;
name|Tcl_Obj
modifier|*
name|pScript
decl_stmt|;
name|char
modifier|*
name|zName
decl_stmt|;
name|int
name|nArg
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|4
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"NAME ?SWITCHES? SCRIPT"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
operator|(
name|objc
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|z
init|=
name|Tcl_GetString
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|int
name|n
init|=
name|strlen30
argument_list|(
name|z
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|>
literal|2
operator|&&
name|strncmp
argument_list|(
name|z
argument_list|,
literal|"-argcount"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
operator|(
name|objc
operator|-
literal|2
operator|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"option requires an argument: "
argument_list|,
name|z
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetIntFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|&
name|nArg
argument_list|)
condition|)
return|return
name|TCL_ERROR
return|;
if|if
condition|(
name|nArg
operator|<
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"number of arguments must be non-negative"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|>
literal|2
operator|&&
name|strncmp
argument_list|(
name|z
argument_list|,
literal|"-deterministic"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|flags
operator||=
name|SQLITE_DETERMINISTIC
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad option \""
argument_list|,
name|z
argument_list|,
literal|"\": must be -argcount or -deterministic"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
name|pScript
operator|=
name|objv
index|[
name|objc
operator|-
literal|1
index|]
expr_stmt|;
name|zName
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pFunc
operator|=
name|findSqlFunc
argument_list|(
name|pDb
argument_list|,
name|zName
argument_list|)
expr_stmt|;
if|if
condition|(
name|pFunc
operator|==
literal|0
condition|)
return|return
name|TCL_ERROR
return|;
if|if
condition|(
name|pFunc
operator|->
name|pScript
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|pFunc
operator|->
name|pScript
argument_list|)
expr_stmt|;
block|}
name|pFunc
operator|->
name|pScript
operator|=
name|pScript
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|pScript
argument_list|)
expr_stmt|;
name|pFunc
operator|->
name|useEvalObjv
operator|=
name|safeToUseEvalObjv
argument_list|(
name|interp
argument_list|,
name|pScript
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_create_function
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
name|zName
argument_list|,
name|nArg
argument_list|,
name|flags
argument_list|,
name|pFunc
argument_list|,
name|tclSqlFunc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
condition|)
block|{
name|rc
operator|=
name|TCL_ERROR
expr_stmt|;
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sqlite3_errmsg
argument_list|(
name|pDb
operator|->
name|db
argument_list|)
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/*   **     $db incrblob ?-readonly? ?DB? TABLE COLUMN ROWID   */
case|case
name|DB_INCRBLOB
case|:
block|{
ifdef|#
directive|ifdef
name|SQLITE_OMIT_INCRBLOB
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"incrblob not available in this build"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
else|#
directive|else
name|int
name|isReadonly
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|zDb
init|=
literal|"main"
decl_stmt|;
specifier|const
name|char
modifier|*
name|zTable
decl_stmt|;
specifier|const
name|char
modifier|*
name|zColumn
decl_stmt|;
name|Tcl_WideInt
name|iRow
decl_stmt|;
comment|/* Check for the -readonly option */
if|if
condition|(
name|objc
operator|>
literal|3
operator|&&
name|strcmp
argument_list|(
name|Tcl_GetString
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|)
argument_list|,
literal|"-readonly"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|isReadonly
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|objc
operator|!=
operator|(
literal|5
operator|+
name|isReadonly
operator|)
operator|&&
name|objc
operator|!=
operator|(
literal|6
operator|+
name|isReadonly
operator|)
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?-readonly? ?DB? TABLE COLUMN ROWID"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|objc
operator|==
operator|(
literal|6
operator|+
name|isReadonly
operator|)
condition|)
block|{
name|zDb
operator|=
name|Tcl_GetString
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
name|zTable
operator|=
name|Tcl_GetString
argument_list|(
name|objv
index|[
name|objc
operator|-
literal|3
index|]
argument_list|)
expr_stmt|;
name|zColumn
operator|=
name|Tcl_GetString
argument_list|(
name|objv
index|[
name|objc
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
name|rc
operator|=
name|Tcl_GetWideIntFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
name|objc
operator|-
literal|1
index|]
argument_list|,
operator|&
name|iRow
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|TCL_OK
condition|)
block|{
name|rc
operator|=
name|createIncrblobChannel
argument_list|(
name|interp
argument_list|,
name|pDb
argument_list|,
name|zDb
argument_list|,
name|zTable
argument_list|,
name|zColumn
argument_list|,
operator|(
name|sqlite3_int64
operator|)
name|iRow
argument_list|,
name|isReadonly
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
block|}
comment|/*   **     $db interrupt   **   ** Interrupt the execution of the inner-most SQL interpreter.  This   ** causes the SQL statement to return an error of SQLITE_INTERRUPT.   */
case|case
name|DB_INTERRUPT
case|:
block|{
name|sqlite3_interrupt
argument_list|(
name|pDb
operator|->
name|db
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*   **     $db nullvalue ?STRING?   **   ** Change text used when a NULL comes back from the database. If ?STRING?   ** is not present, then the current string used for NULL is returned.   ** If STRING is present, then STRING is returned.   **   */
case|case
name|DB_NULLVALUE
case|:
block|{
if|if
condition|(
name|objc
operator|!=
literal|2
operator|&&
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"NULLVALUE"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|objc
operator|==
literal|3
condition|)
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|zNull
init|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|pDb
operator|->
name|zNull
condition|)
block|{
name|Tcl_Free
argument_list|(
name|pDb
operator|->
name|zNull
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zNull
operator|&&
name|len
operator|>
literal|0
condition|)
block|{
name|pDb
operator|->
name|zNull
operator|=
name|Tcl_Alloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pDb
operator|->
name|zNull
argument_list|,
name|zNull
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|pDb
operator|->
name|zNull
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|pDb
operator|->
name|zNull
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|Tcl_NewStringObj
argument_list|(
name|pDb
operator|->
name|zNull
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*   **     $db last_insert_rowid   **   ** Return an integer which is the ROWID for the most recent insert.   */
case|case
name|DB_LAST_INSERT_ROWID
case|:
block|{
name|Tcl_Obj
modifier|*
name|pResult
decl_stmt|;
name|Tcl_WideInt
name|rowid
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|rowid
operator|=
name|sqlite3_last_insert_rowid
argument_list|(
name|pDb
operator|->
name|db
argument_list|)
expr_stmt|;
name|pResult
operator|=
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_SetWideIntObj
argument_list|(
name|pResult
argument_list|,
name|rowid
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*   ** The DB_ONECOLUMN method is implemented together with DB_EXISTS.   */
comment|/*    $db progress ?N CALLBACK?   **   ** Invoke the given callback every N virtual machine opcodes while executing   ** queries.   */
case|case
name|DB_PROGRESS
case|:
block|{
if|if
condition|(
name|objc
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|pDb
operator|->
name|zProgress
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|pDb
operator|->
name|zProgress
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|objc
operator|==
literal|4
condition|)
block|{
name|char
modifier|*
name|zProgress
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|N
decl_stmt|;
if|if
condition|(
name|TCL_OK
operator|!=
name|Tcl_GetIntFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|N
argument_list|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
empty_stmt|;
if|if
condition|(
name|pDb
operator|->
name|zProgress
condition|)
block|{
name|Tcl_Free
argument_list|(
name|pDb
operator|->
name|zProgress
argument_list|)
expr_stmt|;
block|}
name|zProgress
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|zProgress
operator|&&
name|len
operator|>
literal|0
condition|)
block|{
name|pDb
operator|->
name|zProgress
operator|=
name|Tcl_Alloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pDb
operator|->
name|zProgress
argument_list|,
name|zProgress
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pDb
operator|->
name|zProgress
operator|=
literal|0
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|SQLITE_OMIT_PROGRESS_CALLBACK
if|if
condition|(
name|pDb
operator|->
name|zProgress
condition|)
block|{
name|pDb
operator|->
name|interp
operator|=
name|interp
expr_stmt|;
name|sqlite3_progress_handler
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
name|N
argument_list|,
name|DbProgressHandler
argument_list|,
name|pDb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sqlite3_progress_handler
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"N CALLBACK"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
break|break;
block|}
comment|/*    $db profile ?CALLBACK?   **   ** Make arrangements to invoke the CALLBACK routine after each SQL statement   ** that has run.  The text of the SQL and the amount of elapse time are   ** appended to CALLBACK before the script is run.   */
case|case
name|DB_PROFILE
case|:
block|{
if|if
condition|(
name|objc
operator|>
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?CALLBACK?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|objc
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|pDb
operator|->
name|zProfile
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|pDb
operator|->
name|zProfile
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|zProfile
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|pDb
operator|->
name|zProfile
condition|)
block|{
name|Tcl_Free
argument_list|(
name|pDb
operator|->
name|zProfile
argument_list|)
expr_stmt|;
block|}
name|zProfile
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|zProfile
operator|&&
name|len
operator|>
literal|0
condition|)
block|{
name|pDb
operator|->
name|zProfile
operator|=
name|Tcl_Alloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pDb
operator|->
name|zProfile
argument_list|,
name|zProfile
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pDb
operator|->
name|zProfile
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SQLITE_OMIT_TRACE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SQLITE_OMIT_FLOATING_POINT
argument_list|)
if|if
condition|(
name|pDb
operator|->
name|zProfile
condition|)
block|{
name|pDb
operator|->
name|interp
operator|=
name|interp
expr_stmt|;
name|sqlite3_profile
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
name|DbProfileHandler
argument_list|,
name|pDb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sqlite3_profile
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
break|break;
block|}
comment|/*   **     $db rekey KEY   **   ** Change the encryption key on the currently open database.   */
case|case
name|DB_REKEY
case|:
block|{
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_HAS_CODEC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SQLITE_OMIT_CODEC_FROM_TCL
argument_list|)
name|int
name|nKey
decl_stmt|;
name|void
modifier|*
name|pKey
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"KEY"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_HAS_CODEC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SQLITE_OMIT_CODEC_FROM_TCL
argument_list|)
name|pKey
operator|=
name|Tcl_GetByteArrayFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|nKey
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_rekey
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
name|pKey
argument_list|,
name|nKey
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|sqlite3_errstr
argument_list|(
name|rc
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
block|}
comment|/*    $db restore ?DATABASE? FILENAME   **   ** Open a database file named FILENAME.  Transfer the content   ** of FILENAME into the local database DATABASE (default: "main").   */
case|case
name|DB_RESTORE
case|:
block|{
specifier|const
name|char
modifier|*
name|zSrcFile
decl_stmt|;
specifier|const
name|char
modifier|*
name|zDestDb
decl_stmt|;
name|sqlite3
modifier|*
name|pSrc
decl_stmt|;
name|sqlite3_backup
modifier|*
name|pBackup
decl_stmt|;
name|int
name|nTimeout
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|objc
operator|==
literal|3
condition|)
block|{
name|zDestDb
operator|=
literal|"main"
expr_stmt|;
name|zSrcFile
operator|=
name|Tcl_GetString
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|objc
operator|==
literal|4
condition|)
block|{
name|zDestDb
operator|=
name|Tcl_GetString
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|zSrcFile
operator|=
name|Tcl_GetString
argument_list|(
name|objv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?DATABASE? FILENAME"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|rc
operator|=
name|sqlite3_open_v2
argument_list|(
name|zSrcFile
argument_list|,
operator|&
name|pSrc
argument_list|,
name|SQLITE_OPEN_READONLY
operator||
name|pDb
operator|->
name|openFlags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"cannot open source database: "
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|pSrc
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_close
argument_list|(
name|pSrc
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|pBackup
operator|=
name|sqlite3_backup_init
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
name|zDestDb
argument_list|,
name|pSrc
argument_list|,
literal|"main"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pBackup
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"restore failed: "
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|pDb
operator|->
name|db
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_close
argument_list|(
name|pSrc
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
while|while
condition|(
operator|(
name|rc
operator|=
name|sqlite3_backup_step
argument_list|(
name|pBackup
argument_list|,
literal|100
argument_list|)
operator|)
operator|==
name|SQLITE_OK
operator|||
name|rc
operator|==
name|SQLITE_BUSY
condition|)
block|{
if|if
condition|(
name|rc
operator|==
name|SQLITE_BUSY
condition|)
block|{
if|if
condition|(
name|nTimeout
operator|++
operator|>=
literal|3
condition|)
break|break;
name|sqlite3_sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
name|sqlite3_backup_finish
argument_list|(
name|pBackup
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|SQLITE_DONE
condition|)
block|{
name|rc
operator|=
name|TCL_OK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|==
name|SQLITE_BUSY
operator|||
name|rc
operator|==
name|SQLITE_LOCKED
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"restore failed: source database busy"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"restore failed: "
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|pDb
operator|->
name|db
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
name|sqlite3_close
argument_list|(
name|pSrc
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*   **     $db status (step|sort|autoindex)   **   ** Display SQLITE_STMTSTATUS_FULLSCAN_STEP or   ** SQLITE_STMTSTATUS_SORT for the most recent eval.   */
case|case
name|DB_STATUS
case|:
block|{
name|int
name|v
decl_stmt|;
specifier|const
name|char
modifier|*
name|zOp
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"(step|sort|autoindex)"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|zOp
operator|=
name|Tcl_GetString
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|zOp
argument_list|,
literal|"step"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|v
operator|=
name|pDb
operator|->
name|nStep
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|zOp
argument_list|,
literal|"sort"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|v
operator|=
name|pDb
operator|->
name|nSort
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|zOp
argument_list|,
literal|"autoindex"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|v
operator|=
name|pDb
operator|->
name|nIndex
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"bad argument: should be autoindex, step, or sort"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|Tcl_NewIntObj
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*   **     $db timeout MILLESECONDS   **   ** Delay for the number of milliseconds specified when a file is locked.   */
case|case
name|DB_TIMEOUT
case|:
block|{
name|int
name|ms
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"MILLISECONDS"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetIntFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|ms
argument_list|)
condition|)
return|return
name|TCL_ERROR
return|;
name|sqlite3_busy_timeout
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
name|ms
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*   **     $db total_changes   **   ** Return the number of rows that were modified, inserted, or deleted   ** since the database handle was created.   */
case|case
name|DB_TOTAL_CHANGES
case|:
block|{
name|Tcl_Obj
modifier|*
name|pResult
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|pResult
operator|=
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Tcl_SetIntObj
argument_list|(
name|pResult
argument_list|,
name|sqlite3_total_changes
argument_list|(
name|pDb
operator|->
name|db
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*    $db trace ?CALLBACK?   **   ** Make arrangements to invoke the CALLBACK routine for each SQL statement   ** that is executed.  The text of the SQL is appended to CALLBACK before   ** it is executed.   */
case|case
name|DB_TRACE
case|:
block|{
if|if
condition|(
name|objc
operator|>
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?CALLBACK?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|objc
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|pDb
operator|->
name|zTrace
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|pDb
operator|->
name|zTrace
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|zTrace
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|pDb
operator|->
name|zTrace
condition|)
block|{
name|Tcl_Free
argument_list|(
name|pDb
operator|->
name|zTrace
argument_list|)
expr_stmt|;
block|}
name|zTrace
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|zTrace
operator|&&
name|len
operator|>
literal|0
condition|)
block|{
name|pDb
operator|->
name|zTrace
operator|=
name|Tcl_Alloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pDb
operator|->
name|zTrace
argument_list|,
name|zTrace
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pDb
operator|->
name|zTrace
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SQLITE_OMIT_TRACE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SQLITE_OMIT_FLOATING_POINT
argument_list|)
expr|\
operator|&&
operator|!
name|defined
argument_list|(
name|SQLITE_OMIT_DEPRECATED
argument_list|)
if|if
condition|(
name|pDb
operator|->
name|zTrace
condition|)
block|{
name|pDb
operator|->
name|interp
operator|=
name|interp
expr_stmt|;
name|sqlite3_trace
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
name|DbTraceHandler
argument_list|,
name|pDb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sqlite3_trace
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
break|break;
block|}
comment|/*    $db trace_v2 ?CALLBACK? ?MASK?   **   ** Make arrangements to invoke the CALLBACK routine for each trace event   ** matching the mask that is generated.  The parameters are appended to   ** CALLBACK before it is executed.   */
case|case
name|DB_TRACE_V2
case|:
block|{
if|if
condition|(
name|objc
operator|>
literal|4
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?CALLBACK? ?MASK?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|objc
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|pDb
operator|->
name|zTraceV2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|pDb
operator|->
name|zTraceV2
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|zTraceV2
decl_stmt|;
name|int
name|len
decl_stmt|;
name|Tcl_WideInt
name|wMask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|objc
operator|==
literal|4
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|TTYPE_strs
index|[]
init|=
block|{
literal|"statement"
block|,
literal|"profile"
block|,
literal|"row"
block|,
literal|"close"
block|,
literal|0
block|}
decl_stmt|;
enum|enum
name|TTYPE_enum
block|{
name|TTYPE_STMT
block|,
name|TTYPE_PROFILE
block|,
name|TTYPE_ROW
block|,
name|TTYPE_CLOSE
block|}
enum|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TCL_OK
operator|!=
name|Tcl_ListObjLength
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|len
argument_list|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|Tcl_Obj
modifier|*
name|pObj
decl_stmt|;
name|int
name|ttype
decl_stmt|;
if|if
condition|(
name|TCL_OK
operator|!=
name|Tcl_ListObjIndex
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|3
index|]
argument_list|,
name|i
argument_list|,
operator|&
name|pObj
argument_list|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetIndexFromObj
argument_list|(
name|interp
argument_list|,
name|pObj
argument_list|,
name|TTYPE_strs
argument_list|,
literal|"trace type"
argument_list|,
literal|0
argument_list|,
operator|&
name|ttype
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
name|Tcl_WideInt
name|wType
decl_stmt|;
name|Tcl_Obj
modifier|*
name|pError
init|=
name|Tcl_DuplicateObj
argument_list|(
name|Tcl_GetObjResult
argument_list|(
name|interp
argument_list|)
argument_list|)
decl_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|pError
argument_list|)
expr_stmt|;
if|if
condition|(
name|TCL_OK
operator|==
name|Tcl_GetWideIntFromObj
argument_list|(
name|interp
argument_list|,
name|pObj
argument_list|,
operator|&
name|wType
argument_list|)
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|pError
argument_list|)
expr_stmt|;
name|wMask
operator||=
name|wType
expr_stmt|;
block|}
else|else
block|{
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|pError
argument_list|)
expr_stmt|;
name|Tcl_DecrRefCount
argument_list|(
name|pError
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
operator|(
expr|enum
name|TTYPE_enum
operator|)
name|ttype
condition|)
block|{
case|case
name|TTYPE_STMT
case|:
name|wMask
operator||=
name|SQLITE_TRACE_STMT
expr_stmt|;
break|break;
case|case
name|TTYPE_PROFILE
case|:
name|wMask
operator||=
name|SQLITE_TRACE_PROFILE
expr_stmt|;
break|break;
case|case
name|TTYPE_ROW
case|:
name|wMask
operator||=
name|SQLITE_TRACE_ROW
expr_stmt|;
break|break;
case|case
name|TTYPE_CLOSE
case|:
name|wMask
operator||=
name|SQLITE_TRACE_CLOSE
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
else|else
block|{
name|wMask
operator|=
name|SQLITE_TRACE_STMT
expr_stmt|;
comment|/* use the "legacy" default */
block|}
if|if
condition|(
name|pDb
operator|->
name|zTraceV2
condition|)
block|{
name|Tcl_Free
argument_list|(
name|pDb
operator|->
name|zTraceV2
argument_list|)
expr_stmt|;
block|}
name|zTraceV2
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|zTraceV2
operator|&&
name|len
operator|>
literal|0
condition|)
block|{
name|pDb
operator|->
name|zTraceV2
operator|=
name|Tcl_Alloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pDb
operator|->
name|zTraceV2
argument_list|,
name|zTraceV2
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pDb
operator|->
name|zTraceV2
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SQLITE_OMIT_TRACE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SQLITE_OMIT_FLOATING_POINT
argument_list|)
if|if
condition|(
name|pDb
operator|->
name|zTraceV2
condition|)
block|{
name|pDb
operator|->
name|interp
operator|=
name|interp
expr_stmt|;
name|sqlite3_trace_v2
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
operator|(
name|unsigned
operator|)
name|wMask
argument_list|,
name|DbTraceV2Handler
argument_list|,
name|pDb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sqlite3_trace_v2
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
break|break;
block|}
comment|/*    $db transaction [-deferred|-immediate|-exclusive] SCRIPT   **   ** Start a new transaction (if we are not already in the midst of a   ** transaction) and execute the TCL script SCRIPT.  After SCRIPT   ** completes, either commit the transaction or roll it back if SCRIPT   ** throws an exception.  Or if no new transation was started, do nothing.   ** pass the exception on up the stack.   **   ** This command was inspired by Dave Thomas's talk on Ruby at the   ** 2005 O'Reilly Open Source Convention (OSCON).   */
case|case
name|DB_TRANSACTION
case|:
block|{
name|Tcl_Obj
modifier|*
name|pScript
decl_stmt|;
specifier|const
name|char
modifier|*
name|zBegin
init|=
literal|"SAVEPOINT _tcl_transaction"
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|3
operator|&&
name|objc
operator|!=
literal|4
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"[TYPE] SCRIPT"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|pDb
operator|->
name|nTransaction
operator|==
literal|0
operator|&&
name|objc
operator|==
literal|4
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|TTYPE_strs
index|[]
init|=
block|{
literal|"deferred"
block|,
literal|"exclusive"
block|,
literal|"immediate"
block|,
literal|0
block|}
decl_stmt|;
enum|enum
name|TTYPE_enum
block|{
name|TTYPE_DEFERRED
block|,
name|TTYPE_EXCLUSIVE
block|,
name|TTYPE_IMMEDIATE
block|}
enum|;
name|int
name|ttype
decl_stmt|;
if|if
condition|(
name|Tcl_GetIndexFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|2
index|]
argument_list|,
name|TTYPE_strs
argument_list|,
literal|"transaction type"
argument_list|,
literal|0
argument_list|,
operator|&
name|ttype
argument_list|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
switch|switch
condition|(
operator|(
expr|enum
name|TTYPE_enum
operator|)
name|ttype
condition|)
block|{
case|case
name|TTYPE_DEFERRED
case|:
comment|/* no-op */
empty_stmt|;
break|break;
case|case
name|TTYPE_EXCLUSIVE
case|:
name|zBegin
operator|=
literal|"BEGIN EXCLUSIVE"
expr_stmt|;
break|break;
case|case
name|TTYPE_IMMEDIATE
case|:
name|zBegin
operator|=
literal|"BEGIN IMMEDIATE"
expr_stmt|;
break|break;
block|}
block|}
name|pScript
operator|=
name|objv
index|[
name|objc
operator|-
literal|1
index|]
expr_stmt|;
comment|/* Run the SQLite BEGIN command to open a transaction or savepoint. */
name|pDb
operator|->
name|disableAuth
operator|++
expr_stmt|;
name|rc
operator|=
name|sqlite3_exec
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
name|zBegin
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pDb
operator|->
name|disableAuth
operator|--
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|pDb
operator|->
name|db
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|pDb
operator|->
name|nTransaction
operator|++
expr_stmt|;
comment|/* If using NRE, schedule a callback to invoke the script pScript, then     ** a second callback to commit (or rollback) the transaction or savepoint     ** opened above. If not using NRE, evaluate the script directly, then     ** call function DbTransPostCmd() to commit (or rollback) the transaction     ** or savepoint.  */
if|if
condition|(
name|DbUseNre
argument_list|()
condition|)
block|{
name|Tcl_NRAddCallback
argument_list|(
name|interp
argument_list|,
name|DbTransPostCmd
argument_list|,
name|cd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Tcl_NREvalObj
argument_list|(
name|interp
argument_list|,
name|pScript
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|DbTransPostCmd
argument_list|(
operator|&
name|cd
argument_list|,
name|interp
argument_list|,
name|Tcl_EvalObjEx
argument_list|(
name|interp
argument_list|,
name|pScript
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/*   **    $db unlock_notify ?script?   */
case|case
name|DB_UNLOCK_NOTIFY
case|:
block|{
ifndef|#
directive|ifndef
name|SQLITE_ENABLE_UNLOCK_NOTIFY
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"unlock_notify not available in this build"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|TCL_ERROR
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|objc
operator|!=
literal|2
operator|&&
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?SCRIPT?"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
else|else
block|{
name|void
function_decl|(
modifier|*
name|xNotify
function_decl|)
parameter_list|(
name|void
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
init|=
literal|0
function_decl|;
name|void
modifier|*
name|pNotifyArg
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pDb
operator|->
name|pUnlockNotify
condition|)
block|{
name|Tcl_DecrRefCount
argument_list|(
name|pDb
operator|->
name|pUnlockNotify
argument_list|)
expr_stmt|;
name|pDb
operator|->
name|pUnlockNotify
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|objc
operator|==
literal|3
condition|)
block|{
name|xNotify
operator|=
name|DbUnlockNotify
expr_stmt|;
name|pNotifyArg
operator|=
operator|(
name|void
operator|*
operator|)
name|pDb
expr_stmt|;
name|pDb
operator|->
name|pUnlockNotify
operator|=
name|objv
index|[
literal|2
index|]
expr_stmt|;
name|Tcl_IncrRefCount
argument_list|(
name|pDb
operator|->
name|pUnlockNotify
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sqlite3_unlock_notify
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
name|xNotify
argument_list|,
name|pNotifyArg
argument_list|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|pDb
operator|->
name|db
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|TCL_ERROR
expr_stmt|;
block|}
block|}
endif|#
directive|endif
break|break;
block|}
comment|/*   **    $db preupdate_hook count   **    $db preupdate_hook hook ?SCRIPT?   **    $db preupdate_hook new INDEX   **    $db preupdate_hook old INDEX   */
case|case
name|DB_PREUPDATE
case|:
block|{
ifndef|#
directive|ifndef
name|SQLITE_ENABLE_PREUPDATE_HOOK
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"preupdate_hook was omitted at compile-time"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|TCL_ERROR
expr_stmt|;
else|#
directive|else
specifier|static
specifier|const
name|char
modifier|*
name|azSub
index|[]
init|=
block|{
literal|"count"
block|,
literal|"depth"
block|,
literal|"hook"
block|,
literal|"new"
block|,
literal|"old"
block|,
literal|0
block|}
decl_stmt|;
enum|enum
name|DbPreupdateSubCmd
block|{
name|PRE_COUNT
block|,
name|PRE_DEPTH
block|,
name|PRE_HOOK
block|,
name|PRE_NEW
block|,
name|PRE_OLD
block|}
enum|;
name|int
name|iSub
decl_stmt|;
if|if
condition|(
name|objc
operator|<
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"SUB-COMMAND ?ARGS?"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Tcl_GetIndexFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|2
index|]
argument_list|,
name|azSub
argument_list|,
literal|"sub-command"
argument_list|,
literal|0
argument_list|,
operator|&
name|iSub
argument_list|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
switch|switch
condition|(
operator|(
expr|enum
name|DbPreupdateSubCmd
operator|)
name|iSub
condition|)
block|{
case|case
name|PRE_COUNT
case|:
block|{
name|int
name|nCol
init|=
name|sqlite3_preupdate_count
argument_list|(
name|pDb
operator|->
name|db
argument_list|)
decl_stmt|;
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|Tcl_NewIntObj
argument_list|(
name|nCol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|PRE_HOOK
case|:
block|{
if|if
condition|(
name|objc
operator|>
literal|4
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"hook ?SCRIPT?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|DbHookCmd
argument_list|(
name|interp
argument_list|,
name|pDb
argument_list|,
operator|(
name|objc
operator|==
literal|4
condition|?
name|objv
index|[
literal|3
index|]
else|:
literal|0
operator|)
argument_list|,
operator|&
name|pDb
operator|->
name|pPreUpdateHook
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|PRE_DEPTH
case|:
block|{
name|Tcl_Obj
modifier|*
name|pRet
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|3
argument_list|,
name|objv
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|pRet
operator|=
name|Tcl_NewIntObj
argument_list|(
name|sqlite3_preupdate_depth
argument_list|(
name|pDb
operator|->
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|pRet
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|PRE_NEW
case|:
case|case
name|PRE_OLD
case|:
block|{
name|int
name|iIdx
decl_stmt|;
name|sqlite3_value
modifier|*
name|pValue
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|4
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|3
argument_list|,
name|objv
argument_list|,
literal|"INDEX"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|Tcl_GetIntFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|3
index|]
argument_list|,
operator|&
name|iIdx
argument_list|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
name|iSub
operator|==
name|PRE_OLD
condition|)
block|{
name|rc
operator|=
name|sqlite3_preupdate_old
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
name|iIdx
argument_list|,
operator|&
name|pValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|iSub
operator|==
name|PRE_NEW
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_preupdate_new
argument_list|(
name|pDb
operator|->
name|db
argument_list|,
name|iIdx
argument_list|,
operator|&
name|pValue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|==
name|SQLITE_OK
condition|)
block|{
name|Tcl_Obj
modifier|*
name|pObj
decl_stmt|;
name|pObj
operator|=
name|Tcl_NewStringObj
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sqlite3_value_text
argument_list|(
name|pValue
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Tcl_SetObjResult
argument_list|(
name|interp
argument_list|,
name|pObj
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|pDb
operator|->
name|db
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* SQLITE_ENABLE_PREUPDATE_HOOK */
break|break;
block|}
comment|/*   **    $db wal_hook ?script?   **    $db update_hook ?script?   **    $db rollback_hook ?script?   */
case|case
name|DB_WAL_HOOK
case|:
case|case
name|DB_UPDATE_HOOK
case|:
case|case
name|DB_ROLLBACK_HOOK
case|:
block|{
comment|/* set ppHook to point at pUpdateHook or pRollbackHook, depending on     ** whether [$db update_hook] or [$db rollback_hook] was invoked.     */
name|Tcl_Obj
modifier|*
modifier|*
name|ppHook
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|choice
operator|==
name|DB_WAL_HOOK
condition|)
name|ppHook
operator|=
operator|&
name|pDb
operator|->
name|pWalHook
expr_stmt|;
if|if
condition|(
name|choice
operator|==
name|DB_UPDATE_HOOK
condition|)
name|ppHook
operator|=
operator|&
name|pDb
operator|->
name|pUpdateHook
expr_stmt|;
if|if
condition|(
name|choice
operator|==
name|DB_ROLLBACK_HOOK
condition|)
name|ppHook
operator|=
operator|&
name|pDb
operator|->
name|pRollbackHook
expr_stmt|;
if|if
condition|(
name|objc
operator|>
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|2
argument_list|,
name|objv
argument_list|,
literal|"?SCRIPT?"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|DbHookCmd
argument_list|(
name|interp
argument_list|,
name|pDb
argument_list|,
operator|(
name|objc
operator|==
literal|3
condition|?
name|objv
index|[
literal|2
index|]
else|:
literal|0
operator|)
argument_list|,
name|ppHook
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*    $db version   **   ** Return the version string for this database.   */
case|case
name|DB_VERSION
case|:
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sqlite3_libversion
argument_list|()
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* End of the SWITCH statement */
return|return
name|rc
return|;
block|}
end_function

begin_if
if|#
directive|if
name|SQLITE_TCL_NRE
end_if

begin_comment
comment|/* ** Adaptor that provides an objCmd interface to the NRE-enabled ** interface implementation. */
end_comment

begin_function
specifier|static
name|int
name|SQLITE_TCLAPI
name|DbObjCmdAdaptor
parameter_list|(
name|void
modifier|*
name|cd
parameter_list|,
name|Tcl_Interp
modifier|*
name|interp
parameter_list|,
name|int
name|objc
parameter_list|,
name|Tcl_Obj
modifier|*
specifier|const
modifier|*
name|objv
parameter_list|)
block|{
return|return
name|Tcl_NRCallObjProc
argument_list|(
name|interp
argument_list|,
name|DbObjCmd
argument_list|,
name|cd
argument_list|,
name|objc
argument_list|,
name|objv
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SQLITE_TCL_NRE */
end_comment

begin_comment
comment|/* **   sqlite3 DBNAME FILENAME ?-vfs VFSNAME? ?-key KEY? ?-readonly BOOLEAN? **                           ?-create BOOLEAN? ?-nomutex BOOLEAN? ** ** This is the main Tcl command.  When the "sqlite" Tcl command is ** invoked, this routine runs to process that command. ** ** The first argument, DBNAME, is an arbitrary name for a new ** database connection.  This command creates a new command named ** DBNAME that is used to control that connection.  The database ** connection is deleted when the DBNAME command is deleted. ** ** The second argument is the name of the database file. ** */
end_comment

begin_function
specifier|static
name|int
name|SQLITE_TCLAPI
name|DbMain
parameter_list|(
name|void
modifier|*
name|cd
parameter_list|,
name|Tcl_Interp
modifier|*
name|interp
parameter_list|,
name|int
name|objc
parameter_list|,
name|Tcl_Obj
modifier|*
specifier|const
modifier|*
name|objv
parameter_list|)
block|{
name|SqliteDb
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|zArg
decl_stmt|;
name|char
modifier|*
name|zErrMsg
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|zFile
decl_stmt|;
specifier|const
name|char
modifier|*
name|zVfs
init|=
literal|0
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|Tcl_DString
name|translatedFilename
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_HAS_CODEC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SQLITE_OMIT_CODEC_FROM_TCL
argument_list|)
name|void
modifier|*
name|pKey
init|=
literal|0
decl_stmt|;
name|int
name|nKey
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|int
name|rc
decl_stmt|;
comment|/* In normal use, each TCL interpreter runs in a single thread.  So   ** by default, we can turn of mutexing on SQLite database connections.   ** However, for testing purposes it is useful to have mutexes turned   ** on.  So, by default, mutexes default off.  But if compiled with   ** SQLITE_TCL_DEFAULT_FULLMUTEX then mutexes default on.   */
ifdef|#
directive|ifdef
name|SQLITE_TCL_DEFAULT_FULLMUTEX
name|flags
operator|=
name|SQLITE_OPEN_READWRITE
operator||
name|SQLITE_OPEN_CREATE
operator||
name|SQLITE_OPEN_FULLMUTEX
expr_stmt|;
else|#
directive|else
name|flags
operator|=
name|SQLITE_OPEN_READWRITE
operator||
name|SQLITE_OPEN_CREATE
operator||
name|SQLITE_OPEN_NOMUTEX
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|objc
operator|==
literal|2
condition|)
block|{
name|zArg
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|zArg
argument_list|,
literal|"-version"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|sqlite3_libversion
argument_list|()
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|zArg
argument_list|,
literal|"-sourceid"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|sqlite3_sourceid
argument_list|()
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|zArg
argument_list|,
literal|"-has-codec"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_HAS_CODEC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SQLITE_OMIT_CODEC_FROM_TCL
argument_list|)
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"1"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"0"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TCL_OK
return|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|+
literal|1
operator|<
name|objc
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|zArg
operator|=
name|Tcl_GetString
argument_list|(
name|objv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|zArg
argument_list|,
literal|"-key"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_HAS_CODEC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SQLITE_OMIT_CODEC_FROM_TCL
argument_list|)
name|pKey
operator|=
name|Tcl_GetByteArrayFromObj
argument_list|(
name|objv
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|&
name|nKey
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|zArg
argument_list|,
literal|"-vfs"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zVfs
operator|=
name|Tcl_GetString
argument_list|(
name|objv
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|zArg
argument_list|,
literal|"-readonly"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|b
decl_stmt|;
if|if
condition|(
name|Tcl_GetBooleanFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|&
name|b
argument_list|)
condition|)
return|return
name|TCL_ERROR
return|;
if|if
condition|(
name|b
condition|)
block|{
name|flags
operator|&=
operator|~
operator|(
name|SQLITE_OPEN_READWRITE
operator||
name|SQLITE_OPEN_CREATE
operator|)
expr_stmt|;
name|flags
operator||=
name|SQLITE_OPEN_READONLY
expr_stmt|;
block|}
else|else
block|{
name|flags
operator|&=
operator|~
name|SQLITE_OPEN_READONLY
expr_stmt|;
name|flags
operator||=
name|SQLITE_OPEN_READWRITE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|zArg
argument_list|,
literal|"-create"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|b
decl_stmt|;
if|if
condition|(
name|Tcl_GetBooleanFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|&
name|b
argument_list|)
condition|)
return|return
name|TCL_ERROR
return|;
if|if
condition|(
name|b
operator|&&
operator|(
name|flags
operator|&
name|SQLITE_OPEN_READONLY
operator|)
operator|==
literal|0
condition|)
block|{
name|flags
operator||=
name|SQLITE_OPEN_CREATE
expr_stmt|;
block|}
else|else
block|{
name|flags
operator|&=
operator|~
name|SQLITE_OPEN_CREATE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|zArg
argument_list|,
literal|"-nomutex"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|b
decl_stmt|;
if|if
condition|(
name|Tcl_GetBooleanFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|&
name|b
argument_list|)
condition|)
return|return
name|TCL_ERROR
return|;
if|if
condition|(
name|b
condition|)
block|{
name|flags
operator||=
name|SQLITE_OPEN_NOMUTEX
expr_stmt|;
name|flags
operator|&=
operator|~
name|SQLITE_OPEN_FULLMUTEX
expr_stmt|;
block|}
else|else
block|{
name|flags
operator|&=
operator|~
name|SQLITE_OPEN_NOMUTEX
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|zArg
argument_list|,
literal|"-fullmutex"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|b
decl_stmt|;
if|if
condition|(
name|Tcl_GetBooleanFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|&
name|b
argument_list|)
condition|)
return|return
name|TCL_ERROR
return|;
if|if
condition|(
name|b
condition|)
block|{
name|flags
operator||=
name|SQLITE_OPEN_FULLMUTEX
expr_stmt|;
name|flags
operator|&=
operator|~
name|SQLITE_OPEN_NOMUTEX
expr_stmt|;
block|}
else|else
block|{
name|flags
operator|&=
operator|~
name|SQLITE_OPEN_FULLMUTEX
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|zArg
argument_list|,
literal|"-uri"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|b
decl_stmt|;
if|if
condition|(
name|Tcl_GetBooleanFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|&
name|b
argument_list|)
condition|)
return|return
name|TCL_ERROR
return|;
if|if
condition|(
name|b
condition|)
block|{
name|flags
operator||=
name|SQLITE_OPEN_URI
expr_stmt|;
block|}
else|else
block|{
name|flags
operator|&=
operator|~
name|SQLITE_OPEN_URI
expr_stmt|;
block|}
block|}
else|else
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"unknown option: "
argument_list|,
name|zArg
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
block|}
if|if
condition|(
name|objc
operator|<
literal|3
operator|||
operator|(
name|objc
operator|&
literal|1
operator|)
operator|!=
literal|1
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"HANDLE FILENAME ?-vfs VFSNAME? ?-readonly BOOLEAN? ?-create BOOLEAN?"
literal|" ?-nomutex BOOLEAN? ?-fullmutex BOOLEAN? ?-uri BOOLEAN?"
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_HAS_CODEC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SQLITE_OMIT_CODEC_FROM_TCL
argument_list|)
literal|" ?-key CODECKEY?"
endif|#
directive|endif
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|zErrMsg
operator|=
literal|0
expr_stmt|;
name|p
operator|=
operator|(
name|SqliteDb
operator|*
operator|)
name|Tcl_Alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|"malloc failed"
argument_list|,
name|TCL_STATIC
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|zFile
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zFile
operator|=
name|Tcl_TranslateFileName
argument_list|(
name|interp
argument_list|,
name|zFile
argument_list|,
operator|&
name|translatedFilename
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_open_v2
argument_list|(
name|zFile
argument_list|,
operator|&
name|p
operator|->
name|db
argument_list|,
name|flags
argument_list|,
name|zVfs
argument_list|)
expr_stmt|;
name|Tcl_DStringFree
argument_list|(
operator|&
name|translatedFilename
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|db
condition|)
block|{
if|if
condition|(
name|SQLITE_OK
operator|!=
name|sqlite3_errcode
argument_list|(
name|p
operator|->
name|db
argument_list|)
condition|)
block|{
name|zErrMsg
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"%s"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|sqlite3_close
argument_list|(
name|p
operator|->
name|db
argument_list|)
expr_stmt|;
name|p
operator|->
name|db
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|zErrMsg
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"%s"
argument_list|,
name|sqlite3_errstr
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_HAS_CODEC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SQLITE_OMIT_CODEC_FROM_TCL
argument_list|)
if|if
condition|(
name|p
operator|->
name|db
condition|)
block|{
name|sqlite3_key
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|pKey
argument_list|,
name|nKey
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|db
operator|==
literal|0
condition|)
block|{
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|zErrMsg
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
name|Tcl_Free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zErrMsg
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|p
operator|->
name|maxStmt
operator|=
name|NUM_PREPARED_STMTS
expr_stmt|;
name|p
operator|->
name|openFlags
operator|=
name|flags
operator|&
name|SQLITE_OPEN_URI
expr_stmt|;
name|p
operator|->
name|interp
operator|=
name|interp
expr_stmt|;
name|zArg
operator|=
name|Tcl_GetStringFromObj
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DbUseNre
argument_list|()
condition|)
block|{
name|Tcl_NRCreateCommand
argument_list|(
name|interp
argument_list|,
name|zArg
argument_list|,
name|DbObjCmdAdaptor
argument_list|,
name|DbObjCmd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
name|DbDeleteCmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Tcl_CreateObjCommand
argument_list|(
name|interp
argument_list|,
name|zArg
argument_list|,
name|DbObjCmd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
name|DbDeleteCmd
argument_list|)
expr_stmt|;
block|}
return|return
name|TCL_OK
return|;
block|}
end_function

begin_comment
comment|/* ** Provide a dummy Tcl_InitStubs if we are using this as a static ** library. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|USE_TCL_STUBS
end_ifndef

begin_undef
undef|#
directive|undef
name|Tcl_InitStubs
end_undef

begin_define
define|#
directive|define
name|Tcl_InitStubs
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|TCL_VERSION
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** Make sure we have a PACKAGE_VERSION macro defined.  This will be ** defined automatically by the TEA makefile.  But other makefiles ** do not define it. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PACKAGE_VERSION
end_ifndef

begin_define
define|#
directive|define
name|PACKAGE_VERSION
value|SQLITE_VERSION
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** Initialize this module. ** ** This Tcl module contains only a single new Tcl command named "sqlite". ** (Hence there is no namespace.  There is no point in using a namespace ** if the extension only supplies one new name!)  The "sqlite" command is ** used to open a new SQLite database.  See the DbMain() routine above ** for additional information. ** ** The EXTERN macros are required by TCL in order to work on windows. */
end_comment

begin_function
name|EXTERN
name|int
name|Sqlite3_Init
parameter_list|(
name|Tcl_Interp
modifier|*
name|interp
parameter_list|)
block|{
name|int
name|rc
init|=
name|Tcl_InitStubs
argument_list|(
name|interp
argument_list|,
literal|"8.4"
argument_list|,
literal|0
argument_list|)
condition|?
name|TCL_OK
else|:
name|TCL_ERROR
decl_stmt|;
if|if
condition|(
name|rc
operator|==
name|TCL_OK
condition|)
block|{
name|Tcl_CreateObjCommand
argument_list|(
name|interp
argument_list|,
literal|"sqlite3"
argument_list|,
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|DbMain
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SQLITE_3_SUFFIX_ONLY
comment|/* The "sqlite" alias is undocumented.  It is here only to support     ** legacy scripts.  All new scripts should use only the "sqlite3"     ** command. */
name|Tcl_CreateObjCommand
argument_list|(
name|interp
argument_list|,
literal|"sqlite"
argument_list|,
operator|(
name|Tcl_ObjCmdProc
operator|*
operator|)
name|DbMain
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rc
operator|=
name|Tcl_PkgProvide
argument_list|(
name|interp
argument_list|,
literal|"sqlite3"
argument_list|,
name|PACKAGE_VERSION
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
name|EXTERN
name|int
name|Tclsqlite3_Init
parameter_list|(
name|Tcl_Interp
modifier|*
name|interp
parameter_list|)
block|{
return|return
name|Sqlite3_Init
argument_list|(
name|interp
argument_list|)
return|;
block|}
end_function

begin_function
name|EXTERN
name|int
name|Sqlite3_Unload
parameter_list|(
name|Tcl_Interp
modifier|*
name|interp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
name|TCL_OK
return|;
block|}
end_function

begin_function
name|EXTERN
name|int
name|Tclsqlite3_Unload
parameter_list|(
name|Tcl_Interp
modifier|*
name|interp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
name|TCL_OK
return|;
block|}
end_function

begin_comment
comment|/* Because it accesses the file-system and uses persistent state, SQLite ** is not considered appropriate for safe interpreters.  Hence, we cause ** the _SafeInit() interfaces return TCL_ERROR. */
end_comment

begin_function
name|EXTERN
name|int
name|Sqlite3_SafeInit
parameter_list|(
name|Tcl_Interp
modifier|*
name|interp
parameter_list|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_function
name|EXTERN
name|int
name|Sqlite3_SafeUnload
parameter_list|(
name|Tcl_Interp
modifier|*
name|interp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SQLITE_3_SUFFIX_ONLY
end_ifndef

begin_function
name|int
name|Sqlite_Init
parameter_list|(
name|Tcl_Interp
modifier|*
name|interp
parameter_list|)
block|{
return|return
name|Sqlite3_Init
argument_list|(
name|interp
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|Tclsqlite_Init
parameter_list|(
name|Tcl_Interp
modifier|*
name|interp
parameter_list|)
block|{
return|return
name|Sqlite3_Init
argument_list|(
name|interp
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|Sqlite_Unload
parameter_list|(
name|Tcl_Interp
modifier|*
name|interp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
name|TCL_OK
return|;
block|}
end_function

begin_function
name|int
name|Tclsqlite_Unload
parameter_list|(
name|Tcl_Interp
modifier|*
name|interp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
name|TCL_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TCLSH
end_ifdef

begin_comment
comment|/***************************************************************************** ** All of the code that follows is used to build standalone TCL interpreters ** that are statically linked with SQLite.  Enable these by compiling ** with -DTCLSH=n where n can be 1 or 2.  An n of 1 generates a standard ** tclsh but with SQLite built in.  An n of 2 generates the SQLite space ** analysis program. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_TEST
argument_list|)
operator|||
name|defined
argument_list|(
name|SQLITE_TCLMD5
argument_list|)
end_if

begin_comment
comment|/*  * This code implements the MD5 message-digest algorithm.  * The algorithm is due to Ron Rivest.  This code was  * written by Colin Plumb in 1993, no copyright is claimed.  * This code is in the public domain; do with it what you wish.  *  * Equivalent code is available from RSA Data Security, Inc.  * This code has been tested against that, and is equivalent,  * except that you don't need to include two pages of legalese  * with every copy.  *  * To compute the message digest of a chunk of bytes, declare an  * MD5Context structure, pass it to MD5Init, call MD5Update as  * needed on buffers full of bytes, and then call MD5Final, which  * will fill a supplied 16-byte array with the digest.  */
end_comment

begin_comment
comment|/*  * If compiled on a machine that doesn't have a 32-bit integer,  * you just set "uint32" to the appropriate datatype for an  * unsigned 32-bit integer.  For example:  *  *       cc -Duint32='unsigned long' md5.c  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|uint32
end_ifndef

begin_define
define|#
directive|define
name|uint32
value|unsigned int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|MD5Context
block|{
name|int
name|isInit
decl_stmt|;
name|uint32
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|uint32
name|bits
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|char
name|in
index|[
literal|64
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|MD5Context
name|MD5Context
typedef|;
end_typedef

begin_comment
comment|/*  * Note: this code is harmless on little-endian machines.  */
end_comment

begin_function
specifier|static
name|void
name|byteReverse
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|longs
parameter_list|)
block|{
name|uint32
name|t
decl_stmt|;
do|do
block|{
name|t
operator|=
call|(
name|uint32
call|)
argument_list|(
operator|(
name|unsigned
operator|)
name|buf
index|[
literal|3
index|]
operator|<<
literal|8
operator||
name|buf
index|[
literal|2
index|]
argument_list|)
operator|<<
literal|16
operator||
operator|(
operator|(
name|unsigned
operator|)
name|buf
index|[
literal|1
index|]
operator|<<
literal|8
operator||
name|buf
index|[
literal|0
index|]
operator|)
expr_stmt|;
operator|*
operator|(
name|uint32
operator|*
operator|)
name|buf
operator|=
name|t
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|longs
condition|)
do|;
block|}
end_function

begin_comment
comment|/* The four core functions - F1 is optimized somewhat */
end_comment

begin_comment
comment|/* #define F1(x, y, z) (x& y | ~x& z) */
end_comment

begin_define
define|#
directive|define
name|F1
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|(z ^ (x& (y ^ z)))
end_define

begin_define
define|#
directive|define
name|F2
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|F1(z, x, y)
end_define

begin_define
define|#
directive|define
name|F3
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|(x ^ y ^ z)
end_define

begin_define
define|#
directive|define
name|F4
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|(y ^ (x | ~z))
end_define

begin_comment
comment|/* This is the central step in the MD5 algorithm. */
end_comment

begin_define
define|#
directive|define
name|MD5STEP
parameter_list|(
name|f
parameter_list|,
name|w
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|,
name|data
parameter_list|,
name|s
parameter_list|)
define|\
value|( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )
end_define

begin_comment
comment|/*  * The core of the MD5 algorithm, this alters an existing MD5 hash to  * reflect the addition of 16 longwords of new data.  MD5Update blocks  * the data and converts bytes into longwords for this routine.  */
end_comment

begin_function
specifier|static
name|void
name|MD5Transform
parameter_list|(
name|uint32
name|buf
index|[
literal|4
index|]
parameter_list|,
specifier|const
name|uint32
name|in
index|[
literal|16
index|]
parameter_list|)
block|{
specifier|register
name|uint32
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|;
name|a
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|b
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|c
operator|=
name|buf
index|[
literal|2
index|]
expr_stmt|;
name|d
operator|=
name|buf
index|[
literal|3
index|]
expr_stmt|;
name|MD5STEP
argument_list|(
name|F1
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|in
index|[
literal|0
index|]
operator|+
literal|0xd76aa478
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F1
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|in
index|[
literal|1
index|]
operator|+
literal|0xe8c7b756
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F1
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|in
index|[
literal|2
index|]
operator|+
literal|0x242070db
argument_list|,
literal|17
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F1
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|in
index|[
literal|3
index|]
operator|+
literal|0xc1bdceee
argument_list|,
literal|22
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F1
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|in
index|[
literal|4
index|]
operator|+
literal|0xf57c0faf
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F1
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|in
index|[
literal|5
index|]
operator|+
literal|0x4787c62a
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F1
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|in
index|[
literal|6
index|]
operator|+
literal|0xa8304613
argument_list|,
literal|17
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F1
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|in
index|[
literal|7
index|]
operator|+
literal|0xfd469501
argument_list|,
literal|22
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F1
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|in
index|[
literal|8
index|]
operator|+
literal|0x698098d8
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F1
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|in
index|[
literal|9
index|]
operator|+
literal|0x8b44f7af
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F1
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|in
index|[
literal|10
index|]
operator|+
literal|0xffff5bb1
argument_list|,
literal|17
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F1
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|in
index|[
literal|11
index|]
operator|+
literal|0x895cd7be
argument_list|,
literal|22
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F1
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|in
index|[
literal|12
index|]
operator|+
literal|0x6b901122
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F1
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|in
index|[
literal|13
index|]
operator|+
literal|0xfd987193
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F1
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|in
index|[
literal|14
index|]
operator|+
literal|0xa679438e
argument_list|,
literal|17
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F1
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|in
index|[
literal|15
index|]
operator|+
literal|0x49b40821
argument_list|,
literal|22
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F2
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|in
index|[
literal|1
index|]
operator|+
literal|0xf61e2562
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F2
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|in
index|[
literal|6
index|]
operator|+
literal|0xc040b340
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F2
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|in
index|[
literal|11
index|]
operator|+
literal|0x265e5a51
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F2
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|in
index|[
literal|0
index|]
operator|+
literal|0xe9b6c7aa
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F2
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|in
index|[
literal|5
index|]
operator|+
literal|0xd62f105d
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F2
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|in
index|[
literal|10
index|]
operator|+
literal|0x02441453
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F2
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|in
index|[
literal|15
index|]
operator|+
literal|0xd8a1e681
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F2
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|in
index|[
literal|4
index|]
operator|+
literal|0xe7d3fbc8
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F2
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|in
index|[
literal|9
index|]
operator|+
literal|0x21e1cde6
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F2
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|in
index|[
literal|14
index|]
operator|+
literal|0xc33707d6
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F2
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|in
index|[
literal|3
index|]
operator|+
literal|0xf4d50d87
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F2
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|in
index|[
literal|8
index|]
operator|+
literal|0x455a14ed
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F2
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|in
index|[
literal|13
index|]
operator|+
literal|0xa9e3e905
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F2
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|in
index|[
literal|2
index|]
operator|+
literal|0xfcefa3f8
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F2
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|in
index|[
literal|7
index|]
operator|+
literal|0x676f02d9
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F2
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|in
index|[
literal|12
index|]
operator|+
literal|0x8d2a4c8a
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F3
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|in
index|[
literal|5
index|]
operator|+
literal|0xfffa3942
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F3
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|in
index|[
literal|8
index|]
operator|+
literal|0x8771f681
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F3
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|in
index|[
literal|11
index|]
operator|+
literal|0x6d9d6122
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F3
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|in
index|[
literal|14
index|]
operator|+
literal|0xfde5380c
argument_list|,
literal|23
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F3
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|in
index|[
literal|1
index|]
operator|+
literal|0xa4beea44
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F3
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|in
index|[
literal|4
index|]
operator|+
literal|0x4bdecfa9
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F3
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|in
index|[
literal|7
index|]
operator|+
literal|0xf6bb4b60
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F3
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|in
index|[
literal|10
index|]
operator|+
literal|0xbebfbc70
argument_list|,
literal|23
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F3
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|in
index|[
literal|13
index|]
operator|+
literal|0x289b7ec6
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F3
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|in
index|[
literal|0
index|]
operator|+
literal|0xeaa127fa
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F3
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|in
index|[
literal|3
index|]
operator|+
literal|0xd4ef3085
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F3
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|in
index|[
literal|6
index|]
operator|+
literal|0x04881d05
argument_list|,
literal|23
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F3
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|in
index|[
literal|9
index|]
operator|+
literal|0xd9d4d039
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F3
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|in
index|[
literal|12
index|]
operator|+
literal|0xe6db99e5
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F3
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|in
index|[
literal|15
index|]
operator|+
literal|0x1fa27cf8
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F3
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|in
index|[
literal|2
index|]
operator|+
literal|0xc4ac5665
argument_list|,
literal|23
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F4
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|in
index|[
literal|0
index|]
operator|+
literal|0xf4292244
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F4
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|in
index|[
literal|7
index|]
operator|+
literal|0x432aff97
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F4
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|in
index|[
literal|14
index|]
operator|+
literal|0xab9423a7
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F4
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|in
index|[
literal|5
index|]
operator|+
literal|0xfc93a039
argument_list|,
literal|21
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F4
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|in
index|[
literal|12
index|]
operator|+
literal|0x655b59c3
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F4
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|in
index|[
literal|3
index|]
operator|+
literal|0x8f0ccc92
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F4
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|in
index|[
literal|10
index|]
operator|+
literal|0xffeff47d
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F4
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|in
index|[
literal|1
index|]
operator|+
literal|0x85845dd1
argument_list|,
literal|21
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F4
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|in
index|[
literal|8
index|]
operator|+
literal|0x6fa87e4f
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F4
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|in
index|[
literal|15
index|]
operator|+
literal|0xfe2ce6e0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F4
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|in
index|[
literal|6
index|]
operator|+
literal|0xa3014314
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F4
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|in
index|[
literal|13
index|]
operator|+
literal|0x4e0811a1
argument_list|,
literal|21
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F4
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|in
index|[
literal|4
index|]
operator|+
literal|0xf7537e82
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F4
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|in
index|[
literal|11
index|]
operator|+
literal|0xbd3af235
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F4
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|in
index|[
literal|2
index|]
operator|+
literal|0x2ad7d2bb
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|MD5STEP
argument_list|(
name|F4
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|a
argument_list|,
name|in
index|[
literal|9
index|]
operator|+
literal|0xeb86d391
argument_list|,
literal|21
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|+=
name|a
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|+=
name|b
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|+=
name|c
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|+=
name|d
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious  * initialization constants.  */
end_comment

begin_function
specifier|static
name|void
name|MD5Init
parameter_list|(
name|MD5Context
modifier|*
name|ctx
parameter_list|)
block|{
name|ctx
operator|->
name|isInit
operator|=
literal|1
expr_stmt|;
name|ctx
operator|->
name|buf
index|[
literal|0
index|]
operator|=
literal|0x67452301
expr_stmt|;
name|ctx
operator|->
name|buf
index|[
literal|1
index|]
operator|=
literal|0xefcdab89
expr_stmt|;
name|ctx
operator|->
name|buf
index|[
literal|2
index|]
operator|=
literal|0x98badcfe
expr_stmt|;
name|ctx
operator|->
name|buf
index|[
literal|3
index|]
operator|=
literal|0x10325476
expr_stmt|;
name|ctx
operator|->
name|bits
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|bits
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update context to reflect the concatenation of another buffer full  * of bytes.  */
end_comment

begin_function
specifier|static
name|void
name|MD5Update
parameter_list|(
name|MD5Context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
name|uint32
name|t
decl_stmt|;
comment|/* Update bitcount */
name|t
operator|=
name|ctx
operator|->
name|bits
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ctx
operator|->
name|bits
index|[
literal|0
index|]
operator|=
name|t
operator|+
operator|(
operator|(
name|uint32
operator|)
name|len
operator|<<
literal|3
operator|)
operator|)
operator|<
name|t
condition|)
name|ctx
operator|->
name|bits
index|[
literal|1
index|]
operator|++
expr_stmt|;
comment|/* Carry from low to high */
name|ctx
operator|->
name|bits
index|[
literal|1
index|]
operator|+=
name|len
operator|>>
literal|29
expr_stmt|;
name|t
operator|=
operator|(
name|t
operator|>>
literal|3
operator|)
operator|&
literal|0x3f
expr_stmt|;
comment|/* Bytes already in shsInfo->data */
comment|/* Handle any leading odd-sized chunks */
if|if
condition|(
name|t
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ctx
operator|->
name|in
operator|+
name|t
decl_stmt|;
name|t
operator|=
literal|64
operator|-
name|t
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|t
condition|)
block|{
name|memcpy
argument_list|(
name|p
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return;
block|}
name|memcpy
argument_list|(
name|p
argument_list|,
name|buf
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|byteReverse
argument_list|(
name|ctx
operator|->
name|in
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|MD5Transform
argument_list|(
name|ctx
operator|->
name|buf
argument_list|,
operator|(
name|uint32
operator|*
operator|)
name|ctx
operator|->
name|in
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|t
expr_stmt|;
name|len
operator|-=
name|t
expr_stmt|;
block|}
comment|/* Process data in 64-byte chunks */
while|while
condition|(
name|len
operator|>=
literal|64
condition|)
block|{
name|memcpy
argument_list|(
name|ctx
operator|->
name|in
argument_list|,
name|buf
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|byteReverse
argument_list|(
name|ctx
operator|->
name|in
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|MD5Transform
argument_list|(
name|ctx
operator|->
name|buf
argument_list|,
operator|(
name|uint32
operator|*
operator|)
name|ctx
operator|->
name|in
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|64
expr_stmt|;
name|len
operator|-=
literal|64
expr_stmt|;
block|}
comment|/* Handle any remaining bytes of data. */
name|memcpy
argument_list|(
name|ctx
operator|->
name|in
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Final wrapup - pad to 64-byte boundary with the bit pattern  * 1 0* (64-bit count of bits processed, MSB-first)  */
end_comment

begin_function
specifier|static
name|void
name|MD5Final
parameter_list|(
name|unsigned
name|char
name|digest
index|[
literal|16
index|]
parameter_list|,
name|MD5Context
modifier|*
name|ctx
parameter_list|)
block|{
name|unsigned
name|count
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Compute number of bytes mod 64 */
name|count
operator|=
operator|(
name|ctx
operator|->
name|bits
index|[
literal|0
index|]
operator|>>
literal|3
operator|)
operator|&
literal|0x3F
expr_stmt|;
comment|/* Set the first char of padding to 0x80.  This is safe since there is            always at least one byte free */
name|p
operator|=
name|ctx
operator|->
name|in
operator|+
name|count
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0x80
expr_stmt|;
comment|/* Bytes of padding needed to make 64 bytes */
name|count
operator|=
literal|64
operator|-
literal|1
operator|-
name|count
expr_stmt|;
comment|/* Pad out to 56 mod 64 */
if|if
condition|(
name|count
operator|<
literal|8
condition|)
block|{
comment|/* Two lots of padding:  Pad the first block to 64 bytes */
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|byteReverse
argument_list|(
name|ctx
operator|->
name|in
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|MD5Transform
argument_list|(
name|ctx
operator|->
name|buf
argument_list|,
operator|(
name|uint32
operator|*
operator|)
name|ctx
operator|->
name|in
argument_list|)
expr_stmt|;
comment|/* Now fill the next block with 56 bytes */
name|memset
argument_list|(
name|ctx
operator|->
name|in
argument_list|,
literal|0
argument_list|,
literal|56
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Pad block to 56 bytes */
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|count
operator|-
literal|8
argument_list|)
expr_stmt|;
block|}
name|byteReverse
argument_list|(
name|ctx
operator|->
name|in
argument_list|,
literal|14
argument_list|)
expr_stmt|;
comment|/* Append length in bits and transform */
name|memcpy
argument_list|(
name|ctx
operator|->
name|in
operator|+
literal|14
operator|*
literal|4
argument_list|,
name|ctx
operator|->
name|bits
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|MD5Transform
argument_list|(
name|ctx
operator|->
name|buf
argument_list|,
operator|(
name|uint32
operator|*
operator|)
name|ctx
operator|->
name|in
argument_list|)
expr_stmt|;
name|byteReverse
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ctx
operator|->
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|digest
argument_list|,
name|ctx
operator|->
name|buf
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Convert a 128-bit MD5 digest into a 32-digit base-16 number. */
end_comment

begin_function
specifier|static
name|void
name|MD5DigestToBase16
parameter_list|(
name|unsigned
name|char
modifier|*
name|digest
parameter_list|,
name|char
modifier|*
name|zBuf
parameter_list|)
block|{
specifier|static
name|char
specifier|const
name|zEncode
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|int
name|a
init|=
name|digest
index|[
name|i
index|]
decl_stmt|;
name|zBuf
index|[
name|j
operator|++
index|]
operator|=
name|zEncode
index|[
operator|(
name|a
operator|>>
literal|4
operator|)
operator|&
literal|0xf
index|]
expr_stmt|;
name|zBuf
index|[
name|j
operator|++
index|]
operator|=
name|zEncode
index|[
name|a
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
name|zBuf
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Convert a 128-bit MD5 digest into sequency of eight 5-digit integers ** each representing 16 bits of the digest and separated from each ** other by a "-" character. */
end_comment

begin_function
specifier|static
name|void
name|MD5DigestToBase10x8
parameter_list|(
name|unsigned
name|char
name|digest
index|[
literal|16
index|]
parameter_list|,
name|char
name|zDigest
index|[
literal|50
index|]
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|int
name|x
decl_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|x
operator|=
name|digest
index|[
name|i
index|]
operator|*
literal|256
operator|+
name|digest
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|zDigest
index|[
name|j
operator|++
index|]
operator|=
literal|'-'
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
literal|50
operator|-
name|j
argument_list|,
operator|&
name|zDigest
index|[
name|j
index|]
argument_list|,
literal|"%05u"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|j
operator|+=
literal|5
expr_stmt|;
block|}
name|zDigest
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** A TCL command for md5.  The argument is the text to be hashed.  The ** Result is the hash in base64. */
end_comment

begin_function
specifier|static
name|int
name|SQLITE_TCLAPI
name|md5_cmd
parameter_list|(
name|void
modifier|*
name|cd
parameter_list|,
name|Tcl_Interp
modifier|*
name|interp
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|MD5Context
name|ctx
decl_stmt|;
name|unsigned
name|char
name|digest
index|[
literal|16
index|]
decl_stmt|;
name|char
name|zBuf
index|[
literal|50
index|]
decl_stmt|;
name|void
function_decl|(
modifier|*
name|converter
function_decl|)
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" TEXT\""
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|MD5Init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|argv
index|[
literal|1
index|]
argument_list|,
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|MD5Final
argument_list|(
name|digest
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|converter
operator|=
operator|(
name|void
argument_list|(
argument|*
argument_list|)
operator|(
name|unsigned
name|char
operator|*
operator|,
name|char
operator|*
operator|)
operator|)
name|cd
expr_stmt|;
name|converter
argument_list|(
name|digest
argument_list|,
name|zBuf
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|zBuf
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_comment
comment|/* ** A TCL command to take the md5 hash of a file.  The argument is the ** name of the file. */
end_comment

begin_function
specifier|static
name|int
name|SQLITE_TCLAPI
name|md5file_cmd
parameter_list|(
name|void
modifier|*
name|cd
parameter_list|,
name|Tcl_Interp
modifier|*
name|interp
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|FILE
modifier|*
name|in
decl_stmt|;
name|MD5Context
name|ctx
decl_stmt|;
name|void
function_decl|(
modifier|*
name|converter
function_decl|)
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
name|unsigned
name|char
name|digest
index|[
literal|16
index|]
decl_stmt|;
name|char
name|zBuf
index|[
literal|10240
index|]
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"wrong # args: should be \""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|" FILENAME\""
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|in
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
literal|0
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"unable to open file \""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"\" for reading"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|MD5Init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|n
decl_stmt|;
name|n
operator|=
operator|(
name|int
operator|)
name|fread
argument_list|(
name|zBuf
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|zBuf
argument_list|)
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
break|break;
name|MD5Update
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|zBuf
argument_list|,
operator|(
name|unsigned
operator|)
name|n
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|MD5Final
argument_list|(
name|digest
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|converter
operator|=
operator|(
name|void
argument_list|(
argument|*
argument_list|)
operator|(
name|unsigned
name|char
operator|*
operator|,
name|char
operator|*
operator|)
operator|)
name|cd
expr_stmt|;
name|converter
argument_list|(
name|digest
argument_list|,
name|zBuf
argument_list|)
expr_stmt|;
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
name|zBuf
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_comment
comment|/* ** Register the four new TCL commands for generating MD5 checksums ** with the TCL interpreter. */
end_comment

begin_function
name|int
name|Md5_Init
parameter_list|(
name|Tcl_Interp
modifier|*
name|interp
parameter_list|)
block|{
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"md5"
argument_list|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|md5_cmd
argument_list|,
name|MD5DigestToBase16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"md5-10x8"
argument_list|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|md5_cmd
argument_list|,
name|MD5DigestToBase10x8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"md5file"
argument_list|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|md5file_cmd
argument_list|,
name|MD5DigestToBase16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Tcl_CreateCommand
argument_list|(
name|interp
argument_list|,
literal|"md5file-10x8"
argument_list|,
operator|(
name|Tcl_CmdProc
operator|*
operator|)
name|md5file_cmd
argument_list|,
name|MD5DigestToBase10x8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(SQLITE_TEST) || defined(SQLITE_TCLMD5) */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_TEST
argument_list|)
end_if

begin_comment
comment|/* ** During testing, the special md5sum() aggregate function is available. ** inside SQLite.  The following routines implement that function. */
end_comment

begin_function
specifier|static
name|void
name|md5step
parameter_list|(
name|sqlite3_context
modifier|*
name|context
parameter_list|,
name|int
name|argc
parameter_list|,
name|sqlite3_value
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|MD5Context
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
return|return;
name|p
operator|=
name|sqlite3_aggregate_context
argument_list|(
name|context
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|p
operator|->
name|isInit
condition|)
block|{
name|MD5Init
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|zData
init|=
operator|(
name|char
operator|*
operator|)
name|sqlite3_value_text
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|zData
condition|)
block|{
name|MD5Update
argument_list|(
name|p
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|zData
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|zData
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|md5finalize
parameter_list|(
name|sqlite3_context
modifier|*
name|context
parameter_list|)
block|{
name|MD5Context
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
name|digest
index|[
literal|16
index|]
decl_stmt|;
name|char
name|zBuf
index|[
literal|33
index|]
decl_stmt|;
name|p
operator|=
name|sqlite3_aggregate_context
argument_list|(
name|context
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|MD5Final
argument_list|(
name|digest
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|MD5DigestToBase16
argument_list|(
name|digest
argument_list|,
name|zBuf
argument_list|)
expr_stmt|;
name|sqlite3_result_text
argument_list|(
name|context
argument_list|,
name|zBuf
argument_list|,
operator|-
literal|1
argument_list|,
name|SQLITE_TRANSIENT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|Md5_Register
parameter_list|(
name|sqlite3
modifier|*
name|db
parameter_list|,
name|char
modifier|*
modifier|*
name|pzErrMsg
parameter_list|,
specifier|const
name|sqlite3_api_routines
modifier|*
name|pThunk
parameter_list|)
block|{
name|int
name|rc
init|=
name|sqlite3_create_function
argument_list|(
name|db
argument_list|,
literal|"md5sum"
argument_list|,
operator|-
literal|1
argument_list|,
name|SQLITE_UTF8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|md5step
argument_list|,
name|md5finalize
argument_list|)
decl_stmt|;
name|sqlite3_overload_function
argument_list|(
name|db
argument_list|,
literal|"md5sum"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* To exercise this API */
return|return
name|rc
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(SQLITE_TEST) */
end_comment

begin_comment
comment|/* ** If the macro TCLSH is one, then put in code this for the ** "main" routine that will initialize Tcl and take input from ** standard input, or if a file is named on the command line ** the TCL interpreter reads and evaluates that file. */
end_comment

begin_if
if|#
directive|if
name|TCLSH
operator|==
literal|1
end_if

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|tclsh_main_loop
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|zMainloop
index|[]
init|=
literal|"set line {}\n"
literal|"while {![eof stdin]} {\n"
literal|"if {$line!=\"\"} {\n"
literal|"puts -nonewline \"> \"\n"
literal|"} else {\n"
literal|"puts -nonewline \"% \"\n"
literal|"}\n"
literal|"flush stdout\n"
literal|"append line [gets stdin]\n"
literal|"if {[info complete $line]} {\n"
literal|"if {[catch {uplevel #0 $line} result]} {\n"
literal|"puts stderr \"Error: $result\"\n"
literal|"} elseif {$result!=\"\"} {\n"
literal|"puts $result\n"
literal|"}\n"
literal|"set line {}\n"
literal|"} else {\n"
literal|"append line \\n\n"
literal|"}\n"
literal|"}\n"
decl_stmt|;
return|return
name|zMainloop
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|TCLSH
operator|==
literal|2
end_if

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|tclsh_main_loop
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SQLITE_TEST
end_ifdef

begin_function_decl
specifier|static
name|void
name|init_all
parameter_list|(
name|Tcl_Interp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|SQLITE_TCLAPI
name|init_all_cmd
parameter_list|(
name|ClientData
name|cd
parameter_list|,
name|Tcl_Interp
modifier|*
name|interp
parameter_list|,
name|int
name|objc
parameter_list|,
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
parameter_list|)
block|{
name|Tcl_Interp
modifier|*
name|slave
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"SLAVE"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|slave
operator|=
name|Tcl_GetSlave
argument_list|(
name|interp
argument_list|,
name|Tcl_GetString
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slave
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|init_all
argument_list|(
name|slave
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_comment
comment|/* ** Tclcmd: db_use_legacy_prepare DB BOOLEAN ** **   The first argument to this command must be a database command created by **   [sqlite3]. If the second argument is true, then the handle is configured **   to use the sqlite3_prepare_v2() function to prepare statements. If it **   is false, sqlite3_prepare(). */
end_comment

begin_function
specifier|static
name|int
name|SQLITE_TCLAPI
name|db_use_legacy_prepare_cmd
parameter_list|(
name|ClientData
name|cd
parameter_list|,
name|Tcl_Interp
modifier|*
name|interp
parameter_list|,
name|int
name|objc
parameter_list|,
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
parameter_list|)
block|{
name|Tcl_CmdInfo
name|cmdInfo
decl_stmt|;
name|SqliteDb
modifier|*
name|pDb
decl_stmt|;
name|int
name|bPrepare
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|3
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"DB BOOLEAN"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|!
name|Tcl_GetCommandInfo
argument_list|(
name|interp
argument_list|,
name|Tcl_GetString
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|)
argument_list|,
operator|&
name|cmdInfo
argument_list|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"no such db: "
argument_list|,
name|Tcl_GetString
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|pDb
operator|=
operator|(
name|SqliteDb
operator|*
operator|)
name|cmdInfo
operator|.
name|objClientData
expr_stmt|;
if|if
condition|(
name|Tcl_GetBooleanFromObj
argument_list|(
name|interp
argument_list|,
name|objv
index|[
literal|2
index|]
argument_list|,
operator|&
name|bPrepare
argument_list|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|pDb
operator|->
name|bLegacyPrepare
operator|=
name|bPrepare
expr_stmt|;
name|Tcl_ResetResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_comment
comment|/* ** Tclcmd: db_last_stmt_ptr DB ** **   If the statement cache associated with database DB is not empty, **   return the text representation of the most recently used statement **   handle. */
end_comment

begin_function
specifier|static
name|int
name|SQLITE_TCLAPI
name|db_last_stmt_ptr
parameter_list|(
name|ClientData
name|cd
parameter_list|,
name|Tcl_Interp
modifier|*
name|interp
parameter_list|,
name|int
name|objc
parameter_list|,
name|Tcl_Obj
modifier|*
name|CONST
name|objv
index|[]
parameter_list|)
block|{
specifier|extern
name|int
name|sqlite3TestMakePointerStr
argument_list|(
name|Tcl_Interp
operator|*
argument_list|,
name|char
operator|*
argument_list|,
name|void
operator|*
argument_list|)
decl_stmt|;
name|Tcl_CmdInfo
name|cmdInfo
decl_stmt|;
name|SqliteDb
modifier|*
name|pDb
decl_stmt|;
name|sqlite3_stmt
modifier|*
name|pStmt
init|=
literal|0
decl_stmt|;
name|char
name|zBuf
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|objc
operator|!=
literal|2
condition|)
block|{
name|Tcl_WrongNumArgs
argument_list|(
name|interp
argument_list|,
literal|1
argument_list|,
name|objv
argument_list|,
literal|"DB"
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
if|if
condition|(
operator|!
name|Tcl_GetCommandInfo
argument_list|(
name|interp
argument_list|,
name|Tcl_GetString
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|)
argument_list|,
operator|&
name|cmdInfo
argument_list|)
condition|)
block|{
name|Tcl_AppendResult
argument_list|(
name|interp
argument_list|,
literal|"no such db: "
argument_list|,
name|Tcl_GetString
argument_list|(
name|objv
index|[
literal|1
index|]
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|TCL_ERROR
return|;
block|}
name|pDb
operator|=
operator|(
name|SqliteDb
operator|*
operator|)
name|cmdInfo
operator|.
name|objClientData
expr_stmt|;
if|if
condition|(
name|pDb
operator|->
name|stmtList
condition|)
name|pStmt
operator|=
name|pDb
operator|->
name|stmtList
operator|->
name|pStmt
expr_stmt|;
if|if
condition|(
name|sqlite3TestMakePointerStr
argument_list|(
name|interp
argument_list|,
name|zBuf
argument_list|,
name|pStmt
argument_list|)
condition|)
block|{
return|return
name|TCL_ERROR
return|;
block|}
name|Tcl_SetResult
argument_list|(
name|interp
argument_list|,
name|zBuf
argument_list|,
name|TCL_VOLATILE
argument_list|)
expr_stmt|;
return|return
name|TCL_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SQLITE_TEST */
end_comment

begin_comment
comment|/* ** Configure the interpreter passed as the first argument to have access ** to the commands and linked variables that make up: ** **   * the [sqlite3] extension itself, ** **   * If SQLITE_TCLMD5 or SQLITE_TEST is defined, the Md5 commands, and ** **   * If SQLITE_TEST is set, the various test interfaces used by the Tcl **     test suite. */
end_comment

begin_function
specifier|static
name|void
name|init_all
parameter_list|(
name|Tcl_Interp
modifier|*
name|interp
parameter_list|)
block|{
name|Sqlite3_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_TEST
argument_list|)
operator|||
name|defined
argument_list|(
name|SQLITE_TCLMD5
argument_list|)
name|Md5_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SQLITE_TEST
block|{
specifier|extern
name|int
name|Sqliteconfig_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|Sqlitetest1_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|Sqlitetest2_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|Sqlitetest3_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|Sqlitetest4_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|Sqlitetest5_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|Sqlitetest6_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|Sqlitetest7_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|Sqlitetest8_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|Sqlitetest9_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|Sqlitetestasync_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|Sqlitetest_autoext_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|Sqlitetest_blob_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|Sqlitetest_demovfs_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|Sqlitetest_func_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|Sqlitetest_hexio_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|Sqlitetest_init_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|Sqlitetest_malloc_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|Sqlitetest_mutex_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|Sqlitetestschema_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|Sqlitetestsse_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|Sqlitetesttclvar_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|Sqlitetestfs_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|SqlitetestThread_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|SqlitetestOnefile_Init
parameter_list|()
function_decl|;
specifier|extern
name|int
name|SqlitetestOsinst_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|Sqlitetestbackup_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|Sqlitetestintarray_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|Sqlitetestvfs_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|Sqlitetestrtree_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|Sqlitequota_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|Sqlitemultiplex_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|SqliteSuperlock_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|SqlitetestSyscall_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_ENABLE_SESSION
argument_list|)
operator|&&
name|defined
argument_list|(
name|SQLITE_ENABLE_PREUPDATE_HOOK
argument_list|)
specifier|extern
name|int
name|TestSession_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
endif|#
directive|endif
specifier|extern
name|int
name|Fts5tcl_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|SqliteRbu_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|Sqlitetesttcl_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_ENABLE_FTS3
argument_list|)
operator|||
name|defined
argument_list|(
name|SQLITE_ENABLE_FTS4
argument_list|)
specifier|extern
name|int
name|Sqlitetestfts3_Init
argument_list|(
name|Tcl_Interp
operator|*
name|interp
argument_list|)
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SQLITE_ENABLE_ZIPVFS
specifier|extern
name|int
name|Zipvfs_Init
argument_list|(
name|Tcl_Interp
operator|*
argument_list|)
decl_stmt|;
name|Zipvfs_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Sqliteconfig_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Sqlitetest1_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Sqlitetest2_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Sqlitetest3_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Sqlitetest4_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Sqlitetest5_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Sqlitetest6_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Sqlitetest7_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Sqlitetest8_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Sqlitetest9_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Sqlitetestasync_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Sqlitetest_autoext_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Sqlitetest_blob_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Sqlitetest_demovfs_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Sqlitetest_func_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Sqlitetest_hexio_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Sqlitetest_init_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Sqlitetest_malloc_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Sqlitetest_mutex_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Sqlitetestschema_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Sqlitetesttclvar_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Sqlitetestfs_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|SqlitetestThread_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|SqlitetestOnefile_Init
argument_list|()
expr_stmt|;
name|SqlitetestOsinst_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Sqlitetestbackup_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Sqlitetestintarray_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Sqlitetestvfs_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Sqlitetestrtree_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Sqlitequota_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Sqlitemultiplex_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|SqliteSuperlock_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|SqlitetestSyscall_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_ENABLE_SESSION
argument_list|)
operator|&&
name|defined
argument_list|(
name|SQLITE_ENABLE_PREUPDATE_HOOK
argument_list|)
name|TestSession_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Fts5tcl_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|SqliteRbu_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|Sqlitetesttcl_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_ENABLE_FTS3
argument_list|)
operator|||
name|defined
argument_list|(
name|SQLITE_ENABLE_FTS4
argument_list|)
name|Sqlitetestfts3_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Tcl_CreateObjCommand
argument_list|(
name|interp
argument_list|,
literal|"load_testfixture_extensions"
argument_list|,
name|init_all_cmd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Tcl_CreateObjCommand
argument_list|(
name|interp
argument_list|,
literal|"db_use_legacy_prepare"
argument_list|,
name|db_use_legacy_prepare_cmd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Tcl_CreateObjCommand
argument_list|(
name|interp
argument_list|,
literal|"db_last_stmt_ptr"
argument_list|,
name|db_last_stmt_ptr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SQLITE_SSE
name|Sqlitetestsse_Init
argument_list|(
name|interp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Needed for the setrlimit() system call on unix */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|unix
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TCLSH_MAIN
value|main
end_define

begin_comment
comment|/* Needed to fake out mktclapp */
end_comment

begin_function
name|int
name|SQLITE_CDECL
name|TCLSH_MAIN
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|Tcl_Interp
modifier|*
name|interp
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32_WCE
argument_list|)
if|if
condition|(
name|getenv
argument_list|(
literal|"BREAK"
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"attach debugger to process %d and press any key to continue.\n"
argument_list|,
name|GETPID
argument_list|()
argument_list|)
expr_stmt|;
name|fgetc
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Since the primary use case for this binary is testing of SQLite,   ** be sure to generate core files if we crash */
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_TEST
argument_list|)
operator|&&
name|defined
argument_list|(
name|unix
argument_list|)
block|{
name|struct
name|rlimit
name|x
decl_stmt|;
name|getrlimit
argument_list|(
name|RLIMIT_CORE
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
name|x
operator|.
name|rlim_cur
operator|=
name|x
operator|.
name|rlim_max
expr_stmt|;
name|setrlimit
argument_list|(
name|RLIMIT_CORE
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SQLITE_TEST&& unix */
comment|/* Call sqlite3_shutdown() once before doing anything else. This is to   ** test that sqlite3_shutdown() can be safely called by a process before   ** sqlite3_initialize() is. */
name|sqlite3_shutdown
argument_list|()
expr_stmt|;
name|Tcl_FindExecutable
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|Tcl_SetSystemEncoding
argument_list|(
name|NULL
argument_list|,
literal|"utf-8"
argument_list|)
expr_stmt|;
name|interp
operator|=
name|Tcl_CreateInterp
argument_list|()
expr_stmt|;
if|#
directive|if
name|TCLSH
operator|==
literal|2
name|sqlite3_config
argument_list|(
name|SQLITE_CONFIG_SINGLETHREAD
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|init_all
argument_list|(
name|interp
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>=
literal|2
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|zArgc
index|[
literal|32
index|]
decl_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|zArgc
argument_list|)
argument_list|,
name|zArgc
argument_list|,
literal|"%d"
argument_list|,
name|argc
operator|-
operator|(
literal|3
operator|-
name|TCLSH
operator|)
argument_list|)
expr_stmt|;
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
literal|"argc"
argument_list|,
name|zArgc
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
literal|"argv0"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
literal|"argv"
argument_list|,
literal|""
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
operator|-
name|TCLSH
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|Tcl_SetVar
argument_list|(
name|interp
argument_list|,
literal|"argv"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|TCL_GLOBAL_ONLY
operator||
name|TCL_LIST_ELEMENT
operator||
name|TCL_APPEND_VALUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TCLSH
operator|==
literal|1
operator|&&
name|Tcl_EvalFile
argument_list|(
name|interp
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
operator|!=
name|TCL_OK
condition|)
block|{
specifier|const
name|char
modifier|*
name|zInfo
init|=
name|Tcl_GetVar
argument_list|(
name|interp
argument_list|,
literal|"errorInfo"
argument_list|,
name|TCL_GLOBAL_ONLY
argument_list|)
decl_stmt|;
if|if
condition|(
name|zInfo
operator|==
literal|0
condition|)
name|zInfo
operator|=
name|Tcl_GetStringResult
argument_list|(
name|interp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
operator|*
name|argv
argument_list|,
name|zInfo
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|TCLSH
operator|==
literal|2
operator|||
name|argc
operator|<=
literal|1
condition|)
block|{
name|Tcl_GlobalEval
argument_list|(
name|interp
argument_list|,
name|tclsh_main_loop
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCLSH */
end_comment

end_unit

