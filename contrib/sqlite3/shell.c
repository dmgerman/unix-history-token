begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* DO NOT EDIT! ** This file is automatically generated by the script in the canonical ** SQLite source tree at tool/mkshellc.tcl.  That script combines source ** code from various constituent source files of SQLite into this single ** "shell.c" file used to implement the SQLite command-line shell. ** ** Most of the code found below comes from the "src/shell.c.in" file in ** the canonical SQLite source tree.  That main file contains "INCLUDE" ** lines that specify other files in the canonical source tree that are ** inserted to getnerate this complete program source file. ** ** The code from multiple files is combined into this single "shell.c" ** source file to help make the command-line program easier to compile. ** ** To modify this program, get a copy of the canonical SQLite source tree, ** edit the src/shell.c.in" and/or some of the other files that are included ** by "src/shell.c.in", then rerun the tool/mkshellc.tcl script. */
end_comment

begin_comment
comment|/* ** 2001 September 15 ** ** The author disclaims copyright to this source code.  In place of ** a legal notice, here is a blessing: ** **    May you do good and not evil. **    May you find forgiveness for yourself and forgive others. **    May you share freely, never taking more than you give. ** ************************************************************************* ** This file contains code to implement the "sqlite" command line ** utility for accessing SQLite databases. */
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|_CRT_SECURE_NO_WARNINGS
argument_list|)
end_if

begin_comment
comment|/* This needs to come before any includes for MSVC compiler */
end_comment

begin_define
define|#
directive|define
name|_CRT_SECURE_NO_WARNINGS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** Warning pragmas copied from msvc.h in the core. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4054
name|)
end_pragma

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4055
name|)
end_pragma

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4100
name|)
end_pragma

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4127
name|)
end_pragma

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4130
name|)
end_pragma

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4152
name|)
end_pragma

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4189
name|)
end_pragma

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4206
name|)
end_pragma

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4210
name|)
end_pragma

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4232
name|)
end_pragma

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4244
name|)
end_pragma

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4305
name|)
end_pragma

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4306
name|)
end_pragma

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4702
name|)
end_pragma

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4706
name|)
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(_MSC_VER) */
end_comment

begin_comment
comment|/* ** No support for loadable extensions in VxWorks. */
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__RTP__
argument_list|)
operator|||
name|defined
argument_list|(
name|_WRS_KERNEL
argument_list|)
operator|)
operator|&&
operator|!
name|SQLITE_OMIT_LOAD_EXTENSION
end_if

begin_define
define|#
directive|define
name|SQLITE_OMIT_LOAD_EXTENSION
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** Enable large-file support for fopen() and friends on unix. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SQLITE_DISABLE_LFS
end_ifndef

begin_define
define|#
directive|define
name|_LARGE_FILE
value|1
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|_FILE_OFFSET_BITS
end_ifndef

begin_define
define|#
directive|define
name|_FILE_OFFSET_BITS
value|64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|_LARGEFILE_SOURCE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"sqlite3.h"
end_include

begin_if
if|#
directive|if
name|SQLITE_USER_AUTHENTICATION
end_if

begin_include
include|#
directive|include
file|"sqlite3userauth.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
end_if

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__RTP__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_WRS_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_READLINE
end_if

begin_include
include|#
directive|include
file|<readline/readline.h>
end_include

begin_include
include|#
directive|include
file|<readline/history.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_EDITLINE
end_if

begin_include
include|#
directive|include
file|<editline/readline.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_EDITLINE
operator|||
name|HAVE_READLINE
end_if

begin_define
define|#
directive|define
name|shell_add_history
parameter_list|(
name|X
parameter_list|)
value|add_history(X)
end_define

begin_define
define|#
directive|define
name|shell_read_history
parameter_list|(
name|X
parameter_list|)
value|read_history(X)
end_define

begin_define
define|#
directive|define
name|shell_write_history
parameter_list|(
name|X
parameter_list|)
value|write_history(X)
end_define

begin_define
define|#
directive|define
name|shell_stifle_history
parameter_list|(
name|X
parameter_list|)
value|stifle_history(X)
end_define

begin_define
define|#
directive|define
name|shell_readline
parameter_list|(
name|X
parameter_list|)
value|readline(X)
end_define

begin_elif
elif|#
directive|elif
name|HAVE_LINENOISE
end_elif

begin_include
include|#
directive|include
file|"linenoise.h"
end_include

begin_define
define|#
directive|define
name|shell_add_history
parameter_list|(
name|X
parameter_list|)
value|linenoiseHistoryAdd(X)
end_define

begin_define
define|#
directive|define
name|shell_read_history
parameter_list|(
name|X
parameter_list|)
value|linenoiseHistoryLoad(X)
end_define

begin_define
define|#
directive|define
name|shell_write_history
parameter_list|(
name|X
parameter_list|)
value|linenoiseHistorySave(X)
end_define

begin_define
define|#
directive|define
name|shell_stifle_history
parameter_list|(
name|X
parameter_list|)
value|linenoiseHistorySetMaxLen(X)
end_define

begin_define
define|#
directive|define
name|shell_readline
parameter_list|(
name|X
parameter_list|)
value|linenoise(X)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|shell_read_history
parameter_list|(
name|X
parameter_list|)
end_define

begin_define
define|#
directive|define
name|shell_write_history
parameter_list|(
name|X
parameter_list|)
end_define

begin_define
define|#
directive|define
name|shell_stifle_history
parameter_list|(
name|X
parameter_list|)
end_define

begin_define
define|#
directive|define
name|SHELL_USE_LOCAL_GETLINE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
end_if

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_define
define|#
directive|define
name|isatty
parameter_list|(
name|h
parameter_list|)
value|_isatty(h)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|access
end_ifndef

begin_define
define|#
directive|define
name|access
parameter_list|(
name|f
parameter_list|,
name|m
parameter_list|)
value|_access((f),(m))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|popen
end_undef

begin_define
define|#
directive|define
name|popen
value|_popen
end_define

begin_undef
undef|#
directive|undef
name|pclose
end_undef

begin_define
define|#
directive|define
name|pclose
value|_pclose
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Make sure isatty() has a prototype. */
end_comment

begin_function_decl
specifier|extern
name|int
name|isatty
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__RTP__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_WRS_KERNEL
argument_list|)
end_if

begin_comment
comment|/* popen and pclose are not C89 functions and so are   ** sometimes omitted from the<stdio.h> header */
end_comment

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|popen
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|pclose
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SQLITE_OMIT_POPEN
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32_WCE
argument_list|)
end_if

begin_comment
comment|/* Windows CE (arm-wince-mingw32ce-gcc) does not provide isatty()  * thus we always assume that we have a console. That can be  * overridden with the -batch command line option.  */
end_comment

begin_define
define|#
directive|define
name|isatty
parameter_list|(
name|x
parameter_list|)
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ctype macros that work with signed characters */
end_comment

begin_define
define|#
directive|define
name|IsSpace
parameter_list|(
name|X
parameter_list|)
value|isspace((unsigned char)X)
end_define

begin_define
define|#
directive|define
name|IsDigit
parameter_list|(
name|X
parameter_list|)
value|isdigit((unsigned char)X)
end_define

begin_define
define|#
directive|define
name|ToLower
parameter_list|(
name|X
parameter_list|)
value|(char)tolower((unsigned char)X)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
end_if

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_comment
comment|/* string conversion routines only needed on Win32 */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|sqlite3_win32_unicode_to_utf8
parameter_list|(
name|LPCWSTR
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|sqlite3_win32_mbcs_to_utf8_v2
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|sqlite3_win32_utf8_to_mbcs_v2
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|LPWSTR
name|sqlite3_win32_utf8_to_unicode
parameter_list|(
specifier|const
name|char
modifier|*
name|zText
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* On Windows, we normally run with output mode of TEXT so that \n characters ** are automatically translated into \r\n.  However, this behavior needs ** to be disabled in some cases (ex: when generating CSV output and when ** rendering quoted strings that contain \n characters).  The following ** routines take care of that. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
end_if

begin_function
specifier|static
name|void
name|setBinaryMode
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|isOutput
parameter_list|)
block|{
if|if
condition|(
name|isOutput
condition|)
name|fflush
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|_setmode
argument_list|(
name|_fileno
argument_list|(
name|file
argument_list|)
argument_list|,
name|_O_BINARY
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|setTextMode
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|isOutput
parameter_list|)
block|{
if|if
condition|(
name|isOutput
condition|)
name|fflush
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|_setmode
argument_list|(
name|_fileno
argument_list|(
name|file
argument_list|)
argument_list|,
name|_O_TEXT
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|setBinaryMode
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
end_define

begin_define
define|#
directive|define
name|setTextMode
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* True if the timer is enabled */
end_comment

begin_decl_stmt
specifier|static
name|int
name|enableTimer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the current wall-clock time */
end_comment

begin_function
specifier|static
name|sqlite3_int64
name|timeOfDay
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|sqlite3_vfs
modifier|*
name|clockVfs
init|=
literal|0
decl_stmt|;
name|sqlite3_int64
name|t
decl_stmt|;
if|if
condition|(
name|clockVfs
operator|==
literal|0
condition|)
name|clockVfs
operator|=
name|sqlite3_vfs_find
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|clockVfs
operator|->
name|iVersion
operator|>=
literal|2
operator|&&
name|clockVfs
operator|->
name|xCurrentTimeInt64
operator|!=
literal|0
condition|)
block|{
name|clockVfs
operator|->
name|xCurrentTimeInt64
argument_list|(
name|clockVfs
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|double
name|r
decl_stmt|;
name|clockVfs
operator|->
name|xCurrentTime
argument_list|(
name|clockVfs
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|t
operator|=
call|(
name|sqlite3_int64
call|)
argument_list|(
name|r
operator|*
literal|86400000.0
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__minux
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_comment
comment|/* VxWorks does not support getrusage() as far as we can determine */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WRS_KERNEL
argument_list|)
operator|||
name|defined
argument_list|(
name|__RTP__
argument_list|)
end_if

begin_struct
struct|struct
name|rusage
block|{
name|struct
name|timeval
name|ru_utime
decl_stmt|;
comment|/* user CPU time used */
name|struct
name|timeval
name|ru_stime
decl_stmt|;
comment|/* system CPU time used */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|getrusage
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|memset(B,0,sizeof(*B))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Saved resource information for the beginning of an operation */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|rusage
name|sBegin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CPU time at start */
end_comment

begin_decl_stmt
specifier|static
name|sqlite3_int64
name|iBegin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Wall-clock time at start */
end_comment

begin_comment
comment|/* ** Begin timing an operation */
end_comment

begin_function
specifier|static
name|void
name|beginTimer
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|enableTimer
condition|)
block|{
name|getrusage
argument_list|(
name|RUSAGE_SELF
argument_list|,
operator|&
name|sBegin
argument_list|)
expr_stmt|;
name|iBegin
operator|=
name|timeOfDay
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the difference of two time_structs in seconds */
end_comment

begin_function
specifier|static
name|double
name|timeDiff
parameter_list|(
name|struct
name|timeval
modifier|*
name|pStart
parameter_list|,
name|struct
name|timeval
modifier|*
name|pEnd
parameter_list|)
block|{
return|return
operator|(
name|pEnd
operator|->
name|tv_usec
operator|-
name|pStart
operator|->
name|tv_usec
operator|)
operator|*
literal|0.000001
operator|+
call|(
name|double
call|)
argument_list|(
name|pEnd
operator|->
name|tv_sec
operator|-
name|pStart
operator|->
name|tv_sec
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ** Print the timing results. */
end_comment

begin_function
specifier|static
name|void
name|endTimer
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|enableTimer
condition|)
block|{
name|sqlite3_int64
name|iEnd
init|=
name|timeOfDay
argument_list|()
decl_stmt|;
name|struct
name|rusage
name|sEnd
decl_stmt|;
name|getrusage
argument_list|(
name|RUSAGE_SELF
argument_list|,
operator|&
name|sEnd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Run Time: real %.3f user %f sys %f\n"
argument_list|,
operator|(
name|iEnd
operator|-
name|iBegin
operator|)
operator|*
literal|0.001
argument_list|,
name|timeDiff
argument_list|(
operator|&
name|sBegin
operator|.
name|ru_utime
argument_list|,
operator|&
name|sEnd
operator|.
name|ru_utime
argument_list|)
argument_list|,
name|timeDiff
argument_list|(
operator|&
name|sBegin
operator|.
name|ru_stime
argument_list|,
operator|&
name|sEnd
operator|.
name|ru_stime
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|BEGIN_TIMER
value|beginTimer()
end_define

begin_define
define|#
directive|define
name|END_TIMER
value|endTimer()
end_define

begin_define
define|#
directive|define
name|HAS_TIMER
value|1
end_define

begin_elif
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|)
end_elif

begin_comment
comment|/* Saved resource information for the beginning of an operation */
end_comment

begin_decl_stmt
specifier|static
name|HANDLE
name|hProcess
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILETIME
name|ftKernelBegin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILETIME
name|ftUserBegin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sqlite3_int64
name|ftWallBegin
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|BOOL
function_decl|(
name|WINAPI
modifier|*
name|GETPROCTIMES
function_decl|)
parameter_list|(
name|HANDLE
parameter_list|,
name|LPFILETIME
parameter_list|,
name|LPFILETIME
parameter_list|,
name|LPFILETIME
parameter_list|,
name|LPFILETIME
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|static
name|GETPROCTIMES
name|getProcessTimesAddr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** Check to see if we have timer support.  Return 1 if necessary ** support found (or found previously). */
end_comment

begin_function
specifier|static
name|int
name|hasTimer
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|getProcessTimesAddr
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* GetProcessTimes() isn't supported in WIN95 and some other Windows     ** versions. See if the version we are running on has it, and if it     ** does, save off a pointer to it and the current process handle.     */
name|hProcess
operator|=
name|GetCurrentProcess
argument_list|()
expr_stmt|;
if|if
condition|(
name|hProcess
condition|)
block|{
name|HINSTANCE
name|hinstLib
init|=
name|LoadLibrary
argument_list|(
name|TEXT
argument_list|(
literal|"Kernel32.dll"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|hinstLib
condition|)
block|{
name|getProcessTimesAddr
operator|=
operator|(
name|GETPROCTIMES
operator|)
name|GetProcAddress
argument_list|(
name|hinstLib
argument_list|,
literal|"GetProcessTimes"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|getProcessTimesAddr
condition|)
block|{
return|return
literal|1
return|;
block|}
name|FreeLibrary
argument_list|(
name|hinstLib
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ** Begin timing an operation */
end_comment

begin_function
specifier|static
name|void
name|beginTimer
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|enableTimer
operator|&&
name|getProcessTimesAddr
condition|)
block|{
name|FILETIME
name|ftCreation
decl_stmt|,
name|ftExit
decl_stmt|;
name|getProcessTimesAddr
argument_list|(
name|hProcess
argument_list|,
operator|&
name|ftCreation
argument_list|,
operator|&
name|ftExit
argument_list|,
operator|&
name|ftKernelBegin
argument_list|,
operator|&
name|ftUserBegin
argument_list|)
expr_stmt|;
name|ftWallBegin
operator|=
name|timeOfDay
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the difference of two FILETIME structs in seconds */
end_comment

begin_function
specifier|static
name|double
name|timeDiff
parameter_list|(
name|FILETIME
modifier|*
name|pStart
parameter_list|,
name|FILETIME
modifier|*
name|pEnd
parameter_list|)
block|{
name|sqlite_int64
name|i64Start
init|=
operator|*
operator|(
operator|(
name|sqlite_int64
operator|*
operator|)
name|pStart
operator|)
decl_stmt|;
name|sqlite_int64
name|i64End
init|=
operator|*
operator|(
operator|(
name|sqlite_int64
operator|*
operator|)
name|pEnd
operator|)
decl_stmt|;
return|return
call|(
name|double
call|)
argument_list|(
operator|(
name|i64End
operator|-
name|i64Start
operator|)
operator|/
literal|10000000.0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ** Print the timing results. */
end_comment

begin_function
specifier|static
name|void
name|endTimer
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|enableTimer
operator|&&
name|getProcessTimesAddr
condition|)
block|{
name|FILETIME
name|ftCreation
decl_stmt|,
name|ftExit
decl_stmt|,
name|ftKernelEnd
decl_stmt|,
name|ftUserEnd
decl_stmt|;
name|sqlite3_int64
name|ftWallEnd
init|=
name|timeOfDay
argument_list|()
decl_stmt|;
name|getProcessTimesAddr
argument_list|(
name|hProcess
argument_list|,
operator|&
name|ftCreation
argument_list|,
operator|&
name|ftExit
argument_list|,
operator|&
name|ftKernelEnd
argument_list|,
operator|&
name|ftUserEnd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Run Time: real %.3f user %f sys %f\n"
argument_list|,
operator|(
name|ftWallEnd
operator|-
name|ftWallBegin
operator|)
operator|*
literal|0.001
argument_list|,
name|timeDiff
argument_list|(
operator|&
name|ftUserBegin
argument_list|,
operator|&
name|ftUserEnd
argument_list|)
argument_list|,
name|timeDiff
argument_list|(
operator|&
name|ftKernelBegin
argument_list|,
operator|&
name|ftKernelEnd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|BEGIN_TIMER
value|beginTimer()
end_define

begin_define
define|#
directive|define
name|END_TIMER
value|endTimer()
end_define

begin_define
define|#
directive|define
name|HAS_TIMER
value|hasTimer()
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BEGIN_TIMER
end_define

begin_define
define|#
directive|define
name|END_TIMER
end_define

begin_define
define|#
directive|define
name|HAS_TIMER
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** Used to prevent warnings about unused parameters */
end_comment

begin_define
define|#
directive|define
name|UNUSED_PARAMETER
parameter_list|(
name|x
parameter_list|)
value|(void)(x)
end_define

begin_comment
comment|/* ** If the following flag is set, then command execution stops ** at an error if we are not interactive. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bail_on_error
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** Threat stdin as an interactive input if the following variable ** is true.  Otherwise, assume stdin is connected to a file or pipe. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stdin_is_interactive
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** On Windows systems we have to know if standard output is a console ** in order to translate UTF-8 into MBCS.  The following variable is ** true if translation is required. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stdout_is_console
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** The following is the open SQLite database.  We make a pointer ** to this database a static variable so that it can be accessed ** by the SIGINT handler to interrupt database processing. */
end_comment

begin_decl_stmt
specifier|static
name|sqlite3
modifier|*
name|globalDb
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** True if an interrupt (Control-C) has been received. */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|seenInterrupt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** This is the name of our program. It is set in main(), used ** in a number of other places, mostly for error messages. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|Argv0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** Prompt strings. Initialized in main. Settable with **   .prompt main continue */
end_comment

begin_decl_stmt
specifier|static
name|char
name|mainPrompt
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First line prompt. default: "sqlite> "*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|continuePrompt
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Continuation prompt. default: "   ...> " */
end_comment

begin_comment
comment|/* ** Render output like fprintf().  Except, if the output is going to the ** console and if this is running on a Windows machine, translate the ** output from UTF-8 into MBCS. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
end_if

begin_function
name|void
name|utf8_printf
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
specifier|const
name|char
modifier|*
name|zFormat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|zFormat
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdout_is_console
operator|&&
operator|(
name|out
operator|==
name|stdout
operator|||
name|out
operator|==
name|stderr
operator|)
condition|)
block|{
name|char
modifier|*
name|z1
init|=
name|sqlite3_vmprintf
argument_list|(
name|zFormat
argument_list|,
name|ap
argument_list|)
decl_stmt|;
name|char
modifier|*
name|z2
init|=
name|sqlite3_win32_utf8_to_mbcs_v2
argument_list|(
name|z1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|sqlite3_free
argument_list|(
name|z1
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|z2
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|z2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vfprintf
argument_list|(
name|out
argument_list|,
name|zFormat
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_elif
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|utf8_printf
argument_list|)
end_elif

begin_define
define|#
directive|define
name|utf8_printf
value|fprintf
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** Render output like fprintf().  This should not be used on anything that ** includes string formatting (e.g. "%s"). */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|raw_printf
argument_list|)
end_if

begin_define
define|#
directive|define
name|raw_printf
value|fprintf
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** Write I/O traces to the following stream. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SQLITE_ENABLE_IOTRACE
end_ifdef

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|iotrace
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** This routine works like printf in that its first argument is a ** format string and subsequent arguments are values to be substituted ** in place of % fields.  The result of formatting this string ** is written to iotrace. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SQLITE_ENABLE_IOTRACE
end_ifdef

begin_function
specifier|static
name|void
name|SQLITE_CDECL
name|iotracePrintf
parameter_list|(
specifier|const
name|char
modifier|*
name|zFormat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|char
modifier|*
name|z
decl_stmt|;
if|if
condition|(
name|iotrace
operator|==
literal|0
condition|)
return|return;
name|va_start
argument_list|(
name|ap
argument_list|,
name|zFormat
argument_list|)
expr_stmt|;
name|z
operator|=
name|sqlite3_vmprintf
argument_list|(
name|zFormat
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|iotrace
argument_list|,
literal|"%s"
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|z
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** Output string zUtf to stream pOut as w characters.  If w is negative, ** then right-justify the text.  W is the width in UTF-8 characters, not ** in bytes.  This is different from the %*.*s specification in printf ** since with %*.*s the width is measured in bytes, not characters. */
end_comment

begin_function
specifier|static
name|void
name|utf8_width_print
parameter_list|(
name|FILE
modifier|*
name|pOut
parameter_list|,
name|int
name|w
parameter_list|,
specifier|const
name|char
modifier|*
name|zUtf
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|aw
init|=
name|w
operator|<
literal|0
condition|?
operator|-
name|w
else|:
name|w
decl_stmt|;
name|char
name|zBuf
index|[
literal|1000
index|]
decl_stmt|;
if|if
condition|(
name|aw
operator|>
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|zBuf
argument_list|)
operator|/
literal|3
condition|)
name|aw
operator|=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|zBuf
argument_list|)
operator|/
literal|3
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n
operator|=
literal|0
init|;
name|zUtf
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|zUtf
index|[
name|i
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
block|{
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|aw
condition|)
block|{
do|do
block|{
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|zUtf
index|[
name|i
index|]
operator|&
literal|0xc0
operator|)
operator|==
literal|0x80
condition|)
do|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|n
operator|>=
name|aw
condition|)
block|{
name|utf8_printf
argument_list|(
name|pOut
argument_list|,
literal|"%.*s"
argument_list|,
name|i
argument_list|,
name|zUtf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|w
operator|<
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|pOut
argument_list|,
literal|"%*s%s"
argument_list|,
name|aw
operator|-
name|n
argument_list|,
literal|""
argument_list|,
name|zUtf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|utf8_printf
argument_list|(
name|pOut
argument_list|,
literal|"%s%*s"
argument_list|,
name|zUtf
argument_list|,
name|aw
operator|-
name|n
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** Determines if a string is a number of not. */
end_comment

begin_function
specifier|static
name|int
name|isNumber
parameter_list|(
specifier|const
name|char
modifier|*
name|z
parameter_list|,
name|int
modifier|*
name|realnum
parameter_list|)
block|{
if|if
condition|(
operator|*
name|z
operator|==
literal|'-'
operator|||
operator|*
name|z
operator|==
literal|'+'
condition|)
name|z
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|IsDigit
argument_list|(
operator|*
name|z
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
name|z
operator|++
expr_stmt|;
if|if
condition|(
name|realnum
condition|)
operator|*
name|realnum
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|IsDigit
argument_list|(
operator|*
name|z
argument_list|)
condition|)
block|{
name|z
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|z
operator|==
literal|'.'
condition|)
block|{
name|z
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|IsDigit
argument_list|(
operator|*
name|z
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|IsDigit
argument_list|(
operator|*
name|z
argument_list|)
condition|)
block|{
name|z
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|realnum
condition|)
operator|*
name|realnum
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|z
operator|==
literal|'e'
operator|||
operator|*
name|z
operator|==
literal|'E'
condition|)
block|{
name|z
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|z
operator|==
literal|'+'
operator|||
operator|*
name|z
operator|==
literal|'-'
condition|)
name|z
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|IsDigit
argument_list|(
operator|*
name|z
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|IsDigit
argument_list|(
operator|*
name|z
argument_list|)
condition|)
block|{
name|z
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|realnum
condition|)
operator|*
name|realnum
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|*
name|z
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ** Compute a string length that is limited to what can be stored in ** lower 30 bits of a 32-bit signed integer. */
end_comment

begin_function
specifier|static
name|int
name|strlen30
parameter_list|(
specifier|const
name|char
modifier|*
name|z
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|z2
init|=
name|z
decl_stmt|;
while|while
condition|(
operator|*
name|z2
condition|)
block|{
name|z2
operator|++
expr_stmt|;
block|}
return|return
literal|0x3fffffff
operator|&
call|(
name|int
call|)
argument_list|(
name|z2
operator|-
name|z
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ** Return the length of a string in characters.  Multibyte UTF8 characters ** count as a single character. */
end_comment

begin_function
specifier|static
name|int
name|strlenChar
parameter_list|(
specifier|const
name|char
modifier|*
name|z
parameter_list|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|z
condition|)
block|{
if|if
condition|(
operator|(
literal|0xc0
operator|&
operator|*
operator|(
name|z
operator|++
operator|)
operator|)
operator|!=
literal|0x80
condition|)
name|n
operator|++
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* ** This routine reads a line of text from FILE in, stores ** the text in memory obtained from malloc() and returns a pointer ** to the text.  NULL is returned at end of file, or if malloc() ** fails. ** ** If zLine is not NULL then it is a malloced buffer returned from ** a previous call to this routine that may be reused. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|local_getline
parameter_list|(
name|char
modifier|*
name|zLine
parameter_list|,
name|FILE
modifier|*
name|in
parameter_list|)
block|{
name|int
name|nLine
init|=
name|zLine
operator|==
literal|0
condition|?
literal|0
else|:
literal|100
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|n
operator|+
literal|100
operator|>
name|nLine
condition|)
block|{
name|nLine
operator|=
name|nLine
operator|*
literal|2
operator|+
literal|100
expr_stmt|;
name|zLine
operator|=
name|realloc
argument_list|(
name|zLine
argument_list|,
name|nLine
argument_list|)
expr_stmt|;
if|if
condition|(
name|zLine
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fgets
argument_list|(
operator|&
name|zLine
index|[
name|n
index|]
argument_list|,
name|nLine
operator|-
name|n
argument_list|,
name|in
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|zLine
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|zLine
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|zLine
index|[
name|n
index|]
condition|)
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
name|zLine
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|n
operator|--
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
name|zLine
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|'\r'
condition|)
name|n
operator|--
expr_stmt|;
name|zLine
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
comment|/* For interactive input on Windows systems, translate the   ** multi-byte characterset characters into UTF-8. */
if|if
condition|(
name|stdin_is_interactive
operator|&&
name|in
operator|==
name|stdin
condition|)
block|{
name|char
modifier|*
name|zTrans
init|=
name|sqlite3_win32_mbcs_to_utf8_v2
argument_list|(
name|zLine
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|zTrans
condition|)
block|{
name|int
name|nTrans
init|=
name|strlen30
argument_list|(
name|zTrans
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|nTrans
operator|>
name|nLine
condition|)
block|{
name|zLine
operator|=
name|realloc
argument_list|(
name|zLine
argument_list|,
name|nTrans
argument_list|)
expr_stmt|;
if|if
condition|(
name|zLine
operator|==
literal|0
condition|)
block|{
name|sqlite3_free
argument_list|(
name|zTrans
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|memcpy
argument_list|(
name|zLine
argument_list|,
name|zTrans
argument_list|,
name|nTrans
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zTrans
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* defined(_WIN32) || defined(WIN32) */
return|return
name|zLine
return|;
block|}
end_function

begin_comment
comment|/* ** Retrieve a single line of input text. ** ** If in==0 then read from standard input and prompt before each line. ** If isContinuation is true, then a continuation prompt is appropriate. ** If isContinuation is zero, then the main prompt should be used. ** ** If zPrior is not NULL then it is a buffer from a prior call to this ** routine that can be reused. ** ** The result is stored in space obtained from malloc() and must either ** be freed by the caller or else passed back into this routine via the ** zPrior argument for reuse. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|one_input_line
parameter_list|(
name|FILE
modifier|*
name|in
parameter_list|,
name|char
modifier|*
name|zPrior
parameter_list|,
name|int
name|isContinuation
parameter_list|)
block|{
name|char
modifier|*
name|zPrompt
decl_stmt|;
name|char
modifier|*
name|zResult
decl_stmt|;
if|if
condition|(
name|in
operator|!=
literal|0
condition|)
block|{
name|zResult
operator|=
name|local_getline
argument_list|(
name|zPrior
argument_list|,
name|in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zPrompt
operator|=
name|isContinuation
condition|?
name|continuePrompt
else|:
name|mainPrompt
expr_stmt|;
if|#
directive|if
name|SHELL_USE_LOCAL_GETLINE
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|zPrompt
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|zResult
operator|=
name|local_getline
argument_list|(
name|zPrior
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
name|zPrior
argument_list|)
expr_stmt|;
name|zResult
operator|=
name|shell_readline
argument_list|(
name|zPrompt
argument_list|)
expr_stmt|;
if|if
condition|(
name|zResult
operator|&&
operator|*
name|zResult
condition|)
name|shell_add_history
argument_list|(
name|zResult
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|zResult
return|;
block|}
end_function

begin_comment
comment|/* ** A variable length string to which one can append text. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|ShellText
name|ShellText
typedef|;
end_typedef

begin_struct
struct|struct
name|ShellText
block|{
name|char
modifier|*
name|z
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|nAlloc
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ** Initialize and destroy a ShellText object */
end_comment

begin_function
specifier|static
name|void
name|initText
parameter_list|(
name|ShellText
modifier|*
name|p
parameter_list|)
block|{
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|freeText
parameter_list|(
name|ShellText
modifier|*
name|p
parameter_list|)
block|{
name|free
argument_list|(
name|p
operator|->
name|z
argument_list|)
expr_stmt|;
name|initText
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* zIn is either a pointer to a NULL-terminated string in memory obtained ** from malloc(), or a NULL pointer. The string pointed to by zAppend is ** added to zIn, and the result returned in memory obtained from malloc(). ** zIn, if it was not NULL, is freed. ** ** If the third argument, quote, is not '\0', then it is used as a ** quote character for zAppend. */
end_comment

begin_function
specifier|static
name|void
name|appendText
parameter_list|(
name|ShellText
modifier|*
name|p
parameter_list|,
name|char
specifier|const
modifier|*
name|zAppend
parameter_list|,
name|char
name|quote
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|nAppend
init|=
name|strlen30
argument_list|(
name|zAppend
argument_list|)
decl_stmt|;
name|len
operator|=
name|nAppend
operator|+
name|p
operator|->
name|n
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|quote
condition|)
block|{
name|len
operator|+=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nAppend
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|zAppend
index|[
name|i
index|]
operator|==
name|quote
condition|)
name|len
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|n
operator|+
name|len
operator|>=
name|p
operator|->
name|nAlloc
condition|)
block|{
name|p
operator|->
name|nAlloc
operator|=
name|p
operator|->
name|nAlloc
operator|*
literal|2
operator|+
name|len
operator|+
literal|20
expr_stmt|;
name|p
operator|->
name|z
operator|=
name|realloc
argument_list|(
name|p
operator|->
name|z
argument_list|,
name|p
operator|->
name|nAlloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|z
operator|==
literal|0
condition|)
block|{
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|quote
condition|)
block|{
name|char
modifier|*
name|zCsr
init|=
name|p
operator|->
name|z
operator|+
name|p
operator|->
name|n
decl_stmt|;
operator|*
name|zCsr
operator|++
operator|=
name|quote
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nAppend
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|zCsr
operator|++
operator|=
name|zAppend
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|zAppend
index|[
name|i
index|]
operator|==
name|quote
condition|)
operator|*
name|zCsr
operator|++
operator|=
name|quote
expr_stmt|;
block|}
operator|*
name|zCsr
operator|++
operator|=
name|quote
expr_stmt|;
name|p
operator|->
name|n
operator|=
call|(
name|int
call|)
argument_list|(
name|zCsr
operator|-
name|p
operator|->
name|z
argument_list|)
expr_stmt|;
operator|*
name|zCsr
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|p
operator|->
name|z
operator|+
name|p
operator|->
name|n
argument_list|,
name|zAppend
argument_list|,
name|nAppend
argument_list|)
expr_stmt|;
name|p
operator|->
name|n
operator|+=
name|nAppend
expr_stmt|;
name|p
operator|->
name|z
index|[
name|p
operator|->
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** Attempt to determine if identifier zName needs to be quoted, either ** because it contains non-alphanumeric characters, or because it is an ** SQLite keyword.  Be conservative in this estimate:  When in doubt assume ** that quoting is required. ** ** Return '"' if quoting is required.  Return 0 if no quoting is required. */
end_comment

begin_function
specifier|static
name|char
name|quoteChar
parameter_list|(
specifier|const
name|char
modifier|*
name|zName
parameter_list|)
block|{
comment|/* All SQLite keywords, in alphabetical order */
specifier|static
specifier|const
name|char
modifier|*
name|azKeywords
index|[]
init|=
block|{
literal|"ABORT"
block|,
literal|"ACTION"
block|,
literal|"ADD"
block|,
literal|"AFTER"
block|,
literal|"ALL"
block|,
literal|"ALTER"
block|,
literal|"ANALYZE"
block|,
literal|"AND"
block|,
literal|"AS"
block|,
literal|"ASC"
block|,
literal|"ATTACH"
block|,
literal|"AUTOINCREMENT"
block|,
literal|"BEFORE"
block|,
literal|"BEGIN"
block|,
literal|"BETWEEN"
block|,
literal|"BY"
block|,
literal|"CASCADE"
block|,
literal|"CASE"
block|,
literal|"CAST"
block|,
literal|"CHECK"
block|,
literal|"COLLATE"
block|,
literal|"COLUMN"
block|,
literal|"COMMIT"
block|,
literal|"CONFLICT"
block|,
literal|"CONSTRAINT"
block|,
literal|"CREATE"
block|,
literal|"CROSS"
block|,
literal|"CURRENT_DATE"
block|,
literal|"CURRENT_TIME"
block|,
literal|"CURRENT_TIMESTAMP"
block|,
literal|"DATABASE"
block|,
literal|"DEFAULT"
block|,
literal|"DEFERRABLE"
block|,
literal|"DEFERRED"
block|,
literal|"DELETE"
block|,
literal|"DESC"
block|,
literal|"DETACH"
block|,
literal|"DISTINCT"
block|,
literal|"DROP"
block|,
literal|"EACH"
block|,
literal|"ELSE"
block|,
literal|"END"
block|,
literal|"ESCAPE"
block|,
literal|"EXCEPT"
block|,
literal|"EXCLUSIVE"
block|,
literal|"EXISTS"
block|,
literal|"EXPLAIN"
block|,
literal|"FAIL"
block|,
literal|"FOR"
block|,
literal|"FOREIGN"
block|,
literal|"FROM"
block|,
literal|"FULL"
block|,
literal|"GLOB"
block|,
literal|"GROUP"
block|,
literal|"HAVING"
block|,
literal|"IF"
block|,
literal|"IGNORE"
block|,
literal|"IMMEDIATE"
block|,
literal|"IN"
block|,
literal|"INDEX"
block|,
literal|"INDEXED"
block|,
literal|"INITIALLY"
block|,
literal|"INNER"
block|,
literal|"INSERT"
block|,
literal|"INSTEAD"
block|,
literal|"INTERSECT"
block|,
literal|"INTO"
block|,
literal|"IS"
block|,
literal|"ISNULL"
block|,
literal|"JOIN"
block|,
literal|"KEY"
block|,
literal|"LEFT"
block|,
literal|"LIKE"
block|,
literal|"LIMIT"
block|,
literal|"MATCH"
block|,
literal|"NATURAL"
block|,
literal|"NO"
block|,
literal|"NOT"
block|,
literal|"NOTNULL"
block|,
literal|"NULL"
block|,
literal|"OF"
block|,
literal|"OFFSET"
block|,
literal|"ON"
block|,
literal|"OR"
block|,
literal|"ORDER"
block|,
literal|"OUTER"
block|,
literal|"PLAN"
block|,
literal|"PRAGMA"
block|,
literal|"PRIMARY"
block|,
literal|"QUERY"
block|,
literal|"RAISE"
block|,
literal|"RECURSIVE"
block|,
literal|"REFERENCES"
block|,
literal|"REGEXP"
block|,
literal|"REINDEX"
block|,
literal|"RELEASE"
block|,
literal|"RENAME"
block|,
literal|"REPLACE"
block|,
literal|"RESTRICT"
block|,
literal|"RIGHT"
block|,
literal|"ROLLBACK"
block|,
literal|"ROW"
block|,
literal|"SAVEPOINT"
block|,
literal|"SELECT"
block|,
literal|"SET"
block|,
literal|"TABLE"
block|,
literal|"TEMP"
block|,
literal|"TEMPORARY"
block|,
literal|"THEN"
block|,
literal|"TO"
block|,
literal|"TRANSACTION"
block|,
literal|"TRIGGER"
block|,
literal|"UNION"
block|,
literal|"UNIQUE"
block|,
literal|"UPDATE"
block|,
literal|"USING"
block|,
literal|"VACUUM"
block|,
literal|"VALUES"
block|,
literal|"VIEW"
block|,
literal|"VIRTUAL"
block|,
literal|"WHEN"
block|,
literal|"WHERE"
block|,
literal|"WITH"
block|,
literal|"WITHOUT"
block|,   }
decl_stmt|;
name|int
name|i
decl_stmt|,
name|lwr
decl_stmt|,
name|upr
decl_stmt|,
name|mid
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|zName
index|[
literal|0
index|]
argument_list|)
operator|&&
name|zName
index|[
literal|0
index|]
operator|!=
literal|'_'
condition|)
return|return
literal|'"'
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|zName
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isalnum
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|zName
index|[
name|i
index|]
argument_list|)
operator|&&
name|zName
index|[
name|i
index|]
operator|!=
literal|'_'
condition|)
return|return
literal|'"'
return|;
block|}
name|lwr
operator|=
literal|0
expr_stmt|;
name|upr
operator|=
sizeof|sizeof
argument_list|(
name|azKeywords
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|azKeywords
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|lwr
operator|<=
name|upr
condition|)
block|{
name|mid
operator|=
operator|(
name|lwr
operator|+
name|upr
operator|)
operator|/
literal|2
expr_stmt|;
name|c
operator|=
name|sqlite3_stricmp
argument_list|(
name|azKeywords
index|[
name|mid
index|]
argument_list|,
name|zName
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
literal|'"'
return|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
name|lwr
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|upr
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ** SQL function:  shell_add_schema(S,X) ** ** Add the schema name X to the CREATE statement in S and return the result. ** Examples: ** **    CREATE TABLE t1(x)   ->   CREATE TABLE xyz.t1(x); ** ** Also works on ** **    CREATE INDEX **    CREATE UNIQUE INDEX **    CREATE VIEW **    CREATE TRIGGER **    CREATE VIRTUAL TABLE ** ** This UDF is used by the .schema command to insert the schema name of ** attached databases into the middle of the sqlite_master.sql field. */
end_comment

begin_function
specifier|static
name|void
name|shellAddSchemaName
parameter_list|(
name|sqlite3_context
modifier|*
name|pCtx
parameter_list|,
name|int
name|nVal
parameter_list|,
name|sqlite3_value
modifier|*
modifier|*
name|apVal
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|aPrefix
index|[]
init|=
block|{
literal|"TABLE"
block|,
literal|"INDEX"
block|,
literal|"UNIQUE INDEX"
block|,
literal|"VIEW"
block|,
literal|"TRIGGER"
block|,
literal|"VIRTUAL TABLE"
block|}
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|zIn
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_value_text
argument_list|(
name|apVal
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|zSchema
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_value_text
argument_list|(
name|apVal
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|nVal
operator|==
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|zIn
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|zIn
argument_list|,
literal|"CREATE "
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|aPrefix
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|aPrefix
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|n
init|=
name|strlen30
argument_list|(
name|aPrefix
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|zIn
operator|+
literal|7
argument_list|,
name|aPrefix
index|[
name|i
index|]
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|&&
name|zIn
index|[
name|n
operator|+
literal|7
index|]
operator|==
literal|' '
condition|)
block|{
name|char
name|cQuote
init|=
name|quoteChar
argument_list|(
name|zSchema
argument_list|)
decl_stmt|;
name|char
modifier|*
name|z
decl_stmt|;
if|if
condition|(
name|cQuote
condition|)
block|{
name|z
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"%.*s \"%w\".%s"
argument_list|,
name|n
operator|+
literal|7
argument_list|,
name|zIn
argument_list|,
name|zSchema
argument_list|,
name|zIn
operator|+
name|n
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|z
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"%.*s %s.%s"
argument_list|,
name|n
operator|+
literal|7
argument_list|,
name|zIn
argument_list|,
name|zSchema
argument_list|,
name|zIn
operator|+
name|n
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
name|sqlite3_result_text
argument_list|(
name|pCtx
argument_list|,
name|z
argument_list|,
operator|-
literal|1
argument_list|,
name|sqlite3_free
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
name|sqlite3_result_value
argument_list|(
name|pCtx
argument_list|,
name|apVal
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** The source code for several run-time loadable extensions is inserted ** below by the ../tool/mkshellc.tcl script.  Before processing that included ** code, we need to override some macros to make the included program code ** work here in the middle of this regular program. */
end_comment

begin_define
define|#
directive|define
name|SQLITE_EXTENSION_INIT1
end_define

begin_define
define|#
directive|define
name|SQLITE_EXTENSION_INIT2
parameter_list|(
name|X
parameter_list|)
value|(void)(X)
end_define

begin_comment
comment|/************************* Begin ../ext/misc/shathree.c ******************/
end_comment

begin_comment
comment|/* ** 2017-03-08 ** ** The author disclaims copyright to this source code.  In place of ** a legal notice, here is a blessing: ** **    May you do good and not evil. **    May you find forgiveness for yourself and forgive others. **    May you share freely, never taking more than you give. ** ****************************************************************************** ** ** This SQLite extension implements a functions that compute SHA1 hashes. ** Two SQL functions are implemented: ** **     sha3(X,SIZE) **     sha3_query(Y,SIZE) ** ** The sha3(X) function computes the SHA3 hash of the input X, or NULL if ** X is NULL. ** ** The sha3_query(Y) function evalutes all queries in the SQL statements of Y ** and returns a hash of their results. ** ** The SIZE argument is optional.  If omitted, the SHA3-256 hash algorithm ** is used.  If SIZE is included it must be one of the integers 224, 256, ** 384, or 512, to determine SHA3 hash variant that is computed. */
end_comment

begin_macro
name|SQLITE_EXTENSION_INIT1
end_macro

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_typedef
typedef|typedef
name|sqlite3_uint64
name|u64
typedef|;
end_typedef

begin_comment
comment|/****************************************************************************** ** The Hash Engine */
end_comment

begin_comment
comment|/* ** Macros to determine whether the machine is big or little endian, ** and whether or not that determination is run-time or compile-time. ** ** For best performance, an attempt is made to guess at the byte-order ** using C-preprocessor macros.  If that is unsuccessful, or if ** -DSHA3_BYTEORDER=0 is set, then byte-order is determined ** at run-time. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SHA3_BYTEORDER
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|i386
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|_M_IX86
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|__x86_64
argument_list|)
operator|||
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|||
name|defined
argument_list|(
name|_M_X64
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|_M_AMD64
argument_list|)
operator|||
name|defined
argument_list|(
name|_M_ARM
argument_list|)
operator|||
name|defined
argument_list|(
name|__x86
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|__arm__
argument_list|)
end_if

begin_define
define|#
directive|define
name|SHA3_BYTEORDER
value|1234
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|sparc
argument_list|)
operator|||
name|defined
argument_list|(
name|__ppc__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|SHA3_BYTEORDER
value|4321
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SHA3_BYTEORDER
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** State structure for a SHA3 hash in progress */
end_comment

begin_typedef
typedef|typedef
name|struct
name|SHA3Context
name|SHA3Context
typedef|;
end_typedef

begin_struct
struct|struct
name|SHA3Context
block|{
union|union
block|{
name|u64
name|s
index|[
literal|25
index|]
decl_stmt|;
comment|/* Keccak state. 5x5 lines of 64 bits each */
name|unsigned
name|char
name|x
index|[
literal|1600
index|]
decl_stmt|;
comment|/* ... or 1600 bytes */
block|}
name|u
union|;
name|unsigned
name|nRate
decl_stmt|;
comment|/* Bytes of input accepted per Keccak iteration */
name|unsigned
name|nLoaded
decl_stmt|;
comment|/* Input bytes loaded into u.x[] so far this cycle */
name|unsigned
name|ixMask
decl_stmt|;
comment|/* Insert next input into u.x[nLoaded^ixMask]. */
block|}
struct|;
end_struct

begin_comment
comment|/* ** A single step of the Keccak mixing function for a 1600-bit state */
end_comment

begin_function
specifier|static
name|void
name|KeccakF1600Step
parameter_list|(
name|SHA3Context
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u64
name|B0
decl_stmt|,
name|B1
decl_stmt|,
name|B2
decl_stmt|,
name|B3
decl_stmt|,
name|B4
decl_stmt|;
name|u64
name|C0
decl_stmt|,
name|C1
decl_stmt|,
name|C2
decl_stmt|,
name|C3
decl_stmt|,
name|C4
decl_stmt|;
name|u64
name|D0
decl_stmt|,
name|D1
decl_stmt|,
name|D2
decl_stmt|,
name|D3
decl_stmt|,
name|D4
decl_stmt|;
specifier|static
specifier|const
name|u64
name|RC
index|[]
init|=
block|{
literal|0x0000000000000001ULL
block|,
literal|0x0000000000008082ULL
block|,
literal|0x800000000000808aULL
block|,
literal|0x8000000080008000ULL
block|,
literal|0x000000000000808bULL
block|,
literal|0x0000000080000001ULL
block|,
literal|0x8000000080008081ULL
block|,
literal|0x8000000000008009ULL
block|,
literal|0x000000000000008aULL
block|,
literal|0x0000000000000088ULL
block|,
literal|0x0000000080008009ULL
block|,
literal|0x000000008000000aULL
block|,
literal|0x000000008000808bULL
block|,
literal|0x800000000000008bULL
block|,
literal|0x8000000000008089ULL
block|,
literal|0x8000000000008003ULL
block|,
literal|0x8000000000008002ULL
block|,
literal|0x8000000000000080ULL
block|,
literal|0x000000000000800aULL
block|,
literal|0x800000008000000aULL
block|,
literal|0x8000000080008081ULL
block|,
literal|0x8000000000008080ULL
block|,
literal|0x0000000080000001ULL
block|,
literal|0x8000000080008008ULL
block|}
decl_stmt|;
define|#
directive|define
name|A00
value|(p->u.s[0])
define|#
directive|define
name|A01
value|(p->u.s[1])
define|#
directive|define
name|A02
value|(p->u.s[2])
define|#
directive|define
name|A03
value|(p->u.s[3])
define|#
directive|define
name|A04
value|(p->u.s[4])
define|#
directive|define
name|A10
value|(p->u.s[5])
define|#
directive|define
name|A11
value|(p->u.s[6])
define|#
directive|define
name|A12
value|(p->u.s[7])
define|#
directive|define
name|A13
value|(p->u.s[8])
define|#
directive|define
name|A14
value|(p->u.s[9])
define|#
directive|define
name|A20
value|(p->u.s[10])
define|#
directive|define
name|A21
value|(p->u.s[11])
define|#
directive|define
name|A22
value|(p->u.s[12])
define|#
directive|define
name|A23
value|(p->u.s[13])
define|#
directive|define
name|A24
value|(p->u.s[14])
define|#
directive|define
name|A30
value|(p->u.s[15])
define|#
directive|define
name|A31
value|(p->u.s[16])
define|#
directive|define
name|A32
value|(p->u.s[17])
define|#
directive|define
name|A33
value|(p->u.s[18])
define|#
directive|define
name|A34
value|(p->u.s[19])
define|#
directive|define
name|A40
value|(p->u.s[20])
define|#
directive|define
name|A41
value|(p->u.s[21])
define|#
directive|define
name|A42
value|(p->u.s[22])
define|#
directive|define
name|A43
value|(p->u.s[23])
define|#
directive|define
name|A44
value|(p->u.s[24])
define|#
directive|define
name|ROL64
parameter_list|(
name|a
parameter_list|,
name|x
parameter_list|)
value|((a<<x)|(a>>(64-x)))
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|24
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|C0
operator|=
name|A00
operator|^
name|A10
operator|^
name|A20
operator|^
name|A30
operator|^
name|A40
expr_stmt|;
name|C1
operator|=
name|A01
operator|^
name|A11
operator|^
name|A21
operator|^
name|A31
operator|^
name|A41
expr_stmt|;
name|C2
operator|=
name|A02
operator|^
name|A12
operator|^
name|A22
operator|^
name|A32
operator|^
name|A42
expr_stmt|;
name|C3
operator|=
name|A03
operator|^
name|A13
operator|^
name|A23
operator|^
name|A33
operator|^
name|A43
expr_stmt|;
name|C4
operator|=
name|A04
operator|^
name|A14
operator|^
name|A24
operator|^
name|A34
operator|^
name|A44
expr_stmt|;
name|D0
operator|=
name|C4
operator|^
name|ROL64
argument_list|(
name|C1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|D1
operator|=
name|C0
operator|^
name|ROL64
argument_list|(
name|C2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|D2
operator|=
name|C1
operator|^
name|ROL64
argument_list|(
name|C3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|D3
operator|=
name|C2
operator|^
name|ROL64
argument_list|(
name|C4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|D4
operator|=
name|C3
operator|^
name|ROL64
argument_list|(
name|C0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|B0
operator|=
operator|(
name|A00
operator|^
name|D0
operator|)
expr_stmt|;
name|B1
operator|=
name|ROL64
argument_list|(
operator|(
name|A11
operator|^
name|D1
operator|)
argument_list|,
literal|44
argument_list|)
expr_stmt|;
name|B2
operator|=
name|ROL64
argument_list|(
operator|(
name|A22
operator|^
name|D2
operator|)
argument_list|,
literal|43
argument_list|)
expr_stmt|;
name|B3
operator|=
name|ROL64
argument_list|(
operator|(
name|A33
operator|^
name|D3
operator|)
argument_list|,
literal|21
argument_list|)
expr_stmt|;
name|B4
operator|=
name|ROL64
argument_list|(
operator|(
name|A44
operator|^
name|D4
operator|)
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|A00
operator|=
name|B0
operator|^
operator|(
operator|(
operator|~
name|B1
operator|)
operator|&
name|B2
operator|)
expr_stmt|;
name|A00
operator|^=
name|RC
index|[
name|i
index|]
expr_stmt|;
name|A11
operator|=
name|B1
operator|^
operator|(
operator|(
operator|~
name|B2
operator|)
operator|&
name|B3
operator|)
expr_stmt|;
name|A22
operator|=
name|B2
operator|^
operator|(
operator|(
operator|~
name|B3
operator|)
operator|&
name|B4
operator|)
expr_stmt|;
name|A33
operator|=
name|B3
operator|^
operator|(
operator|(
operator|~
name|B4
operator|)
operator|&
name|B0
operator|)
expr_stmt|;
name|A44
operator|=
name|B4
operator|^
operator|(
operator|(
operator|~
name|B0
operator|)
operator|&
name|B1
operator|)
expr_stmt|;
name|B2
operator|=
name|ROL64
argument_list|(
operator|(
name|A20
operator|^
name|D0
operator|)
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|B3
operator|=
name|ROL64
argument_list|(
operator|(
name|A31
operator|^
name|D1
operator|)
argument_list|,
literal|45
argument_list|)
expr_stmt|;
name|B4
operator|=
name|ROL64
argument_list|(
operator|(
name|A42
operator|^
name|D2
operator|)
argument_list|,
literal|61
argument_list|)
expr_stmt|;
name|B0
operator|=
name|ROL64
argument_list|(
operator|(
name|A03
operator|^
name|D3
operator|)
argument_list|,
literal|28
argument_list|)
expr_stmt|;
name|B1
operator|=
name|ROL64
argument_list|(
operator|(
name|A14
operator|^
name|D4
operator|)
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|A20
operator|=
name|B0
operator|^
operator|(
operator|(
operator|~
name|B1
operator|)
operator|&
name|B2
operator|)
expr_stmt|;
name|A31
operator|=
name|B1
operator|^
operator|(
operator|(
operator|~
name|B2
operator|)
operator|&
name|B3
operator|)
expr_stmt|;
name|A42
operator|=
name|B2
operator|^
operator|(
operator|(
operator|~
name|B3
operator|)
operator|&
name|B4
operator|)
expr_stmt|;
name|A03
operator|=
name|B3
operator|^
operator|(
operator|(
operator|~
name|B4
operator|)
operator|&
name|B0
operator|)
expr_stmt|;
name|A14
operator|=
name|B4
operator|^
operator|(
operator|(
operator|~
name|B0
operator|)
operator|&
name|B1
operator|)
expr_stmt|;
name|B4
operator|=
name|ROL64
argument_list|(
operator|(
name|A40
operator|^
name|D0
operator|)
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|B0
operator|=
name|ROL64
argument_list|(
operator|(
name|A01
operator|^
name|D1
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|B1
operator|=
name|ROL64
argument_list|(
operator|(
name|A12
operator|^
name|D2
operator|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|B2
operator|=
name|ROL64
argument_list|(
operator|(
name|A23
operator|^
name|D3
operator|)
argument_list|,
literal|25
argument_list|)
expr_stmt|;
name|B3
operator|=
name|ROL64
argument_list|(
operator|(
name|A34
operator|^
name|D4
operator|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|A40
operator|=
name|B0
operator|^
operator|(
operator|(
operator|~
name|B1
operator|)
operator|&
name|B2
operator|)
expr_stmt|;
name|A01
operator|=
name|B1
operator|^
operator|(
operator|(
operator|~
name|B2
operator|)
operator|&
name|B3
operator|)
expr_stmt|;
name|A12
operator|=
name|B2
operator|^
operator|(
operator|(
operator|~
name|B3
operator|)
operator|&
name|B4
operator|)
expr_stmt|;
name|A23
operator|=
name|B3
operator|^
operator|(
operator|(
operator|~
name|B4
operator|)
operator|&
name|B0
operator|)
expr_stmt|;
name|A34
operator|=
name|B4
operator|^
operator|(
operator|(
operator|~
name|B0
operator|)
operator|&
name|B1
operator|)
expr_stmt|;
name|B1
operator|=
name|ROL64
argument_list|(
operator|(
name|A10
operator|^
name|D0
operator|)
argument_list|,
literal|36
argument_list|)
expr_stmt|;
name|B2
operator|=
name|ROL64
argument_list|(
operator|(
name|A21
operator|^
name|D1
operator|)
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|B3
operator|=
name|ROL64
argument_list|(
operator|(
name|A32
operator|^
name|D2
operator|)
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|B4
operator|=
name|ROL64
argument_list|(
operator|(
name|A43
operator|^
name|D3
operator|)
argument_list|,
literal|56
argument_list|)
expr_stmt|;
name|B0
operator|=
name|ROL64
argument_list|(
operator|(
name|A04
operator|^
name|D4
operator|)
argument_list|,
literal|27
argument_list|)
expr_stmt|;
name|A10
operator|=
name|B0
operator|^
operator|(
operator|(
operator|~
name|B1
operator|)
operator|&
name|B2
operator|)
expr_stmt|;
name|A21
operator|=
name|B1
operator|^
operator|(
operator|(
operator|~
name|B2
operator|)
operator|&
name|B3
operator|)
expr_stmt|;
name|A32
operator|=
name|B2
operator|^
operator|(
operator|(
operator|~
name|B3
operator|)
operator|&
name|B4
operator|)
expr_stmt|;
name|A43
operator|=
name|B3
operator|^
operator|(
operator|(
operator|~
name|B4
operator|)
operator|&
name|B0
operator|)
expr_stmt|;
name|A04
operator|=
name|B4
operator|^
operator|(
operator|(
operator|~
name|B0
operator|)
operator|&
name|B1
operator|)
expr_stmt|;
name|B3
operator|=
name|ROL64
argument_list|(
operator|(
name|A30
operator|^
name|D0
operator|)
argument_list|,
literal|41
argument_list|)
expr_stmt|;
name|B4
operator|=
name|ROL64
argument_list|(
operator|(
name|A41
operator|^
name|D1
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|B0
operator|=
name|ROL64
argument_list|(
operator|(
name|A02
operator|^
name|D2
operator|)
argument_list|,
literal|62
argument_list|)
expr_stmt|;
name|B1
operator|=
name|ROL64
argument_list|(
operator|(
name|A13
operator|^
name|D3
operator|)
argument_list|,
literal|55
argument_list|)
expr_stmt|;
name|B2
operator|=
name|ROL64
argument_list|(
operator|(
name|A24
operator|^
name|D4
operator|)
argument_list|,
literal|39
argument_list|)
expr_stmt|;
name|A30
operator|=
name|B0
operator|^
operator|(
operator|(
operator|~
name|B1
operator|)
operator|&
name|B2
operator|)
expr_stmt|;
name|A41
operator|=
name|B1
operator|^
operator|(
operator|(
operator|~
name|B2
operator|)
operator|&
name|B3
operator|)
expr_stmt|;
name|A02
operator|=
name|B2
operator|^
operator|(
operator|(
operator|~
name|B3
operator|)
operator|&
name|B4
operator|)
expr_stmt|;
name|A13
operator|=
name|B3
operator|^
operator|(
operator|(
operator|~
name|B4
operator|)
operator|&
name|B0
operator|)
expr_stmt|;
name|A24
operator|=
name|B4
operator|^
operator|(
operator|(
operator|~
name|B0
operator|)
operator|&
name|B1
operator|)
expr_stmt|;
name|C0
operator|=
name|A00
operator|^
name|A20
operator|^
name|A40
operator|^
name|A10
operator|^
name|A30
expr_stmt|;
name|C1
operator|=
name|A11
operator|^
name|A31
operator|^
name|A01
operator|^
name|A21
operator|^
name|A41
expr_stmt|;
name|C2
operator|=
name|A22
operator|^
name|A42
operator|^
name|A12
operator|^
name|A32
operator|^
name|A02
expr_stmt|;
name|C3
operator|=
name|A33
operator|^
name|A03
operator|^
name|A23
operator|^
name|A43
operator|^
name|A13
expr_stmt|;
name|C4
operator|=
name|A44
operator|^
name|A14
operator|^
name|A34
operator|^
name|A04
operator|^
name|A24
expr_stmt|;
name|D0
operator|=
name|C4
operator|^
name|ROL64
argument_list|(
name|C1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|D1
operator|=
name|C0
operator|^
name|ROL64
argument_list|(
name|C2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|D2
operator|=
name|C1
operator|^
name|ROL64
argument_list|(
name|C3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|D3
operator|=
name|C2
operator|^
name|ROL64
argument_list|(
name|C4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|D4
operator|=
name|C3
operator|^
name|ROL64
argument_list|(
name|C0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|B0
operator|=
operator|(
name|A00
operator|^
name|D0
operator|)
expr_stmt|;
name|B1
operator|=
name|ROL64
argument_list|(
operator|(
name|A31
operator|^
name|D1
operator|)
argument_list|,
literal|44
argument_list|)
expr_stmt|;
name|B2
operator|=
name|ROL64
argument_list|(
operator|(
name|A12
operator|^
name|D2
operator|)
argument_list|,
literal|43
argument_list|)
expr_stmt|;
name|B3
operator|=
name|ROL64
argument_list|(
operator|(
name|A43
operator|^
name|D3
operator|)
argument_list|,
literal|21
argument_list|)
expr_stmt|;
name|B4
operator|=
name|ROL64
argument_list|(
operator|(
name|A24
operator|^
name|D4
operator|)
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|A00
operator|=
name|B0
operator|^
operator|(
operator|(
operator|~
name|B1
operator|)
operator|&
name|B2
operator|)
expr_stmt|;
name|A00
operator|^=
name|RC
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|A31
operator|=
name|B1
operator|^
operator|(
operator|(
operator|~
name|B2
operator|)
operator|&
name|B3
operator|)
expr_stmt|;
name|A12
operator|=
name|B2
operator|^
operator|(
operator|(
operator|~
name|B3
operator|)
operator|&
name|B4
operator|)
expr_stmt|;
name|A43
operator|=
name|B3
operator|^
operator|(
operator|(
operator|~
name|B4
operator|)
operator|&
name|B0
operator|)
expr_stmt|;
name|A24
operator|=
name|B4
operator|^
operator|(
operator|(
operator|~
name|B0
operator|)
operator|&
name|B1
operator|)
expr_stmt|;
name|B2
operator|=
name|ROL64
argument_list|(
operator|(
name|A40
operator|^
name|D0
operator|)
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|B3
operator|=
name|ROL64
argument_list|(
operator|(
name|A21
operator|^
name|D1
operator|)
argument_list|,
literal|45
argument_list|)
expr_stmt|;
name|B4
operator|=
name|ROL64
argument_list|(
operator|(
name|A02
operator|^
name|D2
operator|)
argument_list|,
literal|61
argument_list|)
expr_stmt|;
name|B0
operator|=
name|ROL64
argument_list|(
operator|(
name|A33
operator|^
name|D3
operator|)
argument_list|,
literal|28
argument_list|)
expr_stmt|;
name|B1
operator|=
name|ROL64
argument_list|(
operator|(
name|A14
operator|^
name|D4
operator|)
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|A40
operator|=
name|B0
operator|^
operator|(
operator|(
operator|~
name|B1
operator|)
operator|&
name|B2
operator|)
expr_stmt|;
name|A21
operator|=
name|B1
operator|^
operator|(
operator|(
operator|~
name|B2
operator|)
operator|&
name|B3
operator|)
expr_stmt|;
name|A02
operator|=
name|B2
operator|^
operator|(
operator|(
operator|~
name|B3
operator|)
operator|&
name|B4
operator|)
expr_stmt|;
name|A33
operator|=
name|B3
operator|^
operator|(
operator|(
operator|~
name|B4
operator|)
operator|&
name|B0
operator|)
expr_stmt|;
name|A14
operator|=
name|B4
operator|^
operator|(
operator|(
operator|~
name|B0
operator|)
operator|&
name|B1
operator|)
expr_stmt|;
name|B4
operator|=
name|ROL64
argument_list|(
operator|(
name|A30
operator|^
name|D0
operator|)
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|B0
operator|=
name|ROL64
argument_list|(
operator|(
name|A11
operator|^
name|D1
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|B1
operator|=
name|ROL64
argument_list|(
operator|(
name|A42
operator|^
name|D2
operator|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|B2
operator|=
name|ROL64
argument_list|(
operator|(
name|A23
operator|^
name|D3
operator|)
argument_list|,
literal|25
argument_list|)
expr_stmt|;
name|B3
operator|=
name|ROL64
argument_list|(
operator|(
name|A04
operator|^
name|D4
operator|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|A30
operator|=
name|B0
operator|^
operator|(
operator|(
operator|~
name|B1
operator|)
operator|&
name|B2
operator|)
expr_stmt|;
name|A11
operator|=
name|B1
operator|^
operator|(
operator|(
operator|~
name|B2
operator|)
operator|&
name|B3
operator|)
expr_stmt|;
name|A42
operator|=
name|B2
operator|^
operator|(
operator|(
operator|~
name|B3
operator|)
operator|&
name|B4
operator|)
expr_stmt|;
name|A23
operator|=
name|B3
operator|^
operator|(
operator|(
operator|~
name|B4
operator|)
operator|&
name|B0
operator|)
expr_stmt|;
name|A04
operator|=
name|B4
operator|^
operator|(
operator|(
operator|~
name|B0
operator|)
operator|&
name|B1
operator|)
expr_stmt|;
name|B1
operator|=
name|ROL64
argument_list|(
operator|(
name|A20
operator|^
name|D0
operator|)
argument_list|,
literal|36
argument_list|)
expr_stmt|;
name|B2
operator|=
name|ROL64
argument_list|(
operator|(
name|A01
operator|^
name|D1
operator|)
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|B3
operator|=
name|ROL64
argument_list|(
operator|(
name|A32
operator|^
name|D2
operator|)
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|B4
operator|=
name|ROL64
argument_list|(
operator|(
name|A13
operator|^
name|D3
operator|)
argument_list|,
literal|56
argument_list|)
expr_stmt|;
name|B0
operator|=
name|ROL64
argument_list|(
operator|(
name|A44
operator|^
name|D4
operator|)
argument_list|,
literal|27
argument_list|)
expr_stmt|;
name|A20
operator|=
name|B0
operator|^
operator|(
operator|(
operator|~
name|B1
operator|)
operator|&
name|B2
operator|)
expr_stmt|;
name|A01
operator|=
name|B1
operator|^
operator|(
operator|(
operator|~
name|B2
operator|)
operator|&
name|B3
operator|)
expr_stmt|;
name|A32
operator|=
name|B2
operator|^
operator|(
operator|(
operator|~
name|B3
operator|)
operator|&
name|B4
operator|)
expr_stmt|;
name|A13
operator|=
name|B3
operator|^
operator|(
operator|(
operator|~
name|B4
operator|)
operator|&
name|B0
operator|)
expr_stmt|;
name|A44
operator|=
name|B4
operator|^
operator|(
operator|(
operator|~
name|B0
operator|)
operator|&
name|B1
operator|)
expr_stmt|;
name|B3
operator|=
name|ROL64
argument_list|(
operator|(
name|A10
operator|^
name|D0
operator|)
argument_list|,
literal|41
argument_list|)
expr_stmt|;
name|B4
operator|=
name|ROL64
argument_list|(
operator|(
name|A41
operator|^
name|D1
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|B0
operator|=
name|ROL64
argument_list|(
operator|(
name|A22
operator|^
name|D2
operator|)
argument_list|,
literal|62
argument_list|)
expr_stmt|;
name|B1
operator|=
name|ROL64
argument_list|(
operator|(
name|A03
operator|^
name|D3
operator|)
argument_list|,
literal|55
argument_list|)
expr_stmt|;
name|B2
operator|=
name|ROL64
argument_list|(
operator|(
name|A34
operator|^
name|D4
operator|)
argument_list|,
literal|39
argument_list|)
expr_stmt|;
name|A10
operator|=
name|B0
operator|^
operator|(
operator|(
operator|~
name|B1
operator|)
operator|&
name|B2
operator|)
expr_stmt|;
name|A41
operator|=
name|B1
operator|^
operator|(
operator|(
operator|~
name|B2
operator|)
operator|&
name|B3
operator|)
expr_stmt|;
name|A22
operator|=
name|B2
operator|^
operator|(
operator|(
operator|~
name|B3
operator|)
operator|&
name|B4
operator|)
expr_stmt|;
name|A03
operator|=
name|B3
operator|^
operator|(
operator|(
operator|~
name|B4
operator|)
operator|&
name|B0
operator|)
expr_stmt|;
name|A34
operator|=
name|B4
operator|^
operator|(
operator|(
operator|~
name|B0
operator|)
operator|&
name|B1
operator|)
expr_stmt|;
name|C0
operator|=
name|A00
operator|^
name|A40
operator|^
name|A30
operator|^
name|A20
operator|^
name|A10
expr_stmt|;
name|C1
operator|=
name|A31
operator|^
name|A21
operator|^
name|A11
operator|^
name|A01
operator|^
name|A41
expr_stmt|;
name|C2
operator|=
name|A12
operator|^
name|A02
operator|^
name|A42
operator|^
name|A32
operator|^
name|A22
expr_stmt|;
name|C3
operator|=
name|A43
operator|^
name|A33
operator|^
name|A23
operator|^
name|A13
operator|^
name|A03
expr_stmt|;
name|C4
operator|=
name|A24
operator|^
name|A14
operator|^
name|A04
operator|^
name|A44
operator|^
name|A34
expr_stmt|;
name|D0
operator|=
name|C4
operator|^
name|ROL64
argument_list|(
name|C1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|D1
operator|=
name|C0
operator|^
name|ROL64
argument_list|(
name|C2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|D2
operator|=
name|C1
operator|^
name|ROL64
argument_list|(
name|C3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|D3
operator|=
name|C2
operator|^
name|ROL64
argument_list|(
name|C4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|D4
operator|=
name|C3
operator|^
name|ROL64
argument_list|(
name|C0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|B0
operator|=
operator|(
name|A00
operator|^
name|D0
operator|)
expr_stmt|;
name|B1
operator|=
name|ROL64
argument_list|(
operator|(
name|A21
operator|^
name|D1
operator|)
argument_list|,
literal|44
argument_list|)
expr_stmt|;
name|B2
operator|=
name|ROL64
argument_list|(
operator|(
name|A42
operator|^
name|D2
operator|)
argument_list|,
literal|43
argument_list|)
expr_stmt|;
name|B3
operator|=
name|ROL64
argument_list|(
operator|(
name|A13
operator|^
name|D3
operator|)
argument_list|,
literal|21
argument_list|)
expr_stmt|;
name|B4
operator|=
name|ROL64
argument_list|(
operator|(
name|A34
operator|^
name|D4
operator|)
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|A00
operator|=
name|B0
operator|^
operator|(
operator|(
operator|~
name|B1
operator|)
operator|&
name|B2
operator|)
expr_stmt|;
name|A00
operator|^=
name|RC
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
name|A21
operator|=
name|B1
operator|^
operator|(
operator|(
operator|~
name|B2
operator|)
operator|&
name|B3
operator|)
expr_stmt|;
name|A42
operator|=
name|B2
operator|^
operator|(
operator|(
operator|~
name|B3
operator|)
operator|&
name|B4
operator|)
expr_stmt|;
name|A13
operator|=
name|B3
operator|^
operator|(
operator|(
operator|~
name|B4
operator|)
operator|&
name|B0
operator|)
expr_stmt|;
name|A34
operator|=
name|B4
operator|^
operator|(
operator|(
operator|~
name|B0
operator|)
operator|&
name|B1
operator|)
expr_stmt|;
name|B2
operator|=
name|ROL64
argument_list|(
operator|(
name|A30
operator|^
name|D0
operator|)
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|B3
operator|=
name|ROL64
argument_list|(
operator|(
name|A01
operator|^
name|D1
operator|)
argument_list|,
literal|45
argument_list|)
expr_stmt|;
name|B4
operator|=
name|ROL64
argument_list|(
operator|(
name|A22
operator|^
name|D2
operator|)
argument_list|,
literal|61
argument_list|)
expr_stmt|;
name|B0
operator|=
name|ROL64
argument_list|(
operator|(
name|A43
operator|^
name|D3
operator|)
argument_list|,
literal|28
argument_list|)
expr_stmt|;
name|B1
operator|=
name|ROL64
argument_list|(
operator|(
name|A14
operator|^
name|D4
operator|)
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|A30
operator|=
name|B0
operator|^
operator|(
operator|(
operator|~
name|B1
operator|)
operator|&
name|B2
operator|)
expr_stmt|;
name|A01
operator|=
name|B1
operator|^
operator|(
operator|(
operator|~
name|B2
operator|)
operator|&
name|B3
operator|)
expr_stmt|;
name|A22
operator|=
name|B2
operator|^
operator|(
operator|(
operator|~
name|B3
operator|)
operator|&
name|B4
operator|)
expr_stmt|;
name|A43
operator|=
name|B3
operator|^
operator|(
operator|(
operator|~
name|B4
operator|)
operator|&
name|B0
operator|)
expr_stmt|;
name|A14
operator|=
name|B4
operator|^
operator|(
operator|(
operator|~
name|B0
operator|)
operator|&
name|B1
operator|)
expr_stmt|;
name|B4
operator|=
name|ROL64
argument_list|(
operator|(
name|A10
operator|^
name|D0
operator|)
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|B0
operator|=
name|ROL64
argument_list|(
operator|(
name|A31
operator|^
name|D1
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|B1
operator|=
name|ROL64
argument_list|(
operator|(
name|A02
operator|^
name|D2
operator|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|B2
operator|=
name|ROL64
argument_list|(
operator|(
name|A23
operator|^
name|D3
operator|)
argument_list|,
literal|25
argument_list|)
expr_stmt|;
name|B3
operator|=
name|ROL64
argument_list|(
operator|(
name|A44
operator|^
name|D4
operator|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|A10
operator|=
name|B0
operator|^
operator|(
operator|(
operator|~
name|B1
operator|)
operator|&
name|B2
operator|)
expr_stmt|;
name|A31
operator|=
name|B1
operator|^
operator|(
operator|(
operator|~
name|B2
operator|)
operator|&
name|B3
operator|)
expr_stmt|;
name|A02
operator|=
name|B2
operator|^
operator|(
operator|(
operator|~
name|B3
operator|)
operator|&
name|B4
operator|)
expr_stmt|;
name|A23
operator|=
name|B3
operator|^
operator|(
operator|(
operator|~
name|B4
operator|)
operator|&
name|B0
operator|)
expr_stmt|;
name|A44
operator|=
name|B4
operator|^
operator|(
operator|(
operator|~
name|B0
operator|)
operator|&
name|B1
operator|)
expr_stmt|;
name|B1
operator|=
name|ROL64
argument_list|(
operator|(
name|A40
operator|^
name|D0
operator|)
argument_list|,
literal|36
argument_list|)
expr_stmt|;
name|B2
operator|=
name|ROL64
argument_list|(
operator|(
name|A11
operator|^
name|D1
operator|)
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|B3
operator|=
name|ROL64
argument_list|(
operator|(
name|A32
operator|^
name|D2
operator|)
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|B4
operator|=
name|ROL64
argument_list|(
operator|(
name|A03
operator|^
name|D3
operator|)
argument_list|,
literal|56
argument_list|)
expr_stmt|;
name|B0
operator|=
name|ROL64
argument_list|(
operator|(
name|A24
operator|^
name|D4
operator|)
argument_list|,
literal|27
argument_list|)
expr_stmt|;
name|A40
operator|=
name|B0
operator|^
operator|(
operator|(
operator|~
name|B1
operator|)
operator|&
name|B2
operator|)
expr_stmt|;
name|A11
operator|=
name|B1
operator|^
operator|(
operator|(
operator|~
name|B2
operator|)
operator|&
name|B3
operator|)
expr_stmt|;
name|A32
operator|=
name|B2
operator|^
operator|(
operator|(
operator|~
name|B3
operator|)
operator|&
name|B4
operator|)
expr_stmt|;
name|A03
operator|=
name|B3
operator|^
operator|(
operator|(
operator|~
name|B4
operator|)
operator|&
name|B0
operator|)
expr_stmt|;
name|A24
operator|=
name|B4
operator|^
operator|(
operator|(
operator|~
name|B0
operator|)
operator|&
name|B1
operator|)
expr_stmt|;
name|B3
operator|=
name|ROL64
argument_list|(
operator|(
name|A20
operator|^
name|D0
operator|)
argument_list|,
literal|41
argument_list|)
expr_stmt|;
name|B4
operator|=
name|ROL64
argument_list|(
operator|(
name|A41
operator|^
name|D1
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|B0
operator|=
name|ROL64
argument_list|(
operator|(
name|A12
operator|^
name|D2
operator|)
argument_list|,
literal|62
argument_list|)
expr_stmt|;
name|B1
operator|=
name|ROL64
argument_list|(
operator|(
name|A33
operator|^
name|D3
operator|)
argument_list|,
literal|55
argument_list|)
expr_stmt|;
name|B2
operator|=
name|ROL64
argument_list|(
operator|(
name|A04
operator|^
name|D4
operator|)
argument_list|,
literal|39
argument_list|)
expr_stmt|;
name|A20
operator|=
name|B0
operator|^
operator|(
operator|(
operator|~
name|B1
operator|)
operator|&
name|B2
operator|)
expr_stmt|;
name|A41
operator|=
name|B1
operator|^
operator|(
operator|(
operator|~
name|B2
operator|)
operator|&
name|B3
operator|)
expr_stmt|;
name|A12
operator|=
name|B2
operator|^
operator|(
operator|(
operator|~
name|B3
operator|)
operator|&
name|B4
operator|)
expr_stmt|;
name|A33
operator|=
name|B3
operator|^
operator|(
operator|(
operator|~
name|B4
operator|)
operator|&
name|B0
operator|)
expr_stmt|;
name|A04
operator|=
name|B4
operator|^
operator|(
operator|(
operator|~
name|B0
operator|)
operator|&
name|B1
operator|)
expr_stmt|;
name|C0
operator|=
name|A00
operator|^
name|A30
operator|^
name|A10
operator|^
name|A40
operator|^
name|A20
expr_stmt|;
name|C1
operator|=
name|A21
operator|^
name|A01
operator|^
name|A31
operator|^
name|A11
operator|^
name|A41
expr_stmt|;
name|C2
operator|=
name|A42
operator|^
name|A22
operator|^
name|A02
operator|^
name|A32
operator|^
name|A12
expr_stmt|;
name|C3
operator|=
name|A13
operator|^
name|A43
operator|^
name|A23
operator|^
name|A03
operator|^
name|A33
expr_stmt|;
name|C4
operator|=
name|A34
operator|^
name|A14
operator|^
name|A44
operator|^
name|A24
operator|^
name|A04
expr_stmt|;
name|D0
operator|=
name|C4
operator|^
name|ROL64
argument_list|(
name|C1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|D1
operator|=
name|C0
operator|^
name|ROL64
argument_list|(
name|C2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|D2
operator|=
name|C1
operator|^
name|ROL64
argument_list|(
name|C3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|D3
operator|=
name|C2
operator|^
name|ROL64
argument_list|(
name|C4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|D4
operator|=
name|C3
operator|^
name|ROL64
argument_list|(
name|C0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|B0
operator|=
operator|(
name|A00
operator|^
name|D0
operator|)
expr_stmt|;
name|B1
operator|=
name|ROL64
argument_list|(
operator|(
name|A01
operator|^
name|D1
operator|)
argument_list|,
literal|44
argument_list|)
expr_stmt|;
name|B2
operator|=
name|ROL64
argument_list|(
operator|(
name|A02
operator|^
name|D2
operator|)
argument_list|,
literal|43
argument_list|)
expr_stmt|;
name|B3
operator|=
name|ROL64
argument_list|(
operator|(
name|A03
operator|^
name|D3
operator|)
argument_list|,
literal|21
argument_list|)
expr_stmt|;
name|B4
operator|=
name|ROL64
argument_list|(
operator|(
name|A04
operator|^
name|D4
operator|)
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|A00
operator|=
name|B0
operator|^
operator|(
operator|(
operator|~
name|B1
operator|)
operator|&
name|B2
operator|)
expr_stmt|;
name|A00
operator|^=
name|RC
index|[
name|i
operator|+
literal|3
index|]
expr_stmt|;
name|A01
operator|=
name|B1
operator|^
operator|(
operator|(
operator|~
name|B2
operator|)
operator|&
name|B3
operator|)
expr_stmt|;
name|A02
operator|=
name|B2
operator|^
operator|(
operator|(
operator|~
name|B3
operator|)
operator|&
name|B4
operator|)
expr_stmt|;
name|A03
operator|=
name|B3
operator|^
operator|(
operator|(
operator|~
name|B4
operator|)
operator|&
name|B0
operator|)
expr_stmt|;
name|A04
operator|=
name|B4
operator|^
operator|(
operator|(
operator|~
name|B0
operator|)
operator|&
name|B1
operator|)
expr_stmt|;
name|B2
operator|=
name|ROL64
argument_list|(
operator|(
name|A10
operator|^
name|D0
operator|)
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|B3
operator|=
name|ROL64
argument_list|(
operator|(
name|A11
operator|^
name|D1
operator|)
argument_list|,
literal|45
argument_list|)
expr_stmt|;
name|B4
operator|=
name|ROL64
argument_list|(
operator|(
name|A12
operator|^
name|D2
operator|)
argument_list|,
literal|61
argument_list|)
expr_stmt|;
name|B0
operator|=
name|ROL64
argument_list|(
operator|(
name|A13
operator|^
name|D3
operator|)
argument_list|,
literal|28
argument_list|)
expr_stmt|;
name|B1
operator|=
name|ROL64
argument_list|(
operator|(
name|A14
operator|^
name|D4
operator|)
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|A10
operator|=
name|B0
operator|^
operator|(
operator|(
operator|~
name|B1
operator|)
operator|&
name|B2
operator|)
expr_stmt|;
name|A11
operator|=
name|B1
operator|^
operator|(
operator|(
operator|~
name|B2
operator|)
operator|&
name|B3
operator|)
expr_stmt|;
name|A12
operator|=
name|B2
operator|^
operator|(
operator|(
operator|~
name|B3
operator|)
operator|&
name|B4
operator|)
expr_stmt|;
name|A13
operator|=
name|B3
operator|^
operator|(
operator|(
operator|~
name|B4
operator|)
operator|&
name|B0
operator|)
expr_stmt|;
name|A14
operator|=
name|B4
operator|^
operator|(
operator|(
operator|~
name|B0
operator|)
operator|&
name|B1
operator|)
expr_stmt|;
name|B4
operator|=
name|ROL64
argument_list|(
operator|(
name|A20
operator|^
name|D0
operator|)
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|B0
operator|=
name|ROL64
argument_list|(
operator|(
name|A21
operator|^
name|D1
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|B1
operator|=
name|ROL64
argument_list|(
operator|(
name|A22
operator|^
name|D2
operator|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|B2
operator|=
name|ROL64
argument_list|(
operator|(
name|A23
operator|^
name|D3
operator|)
argument_list|,
literal|25
argument_list|)
expr_stmt|;
name|B3
operator|=
name|ROL64
argument_list|(
operator|(
name|A24
operator|^
name|D4
operator|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|A20
operator|=
name|B0
operator|^
operator|(
operator|(
operator|~
name|B1
operator|)
operator|&
name|B2
operator|)
expr_stmt|;
name|A21
operator|=
name|B1
operator|^
operator|(
operator|(
operator|~
name|B2
operator|)
operator|&
name|B3
operator|)
expr_stmt|;
name|A22
operator|=
name|B2
operator|^
operator|(
operator|(
operator|~
name|B3
operator|)
operator|&
name|B4
operator|)
expr_stmt|;
name|A23
operator|=
name|B3
operator|^
operator|(
operator|(
operator|~
name|B4
operator|)
operator|&
name|B0
operator|)
expr_stmt|;
name|A24
operator|=
name|B4
operator|^
operator|(
operator|(
operator|~
name|B0
operator|)
operator|&
name|B1
operator|)
expr_stmt|;
name|B1
operator|=
name|ROL64
argument_list|(
operator|(
name|A30
operator|^
name|D0
operator|)
argument_list|,
literal|36
argument_list|)
expr_stmt|;
name|B2
operator|=
name|ROL64
argument_list|(
operator|(
name|A31
operator|^
name|D1
operator|)
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|B3
operator|=
name|ROL64
argument_list|(
operator|(
name|A32
operator|^
name|D2
operator|)
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|B4
operator|=
name|ROL64
argument_list|(
operator|(
name|A33
operator|^
name|D3
operator|)
argument_list|,
literal|56
argument_list|)
expr_stmt|;
name|B0
operator|=
name|ROL64
argument_list|(
operator|(
name|A34
operator|^
name|D4
operator|)
argument_list|,
literal|27
argument_list|)
expr_stmt|;
name|A30
operator|=
name|B0
operator|^
operator|(
operator|(
operator|~
name|B1
operator|)
operator|&
name|B2
operator|)
expr_stmt|;
name|A31
operator|=
name|B1
operator|^
operator|(
operator|(
operator|~
name|B2
operator|)
operator|&
name|B3
operator|)
expr_stmt|;
name|A32
operator|=
name|B2
operator|^
operator|(
operator|(
operator|~
name|B3
operator|)
operator|&
name|B4
operator|)
expr_stmt|;
name|A33
operator|=
name|B3
operator|^
operator|(
operator|(
operator|~
name|B4
operator|)
operator|&
name|B0
operator|)
expr_stmt|;
name|A34
operator|=
name|B4
operator|^
operator|(
operator|(
operator|~
name|B0
operator|)
operator|&
name|B1
operator|)
expr_stmt|;
name|B3
operator|=
name|ROL64
argument_list|(
operator|(
name|A40
operator|^
name|D0
operator|)
argument_list|,
literal|41
argument_list|)
expr_stmt|;
name|B4
operator|=
name|ROL64
argument_list|(
operator|(
name|A41
operator|^
name|D1
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|B0
operator|=
name|ROL64
argument_list|(
operator|(
name|A42
operator|^
name|D2
operator|)
argument_list|,
literal|62
argument_list|)
expr_stmt|;
name|B1
operator|=
name|ROL64
argument_list|(
operator|(
name|A43
operator|^
name|D3
operator|)
argument_list|,
literal|55
argument_list|)
expr_stmt|;
name|B2
operator|=
name|ROL64
argument_list|(
operator|(
name|A44
operator|^
name|D4
operator|)
argument_list|,
literal|39
argument_list|)
expr_stmt|;
name|A40
operator|=
name|B0
operator|^
operator|(
operator|(
operator|~
name|B1
operator|)
operator|&
name|B2
operator|)
expr_stmt|;
name|A41
operator|=
name|B1
operator|^
operator|(
operator|(
operator|~
name|B2
operator|)
operator|&
name|B3
operator|)
expr_stmt|;
name|A42
operator|=
name|B2
operator|^
operator|(
operator|(
operator|~
name|B3
operator|)
operator|&
name|B4
operator|)
expr_stmt|;
name|A43
operator|=
name|B3
operator|^
operator|(
operator|(
operator|~
name|B4
operator|)
operator|&
name|B0
operator|)
expr_stmt|;
name|A44
operator|=
name|B4
operator|^
operator|(
operator|(
operator|~
name|B0
operator|)
operator|&
name|B1
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** Initialize a new hash.  iSize determines the size of the hash ** in bits and should be one of 224, 256, 384, or 512.  Or iSize ** can be zero to use the default hash size of 256 bits. */
end_comment

begin_function
specifier|static
name|void
name|SHA3Init
parameter_list|(
name|SHA3Context
modifier|*
name|p
parameter_list|,
name|int
name|iSize
parameter_list|)
block|{
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iSize
operator|>=
literal|128
operator|&&
name|iSize
operator|<=
literal|512
condition|)
block|{
name|p
operator|->
name|nRate
operator|=
operator|(
literal|1600
operator|-
operator|(
operator|(
name|iSize
operator|+
literal|31
operator|)
operator|&
operator|~
literal|31
operator|)
operator|*
literal|2
operator|)
operator|/
literal|8
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|nRate
operator|=
operator|(
literal|1600
operator|-
literal|2
operator|*
literal|256
operator|)
operator|/
literal|8
expr_stmt|;
block|}
if|#
directive|if
name|SHA3_BYTEORDER
operator|==
literal|1234
comment|/* Known to be little-endian at compile-time. No-op */
elif|#
directive|elif
name|SHA3_BYTEORDER
operator|==
literal|4321
name|p
operator|->
name|ixMask
operator|=
literal|7
expr_stmt|;
comment|/* Big-endian */
else|#
directive|else
block|{
specifier|static
name|unsigned
name|int
name|one
init|=
literal|1
decl_stmt|;
if|if
condition|(
literal|1
operator|==
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|one
condition|)
block|{
comment|/* Little endian.  No byte swapping. */
name|p
operator|->
name|ixMask
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Big endian.  Byte swap. */
name|p
operator|->
name|ixMask
operator|=
literal|7
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ** Make consecutive calls to the SHA3Update function to add new content ** to the hash */
end_comment

begin_function
specifier|static
name|void
name|SHA3Update
parameter_list|(
name|SHA3Context
modifier|*
name|p
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|aData
parameter_list|,
name|unsigned
name|int
name|nData
parameter_list|)
block|{
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|SHA3_BYTEORDER
operator|==
literal|1234
if|if
condition|(
operator|(
name|p
operator|->
name|nLoaded
operator|%
literal|8
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|aData
operator|-
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
literal|0
operator|)
operator|&
literal|7
operator|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
init|;
name|i
operator|+
literal|7
operator|<
name|nData
condition|;
name|i
operator|+=
literal|8
control|)
block|{
name|p
operator|->
name|u
operator|.
name|s
index|[
name|p
operator|->
name|nLoaded
operator|/
literal|8
index|]
operator|^=
operator|*
operator|(
name|u64
operator|*
operator|)
operator|&
name|aData
index|[
name|i
index|]
expr_stmt|;
name|p
operator|->
name|nLoaded
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|nLoaded
operator|>=
name|p
operator|->
name|nRate
condition|)
block|{
name|KeccakF1600Step
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|nLoaded
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
for|for
control|(
init|;
name|i
operator|<
name|nData
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
name|SHA3_BYTEORDER
operator|==
literal|1234
name|p
operator|->
name|u
operator|.
name|x
index|[
name|p
operator|->
name|nLoaded
index|]
operator|^=
name|aData
index|[
name|i
index|]
expr_stmt|;
elif|#
directive|elif
name|SHA3_BYTEORDER
operator|==
literal|4321
name|p
operator|->
name|u
operator|.
name|x
index|[
name|p
operator|->
name|nLoaded
operator|^
literal|0x07
index|]
operator|^=
name|aData
index|[
name|i
index|]
expr_stmt|;
else|#
directive|else
name|p
operator|->
name|u
operator|.
name|x
index|[
name|p
operator|->
name|nLoaded
operator|^
name|p
operator|->
name|ixMask
index|]
operator|^=
name|aData
index|[
name|i
index|]
expr_stmt|;
endif|#
directive|endif
name|p
operator|->
name|nLoaded
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|nLoaded
operator|==
name|p
operator|->
name|nRate
condition|)
block|{
name|KeccakF1600Step
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|nLoaded
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ** After all content has been added, invoke SHA3Final() to compute ** the final hash.  The function returns a pointer to the binary ** hash value. */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|SHA3Final
parameter_list|(
name|SHA3Context
modifier|*
name|p
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|nLoaded
operator|==
name|p
operator|->
name|nRate
operator|-
literal|1
condition|)
block|{
specifier|const
name|unsigned
name|char
name|c1
init|=
literal|0x86
decl_stmt|;
name|SHA3Update
argument_list|(
name|p
argument_list|,
operator|&
name|c1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|unsigned
name|char
name|c2
init|=
literal|0x06
decl_stmt|;
specifier|const
name|unsigned
name|char
name|c3
init|=
literal|0x80
decl_stmt|;
name|SHA3Update
argument_list|(
name|p
argument_list|,
operator|&
name|c2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p
operator|->
name|nLoaded
operator|=
name|p
operator|->
name|nRate
operator|-
literal|1
expr_stmt|;
name|SHA3Update
argument_list|(
name|p
argument_list|,
operator|&
name|c3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|nRate
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|->
name|u
operator|.
name|x
index|[
name|i
operator|+
name|p
operator|->
name|nRate
index|]
operator|=
name|p
operator|->
name|u
operator|.
name|x
index|[
name|i
operator|^
name|p
operator|->
name|ixMask
index|]
expr_stmt|;
block|}
return|return
operator|&
name|p
operator|->
name|u
operator|.
name|x
index|[
name|p
operator|->
name|nRate
index|]
return|;
block|}
end_function

begin_comment
comment|/* End of the hashing logic *****************************************************************************/
end_comment

begin_comment
comment|/* ** Implementation of the sha3(X,SIZE) function. ** ** Return a BLOB which is the SIZE-bit SHA3 hash of X.  The default ** size is 256.  If X is a BLOB, it is hashed as is.   ** For all other non-NULL types of input, X is converted into a UTF-8 string ** and the string is hashed without the trailing 0x00 terminator.  The hash ** of a NULL value is NULL. */
end_comment

begin_function
specifier|static
name|void
name|sha3Func
parameter_list|(
name|sqlite3_context
modifier|*
name|context
parameter_list|,
name|int
name|argc
parameter_list|,
name|sqlite3_value
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|SHA3Context
name|cx
decl_stmt|;
name|int
name|eType
init|=
name|sqlite3_value_type
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|nByte
init|=
name|sqlite3_value_bytes
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|iSize
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|iSize
operator|=
literal|256
expr_stmt|;
block|}
else|else
block|{
name|iSize
operator|=
name|sqlite3_value_int
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|iSize
operator|!=
literal|224
operator|&&
name|iSize
operator|!=
literal|256
operator|&&
name|iSize
operator|!=
literal|384
operator|&&
name|iSize
operator|!=
literal|512
condition|)
block|{
name|sqlite3_result_error
argument_list|(
name|context
argument_list|,
literal|"SHA3 size should be one of: 224 256 "
literal|"384 512"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|eType
operator|==
name|SQLITE_NULL
condition|)
return|return;
name|SHA3Init
argument_list|(
operator|&
name|cx
argument_list|,
name|iSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|eType
operator|==
name|SQLITE_BLOB
condition|)
block|{
name|SHA3Update
argument_list|(
operator|&
name|cx
argument_list|,
name|sqlite3_value_blob
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|nByte
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SHA3Update
argument_list|(
operator|&
name|cx
argument_list|,
name|sqlite3_value_text
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|nByte
argument_list|)
expr_stmt|;
block|}
name|sqlite3_result_blob
argument_list|(
name|context
argument_list|,
name|SHA3Final
argument_list|(
operator|&
name|cx
argument_list|)
argument_list|,
name|iSize
operator|/
literal|8
argument_list|,
name|SQLITE_TRANSIENT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute a string using sqlite3_vsnprintf() with a maximum length ** of 50 bytes and add it to the hash. */
end_comment

begin_function
specifier|static
name|void
name|hash_step_vformat
parameter_list|(
name|SHA3Context
modifier|*
name|p
parameter_list|,
comment|/* Add content to this context */
specifier|const
name|char
modifier|*
name|zFormat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
name|zBuf
index|[
literal|50
index|]
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|zFormat
argument_list|)
expr_stmt|;
name|sqlite3_vsnprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|zBuf
argument_list|)
argument_list|,
name|zBuf
argument_list|,
name|zFormat
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|zBuf
argument_list|)
expr_stmt|;
name|SHA3Update
argument_list|(
name|p
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|zBuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Implementation of the sha3_query(SQL,SIZE) function. ** ** This function compiles and runs the SQL statement(s) given in the ** argument. The results are hashed using a SIZE-bit SHA3.  The default ** size is 256. ** ** The format of the byte stream that is hashed is summarized as follows: ** **       S<n>:<sql> **       R **       N **       I<int> **       F<ieee-float> **       B<size>:<bytes> **       T<size>:<text> ** **<sql> is the original SQL text for each statement run and<n> is ** the size of that text.  The SQL text is UTF-8.  A single R character ** occurs before the start of each row.  N means a NULL value. ** I mean an 8-byte little-endian integer<int>.  F is a floating point ** number with an 8-byte little-endian IEEE floating point value<ieee-float>. ** B means blobs of<size> bytes.  T means text rendered as<size> ** bytes of UTF-8.  The<n> and<size> values are expressed as an ASCII ** text integers. ** ** For each SQL statement in the X input, there is one S segment.  Each ** S segment is followed by zero or more R segments, one for each row in the ** result set.  After each R, there are one or more N, I, F, B, or T segments, ** one for each column in the result set.  Segments are concatentated directly ** with no delimiters of any kind. */
end_comment

begin_function
specifier|static
name|void
name|sha3QueryFunc
parameter_list|(
name|sqlite3_context
modifier|*
name|context
parameter_list|,
name|int
name|argc
parameter_list|,
name|sqlite3_value
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|sqlite3
modifier|*
name|db
init|=
name|sqlite3_context_db_handle
argument_list|(
name|context
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|zSql
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_value_text
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|sqlite3_stmt
modifier|*
name|pStmt
init|=
literal|0
decl_stmt|;
name|int
name|nCol
decl_stmt|;
comment|/* Number of columns in the result set */
name|int
name|i
decl_stmt|;
comment|/* Loop counter */
name|int
name|rc
decl_stmt|;
name|int
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
name|SHA3Context
name|cx
decl_stmt|;
name|int
name|iSize
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|iSize
operator|=
literal|256
expr_stmt|;
block|}
else|else
block|{
name|iSize
operator|=
name|sqlite3_value_int
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|iSize
operator|!=
literal|224
operator|&&
name|iSize
operator|!=
literal|256
operator|&&
name|iSize
operator|!=
literal|384
operator|&&
name|iSize
operator|!=
literal|512
condition|)
block|{
name|sqlite3_result_error
argument_list|(
name|context
argument_list|,
literal|"SHA3 size should be one of: 224 256 "
literal|"384 512"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|zSql
operator|==
literal|0
condition|)
return|return;
name|SHA3Init
argument_list|(
operator|&
name|cx
argument_list|,
name|iSize
argument_list|)
expr_stmt|;
while|while
condition|(
name|zSql
index|[
literal|0
index|]
condition|)
block|{
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|db
argument_list|,
name|zSql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pStmt
argument_list|,
operator|&
name|zSql
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|char
modifier|*
name|zMsg
init|=
name|sqlite3_mprintf
argument_list|(
literal|"error SQL statement [%s]: %s"
argument_list|,
name|zSql
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|db
argument_list|)
argument_list|)
decl_stmt|;
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|sqlite3_result_error
argument_list|(
name|context
argument_list|,
name|zMsg
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zMsg
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|sqlite3_stmt_readonly
argument_list|(
name|pStmt
argument_list|)
condition|)
block|{
name|char
modifier|*
name|zMsg
init|=
name|sqlite3_mprintf
argument_list|(
literal|"non-query: [%s]"
argument_list|,
name|sqlite3_sql
argument_list|(
name|pStmt
argument_list|)
argument_list|)
decl_stmt|;
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|sqlite3_result_error
argument_list|(
name|context
argument_list|,
name|zMsg
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zMsg
argument_list|)
expr_stmt|;
return|return;
block|}
name|nCol
operator|=
name|sqlite3_column_count
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|z
operator|=
name|sqlite3_sql
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|hash_step_vformat
argument_list|(
operator|&
name|cx
argument_list|,
literal|"S%d:"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|SHA3Update
argument_list|(
operator|&
name|cx
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|z
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* Compute a hash over the result of the query */
while|while
condition|(
name|SQLITE_ROW
operator|==
name|sqlite3_step
argument_list|(
name|pStmt
argument_list|)
condition|)
block|{
name|SHA3Update
argument_list|(
operator|&
name|cx
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
literal|"R"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nCol
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|sqlite3_column_type
argument_list|(
name|pStmt
argument_list|,
name|i
argument_list|)
condition|)
block|{
case|case
name|SQLITE_NULL
case|:
block|{
name|SHA3Update
argument_list|(
operator|&
name|cx
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
literal|"N"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SQLITE_INTEGER
case|:
block|{
name|sqlite3_uint64
name|u
decl_stmt|;
name|int
name|j
decl_stmt|;
name|unsigned
name|char
name|x
index|[
literal|9
index|]
decl_stmt|;
name|sqlite3_int64
name|v
init|=
name|sqlite3_column_int64
argument_list|(
name|pStmt
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|u
argument_list|,
operator|&
name|v
argument_list|,
literal|8
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|8
init|;
name|j
operator|>=
literal|1
condition|;
name|j
operator|--
control|)
block|{
name|x
index|[
name|j
index|]
operator|=
name|u
operator|&
literal|0xff
expr_stmt|;
name|u
operator|>>=
literal|8
expr_stmt|;
block|}
name|x
index|[
literal|0
index|]
operator|=
literal|'I'
expr_stmt|;
name|SHA3Update
argument_list|(
operator|&
name|cx
argument_list|,
name|x
argument_list|,
literal|9
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SQLITE_FLOAT
case|:
block|{
name|sqlite3_uint64
name|u
decl_stmt|;
name|int
name|j
decl_stmt|;
name|unsigned
name|char
name|x
index|[
literal|9
index|]
decl_stmt|;
name|double
name|r
init|=
name|sqlite3_column_double
argument_list|(
name|pStmt
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|u
argument_list|,
operator|&
name|r
argument_list|,
literal|8
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|8
init|;
name|j
operator|>=
literal|1
condition|;
name|j
operator|--
control|)
block|{
name|x
index|[
name|j
index|]
operator|=
name|u
operator|&
literal|0xff
expr_stmt|;
name|u
operator|>>=
literal|8
expr_stmt|;
block|}
name|x
index|[
literal|0
index|]
operator|=
literal|'F'
expr_stmt|;
name|SHA3Update
argument_list|(
operator|&
name|cx
argument_list|,
name|x
argument_list|,
literal|9
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SQLITE_TEXT
case|:
block|{
name|int
name|n2
init|=
name|sqlite3_column_bytes
argument_list|(
name|pStmt
argument_list|,
name|i
argument_list|)
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|z2
init|=
name|sqlite3_column_text
argument_list|(
name|pStmt
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|hash_step_vformat
argument_list|(
operator|&
name|cx
argument_list|,
literal|"T%d:"
argument_list|,
name|n2
argument_list|)
expr_stmt|;
name|SHA3Update
argument_list|(
operator|&
name|cx
argument_list|,
name|z2
argument_list|,
name|n2
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SQLITE_BLOB
case|:
block|{
name|int
name|n2
init|=
name|sqlite3_column_bytes
argument_list|(
name|pStmt
argument_list|,
name|i
argument_list|)
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|z2
init|=
name|sqlite3_column_blob
argument_list|(
name|pStmt
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|hash_step_vformat
argument_list|(
operator|&
name|cx
argument_list|,
literal|"B%d:"
argument_list|,
name|n2
argument_list|)
expr_stmt|;
name|SHA3Update
argument_list|(
operator|&
name|cx
argument_list|,
name|z2
argument_list|,
name|n2
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
block|}
name|sqlite3_result_blob
argument_list|(
name|context
argument_list|,
name|SHA3Final
argument_list|(
operator|&
name|cx
argument_list|)
argument_list|,
name|iSize
operator|/
literal|8
argument_list|,
name|SQLITE_TRANSIENT
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_macro
name|__declspec
argument_list|(
argument|dllexport
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|sqlite3_shathree_init
parameter_list|(
name|sqlite3
modifier|*
name|db
parameter_list|,
name|char
modifier|*
modifier|*
name|pzErrMsg
parameter_list|,
specifier|const
name|sqlite3_api_routines
modifier|*
name|pApi
parameter_list|)
block|{
name|int
name|rc
init|=
name|SQLITE_OK
decl_stmt|;
name|SQLITE_EXTENSION_INIT2
argument_list|(
name|pApi
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pzErrMsg
expr_stmt|;
comment|/* Unused parameter */
name|rc
operator|=
name|sqlite3_create_function
argument_list|(
name|db
argument_list|,
literal|"sha3"
argument_list|,
literal|1
argument_list|,
name|SQLITE_UTF8
argument_list|,
literal|0
argument_list|,
name|sha3Func
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|SQLITE_OK
condition|)
block|{
name|rc
operator|=
name|sqlite3_create_function
argument_list|(
name|db
argument_list|,
literal|"sha3"
argument_list|,
literal|2
argument_list|,
name|SQLITE_UTF8
argument_list|,
literal|0
argument_list|,
name|sha3Func
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|==
name|SQLITE_OK
condition|)
block|{
name|rc
operator|=
name|sqlite3_create_function
argument_list|(
name|db
argument_list|,
literal|"sha3_query"
argument_list|,
literal|1
argument_list|,
name|SQLITE_UTF8
argument_list|,
literal|0
argument_list|,
name|sha3QueryFunc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|==
name|SQLITE_OK
condition|)
block|{
name|rc
operator|=
name|sqlite3_create_function
argument_list|(
name|db
argument_list|,
literal|"sha3_query"
argument_list|,
literal|2
argument_list|,
name|SQLITE_UTF8
argument_list|,
literal|0
argument_list|,
name|sha3QueryFunc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/************************* End ../ext/misc/shathree.c ********************/
end_comment

begin_comment
comment|/************************* Begin ../ext/misc/fileio.c ******************/
end_comment

begin_comment
comment|/* ** 2014-06-13 ** ** The author disclaims copyright to this source code.  In place of ** a legal notice, here is a blessing: ** **    May you do good and not evil. **    May you find forgiveness for yourself and forgive others. **    May you share freely, never taking more than you give. ** ****************************************************************************** ** ** This SQLite extension implements SQL functions readfile() and ** writefile(). */
end_comment

begin_function
name|SQLITE_EXTENSION_INIT1
include|#
directive|include
file|<stdio.h>
comment|/* ** Implementation of the "readfile(X)" SQL function.  The entire content ** of the file named X is read and returned as a BLOB.  NULL is returned ** if the file does not exist or is unreadable. */
specifier|static
name|void
name|readfileFunc
parameter_list|(
name|sqlite3_context
modifier|*
name|context
parameter_list|,
name|int
name|argc
parameter_list|,
name|sqlite3_value
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|zName
decl_stmt|;
name|FILE
modifier|*
name|in
decl_stmt|;
name|long
name|nIn
decl_stmt|;
name|void
modifier|*
name|pBuf
decl_stmt|;
call|(
name|void
call|)
argument_list|(
name|argc
argument_list|)
expr_stmt|;
comment|/* Unused parameter */
name|zName
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_value_text
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|zName
operator|==
literal|0
condition|)
return|return;
name|in
operator|=
name|fopen
argument_list|(
name|zName
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
literal|0
condition|)
return|return;
name|fseek
argument_list|(
name|in
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
name|nIn
operator|=
name|ftell
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|rewind
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|pBuf
operator|=
name|sqlite3_malloc
argument_list|(
name|nIn
argument_list|)
expr_stmt|;
if|if
condition|(
name|pBuf
operator|&&
literal|1
operator|==
name|fread
argument_list|(
name|pBuf
argument_list|,
name|nIn
argument_list|,
literal|1
argument_list|,
name|in
argument_list|)
condition|)
block|{
name|sqlite3_result_blob
argument_list|(
name|context
argument_list|,
name|pBuf
argument_list|,
name|nIn
argument_list|,
name|sqlite3_free
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sqlite3_free
argument_list|(
name|pBuf
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Implementation of the "writefile(X,Y)" SQL function.  The argument Y ** is written into file X.  The number of bytes written is returned.  Or ** NULL is returned if something goes wrong, such as being unable to open ** file X for writing. */
end_comment

begin_function
specifier|static
name|void
name|writefileFunc
parameter_list|(
name|sqlite3_context
modifier|*
name|context
parameter_list|,
name|int
name|argc
parameter_list|,
name|sqlite3_value
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|FILE
modifier|*
name|out
decl_stmt|;
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
name|sqlite3_int64
name|rc
decl_stmt|;
specifier|const
name|char
modifier|*
name|zFile
decl_stmt|;
call|(
name|void
call|)
argument_list|(
name|argc
argument_list|)
expr_stmt|;
comment|/* Unused parameter */
name|zFile
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_value_text
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|zFile
operator|==
literal|0
condition|)
return|return;
name|out
operator|=
name|fopen
argument_list|(
name|zFile
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
literal|0
condition|)
return|return;
name|z
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_value_blob
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|fwrite
argument_list|(
name|z
argument_list|,
literal|1
argument_list|,
name|sqlite3_value_bytes
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|sqlite3_result_int64
argument_list|(
name|context
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_macro
name|__declspec
argument_list|(
argument|dllexport
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|sqlite3_fileio_init
parameter_list|(
name|sqlite3
modifier|*
name|db
parameter_list|,
name|char
modifier|*
modifier|*
name|pzErrMsg
parameter_list|,
specifier|const
name|sqlite3_api_routines
modifier|*
name|pApi
parameter_list|)
block|{
name|int
name|rc
init|=
name|SQLITE_OK
decl_stmt|;
name|SQLITE_EXTENSION_INIT2
argument_list|(
name|pApi
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pzErrMsg
expr_stmt|;
comment|/* Unused parameter */
name|rc
operator|=
name|sqlite3_create_function
argument_list|(
name|db
argument_list|,
literal|"readfile"
argument_list|,
literal|1
argument_list|,
name|SQLITE_UTF8
argument_list|,
literal|0
argument_list|,
name|readfileFunc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|SQLITE_OK
condition|)
block|{
name|rc
operator|=
name|sqlite3_create_function
argument_list|(
name|db
argument_list|,
literal|"writefile"
argument_list|,
literal|2
argument_list|,
name|SQLITE_UTF8
argument_list|,
literal|0
argument_list|,
name|writefileFunc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/************************* End ../ext/misc/fileio.c ********************/
end_comment

begin_comment
comment|/************************* Begin ../ext/misc/completion.c ******************/
end_comment

begin_comment
comment|/* ** 2017-07-10 ** ** The author disclaims copyright to this source code.  In place of ** a legal notice, here is a blessing: ** **    May you do good and not evil. **    May you find forgiveness for yourself and forgive others. **    May you share freely, never taking more than you give. ** ************************************************************************* ** ** This file implements an eponymous virtual table that returns suggested ** completions for a partial SQL input. ** ** Suggested usage: ** **     SELECT DISTINCT candidate COLLATE nocase **       FROM completion($prefix,$wholeline) **      ORDER BY 1; ** ** The two query parameters are optional.  $prefix is the text of the ** current word being typed and that is to be completed.  $wholeline is ** the complete input line, used for context. ** ** The raw completion() table might return the same candidate multiple ** times, for example if the same column name is used to two or more ** tables.  And the candidates are returned in an arbitrary order.  Hence, ** the DISTINCT and ORDER BY are recommended. ** ** This virtual table operates at the speed of human typing, and so there ** is no attempt to make it fast.  Even a slow implementation will be much ** faster than any human can type. ** */
end_comment

begin_macro
name|SQLITE_EXTENSION_INIT1
end_macro

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SQLITE_OMIT_VIRTUALTABLE
end_ifndef

begin_comment
comment|/* completion_vtab is a subclass of sqlite3_vtab which will ** serve as the underlying representation of a completion virtual table */
end_comment

begin_typedef
typedef|typedef
name|struct
name|completion_vtab
name|completion_vtab
typedef|;
end_typedef

begin_struct
struct|struct
name|completion_vtab
block|{
name|sqlite3_vtab
name|base
decl_stmt|;
comment|/* Base class - must be first */
name|sqlite3
modifier|*
name|db
decl_stmt|;
comment|/* Database connection for this completion vtab */
block|}
struct|;
end_struct

begin_comment
comment|/* completion_cursor is a subclass of sqlite3_vtab_cursor which will ** serve as the underlying representation of a cursor that scans ** over rows of the result */
end_comment

begin_typedef
typedef|typedef
name|struct
name|completion_cursor
name|completion_cursor
typedef|;
end_typedef

begin_struct
struct|struct
name|completion_cursor
block|{
name|sqlite3_vtab_cursor
name|base
decl_stmt|;
comment|/* Base class - must be first */
name|sqlite3
modifier|*
name|db
decl_stmt|;
comment|/* Database connection for this cursor */
name|int
name|nPrefix
decl_stmt|,
name|nLine
decl_stmt|;
comment|/* Number of bytes in zPrefix and zLine */
name|char
modifier|*
name|zPrefix
decl_stmt|;
comment|/* The prefix for the word we want to complete */
name|char
modifier|*
name|zLine
decl_stmt|;
comment|/* The whole that we want to complete */
specifier|const
name|char
modifier|*
name|zCurrentRow
decl_stmt|;
comment|/* Current output row */
name|sqlite3_stmt
modifier|*
name|pStmt
decl_stmt|;
comment|/* Current statement */
name|sqlite3_int64
name|iRowid
decl_stmt|;
comment|/* The rowid */
name|int
name|ePhase
decl_stmt|;
comment|/* Current phase */
name|int
name|j
decl_stmt|;
comment|/* inter-phase counter */
block|}
struct|;
end_struct

begin_comment
comment|/* Values for ePhase: */
end_comment

begin_define
define|#
directive|define
name|COMPLETION_FIRST_PHASE
value|1
end_define

begin_define
define|#
directive|define
name|COMPLETION_KEYWORDS
value|1
end_define

begin_define
define|#
directive|define
name|COMPLETION_PRAGMAS
value|2
end_define

begin_define
define|#
directive|define
name|COMPLETION_FUNCTIONS
value|3
end_define

begin_define
define|#
directive|define
name|COMPLETION_COLLATIONS
value|4
end_define

begin_define
define|#
directive|define
name|COMPLETION_INDEXES
value|5
end_define

begin_define
define|#
directive|define
name|COMPLETION_TRIGGERS
value|6
end_define

begin_define
define|#
directive|define
name|COMPLETION_DATABASES
value|7
end_define

begin_define
define|#
directive|define
name|COMPLETION_TABLES
value|8
end_define

begin_define
define|#
directive|define
name|COMPLETION_COLUMNS
value|9
end_define

begin_define
define|#
directive|define
name|COMPLETION_MODULES
value|10
end_define

begin_define
define|#
directive|define
name|COMPLETION_EOF
value|11
end_define

begin_comment
comment|/* ** The completionConnect() method is invoked to create a new ** completion_vtab that describes the completion virtual table. ** ** Think of this routine as the constructor for completion_vtab objects. ** ** All this routine needs to do is: ** **    (1) Allocate the completion_vtab object and initialize all fields. ** **    (2) Tell SQLite (via the sqlite3_declare_vtab() interface) what the **        result set of queries against completion will look like. */
end_comment

begin_function
specifier|static
name|int
name|completionConnect
parameter_list|(
name|sqlite3
modifier|*
name|db
parameter_list|,
name|void
modifier|*
name|pAux
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|,
name|sqlite3_vtab
modifier|*
modifier|*
name|ppVtab
parameter_list|,
name|char
modifier|*
modifier|*
name|pzErr
parameter_list|)
block|{
name|completion_vtab
modifier|*
name|pNew
decl_stmt|;
name|int
name|rc
decl_stmt|;
call|(
name|void
call|)
argument_list|(
name|pAux
argument_list|)
expr_stmt|;
comment|/* Unused parameter */
call|(
name|void
call|)
argument_list|(
name|argc
argument_list|)
expr_stmt|;
comment|/* Unused parameter */
call|(
name|void
call|)
argument_list|(
name|argv
argument_list|)
expr_stmt|;
comment|/* Unused parameter */
call|(
name|void
call|)
argument_list|(
name|pzErr
argument_list|)
expr_stmt|;
comment|/* Unused parameter */
comment|/* Column numbers */
define|#
directive|define
name|COMPLETION_COLUMN_CANDIDATE
value|0
comment|/* Suggested completion of the input */
define|#
directive|define
name|COMPLETION_COLUMN_PREFIX
value|1
comment|/* Prefix of the word to be completed */
define|#
directive|define
name|COMPLETION_COLUMN_WHOLELINE
value|2
comment|/* Entire line seen so far */
define|#
directive|define
name|COMPLETION_COLUMN_PHASE
value|3
comment|/* ePhase - used for debugging only */
name|rc
operator|=
name|sqlite3_declare_vtab
argument_list|(
name|db
argument_list|,
literal|"CREATE TABLE x("
literal|"  candidate TEXT,"
literal|"  prefix TEXT HIDDEN,"
literal|"  wholeline TEXT HIDDEN,"
literal|"  phase INT HIDDEN"
comment|/* Used for debugging only */
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|SQLITE_OK
condition|)
block|{
name|pNew
operator|=
name|sqlite3_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pNew
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ppVtab
operator|=
operator|(
name|sqlite3_vtab
operator|*
operator|)
name|pNew
expr_stmt|;
if|if
condition|(
name|pNew
operator|==
literal|0
condition|)
return|return
name|SQLITE_NOMEM
return|;
name|memset
argument_list|(
name|pNew
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pNew
argument_list|)
argument_list|)
expr_stmt|;
name|pNew
operator|->
name|db
operator|=
name|db
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* ** This method is the destructor for completion_cursor objects. */
end_comment

begin_function
specifier|static
name|int
name|completionDisconnect
parameter_list|(
name|sqlite3_vtab
modifier|*
name|pVtab
parameter_list|)
block|{
name|sqlite3_free
argument_list|(
name|pVtab
argument_list|)
expr_stmt|;
return|return
name|SQLITE_OK
return|;
block|}
end_function

begin_comment
comment|/* ** Constructor for a new completion_cursor object. */
end_comment

begin_function
specifier|static
name|int
name|completionOpen
parameter_list|(
name|sqlite3_vtab
modifier|*
name|p
parameter_list|,
name|sqlite3_vtab_cursor
modifier|*
modifier|*
name|ppCursor
parameter_list|)
block|{
name|completion_cursor
modifier|*
name|pCur
decl_stmt|;
name|pCur
operator|=
name|sqlite3_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pCur
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pCur
operator|==
literal|0
condition|)
return|return
name|SQLITE_NOMEM
return|;
name|memset
argument_list|(
name|pCur
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pCur
argument_list|)
argument_list|)
expr_stmt|;
name|pCur
operator|->
name|db
operator|=
operator|(
operator|(
name|completion_vtab
operator|*
operator|)
name|p
operator|)
operator|->
name|db
expr_stmt|;
operator|*
name|ppCursor
operator|=
operator|&
name|pCur
operator|->
name|base
expr_stmt|;
return|return
name|SQLITE_OK
return|;
block|}
end_function

begin_comment
comment|/* ** Reset the completion_cursor. */
end_comment

begin_function
specifier|static
name|void
name|completionCursorReset
parameter_list|(
name|completion_cursor
modifier|*
name|pCur
parameter_list|)
block|{
name|sqlite3_free
argument_list|(
name|pCur
operator|->
name|zPrefix
argument_list|)
expr_stmt|;
name|pCur
operator|->
name|zPrefix
operator|=
literal|0
expr_stmt|;
name|pCur
operator|->
name|nPrefix
operator|=
literal|0
expr_stmt|;
name|sqlite3_free
argument_list|(
name|pCur
operator|->
name|zLine
argument_list|)
expr_stmt|;
name|pCur
operator|->
name|zLine
operator|=
literal|0
expr_stmt|;
name|pCur
operator|->
name|nLine
operator|=
literal|0
expr_stmt|;
name|sqlite3_finalize
argument_list|(
name|pCur
operator|->
name|pStmt
argument_list|)
expr_stmt|;
name|pCur
operator|->
name|pStmt
operator|=
literal|0
expr_stmt|;
name|pCur
operator|->
name|j
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Destructor for a completion_cursor. */
end_comment

begin_function
specifier|static
name|int
name|completionClose
parameter_list|(
name|sqlite3_vtab_cursor
modifier|*
name|cur
parameter_list|)
block|{
name|completionCursorReset
argument_list|(
operator|(
name|completion_cursor
operator|*
operator|)
name|cur
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|cur
argument_list|)
expr_stmt|;
return|return
name|SQLITE_OK
return|;
block|}
end_function

begin_comment
comment|/* ** All SQL keywords understood by SQLite */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|completionKwrds
index|[]
init|=
block|{
literal|"ABORT"
block|,
literal|"ACTION"
block|,
literal|"ADD"
block|,
literal|"AFTER"
block|,
literal|"ALL"
block|,
literal|"ALTER"
block|,
literal|"ANALYZE"
block|,
literal|"AND"
block|,
literal|"AS"
block|,
literal|"ASC"
block|,
literal|"ATTACH"
block|,
literal|"AUTOINCREMENT"
block|,
literal|"BEFORE"
block|,
literal|"BEGIN"
block|,
literal|"BETWEEN"
block|,
literal|"BY"
block|,
literal|"CASCADE"
block|,
literal|"CASE"
block|,
literal|"CAST"
block|,
literal|"CHECK"
block|,
literal|"COLLATE"
block|,
literal|"COLUMN"
block|,
literal|"COMMIT"
block|,
literal|"CONFLICT"
block|,
literal|"CONSTRAINT"
block|,
literal|"CREATE"
block|,
literal|"CROSS"
block|,
literal|"CURRENT_DATE"
block|,
literal|"CURRENT_TIME"
block|,
literal|"CURRENT_TIMESTAMP"
block|,
literal|"DATABASE"
block|,
literal|"DEFAULT"
block|,
literal|"DEFERRABLE"
block|,
literal|"DEFERRED"
block|,
literal|"DELETE"
block|,
literal|"DESC"
block|,
literal|"DETACH"
block|,
literal|"DISTINCT"
block|,
literal|"DROP"
block|,
literal|"EACH"
block|,
literal|"ELSE"
block|,
literal|"END"
block|,
literal|"ESCAPE"
block|,
literal|"EXCEPT"
block|,
literal|"EXCLUSIVE"
block|,
literal|"EXISTS"
block|,
literal|"EXPLAIN"
block|,
literal|"FAIL"
block|,
literal|"FOR"
block|,
literal|"FOREIGN"
block|,
literal|"FROM"
block|,
literal|"FULL"
block|,
literal|"GLOB"
block|,
literal|"GROUP"
block|,
literal|"HAVING"
block|,
literal|"IF"
block|,
literal|"IGNORE"
block|,
literal|"IMMEDIATE"
block|,
literal|"IN"
block|,
literal|"INDEX"
block|,
literal|"INDEXED"
block|,
literal|"INITIALLY"
block|,
literal|"INNER"
block|,
literal|"INSERT"
block|,
literal|"INSTEAD"
block|,
literal|"INTERSECT"
block|,
literal|"INTO"
block|,
literal|"IS"
block|,
literal|"ISNULL"
block|,
literal|"JOIN"
block|,
literal|"KEY"
block|,
literal|"LEFT"
block|,
literal|"LIKE"
block|,
literal|"LIMIT"
block|,
literal|"MATCH"
block|,
literal|"NATURAL"
block|,
literal|"NO"
block|,
literal|"NOT"
block|,
literal|"NOTNULL"
block|,
literal|"NULL"
block|,
literal|"OF"
block|,
literal|"OFFSET"
block|,
literal|"ON"
block|,
literal|"OR"
block|,
literal|"ORDER"
block|,
literal|"OUTER"
block|,
literal|"PLAN"
block|,
literal|"PRAGMA"
block|,
literal|"PRIMARY"
block|,
literal|"QUERY"
block|,
literal|"RAISE"
block|,
literal|"RECURSIVE"
block|,
literal|"REFERENCES"
block|,
literal|"REGEXP"
block|,
literal|"REINDEX"
block|,
literal|"RELEASE"
block|,
literal|"RENAME"
block|,
literal|"REPLACE"
block|,
literal|"RESTRICT"
block|,
literal|"RIGHT"
block|,
literal|"ROLLBACK"
block|,
literal|"ROW"
block|,
literal|"SAVEPOINT"
block|,
literal|"SELECT"
block|,
literal|"SET"
block|,
literal|"TABLE"
block|,
literal|"TEMP"
block|,
literal|"TEMPORARY"
block|,
literal|"THEN"
block|,
literal|"TO"
block|,
literal|"TRANSACTION"
block|,
literal|"TRIGGER"
block|,
literal|"UNION"
block|,
literal|"UNIQUE"
block|,
literal|"UPDATE"
block|,
literal|"USING"
block|,
literal|"VACUUM"
block|,
literal|"VALUES"
block|,
literal|"VIEW"
block|,
literal|"VIRTUAL"
block|,
literal|"WHEN"
block|,
literal|"WHERE"
block|,
literal|"WITH"
block|,
literal|"WITHOUT"
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|completionKwCount
define|\
value|(int)(sizeof(completionKwrds)/sizeof(completionKwrds[0]))
end_define

begin_comment
comment|/* ** Advance a completion_cursor to its next row of output. ** ** The ->ePhase, ->j, and ->pStmt fields of the completion_cursor object ** record the current state of the scan.  This routine sets ->zCurrentRow ** to the current row of output and then returns.  If no more rows remain, ** then ->ePhase is set to COMPLETION_EOF which will signal the virtual ** table that has reached the end of its scan. ** ** The current implementation just lists potential identifiers and ** keywords and filters them by zPrefix.  Future enhancements should ** take zLine into account to try to restrict the set of identifiers and ** keywords based on what would be legal at the current point of input. */
end_comment

begin_function
specifier|static
name|int
name|completionNext
parameter_list|(
name|sqlite3_vtab_cursor
modifier|*
name|cur
parameter_list|)
block|{
name|completion_cursor
modifier|*
name|pCur
init|=
operator|(
name|completion_cursor
operator|*
operator|)
name|cur
decl_stmt|;
name|int
name|eNextPhase
init|=
literal|0
decl_stmt|;
comment|/* Next phase to try if current phase reaches end */
name|int
name|iCol
init|=
operator|-
literal|1
decl_stmt|;
comment|/* If>=0, step pCur->pStmt and use the i-th column */
name|pCur
operator|->
name|iRowid
operator|++
expr_stmt|;
while|while
condition|(
name|pCur
operator|->
name|ePhase
operator|!=
name|COMPLETION_EOF
condition|)
block|{
switch|switch
condition|(
name|pCur
operator|->
name|ePhase
condition|)
block|{
case|case
name|COMPLETION_KEYWORDS
case|:
block|{
if|if
condition|(
name|pCur
operator|->
name|j
operator|>=
name|completionKwCount
condition|)
block|{
name|pCur
operator|->
name|zCurrentRow
operator|=
literal|0
expr_stmt|;
name|pCur
operator|->
name|ePhase
operator|=
name|COMPLETION_DATABASES
expr_stmt|;
block|}
else|else
block|{
name|pCur
operator|->
name|zCurrentRow
operator|=
name|completionKwrds
index|[
name|pCur
operator|->
name|j
operator|++
index|]
expr_stmt|;
block|}
name|iCol
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
case|case
name|COMPLETION_DATABASES
case|:
block|{
if|if
condition|(
name|pCur
operator|->
name|pStmt
operator|==
literal|0
condition|)
block|{
name|sqlite3_prepare_v2
argument_list|(
name|pCur
operator|->
name|db
argument_list|,
literal|"PRAGMA database_list"
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pCur
operator|->
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|iCol
operator|=
literal|1
expr_stmt|;
name|eNextPhase
operator|=
name|COMPLETION_TABLES
expr_stmt|;
break|break;
block|}
case|case
name|COMPLETION_TABLES
case|:
block|{
if|if
condition|(
name|pCur
operator|->
name|pStmt
operator|==
literal|0
condition|)
block|{
name|sqlite3_stmt
modifier|*
name|pS2
decl_stmt|;
name|char
modifier|*
name|zSql
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|zSep
init|=
literal|""
decl_stmt|;
name|sqlite3_prepare_v2
argument_list|(
name|pCur
operator|->
name|db
argument_list|,
literal|"PRAGMA database_list"
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pS2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|sqlite3_step
argument_list|(
name|pS2
argument_list|)
operator|==
name|SQLITE_ROW
condition|)
block|{
specifier|const
name|char
modifier|*
name|zDb
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pS2
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|zSql
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"%z%s"
literal|"SELECT name FROM \"%w\".sqlite_master"
literal|" WHERE type='table'"
argument_list|,
name|zSql
argument_list|,
name|zSep
argument_list|,
name|zDb
argument_list|)
expr_stmt|;
if|if
condition|(
name|zSql
operator|==
literal|0
condition|)
return|return
name|SQLITE_NOMEM
return|;
name|zSep
operator|=
literal|" UNION "
expr_stmt|;
block|}
name|sqlite3_finalize
argument_list|(
name|pS2
argument_list|)
expr_stmt|;
name|sqlite3_prepare_v2
argument_list|(
name|pCur
operator|->
name|db
argument_list|,
name|zSql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pCur
operator|->
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
block|}
name|iCol
operator|=
literal|0
expr_stmt|;
name|eNextPhase
operator|=
name|COMPLETION_COLUMNS
expr_stmt|;
break|break;
block|}
case|case
name|COMPLETION_COLUMNS
case|:
block|{
if|if
condition|(
name|pCur
operator|->
name|pStmt
operator|==
literal|0
condition|)
block|{
name|sqlite3_stmt
modifier|*
name|pS2
decl_stmt|;
name|char
modifier|*
name|zSql
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|zSep
init|=
literal|""
decl_stmt|;
name|sqlite3_prepare_v2
argument_list|(
name|pCur
operator|->
name|db
argument_list|,
literal|"PRAGMA database_list"
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pS2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|sqlite3_step
argument_list|(
name|pS2
argument_list|)
operator|==
name|SQLITE_ROW
condition|)
block|{
specifier|const
name|char
modifier|*
name|zDb
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pS2
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|zSql
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"%z%s"
literal|"SELECT pti.name FROM \"%w\".sqlite_master AS sm"
literal|" JOIN pragma_table_info(sm.name,%Q) AS pti"
literal|" WHERE sm.type='table'"
argument_list|,
name|zSql
argument_list|,
name|zSep
argument_list|,
name|zDb
argument_list|,
name|zDb
argument_list|)
expr_stmt|;
if|if
condition|(
name|zSql
operator|==
literal|0
condition|)
return|return
name|SQLITE_NOMEM
return|;
name|zSep
operator|=
literal|" UNION "
expr_stmt|;
block|}
name|sqlite3_finalize
argument_list|(
name|pS2
argument_list|)
expr_stmt|;
name|sqlite3_prepare_v2
argument_list|(
name|pCur
operator|->
name|db
argument_list|,
name|zSql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pCur
operator|->
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
block|}
name|iCol
operator|=
literal|0
expr_stmt|;
name|eNextPhase
operator|=
name|COMPLETION_EOF
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|iCol
operator|<
literal|0
condition|)
block|{
comment|/* This case is when the phase presets zCurrentRow */
if|if
condition|(
name|pCur
operator|->
name|zCurrentRow
operator|==
literal|0
condition|)
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|sqlite3_step
argument_list|(
name|pCur
operator|->
name|pStmt
argument_list|)
operator|==
name|SQLITE_ROW
condition|)
block|{
comment|/* Extract the next row of content */
name|pCur
operator|->
name|zCurrentRow
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pCur
operator|->
name|pStmt
argument_list|,
name|iCol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* When all rows are finished, advance to the next phase */
name|sqlite3_finalize
argument_list|(
name|pCur
operator|->
name|pStmt
argument_list|)
expr_stmt|;
name|pCur
operator|->
name|pStmt
operator|=
literal|0
expr_stmt|;
name|pCur
operator|->
name|ePhase
operator|=
name|eNextPhase
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|pCur
operator|->
name|nPrefix
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|sqlite3_strnicmp
argument_list|(
name|pCur
operator|->
name|zPrefix
argument_list|,
name|pCur
operator|->
name|zCurrentRow
argument_list|,
name|pCur
operator|->
name|nPrefix
argument_list|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
return|return
name|SQLITE_OK
return|;
block|}
end_function

begin_comment
comment|/* ** Return values of columns for the row at which the completion_cursor ** is currently pointing. */
end_comment

begin_function
specifier|static
name|int
name|completionColumn
parameter_list|(
name|sqlite3_vtab_cursor
modifier|*
name|cur
parameter_list|,
comment|/* The cursor */
name|sqlite3_context
modifier|*
name|ctx
parameter_list|,
comment|/* First argument to sqlite3_result_...() */
name|int
name|i
comment|/* Which column to return */
parameter_list|)
block|{
name|completion_cursor
modifier|*
name|pCur
init|=
operator|(
name|completion_cursor
operator|*
operator|)
name|cur
decl_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|COMPLETION_COLUMN_CANDIDATE
case|:
block|{
name|sqlite3_result_text
argument_list|(
name|ctx
argument_list|,
name|pCur
operator|->
name|zCurrentRow
argument_list|,
operator|-
literal|1
argument_list|,
name|SQLITE_TRANSIENT
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|COMPLETION_COLUMN_PREFIX
case|:
block|{
name|sqlite3_result_text
argument_list|(
name|ctx
argument_list|,
name|pCur
operator|->
name|zPrefix
argument_list|,
operator|-
literal|1
argument_list|,
name|SQLITE_TRANSIENT
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|COMPLETION_COLUMN_WHOLELINE
case|:
block|{
name|sqlite3_result_text
argument_list|(
name|ctx
argument_list|,
name|pCur
operator|->
name|zLine
argument_list|,
operator|-
literal|1
argument_list|,
name|SQLITE_TRANSIENT
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|COMPLETION_COLUMN_PHASE
case|:
block|{
name|sqlite3_result_int
argument_list|(
name|ctx
argument_list|,
name|pCur
operator|->
name|ePhase
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|SQLITE_OK
return|;
block|}
end_function

begin_comment
comment|/* ** Return the rowid for the current row.  In this implementation, the ** rowid is the same as the output value. */
end_comment

begin_function
specifier|static
name|int
name|completionRowid
parameter_list|(
name|sqlite3_vtab_cursor
modifier|*
name|cur
parameter_list|,
name|sqlite_int64
modifier|*
name|pRowid
parameter_list|)
block|{
name|completion_cursor
modifier|*
name|pCur
init|=
operator|(
name|completion_cursor
operator|*
operator|)
name|cur
decl_stmt|;
operator|*
name|pRowid
operator|=
name|pCur
operator|->
name|iRowid
expr_stmt|;
return|return
name|SQLITE_OK
return|;
block|}
end_function

begin_comment
comment|/* ** Return TRUE if the cursor has been moved off of the last ** row of output. */
end_comment

begin_function
specifier|static
name|int
name|completionEof
parameter_list|(
name|sqlite3_vtab_cursor
modifier|*
name|cur
parameter_list|)
block|{
name|completion_cursor
modifier|*
name|pCur
init|=
operator|(
name|completion_cursor
operator|*
operator|)
name|cur
decl_stmt|;
return|return
name|pCur
operator|->
name|ePhase
operator|>=
name|COMPLETION_EOF
return|;
block|}
end_function

begin_comment
comment|/* ** This method is called to "rewind" the completion_cursor object back ** to the first row of output.  This method is always called at least ** once prior to any call to completionColumn() or completionRowid() or  ** completionEof(). */
end_comment

begin_function
specifier|static
name|int
name|completionFilter
parameter_list|(
name|sqlite3_vtab_cursor
modifier|*
name|pVtabCursor
parameter_list|,
name|int
name|idxNum
parameter_list|,
specifier|const
name|char
modifier|*
name|idxStr
parameter_list|,
name|int
name|argc
parameter_list|,
name|sqlite3_value
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|completion_cursor
modifier|*
name|pCur
init|=
operator|(
name|completion_cursor
operator|*
operator|)
name|pVtabCursor
decl_stmt|;
name|int
name|iArg
init|=
literal|0
decl_stmt|;
call|(
name|void
call|)
argument_list|(
name|idxStr
argument_list|)
expr_stmt|;
comment|/* Unused parameter */
call|(
name|void
call|)
argument_list|(
name|argc
argument_list|)
expr_stmt|;
comment|/* Unused parameter */
name|completionCursorReset
argument_list|(
name|pCur
argument_list|)
expr_stmt|;
if|if
condition|(
name|idxNum
operator|&
literal|1
condition|)
block|{
name|pCur
operator|->
name|nPrefix
operator|=
name|sqlite3_value_bytes
argument_list|(
name|argv
index|[
name|iArg
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pCur
operator|->
name|nPrefix
operator|>
literal|0
condition|)
block|{
name|pCur
operator|->
name|zPrefix
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"%s"
argument_list|,
name|sqlite3_value_text
argument_list|(
name|argv
index|[
name|iArg
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pCur
operator|->
name|zPrefix
operator|==
literal|0
condition|)
return|return
name|SQLITE_NOMEM
return|;
block|}
name|iArg
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|idxNum
operator|&
literal|2
condition|)
block|{
name|pCur
operator|->
name|nLine
operator|=
name|sqlite3_value_bytes
argument_list|(
name|argv
index|[
name|iArg
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pCur
operator|->
name|nLine
operator|>
literal|0
condition|)
block|{
name|pCur
operator|->
name|zLine
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"%s"
argument_list|,
name|sqlite3_value_text
argument_list|(
name|argv
index|[
name|iArg
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pCur
operator|->
name|zLine
operator|==
literal|0
condition|)
return|return
name|SQLITE_NOMEM
return|;
block|}
name|iArg
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|pCur
operator|->
name|zLine
operator|!=
literal|0
operator|&&
name|pCur
operator|->
name|zPrefix
operator|==
literal|0
condition|)
block|{
name|int
name|i
init|=
name|pCur
operator|->
name|nLine
decl_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
operator|&&
operator|(
name|isalnum
argument_list|(
name|pCur
operator|->
name|zLine
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
operator|||
name|pCur
operator|->
name|zLine
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'_'
operator|)
condition|)
block|{
name|i
operator|--
expr_stmt|;
block|}
name|pCur
operator|->
name|nPrefix
operator|=
name|pCur
operator|->
name|nLine
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|pCur
operator|->
name|nPrefix
operator|>
literal|0
condition|)
block|{
name|pCur
operator|->
name|zPrefix
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"%.*s"
argument_list|,
name|pCur
operator|->
name|nPrefix
argument_list|,
name|pCur
operator|->
name|zLine
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|pCur
operator|->
name|zPrefix
operator|==
literal|0
condition|)
return|return
name|SQLITE_NOMEM
return|;
block|}
block|}
name|pCur
operator|->
name|iRowid
operator|=
literal|0
expr_stmt|;
name|pCur
operator|->
name|ePhase
operator|=
name|COMPLETION_FIRST_PHASE
expr_stmt|;
return|return
name|completionNext
argument_list|(
name|pVtabCursor
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ** SQLite will invoke this method one or more times while planning a query ** that uses the completion virtual table.  This routine needs to create ** a query plan for each invocation and compute an estimated cost for that ** plan. ** ** There are two hidden parameters that act as arguments to the table-valued ** function:  "prefix" and "wholeline".  Bit 0 of idxNum is set if "prefix" ** is available and bit 1 is set if "wholeline" is available. */
end_comment

begin_function
specifier|static
name|int
name|completionBestIndex
parameter_list|(
name|sqlite3_vtab
modifier|*
name|tab
parameter_list|,
name|sqlite3_index_info
modifier|*
name|pIdxInfo
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Loop over constraints */
name|int
name|idxNum
init|=
literal|0
decl_stmt|;
comment|/* The query plan bitmask */
name|int
name|prefixIdx
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Index of the start= constraint, or -1 if none */
name|int
name|wholelineIdx
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Index of the stop= constraint, or -1 if none */
name|int
name|nArg
init|=
literal|0
decl_stmt|;
comment|/* Number of arguments that completeFilter() expects */
specifier|const
name|struct
name|sqlite3_index_constraint
modifier|*
name|pConstraint
decl_stmt|;
call|(
name|void
call|)
argument_list|(
name|tab
argument_list|)
expr_stmt|;
comment|/* Unused parameter */
name|pConstraint
operator|=
name|pIdxInfo
operator|->
name|aConstraint
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pIdxInfo
operator|->
name|nConstraint
condition|;
name|i
operator|++
operator|,
name|pConstraint
operator|++
control|)
block|{
if|if
condition|(
name|pConstraint
operator|->
name|usable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|pConstraint
operator|->
name|op
operator|!=
name|SQLITE_INDEX_CONSTRAINT_EQ
condition|)
continue|continue;
switch|switch
condition|(
name|pConstraint
operator|->
name|iColumn
condition|)
block|{
case|case
name|COMPLETION_COLUMN_PREFIX
case|:
name|prefixIdx
operator|=
name|i
expr_stmt|;
name|idxNum
operator||=
literal|1
expr_stmt|;
break|break;
case|case
name|COMPLETION_COLUMN_WHOLELINE
case|:
name|wholelineIdx
operator|=
name|i
expr_stmt|;
name|idxNum
operator||=
literal|2
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|prefixIdx
operator|>=
literal|0
condition|)
block|{
name|pIdxInfo
operator|->
name|aConstraintUsage
index|[
name|prefixIdx
index|]
operator|.
name|argvIndex
operator|=
operator|++
name|nArg
expr_stmt|;
name|pIdxInfo
operator|->
name|aConstraintUsage
index|[
name|prefixIdx
index|]
operator|.
name|omit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|wholelineIdx
operator|>=
literal|0
condition|)
block|{
name|pIdxInfo
operator|->
name|aConstraintUsage
index|[
name|wholelineIdx
index|]
operator|.
name|argvIndex
operator|=
operator|++
name|nArg
expr_stmt|;
name|pIdxInfo
operator|->
name|aConstraintUsage
index|[
name|wholelineIdx
index|]
operator|.
name|omit
operator|=
literal|1
expr_stmt|;
block|}
name|pIdxInfo
operator|->
name|idxNum
operator|=
name|idxNum
expr_stmt|;
name|pIdxInfo
operator|->
name|estimatedCost
operator|=
operator|(
name|double
operator|)
literal|5000
operator|-
literal|1000
operator|*
name|nArg
expr_stmt|;
name|pIdxInfo
operator|->
name|estimatedRows
operator|=
literal|500
operator|-
literal|100
operator|*
name|nArg
expr_stmt|;
return|return
name|SQLITE_OK
return|;
block|}
end_function

begin_comment
comment|/* ** This following structure defines all the methods for the  ** completion virtual table. */
end_comment

begin_decl_stmt
specifier|static
name|sqlite3_module
name|completionModule
init|=
block|{
literal|0
block|,
comment|/* iVersion */
literal|0
block|,
comment|/* xCreate */
name|completionConnect
block|,
comment|/* xConnect */
name|completionBestIndex
block|,
comment|/* xBestIndex */
name|completionDisconnect
block|,
comment|/* xDisconnect */
literal|0
block|,
comment|/* xDestroy */
name|completionOpen
block|,
comment|/* xOpen - open a cursor */
name|completionClose
block|,
comment|/* xClose - close a cursor */
name|completionFilter
block|,
comment|/* xFilter - configure scan constraints */
name|completionNext
block|,
comment|/* xNext - advance a cursor */
name|completionEof
block|,
comment|/* xEof - check for end of scan */
name|completionColumn
block|,
comment|/* xColumn - read data */
name|completionRowid
block|,
comment|/* xRowid - read data */
literal|0
block|,
comment|/* xUpdate */
literal|0
block|,
comment|/* xBegin */
literal|0
block|,
comment|/* xSync */
literal|0
block|,
comment|/* xCommit */
literal|0
block|,
comment|/* xRollback */
literal|0
block|,
comment|/* xFindMethod */
literal|0
block|,
comment|/* xRename */
literal|0
block|,
comment|/* xSavepoint */
literal|0
block|,
comment|/* xRelease */
literal|0
comment|/* xRollbackTo */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SQLITE_OMIT_VIRTUALTABLE */
end_comment

begin_function
name|int
name|sqlite3CompletionVtabInit
parameter_list|(
name|sqlite3
modifier|*
name|db
parameter_list|)
block|{
name|int
name|rc
init|=
name|SQLITE_OK
decl_stmt|;
ifndef|#
directive|ifndef
name|SQLITE_OMIT_VIRTUALTABLE
name|rc
operator|=
name|sqlite3_create_module
argument_list|(
name|db
argument_list|,
literal|"completion"
argument_list|,
operator|&
name|completionModule
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|rc
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_macro
name|__declspec
argument_list|(
argument|dllexport
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|sqlite3_completion_init
parameter_list|(
name|sqlite3
modifier|*
name|db
parameter_list|,
name|char
modifier|*
modifier|*
name|pzErrMsg
parameter_list|,
specifier|const
name|sqlite3_api_routines
modifier|*
name|pApi
parameter_list|)
block|{
name|int
name|rc
init|=
name|SQLITE_OK
decl_stmt|;
name|SQLITE_EXTENSION_INIT2
argument_list|(
name|pApi
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
name|pzErrMsg
argument_list|)
expr_stmt|;
comment|/* Unused parameter */
ifndef|#
directive|ifndef
name|SQLITE_OMIT_VIRTUALTABLE
name|rc
operator|=
name|sqlite3CompletionVtabInit
argument_list|(
name|db
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/************************* End ../ext/misc/completion.c ********************/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_ENABLE_SESSION
argument_list|)
end_if

begin_comment
comment|/* ** State information for a single open session */
end_comment

begin_typedef
typedef|typedef
name|struct
name|OpenSession
name|OpenSession
typedef|;
end_typedef

begin_struct
struct|struct
name|OpenSession
block|{
name|char
modifier|*
name|zName
decl_stmt|;
comment|/* Symbolic name for this session */
name|int
name|nFilter
decl_stmt|;
comment|/* Number of xFilter rejection GLOB patterns */
name|char
modifier|*
modifier|*
name|azFilter
decl_stmt|;
comment|/* Array of xFilter rejection GLOB patterns */
name|sqlite3_session
modifier|*
name|p
decl_stmt|;
comment|/* The open session */
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** Shell output mode information from before ".explain on", ** saved so that it can be restored by ".explain off" */
end_comment

begin_typedef
typedef|typedef
name|struct
name|SavedModeInfo
name|SavedModeInfo
typedef|;
end_typedef

begin_struct
struct|struct
name|SavedModeInfo
block|{
name|int
name|valid
decl_stmt|;
comment|/* Is there legit data in here? */
name|int
name|mode
decl_stmt|;
comment|/* Mode prior to ".explain on" */
name|int
name|showHeader
decl_stmt|;
comment|/* The ".header" setting prior to ".explain on" */
name|int
name|colWidth
index|[
literal|100
index|]
decl_stmt|;
comment|/* Column widths prior to ".explain on" */
block|}
struct|;
end_struct

begin_comment
comment|/* ** State information about the database connection is contained in an ** instance of the following structure. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|ShellState
name|ShellState
typedef|;
end_typedef

begin_struct
struct|struct
name|ShellState
block|{
name|sqlite3
modifier|*
name|db
decl_stmt|;
comment|/* The database */
name|int
name|autoExplain
decl_stmt|;
comment|/* Automatically turn on .explain mode */
name|int
name|autoEQP
decl_stmt|;
comment|/* Run EXPLAIN QUERY PLAN prior to seach SQL stmt */
name|int
name|statsOn
decl_stmt|;
comment|/* True to display memory stats before each finalize */
name|int
name|scanstatsOn
decl_stmt|;
comment|/* True to display scan stats before each finalize */
name|int
name|outCount
decl_stmt|;
comment|/* Revert to stdout when reaching zero */
name|int
name|cnt
decl_stmt|;
comment|/* Number of records displayed so far */
name|FILE
modifier|*
name|out
decl_stmt|;
comment|/* Write results here */
name|FILE
modifier|*
name|traceOut
decl_stmt|;
comment|/* Output for sqlite3_trace() */
name|int
name|nErr
decl_stmt|;
comment|/* Number of errors seen */
name|int
name|mode
decl_stmt|;
comment|/* An output mode setting */
name|int
name|cMode
decl_stmt|;
comment|/* temporary output mode for the current query */
name|int
name|normalMode
decl_stmt|;
comment|/* Output mode before ".explain on" */
name|int
name|writableSchema
decl_stmt|;
comment|/* True if PRAGMA writable_schema=ON */
name|int
name|showHeader
decl_stmt|;
comment|/* True to show column names in List or Column mode */
name|int
name|nCheck
decl_stmt|;
comment|/* Number of ".check" commands run */
name|unsigned
name|shellFlgs
decl_stmt|;
comment|/* Various flags */
name|char
modifier|*
name|zDestTable
decl_stmt|;
comment|/* Name of destination table when MODE_Insert */
name|char
name|zTestcase
index|[
literal|30
index|]
decl_stmt|;
comment|/* Name of current test case */
name|char
name|colSeparator
index|[
literal|20
index|]
decl_stmt|;
comment|/* Column separator character for several modes */
name|char
name|rowSeparator
index|[
literal|20
index|]
decl_stmt|;
comment|/* Row separator character for MODE_Ascii */
name|int
name|colWidth
index|[
literal|100
index|]
decl_stmt|;
comment|/* Requested width of each column when in column mode*/
name|int
name|actualWidth
index|[
literal|100
index|]
decl_stmt|;
comment|/* Actual width of each column */
name|char
name|nullValue
index|[
literal|20
index|]
decl_stmt|;
comment|/* The text to print when a NULL comes back from                          ** the database */
name|char
name|outfile
index|[
name|FILENAME_MAX
index|]
decl_stmt|;
comment|/* Filename for *out */
specifier|const
name|char
modifier|*
name|zDbFilename
decl_stmt|;
comment|/* name of the database file */
name|char
modifier|*
name|zFreeOnClose
decl_stmt|;
comment|/* Filename to free when closing */
specifier|const
name|char
modifier|*
name|zVfs
decl_stmt|;
comment|/* Name of VFS to use */
name|sqlite3_stmt
modifier|*
name|pStmt
decl_stmt|;
comment|/* Current statement if any. */
name|FILE
modifier|*
name|pLog
decl_stmt|;
comment|/* Write log output here */
name|int
modifier|*
name|aiIndent
decl_stmt|;
comment|/* Array of indents used in MODE_Explain */
name|int
name|nIndent
decl_stmt|;
comment|/* Size of array aiIndent[] */
name|int
name|iIndent
decl_stmt|;
comment|/* Index of current op in aiIndent[] */
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_ENABLE_SESSION
argument_list|)
name|int
name|nSession
decl_stmt|;
comment|/* Number of active sessions */
name|OpenSession
name|aSession
index|[
literal|4
index|]
decl_stmt|;
comment|/* Array of sessions.  [0] is in focus. */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/* ** These are the allowed shellFlgs values */
end_comment

begin_define
define|#
directive|define
name|SHFLG_Scratch
value|0x00000001
end_define

begin_comment
comment|/* The --scratch option is used */
end_comment

begin_define
define|#
directive|define
name|SHFLG_Pagecache
value|0x00000002
end_define

begin_comment
comment|/* The --pagecache option is used */
end_comment

begin_define
define|#
directive|define
name|SHFLG_Lookaside
value|0x00000004
end_define

begin_comment
comment|/* Lookaside memory is used */
end_comment

begin_define
define|#
directive|define
name|SHFLG_Backslash
value|0x00000008
end_define

begin_comment
comment|/* The --backslash option is used */
end_comment

begin_define
define|#
directive|define
name|SHFLG_PreserveRowid
value|0x00000010
end_define

begin_comment
comment|/* .dump preserves rowid values */
end_comment

begin_define
define|#
directive|define
name|SHFLG_Newlines
value|0x00000020
end_define

begin_comment
comment|/* .dump --newline flag */
end_comment

begin_define
define|#
directive|define
name|SHFLG_CountChanges
value|0x00000040
end_define

begin_comment
comment|/* .changes setting */
end_comment

begin_define
define|#
directive|define
name|SHFLG_Echo
value|0x00000080
end_define

begin_comment
comment|/* .echo or --echo setting */
end_comment

begin_comment
comment|/* ** Macros for testing and setting shellFlgs */
end_comment

begin_define
define|#
directive|define
name|ShellHasFlag
parameter_list|(
name|P
parameter_list|,
name|X
parameter_list|)
value|(((P)->shellFlgs& (X))!=0)
end_define

begin_define
define|#
directive|define
name|ShellSetFlag
parameter_list|(
name|P
parameter_list|,
name|X
parameter_list|)
value|((P)->shellFlgs|=(X))
end_define

begin_define
define|#
directive|define
name|ShellClearFlag
parameter_list|(
name|P
parameter_list|,
name|X
parameter_list|)
value|((P)->shellFlgs&=(~(X)))
end_define

begin_comment
comment|/* ** These are the allowed modes. */
end_comment

begin_define
define|#
directive|define
name|MODE_Line
value|0
end_define

begin_comment
comment|/* One column per line.  Blank line between records */
end_comment

begin_define
define|#
directive|define
name|MODE_Column
value|1
end_define

begin_comment
comment|/* One record per line in neat columns */
end_comment

begin_define
define|#
directive|define
name|MODE_List
value|2
end_define

begin_comment
comment|/* One record per line with a separator */
end_comment

begin_define
define|#
directive|define
name|MODE_Semi
value|3
end_define

begin_comment
comment|/* Same as MODE_List but append ";" to each line */
end_comment

begin_define
define|#
directive|define
name|MODE_Html
value|4
end_define

begin_comment
comment|/* Generate an XHTML table */
end_comment

begin_define
define|#
directive|define
name|MODE_Insert
value|5
end_define

begin_comment
comment|/* Generate SQL "insert" statements */
end_comment

begin_define
define|#
directive|define
name|MODE_Quote
value|6
end_define

begin_comment
comment|/* Quote values as for SQL */
end_comment

begin_define
define|#
directive|define
name|MODE_Tcl
value|7
end_define

begin_comment
comment|/* Generate ANSI-C or TCL quoted elements */
end_comment

begin_define
define|#
directive|define
name|MODE_Csv
value|8
end_define

begin_comment
comment|/* Quote strings, numbers are plain */
end_comment

begin_define
define|#
directive|define
name|MODE_Explain
value|9
end_define

begin_comment
comment|/* Like MODE_Column, but do not truncate data */
end_comment

begin_define
define|#
directive|define
name|MODE_Ascii
value|10
end_define

begin_comment
comment|/* Use ASCII unit and record separators (0x1F/0x1E) */
end_comment

begin_define
define|#
directive|define
name|MODE_Pretty
value|11
end_define

begin_comment
comment|/* Pretty-print schemas */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|modeDescr
index|[]
init|=
block|{
literal|"line"
block|,
literal|"column"
block|,
literal|"list"
block|,
literal|"semi"
block|,
literal|"html"
block|,
literal|"insert"
block|,
literal|"quote"
block|,
literal|"tcl"
block|,
literal|"csv"
block|,
literal|"explain"
block|,
literal|"ascii"
block|,
literal|"prettyprint"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** These are the column/row/line separators used by the various ** import/export modes. */
end_comment

begin_define
define|#
directive|define
name|SEP_Column
value|"|"
end_define

begin_define
define|#
directive|define
name|SEP_Row
value|"\n"
end_define

begin_define
define|#
directive|define
name|SEP_Tab
value|"\t"
end_define

begin_define
define|#
directive|define
name|SEP_Space
value|" "
end_define

begin_define
define|#
directive|define
name|SEP_Comma
value|","
end_define

begin_define
define|#
directive|define
name|SEP_CrLf
value|"\r\n"
end_define

begin_define
define|#
directive|define
name|SEP_Unit
value|"\x1F"
end_define

begin_define
define|#
directive|define
name|SEP_Record
value|"\x1E"
end_define

begin_comment
comment|/* ** Number of elements in an array */
end_comment

begin_define
define|#
directive|define
name|ArraySize
parameter_list|(
name|X
parameter_list|)
value|(int)(sizeof(X)/sizeof(X[0]))
end_define

begin_comment
comment|/* ** A callback for the sqlite3_log() interface. */
end_comment

begin_function
specifier|static
name|void
name|shellLog
parameter_list|(
name|void
modifier|*
name|pArg
parameter_list|,
name|int
name|iErrCode
parameter_list|,
specifier|const
name|char
modifier|*
name|zMsg
parameter_list|)
block|{
name|ShellState
modifier|*
name|p
init|=
operator|(
name|ShellState
operator|*
operator|)
name|pArg
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|pLog
operator|==
literal|0
condition|)
return|return;
name|utf8_printf
argument_list|(
name|p
operator|->
name|pLog
argument_list|,
literal|"(%d) %s\n"
argument_list|,
name|iErrCode
argument_list|,
name|zMsg
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|p
operator|->
name|pLog
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Output the given string as a hex-encoded blob (eg. X'1234' ) */
end_comment

begin_function
specifier|static
name|void
name|output_hex_blob
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|pBlob
parameter_list|,
name|int
name|nBlob
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|zBlob
init|=
operator|(
name|char
operator|*
operator|)
name|pBlob
decl_stmt|;
name|raw_printf
argument_list|(
name|out
argument_list|,
literal|"X'"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nBlob
condition|;
name|i
operator|++
control|)
block|{
name|raw_printf
argument_list|(
name|out
argument_list|,
literal|"%02x"
argument_list|,
name|zBlob
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
name|raw_printf
argument_list|(
name|out
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Find a string that is not found anywhere in z[].  Return a pointer ** to that string. ** ** Try to use zA and zB first.  If both of those are already found in z[] ** then make up some string and store it in the buffer zBuf. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|unused_string
parameter_list|(
specifier|const
name|char
modifier|*
name|z
parameter_list|,
comment|/* Result must not appear anywhere in z */
specifier|const
name|char
modifier|*
name|zA
parameter_list|,
specifier|const
name|char
modifier|*
name|zB
parameter_list|,
comment|/* Try these first */
name|char
modifier|*
name|zBuf
comment|/* Space to store a generated string */
parameter_list|)
block|{
name|unsigned
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|z
argument_list|,
name|zA
argument_list|)
operator|==
literal|0
condition|)
return|return
name|zA
return|;
if|if
condition|(
name|strstr
argument_list|(
name|z
argument_list|,
name|zB
argument_list|)
operator|==
literal|0
condition|)
return|return
name|zB
return|;
do|do
block|{
name|sqlite3_snprintf
argument_list|(
literal|20
argument_list|,
name|zBuf
argument_list|,
literal|"(%s%u)"
argument_list|,
name|zA
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|strstr
argument_list|(
name|z
argument_list|,
name|zBuf
argument_list|)
operator|!=
literal|0
condition|)
do|;
return|return
name|zBuf
return|;
block|}
end_function

begin_comment
comment|/* ** Output the given string as a quoted string using SQL quoting conventions. ** ** See also: output_quoted_escaped_string() */
end_comment

begin_function
specifier|static
name|void
name|output_quoted_string
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
specifier|const
name|char
modifier|*
name|z
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|c
decl_stmt|;
name|setBinaryMode
argument_list|(
name|out
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|c
operator|=
name|z
index|[
name|i
index|]
operator|)
operator|!=
literal|0
operator|&&
name|c
operator|!=
literal|'\''
condition|;
name|i
operator|++
control|)
block|{}
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|out
argument_list|,
literal|"'%s'"
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|raw_printf
argument_list|(
name|out
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|z
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|c
operator|=
name|z
index|[
name|i
index|]
operator|)
operator|!=
literal|0
operator|&&
name|c
operator|!=
literal|'\''
condition|;
name|i
operator|++
control|)
block|{}
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|utf8_printf
argument_list|(
name|out
argument_list|,
literal|"%.*s"
argument_list|,
name|i
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|z
operator|+=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
block|{
name|raw_printf
argument_list|(
name|out
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|z
operator|++
expr_stmt|;
block|}
name|raw_printf
argument_list|(
name|out
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
block|}
name|setTextMode
argument_list|(
name|out
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Output the given string as a quoted string using SQL quoting conventions. ** Additionallly , escape the "\n" and "\r" characters so that they do not ** get corrupted by end-of-line translation facilities in some operating ** systems. ** ** This is like output_quoted_string() but with the addition of the \r\n ** escape mechanism. */
end_comment

begin_function
specifier|static
name|void
name|output_quoted_escaped_string
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
specifier|const
name|char
modifier|*
name|z
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|c
decl_stmt|;
name|setBinaryMode
argument_list|(
name|out
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|c
operator|=
name|z
index|[
name|i
index|]
operator|)
operator|!=
literal|0
operator|&&
name|c
operator|!=
literal|'\''
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\r'
condition|;
name|i
operator|++
control|)
block|{}
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|out
argument_list|,
literal|"'%s'"
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|zNL
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|zCR
init|=
literal|0
decl_stmt|;
name|int
name|nNL
init|=
literal|0
decl_stmt|;
name|int
name|nCR
init|=
literal|0
decl_stmt|;
name|char
name|zBuf1
index|[
literal|20
index|]
decl_stmt|,
name|zBuf2
index|[
literal|20
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|z
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|z
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
name|nNL
operator|++
expr_stmt|;
if|if
condition|(
name|z
index|[
name|i
index|]
operator|==
literal|'\r'
condition|)
name|nCR
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nNL
condition|)
block|{
name|raw_printf
argument_list|(
name|out
argument_list|,
literal|"replace("
argument_list|)
expr_stmt|;
name|zNL
operator|=
name|unused_string
argument_list|(
name|z
argument_list|,
literal|"\\n"
argument_list|,
literal|"\\012"
argument_list|,
name|zBuf1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nCR
condition|)
block|{
name|raw_printf
argument_list|(
name|out
argument_list|,
literal|"replace("
argument_list|)
expr_stmt|;
name|zCR
operator|=
name|unused_string
argument_list|(
name|z
argument_list|,
literal|"\\r"
argument_list|,
literal|"\\015"
argument_list|,
name|zBuf2
argument_list|)
expr_stmt|;
block|}
name|raw_printf
argument_list|(
name|out
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|z
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|c
operator|=
name|z
index|[
name|i
index|]
operator|)
operator|!=
literal|0
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\r'
operator|&&
name|c
operator|!=
literal|'\''
condition|;
name|i
operator|++
control|)
block|{}
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|utf8_printf
argument_list|(
name|out
argument_list|,
literal|"%.*s"
argument_list|,
name|i
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|z
operator|+=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
block|{
name|raw_printf
argument_list|(
name|out
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|z
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|raw_printf
argument_list|(
name|out
argument_list|,
literal|"%s"
argument_list|,
name|zNL
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|raw_printf
argument_list|(
name|out
argument_list|,
literal|"%s"
argument_list|,
name|zCR
argument_list|)
expr_stmt|;
block|}
name|raw_printf
argument_list|(
name|out
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nCR
condition|)
block|{
name|raw_printf
argument_list|(
name|out
argument_list|,
literal|",'%s',char(13))"
argument_list|,
name|zCR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nNL
condition|)
block|{
name|raw_printf
argument_list|(
name|out
argument_list|,
literal|",'%s',char(10))"
argument_list|,
name|zNL
argument_list|)
expr_stmt|;
block|}
block|}
name|setTextMode
argument_list|(
name|out
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Output the given string as a quoted according to C or TCL quoting rules. */
end_comment

begin_function
specifier|static
name|void
name|output_c_string
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
specifier|const
name|char
modifier|*
name|z
parameter_list|)
block|{
name|unsigned
name|int
name|c
decl_stmt|;
name|fputc
argument_list|(
literal|'"'
argument_list|,
name|out
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|(
name|z
operator|++
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|fputc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|fputc
argument_list|(
literal|'\\'
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'"'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|fputc
argument_list|(
literal|'\\'
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'t'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|fputc
argument_list|(
literal|'\\'
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
block|{
name|fputc
argument_list|(
literal|'\\'
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'r'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isprint
argument_list|(
name|c
operator|&
literal|0xff
argument_list|)
condition|)
block|{
name|raw_printf
argument_list|(
name|out
argument_list|,
literal|"\\%03o"
argument_list|,
name|c
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
name|fputc
argument_list|(
literal|'"'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Output the given string with characters that are special to ** HTML escaped. */
end_comment

begin_function
specifier|static
name|void
name|output_html_string
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
specifier|const
name|char
modifier|*
name|z
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|z
operator|==
literal|0
condition|)
name|z
operator|=
literal|""
expr_stmt|;
while|while
condition|(
operator|*
name|z
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|z
index|[
name|i
index|]
operator|&&
name|z
index|[
name|i
index|]
operator|!=
literal|'<'
operator|&&
name|z
index|[
name|i
index|]
operator|!=
literal|'&'
operator|&&
name|z
index|[
name|i
index|]
operator|!=
literal|'>'
operator|&&
name|z
index|[
name|i
index|]
operator|!=
literal|'\"'
operator|&&
name|z
index|[
name|i
index|]
operator|!=
literal|'\''
condition|;
name|i
operator|++
control|)
block|{}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|out
argument_list|,
literal|"%.*s"
argument_list|,
name|i
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|z
index|[
name|i
index|]
operator|==
literal|'<'
condition|)
block|{
name|raw_printf
argument_list|(
name|out
argument_list|,
literal|"&lt;"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|z
index|[
name|i
index|]
operator|==
literal|'&'
condition|)
block|{
name|raw_printf
argument_list|(
name|out
argument_list|,
literal|"&amp;"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|z
index|[
name|i
index|]
operator|==
literal|'>'
condition|)
block|{
name|raw_printf
argument_list|(
name|out
argument_list|,
literal|"&gt;"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|z
index|[
name|i
index|]
operator|==
literal|'\"'
condition|)
block|{
name|raw_printf
argument_list|(
name|out
argument_list|,
literal|"&quot;"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|z
index|[
name|i
index|]
operator|==
literal|'\''
condition|)
block|{
name|raw_printf
argument_list|(
name|out
argument_list|,
literal|"&#39;"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
name|z
operator|+=
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** If a field contains any character identified by a 1 in the following ** array, then the string must be quoted for CSV. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|needCsvQuote
index|[]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** Output a single term of CSV.  Actually, p->colSeparator is used for ** the separator, which may or may not be a comma.  p->nullValue is ** the null value.  Strings are quoted if necessary.  The separator ** is only issued if bSep is true. */
end_comment

begin_function
specifier|static
name|void
name|output_csv
parameter_list|(
name|ShellState
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|z
parameter_list|,
name|int
name|bSep
parameter_list|)
block|{
name|FILE
modifier|*
name|out
init|=
name|p
operator|->
name|out
decl_stmt|;
if|if
condition|(
name|z
operator|==
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|out
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|nullValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|int
name|nSep
init|=
name|strlen30
argument_list|(
name|p
operator|->
name|colSeparator
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|z
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|needCsvQuote
index|[
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|z
operator|)
index|[
name|i
index|]
index|]
operator|||
operator|(
name|z
index|[
name|i
index|]
operator|==
name|p
operator|->
name|colSeparator
index|[
literal|0
index|]
operator|&&
operator|(
name|nSep
operator|==
literal|1
operator|||
name|memcmp
argument_list|(
name|z
argument_list|,
name|p
operator|->
name|colSeparator
argument_list|,
name|nSep
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|putc
argument_list|(
literal|'"'
argument_list|,
name|out
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|z
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|z
index|[
name|i
index|]
operator|==
literal|'"'
condition|)
name|putc
argument_list|(
literal|'"'
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|z
index|[
name|i
index|]
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'"'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|utf8_printf
argument_list|(
name|out
argument_list|,
literal|"%s"
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bSep
condition|)
block|{
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|colSeparator
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SIGINT
end_ifdef

begin_comment
comment|/* ** This routine runs when the user presses Ctrl-C */
end_comment

begin_function
specifier|static
name|void
name|interrupt_handler
parameter_list|(
name|int
name|NotUsed
parameter_list|)
block|{
name|UNUSED_PARAMETER
argument_list|(
name|NotUsed
argument_list|)
expr_stmt|;
name|seenInterrupt
operator|++
expr_stmt|;
if|if
condition|(
name|seenInterrupt
operator|>
literal|2
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|globalDb
condition|)
name|sqlite3_interrupt
argument_list|(
name|globalDb
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SQLITE_OMIT_AUTHORIZATION
end_ifndef

begin_comment
comment|/* ** When the ".auth ON" is set, the following authorizer callback is ** invoked.  It always returns SQLITE_OK. */
end_comment

begin_function
specifier|static
name|int
name|shellAuth
parameter_list|(
name|void
modifier|*
name|pClientData
parameter_list|,
name|int
name|op
parameter_list|,
specifier|const
name|char
modifier|*
name|zA1
parameter_list|,
specifier|const
name|char
modifier|*
name|zA2
parameter_list|,
specifier|const
name|char
modifier|*
name|zA3
parameter_list|,
specifier|const
name|char
modifier|*
name|zA4
parameter_list|)
block|{
name|ShellState
modifier|*
name|p
init|=
operator|(
name|ShellState
operator|*
operator|)
name|pClientData
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|azAction
index|[]
init|=
block|{
literal|0
block|,
literal|"CREATE_INDEX"
block|,
literal|"CREATE_TABLE"
block|,
literal|"CREATE_TEMP_INDEX"
block|,
literal|"CREATE_TEMP_TABLE"
block|,
literal|"CREATE_TEMP_TRIGGER"
block|,
literal|"CREATE_TEMP_VIEW"
block|,
literal|"CREATE_TRIGGER"
block|,
literal|"CREATE_VIEW"
block|,
literal|"DELETE"
block|,
literal|"DROP_INDEX"
block|,
literal|"DROP_TABLE"
block|,
literal|"DROP_TEMP_INDEX"
block|,
literal|"DROP_TEMP_TABLE"
block|,
literal|"DROP_TEMP_TRIGGER"
block|,
literal|"DROP_TEMP_VIEW"
block|,
literal|"DROP_TRIGGER"
block|,
literal|"DROP_VIEW"
block|,
literal|"INSERT"
block|,
literal|"PRAGMA"
block|,
literal|"READ"
block|,
literal|"SELECT"
block|,
literal|"TRANSACTION"
block|,
literal|"UPDATE"
block|,
literal|"ATTACH"
block|,
literal|"DETACH"
block|,
literal|"ALTER_TABLE"
block|,
literal|"REINDEX"
block|,
literal|"ANALYZE"
block|,
literal|"CREATE_VTABLE"
block|,
literal|"DROP_VTABLE"
block|,
literal|"FUNCTION"
block|,
literal|"SAVEPOINT"
block|,
literal|"RECURSIVE"
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|az
index|[
literal|4
index|]
decl_stmt|;
name|az
index|[
literal|0
index|]
operator|=
name|zA1
expr_stmt|;
name|az
index|[
literal|1
index|]
operator|=
name|zA2
expr_stmt|;
name|az
index|[
literal|2
index|]
operator|=
name|zA3
expr_stmt|;
name|az
index|[
literal|3
index|]
operator|=
name|zA4
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"authorizer: %s"
argument_list|,
name|azAction
index|[
name|op
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|az
index|[
name|i
index|]
condition|)
block|{
name|output_c_string
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|az
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"NULL"
argument_list|)
expr_stmt|;
block|}
block|}
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|SQLITE_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** Print a schema statement.  Part of MODE_Semi and MODE_Pretty output. ** ** This routine converts some CREATE TABLE statements for shadow tables ** in FTS3/4/5 into CREATE TABLE IF NOT EXISTS statements. */
end_comment

begin_function
specifier|static
name|void
name|printSchemaLine
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
specifier|const
name|char
modifier|*
name|z
parameter_list|,
specifier|const
name|char
modifier|*
name|zTail
parameter_list|)
block|{
if|if
condition|(
name|sqlite3_strglob
argument_list|(
literal|"CREATE TABLE ['\"]*"
argument_list|,
name|z
argument_list|)
operator|==
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|out
argument_list|,
literal|"CREATE TABLE IF NOT EXISTS %s%s"
argument_list|,
name|z
operator|+
literal|13
argument_list|,
name|zTail
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|utf8_printf
argument_list|(
name|out
argument_list|,
literal|"%s%s"
argument_list|,
name|z
argument_list|,
name|zTail
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|printSchemaLineN
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
name|char
modifier|*
name|z
parameter_list|,
name|int
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|zTail
parameter_list|)
block|{
name|char
name|c
init|=
name|z
index|[
name|n
index|]
decl_stmt|;
name|z
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|printSchemaLine
argument_list|(
name|out
argument_list|,
name|z
argument_list|,
name|zTail
argument_list|)
expr_stmt|;
name|z
index|[
name|n
index|]
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** This is the callback routine that the shell ** invokes for each row of a query result. */
end_comment

begin_function
specifier|static
name|int
name|shell_callback
parameter_list|(
name|void
modifier|*
name|pArg
parameter_list|,
name|int
name|nArg
parameter_list|,
comment|/* Number of result columns */
name|char
modifier|*
modifier|*
name|azArg
parameter_list|,
comment|/* Text of each result column */
name|char
modifier|*
modifier|*
name|azCol
parameter_list|,
comment|/* Column names */
name|int
modifier|*
name|aiType
comment|/* Column types */
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ShellState
modifier|*
name|p
init|=
operator|(
name|ShellState
operator|*
operator|)
name|pArg
decl_stmt|;
switch|switch
condition|(
name|p
operator|->
name|cMode
condition|)
block|{
case|case
name|MODE_Line
case|:
block|{
name|int
name|w
init|=
literal|5
decl_stmt|;
if|if
condition|(
name|azArg
operator|==
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
name|strlen30
argument_list|(
name|azCol
index|[
name|i
index|]
condition|?
name|azCol
index|[
name|i
index|]
else|:
literal|""
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|w
condition|)
name|w
operator|=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|cnt
operator|++
operator|>
literal|0
condition|)
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|rowSeparator
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%*s = %s%s"
argument_list|,
name|w
argument_list|,
name|azCol
index|[
name|i
index|]
argument_list|,
name|azArg
index|[
name|i
index|]
condition|?
name|azArg
index|[
name|i
index|]
else|:
name|p
operator|->
name|nullValue
argument_list|,
name|p
operator|->
name|rowSeparator
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|MODE_Explain
case|:
case|case
name|MODE_Column
case|:
block|{
specifier|static
specifier|const
name|int
name|aExplainWidths
index|[]
init|=
block|{
literal|4
block|,
literal|13
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|13
block|,
literal|2
block|,
literal|13
block|}
decl_stmt|;
specifier|const
name|int
modifier|*
name|colWidth
decl_stmt|;
name|int
name|showHdr
decl_stmt|;
name|char
modifier|*
name|rowSep
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|cMode
operator|==
name|MODE_Column
condition|)
block|{
name|colWidth
operator|=
name|p
operator|->
name|colWidth
expr_stmt|;
name|showHdr
operator|=
name|p
operator|->
name|showHeader
expr_stmt|;
name|rowSep
operator|=
name|p
operator|->
name|rowSeparator
expr_stmt|;
block|}
else|else
block|{
name|colWidth
operator|=
name|aExplainWidths
expr_stmt|;
name|showHdr
operator|=
literal|1
expr_stmt|;
name|rowSep
operator|=
name|SEP_Row
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|cnt
operator|++
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|int
name|w
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
name|i
operator|<
name|ArraySize
argument_list|(
name|p
operator|->
name|colWidth
argument_list|)
condition|)
block|{
name|w
operator|=
name|colWidth
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|w
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|==
literal|0
condition|)
block|{
name|w
operator|=
name|strlenChar
argument_list|(
name|azCol
index|[
name|i
index|]
condition|?
name|azCol
index|[
name|i
index|]
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|<
literal|10
condition|)
name|w
operator|=
literal|10
expr_stmt|;
name|n
operator|=
name|strlenChar
argument_list|(
name|azArg
operator|&&
name|azArg
index|[
name|i
index|]
condition|?
name|azArg
index|[
name|i
index|]
else|:
name|p
operator|->
name|nullValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|<
name|n
condition|)
name|w
operator|=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|ArraySize
argument_list|(
name|p
operator|->
name|actualWidth
argument_list|)
condition|)
block|{
name|p
operator|->
name|actualWidth
index|[
name|i
index|]
operator|=
name|w
expr_stmt|;
block|}
if|if
condition|(
name|showHdr
condition|)
block|{
name|utf8_width_print
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|w
argument_list|,
name|azCol
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|i
operator|==
name|nArg
operator|-
literal|1
condition|?
name|rowSep
else|:
literal|"  "
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|showHdr
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|int
name|w
decl_stmt|;
if|if
condition|(
name|i
operator|<
name|ArraySize
argument_list|(
name|p
operator|->
name|actualWidth
argument_list|)
condition|)
block|{
name|w
operator|=
name|p
operator|->
name|actualWidth
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|w
operator|<
literal|0
condition|)
name|w
operator|=
operator|-
name|w
expr_stmt|;
block|}
else|else
block|{
name|w
operator|=
literal|10
expr_stmt|;
block|}
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%-*.*s%s"
argument_list|,
name|w
argument_list|,
name|w
argument_list|,
literal|"----------------------------------------------------------"
literal|"----------------------------------------------------------"
argument_list|,
name|i
operator|==
name|nArg
operator|-
literal|1
condition|?
name|rowSep
else|:
literal|"  "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|azArg
operator|==
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|int
name|w
decl_stmt|;
if|if
condition|(
name|i
operator|<
name|ArraySize
argument_list|(
name|p
operator|->
name|actualWidth
argument_list|)
condition|)
block|{
name|w
operator|=
name|p
operator|->
name|actualWidth
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|w
operator|=
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|cMode
operator|==
name|MODE_Explain
operator|&&
name|azArg
index|[
name|i
index|]
operator|&&
name|strlenChar
argument_list|(
name|azArg
index|[
name|i
index|]
argument_list|)
operator|>
name|w
condition|)
block|{
name|w
operator|=
name|strlenChar
argument_list|(
name|azArg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|1
operator|&&
name|p
operator|->
name|aiIndent
operator|&&
name|p
operator|->
name|pStmt
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|iIndent
operator|<
name|p
operator|->
name|nIndent
condition|)
block|{
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%*.s"
argument_list|,
name|p
operator|->
name|aiIndent
index|[
name|p
operator|->
name|iIndent
index|]
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|iIndent
operator|++
expr_stmt|;
block|}
name|utf8_width_print
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|w
argument_list|,
name|azArg
index|[
name|i
index|]
condition|?
name|azArg
index|[
name|i
index|]
else|:
name|p
operator|->
name|nullValue
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|i
operator|==
name|nArg
operator|-
literal|1
condition|?
name|rowSep
else|:
literal|"  "
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|MODE_Semi
case|:
block|{
comment|/* .schema and .fullschema output */
name|printSchemaLine
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MODE_Pretty
case|:
block|{
comment|/* .schema and .fullschema with --indent */
name|char
modifier|*
name|z
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|nParen
init|=
literal|0
decl_stmt|;
name|char
name|cEnd
init|=
literal|0
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|nLine
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|nArg
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|azArg
index|[
literal|0
index|]
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|sqlite3_strlike
argument_list|(
literal|"CREATE VIEW%"
argument_list|,
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|||
name|sqlite3_strlike
argument_list|(
literal|"CREATE TRIG%"
argument_list|,
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s;\n"
argument_list|,
name|azArg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|z
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"%s"
argument_list|,
name|azArg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|IsSpace
argument_list|(
name|z
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{}
for|for
control|(
init|;
operator|(
name|c
operator|=
name|z
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|IsSpace
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|IsSpace
argument_list|(
name|z
index|[
name|j
operator|-
literal|1
index|]
argument_list|)
operator|||
name|z
index|[
name|j
operator|-
literal|1
index|]
operator|==
literal|'('
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'('
operator|||
name|c
operator|==
literal|')'
operator|)
operator|&&
name|j
operator|>
literal|0
operator|&&
name|IsSpace
argument_list|(
name|z
index|[
name|j
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|j
operator|--
expr_stmt|;
block|}
name|z
index|[
name|j
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
while|while
condition|(
name|j
operator|>
literal|0
operator|&&
name|IsSpace
argument_list|(
name|z
index|[
name|j
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|j
operator|--
expr_stmt|;
block|}
name|z
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strlen30
argument_list|(
name|z
argument_list|)
operator|>=
literal|79
condition|)
block|{
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
operator|(
name|c
operator|=
name|z
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
name|cEnd
condition|)
block|{
name|cEnd
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'"'
operator|||
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'`'
condition|)
block|{
name|cEnd
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'['
condition|)
block|{
name|cEnd
operator|=
literal|']'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
block|{
name|nParen
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
block|{
name|nParen
operator|--
expr_stmt|;
if|if
condition|(
name|nLine
operator|>
literal|0
operator|&&
name|nParen
operator|==
literal|0
operator|&&
name|j
operator|>
literal|0
condition|)
block|{
name|printSchemaLineN
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|z
argument_list|,
name|j
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|z
index|[
name|j
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|nParen
operator|==
literal|1
operator|&&
operator|(
name|c
operator|==
literal|'('
operator|||
name|c
operator|==
literal|','
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|j
operator|--
expr_stmt|;
name|printSchemaLineN
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|z
argument_list|,
name|j
argument_list|,
literal|"\n  "
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|nLine
operator|++
expr_stmt|;
while|while
condition|(
name|IsSpace
argument_list|(
name|z
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
name|z
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|printSchemaLine
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|z
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|z
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MODE_List
case|:
block|{
if|if
condition|(
name|p
operator|->
name|cnt
operator|++
operator|==
literal|0
operator|&&
name|p
operator|->
name|showHeader
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s%s"
argument_list|,
name|azCol
index|[
name|i
index|]
argument_list|,
name|i
operator|==
name|nArg
operator|-
literal|1
condition|?
name|p
operator|->
name|rowSeparator
else|:
name|p
operator|->
name|colSeparator
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|azArg
operator|==
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|z
init|=
name|azArg
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|z
operator|==
literal|0
condition|)
name|z
operator|=
name|p
operator|->
name|nullValue
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|nArg
operator|-
literal|1
condition|)
block|{
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|colSeparator
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|rowSeparator
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|MODE_Html
case|:
block|{
if|if
condition|(
name|p
operator|->
name|cnt
operator|++
operator|==
literal|0
operator|&&
name|p
operator|->
name|showHeader
condition|)
block|{
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"<TR>"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"<TH>"
argument_list|)
expr_stmt|;
name|output_html_string
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|azCol
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"</TH>\n"
argument_list|)
expr_stmt|;
block|}
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"</TR>\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|azArg
operator|==
literal|0
condition|)
break|break;
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"<TR>"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"<TD>"
argument_list|)
expr_stmt|;
name|output_html_string
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|azArg
index|[
name|i
index|]
condition|?
name|azArg
index|[
name|i
index|]
else|:
name|p
operator|->
name|nullValue
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"</TD>\n"
argument_list|)
expr_stmt|;
block|}
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"</TR>\n"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MODE_Tcl
case|:
block|{
if|if
condition|(
name|p
operator|->
name|cnt
operator|++
operator|==
literal|0
operator|&&
name|p
operator|->
name|showHeader
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|output_c_string
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|azCol
index|[
name|i
index|]
condition|?
name|azCol
index|[
name|i
index|]
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|nArg
operator|-
literal|1
condition|)
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|colSeparator
argument_list|)
expr_stmt|;
block|}
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|rowSeparator
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|azArg
operator|==
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|output_c_string
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|azArg
index|[
name|i
index|]
condition|?
name|azArg
index|[
name|i
index|]
else|:
name|p
operator|->
name|nullValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|nArg
operator|-
literal|1
condition|)
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|colSeparator
argument_list|)
expr_stmt|;
block|}
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|rowSeparator
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MODE_Csv
case|:
block|{
name|setBinaryMode
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|cnt
operator|++
operator|==
literal|0
operator|&&
name|p
operator|->
name|showHeader
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|output_csv
argument_list|(
name|p
argument_list|,
name|azCol
index|[
name|i
index|]
condition|?
name|azCol
index|[
name|i
index|]
else|:
literal|""
argument_list|,
name|i
operator|<
name|nArg
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|rowSeparator
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nArg
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|output_csv
argument_list|(
name|p
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|,
name|i
operator|<
name|nArg
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|rowSeparator
argument_list|)
expr_stmt|;
block|}
name|setTextMode
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MODE_Insert
case|:
block|{
if|if
condition|(
name|azArg
operator|==
literal|0
condition|)
break|break;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"INSERT INTO %s"
argument_list|,
name|p
operator|->
name|zDestTable
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|showHeader
condition|)
block|{
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|quoteChar
argument_list|(
name|azCol
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|char
modifier|*
name|z
init|=
name|sqlite3_mprintf
argument_list|(
literal|"\"%w\""
argument_list|,
name|azCol
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|z
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|azCol
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|cnt
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|i
operator|>
literal|0
condition|?
literal|","
else|:
literal|" VALUES("
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|azArg
index|[
name|i
index|]
operator|==
literal|0
operator|)
operator|||
operator|(
name|aiType
operator|&&
name|aiType
index|[
name|i
index|]
operator|==
name|SQLITE_NULL
operator|)
condition|)
block|{
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"NULL"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aiType
operator|&&
name|aiType
index|[
name|i
index|]
operator|==
name|SQLITE_TEXT
condition|)
block|{
if|if
condition|(
name|ShellHasFlag
argument_list|(
name|p
argument_list|,
name|SHFLG_Newlines
argument_list|)
condition|)
block|{
name|output_quoted_string
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_quoted_escaped_string
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|aiType
operator|&&
name|aiType
index|[
name|i
index|]
operator|==
name|SQLITE_INTEGER
condition|)
block|{
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aiType
operator|&&
name|aiType
index|[
name|i
index|]
operator|==
name|SQLITE_FLOAT
condition|)
block|{
name|char
name|z
index|[
literal|50
index|]
decl_stmt|;
name|double
name|r
init|=
name|sqlite3_column_double
argument_list|(
name|p
operator|->
name|pStmt
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|sqlite3_snprintf
argument_list|(
literal|50
argument_list|,
name|z
argument_list|,
literal|"%!.20g"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aiType
operator|&&
name|aiType
index|[
name|i
index|]
operator|==
name|SQLITE_BLOB
operator|&&
name|p
operator|->
name|pStmt
condition|)
block|{
specifier|const
name|void
modifier|*
name|pBlob
init|=
name|sqlite3_column_blob
argument_list|(
name|p
operator|->
name|pStmt
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|nBlob
init|=
name|sqlite3_column_bytes
argument_list|(
name|p
operator|->
name|pStmt
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|output_hex_blob
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|pBlob
argument_list|,
name|nBlob
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isNumber
argument_list|(
name|azArg
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ShellHasFlag
argument_list|(
name|p
argument_list|,
name|SHFLG_Newlines
argument_list|)
condition|)
block|{
name|output_quoted_string
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_quoted_escaped_string
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|");\n"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MODE_Quote
case|:
block|{
if|if
condition|(
name|azArg
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|p
operator|->
name|cnt
operator|==
literal|0
operator|&&
name|p
operator|->
name|showHeader
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|azCol
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|cnt
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|azArg
index|[
name|i
index|]
operator|==
literal|0
operator|)
operator|||
operator|(
name|aiType
operator|&&
name|aiType
index|[
name|i
index|]
operator|==
name|SQLITE_NULL
operator|)
condition|)
block|{
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"NULL"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aiType
operator|&&
name|aiType
index|[
name|i
index|]
operator|==
name|SQLITE_TEXT
condition|)
block|{
name|output_quoted_string
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aiType
operator|&&
name|aiType
index|[
name|i
index|]
operator|==
name|SQLITE_INTEGER
condition|)
block|{
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aiType
operator|&&
name|aiType
index|[
name|i
index|]
operator|==
name|SQLITE_FLOAT
condition|)
block|{
name|char
name|z
index|[
literal|50
index|]
decl_stmt|;
name|double
name|r
init|=
name|sqlite3_column_double
argument_list|(
name|p
operator|->
name|pStmt
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|sqlite3_snprintf
argument_list|(
literal|50
argument_list|,
name|z
argument_list|,
literal|"%!.20g"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aiType
operator|&&
name|aiType
index|[
name|i
index|]
operator|==
name|SQLITE_BLOB
operator|&&
name|p
operator|->
name|pStmt
condition|)
block|{
specifier|const
name|void
modifier|*
name|pBlob
init|=
name|sqlite3_column_blob
argument_list|(
name|p
operator|->
name|pStmt
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|nBlob
init|=
name|sqlite3_column_bytes
argument_list|(
name|p
operator|->
name|pStmt
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|output_hex_blob
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|pBlob
argument_list|,
name|nBlob
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isNumber
argument_list|(
name|azArg
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_quoted_string
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MODE_Ascii
case|:
block|{
if|if
condition|(
name|p
operator|->
name|cnt
operator|++
operator|==
literal|0
operator|&&
name|p
operator|->
name|showHeader
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|colSeparator
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|azCol
index|[
name|i
index|]
condition|?
name|azCol
index|[
name|i
index|]
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|rowSeparator
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|azArg
operator|==
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|colSeparator
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|azArg
index|[
name|i
index|]
condition|?
name|azArg
index|[
name|i
index|]
else|:
name|p
operator|->
name|nullValue
argument_list|)
expr_stmt|;
block|}
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|rowSeparator
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ** This is the callback routine that the SQLite library ** invokes for each row of a query result. */
end_comment

begin_function
specifier|static
name|int
name|callback
parameter_list|(
name|void
modifier|*
name|pArg
parameter_list|,
name|int
name|nArg
parameter_list|,
name|char
modifier|*
modifier|*
name|azArg
parameter_list|,
name|char
modifier|*
modifier|*
name|azCol
parameter_list|)
block|{
comment|/* since we don't have type info, call the shell_callback with a NULL value */
return|return
name|shell_callback
argument_list|(
name|pArg
argument_list|,
name|nArg
argument_list|,
name|azArg
argument_list|,
name|azCol
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ** This is the callback routine from sqlite3_exec() that appends all ** output onto the end of a ShellText object. */
end_comment

begin_function
specifier|static
name|int
name|captureOutputCallback
parameter_list|(
name|void
modifier|*
name|pArg
parameter_list|,
name|int
name|nArg
parameter_list|,
name|char
modifier|*
modifier|*
name|azArg
parameter_list|,
name|char
modifier|*
modifier|*
name|az
parameter_list|)
block|{
name|ShellText
modifier|*
name|p
init|=
operator|(
name|ShellText
operator|*
operator|)
name|pArg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|UNUSED_PARAMETER
argument_list|(
name|az
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|n
condition|)
name|appendText
argument_list|(
name|p
argument_list|,
literal|"|"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
condition|)
name|appendText
argument_list|(
name|p
argument_list|,
literal|","
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|azArg
index|[
name|i
index|]
condition|)
name|appendText
argument_list|(
name|p
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ** Generate an appropriate SELFTEST table in the main database. */
end_comment

begin_function
specifier|static
name|void
name|createSelftestTable
parameter_list|(
name|ShellState
modifier|*
name|p
parameter_list|)
block|{
name|char
modifier|*
name|zErrMsg
init|=
literal|0
decl_stmt|;
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"SAVEPOINT selftest_init;\n"
literal|"CREATE TABLE IF NOT EXISTS selftest(\n"
literal|"  tno INTEGER PRIMARY KEY,\n"
comment|/* Test number */
literal|"  op TEXT,\n"
comment|/* Operator:  memo run */
literal|"  cmd TEXT,\n"
comment|/* Command text */
literal|"  ans TEXT\n"
comment|/* Desired answer */
literal|");"
literal|"CREATE TEMP TABLE [_shell$self](op,cmd,ans);\n"
literal|"INSERT INTO [_shell$self](rowid,op,cmd)\n"
literal|"  VALUES(coalesce((SELECT (max(tno)+100)/10 FROM selftest),10),\n"
literal|"         'memo','Tests generated by --init');\n"
literal|"INSERT INTO [_shell$self]\n"
literal|"  SELECT 'run',\n"
literal|"    'SELECT hex(sha3_query(''SELECT type,name,tbl_name,sql "
literal|"FROM sqlite_master ORDER BY 2'',224))',\n"
literal|"    hex(sha3_query('SELECT type,name,tbl_name,sql "
literal|"FROM sqlite_master ORDER BY 2',224));\n"
literal|"INSERT INTO [_shell$self]\n"
literal|"  SELECT 'run',"
literal|"    'SELECT hex(sha3_query(''SELECT * FROM \"' ||"
literal|"        printf('%w',name) || '\" NOT INDEXED'',224))',\n"
literal|"    hex(sha3_query(printf('SELECT * FROM \"%w\" NOT INDEXED',name),224))\n"
literal|"  FROM (\n"
literal|"    SELECT name FROM sqlite_master\n"
literal|"     WHERE type='table'\n"
literal|"       AND name<>'selftest'\n"
literal|"       AND coalesce(rootpage,0)>0\n"
literal|"  )\n"
literal|" ORDER BY name;\n"
literal|"INSERT INTO [_shell$self]\n"
literal|"  VALUES('run','PRAGMA integrity_check','ok');\n"
literal|"INSERT INTO selftest(tno,op,cmd,ans)"
literal|"  SELECT rowid*10,op,cmd,ans FROM [_shell$self];\n"
literal|"DROP TABLE [_shell$self];"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|zErrMsg
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"SELFTEST initialization failure: %s\n"
argument_list|,
name|zErrMsg
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zErrMsg
argument_list|)
expr_stmt|;
block|}
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"RELEASE selftest_init"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Set the destination table field of the ShellState structure to ** the name of the table given.  Escape any quote characters in the ** table name. */
end_comment

begin_function
specifier|static
name|void
name|set_table_name
parameter_list|(
name|ShellState
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|zName
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|int
name|cQuote
decl_stmt|;
name|char
modifier|*
name|z
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|zDestTable
condition|)
block|{
name|free
argument_list|(
name|p
operator|->
name|zDestTable
argument_list|)
expr_stmt|;
name|p
operator|->
name|zDestTable
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|zName
operator|==
literal|0
condition|)
return|return;
name|cQuote
operator|=
name|quoteChar
argument_list|(
name|zName
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen30
argument_list|(
name|zName
argument_list|)
expr_stmt|;
if|if
condition|(
name|cQuote
condition|)
name|n
operator|+=
name|n
operator|+
literal|2
expr_stmt|;
name|z
operator|=
name|p
operator|->
name|zDestTable
operator|=
name|malloc
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|==
literal|0
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cQuote
condition|)
name|z
index|[
name|n
operator|++
index|]
operator|=
name|cQuote
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|zName
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|z
index|[
name|n
operator|++
index|]
operator|=
name|zName
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|zName
index|[
name|i
index|]
operator|==
name|cQuote
condition|)
name|z
index|[
name|n
operator|++
index|]
operator|=
name|cQuote
expr_stmt|;
block|}
if|if
condition|(
name|cQuote
condition|)
name|z
index|[
name|n
operator|++
index|]
operator|=
name|cQuote
expr_stmt|;
name|z
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Execute a query statement that will generate SQL output.  Print ** the result columns, comma-separated, on a line and then add a ** semicolon terminator to the end of that line. ** ** If the number of columns is 1 and that column contains text "--" ** then write the semicolon on a separate line.  That way, if a ** "--" comment occurs at the end of the statement, the comment ** won't consume the semicolon terminator. */
end_comment

begin_function
specifier|static
name|int
name|run_table_dump_query
parameter_list|(
name|ShellState
modifier|*
name|p
parameter_list|,
comment|/* Query context */
specifier|const
name|char
modifier|*
name|zSelect
parameter_list|,
comment|/* SELECT statement to extract content */
specifier|const
name|char
modifier|*
name|zFirstRow
comment|/* Print before first row, if not NULL */
parameter_list|)
block|{
name|sqlite3_stmt
modifier|*
name|pSelect
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|int
name|nResult
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zSelect
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pSelect
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
operator|||
operator|!
name|pSelect
condition|)
block|{
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"/**** ERROR: (%d) %s *****/\n"
argument_list|,
name|rc
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|&
literal|0xff
operator|)
operator|!=
name|SQLITE_CORRUPT
condition|)
name|p
operator|->
name|nErr
operator|++
expr_stmt|;
return|return
name|rc
return|;
block|}
name|rc
operator|=
name|sqlite3_step
argument_list|(
name|pSelect
argument_list|)
expr_stmt|;
name|nResult
operator|=
name|sqlite3_column_count
argument_list|(
name|pSelect
argument_list|)
expr_stmt|;
while|while
condition|(
name|rc
operator|==
name|SQLITE_ROW
condition|)
block|{
if|if
condition|(
name|zFirstRow
condition|)
block|{
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|zFirstRow
argument_list|)
expr_stmt|;
name|zFirstRow
operator|=
literal|0
expr_stmt|;
block|}
name|z
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pSelect
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|z
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nResult
condition|;
name|i
operator|++
control|)
block|{
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|",%s"
argument_list|,
name|sqlite3_column_text
argument_list|(
name|pSelect
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|z
operator|==
literal|0
condition|)
name|z
operator|=
literal|""
expr_stmt|;
while|while
condition|(
name|z
index|[
literal|0
index|]
operator|&&
operator|(
name|z
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
name|z
index|[
literal|1
index|]
operator|!=
literal|'-'
operator|)
condition|)
name|z
operator|++
expr_stmt|;
if|if
condition|(
name|z
index|[
literal|0
index|]
condition|)
block|{
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n;\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|sqlite3_step
argument_list|(
name|pSelect
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|sqlite3_finalize
argument_list|(
name|pSelect
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
condition|)
block|{
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"/**** ERROR: (%d) %s *****/\n"
argument_list|,
name|rc
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|&
literal|0xff
operator|)
operator|!=
name|SQLITE_CORRUPT
condition|)
name|p
operator|->
name|nErr
operator|++
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* ** Allocate space and save off current error string. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|save_err_msg
parameter_list|(
name|sqlite3
modifier|*
name|db
comment|/* Database to query */
parameter_list|)
block|{
name|int
name|nErrMsg
init|=
literal|1
operator|+
name|strlen30
argument_list|(
name|sqlite3_errmsg
argument_list|(
name|db
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|zErrMsg
init|=
name|sqlite3_malloc64
argument_list|(
name|nErrMsg
argument_list|)
decl_stmt|;
if|if
condition|(
name|zErrMsg
condition|)
block|{
name|memcpy
argument_list|(
name|zErrMsg
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|db
argument_list|)
argument_list|,
name|nErrMsg
argument_list|)
expr_stmt|;
block|}
return|return
name|zErrMsg
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_comment
comment|/* ** Attempt to display I/O stats on Linux using /proc/PID/io */
end_comment

begin_function
specifier|static
name|void
name|displayLinuxIoStats
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|)
block|{
name|FILE
modifier|*
name|in
decl_stmt|;
name|char
name|z
index|[
literal|200
index|]
decl_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|z
argument_list|)
argument_list|,
name|z
argument_list|,
literal|"/proc/%d/io"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|in
operator|=
name|fopen
argument_list|(
name|z
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
literal|0
condition|)
return|return;
while|while
condition|(
name|fgets
argument_list|(
name|z
argument_list|,
sizeof|sizeof
argument_list|(
name|z
argument_list|)
argument_list|,
name|in
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|zPattern
decl_stmt|;
specifier|const
name|char
modifier|*
name|zDesc
decl_stmt|;
block|}
name|aTrans
index|[]
init|=
block|{
block|{
literal|"rchar: "
block|,
literal|"Bytes received by read():"
block|}
block|,
block|{
literal|"wchar: "
block|,
literal|"Bytes sent to write():"
block|}
block|,
block|{
literal|"syscr: "
block|,
literal|"Read() system calls:"
block|}
block|,
block|{
literal|"syscw: "
block|,
literal|"Write() system calls:"
block|}
block|,
block|{
literal|"read_bytes: "
block|,
literal|"Bytes read from storage:"
block|}
block|,
block|{
literal|"write_bytes: "
block|,
literal|"Bytes written to storage:"
block|}
block|,
block|{
literal|"cancelled_write_bytes: "
block|,
literal|"Cancelled write bytes:"
block|}
block|,     }
struct|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|aTrans
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|n
init|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|aTrans
index|[
name|i
index|]
operator|.
name|zPattern
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|aTrans
index|[
name|i
index|]
operator|.
name|zPattern
argument_list|,
name|z
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|out
argument_list|,
literal|"%-36s %s"
argument_list|,
name|aTrans
index|[
name|i
index|]
operator|.
name|zDesc
argument_list|,
operator|&
name|z
index|[
name|n
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** Display a single line of status using 64-bit values. */
end_comment

begin_function
specifier|static
name|void
name|displayStatLine
parameter_list|(
name|ShellState
modifier|*
name|p
parameter_list|,
comment|/* The shell context */
name|char
modifier|*
name|zLabel
parameter_list|,
comment|/* Label for this one line */
name|char
modifier|*
name|zFormat
parameter_list|,
comment|/* Format for the result */
name|int
name|iStatusCtrl
parameter_list|,
comment|/* Which status to display */
name|int
name|bReset
comment|/* True to reset the stats */
parameter_list|)
block|{
name|sqlite3_int64
name|iCur
init|=
operator|-
literal|1
decl_stmt|;
name|sqlite3_int64
name|iHiwtr
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nPercent
decl_stmt|;
name|char
name|zLine
index|[
literal|200
index|]
decl_stmt|;
name|sqlite3_status64
argument_list|(
name|iStatusCtrl
argument_list|,
operator|&
name|iCur
argument_list|,
operator|&
name|iHiwtr
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|nPercent
operator|=
literal|0
init|;
name|zFormat
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|zFormat
index|[
name|i
index|]
operator|==
literal|'%'
condition|)
name|nPercent
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nPercent
operator|>
literal|1
condition|)
block|{
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|zLine
argument_list|)
argument_list|,
name|zLine
argument_list|,
name|zFormat
argument_list|,
name|iCur
argument_list|,
name|iHiwtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|zLine
argument_list|)
argument_list|,
name|zLine
argument_list|,
name|zFormat
argument_list|,
name|iHiwtr
argument_list|)
expr_stmt|;
block|}
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%-36s %s\n"
argument_list|,
name|zLabel
argument_list|,
name|zLine
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Display memory stats. */
end_comment

begin_function
specifier|static
name|int
name|display_stats
parameter_list|(
name|sqlite3
modifier|*
name|db
parameter_list|,
comment|/* Database to query */
name|ShellState
modifier|*
name|pArg
parameter_list|,
comment|/* Pointer to ShellState */
name|int
name|bReset
comment|/* True to reset the stats */
parameter_list|)
block|{
name|int
name|iCur
decl_stmt|;
name|int
name|iHiwtr
decl_stmt|;
if|if
condition|(
name|pArg
operator|&&
name|pArg
operator|->
name|out
condition|)
block|{
name|displayStatLine
argument_list|(
name|pArg
argument_list|,
literal|"Memory Used:"
argument_list|,
literal|"%lld (max %lld) bytes"
argument_list|,
name|SQLITE_STATUS_MEMORY_USED
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|displayStatLine
argument_list|(
name|pArg
argument_list|,
literal|"Number of Outstanding Allocations:"
argument_list|,
literal|"%lld (max %lld)"
argument_list|,
name|SQLITE_STATUS_MALLOC_COUNT
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
if|if
condition|(
name|pArg
operator|->
name|shellFlgs
operator|&
name|SHFLG_Pagecache
condition|)
block|{
name|displayStatLine
argument_list|(
name|pArg
argument_list|,
literal|"Number of Pcache Pages Used:"
argument_list|,
literal|"%lld (max %lld) pages"
argument_list|,
name|SQLITE_STATUS_PAGECACHE_USED
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
block|}
name|displayStatLine
argument_list|(
name|pArg
argument_list|,
literal|"Number of Pcache Overflow Bytes:"
argument_list|,
literal|"%lld (max %lld) bytes"
argument_list|,
name|SQLITE_STATUS_PAGECACHE_OVERFLOW
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
if|if
condition|(
name|pArg
operator|->
name|shellFlgs
operator|&
name|SHFLG_Scratch
condition|)
block|{
name|displayStatLine
argument_list|(
name|pArg
argument_list|,
literal|"Number of Scratch Allocations Used:"
argument_list|,
literal|"%lld (max %lld)"
argument_list|,
name|SQLITE_STATUS_SCRATCH_USED
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
block|}
name|displayStatLine
argument_list|(
name|pArg
argument_list|,
literal|"Number of Scratch Overflow Bytes:"
argument_list|,
literal|"%lld (max %lld) bytes"
argument_list|,
name|SQLITE_STATUS_SCRATCH_OVERFLOW
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|displayStatLine
argument_list|(
name|pArg
argument_list|,
literal|"Largest Allocation:"
argument_list|,
literal|"%lld bytes"
argument_list|,
name|SQLITE_STATUS_MALLOC_SIZE
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|displayStatLine
argument_list|(
name|pArg
argument_list|,
literal|"Largest Pcache Allocation:"
argument_list|,
literal|"%lld bytes"
argument_list|,
name|SQLITE_STATUS_PAGECACHE_SIZE
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|displayStatLine
argument_list|(
name|pArg
argument_list|,
literal|"Largest Scratch Allocation:"
argument_list|,
literal|"%lld bytes"
argument_list|,
name|SQLITE_STATUS_SCRATCH_SIZE
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|YYTRACKMAXSTACKDEPTH
name|displayStatLine
argument_list|(
name|pArg
argument_list|,
literal|"Deepest Parser Stack:"
argument_list|,
literal|"%lld (max %lld)"
argument_list|,
name|SQLITE_STATUS_PARSER_STACK
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|pArg
operator|&&
name|pArg
operator|->
name|out
operator|&&
name|db
condition|)
block|{
if|if
condition|(
name|pArg
operator|->
name|shellFlgs
operator|&
name|SHFLG_Lookaside
condition|)
block|{
name|iHiwtr
operator|=
name|iCur
operator|=
operator|-
literal|1
expr_stmt|;
name|sqlite3_db_status
argument_list|(
name|db
argument_list|,
name|SQLITE_DBSTATUS_LOOKASIDE_USED
argument_list|,
operator|&
name|iCur
argument_list|,
operator|&
name|iHiwtr
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Lookaside Slots Used:                %d (max %d)\n"
argument_list|,
name|iCur
argument_list|,
name|iHiwtr
argument_list|)
expr_stmt|;
name|sqlite3_db_status
argument_list|(
name|db
argument_list|,
name|SQLITE_DBSTATUS_LOOKASIDE_HIT
argument_list|,
operator|&
name|iCur
argument_list|,
operator|&
name|iHiwtr
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Successful lookaside attempts:       %d\n"
argument_list|,
name|iHiwtr
argument_list|)
expr_stmt|;
name|sqlite3_db_status
argument_list|(
name|db
argument_list|,
name|SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE
argument_list|,
operator|&
name|iCur
argument_list|,
operator|&
name|iHiwtr
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Lookaside failures due to size:      %d\n"
argument_list|,
name|iHiwtr
argument_list|)
expr_stmt|;
name|sqlite3_db_status
argument_list|(
name|db
argument_list|,
name|SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL
argument_list|,
operator|&
name|iCur
argument_list|,
operator|&
name|iHiwtr
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Lookaside failures due to OOM:       %d\n"
argument_list|,
name|iHiwtr
argument_list|)
expr_stmt|;
block|}
name|iHiwtr
operator|=
name|iCur
operator|=
operator|-
literal|1
expr_stmt|;
name|sqlite3_db_status
argument_list|(
name|db
argument_list|,
name|SQLITE_DBSTATUS_CACHE_USED
argument_list|,
operator|&
name|iCur
argument_list|,
operator|&
name|iHiwtr
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Pager Heap Usage:                    %d bytes\n"
argument_list|,
name|iCur
argument_list|)
expr_stmt|;
name|iHiwtr
operator|=
name|iCur
operator|=
operator|-
literal|1
expr_stmt|;
name|sqlite3_db_status
argument_list|(
name|db
argument_list|,
name|SQLITE_DBSTATUS_CACHE_HIT
argument_list|,
operator|&
name|iCur
argument_list|,
operator|&
name|iHiwtr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Page cache hits:                     %d\n"
argument_list|,
name|iCur
argument_list|)
expr_stmt|;
name|iHiwtr
operator|=
name|iCur
operator|=
operator|-
literal|1
expr_stmt|;
name|sqlite3_db_status
argument_list|(
name|db
argument_list|,
name|SQLITE_DBSTATUS_CACHE_MISS
argument_list|,
operator|&
name|iCur
argument_list|,
operator|&
name|iHiwtr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Page cache misses:                   %d\n"
argument_list|,
name|iCur
argument_list|)
expr_stmt|;
name|iHiwtr
operator|=
name|iCur
operator|=
operator|-
literal|1
expr_stmt|;
name|sqlite3_db_status
argument_list|(
name|db
argument_list|,
name|SQLITE_DBSTATUS_CACHE_WRITE
argument_list|,
operator|&
name|iCur
argument_list|,
operator|&
name|iHiwtr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Page cache writes:                   %d\n"
argument_list|,
name|iCur
argument_list|)
expr_stmt|;
name|iHiwtr
operator|=
name|iCur
operator|=
operator|-
literal|1
expr_stmt|;
name|sqlite3_db_status
argument_list|(
name|db
argument_list|,
name|SQLITE_DBSTATUS_SCHEMA_USED
argument_list|,
operator|&
name|iCur
argument_list|,
operator|&
name|iHiwtr
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Schema Heap Usage:                   %d bytes\n"
argument_list|,
name|iCur
argument_list|)
expr_stmt|;
name|iHiwtr
operator|=
name|iCur
operator|=
operator|-
literal|1
expr_stmt|;
name|sqlite3_db_status
argument_list|(
name|db
argument_list|,
name|SQLITE_DBSTATUS_STMT_USED
argument_list|,
operator|&
name|iCur
argument_list|,
operator|&
name|iHiwtr
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Statement Heap/Lookaside Usage:      %d bytes\n"
argument_list|,
name|iCur
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pArg
operator|&&
name|pArg
operator|->
name|out
operator|&&
name|db
operator|&&
name|pArg
operator|->
name|pStmt
condition|)
block|{
name|iCur
operator|=
name|sqlite3_stmt_status
argument_list|(
name|pArg
operator|->
name|pStmt
argument_list|,
name|SQLITE_STMTSTATUS_FULLSCAN_STEP
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Fullscan Steps:                      %d\n"
argument_list|,
name|iCur
argument_list|)
expr_stmt|;
name|iCur
operator|=
name|sqlite3_stmt_status
argument_list|(
name|pArg
operator|->
name|pStmt
argument_list|,
name|SQLITE_STMTSTATUS_SORT
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Sort Operations:                     %d\n"
argument_list|,
name|iCur
argument_list|)
expr_stmt|;
name|iCur
operator|=
name|sqlite3_stmt_status
argument_list|(
name|pArg
operator|->
name|pStmt
argument_list|,
name|SQLITE_STMTSTATUS_AUTOINDEX
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Autoindex Inserts:                   %d\n"
argument_list|,
name|iCur
argument_list|)
expr_stmt|;
name|iCur
operator|=
name|sqlite3_stmt_status
argument_list|(
name|pArg
operator|->
name|pStmt
argument_list|,
name|SQLITE_STMTSTATUS_VM_STEP
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Virtual Machine Steps:               %d\n"
argument_list|,
name|iCur
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__linux__
name|displayLinuxIoStats
argument_list|(
name|pArg
operator|->
name|out
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Do not remove this machine readable comment: extra-stats-output-here */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ** Display scan stats. */
end_comment

begin_function
specifier|static
name|void
name|display_scanstats
parameter_list|(
name|sqlite3
modifier|*
name|db
parameter_list|,
comment|/* Database to query */
name|ShellState
modifier|*
name|pArg
comment|/* Pointer to ShellState */
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|SQLITE_ENABLE_STMT_SCANSTATUS
name|UNUSED_PARAMETER
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|UNUSED_PARAMETER
argument_list|(
name|pArg
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
name|i
decl_stmt|,
name|k
decl_stmt|,
name|n
decl_stmt|,
name|mx
decl_stmt|;
name|raw_printf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"-------- scanstats --------\n"
argument_list|)
expr_stmt|;
name|mx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<=
name|mx
condition|;
name|k
operator|++
control|)
block|{
name|double
name|rEstLoop
init|=
literal|1.0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|n
operator|=
literal|0
init|;
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|sqlite3_stmt
modifier|*
name|p
init|=
name|pArg
operator|->
name|pStmt
decl_stmt|;
name|sqlite3_int64
name|nLoop
decl_stmt|,
name|nVisit
decl_stmt|;
name|double
name|rEst
decl_stmt|;
name|int
name|iSid
decl_stmt|;
specifier|const
name|char
modifier|*
name|zExplain
decl_stmt|;
if|if
condition|(
name|sqlite3_stmt_scanstatus
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|SQLITE_SCANSTAT_NLOOP
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|nLoop
argument_list|)
condition|)
block|{
break|break;
block|}
name|sqlite3_stmt_scanstatus
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|SQLITE_SCANSTAT_SELECTID
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|iSid
argument_list|)
expr_stmt|;
if|if
condition|(
name|iSid
operator|>
name|mx
condition|)
name|mx
operator|=
name|iSid
expr_stmt|;
if|if
condition|(
name|iSid
operator|!=
name|k
condition|)
continue|continue;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|rEstLoop
operator|=
operator|(
name|double
operator|)
name|nLoop
expr_stmt|;
if|if
condition|(
name|k
operator|>
literal|0
condition|)
name|raw_printf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"-------- subquery %d -------\n"
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
name|n
operator|++
expr_stmt|;
name|sqlite3_stmt_scanstatus
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|SQLITE_SCANSTAT_NVISIT
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|nVisit
argument_list|)
expr_stmt|;
name|sqlite3_stmt_scanstatus
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|SQLITE_SCANSTAT_EST
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|rEst
argument_list|)
expr_stmt|;
name|sqlite3_stmt_scanstatus
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|SQLITE_SCANSTAT_EXPLAIN
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|zExplain
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Loop %2d: %s\n"
argument_list|,
name|n
argument_list|,
name|zExplain
argument_list|)
expr_stmt|;
name|rEstLoop
operator|*=
name|rEst
expr_stmt|;
name|raw_printf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"         nLoop=%-8lld nRow=%-8lld estRow=%-8lld estRow/Loop=%-8g\n"
argument_list|,
name|nLoop
argument_list|,
name|nVisit
argument_list|,
call|(
name|sqlite3_int64
call|)
argument_list|(
name|rEstLoop
operator|+
literal|0.5
argument_list|)
argument_list|,
name|rEst
argument_list|)
expr_stmt|;
block|}
block|}
name|raw_printf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"---------------------------\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ** Parameter azArray points to a zero-terminated array of strings. zStr ** points to a single nul-terminated string. Return non-zero if zStr ** is equal, according to strcmp(), to any of the strings in the array. ** Otherwise, return zero. */
end_comment

begin_function
specifier|static
name|int
name|str_in_array
parameter_list|(
specifier|const
name|char
modifier|*
name|zStr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|azArray
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|azArray
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|zStr
argument_list|,
name|azArray
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ** If compiled statement pSql appears to be an EXPLAIN statement, allocate ** and populate the ShellState.aiIndent[] array with the number of ** spaces each opcode should be indented before it is output. ** ** The indenting rules are: ** **     * For each "Next", "Prev", "VNext" or "VPrev" instruction, indent **       all opcodes that occur between the p2 jump destination and the opcode **       itself by 2 spaces. ** **     * For each "Goto", if the jump destination is earlier in the program **       and ends on one of: **          Yield  SeekGt  SeekLt  RowSetRead  Rewind **       or if the P1 parameter is one instead of zero, **       then indent all opcodes between the earlier instruction **       and "Goto" by 2 spaces. */
end_comment

begin_function
specifier|static
name|void
name|explain_data_prepare
parameter_list|(
name|ShellState
modifier|*
name|p
parameter_list|,
name|sqlite3_stmt
modifier|*
name|pSql
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|zSql
decl_stmt|;
comment|/* The text of the SQL statement */
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
comment|/* Used to check if this is an EXPLAIN */
name|int
modifier|*
name|abYield
init|=
literal|0
decl_stmt|;
comment|/* True if op is an OP_Yield */
name|int
name|nAlloc
init|=
literal|0
decl_stmt|;
comment|/* Allocated size of p->aiIndent[], abYield */
name|int
name|iOp
decl_stmt|;
comment|/* Index of operation in p->aiIndent[] */
specifier|const
name|char
modifier|*
name|azNext
index|[]
init|=
block|{
literal|"Next"
block|,
literal|"Prev"
block|,
literal|"VPrev"
block|,
literal|"VNext"
block|,
literal|"SorterNext"
block|,
literal|"NextIfOpen"
block|,
literal|"PrevIfOpen"
block|,
literal|0
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|azYield
index|[]
init|=
block|{
literal|"Yield"
block|,
literal|"SeekLT"
block|,
literal|"SeekGT"
block|,
literal|"RowSetRead"
block|,
literal|"Rewind"
block|,
literal|0
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|azGoto
index|[]
init|=
block|{
literal|"Goto"
block|,
literal|0
block|}
decl_stmt|;
comment|/* Try to figure out if this is really an EXPLAIN statement. If this   ** cannot be verified, return early.  */
if|if
condition|(
name|sqlite3_column_count
argument_list|(
name|pSql
argument_list|)
operator|!=
literal|8
condition|)
block|{
name|p
operator|->
name|cMode
operator|=
name|p
operator|->
name|mode
expr_stmt|;
return|return;
block|}
name|zSql
operator|=
name|sqlite3_sql
argument_list|(
name|pSql
argument_list|)
expr_stmt|;
if|if
condition|(
name|zSql
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|z
operator|=
name|zSql
init|;
operator|*
name|z
operator|==
literal|' '
operator|||
operator|*
name|z
operator|==
literal|'\t'
operator|||
operator|*
name|z
operator|==
literal|'\n'
operator|||
operator|*
name|z
operator|==
literal|'\f'
operator|||
operator|*
name|z
operator|==
literal|'\r'
condition|;
name|z
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|sqlite3_strnicmp
argument_list|(
name|z
argument_list|,
literal|"explain"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|p
operator|->
name|cMode
operator|=
name|p
operator|->
name|mode
expr_stmt|;
return|return;
block|}
for|for
control|(
name|iOp
operator|=
literal|0
init|;
name|SQLITE_ROW
operator|==
name|sqlite3_step
argument_list|(
name|pSql
argument_list|)
condition|;
name|iOp
operator|++
control|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|iAddr
init|=
name|sqlite3_column_int
argument_list|(
name|pSql
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|zOp
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pSql
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Set p2 to the P2 field of the current opcode. Then, assuming that     ** p2 is an instruction address, set variable p2op to the index of that     ** instruction in the aiIndent[] array. p2 and p2op may be different if     ** the current instruction is part of a sub-program generated by an     ** SQL trigger or foreign key.  */
name|int
name|p2
init|=
name|sqlite3_column_int
argument_list|(
name|pSql
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|int
name|p2op
init|=
operator|(
name|p2
operator|+
operator|(
name|iOp
operator|-
name|iAddr
operator|)
operator|)
decl_stmt|;
comment|/* Grow the p->aiIndent array as required */
if|if
condition|(
name|iOp
operator|>=
name|nAlloc
condition|)
block|{
if|if
condition|(
name|iOp
operator|==
literal|0
condition|)
block|{
comment|/* Do further verfication that this is explain output.  Abort if         ** it is not */
specifier|static
specifier|const
name|char
modifier|*
name|explainCols
index|[]
init|=
block|{
literal|"addr"
block|,
literal|"opcode"
block|,
literal|"p1"
block|,
literal|"p2"
block|,
literal|"p3"
block|,
literal|"p4"
block|,
literal|"p5"
block|,
literal|"comment"
block|}
decl_stmt|;
name|int
name|jj
decl_stmt|;
for|for
control|(
name|jj
operator|=
literal|0
init|;
name|jj
operator|<
name|ArraySize
argument_list|(
name|explainCols
argument_list|)
condition|;
name|jj
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|sqlite3_column_name
argument_list|(
name|pSql
argument_list|,
name|jj
argument_list|)
argument_list|,
name|explainCols
index|[
name|jj
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|p
operator|->
name|cMode
operator|=
name|p
operator|->
name|mode
expr_stmt|;
name|sqlite3_reset
argument_list|(
name|pSql
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
name|nAlloc
operator|+=
literal|100
expr_stmt|;
name|p
operator|->
name|aiIndent
operator|=
operator|(
name|int
operator|*
operator|)
name|sqlite3_realloc64
argument_list|(
name|p
operator|->
name|aiIndent
argument_list|,
name|nAlloc
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|abYield
operator|=
operator|(
name|int
operator|*
operator|)
name|sqlite3_realloc64
argument_list|(
name|abYield
argument_list|,
name|nAlloc
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|abYield
index|[
name|iOp
index|]
operator|=
name|str_in_array
argument_list|(
name|zOp
argument_list|,
name|azYield
argument_list|)
expr_stmt|;
name|p
operator|->
name|aiIndent
index|[
name|iOp
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|nIndent
operator|=
name|iOp
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|str_in_array
argument_list|(
name|zOp
argument_list|,
name|azNext
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|p2op
init|;
name|i
operator|<
name|iOp
condition|;
name|i
operator|++
control|)
name|p
operator|->
name|aiIndent
index|[
name|i
index|]
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|str_in_array
argument_list|(
name|zOp
argument_list|,
name|azGoto
argument_list|)
operator|&&
name|p2op
operator|<
name|p
operator|->
name|nIndent
operator|&&
operator|(
name|abYield
index|[
name|p2op
index|]
operator|||
name|sqlite3_column_int
argument_list|(
name|pSql
argument_list|,
literal|2
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|p2op
init|;
name|i
operator|<
name|iOp
condition|;
name|i
operator|++
control|)
name|p
operator|->
name|aiIndent
index|[
name|i
index|]
operator|+=
literal|2
expr_stmt|;
block|}
block|}
name|p
operator|->
name|iIndent
operator|=
literal|0
expr_stmt|;
name|sqlite3_free
argument_list|(
name|abYield
argument_list|)
expr_stmt|;
name|sqlite3_reset
argument_list|(
name|pSql
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Free the array allocated by explain_data_prepare(). */
end_comment

begin_function
specifier|static
name|void
name|explain_data_delete
parameter_list|(
name|ShellState
modifier|*
name|p
parameter_list|)
block|{
name|sqlite3_free
argument_list|(
name|p
operator|->
name|aiIndent
argument_list|)
expr_stmt|;
name|p
operator|->
name|aiIndent
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|nIndent
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|iIndent
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Disable and restore .wheretrace and .selecttrace settings. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|SQLITE_ENABLE_SELECTTRACE
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|int
name|sqlite3SelectTrace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|savedSelectTrace
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|SQLITE_ENABLE_WHERETRACE
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|int
name|sqlite3WhereTrace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|savedWhereTrace
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|disable_debug_trace_modes
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|SQLITE_ENABLE_SELECTTRACE
argument_list|)
name|savedSelectTrace
operator|=
name|sqlite3SelectTrace
expr_stmt|;
name|sqlite3SelectTrace
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|SQLITE_ENABLE_WHERETRACE
argument_list|)
name|savedWhereTrace
operator|=
name|sqlite3WhereTrace
expr_stmt|;
name|sqlite3WhereTrace
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|restore_debug_trace_modes
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|SQLITE_ENABLE_SELECTTRACE
argument_list|)
name|sqlite3SelectTrace
operator|=
name|savedSelectTrace
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|SQLITE_ENABLE_WHERETRACE
argument_list|)
name|sqlite3WhereTrace
operator|=
name|savedWhereTrace
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ** Run a prepared statement */
end_comment

begin_function
specifier|static
name|void
name|exec_prepared_stmt
parameter_list|(
name|ShellState
modifier|*
name|pArg
parameter_list|,
comment|/* Pointer to ShellState */
name|sqlite3_stmt
modifier|*
name|pStmt
parameter_list|,
comment|/* Statment to run */
name|int
function_decl|(
modifier|*
name|xCallback
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
comment|/* Callback function */
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
comment|/* perform the first step.  this will tell us if we   ** have a result set or not and how wide it is.   */
name|rc
operator|=
name|sqlite3_step
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
comment|/* if we have a result set... */
if|if
condition|(
name|SQLITE_ROW
operator|==
name|rc
condition|)
block|{
comment|/* if we have a callback... */
if|if
condition|(
name|xCallback
condition|)
block|{
comment|/* allocate space for col name ptr, value ptr, and type */
name|int
name|nCol
init|=
name|sqlite3_column_count
argument_list|(
name|pStmt
argument_list|)
decl_stmt|;
name|void
modifier|*
name|pData
init|=
name|sqlite3_malloc64
argument_list|(
literal|3
operator|*
name|nCol
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|pData
condition|)
block|{
name|rc
operator|=
name|SQLITE_NOMEM
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
modifier|*
name|azCols
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|pData
decl_stmt|;
comment|/* Names of result columns */
name|char
modifier|*
modifier|*
name|azVals
init|=
operator|&
name|azCols
index|[
name|nCol
index|]
decl_stmt|;
comment|/* Results */
name|int
modifier|*
name|aiTypes
init|=
operator|(
name|int
operator|*
operator|)
operator|&
name|azVals
index|[
name|nCol
index|]
decl_stmt|;
comment|/* Result types */
name|int
name|i
decl_stmt|,
name|x
decl_stmt|;
name|assert
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* save off ptrs to column names */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nCol
condition|;
name|i
operator|++
control|)
block|{
name|azCols
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|sqlite3_column_name
argument_list|(
name|pStmt
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
do|do
block|{
comment|/* extract the data and data types */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nCol
condition|;
name|i
operator|++
control|)
block|{
name|aiTypes
index|[
name|i
index|]
operator|=
name|x
operator|=
name|sqlite3_column_type
argument_list|(
name|pStmt
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|SQLITE_BLOB
operator|&&
name|pArg
operator|&&
name|pArg
operator|->
name|cMode
operator|==
name|MODE_Insert
condition|)
block|{
name|azVals
index|[
name|i
index|]
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|azVals
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pStmt
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|azVals
index|[
name|i
index|]
operator|&&
operator|(
name|aiTypes
index|[
name|i
index|]
operator|!=
name|SQLITE_NULL
operator|)
condition|)
block|{
name|rc
operator|=
name|SQLITE_NOMEM
expr_stmt|;
break|break;
comment|/* from for */
block|}
block|}
comment|/* end for */
comment|/* if data and types extracted successfully... */
if|if
condition|(
name|SQLITE_ROW
operator|==
name|rc
condition|)
block|{
comment|/* call the supplied callback with the result row data */
if|if
condition|(
name|xCallback
argument_list|(
name|pArg
argument_list|,
name|nCol
argument_list|,
name|azVals
argument_list|,
name|azCols
argument_list|,
name|aiTypes
argument_list|)
condition|)
block|{
name|rc
operator|=
name|SQLITE_ABORT
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|sqlite3_step
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|SQLITE_ROW
operator|==
name|rc
condition|)
do|;
name|sqlite3_free
argument_list|(
name|pData
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
do|do
block|{
name|rc
operator|=
name|sqlite3_step
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rc
operator|==
name|SQLITE_ROW
condition|)
do|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ** Execute a statement or set of statements.  Print ** any result rows/columns depending on the current mode ** set via the supplied callback. ** ** This is very similar to SQLite's built-in sqlite3_exec() ** function except it takes a slightly different callback ** and callback data argument. */
end_comment

begin_function
specifier|static
name|int
name|shell_exec
parameter_list|(
name|sqlite3
modifier|*
name|db
parameter_list|,
comment|/* An open database */
specifier|const
name|char
modifier|*
name|zSql
parameter_list|,
comment|/* SQL to be evaluated */
name|int
function_decl|(
modifier|*
name|xCallback
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
parameter_list|,
comment|/* Callback function */
comment|/* (not the same as sqlite3_exec) */
name|ShellState
modifier|*
name|pArg
parameter_list|,
comment|/* Pointer to ShellState */
name|char
modifier|*
modifier|*
name|pzErrMsg
comment|/* Error msg written here */
parameter_list|)
block|{
name|sqlite3_stmt
modifier|*
name|pStmt
init|=
name|NULL
decl_stmt|;
comment|/* Statement to execute. */
name|int
name|rc
init|=
name|SQLITE_OK
decl_stmt|;
comment|/* Return Code */
name|int
name|rc2
decl_stmt|;
specifier|const
name|char
modifier|*
name|zLeftover
decl_stmt|;
comment|/* Tail of unprocessed SQL */
if|if
condition|(
name|pzErrMsg
condition|)
block|{
operator|*
name|pzErrMsg
operator|=
name|NULL
expr_stmt|;
block|}
while|while
condition|(
name|zSql
index|[
literal|0
index|]
operator|&&
operator|(
name|SQLITE_OK
operator|==
name|rc
operator|)
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|zStmtSql
decl_stmt|;
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|db
argument_list|,
name|zSql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pStmt
argument_list|,
operator|&
name|zLeftover
argument_list|)
expr_stmt|;
if|if
condition|(
name|SQLITE_OK
operator|!=
name|rc
condition|)
block|{
if|if
condition|(
name|pzErrMsg
condition|)
block|{
operator|*
name|pzErrMsg
operator|=
name|save_err_msg
argument_list|(
name|db
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|pStmt
condition|)
block|{
comment|/* this happens for a comment or white-space */
name|zSql
operator|=
name|zLeftover
expr_stmt|;
while|while
condition|(
name|IsSpace
argument_list|(
name|zSql
index|[
literal|0
index|]
argument_list|)
condition|)
name|zSql
operator|++
expr_stmt|;
continue|continue;
block|}
name|zStmtSql
operator|=
name|sqlite3_sql
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|zStmtSql
operator|==
literal|0
condition|)
name|zStmtSql
operator|=
literal|""
expr_stmt|;
while|while
condition|(
name|IsSpace
argument_list|(
name|zStmtSql
index|[
literal|0
index|]
argument_list|)
condition|)
name|zStmtSql
operator|++
expr_stmt|;
comment|/* save off the prepared statment handle and reset row count */
if|if
condition|(
name|pArg
condition|)
block|{
name|pArg
operator|->
name|pStmt
operator|=
name|pStmt
expr_stmt|;
name|pArg
operator|->
name|cnt
operator|=
literal|0
expr_stmt|;
block|}
comment|/* echo the sql statement if echo on */
if|if
condition|(
name|pArg
operator|&&
name|ShellHasFlag
argument_list|(
name|pArg
argument_list|,
name|SHFLG_Echo
argument_list|)
condition|)
block|{
name|utf8_printf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"%s\n"
argument_list|,
name|zStmtSql
condition|?
name|zStmtSql
else|:
name|zSql
argument_list|)
expr_stmt|;
block|}
comment|/* Show the EXPLAIN QUERY PLAN if .eqp is on */
if|if
condition|(
name|pArg
operator|&&
name|pArg
operator|->
name|autoEQP
operator|&&
name|sqlite3_strlike
argument_list|(
literal|"EXPLAIN%"
argument_list|,
name|zStmtSql
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sqlite3_stmt
modifier|*
name|pExplain
decl_stmt|;
name|char
modifier|*
name|zEQP
decl_stmt|;
name|disable_debug_trace_modes
argument_list|()
expr_stmt|;
name|zEQP
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"EXPLAIN QUERY PLAN %s"
argument_list|,
name|zStmtSql
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|db
argument_list|,
name|zEQP
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pExplain
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|SQLITE_OK
condition|)
block|{
while|while
condition|(
name|sqlite3_step
argument_list|(
name|pExplain
argument_list|)
operator|==
name|SQLITE_ROW
condition|)
block|{
name|raw_printf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"--EQP-- %d,"
argument_list|,
name|sqlite3_column_int
argument_list|(
name|pExplain
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"%d,"
argument_list|,
name|sqlite3_column_int
argument_list|(
name|pExplain
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"%d,"
argument_list|,
name|sqlite3_column_int
argument_list|(
name|pExplain
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"%s\n"
argument_list|,
name|sqlite3_column_text
argument_list|(
name|pExplain
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|sqlite3_finalize
argument_list|(
name|pExplain
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zEQP
argument_list|)
expr_stmt|;
if|if
condition|(
name|pArg
operator|->
name|autoEQP
operator|>=
literal|2
condition|)
block|{
comment|/* Also do an EXPLAIN for ".eqp full" mode */
name|zEQP
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"EXPLAIN %s"
argument_list|,
name|zStmtSql
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|db
argument_list|,
name|zEQP
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pExplain
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|SQLITE_OK
condition|)
block|{
name|pArg
operator|->
name|cMode
operator|=
name|MODE_Explain
expr_stmt|;
name|explain_data_prepare
argument_list|(
name|pArg
argument_list|,
name|pExplain
argument_list|)
expr_stmt|;
name|exec_prepared_stmt
argument_list|(
name|pArg
argument_list|,
name|pExplain
argument_list|,
name|xCallback
argument_list|)
expr_stmt|;
name|explain_data_delete
argument_list|(
name|pArg
argument_list|)
expr_stmt|;
block|}
name|sqlite3_finalize
argument_list|(
name|pExplain
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zEQP
argument_list|)
expr_stmt|;
block|}
name|restore_debug_trace_modes
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|pArg
condition|)
block|{
name|pArg
operator|->
name|cMode
operator|=
name|pArg
operator|->
name|mode
expr_stmt|;
if|if
condition|(
name|pArg
operator|->
name|autoExplain
operator|&&
name|sqlite3_column_count
argument_list|(
name|pStmt
argument_list|)
operator|==
literal|8
operator|&&
name|sqlite3_strlike
argument_list|(
literal|"EXPLAIN%"
argument_list|,
name|zStmtSql
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pArg
operator|->
name|cMode
operator|=
name|MODE_Explain
expr_stmt|;
block|}
comment|/* If the shell is currently in ".explain" mode, gather the extra         ** data required to add indents to the output.*/
if|if
condition|(
name|pArg
operator|->
name|cMode
operator|==
name|MODE_Explain
condition|)
block|{
name|explain_data_prepare
argument_list|(
name|pArg
argument_list|,
name|pStmt
argument_list|)
expr_stmt|;
block|}
block|}
name|exec_prepared_stmt
argument_list|(
name|pArg
argument_list|,
name|pStmt
argument_list|,
name|xCallback
argument_list|)
expr_stmt|;
name|explain_data_delete
argument_list|(
name|pArg
argument_list|)
expr_stmt|;
comment|/* print usage stats if stats on */
if|if
condition|(
name|pArg
operator|&&
name|pArg
operator|->
name|statsOn
condition|)
block|{
name|display_stats
argument_list|(
name|db
argument_list|,
name|pArg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* print loop-counters if required */
if|if
condition|(
name|pArg
operator|&&
name|pArg
operator|->
name|scanstatsOn
condition|)
block|{
name|display_scanstats
argument_list|(
name|db
argument_list|,
name|pArg
argument_list|)
expr_stmt|;
block|}
comment|/* Finalize the statement just executed. If this fails, save a       ** copy of the error message. Otherwise, set zSql to point to the       ** next statement to execute. */
name|rc2
operator|=
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_NOMEM
condition|)
name|rc
operator|=
name|rc2
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|SQLITE_OK
condition|)
block|{
name|zSql
operator|=
name|zLeftover
expr_stmt|;
while|while
condition|(
name|IsSpace
argument_list|(
name|zSql
index|[
literal|0
index|]
argument_list|)
condition|)
name|zSql
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pzErrMsg
condition|)
block|{
operator|*
name|pzErrMsg
operator|=
name|save_err_msg
argument_list|(
name|db
argument_list|)
expr_stmt|;
block|}
comment|/* clear saved stmt handle */
if|if
condition|(
name|pArg
condition|)
block|{
name|pArg
operator|->
name|pStmt
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
comment|/* end while */
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* ** Release memory previously allocated by tableColumnList(). */
end_comment

begin_function
specifier|static
name|void
name|freeColumnList
parameter_list|(
name|char
modifier|*
modifier|*
name|azCol
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|azCol
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|sqlite3_free
argument_list|(
name|azCol
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* azCol[0] is a static string */
name|sqlite3_free
argument_list|(
name|azCol
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Return a list of pointers to strings which are the names of all ** columns in table zTab.   The memory to hold the names is dynamically ** allocated and must be released by the caller using a subsequent call ** to freeColumnList(). ** ** The azCol[0] entry is usually NULL.  However, if zTab contains a rowid ** value that needs to be preserved, then azCol[0] is filled in with the ** name of the rowid column. ** ** The first regular column in the table is azCol[1].  The list is terminated ** by an entry with azCol[i]==0. */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|tableColumnList
parameter_list|(
name|ShellState
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|zTab
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|azCol
init|=
literal|0
decl_stmt|;
name|sqlite3_stmt
modifier|*
name|pStmt
decl_stmt|;
name|char
modifier|*
name|zSql
decl_stmt|;
name|int
name|nCol
init|=
literal|0
decl_stmt|;
name|int
name|nAlloc
init|=
literal|0
decl_stmt|;
name|int
name|nPK
init|=
literal|0
decl_stmt|;
comment|/* Number of PRIMARY KEY columns seen */
name|int
name|isIPK
init|=
literal|0
decl_stmt|;
comment|/* True if one PRIMARY KEY column of type INTEGER */
name|int
name|preserveRowid
init|=
name|ShellHasFlag
argument_list|(
name|p
argument_list|,
name|SHFLG_PreserveRowid
argument_list|)
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|zSql
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"PRAGMA table_info=%Q"
argument_list|,
name|zTab
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zSql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|sqlite3_step
argument_list|(
name|pStmt
argument_list|)
operator|==
name|SQLITE_ROW
condition|)
block|{
if|if
condition|(
name|nCol
operator|>=
name|nAlloc
operator|-
literal|2
condition|)
block|{
name|nAlloc
operator|=
name|nAlloc
operator|*
literal|2
operator|+
name|nCol
operator|+
literal|10
expr_stmt|;
name|azCol
operator|=
name|sqlite3_realloc
argument_list|(
name|azCol
argument_list|,
name|nAlloc
operator|*
sizeof|sizeof
argument_list|(
name|azCol
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|azCol
operator|==
literal|0
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|azCol
index|[
operator|++
name|nCol
index|]
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"%s"
argument_list|,
name|sqlite3_column_text
argument_list|(
name|pStmt
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sqlite3_column_int
argument_list|(
name|pStmt
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|nPK
operator|++
expr_stmt|;
if|if
condition|(
name|nPK
operator|==
literal|1
operator|&&
name|sqlite3_stricmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pStmt
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|"INTEGER"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|isIPK
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|isIPK
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|azCol
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|azCol
index|[
name|nCol
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* The decision of whether or not a rowid really needs to be preserved   ** is tricky.  We never need to preserve a rowid for a WITHOUT ROWID table   ** or a table with an INTEGER PRIMARY KEY.  We are unable to preserve   ** rowids on tables where the rowid is inaccessible because there are other   ** columns in the table named "rowid", "_rowid_", and "oid".   */
if|if
condition|(
name|preserveRowid
operator|&&
name|isIPK
condition|)
block|{
comment|/* If a single PRIMARY KEY column with type INTEGER was seen, then it     ** might be an alise for the ROWID.  But it might also be a WITHOUT ROWID     ** table or a INTEGER PRIMARY KEY DESC column, neither of which are     ** ROWID aliases.  To distinguish these cases, check to see if     ** there is a "pk" entry in "PRAGMA index_list".  There will be     ** no "pk" index if the PRIMARY KEY really is an alias for the ROWID.     */
name|zSql
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"SELECT 1 FROM pragma_index_list(%Q)"
literal|" WHERE origin='pk'"
argument_list|,
name|zTab
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zSql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|freeColumnList
argument_list|(
name|azCol
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|rc
operator|=
name|sqlite3_step
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|preserveRowid
operator|=
name|rc
operator|==
name|SQLITE_ROW
expr_stmt|;
block|}
if|if
condition|(
name|preserveRowid
condition|)
block|{
comment|/* Only preserve the rowid if we can find a name to use for the     ** rowid */
specifier|static
name|char
modifier|*
name|azRowid
index|[]
init|=
block|{
literal|"rowid"
block|,
literal|"_rowid_"
block|,
literal|"oid"
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nCol
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sqlite3_stricmp
argument_list|(
name|azRowid
index|[
name|j
index|]
argument_list|,
name|azCol
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>
name|nCol
condition|)
block|{
comment|/* At this point, we know that azRowid[j] is not the name of any         ** ordinary column in the table.  Verify that azRowid[j] is a valid         ** name for the rowid before adding it to azCol[0].  WITHOUT ROWID         ** tables will fail this last check */
name|rc
operator|=
name|sqlite3_table_column_metadata
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|0
argument_list|,
name|zTab
argument_list|,
name|azRowid
index|[
name|j
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|SQLITE_OK
condition|)
name|azCol
index|[
literal|0
index|]
operator|=
name|azRowid
index|[
name|j
index|]
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|azCol
return|;
block|}
end_function

begin_comment
comment|/* ** Toggle the reverse_unordered_selects setting. */
end_comment

begin_function
specifier|static
name|void
name|toggleSelectOrder
parameter_list|(
name|sqlite3
modifier|*
name|db
parameter_list|)
block|{
name|sqlite3_stmt
modifier|*
name|pStmt
init|=
literal|0
decl_stmt|;
name|int
name|iSetting
init|=
literal|0
decl_stmt|;
name|char
name|zStmt
index|[
literal|100
index|]
decl_stmt|;
name|sqlite3_prepare_v2
argument_list|(
name|db
argument_list|,
literal|"PRAGMA reverse_unordered_selects"
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sqlite3_step
argument_list|(
name|pStmt
argument_list|)
operator|==
name|SQLITE_ROW
condition|)
block|{
name|iSetting
operator|=
name|sqlite3_column_int
argument_list|(
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|zStmt
argument_list|)
argument_list|,
name|zStmt
argument_list|,
literal|"PRAGMA reverse_unordered_selects(%d)"
argument_list|,
operator|!
name|iSetting
argument_list|)
expr_stmt|;
name|sqlite3_exec
argument_list|(
name|db
argument_list|,
name|zStmt
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** This is a different callback routine used for dumping the database. ** Each row received by this callback consists of a table name, ** the table type ("index" or "table") and SQL to create the table. ** This routine should print text sufficient to recreate the table. */
end_comment

begin_function
specifier|static
name|int
name|dump_callback
parameter_list|(
name|void
modifier|*
name|pArg
parameter_list|,
name|int
name|nArg
parameter_list|,
name|char
modifier|*
modifier|*
name|azArg
parameter_list|,
name|char
modifier|*
modifier|*
name|azNotUsed
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
specifier|const
name|char
modifier|*
name|zTable
decl_stmt|;
specifier|const
name|char
modifier|*
name|zType
decl_stmt|;
specifier|const
name|char
modifier|*
name|zSql
decl_stmt|;
name|ShellState
modifier|*
name|p
init|=
operator|(
name|ShellState
operator|*
operator|)
name|pArg
decl_stmt|;
name|UNUSED_PARAMETER
argument_list|(
name|azNotUsed
argument_list|)
expr_stmt|;
if|if
condition|(
name|nArg
operator|!=
literal|3
condition|)
return|return
literal|1
return|;
name|zTable
operator|=
name|azArg
index|[
literal|0
index|]
expr_stmt|;
name|zType
operator|=
name|azArg
index|[
literal|1
index|]
expr_stmt|;
name|zSql
operator|=
name|azArg
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|zTable
argument_list|,
literal|"sqlite_sequence"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"DELETE FROM sqlite_sequence;\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sqlite3_strglob
argument_list|(
literal|"sqlite_stat?"
argument_list|,
name|zTable
argument_list|)
operator|==
literal|0
condition|)
block|{
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"ANALYZE sqlite_master;\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|zTable
argument_list|,
literal|"sqlite_"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|zSql
argument_list|,
literal|"CREATE VIRTUAL TABLE"
argument_list|,
literal|20
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|zIns
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|writableSchema
condition|)
block|{
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"PRAGMA writable_schema=ON;\n"
argument_list|)
expr_stmt|;
name|p
operator|->
name|writableSchema
operator|=
literal|1
expr_stmt|;
block|}
name|zIns
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"INSERT INTO sqlite_master(type,name,tbl_name,rootpage,sql)"
literal|"VALUES('table','%q','%q',0,'%q');"
argument_list|,
name|zTable
argument_list|,
name|zTable
argument_list|,
name|zSql
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s\n"
argument_list|,
name|zIns
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zIns
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|printSchemaLine
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|zSql
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|zType
argument_list|,
literal|"table"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ShellText
name|sSelect
decl_stmt|;
name|ShellText
name|sTable
decl_stmt|;
name|char
modifier|*
modifier|*
name|azCol
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|savedDestTable
decl_stmt|;
name|int
name|savedMode
decl_stmt|;
name|azCol
operator|=
name|tableColumnList
argument_list|(
name|p
argument_list|,
name|zTable
argument_list|)
expr_stmt|;
if|if
condition|(
name|azCol
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|nErr
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Always quote the table name, even if it appears to be pure ascii,     ** in case it is a keyword. Ex:  INSERT INTO "table" ... */
name|initText
argument_list|(
operator|&
name|sTable
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|sTable
argument_list|,
name|zTable
argument_list|,
name|quoteChar
argument_list|(
name|zTable
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If preserving the rowid, add a column list after the table name.     ** In other words:  "INSERT INTO tab(rowid,a,b,c,...) VALUES(...)"     ** instead of the usual "INSERT INTO tab VALUES(...)".     */
if|if
condition|(
name|azCol
index|[
literal|0
index|]
condition|)
block|{
name|appendText
argument_list|(
operator|&
name|sTable
argument_list|,
literal|"("
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|sTable
argument_list|,
name|azCol
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|azCol
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|appendText
argument_list|(
operator|&
name|sTable
argument_list|,
literal|","
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|sTable
argument_list|,
name|azCol
index|[
name|i
index|]
argument_list|,
name|quoteChar
argument_list|(
name|azCol
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|appendText
argument_list|(
operator|&
name|sTable
argument_list|,
literal|")"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Build an appropriate SELECT statement */
name|initText
argument_list|(
operator|&
name|sSelect
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|sSelect
argument_list|,
literal|"SELECT "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|azCol
index|[
literal|0
index|]
condition|)
block|{
name|appendText
argument_list|(
operator|&
name|sSelect
argument_list|,
name|azCol
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|sSelect
argument_list|,
literal|","
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|azCol
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|appendText
argument_list|(
operator|&
name|sSelect
argument_list|,
name|azCol
index|[
name|i
index|]
argument_list|,
name|quoteChar
argument_list|(
name|azCol
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|azCol
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
name|appendText
argument_list|(
operator|&
name|sSelect
argument_list|,
literal|","
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|freeColumnList
argument_list|(
name|azCol
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|sSelect
argument_list|,
literal|" FROM "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|sSelect
argument_list|,
name|zTable
argument_list|,
name|quoteChar
argument_list|(
name|zTable
argument_list|)
argument_list|)
expr_stmt|;
name|savedDestTable
operator|=
name|p
operator|->
name|zDestTable
expr_stmt|;
name|savedMode
operator|=
name|p
operator|->
name|mode
expr_stmt|;
name|p
operator|->
name|zDestTable
operator|=
name|sTable
operator|.
name|z
expr_stmt|;
name|p
operator|->
name|mode
operator|=
name|p
operator|->
name|cMode
operator|=
name|MODE_Insert
expr_stmt|;
name|rc
operator|=
name|shell_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|sSelect
operator|.
name|z
argument_list|,
name|shell_callback
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|&
literal|0xff
operator|)
operator|==
name|SQLITE_CORRUPT
condition|)
block|{
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"/****** CORRUPTION ERROR *******/\n"
argument_list|)
expr_stmt|;
name|toggleSelectOrder
argument_list|(
name|p
operator|->
name|db
argument_list|)
expr_stmt|;
name|shell_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|sSelect
operator|.
name|z
argument_list|,
name|shell_callback
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|toggleSelectOrder
argument_list|(
name|p
operator|->
name|db
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|zDestTable
operator|=
name|savedDestTable
expr_stmt|;
name|p
operator|->
name|mode
operator|=
name|savedMode
expr_stmt|;
name|freeText
argument_list|(
operator|&
name|sTable
argument_list|)
expr_stmt|;
name|freeText
argument_list|(
operator|&
name|sSelect
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
name|p
operator|->
name|nErr
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ** Run zQuery.  Use dump_callback() as the callback routine so that ** the contents of the query are output as SQL statements. ** ** If we get a SQLITE_CORRUPT error, rerun the query after appending ** "ORDER BY rowid DESC" to the end. */
end_comment

begin_function
specifier|static
name|int
name|run_schema_dump_query
parameter_list|(
name|ShellState
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|zQuery
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|char
modifier|*
name|zErr
init|=
literal|0
decl_stmt|;
name|rc
operator|=
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zQuery
argument_list|,
name|dump_callback
argument_list|,
name|p
argument_list|,
operator|&
name|zErr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|SQLITE_CORRUPT
condition|)
block|{
name|char
modifier|*
name|zQ2
decl_stmt|;
name|int
name|len
init|=
name|strlen30
argument_list|(
name|zQuery
argument_list|)
decl_stmt|;
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"/****** CORRUPTION ERROR *******/\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zErr
condition|)
block|{
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"/****** %s ******/\n"
argument_list|,
name|zErr
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zErr
argument_list|)
expr_stmt|;
name|zErr
operator|=
literal|0
expr_stmt|;
block|}
name|zQ2
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|zQ2
operator|==
literal|0
condition|)
return|return
name|rc
return|;
name|sqlite3_snprintf
argument_list|(
name|len
operator|+
literal|100
argument_list|,
name|zQ2
argument_list|,
literal|"%s ORDER BY rowid DESC"
argument_list|,
name|zQuery
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zQ2
argument_list|,
name|dump_callback
argument_list|,
name|p
argument_list|,
operator|&
name|zErr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"/****** ERROR: %s ******/\n"
argument_list|,
name|zErr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|SQLITE_CORRUPT
expr_stmt|;
block|}
name|sqlite3_free
argument_list|(
name|zErr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zQ2
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* ** Text of a help message */
end_comment

begin_decl_stmt
specifier|static
name|char
name|zHelp
index|[]
init|=
ifndef|#
directive|ifndef
name|SQLITE_OMIT_AUTHORIZATION
literal|".auth ON|OFF           Show authorizer callbacks\n"
endif|#
directive|endif
literal|".backup ?DB? FILE      Backup DB (default \"main\") to FILE\n"
literal|".bail on|off           Stop after hitting an error.  Default OFF\n"
literal|".binary on|off         Turn binary output on or off.  Default OFF\n"
literal|".cd DIRECTORY          Change the working directory to DIRECTORY\n"
literal|".changes on|off        Show number of rows changed by SQL\n"
literal|".check GLOB            Fail if output since .testcase does not match\n"
literal|".clone NEWDB           Clone data into NEWDB from the existing database\n"
literal|".databases             List names and files of attached databases\n"
literal|".dbinfo ?DB?           Show status information about the database\n"
literal|".dump ?TABLE? ...      Dump the database in an SQL text format\n"
literal|"                         If TABLE specified, only dump tables matching\n"
literal|"                         LIKE pattern TABLE.\n"
literal|".echo on|off           Turn command echo on or off\n"
literal|".eqp on|off|full       Enable or disable automatic EXPLAIN QUERY PLAN\n"
literal|".exit                  Exit this program\n"
comment|/* Because explain mode comes on automatically now, the ".explain" mode ** is removed from the help screen.  It is still supported for legacy, however */
comment|/*".explain ?on|off|auto? Turn EXPLAIN output mode on or off or to automatic\n"*/
literal|".fullschema ?--indent? Show schema and the content of sqlite_stat tables\n"
literal|".headers on|off        Turn display of headers on or off\n"
literal|".help                  Show this message\n"
literal|".import FILE TABLE     Import data from FILE into TABLE\n"
ifndef|#
directive|ifndef
name|SQLITE_OMIT_TEST_CONTROL
literal|".imposter INDEX TABLE  Create imposter table TABLE on index INDEX\n"
endif|#
directive|endif
literal|".indexes ?TABLE?       Show names of all indexes\n"
literal|"                         If TABLE specified, only show indexes for tables\n"
literal|"                         matching LIKE pattern TABLE.\n"
ifdef|#
directive|ifdef
name|SQLITE_ENABLE_IOTRACE
literal|".iotrace FILE          Enable I/O diagnostic logging to FILE\n"
endif|#
directive|endif
literal|".limit ?LIMIT? ?VAL?   Display or change the value of an SQLITE_LIMIT\n"
literal|".lint OPTIONS          Report potential schema issues. Options:\n"
literal|"                         fkey-indexes     Find missing foreign key indexes\n"
ifndef|#
directive|ifndef
name|SQLITE_OMIT_LOAD_EXTENSION
literal|".load FILE ?ENTRY?     Load an extension library\n"
endif|#
directive|endif
literal|".log FILE|off          Turn logging on or off.  FILE can be stderr/stdout\n"
literal|".mode MODE ?TABLE?     Set output mode where MODE is one of:\n"
literal|"                         ascii    Columns/rows delimited by 0x1F and 0x1E\n"
literal|"                         csv      Comma-separated values\n"
literal|"                         column   Left-aligned columns.  (See .width)\n"
literal|"                         html     HTML<table> code\n"
literal|"                         insert   SQL insert statements for TABLE\n"
literal|"                         line     One value per line\n"
literal|"                         list     Values delimited by \"|\"\n"
literal|"                         quote    Escape answers as for SQL\n"
literal|"                         tabs     Tab-separated values\n"
literal|"                         tcl      TCL list elements\n"
literal|".nullvalue STRING      Use STRING in place of NULL values\n"
literal|".once FILENAME         Output for the next SQL command only to FILENAME\n"
literal|".open ?OPTIONS? ?FILE? Close existing database and reopen FILE\n"
literal|"                         The --new option starts with an empty file\n"
literal|".output ?FILENAME?     Send output to FILENAME or stdout\n"
literal|".print STRING...       Print literal STRING\n"
literal|".prompt MAIN CONTINUE  Replace the standard prompts\n"
literal|".quit                  Exit this program\n"
literal|".read FILENAME         Execute SQL in FILENAME\n"
literal|".restore ?DB? FILE     Restore content of DB (default \"main\") from FILE\n"
literal|".save FILE             Write in-memory database into FILE\n"
literal|".scanstats on|off      Turn sqlite3_stmt_scanstatus() metrics on or off\n"
literal|".schema ?PATTERN?      Show the CREATE statements matching PATTERN\n"
literal|"                          Add --indent for pretty-printing\n"
literal|".selftest ?--init?     Run tests defined in the SELFTEST table\n"
literal|".separator COL ?ROW?   Change the column separator and optionally the row\n"
literal|"                         separator for both the output mode and .import\n"
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_ENABLE_SESSION
argument_list|)
literal|".session CMD ...       Create or control sessions\n"
endif|#
directive|endif
literal|".sha3sum ?OPTIONS...?  Compute a SHA3 hash of database content\n"
literal|".shell CMD ARGS...     Run CMD ARGS... in a system shell\n"
literal|".show                  Show the current values for various settings\n"
literal|".stats ?on|off?        Show stats or turn stats on or off\n"
literal|".system CMD ARGS...    Run CMD ARGS... in a system shell\n"
literal|".tables ?TABLE?        List names of tables\n"
literal|"                         If TABLE specified, only list tables matching\n"
literal|"                         LIKE pattern TABLE.\n"
literal|".testcase NAME         Begin redirecting output to 'testcase-out.txt'\n"
literal|".timeout MS            Try opening locked tables for MS milliseconds\n"
literal|".timer on|off          Turn SQL timer on or off\n"
literal|".trace FILE|off        Output each SQL statement as it is run\n"
literal|".vfsinfo ?AUX?         Information about the top-level VFS\n"
literal|".vfslist               List all available VFSes\n"
literal|".vfsname ?AUX?         Print the name of the VFS stack\n"
literal|".width NUM1 NUM2 ...   Set column widths for \"column\" mode\n"
literal|"                         Negative values right-justify\n"
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_ENABLE_SESSION
argument_list|)
end_if

begin_comment
comment|/* ** Print help information for the ".sessions" command */
end_comment

begin_function
name|void
name|session_help
parameter_list|(
name|ShellState
modifier|*
name|p
parameter_list|)
block|{
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|".session ?NAME? SUBCOMMAND ?ARGS...?\n"
literal|"If ?NAME? is omitted, the first defined session is used.\n"
literal|"Subcommands:\n"
literal|"   attach TABLE             Attach TABLE\n"
literal|"   changeset FILE           Write a changeset into FILE\n"
literal|"   close                    Close one session\n"
literal|"   enable ?BOOLEAN?         Set or query the enable bit\n"
literal|"   filter GLOB...           Reject tables matching GLOBs\n"
literal|"   indirect ?BOOLEAN?       Mark or query the indirect status\n"
literal|"   isempty                  Query whether the session is empty\n"
literal|"   list                     List currently open session names\n"
literal|"   open DB NAME             Open a new session on DB\n"
literal|"   patchset FILE            Write a patchset into FILE\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Forward reference */
end_comment

begin_function_decl
specifier|static
name|int
name|process_input
parameter_list|(
name|ShellState
modifier|*
name|p
parameter_list|,
name|FILE
modifier|*
name|in
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ** Read the content of file zName into memory obtained from sqlite3_malloc64() ** and return a pointer to the buffer. The caller is responsible for freeing ** the memory. ** ** If parameter pnByte is not NULL, (*pnByte) is set to the number of bytes ** read. ** ** For convenience, a nul-terminator byte is always appended to the data read ** from the file before the buffer is returned. This byte is not included in ** the final value of (*pnByte), if applicable. ** ** NULL is returned if any error is encountered. The final value of *pnByte ** is undefined in this case. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|readFile
parameter_list|(
specifier|const
name|char
modifier|*
name|zName
parameter_list|,
name|int
modifier|*
name|pnByte
parameter_list|)
block|{
name|FILE
modifier|*
name|in
init|=
name|fopen
argument_list|(
name|zName
argument_list|,
literal|"rb"
argument_list|)
decl_stmt|;
name|long
name|nIn
decl_stmt|;
name|size_t
name|nRead
decl_stmt|;
name|char
modifier|*
name|pBuf
decl_stmt|;
if|if
condition|(
name|in
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|fseek
argument_list|(
name|in
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
name|nIn
operator|=
name|ftell
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|rewind
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|pBuf
operator|=
name|sqlite3_malloc64
argument_list|(
name|nIn
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pBuf
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|nRead
operator|=
name|fread
argument_list|(
name|pBuf
argument_list|,
name|nIn
argument_list|,
literal|1
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|nRead
operator|!=
literal|1
condition|)
block|{
name|sqlite3_free
argument_list|(
name|pBuf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|pBuf
index|[
name|nIn
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pnByte
condition|)
operator|*
name|pnByte
operator|=
name|nIn
expr_stmt|;
return|return
name|pBuf
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_ENABLE_SESSION
argument_list|)
end_if

begin_comment
comment|/* ** Close a single OpenSession object and release all of its associated ** resources. */
end_comment

begin_function
specifier|static
name|void
name|session_close
parameter_list|(
name|OpenSession
modifier|*
name|pSession
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|sqlite3session_delete
argument_list|(
name|pSession
operator|->
name|p
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|pSession
operator|->
name|zName
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pSession
operator|->
name|nFilter
condition|;
name|i
operator|++
control|)
block|{
name|sqlite3_free
argument_list|(
name|pSession
operator|->
name|azFilter
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|sqlite3_free
argument_list|(
name|pSession
operator|->
name|azFilter
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|pSession
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|OpenSession
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** Close all OpenSession objects and release all associated resources. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_ENABLE_SESSION
argument_list|)
end_if

begin_function
specifier|static
name|void
name|session_close_all
parameter_list|(
name|ShellState
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|nSession
condition|;
name|i
operator|++
control|)
block|{
name|session_close
argument_list|(
operator|&
name|p
operator|->
name|aSession
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|nSession
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|session_close_all
parameter_list|(
name|X
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** Implementation of the xFilter function for an open session.  Omit ** any tables named by ".session filter" but let all other table through. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_ENABLE_SESSION
argument_list|)
end_if

begin_function
specifier|static
name|int
name|session_filter
parameter_list|(
name|void
modifier|*
name|pCtx
parameter_list|,
specifier|const
name|char
modifier|*
name|zTab
parameter_list|)
block|{
name|OpenSession
modifier|*
name|pSession
init|=
operator|(
name|OpenSession
operator|*
operator|)
name|pCtx
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pSession
operator|->
name|nFilter
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sqlite3_strglob
argument_list|(
name|pSession
operator|->
name|azFilter
index|[
name|i
index|]
argument_list|,
name|zTab
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** Make sure the database is open.  If it is not, then open it.  If ** the database fails to open, print an error message and exit. */
end_comment

begin_function
specifier|static
name|void
name|open_db
parameter_list|(
name|ShellState
modifier|*
name|p
parameter_list|,
name|int
name|keepAlive
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|db
operator|==
literal|0
condition|)
block|{
name|sqlite3_initialize
argument_list|()
expr_stmt|;
name|sqlite3_open
argument_list|(
name|p
operator|->
name|zDbFilename
argument_list|,
operator|&
name|p
operator|->
name|db
argument_list|)
expr_stmt|;
name|globalDb
operator|=
name|p
operator|->
name|db
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|db
operator|==
literal|0
operator|||
name|SQLITE_OK
operator|!=
name|sqlite3_errcode
argument_list|(
name|p
operator|->
name|db
argument_list|)
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: unable to open database \"%s\": %s\n"
argument_list|,
name|p
operator|->
name|zDbFilename
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|keepAlive
condition|)
return|return;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|SQLITE_OMIT_LOAD_EXTENSION
name|sqlite3_enable_load_extension
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sqlite3_fileio_init
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_shathree_init
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_completion_init
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_create_function
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"shell_add_schema"
argument_list|,
literal|2
argument_list|,
name|SQLITE_UTF8
argument_list|,
literal|0
argument_list|,
name|shellAddSchemaName
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|HAVE_READLINE
operator|||
name|HAVE_EDITLINE
end_if

begin_comment
comment|/* ** Readline completion callbacks */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|readline_completion_generator
parameter_list|(
specifier|const
name|char
modifier|*
name|text
parameter_list|,
name|int
name|state
parameter_list|)
block|{
specifier|static
name|sqlite3_stmt
modifier|*
name|pStmt
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|zRet
decl_stmt|;
if|if
condition|(
name|state
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|zSql
decl_stmt|;
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|zSql
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"SELECT DISTINCT candidate COLLATE nocase"
literal|"  FROM completion(%Q) ORDER BY 1"
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|sqlite3_prepare_v2
argument_list|(
name|globalDb
argument_list|,
name|zSql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sqlite3_step
argument_list|(
name|pStmt
argument_list|)
operator|==
name|SQLITE_ROW
condition|)
block|{
name|zRet
operator|=
name|strdup
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pStmt
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|pStmt
operator|=
literal|0
expr_stmt|;
name|zRet
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|zRet
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|readline_completion
parameter_list|(
specifier|const
name|char
modifier|*
name|zText
parameter_list|,
name|int
name|iStart
parameter_list|,
name|int
name|iEnd
parameter_list|)
block|{
name|rl_attempted_completion_over
operator|=
literal|1
expr_stmt|;
return|return
name|rl_completion_matches
argument_list|(
name|zText
argument_list|,
name|readline_completion_generator
argument_list|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|HAVE_LINENOISE
end_elif

begin_comment
comment|/* ** Linenoise completion callback */
end_comment

begin_function
specifier|static
name|void
name|linenoise_completion
parameter_list|(
specifier|const
name|char
modifier|*
name|zLine
parameter_list|,
name|linenoiseCompletions
modifier|*
name|lc
parameter_list|)
block|{
name|int
name|nLine
init|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|zLine
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|iStart
decl_stmt|;
name|sqlite3_stmt
modifier|*
name|pStmt
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|zSql
decl_stmt|;
name|char
name|zBuf
index|[
literal|1000
index|]
decl_stmt|;
if|if
condition|(
name|nLine
operator|>
sizeof|sizeof
argument_list|(
name|zBuf
argument_list|)
operator|-
literal|30
condition|)
return|return;
if|if
condition|(
name|zLine
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|nLine
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
operator|&&
operator|(
name|isalnum
argument_list|(
name|zLine
index|[
name|i
index|]
argument_list|)
operator|||
name|zLine
index|[
name|i
index|]
operator|==
literal|'_'
operator|)
condition|;
name|i
operator|--
control|)
block|{}
if|if
condition|(
name|i
operator|==
name|nLine
operator|-
literal|1
condition|)
return|return;
name|iStart
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|zBuf
argument_list|,
name|zLine
argument_list|,
name|iStart
argument_list|)
expr_stmt|;
name|zSql
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"SELECT DISTINCT candidate COLLATE nocase"
literal|"  FROM completion(%Q,%Q) ORDER BY 1"
argument_list|,
operator|&
name|zLine
index|[
name|iStart
index|]
argument_list|,
name|zLine
argument_list|)
expr_stmt|;
name|sqlite3_prepare_v2
argument_list|(
name|globalDb
argument_list|,
name|zSql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
name|sqlite3_exec
argument_list|(
name|globalDb
argument_list|,
literal|"PRAGMA page_count"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Load the schema */
while|while
condition|(
name|sqlite3_step
argument_list|(
name|pStmt
argument_list|)
operator|==
name|SQLITE_ROW
condition|)
block|{
specifier|const
name|char
modifier|*
name|zCompletion
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pStmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|nCompletion
init|=
name|sqlite3_column_bytes
argument_list|(
name|pStmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|iStart
operator|+
name|nCompletion
operator|<
sizeof|sizeof
argument_list|(
name|zBuf
argument_list|)
operator|-
literal|1
condition|)
block|{
name|memcpy
argument_list|(
name|zBuf
operator|+
name|iStart
argument_list|,
name|zCompletion
argument_list|,
name|nCompletion
operator|+
literal|1
argument_list|)
expr_stmt|;
name|linenoiseAddCompletion
argument_list|(
name|lc
argument_list|,
name|zBuf
argument_list|)
expr_stmt|;
block|}
block|}
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** Do C-language style dequoting. ** **    \a    -> alarm **    \b    -> backspace **    \t    -> tab **    \n    -> newline **    \v    -> vertical tab **    \f    -> form feed **    \r    -> carriage return **    \s    -> space **    \"    -> " **    \'    -> ' **    \\    -> backslash **    \NNN  -> ascii character NNN in octal */
end_comment

begin_function
specifier|static
name|void
name|resolve_backslashes
parameter_list|(
name|char
modifier|*
name|z
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|*
name|z
operator|&&
operator|*
name|z
operator|!=
literal|'\\'
condition|)
name|z
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
operator|(
name|c
operator|=
name|z
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
name|z
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
name|c
operator|=
name|z
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'a'
condition|)
block|{
name|c
operator|=
literal|'\a'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'b'
condition|)
block|{
name|c
operator|=
literal|'\b'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'t'
condition|)
block|{
name|c
operator|=
literal|'\t'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'n'
condition|)
block|{
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'v'
condition|)
block|{
name|c
operator|=
literal|'\v'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'f'
condition|)
block|{
name|c
operator|=
literal|'\f'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'r'
condition|)
block|{
name|c
operator|=
literal|'\r'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|c
operator|=
literal|'"'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
block|{
name|c
operator|=
literal|'\''
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
literal|'\\'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'7'
condition|)
block|{
name|c
operator|-=
literal|'0'
expr_stmt|;
if|if
condition|(
name|z
index|[
name|i
operator|+
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|z
index|[
name|i
operator|+
literal|1
index|]
operator|<=
literal|'7'
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|c
operator|=
operator|(
name|c
operator|<<
literal|3
operator|)
operator|+
name|z
index|[
name|i
index|]
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|z
index|[
name|i
operator|+
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|z
index|[
name|i
operator|+
literal|1
index|]
operator|<=
literal|'7'
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|c
operator|=
operator|(
name|c
operator|<<
literal|3
operator|)
operator|+
name|z
index|[
name|i
index|]
operator|-
literal|'0'
expr_stmt|;
block|}
block|}
block|}
block|}
name|z
index|[
name|j
index|]
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|<
name|i
condition|)
name|z
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Return the value of a hexadecimal digit.  Return -1 if the input ** is not a hex digit. */
end_comment

begin_function
specifier|static
name|int
name|hexDigitValue
parameter_list|(
name|char
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
return|return
name|c
operator|-
literal|'0'
return|;
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
return|return
name|c
operator|-
literal|'a'
operator|+
literal|10
return|;
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
condition|)
return|return
name|c
operator|-
literal|'A'
operator|+
literal|10
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ** Interpret zArg as an integer value, possibly with suffixes. */
end_comment

begin_function
specifier|static
name|sqlite3_int64
name|integerValue
parameter_list|(
specifier|const
name|char
modifier|*
name|zArg
parameter_list|)
block|{
name|sqlite3_int64
name|v
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
struct|struct
block|{
name|char
modifier|*
name|zSuffix
decl_stmt|;
name|int
name|iMult
decl_stmt|;
block|}
name|aMult
index|[]
init|=
block|{
block|{
literal|"KiB"
block|,
literal|1024
block|}
block|,
block|{
literal|"MiB"
block|,
literal|1024
operator|*
literal|1024
block|}
block|,
block|{
literal|"GiB"
block|,
literal|1024
operator|*
literal|1024
operator|*
literal|1024
block|}
block|,
block|{
literal|"KB"
block|,
literal|1000
block|}
block|,
block|{
literal|"MB"
block|,
literal|1000000
block|}
block|,
block|{
literal|"GB"
block|,
literal|1000000000
block|}
block|,
block|{
literal|"K"
block|,
literal|1000
block|}
block|,
block|{
literal|"M"
block|,
literal|1000000
block|}
block|,
block|{
literal|"G"
block|,
literal|1000000000
block|}
block|,   }
struct|;
name|int
name|i
decl_stmt|;
name|int
name|isNeg
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|zArg
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|isNeg
operator|=
literal|1
expr_stmt|;
name|zArg
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zArg
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
block|{
name|zArg
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|zArg
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|zArg
index|[
literal|1
index|]
operator|==
literal|'x'
condition|)
block|{
name|int
name|x
decl_stmt|;
name|zArg
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|(
name|x
operator|=
name|hexDigitValue
argument_list|(
name|zArg
index|[
literal|0
index|]
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|v
operator|=
operator|(
name|v
operator|<<
literal|4
operator|)
operator|+
name|x
expr_stmt|;
name|zArg
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|IsDigit
argument_list|(
name|zArg
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|v
operator|=
name|v
operator|*
literal|10
operator|+
name|zArg
index|[
literal|0
index|]
operator|-
literal|'0'
expr_stmt|;
name|zArg
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|aMult
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sqlite3_stricmp
argument_list|(
name|aMult
index|[
name|i
index|]
operator|.
name|zSuffix
argument_list|,
name|zArg
argument_list|)
operator|==
literal|0
condition|)
block|{
name|v
operator|*=
name|aMult
index|[
name|i
index|]
operator|.
name|iMult
expr_stmt|;
break|break;
block|}
block|}
return|return
name|isNeg
condition|?
operator|-
name|v
else|:
name|v
return|;
block|}
end_function

begin_comment
comment|/* ** Interpret zArg as either an integer or a boolean value.  Return 1 or 0 ** for TRUE and FALSE.  Return the integer value if appropriate. */
end_comment

begin_function
specifier|static
name|int
name|booleanValue
parameter_list|(
specifier|const
name|char
modifier|*
name|zArg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|zArg
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|zArg
index|[
literal|1
index|]
operator|==
literal|'x'
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|2
init|;
name|hexDigitValue
argument_list|(
name|zArg
index|[
name|i
index|]
argument_list|)
operator|>=
literal|0
condition|;
name|i
operator|++
control|)
block|{}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|zArg
index|[
name|i
index|]
operator|>=
literal|'0'
operator|&&
name|zArg
index|[
name|i
index|]
operator|<=
literal|'9'
condition|;
name|i
operator|++
control|)
block|{}
block|}
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|zArg
index|[
name|i
index|]
operator|==
literal|0
condition|)
return|return
call|(
name|int
call|)
argument_list|(
name|integerValue
argument_list|(
name|zArg
argument_list|)
operator|&
literal|0xffffffff
argument_list|)
return|;
if|if
condition|(
name|sqlite3_stricmp
argument_list|(
name|zArg
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
operator|||
name|sqlite3_stricmp
argument_list|(
name|zArg
argument_list|,
literal|"yes"
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
name|sqlite3_stricmp
argument_list|(
name|zArg
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
operator|||
name|sqlite3_stricmp
argument_list|(
name|zArg
argument_list|,
literal|"no"
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: Not a boolean value: \"%s\". Assuming \"no\".\n"
argument_list|,
name|zArg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ** Set or clear a shell flag according to a boolean value. */
end_comment

begin_function
specifier|static
name|void
name|setOrClearFlag
parameter_list|(
name|ShellState
modifier|*
name|p
parameter_list|,
name|unsigned
name|mFlag
parameter_list|,
specifier|const
name|char
modifier|*
name|zArg
parameter_list|)
block|{
if|if
condition|(
name|booleanValue
argument_list|(
name|zArg
argument_list|)
condition|)
block|{
name|ShellSetFlag
argument_list|(
name|p
argument_list|,
name|mFlag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ShellClearFlag
argument_list|(
name|p
argument_list|,
name|mFlag
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** Close an output file, assuming it is not stderr or stdout */
end_comment

begin_function
specifier|static
name|void
name|output_file_close
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
if|if
condition|(
name|f
operator|&&
name|f
operator|!=
name|stdout
operator|&&
name|f
operator|!=
name|stderr
condition|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Try to open an output file.   The names "stdout" and "stderr" are ** recognized and do the right thing.  NULL is returned if the output ** filename is "off". */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|output_file_open
parameter_list|(
specifier|const
name|char
modifier|*
name|zFile
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|zFile
argument_list|,
literal|"stdout"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|f
operator|=
name|stdout
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|zFile
argument_list|,
literal|"stderr"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|f
operator|=
name|stderr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|zFile
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|f
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|f
operator|=
name|fopen
argument_list|(
name|zFile
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: cannot open \"%s\"\n"
argument_list|,
name|zFile
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|f
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SQLITE_UNTESTABLE
argument_list|)
end_if

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SQLITE_OMIT_TRACE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SQLITE_OMIT_FLOATING_POINT
argument_list|)
end_if

begin_comment
comment|/* ** A routine for handling output from sqlite3_trace(). */
end_comment

begin_function
specifier|static
name|int
name|sql_trace_callback
parameter_list|(
name|unsigned
name|mType
parameter_list|,
name|void
modifier|*
name|pArg
parameter_list|,
name|void
modifier|*
name|pP
parameter_list|,
name|void
modifier|*
name|pX
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
operator|(
name|FILE
operator|*
operator|)
name|pArg
decl_stmt|;
name|UNUSED_PARAMETER
argument_list|(
name|mType
argument_list|)
expr_stmt|;
name|UNUSED_PARAMETER
argument_list|(
name|pP
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
block|{
specifier|const
name|char
modifier|*
name|z
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|pX
decl_stmt|;
name|int
name|i
init|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|z
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
operator|&&
name|z
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|';'
condition|)
block|{
name|i
operator|--
expr_stmt|;
block|}
name|utf8_printf
argument_list|(
name|f
argument_list|,
literal|"%.*s;\n"
argument_list|,
name|i
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** A no-op routine that runs with the ".breakpoint" doc-command.  This is ** a useful spot to set a debugger breakpoint. */
end_comment

begin_function
specifier|static
name|void
name|test_breakpoint
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|nCall
init|=
literal|0
decl_stmt|;
name|nCall
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** An object used to read a CSV and other files for import. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|ImportCtx
name|ImportCtx
typedef|;
end_typedef

begin_struct
struct|struct
name|ImportCtx
block|{
specifier|const
name|char
modifier|*
name|zFile
decl_stmt|;
comment|/* Name of the input file */
name|FILE
modifier|*
name|in
decl_stmt|;
comment|/* Read the CSV text from this input stream */
name|char
modifier|*
name|z
decl_stmt|;
comment|/* Accumulated text for a field */
name|int
name|n
decl_stmt|;
comment|/* Number of bytes in z */
name|int
name|nAlloc
decl_stmt|;
comment|/* Space allocated for z[] */
name|int
name|nLine
decl_stmt|;
comment|/* Current line number */
name|int
name|bNotFirst
decl_stmt|;
comment|/* True if one or more bytes already read */
name|int
name|cTerm
decl_stmt|;
comment|/* Character that terminated the most recent field */
name|int
name|cColSep
decl_stmt|;
comment|/* The column separator character.  (Usually ",") */
name|int
name|cRowSep
decl_stmt|;
comment|/* The row separator character.  (Usually "\n") */
block|}
struct|;
end_struct

begin_comment
comment|/* Append a single byte to z[] */
end_comment

begin_function
specifier|static
name|void
name|import_append_char
parameter_list|(
name|ImportCtx
modifier|*
name|p
parameter_list|,
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|n
operator|+
literal|1
operator|>=
name|p
operator|->
name|nAlloc
condition|)
block|{
name|p
operator|->
name|nAlloc
operator|+=
name|p
operator|->
name|nAlloc
operator|+
literal|100
expr_stmt|;
name|p
operator|->
name|z
operator|=
name|sqlite3_realloc64
argument_list|(
name|p
operator|->
name|z
argument_list|,
name|p
operator|->
name|nAlloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|z
operator|==
literal|0
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|p
operator|->
name|z
index|[
name|p
operator|->
name|n
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a single field of CSV text.  Compatible with rfc4180 and extended ** with the option of having a separator other than ",". ** **   +  Input comes from p->in. **   +  Store results in p->z of length p->n.  Space to hold p->z comes **      from sqlite3_malloc64(). **   +  Use p->cSep as the column separator.  The default is ",". **   +  Use p->rSep as the row separator.  The default is "\n". **   +  Keep track of the line number in p->nLine. **   +  Store the character that terminates the field in p->cTerm.  Store **      EOF on end-of-file. **   +  Report syntax errors on stderr */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|SQLITE_CDECL
name|csv_read_one_field
parameter_list|(
name|ImportCtx
modifier|*
name|p
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|cSep
init|=
name|p
operator|->
name|cColSep
decl_stmt|;
name|int
name|rSep
init|=
name|p
operator|->
name|cRowSep
decl_stmt|;
name|p
operator|->
name|n
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|fgetc
argument_list|(
name|p
operator|->
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
operator|||
name|seenInterrupt
condition|)
block|{
name|p
operator|->
name|cTerm
operator|=
name|EOF
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|int
name|pc
decl_stmt|,
name|ppc
decl_stmt|;
name|int
name|startLine
init|=
name|p
operator|->
name|nLine
decl_stmt|;
name|int
name|cQuote
init|=
name|c
decl_stmt|;
name|pc
operator|=
name|ppc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|fgetc
argument_list|(
name|p
operator|->
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|rSep
condition|)
name|p
operator|->
name|nLine
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|cQuote
condition|)
block|{
if|if
condition|(
name|pc
operator|==
name|cQuote
condition|)
block|{
name|pc
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|(
name|c
operator|==
name|cSep
operator|&&
name|pc
operator|==
name|cQuote
operator|)
operator|||
operator|(
name|c
operator|==
name|rSep
operator|&&
name|pc
operator|==
name|cQuote
operator|)
operator|||
operator|(
name|c
operator|==
name|rSep
operator|&&
name|pc
operator|==
literal|'\r'
operator|&&
name|ppc
operator|==
name|cQuote
operator|)
operator|||
operator|(
name|c
operator|==
name|EOF
operator|&&
name|pc
operator|==
name|cQuote
operator|)
condition|)
block|{
do|do
block|{
name|p
operator|->
name|n
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|->
name|z
index|[
name|p
operator|->
name|n
index|]
operator|!=
name|cQuote
condition|)
do|;
name|p
operator|->
name|cTerm
operator|=
name|c
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pc
operator|==
name|cQuote
operator|&&
name|c
operator|!=
literal|'\r'
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: unescaped %c character\n"
argument_list|,
name|p
operator|->
name|zFile
argument_list|,
name|p
operator|->
name|nLine
argument_list|,
name|cQuote
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: unterminated %c-quoted field\n"
argument_list|,
name|p
operator|->
name|zFile
argument_list|,
name|startLine
argument_list|,
name|cQuote
argument_list|)
expr_stmt|;
name|p
operator|->
name|cTerm
operator|=
name|c
expr_stmt|;
break|break;
block|}
name|import_append_char
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|ppc
operator|=
name|pc
expr_stmt|;
name|pc
operator|=
name|c
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If this is the first field being parsed and it begins with the     ** UTF-8 BOM  (0xEF BB BF) then skip the BOM */
if|if
condition|(
operator|(
name|c
operator|&
literal|0xff
operator|)
operator|==
literal|0xef
operator|&&
name|p
operator|->
name|bNotFirst
operator|==
literal|0
condition|)
block|{
name|import_append_char
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|fgetc
argument_list|(
name|p
operator|->
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|&
literal|0xff
operator|)
operator|==
literal|0xbb
condition|)
block|{
name|import_append_char
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|fgetc
argument_list|(
name|p
operator|->
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|&
literal|0xff
operator|)
operator|==
literal|0xbf
condition|)
block|{
name|p
operator|->
name|bNotFirst
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|n
operator|=
literal|0
expr_stmt|;
return|return
name|csv_read_one_field
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
block|}
while|while
condition|(
name|c
operator|!=
name|EOF
operator|&&
name|c
operator|!=
name|cSep
operator|&&
name|c
operator|!=
name|rSep
condition|)
block|{
name|import_append_char
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|fgetc
argument_list|(
name|p
operator|->
name|in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|rSep
condition|)
block|{
name|p
operator|->
name|nLine
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|n
operator|>
literal|0
operator|&&
name|p
operator|->
name|z
index|[
name|p
operator|->
name|n
operator|-
literal|1
index|]
operator|==
literal|'\r'
condition|)
name|p
operator|->
name|n
operator|--
expr_stmt|;
block|}
name|p
operator|->
name|cTerm
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|z
condition|)
name|p
operator|->
name|z
index|[
name|p
operator|->
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|bNotFirst
operator|=
literal|1
expr_stmt|;
return|return
name|p
operator|->
name|z
return|;
block|}
end_function

begin_comment
comment|/* Read a single field of ASCII delimited text. ** **   +  Input comes from p->in. **   +  Store results in p->z of length p->n.  Space to hold p->z comes **      from sqlite3_malloc64(). **   +  Use p->cSep as the column separator.  The default is "\x1F". **   +  Use p->rSep as the row separator.  The default is "\x1E". **   +  Keep track of the row number in p->nLine. **   +  Store the character that terminates the field in p->cTerm.  Store **      EOF on end-of-file. **   +  Report syntax errors on stderr */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|SQLITE_CDECL
name|ascii_read_one_field
parameter_list|(
name|ImportCtx
modifier|*
name|p
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|cSep
init|=
name|p
operator|->
name|cColSep
decl_stmt|;
name|int
name|rSep
init|=
name|p
operator|->
name|cRowSep
decl_stmt|;
name|p
operator|->
name|n
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|fgetc
argument_list|(
name|p
operator|->
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
operator|||
name|seenInterrupt
condition|)
block|{
name|p
operator|->
name|cTerm
operator|=
name|EOF
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
name|c
operator|!=
name|EOF
operator|&&
name|c
operator|!=
name|cSep
operator|&&
name|c
operator|!=
name|rSep
condition|)
block|{
name|import_append_char
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|fgetc
argument_list|(
name|p
operator|->
name|in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|rSep
condition|)
block|{
name|p
operator|->
name|nLine
operator|++
expr_stmt|;
block|}
name|p
operator|->
name|cTerm
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|z
condition|)
name|p
operator|->
name|z
index|[
name|p
operator|->
name|n
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|p
operator|->
name|z
return|;
block|}
end_function

begin_comment
comment|/* ** Try to transfer data for table zTable.  If an error is seen while ** moving forward, try to go backwards.  The backwards movement won't ** work for WITHOUT ROWID tables. */
end_comment

begin_function
specifier|static
name|void
name|tryToCloneData
parameter_list|(
name|ShellState
modifier|*
name|p
parameter_list|,
name|sqlite3
modifier|*
name|newDb
parameter_list|,
specifier|const
name|char
modifier|*
name|zTable
parameter_list|)
block|{
name|sqlite3_stmt
modifier|*
name|pQuery
init|=
literal|0
decl_stmt|;
name|sqlite3_stmt
modifier|*
name|pInsert
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|zQuery
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|zInsert
init|=
literal|0
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|;
name|int
name|nTable
init|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|zTable
argument_list|)
decl_stmt|;
name|int
name|k
init|=
literal|0
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
specifier|const
name|int
name|spinRate
init|=
literal|10000
decl_stmt|;
name|zQuery
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"SELECT * FROM \"%w\""
argument_list|,
name|zTable
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zQuery
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pQuery
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error %d: %s on [%s]\n"
argument_list|,
name|sqlite3_extended_errcode
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|,
name|zQuery
argument_list|)
expr_stmt|;
goto|goto
name|end_data_xfer
goto|;
block|}
name|n
operator|=
name|sqlite3_column_count
argument_list|(
name|pQuery
argument_list|)
expr_stmt|;
name|zInsert
operator|=
name|sqlite3_malloc64
argument_list|(
literal|200
operator|+
name|nTable
operator|+
name|n
operator|*
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|zInsert
operator|==
literal|0
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"out of memory\n"
argument_list|)
expr_stmt|;
goto|goto
name|end_data_xfer
goto|;
block|}
name|sqlite3_snprintf
argument_list|(
literal|200
operator|+
name|nTable
argument_list|,
name|zInsert
argument_list|,
literal|"INSERT OR IGNORE INTO \"%s\" VALUES(?"
argument_list|,
name|zTable
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|zInsert
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|zInsert
operator|+
name|i
argument_list|,
literal|",?"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|zInsert
operator|+
name|i
argument_list|,
literal|");"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|newDb
argument_list|,
name|zInsert
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pInsert
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error %d: %s on [%s]\n"
argument_list|,
name|sqlite3_extended_errcode
argument_list|(
name|newDb
argument_list|)
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|newDb
argument_list|)
argument_list|,
name|zQuery
argument_list|)
expr_stmt|;
goto|goto
name|end_data_xfer
goto|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|2
condition|;
name|k
operator|++
control|)
block|{
while|while
condition|(
operator|(
name|rc
operator|=
name|sqlite3_step
argument_list|(
name|pQuery
argument_list|)
operator|)
operator|==
name|SQLITE_ROW
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|sqlite3_column_type
argument_list|(
name|pQuery
argument_list|,
name|i
argument_list|)
condition|)
block|{
case|case
name|SQLITE_NULL
case|:
block|{
name|sqlite3_bind_null
argument_list|(
name|pInsert
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SQLITE_INTEGER
case|:
block|{
name|sqlite3_bind_int64
argument_list|(
name|pInsert
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|sqlite3_column_int64
argument_list|(
name|pQuery
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SQLITE_FLOAT
case|:
block|{
name|sqlite3_bind_double
argument_list|(
name|pInsert
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|sqlite3_column_double
argument_list|(
name|pQuery
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SQLITE_TEXT
case|:
block|{
name|sqlite3_bind_text
argument_list|(
name|pInsert
argument_list|,
name|i
operator|+
literal|1
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pQuery
argument_list|,
name|i
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
name|SQLITE_STATIC
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SQLITE_BLOB
case|:
block|{
name|sqlite3_bind_blob
argument_list|(
name|pInsert
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|sqlite3_column_blob
argument_list|(
name|pQuery
argument_list|,
name|i
argument_list|)
argument_list|,
name|sqlite3_column_bytes
argument_list|(
name|pQuery
argument_list|,
name|i
argument_list|)
argument_list|,
name|SQLITE_STATIC
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* End for */
name|rc
operator|=
name|sqlite3_step
argument_list|(
name|pInsert
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
operator|&&
name|rc
operator|!=
name|SQLITE_ROW
operator|&&
name|rc
operator|!=
name|SQLITE_DONE
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error %d: %s\n"
argument_list|,
name|sqlite3_extended_errcode
argument_list|(
name|newDb
argument_list|)
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|newDb
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sqlite3_reset
argument_list|(
name|pInsert
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|cnt
operator|%
name|spinRate
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%c\b"
argument_list|,
literal|"|/-\\"
index|[
operator|(
name|cnt
operator|/
name|spinRate
operator|)
operator|%
literal|4
index|]
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* End while */
if|if
condition|(
name|rc
operator|==
name|SQLITE_DONE
condition|)
break|break;
name|sqlite3_finalize
argument_list|(
name|pQuery
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zQuery
argument_list|)
expr_stmt|;
name|zQuery
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"SELECT * FROM \"%w\" ORDER BY rowid DESC;"
argument_list|,
name|zTable
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zQuery
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pQuery
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: cannot step \"%s\" backwards"
argument_list|,
name|zTable
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* End for(k=0...) */
name|end_data_xfer
label|:
name|sqlite3_finalize
argument_list|(
name|pQuery
argument_list|)
expr_stmt|;
name|sqlite3_finalize
argument_list|(
name|pInsert
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zQuery
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zInsert
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Try to transfer all rows of the schema that match zWhere.  For ** each row, invoke xForEach() on the object defined by that row. ** If an error is encountered while moving forward through the ** sqlite_master table, try again moving backwards. */
end_comment

begin_function
specifier|static
name|void
name|tryToCloneSchema
parameter_list|(
name|ShellState
modifier|*
name|p
parameter_list|,
name|sqlite3
modifier|*
name|newDb
parameter_list|,
specifier|const
name|char
modifier|*
name|zWhere
parameter_list|,
name|void
function_decl|(
modifier|*
name|xForEach
function_decl|)
parameter_list|(
name|ShellState
modifier|*
parameter_list|,
name|sqlite3
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
parameter_list|)
block|{
name|sqlite3_stmt
modifier|*
name|pQuery
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|zQuery
init|=
literal|0
decl_stmt|;
name|int
name|rc
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|zName
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|zSql
decl_stmt|;
name|char
modifier|*
name|zErrMsg
init|=
literal|0
decl_stmt|;
name|zQuery
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"SELECT name, sql FROM sqlite_master"
literal|" WHERE %s"
argument_list|,
name|zWhere
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zQuery
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pQuery
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: (%d) %s on [%s]\n"
argument_list|,
name|sqlite3_extended_errcode
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|,
name|zQuery
argument_list|)
expr_stmt|;
goto|goto
name|end_schema_xfer
goto|;
block|}
while|while
condition|(
operator|(
name|rc
operator|=
name|sqlite3_step
argument_list|(
name|pQuery
argument_list|)
operator|)
operator|==
name|SQLITE_ROW
condition|)
block|{
name|zName
operator|=
name|sqlite3_column_text
argument_list|(
name|pQuery
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zSql
operator|=
name|sqlite3_column_text
argument_list|(
name|pQuery
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s... "
argument_list|,
name|zName
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sqlite3_exec
argument_list|(
name|newDb
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|zSql
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|zErrMsg
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\nSQL: [%s]\n"
argument_list|,
name|zErrMsg
argument_list|,
name|zSql
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zErrMsg
argument_list|)
expr_stmt|;
name|zErrMsg
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|xForEach
condition|)
block|{
name|xForEach
argument_list|(
name|p
argument_list|,
name|newDb
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|zName
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|!=
name|SQLITE_DONE
condition|)
block|{
name|sqlite3_finalize
argument_list|(
name|pQuery
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zQuery
argument_list|)
expr_stmt|;
name|zQuery
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"SELECT name, sql FROM sqlite_master"
literal|" WHERE %s ORDER BY rowid DESC"
argument_list|,
name|zWhere
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zQuery
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pQuery
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: (%d) %s on [%s]\n"
argument_list|,
name|sqlite3_extended_errcode
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|,
name|zQuery
argument_list|)
expr_stmt|;
goto|goto
name|end_schema_xfer
goto|;
block|}
while|while
condition|(
operator|(
name|rc
operator|=
name|sqlite3_step
argument_list|(
name|pQuery
argument_list|)
operator|)
operator|==
name|SQLITE_ROW
condition|)
block|{
name|zName
operator|=
name|sqlite3_column_text
argument_list|(
name|pQuery
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zSql
operator|=
name|sqlite3_column_text
argument_list|(
name|pQuery
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s... "
argument_list|,
name|zName
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sqlite3_exec
argument_list|(
name|newDb
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|zSql
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|zErrMsg
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\nSQL: [%s]\n"
argument_list|,
name|zErrMsg
argument_list|,
name|zSql
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zErrMsg
argument_list|)
expr_stmt|;
name|zErrMsg
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|xForEach
condition|)
block|{
name|xForEach
argument_list|(
name|p
argument_list|,
name|newDb
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|zName
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|end_schema_xfer
label|:
name|sqlite3_finalize
argument_list|(
name|pQuery
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zQuery
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Open a new database file named "zNewDb".  Try to recover as much information ** as possible out of the main database (which might be corrupt) and write it ** into zNewDb. */
end_comment

begin_function
specifier|static
name|void
name|tryToClone
parameter_list|(
name|ShellState
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|zNewDb
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|sqlite3
modifier|*
name|newDb
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|access
argument_list|(
name|zNewDb
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"File \"%s\" already exists.\n"
argument_list|,
name|zNewDb
argument_list|)
expr_stmt|;
return|return;
block|}
name|rc
operator|=
name|sqlite3_open
argument_list|(
name|zNewDb
argument_list|,
operator|&
name|newDb
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot create output database: %s\n"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|newDb
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"PRAGMA writable_schema=ON;"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_exec
argument_list|(
name|newDb
argument_list|,
literal|"BEGIN EXCLUSIVE;"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tryToCloneSchema
argument_list|(
name|p
argument_list|,
name|newDb
argument_list|,
literal|"type='table'"
argument_list|,
name|tryToCloneData
argument_list|)
expr_stmt|;
name|tryToCloneSchema
argument_list|(
name|p
argument_list|,
name|newDb
argument_list|,
literal|"type!='table'"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_exec
argument_list|(
name|newDb
argument_list|,
literal|"COMMIT;"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"PRAGMA writable_schema=OFF;"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sqlite3_close
argument_list|(
name|newDb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Change the output file back to stdout */
end_comment

begin_function
specifier|static
name|void
name|output_reset
parameter_list|(
name|ShellState
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|outfile
index|[
literal|0
index|]
operator|==
literal|'|'
condition|)
block|{
ifndef|#
directive|ifndef
name|SQLITE_OMIT_POPEN
name|pclose
argument_list|(
name|p
operator|->
name|out
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|output_file_close
argument_list|(
name|p
operator|->
name|out
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|outfile
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|out
operator|=
name|stdout
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Run an SQL command and return the single integer result. */
end_comment

begin_function
specifier|static
name|int
name|db_int
parameter_list|(
name|ShellState
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|zSql
parameter_list|)
block|{
name|sqlite3_stmt
modifier|*
name|pStmt
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
name|sqlite3_prepare_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zSql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pStmt
operator|&&
name|sqlite3_step
argument_list|(
name|pStmt
argument_list|)
operator|==
name|SQLITE_ROW
condition|)
block|{
name|res
operator|=
name|sqlite3_column_int
argument_list|(
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* ** Convert a 2-byte or 4-byte big-endian integer into a native integer */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|get2byteInt
parameter_list|(
name|unsigned
name|char
modifier|*
name|a
parameter_list|)
block|{
return|return
operator|(
name|a
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator|+
name|a
index|[
literal|1
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|get4byteInt
parameter_list|(
name|unsigned
name|char
modifier|*
name|a
parameter_list|)
block|{
return|return
operator|(
name|a
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator|+
operator|(
name|a
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|a
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
name|a
index|[
literal|3
index|]
return|;
block|}
end_function

begin_comment
comment|/* ** Implementation of the ".info" command. ** ** Return 1 on error, 2 to exit, and 0 otherwise. */
end_comment

begin_function
specifier|static
name|int
name|shell_dbinfo_command
parameter_list|(
name|ShellState
modifier|*
name|p
parameter_list|,
name|int
name|nArg
parameter_list|,
name|char
modifier|*
modifier|*
name|azArg
parameter_list|)
block|{
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|zName
decl_stmt|;
name|int
name|ofst
decl_stmt|;
block|}
name|aField
index|[]
init|=
block|{
block|{
literal|"file change counter:"
block|,
literal|24
block|}
block|,
block|{
literal|"database page count:"
block|,
literal|28
block|}
block|,
block|{
literal|"freelist page count:"
block|,
literal|36
block|}
block|,
block|{
literal|"schema cookie:"
block|,
literal|40
block|}
block|,
block|{
literal|"schema format:"
block|,
literal|44
block|}
block|,
block|{
literal|"default cache size:"
block|,
literal|48
block|}
block|,
block|{
literal|"autovacuum top root:"
block|,
literal|52
block|}
block|,
block|{
literal|"incremental vacuum:"
block|,
literal|64
block|}
block|,
block|{
literal|"text encoding:"
block|,
literal|56
block|}
block|,
block|{
literal|"user version:"
block|,
literal|60
block|}
block|,
block|{
literal|"application id:"
block|,
literal|68
block|}
block|,
block|{
literal|"software version:"
block|,
literal|96
block|}
block|,   }
struct|;
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|zName
decl_stmt|;
specifier|const
name|char
modifier|*
name|zSql
decl_stmt|;
block|}
name|aQuery
index|[]
init|=
block|{
block|{
literal|"number of tables:"
block|,
literal|"SELECT count(*) FROM %s WHERE type='table'"
block|}
block|,
block|{
literal|"number of indexes:"
block|,
literal|"SELECT count(*) FROM %s WHERE type='index'"
block|}
block|,
block|{
literal|"number of triggers:"
block|,
literal|"SELECT count(*) FROM %s WHERE type='trigger'"
block|}
block|,
block|{
literal|"number of views:"
block|,
literal|"SELECT count(*) FROM %s WHERE type='view'"
block|}
block|,
block|{
literal|"schema size:"
block|,
literal|"SELECT total(length(sql)) FROM %s"
block|}
block|,   }
struct|;
name|sqlite3_file
modifier|*
name|pFile
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|zSchemaTab
decl_stmt|;
name|char
modifier|*
name|zDb
init|=
name|nArg
operator|>=
literal|2
condition|?
name|azArg
index|[
literal|1
index|]
else|:
literal|"main"
decl_stmt|;
name|unsigned
name|char
name|aHdr
index|[
literal|100
index|]
decl_stmt|;
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|db
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|sqlite3_file_control
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zDb
argument_list|,
name|SQLITE_FCNTL_FILE_POINTER
argument_list|,
operator|&
name|pFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|pFile
operator|==
literal|0
operator|||
name|pFile
operator|->
name|pMethods
operator|==
literal|0
operator|||
name|pFile
operator|->
name|pMethods
operator|->
name|xRead
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
name|i
operator|=
name|pFile
operator|->
name|pMethods
operator|->
name|xRead
argument_list|(
name|pFile
argument_list|,
name|aHdr
argument_list|,
literal|100
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|SQLITE_OK
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"unable to read database header\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|i
operator|=
name|get2byteInt
argument_list|(
name|aHdr
operator|+
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|i
operator|=
literal|65536
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%-20s %d\n"
argument_list|,
literal|"database page size:"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%-20s %d\n"
argument_list|,
literal|"write format:"
argument_list|,
name|aHdr
index|[
literal|18
index|]
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%-20s %d\n"
argument_list|,
literal|"read format:"
argument_list|,
name|aHdr
index|[
literal|19
index|]
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%-20s %d\n"
argument_list|,
literal|"reserved bytes:"
argument_list|,
name|aHdr
index|[
literal|20
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|aField
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ofst
init|=
name|aField
index|[
name|i
index|]
operator|.
name|ofst
decl_stmt|;
name|unsigned
name|int
name|val
init|=
name|get4byteInt
argument_list|(
name|aHdr
operator|+
name|ofst
argument_list|)
decl_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%-20s %u"
argument_list|,
name|aField
index|[
name|i
index|]
operator|.
name|zName
argument_list|,
name|val
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ofst
condition|)
block|{
case|case
literal|56
case|:
block|{
if|if
condition|(
name|val
operator|==
literal|1
condition|)
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|" (utf8)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|2
condition|)
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|" (utf16le)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|3
condition|)
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|" (utf16be)"
argument_list|)
expr_stmt|;
block|}
block|}
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zDb
operator|==
literal|0
condition|)
block|{
name|zSchemaTab
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"main.sqlite_master"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|zDb
argument_list|,
literal|"temp"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zSchemaTab
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"%s"
argument_list|,
literal|"sqlite_temp_master"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zSchemaTab
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"\"%w\".sqlite_master"
argument_list|,
name|zDb
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|aQuery
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|zSql
init|=
name|sqlite3_mprintf
argument_list|(
name|aQuery
index|[
name|i
index|]
operator|.
name|zSql
argument_list|,
name|zSchemaTab
argument_list|)
decl_stmt|;
name|int
name|val
init|=
name|db_int
argument_list|(
name|p
argument_list|,
name|zSql
argument_list|)
decl_stmt|;
name|sqlite3_free
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%-20s %d\n"
argument_list|,
name|aQuery
index|[
name|i
index|]
operator|.
name|zName
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|sqlite3_free
argument_list|(
name|zSchemaTab
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ** Print the current sqlite3_errmsg() value to stderr and return 1. */
end_comment

begin_function
specifier|static
name|int
name|shellDatabaseError
parameter_list|(
name|sqlite3
modifier|*
name|db
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|zErr
init|=
name|sqlite3_errmsg
argument_list|(
name|db
argument_list|)
decl_stmt|;
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|zErr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ** Print an out-of-memory message to stderr and return 1. */
end_comment

begin_function
specifier|static
name|int
name|shellNomemError
parameter_list|(
name|void
parameter_list|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: out of memory\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ** Compare the pattern in zGlob[] against the text in z[].  Return TRUE ** if they match and FALSE (0) if they do not match. ** ** Globbing rules: ** **      '*'       Matches any sequence of zero or more characters. ** **      '?'       Matches exactly one character. ** **     [...]      Matches one character from the enclosed list of **                characters. ** **     [^...]     Matches one character not in the enclosed list. ** **      '#'       Matches any sequence of one or more digits with an **                optional + or - sign in front ** **      ' '       Any span of whitespace matches any other span of **                whitespace. ** ** Extra whitespace at the end of z[] is ignored. */
end_comment

begin_function
specifier|static
name|int
name|testcase_glob
parameter_list|(
specifier|const
name|char
modifier|*
name|zGlob
parameter_list|,
specifier|const
name|char
modifier|*
name|z
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|c2
decl_stmt|;
name|int
name|invert
decl_stmt|;
name|int
name|seen
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|(
name|zGlob
operator|++
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|IsSpace
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|IsSpace
argument_list|(
operator|*
name|z
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|IsSpace
argument_list|(
operator|*
name|zGlob
argument_list|)
condition|)
name|zGlob
operator|++
expr_stmt|;
while|while
condition|(
name|IsSpace
argument_list|(
operator|*
name|z
argument_list|)
condition|)
name|z
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|(
name|zGlob
operator|++
operator|)
operator|)
operator|)
operator|==
literal|'*'
operator|||
name|c
operator|==
literal|'?'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'?'
operator|&&
operator|(
operator|*
operator|(
name|z
operator|++
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'['
condition|)
block|{
while|while
condition|(
operator|*
name|z
operator|&&
name|testcase_glob
argument_list|(
name|zGlob
operator|-
literal|1
argument_list|,
name|z
argument_list|)
operator|==
literal|0
condition|)
block|{
name|z
operator|++
expr_stmt|;
block|}
return|return
operator|(
operator|*
name|z
operator|)
operator|!=
literal|0
return|;
block|}
while|while
condition|(
operator|(
name|c2
operator|=
operator|(
operator|*
operator|(
name|z
operator|++
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
name|c2
operator|!=
name|c
condition|)
block|{
name|c2
operator|=
operator|*
operator|(
name|z
operator|++
operator|)
expr_stmt|;
if|if
condition|(
name|c2
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|testcase_glob
argument_list|(
name|zGlob
argument_list|,
name|z
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'?'
condition|)
block|{
if|if
condition|(
operator|(
operator|*
operator|(
name|z
operator|++
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'['
condition|)
block|{
name|int
name|prior_c
init|=
literal|0
decl_stmt|;
name|seen
operator|=
literal|0
expr_stmt|;
name|invert
operator|=
literal|0
expr_stmt|;
name|c
operator|=
operator|*
operator|(
name|z
operator|++
operator|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|c2
operator|=
operator|*
operator|(
name|zGlob
operator|++
operator|)
expr_stmt|;
if|if
condition|(
name|c2
operator|==
literal|'^'
condition|)
block|{
name|invert
operator|=
literal|1
expr_stmt|;
name|c2
operator|=
operator|*
operator|(
name|zGlob
operator|++
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|c2
operator|==
literal|']'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|']'
condition|)
name|seen
operator|=
literal|1
expr_stmt|;
name|c2
operator|=
operator|*
operator|(
name|zGlob
operator|++
operator|)
expr_stmt|;
block|}
while|while
condition|(
name|c2
operator|&&
name|c2
operator|!=
literal|']'
condition|)
block|{
if|if
condition|(
name|c2
operator|==
literal|'-'
operator|&&
name|zGlob
index|[
literal|0
index|]
operator|!=
literal|']'
operator|&&
name|zGlob
index|[
literal|0
index|]
operator|!=
literal|0
operator|&&
name|prior_c
operator|>
literal|0
condition|)
block|{
name|c2
operator|=
operator|*
operator|(
name|zGlob
operator|++
operator|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
name|prior_c
operator|&&
name|c
operator|<=
name|c2
condition|)
name|seen
operator|=
literal|1
expr_stmt|;
name|prior_c
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|==
name|c2
condition|)
block|{
name|seen
operator|=
literal|1
expr_stmt|;
block|}
name|prior_c
operator|=
name|c2
expr_stmt|;
block|}
name|c2
operator|=
operator|*
operator|(
name|zGlob
operator|++
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|c2
operator|==
literal|0
operator|||
operator|(
name|seen
operator|^
name|invert
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
block|{
if|if
condition|(
operator|(
name|z
index|[
literal|0
index|]
operator|==
literal|'-'
operator|||
name|z
index|[
literal|0
index|]
operator|==
literal|'+'
operator|)
operator|&&
name|IsDigit
argument_list|(
name|z
index|[
literal|1
index|]
argument_list|)
condition|)
name|z
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|IsDigit
argument_list|(
name|z
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
name|z
operator|++
expr_stmt|;
while|while
condition|(
name|IsDigit
argument_list|(
name|z
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|z
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|c
operator|!=
operator|(
operator|*
operator|(
name|z
operator|++
operator|)
operator|)
condition|)
return|return
literal|0
return|;
block|}
block|}
while|while
condition|(
name|IsSpace
argument_list|(
operator|*
name|z
argument_list|)
condition|)
block|{
name|z
operator|++
expr_stmt|;
block|}
return|return
operator|*
name|z
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ** Compare the string as a command-line option with either one or two ** initial "-" characters. */
end_comment

begin_function
specifier|static
name|int
name|optionMatch
parameter_list|(
specifier|const
name|char
modifier|*
name|zStr
parameter_list|,
specifier|const
name|char
modifier|*
name|zOpt
parameter_list|)
block|{
if|if
condition|(
name|zStr
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
return|return
literal|0
return|;
name|zStr
operator|++
expr_stmt|;
if|if
condition|(
name|zStr
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|zStr
operator|++
expr_stmt|;
return|return
name|strcmp
argument_list|(
name|zStr
argument_list|,
name|zOpt
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ** Delete a file. */
end_comment

begin_function
name|int
name|shellDeleteFile
parameter_list|(
specifier|const
name|char
modifier|*
name|zFilename
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
name|wchar_t
modifier|*
name|z
init|=
name|sqlite3_win32_utf8_to_unicode
argument_list|(
name|zFilename
argument_list|)
decl_stmt|;
name|rc
operator|=
name|_wunlink
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|z
argument_list|)
expr_stmt|;
else|#
directive|else
name|rc
operator|=
name|unlink
argument_list|(
name|zFilename
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* ** The implementation of SQL scalar function fkey_collate_clause(), used ** by the ".lint fkey-indexes" command. This scalar function is always ** called with four arguments - the parent table name, the parent column name, ** the child table name and the child column name. ** **   fkey_collate_clause('parent-tab', 'parent-col', 'child-tab', 'child-col') ** ** If either of the named tables or columns do not exist, this function ** returns an empty string. An empty string is also returned if both tables ** and columns exist but have the same default collation sequence. Or, ** if both exist but the default collation sequences are different, this ** function returns the string " COLLATE<parent-collation>", where **<parent-collation> is the default collation sequence of the parent column. */
end_comment

begin_function
specifier|static
name|void
name|shellFkeyCollateClause
parameter_list|(
name|sqlite3_context
modifier|*
name|pCtx
parameter_list|,
name|int
name|nVal
parameter_list|,
name|sqlite3_value
modifier|*
modifier|*
name|apVal
parameter_list|)
block|{
name|sqlite3
modifier|*
name|db
init|=
name|sqlite3_context_db_handle
argument_list|(
name|pCtx
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|zParent
decl_stmt|;
specifier|const
name|char
modifier|*
name|zParentCol
decl_stmt|;
specifier|const
name|char
modifier|*
name|zParentSeq
decl_stmt|;
specifier|const
name|char
modifier|*
name|zChild
decl_stmt|;
specifier|const
name|char
modifier|*
name|zChildCol
decl_stmt|;
specifier|const
name|char
modifier|*
name|zChildSeq
init|=
literal|0
decl_stmt|;
comment|/* Initialize to avoid false-positive warning */
name|int
name|rc
decl_stmt|;
name|assert
argument_list|(
name|nVal
operator|==
literal|4
argument_list|)
expr_stmt|;
name|zParent
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_value_text
argument_list|(
name|apVal
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|zParentCol
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_value_text
argument_list|(
name|apVal
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|zChild
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_value_text
argument_list|(
name|apVal
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|zChildCol
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_value_text
argument_list|(
name|apVal
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sqlite3_result_text
argument_list|(
name|pCtx
argument_list|,
literal|""
argument_list|,
operator|-
literal|1
argument_list|,
name|SQLITE_STATIC
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_table_column_metadata
argument_list|(
name|db
argument_list|,
literal|"main"
argument_list|,
name|zParent
argument_list|,
name|zParentCol
argument_list|,
literal|0
argument_list|,
operator|&
name|zParentSeq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|SQLITE_OK
condition|)
block|{
name|rc
operator|=
name|sqlite3_table_column_metadata
argument_list|(
name|db
argument_list|,
literal|"main"
argument_list|,
name|zChild
argument_list|,
name|zChildCol
argument_list|,
literal|0
argument_list|,
operator|&
name|zChildSeq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|==
name|SQLITE_OK
operator|&&
name|sqlite3_stricmp
argument_list|(
name|zParentSeq
argument_list|,
name|zChildSeq
argument_list|)
condition|)
block|{
name|char
modifier|*
name|z
init|=
name|sqlite3_mprintf
argument_list|(
literal|" COLLATE %s"
argument_list|,
name|zParentSeq
argument_list|)
decl_stmt|;
name|sqlite3_result_text
argument_list|(
name|pCtx
argument_list|,
name|z
argument_list|,
operator|-
literal|1
argument_list|,
name|SQLITE_TRANSIENT
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|z
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** The implementation of dot-command ".lint fkey-indexes". */
end_comment

begin_function
specifier|static
name|int
name|lintFkeyIndexes
parameter_list|(
name|ShellState
modifier|*
name|pState
parameter_list|,
comment|/* Current shell tool state */
name|char
modifier|*
modifier|*
name|azArg
parameter_list|,
comment|/* Array of arguments passed to dot command */
name|int
name|nArg
comment|/* Number of entries in azArg[] */
parameter_list|)
block|{
name|sqlite3
modifier|*
name|db
init|=
name|pState
operator|->
name|db
decl_stmt|;
comment|/* Database handle to query "main" db of */
name|FILE
modifier|*
name|out
init|=
name|pState
operator|->
name|out
decl_stmt|;
comment|/* Stream to write non-error output to */
name|int
name|bVerbose
init|=
literal|0
decl_stmt|;
comment|/* If -verbose is present */
name|int
name|bGroupByParent
init|=
literal|0
decl_stmt|;
comment|/* If -groupbyparent is present */
name|int
name|i
decl_stmt|;
comment|/* To iterate through azArg[] */
specifier|const
name|char
modifier|*
name|zIndent
init|=
literal|""
decl_stmt|;
comment|/* How much to indent CREATE INDEX by */
name|int
name|rc
decl_stmt|;
comment|/* Return code */
name|sqlite3_stmt
modifier|*
name|pSql
init|=
literal|0
decl_stmt|;
comment|/* Compiled version of SQL statement below */
comment|/*   ** This SELECT statement returns one row for each foreign key constraint   ** in the schema of the main database. The column values are:   **   ** 0. The text of an SQL statement similar to:   **   **      "EXPLAIN QUERY PLAN SELECT rowid FROM child_table WHERE child_key=?"   **   **    This is the same SELECT that the foreign keys implementation needs   **    to run internally on child tables. If there is an index that can   **    be used to optimize this query, then it can also be used by the FK   **    implementation to optimize DELETE or UPDATE statements on the parent   **    table.   **   ** 1. A GLOB pattern suitable for sqlite3_strglob(). If the plan output by   **    the EXPLAIN QUERY PLAN command matches this pattern, then the schema   **    contains an index that can be used to optimize the query.   **   ** 2. Human readable text that describes the child table and columns. e.g.   **   **       "child_table(child_key1, child_key2)"   **   ** 3. Human readable text that describes the parent table and columns. e.g.   **   **       "parent_table(parent_key1, parent_key2)"   **   ** 4. A full CREATE INDEX statement for an index that could be used to   **    optimize DELETE or UPDATE statements on the parent table. e.g.   **   **       "CREATE INDEX child_table_child_key ON child_table(child_key)"   **   ** 5. The name of the parent table.   **   ** These six values are used by the C logic below to generate the report.   */
specifier|const
name|char
modifier|*
name|zSql
init|=
literal|"SELECT "
literal|"     'EXPLAIN QUERY PLAN SELECT rowid FROM ' || quote(s.name) || ' WHERE '"
literal|"  || group_concat(quote(s.name) || '.' || quote(f.[from]) || '=?' "
literal|"  || fkey_collate_clause("
literal|"       f.[table], COALESCE(f.[to], p.[name]), s.name, f.[from]),' AND ')"
literal|", "
literal|"     'SEARCH TABLE ' || s.name || ' USING COVERING INDEX*('"
literal|"  || group_concat('*=?', ' AND ') || ')'"
literal|", "
literal|"     s.name  || '(' || group_concat(f.[from],  ', ') || ')'"
literal|", "
literal|"     f.[table] || '(' || group_concat(COALESCE(f.[to], p.[name])) || ')'"
literal|", "
literal|"     'CREATE INDEX ' || quote(s.name ||'_'|| group_concat(f.[from], '_'))"
literal|"  || ' ON ' || quote(s.name) || '('"
literal|"  || group_concat(quote(f.[from]) ||"
literal|"        fkey_collate_clause("
literal|"          f.[table], COALESCE(f.[to], p.[name]), s.name, f.[from]), ', ')"
literal|"  || ');'"
literal|", "
literal|"     f.[table] "
literal|"FROM sqlite_master AS s, pragma_foreign_key_list(s.name) AS f "
literal|"LEFT JOIN pragma_table_info AS p ON (pk-1=seq AND p.arg=f.[table]) "
literal|"GROUP BY s.name, f.id "
literal|"ORDER BY (CASE WHEN ? THEN f.[table] ELSE s.name END)"
decl_stmt|;
specifier|const
name|char
modifier|*
name|zGlobIPK
init|=
literal|"SEARCH TABLE * USING INTEGER PRIMARY KEY (rowid=?)"
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|int
name|n
init|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|azArg
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|>
literal|1
operator|&&
name|sqlite3_strnicmp
argument_list|(
literal|"-verbose"
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bVerbose
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|>
literal|1
operator|&&
name|sqlite3_strnicmp
argument_list|(
literal|"-groupbyparent"
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bGroupByParent
operator|=
literal|1
expr_stmt|;
name|zIndent
operator|=
literal|"    "
expr_stmt|;
block|}
else|else
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s %s ?-verbose? ?-groupbyparent?\n"
argument_list|,
name|azArg
index|[
literal|0
index|]
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|SQLITE_ERROR
return|;
block|}
block|}
comment|/* Register the fkey_collate_clause() SQL function */
name|rc
operator|=
name|sqlite3_create_function
argument_list|(
name|db
argument_list|,
literal|"fkey_collate_clause"
argument_list|,
literal|4
argument_list|,
name|SQLITE_UTF8
argument_list|,
literal|0
argument_list|,
name|shellFkeyCollateClause
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|SQLITE_OK
condition|)
block|{
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|db
argument_list|,
name|zSql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pSql
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|==
name|SQLITE_OK
condition|)
block|{
name|sqlite3_bind_int
argument_list|(
name|pSql
argument_list|,
literal|1
argument_list|,
name|bGroupByParent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|==
name|SQLITE_OK
condition|)
block|{
name|int
name|rc2
decl_stmt|;
name|char
modifier|*
name|zPrev
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|SQLITE_ROW
operator|==
name|sqlite3_step
argument_list|(
name|pSql
argument_list|)
condition|)
block|{
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|;
name|sqlite3_stmt
modifier|*
name|pExplain
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|zEQP
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pSql
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|zGlob
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pSql
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|zFrom
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pSql
argument_list|,
literal|2
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|zTarget
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pSql
argument_list|,
literal|3
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|zCI
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pSql
argument_list|,
literal|4
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|zParent
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pSql
argument_list|,
literal|5
argument_list|)
decl_stmt|;
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|db
argument_list|,
name|zEQP
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pExplain
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
condition|)
break|break;
if|if
condition|(
name|SQLITE_ROW
operator|==
name|sqlite3_step
argument_list|(
name|pExplain
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|zPlan
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pExplain
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|res
operator|=
operator|(
literal|0
operator|==
name|sqlite3_strglob
argument_list|(
name|zGlob
argument_list|,
name|zPlan
argument_list|)
operator|||
literal|0
operator|==
name|sqlite3_strglob
argument_list|(
name|zGlobIPK
argument_list|,
name|zPlan
argument_list|)
operator|)
expr_stmt|;
block|}
name|rc
operator|=
name|sqlite3_finalize
argument_list|(
name|pExplain
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
condition|)
break|break;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: internal error"
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
if|if
condition|(
name|bGroupByParent
operator|&&
operator|(
name|bVerbose
operator|||
name|res
operator|==
literal|0
operator|)
operator|&&
operator|(
name|zPrev
operator|==
literal|0
operator|||
name|sqlite3_stricmp
argument_list|(
name|zParent
argument_list|,
name|zPrev
argument_list|)
operator|)
condition|)
block|{
name|raw_printf
argument_list|(
name|out
argument_list|,
literal|"-- Parent table %s\n"
argument_list|,
name|zParent
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zPrev
argument_list|)
expr_stmt|;
name|zPrev
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"%s"
argument_list|,
name|zParent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|==
literal|0
condition|)
block|{
name|raw_printf
argument_list|(
name|out
argument_list|,
literal|"%s%s --> %s\n"
argument_list|,
name|zIndent
argument_list|,
name|zCI
argument_list|,
name|zTarget
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bVerbose
condition|)
block|{
name|raw_printf
argument_list|(
name|out
argument_list|,
literal|"%s/* no extra indexes required for %s -> %s */\n"
argument_list|,
name|zIndent
argument_list|,
name|zFrom
argument_list|,
name|zTarget
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|sqlite3_free
argument_list|(
name|zPrev
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rc2
operator|=
name|sqlite3_finalize
argument_list|(
name|pSql
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|SQLITE_OK
operator|&&
name|rc2
operator|!=
name|SQLITE_OK
condition|)
block|{
name|rc
operator|=
name|rc2
expr_stmt|;
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* ** Implementation of ".lint" dot command. */
end_comment

begin_function
specifier|static
name|int
name|lintDotCommand
parameter_list|(
name|ShellState
modifier|*
name|pState
parameter_list|,
comment|/* Current shell tool state */
name|char
modifier|*
modifier|*
name|azArg
parameter_list|,
comment|/* Array of arguments passed to dot command */
name|int
name|nArg
comment|/* Number of entries in azArg[] */
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|n
operator|=
operator|(
name|nArg
operator|>=
literal|2
condition|?
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
operator|||
name|sqlite3_strnicmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"fkey-indexes"
argument_list|,
name|n
argument_list|)
condition|)
goto|goto
name|usage
goto|;
return|return
name|lintFkeyIndexes
argument_list|(
name|pState
argument_list|,
name|azArg
argument_list|,
name|nArg
argument_list|)
return|;
name|usage
label|:
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage %s sub-command ?switches...?\n"
argument_list|,
name|azArg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Where sub-commands are:\n"
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"    fkey-indexes\n"
argument_list|)
expr_stmt|;
return|return
name|SQLITE_ERROR
return|;
block|}
end_function

begin_comment
comment|/* ** If an input line begins with "." then invoke this routine to ** process that line. ** ** Return 1 on error, 2 to exit, and 0 otherwise. */
end_comment

begin_function
specifier|static
name|int
name|do_meta_command
parameter_list|(
name|char
modifier|*
name|zLine
parameter_list|,
name|ShellState
modifier|*
name|p
parameter_list|)
block|{
name|int
name|h
init|=
literal|1
decl_stmt|;
name|int
name|nArg
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|,
name|c
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|azArg
index|[
literal|50
index|]
decl_stmt|;
comment|/* Parse the input line into tokens.   */
while|while
condition|(
name|zLine
index|[
name|h
index|]
operator|&&
name|nArg
operator|<
name|ArraySize
argument_list|(
name|azArg
argument_list|)
condition|)
block|{
while|while
condition|(
name|IsSpace
argument_list|(
name|zLine
index|[
name|h
index|]
argument_list|)
condition|)
block|{
name|h
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|zLine
index|[
name|h
index|]
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|zLine
index|[
name|h
index|]
operator|==
literal|'\''
operator|||
name|zLine
index|[
name|h
index|]
operator|==
literal|'"'
condition|)
block|{
name|int
name|delim
init|=
name|zLine
index|[
name|h
operator|++
index|]
decl_stmt|;
name|azArg
index|[
name|nArg
operator|++
index|]
operator|=
operator|&
name|zLine
index|[
name|h
index|]
expr_stmt|;
while|while
condition|(
name|zLine
index|[
name|h
index|]
operator|&&
name|zLine
index|[
name|h
index|]
operator|!=
name|delim
condition|)
block|{
if|if
condition|(
name|zLine
index|[
name|h
index|]
operator|==
literal|'\\'
operator|&&
name|delim
operator|==
literal|'"'
operator|&&
name|zLine
index|[
name|h
operator|+
literal|1
index|]
operator|!=
literal|0
condition|)
name|h
operator|++
expr_stmt|;
name|h
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|zLine
index|[
name|h
index|]
operator|==
name|delim
condition|)
block|{
name|zLine
index|[
name|h
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|delim
operator|==
literal|'"'
condition|)
name|resolve_backslashes
argument_list|(
name|azArg
index|[
name|nArg
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|azArg
index|[
name|nArg
operator|++
index|]
operator|=
operator|&
name|zLine
index|[
name|h
index|]
expr_stmt|;
while|while
condition|(
name|zLine
index|[
name|h
index|]
operator|&&
operator|!
name|IsSpace
argument_list|(
name|zLine
index|[
name|h
index|]
argument_list|)
condition|)
block|{
name|h
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|zLine
index|[
name|h
index|]
condition|)
name|zLine
index|[
name|h
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|resolve_backslashes
argument_list|(
name|azArg
index|[
name|nArg
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process the input line.   */
if|if
condition|(
name|nArg
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* no tokens, no error */
name|n
operator|=
name|strlen30
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|c
operator|=
name|azArg
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
ifndef|#
directive|ifndef
name|SQLITE_OMIT_AUTHORIZATION
if|if
condition|(
name|c
operator|==
literal|'a'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"auth"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|!=
literal|2
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .auth ON|OFF\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|booleanValue
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|sqlite3_set_authorizer
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|shellAuth
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sqlite3_set_authorizer
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
operator|(
name|c
operator|==
literal|'b'
operator|&&
name|n
operator|>=
literal|3
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"backup"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|c
operator|==
literal|'s'
operator|&&
name|n
operator|>=
literal|3
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"save"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|zDestFile
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|zDb
init|=
literal|0
decl_stmt|;
name|sqlite3
modifier|*
name|pDest
decl_stmt|;
name|sqlite3_backup
modifier|*
name|pBackup
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|nArg
condition|;
name|j
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|z
init|=
name|azArg
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|z
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
while|while
condition|(
name|z
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|z
operator|++
expr_stmt|;
comment|/* No options to process at this time */
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"unknown option: %s\n"
argument_list|,
name|azArg
index|[
name|j
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|zDestFile
operator|==
literal|0
condition|)
block|{
name|zDestFile
operator|=
name|azArg
index|[
name|j
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zDb
operator|==
literal|0
condition|)
block|{
name|zDb
operator|=
name|zDestFile
expr_stmt|;
name|zDestFile
operator|=
name|azArg
index|[
name|j
index|]
expr_stmt|;
block|}
else|else
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"too many arguments to .backup\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|zDestFile
operator|==
literal|0
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"missing FILENAME argument on .backup\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|zDb
operator|==
literal|0
condition|)
name|zDb
operator|=
literal|"main"
expr_stmt|;
name|rc
operator|=
name|sqlite3_open
argument_list|(
name|zDestFile
argument_list|,
operator|&
name|pDest
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: cannot open \"%s\"\n"
argument_list|,
name|zDestFile
argument_list|)
expr_stmt|;
name|sqlite3_close
argument_list|(
name|pDest
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pBackup
operator|=
name|sqlite3_backup_init
argument_list|(
name|pDest
argument_list|,
literal|"main"
argument_list|,
name|p
operator|->
name|db
argument_list|,
name|zDb
argument_list|)
expr_stmt|;
if|if
condition|(
name|pBackup
operator|==
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|pDest
argument_list|)
argument_list|)
expr_stmt|;
name|sqlite3_close
argument_list|(
name|pDest
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
while|while
condition|(
operator|(
name|rc
operator|=
name|sqlite3_backup_step
argument_list|(
name|pBackup
argument_list|,
literal|100
argument_list|)
operator|)
operator|==
name|SQLITE_OK
condition|)
block|{}
name|sqlite3_backup_finish
argument_list|(
name|pBackup
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|SQLITE_DONE
condition|)
block|{
name|rc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|pDest
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
name|sqlite3_close
argument_list|(
name|pDest
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'b'
operator|&&
name|n
operator|>=
literal|3
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"bail"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|==
literal|2
condition|)
block|{
name|bail_on_error
operator|=
name|booleanValue
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .bail on|off\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'b'
operator|&&
name|n
operator|>=
literal|3
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"binary"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|booleanValue
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|setBinaryMode
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setTextMode
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .binary on|off\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'c'
operator|&&
name|strcmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"cd"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|==
literal|2
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
name|wchar_t
modifier|*
name|z
init|=
name|sqlite3_win32_utf8_to_unicode
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|rc
operator|=
operator|!
name|SetCurrentDirectoryW
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|z
argument_list|)
expr_stmt|;
else|#
directive|else
name|rc
operator|=
name|chdir
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rc
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot change to directory \"%s\"\n"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .cd DIRECTORY\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
comment|/* The undocumented ".breakpoint" command causes a call to the no-op   ** routine named test_breakpoint().   */
if|if
condition|(
name|c
operator|==
literal|'b'
operator|&&
name|n
operator|>=
literal|3
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"breakpoint"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|test_breakpoint
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'c'
operator|&&
name|n
operator|>=
literal|3
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"changes"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|==
literal|2
condition|)
block|{
name|setOrClearFlag
argument_list|(
name|p
argument_list|,
name|SHFLG_CountChanges
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .changes on|off\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
comment|/* Cancel output redirection, if it is currently set (by .testcase)   ** Then read the content of the testcase-out.txt file and compare against   ** azArg[1].  If there are differences, report an error and exit.   */
if|if
condition|(
name|c
operator|==
literal|'c'
operator|&&
name|n
operator|>=
literal|3
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"check"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|zRes
init|=
literal|0
decl_stmt|;
name|output_reset
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nArg
operator|!=
literal|2
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .check GLOB-PATTERN\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|zRes
operator|=
name|readFile
argument_list|(
literal|"testcase-out.txt"
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: cannot read 'testcase-out.txt'\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testcase_glob
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
name|zRes
argument_list|)
operator|==
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"testcase-%s FAILED\n Expected: [%s]\n      Got: [%s]\n"
argument_list|,
name|p
operator|->
name|zTestcase
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|,
name|zRes
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|utf8_printf
argument_list|(
name|stdout
argument_list|,
literal|"testcase-%s ok\n"
argument_list|,
name|p
operator|->
name|zTestcase
argument_list|)
expr_stmt|;
name|p
operator|->
name|nCheck
operator|++
expr_stmt|;
block|}
name|sqlite3_free
argument_list|(
name|zRes
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'c'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"clone"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|==
literal|2
condition|)
block|{
name|tryToClone
argument_list|(
name|p
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .clone FILENAME\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'d'
operator|&&
name|n
operator|>
literal|1
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"databases"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ShellState
name|data
decl_stmt|;
name|char
modifier|*
name|zErrMsg
init|=
literal|0
decl_stmt|;
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|data
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|showHeader
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|cMode
operator|=
name|data
operator|.
name|mode
operator|=
name|MODE_List
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|data
operator|.
name|colSeparator
argument_list|)
argument_list|,
name|data
operator|.
name|colSeparator
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|data
operator|.
name|cnt
operator|=
literal|0
expr_stmt|;
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"SELECT name, file FROM pragma_database_list"
argument_list|,
name|callback
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|zErrMsg
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|zErrMsg
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zErrMsg
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'d'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"dbinfo"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|shell_dbinfo_command
argument_list|(
name|p
argument_list|,
name|nArg
argument_list|,
name|azArg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'d'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"dump"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|zLike
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|savedShowHeader
init|=
name|p
operator|->
name|showHeader
decl_stmt|;
name|ShellClearFlag
argument_list|(
name|p
argument_list|,
name|SHFLG_PreserveRowid
operator||
name|SHFLG_Newlines
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|azArg
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
specifier|const
name|char
modifier|*
name|z
init|=
name|azArg
index|[
name|i
index|]
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|z
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|z
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"preserve-rowids"
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|SQLITE_OMIT_VIRTUALTABLE
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"The --preserve-rowids option is not compatible"
literal|" with SQLITE_OMIT_VIRTUALTABLE\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
else|#
directive|else
name|ShellSetFlag
argument_list|(
name|p
argument_list|,
name|SHFLG_PreserveRowid
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"newlines"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ShellSetFlag
argument_list|(
name|p
argument_list|,
name|SHFLG_Newlines
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown option \"%s\" on \".dump\"\n"
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|zLike
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .dump ?--preserve-rowids? "
literal|"?--newlines? ?LIKE-PATTERN?\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
else|else
block|{
name|zLike
operator|=
name|azArg
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* When playing back a "dump", the content might appear in an order     ** which causes immediate foreign key constraints to be violated.     ** So disable foreign-key constraint enforcement to prevent problems. */
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"PRAGMA foreign_keys=OFF;\n"
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"BEGIN TRANSACTION;\n"
argument_list|)
expr_stmt|;
name|p
operator|->
name|writableSchema
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|showHeader
operator|=
literal|0
expr_stmt|;
comment|/* Set writable_schema=ON since doing so forces SQLite to initialize     ** as much of the schema as it can even if the sqlite_master table is     ** corrupt. */
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"SAVEPOINT dump; PRAGMA writable_schema=ON"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|nErr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|zLike
operator|==
literal|0
condition|)
block|{
name|run_schema_dump_query
argument_list|(
name|p
argument_list|,
literal|"SELECT name, type, sql FROM sqlite_master "
literal|"WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence'"
argument_list|)
expr_stmt|;
name|run_schema_dump_query
argument_list|(
name|p
argument_list|,
literal|"SELECT name, type, sql FROM sqlite_master "
literal|"WHERE name=='sqlite_sequence'"
argument_list|)
expr_stmt|;
name|run_table_dump_query
argument_list|(
name|p
argument_list|,
literal|"SELECT sql FROM sqlite_master "
literal|"WHERE sql NOT NULL AND type IN ('index','trigger','view')"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|zSql
decl_stmt|;
name|zSql
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"SELECT name, type, sql FROM sqlite_master "
literal|"WHERE tbl_name LIKE %Q AND type=='table'"
literal|"  AND sql NOT NULL"
argument_list|,
name|zLike
argument_list|)
expr_stmt|;
name|run_schema_dump_query
argument_list|(
name|p
argument_list|,
name|zSql
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
name|zSql
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"SELECT sql FROM sqlite_master "
literal|"WHERE sql NOT NULL"
literal|"  AND type IN ('index','trigger','view')"
literal|"  AND tbl_name LIKE %Q"
argument_list|,
name|zLike
argument_list|)
expr_stmt|;
name|run_table_dump_query
argument_list|(
name|p
argument_list|,
name|zSql
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|writableSchema
condition|)
block|{
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"PRAGMA writable_schema=OFF;\n"
argument_list|)
expr_stmt|;
name|p
operator|->
name|writableSchema
operator|=
literal|0
expr_stmt|;
block|}
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"PRAGMA writable_schema=OFF;"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"RELEASE dump;"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|p
operator|->
name|nErr
condition|?
literal|"ROLLBACK; -- due to errors\n"
else|:
literal|"COMMIT;\n"
argument_list|)
expr_stmt|;
name|p
operator|->
name|showHeader
operator|=
name|savedShowHeader
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'e'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"echo"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|==
literal|2
condition|)
block|{
name|setOrClearFlag
argument_list|(
name|p
argument_list|,
name|SHFLG_Echo
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .echo on|off\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'e'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"eqp"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"full"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|autoEQP
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|autoEQP
operator|=
name|booleanValue
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .eqp on|off|full\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'e'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"exit"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|>
literal|1
operator|&&
operator|(
name|rc
operator|=
operator|(
name|int
operator|)
name|integerValue
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|exit
argument_list|(
name|rc
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
comment|/* The ".explain" command is automatic now.  It is largely pointless.  It   ** retained purely for backwards compatibility */
if|if
condition|(
name|c
operator|==
literal|'e'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"explain"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|val
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|nArg
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"auto"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|val
operator|=
literal|99
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|booleanValue
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|val
operator|==
literal|1
operator|&&
name|p
operator|->
name|mode
operator|!=
name|MODE_Explain
condition|)
block|{
name|p
operator|->
name|normalMode
operator|=
name|p
operator|->
name|mode
expr_stmt|;
name|p
operator|->
name|mode
operator|=
name|MODE_Explain
expr_stmt|;
name|p
operator|->
name|autoExplain
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|mode
operator|==
name|MODE_Explain
condition|)
name|p
operator|->
name|mode
operator|=
name|p
operator|->
name|normalMode
expr_stmt|;
name|p
operator|->
name|autoExplain
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|==
literal|99
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|mode
operator|==
name|MODE_Explain
condition|)
name|p
operator|->
name|mode
operator|=
name|p
operator|->
name|normalMode
expr_stmt|;
name|p
operator|->
name|autoExplain
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'f'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"fullschema"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ShellState
name|data
decl_stmt|;
name|char
modifier|*
name|zErrMsg
init|=
literal|0
decl_stmt|;
name|int
name|doStats
init|=
literal|0
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|data
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|showHeader
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|cMode
operator|=
name|data
operator|.
name|mode
operator|=
name|MODE_Semi
expr_stmt|;
if|if
condition|(
name|nArg
operator|==
literal|2
operator|&&
name|optionMatch
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"indent"
argument_list|)
condition|)
block|{
name|data
operator|.
name|cMode
operator|=
name|data
operator|.
name|mode
operator|=
name|MODE_Pretty
expr_stmt|;
name|nArg
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|nArg
operator|!=
literal|1
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .fullschema ?--indent?\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"SELECT sql FROM"
literal|"  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"
literal|"     FROM sqlite_master UNION ALL"
literal|"   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "
literal|"WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%' "
literal|"ORDER BY rowid"
argument_list|,
name|callback
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|SQLITE_OK
condition|)
block|{
name|sqlite3_stmt
modifier|*
name|pStmt
decl_stmt|;
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"SELECT rowid FROM sqlite_master"
literal|" WHERE name GLOB 'sqlite_stat[134]'"
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|doStats
operator|=
name|sqlite3_step
argument_list|(
name|pStmt
argument_list|)
operator|==
name|SQLITE_ROW
expr_stmt|;
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doStats
operator|==
literal|0
condition|)
block|{
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"/* No STAT tables available */\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"ANALYZE sqlite_master;\n"
argument_list|)
expr_stmt|;
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"SELECT 'ANALYZE sqlite_master'"
argument_list|,
name|callback
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
name|data
operator|.
name|cMode
operator|=
name|data
operator|.
name|mode
operator|=
name|MODE_Insert
expr_stmt|;
name|data
operator|.
name|zDestTable
operator|=
literal|"sqlite_stat1"
expr_stmt|;
name|shell_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"SELECT * FROM sqlite_stat1"
argument_list|,
name|shell_callback
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
name|data
operator|.
name|zDestTable
operator|=
literal|"sqlite_stat3"
expr_stmt|;
name|shell_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"SELECT * FROM sqlite_stat3"
argument_list|,
name|shell_callback
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
name|data
operator|.
name|zDestTable
operator|=
literal|"sqlite_stat4"
expr_stmt|;
name|shell_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"SELECT * FROM sqlite_stat4"
argument_list|,
name|shell_callback
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"ANALYZE sqlite_master;\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'h'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"headers"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|==
literal|2
condition|)
block|{
name|p
operator|->
name|showHeader
operator|=
name|booleanValue
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .headers on|off\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'h'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"help"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|zHelp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'i'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"import"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|zTable
decl_stmt|;
comment|/* Insert data into this table */
name|char
modifier|*
name|zFile
decl_stmt|;
comment|/* Name of file to extra content from */
name|sqlite3_stmt
modifier|*
name|pStmt
init|=
name|NULL
decl_stmt|;
comment|/* A statement */
name|int
name|nCol
decl_stmt|;
comment|/* Number of columns in the table */
name|int
name|nByte
decl_stmt|;
comment|/* Number of bytes in an SQL string */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Loop counters */
name|int
name|needCommit
decl_stmt|;
comment|/* True to COMMIT or ROLLBACK at end */
name|int
name|nSep
decl_stmt|;
comment|/* Number of bytes in p->colSeparator[] */
name|char
modifier|*
name|zSql
decl_stmt|;
comment|/* An SQL statement */
name|ImportCtx
name|sCtx
decl_stmt|;
comment|/* Reader context */
name|char
modifier|*
function_decl|(
name|SQLITE_CDECL
modifier|*
name|xRead
function_decl|)
parameter_list|(
name|ImportCtx
modifier|*
parameter_list|)
function_decl|;
comment|/* Func to read one value */
name|int
function_decl|(
name|SQLITE_CDECL
modifier|*
name|xCloser
function_decl|)
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
comment|/* Func to close file */
if|if
condition|(
name|nArg
operator|!=
literal|3
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .import FILE TABLE\n"
argument_list|)
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
name|zFile
operator|=
name|azArg
index|[
literal|1
index|]
expr_stmt|;
name|zTable
operator|=
name|azArg
index|[
literal|2
index|]
expr_stmt|;
name|seenInterrupt
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sCtx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sCtx
argument_list|)
argument_list|)
expr_stmt|;
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nSep
operator|=
name|strlen30
argument_list|(
name|p
operator|->
name|colSeparator
argument_list|)
expr_stmt|;
if|if
condition|(
name|nSep
operator|==
literal|0
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: non-null column separator required for import\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|nSep
operator|>
literal|1
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: multi-character column separators not allowed"
literal|" for import\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|nSep
operator|=
name|strlen30
argument_list|(
name|p
operator|->
name|rowSeparator
argument_list|)
expr_stmt|;
if|if
condition|(
name|nSep
operator|==
literal|0
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: non-null row separator required for import\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|nSep
operator|==
literal|2
operator|&&
name|p
operator|->
name|mode
operator|==
name|MODE_Csv
operator|&&
name|strcmp
argument_list|(
name|p
operator|->
name|rowSeparator
argument_list|,
name|SEP_CrLf
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* When importing CSV (only), if the row separator is set to the       ** default output row separator, change it to the default input       ** row separator.  This avoids having to maintain different input       ** and output row separators. */
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|rowSeparator
argument_list|)
argument_list|,
name|p
operator|->
name|rowSeparator
argument_list|,
name|SEP_Row
argument_list|)
expr_stmt|;
name|nSep
operator|=
name|strlen30
argument_list|(
name|p
operator|->
name|rowSeparator
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nSep
operator|>
literal|1
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: multi-character row separators not allowed"
literal|" for import\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|sCtx
operator|.
name|zFile
operator|=
name|zFile
expr_stmt|;
name|sCtx
operator|.
name|nLine
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sCtx
operator|.
name|zFile
index|[
literal|0
index|]
operator|==
literal|'|'
condition|)
block|{
ifdef|#
directive|ifdef
name|SQLITE_OMIT_POPEN
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: pipes are not supported in this OS\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
else|#
directive|else
name|sCtx
operator|.
name|in
operator|=
name|popen
argument_list|(
name|sCtx
operator|.
name|zFile
operator|+
literal|1
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|sCtx
operator|.
name|zFile
operator|=
literal|"<pipe>"
expr_stmt|;
name|xCloser
operator|=
name|pclose
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|sCtx
operator|.
name|in
operator|=
name|fopen
argument_list|(
name|sCtx
operator|.
name|zFile
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
name|xCloser
operator|=
name|fclose
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|mode
operator|==
name|MODE_Ascii
condition|)
block|{
name|xRead
operator|=
name|ascii_read_one_field
expr_stmt|;
block|}
else|else
block|{
name|xRead
operator|=
name|csv_read_one_field
expr_stmt|;
block|}
if|if
condition|(
name|sCtx
operator|.
name|in
operator|==
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: cannot open \"%s\"\n"
argument_list|,
name|zFile
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|sCtx
operator|.
name|cColSep
operator|=
name|p
operator|->
name|colSeparator
index|[
literal|0
index|]
expr_stmt|;
name|sCtx
operator|.
name|cRowSep
operator|=
name|p
operator|->
name|rowSeparator
index|[
literal|0
index|]
expr_stmt|;
name|zSql
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"SELECT * FROM %s"
argument_list|,
name|zTable
argument_list|)
expr_stmt|;
if|if
condition|(
name|zSql
operator|==
literal|0
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: out of memory\n"
argument_list|)
expr_stmt|;
name|xCloser
argument_list|(
name|sCtx
operator|.
name|in
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|nByte
operator|=
name|strlen30
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zSql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|import_append_char
argument_list|(
operator|&
name|sCtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* To ensure sCtx.z is allocated */
if|if
condition|(
name|rc
operator|&&
name|sqlite3_strglob
argument_list|(
literal|"no such table: *"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|zCreate
init|=
name|sqlite3_mprintf
argument_list|(
literal|"CREATE TABLE %s"
argument_list|,
name|zTable
argument_list|)
decl_stmt|;
name|char
name|cSep
init|=
literal|'('
decl_stmt|;
while|while
condition|(
name|xRead
argument_list|(
operator|&
name|sCtx
argument_list|)
condition|)
block|{
name|zCreate
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"%z%c\n  \"%w\" TEXT"
argument_list|,
name|zCreate
argument_list|,
name|cSep
argument_list|,
name|sCtx
operator|.
name|z
argument_list|)
expr_stmt|;
name|cSep
operator|=
literal|','
expr_stmt|;
if|if
condition|(
name|sCtx
operator|.
name|cTerm
operator|!=
name|sCtx
operator|.
name|cColSep
condition|)
break|break;
block|}
if|if
condition|(
name|cSep
operator|==
literal|'('
condition|)
block|{
name|sqlite3_free
argument_list|(
name|zCreate
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|sCtx
operator|.
name|z
argument_list|)
expr_stmt|;
name|xCloser
argument_list|(
name|sCtx
operator|.
name|in
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"%s: empty file\n"
argument_list|,
name|sCtx
operator|.
name|zFile
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|zCreate
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"%z\n)"
argument_list|,
name|zCreate
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zCreate
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zCreate
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"CREATE TABLE %s(...) failed: %s\n"
argument_list|,
name|zTable
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|sCtx
operator|.
name|z
argument_list|)
expr_stmt|;
name|xCloser
argument_list|(
name|sCtx
operator|.
name|in
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zSql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sqlite3_free
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
if|if
condition|(
name|pStmt
condition|)
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|xCloser
argument_list|(
name|sCtx
operator|.
name|in
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|nCol
operator|=
name|sqlite3_column_count
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|pStmt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nCol
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* no columns, no error */
name|zSql
operator|=
name|sqlite3_malloc64
argument_list|(
name|nByte
operator|*
literal|2
operator|+
literal|20
operator|+
name|nCol
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|zSql
operator|==
literal|0
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: out of memory\n"
argument_list|)
expr_stmt|;
name|xCloser
argument_list|(
name|sCtx
operator|.
name|in
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|sqlite3_snprintf
argument_list|(
name|nByte
operator|+
literal|20
argument_list|,
name|zSql
argument_list|,
literal|"INSERT INTO \"%w\" VALUES(?"
argument_list|,
name|zTable
argument_list|)
expr_stmt|;
name|j
operator|=
name|strlen30
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nCol
condition|;
name|i
operator|++
control|)
block|{
name|zSql
index|[
name|j
operator|++
index|]
operator|=
literal|','
expr_stmt|;
name|zSql
index|[
name|j
operator|++
index|]
operator|=
literal|'?'
expr_stmt|;
block|}
name|zSql
index|[
name|j
operator|++
index|]
operator|=
literal|')'
expr_stmt|;
name|zSql
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zSql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pStmt
condition|)
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|xCloser
argument_list|(
name|sCtx
operator|.
name|in
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|needCommit
operator|=
name|sqlite3_get_autocommit
argument_list|(
name|p
operator|->
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|needCommit
condition|)
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"BEGIN"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
do|do
block|{
name|int
name|startLine
init|=
name|sCtx
operator|.
name|nLine
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nCol
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|z
init|=
name|xRead
argument_list|(
operator|&
name|sCtx
argument_list|)
decl_stmt|;
comment|/*         ** Did we reach end-of-file before finding any columns?         ** If so, stop instead of NULL filling the remaining columns.         */
if|if
condition|(
name|z
operator|==
literal|0
operator|&&
name|i
operator|==
literal|0
condition|)
break|break;
comment|/*         ** Did we reach end-of-file OR end-of-line before finding any         ** columns in ASCII mode?  If so, stop instead of NULL filling         ** the remaining columns.         */
if|if
condition|(
name|p
operator|->
name|mode
operator|==
name|MODE_Ascii
operator|&&
operator|(
name|z
operator|==
literal|0
operator|||
name|z
index|[
literal|0
index|]
operator|==
literal|0
operator|)
operator|&&
name|i
operator|==
literal|0
condition|)
break|break;
name|sqlite3_bind_text
argument_list|(
name|pStmt
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|z
argument_list|,
operator|-
literal|1
argument_list|,
name|SQLITE_TRANSIENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|nCol
operator|-
literal|1
operator|&&
name|sCtx
operator|.
name|cTerm
operator|!=
name|sCtx
operator|.
name|cColSep
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: expected %d columns but found %d - "
literal|"filling the rest with NULL\n"
argument_list|,
name|sCtx
operator|.
name|zFile
argument_list|,
name|startLine
argument_list|,
name|nCol
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|i
operator|<=
name|nCol
condition|)
block|{
name|sqlite3_bind_null
argument_list|(
name|pStmt
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|sCtx
operator|.
name|cTerm
operator|==
name|sCtx
operator|.
name|cColSep
condition|)
block|{
do|do
block|{
name|xRead
argument_list|(
operator|&
name|sCtx
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|sCtx
operator|.
name|cTerm
operator|==
name|sCtx
operator|.
name|cColSep
condition|)
do|;
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: expected %d columns but found %d - "
literal|"extras ignored\n"
argument_list|,
name|sCtx
operator|.
name|zFile
argument_list|,
name|startLine
argument_list|,
name|nCol
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|nCol
condition|)
block|{
name|sqlite3_step
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_reset
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: INSERT failed: %s\n"
argument_list|,
name|sCtx
operator|.
name|zFile
argument_list|,
name|startLine
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|sCtx
operator|.
name|cTerm
operator|!=
name|EOF
condition|)
do|;
name|xCloser
argument_list|(
name|sCtx
operator|.
name|in
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|sCtx
operator|.
name|z
argument_list|)
expr_stmt|;
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|needCommit
condition|)
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"COMMIT"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
ifndef|#
directive|ifndef
name|SQLITE_UNTESTABLE
if|if
condition|(
name|c
operator|==
literal|'i'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"imposter"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|zSql
decl_stmt|;
name|char
modifier|*
name|zCollist
init|=
literal|0
decl_stmt|;
name|sqlite3_stmt
modifier|*
name|pStmt
decl_stmt|;
name|int
name|tnum
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|nArg
operator|!=
literal|3
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .imposter INDEX IMPOSTER\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zSql
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"SELECT rootpage FROM sqlite_master"
literal|" WHERE name='%q' AND type='index'"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sqlite3_prepare_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zSql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
if|if
condition|(
name|sqlite3_step
argument_list|(
name|pStmt
argument_list|)
operator|==
name|SQLITE_ROW
condition|)
block|{
name|tnum
operator|=
name|sqlite3_column_int
argument_list|(
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|tnum
operator|==
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"no such index: \"%s\"\n"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
name|zSql
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"PRAGMA index_xinfo='%q'"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zSql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sqlite3_step
argument_list|(
name|pStmt
argument_list|)
operator|==
name|SQLITE_ROW
condition|)
block|{
name|char
name|zLabel
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|zCol
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pStmt
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|zCol
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sqlite3_column_int
argument_list|(
name|pStmt
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|zCol
operator|=
literal|"_ROWID_"
expr_stmt|;
block|}
else|else
block|{
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|zLabel
argument_list|)
argument_list|,
name|zLabel
argument_list|,
literal|"expr%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|zCol
operator|=
name|zLabel
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zCollist
operator|==
literal|0
condition|)
block|{
name|zCollist
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"\"%w\""
argument_list|,
name|zCol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zCollist
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"%z,\"%w\""
argument_list|,
name|zCollist
argument_list|,
name|zCol
argument_list|)
expr_stmt|;
block|}
block|}
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|zSql
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"CREATE TABLE \"%w\"(%s,PRIMARY KEY(%s))WITHOUT ROWID"
argument_list|,
name|azArg
index|[
literal|2
index|]
argument_list|,
name|zCollist
argument_list|,
name|zCollist
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zCollist
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_test_control
argument_list|(
name|SQLITE_TESTCTRL_IMPOSTER
argument_list|,
name|p
operator|->
name|db
argument_list|,
literal|"main"
argument_list|,
literal|1
argument_list|,
name|tnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|SQLITE_OK
condition|)
block|{
name|rc
operator|=
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zSql
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_test_control
argument_list|(
name|SQLITE_TESTCTRL_IMPOSTER
argument_list|,
name|p
operator|->
name|db
argument_list|,
literal|"main"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error in [%s]: %s\n"
argument_list|,
name|zSql
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|utf8_printf
argument_list|(
name|stdout
argument_list|,
literal|"%s;\n"
argument_list|,
name|zSql
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|stdout
argument_list|,
literal|"WARNING: writing to an imposter table will corrupt the index!\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"SQLITE_TESTCTRL_IMPOSTER returns %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
name|sqlite3_free
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* !defined(SQLITE_OMIT_TEST_CONTROL) */
ifdef|#
directive|ifdef
name|SQLITE_ENABLE_IOTRACE
if|if
condition|(
name|c
operator|==
literal|'i'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"iotrace"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SQLITE_API
specifier|extern
name|void
argument_list|(
name|SQLITE_CDECL
operator|*
name|sqlite3IoTrace
argument_list|)
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
operator|...
argument_list|)
decl_stmt|;
if|if
condition|(
name|iotrace
operator|&&
name|iotrace
operator|!=
name|stdout
condition|)
name|fclose
argument_list|(
name|iotrace
argument_list|)
expr_stmt|;
name|iotrace
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nArg
operator|<
literal|2
condition|)
block|{
name|sqlite3IoTrace
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sqlite3IoTrace
operator|=
name|iotracePrintf
expr_stmt|;
name|iotrace
operator|=
name|stdout
expr_stmt|;
block|}
else|else
block|{
name|iotrace
operator|=
name|fopen
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|iotrace
operator|==
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: cannot open \"%s\"\n"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sqlite3IoTrace
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sqlite3IoTrace
operator|=
name|iotracePrintf
expr_stmt|;
block|}
block|}
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
literal|'l'
operator|&&
name|n
operator|>=
literal|5
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"limits"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|zLimitName
decl_stmt|;
comment|/* Name of a limit */
name|int
name|limitCode
decl_stmt|;
comment|/* Integer code for that limit */
block|}
name|aLimit
index|[]
init|=
block|{
block|{
literal|"length"
block|,
name|SQLITE_LIMIT_LENGTH
block|}
block|,
block|{
literal|"sql_length"
block|,
name|SQLITE_LIMIT_SQL_LENGTH
block|}
block|,
block|{
literal|"column"
block|,
name|SQLITE_LIMIT_COLUMN
block|}
block|,
block|{
literal|"expr_depth"
block|,
name|SQLITE_LIMIT_EXPR_DEPTH
block|}
block|,
block|{
literal|"compound_select"
block|,
name|SQLITE_LIMIT_COMPOUND_SELECT
block|}
block|,
block|{
literal|"vdbe_op"
block|,
name|SQLITE_LIMIT_VDBE_OP
block|}
block|,
block|{
literal|"function_arg"
block|,
name|SQLITE_LIMIT_FUNCTION_ARG
block|}
block|,
block|{
literal|"attached"
block|,
name|SQLITE_LIMIT_ATTACHED
block|}
block|,
block|{
literal|"like_pattern_length"
block|,
name|SQLITE_LIMIT_LIKE_PATTERN_LENGTH
block|}
block|,
block|{
literal|"variable_number"
block|,
name|SQLITE_LIMIT_VARIABLE_NUMBER
block|}
block|,
block|{
literal|"trigger_depth"
block|,
name|SQLITE_LIMIT_TRIGGER_DEPTH
block|}
block|,
block|{
literal|"worker_threads"
block|,
name|SQLITE_LIMIT_WORKER_THREADS
block|}
block|,     }
struct|;
name|int
name|i
decl_stmt|,
name|n2
decl_stmt|;
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nArg
operator|==
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|aLimit
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%20s %d\n"
argument_list|,
name|aLimit
index|[
name|i
index|]
operator|.
name|zLimitName
argument_list|,
name|sqlite3_limit
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|aLimit
index|[
name|i
index|]
operator|.
name|limitCode
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nArg
operator|>
literal|3
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .limit NAME ?NEW-VALUE?\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
else|else
block|{
name|int
name|iLimit
init|=
operator|-
literal|1
decl_stmt|;
name|n2
operator|=
name|strlen30
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|aLimit
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sqlite3_strnicmp
argument_list|(
name|aLimit
index|[
name|i
index|]
operator|.
name|zLimitName
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|,
name|n2
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|iLimit
operator|<
literal|0
condition|)
block|{
name|iLimit
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"ambiguous limit: \"%s\"\n"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
block|}
block|}
if|if
condition|(
name|iLimit
operator|<
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"unknown limit: \"%s\"\n"
literal|"enter \".limits\" with no arguments for a list.\n"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
if|if
condition|(
name|nArg
operator|==
literal|3
condition|)
block|{
name|sqlite3_limit
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|aLimit
index|[
name|iLimit
index|]
operator|.
name|limitCode
argument_list|,
operator|(
name|int
operator|)
name|integerValue
argument_list|(
name|azArg
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%20s %d\n"
argument_list|,
name|aLimit
index|[
name|iLimit
index|]
operator|.
name|zLimitName
argument_list|,
name|sqlite3_limit
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|aLimit
index|[
name|iLimit
index|]
operator|.
name|limitCode
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'l'
operator|&&
name|n
operator|>
literal|2
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"lint"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lintDotCommand
argument_list|(
name|p
argument_list|,
name|azArg
argument_list|,
name|nArg
argument_list|)
expr_stmt|;
block|}
elseif|else
ifndef|#
directive|ifndef
name|SQLITE_OMIT_LOAD_EXTENSION
if|if
condition|(
name|c
operator|==
literal|'l'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"load"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|zFile
decl_stmt|,
modifier|*
name|zProc
decl_stmt|;
name|char
modifier|*
name|zErrMsg
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nArg
operator|<
literal|2
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .load FILE ?ENTRYPOINT?\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
name|zFile
operator|=
name|azArg
index|[
literal|1
index|]
expr_stmt|;
name|zProc
operator|=
name|nArg
operator|>=
literal|3
condition|?
name|azArg
index|[
literal|2
index|]
else|:
literal|0
expr_stmt|;
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_load_extension
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zFile
argument_list|,
name|zProc
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|zErrMsg
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zErrMsg
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
literal|'l'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"log"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|!=
literal|2
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .log FILENAME\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|zFile
init|=
name|azArg
index|[
literal|1
index|]
decl_stmt|;
name|output_file_close
argument_list|(
name|p
operator|->
name|pLog
argument_list|)
expr_stmt|;
name|p
operator|->
name|pLog
operator|=
name|output_file_open
argument_list|(
name|zFile
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'m'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"mode"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|zMode
init|=
name|nArg
operator|>=
literal|2
condition|?
name|azArg
index|[
literal|1
index|]
else|:
literal|""
decl_stmt|;
name|int
name|n2
init|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|zMode
argument_list|)
decl_stmt|;
name|int
name|c2
init|=
name|zMode
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|c2
operator|==
literal|'l'
operator|&&
name|n2
operator|>
literal|2
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"lines"
argument_list|,
name|n2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|mode
operator|=
name|MODE_Line
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|rowSeparator
argument_list|)
argument_list|,
name|p
operator|->
name|rowSeparator
argument_list|,
name|SEP_Row
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c2
operator|==
literal|'c'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"columns"
argument_list|,
name|n2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|mode
operator|=
name|MODE_Column
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|rowSeparator
argument_list|)
argument_list|,
name|p
operator|->
name|rowSeparator
argument_list|,
name|SEP_Row
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c2
operator|==
literal|'l'
operator|&&
name|n2
operator|>
literal|2
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"list"
argument_list|,
name|n2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|mode
operator|=
name|MODE_List
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|colSeparator
argument_list|)
argument_list|,
name|p
operator|->
name|colSeparator
argument_list|,
name|SEP_Column
argument_list|)
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|rowSeparator
argument_list|)
argument_list|,
name|p
operator|->
name|rowSeparator
argument_list|,
name|SEP_Row
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c2
operator|==
literal|'h'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"html"
argument_list|,
name|n2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|mode
operator|=
name|MODE_Html
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c2
operator|==
literal|'t'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"tcl"
argument_list|,
name|n2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|mode
operator|=
name|MODE_Tcl
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|colSeparator
argument_list|)
argument_list|,
name|p
operator|->
name|colSeparator
argument_list|,
name|SEP_Space
argument_list|)
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|rowSeparator
argument_list|)
argument_list|,
name|p
operator|->
name|rowSeparator
argument_list|,
name|SEP_Row
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c2
operator|==
literal|'c'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"csv"
argument_list|,
name|n2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|mode
operator|=
name|MODE_Csv
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|colSeparator
argument_list|)
argument_list|,
name|p
operator|->
name|colSeparator
argument_list|,
name|SEP_Comma
argument_list|)
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|rowSeparator
argument_list|)
argument_list|,
name|p
operator|->
name|rowSeparator
argument_list|,
name|SEP_CrLf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c2
operator|==
literal|'t'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"tabs"
argument_list|,
name|n2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|mode
operator|=
name|MODE_List
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|colSeparator
argument_list|)
argument_list|,
name|p
operator|->
name|colSeparator
argument_list|,
name|SEP_Tab
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c2
operator|==
literal|'i'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"insert"
argument_list|,
name|n2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|mode
operator|=
name|MODE_Insert
expr_stmt|;
name|set_table_name
argument_list|(
name|p
argument_list|,
name|nArg
operator|>=
literal|3
condition|?
name|azArg
index|[
literal|2
index|]
else|:
literal|"table"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c2
operator|==
literal|'q'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"quote"
argument_list|,
name|n2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|mode
operator|=
name|MODE_Quote
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c2
operator|==
literal|'a'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"ascii"
argument_list|,
name|n2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|mode
operator|=
name|MODE_Ascii
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|colSeparator
argument_list|)
argument_list|,
name|p
operator|->
name|colSeparator
argument_list|,
name|SEP_Unit
argument_list|)
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|rowSeparator
argument_list|)
argument_list|,
name|p
operator|->
name|rowSeparator
argument_list|,
name|SEP_Record
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nArg
operator|==
literal|1
condition|)
block|{
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"current output mode: %s\n"
argument_list|,
name|modeDescr
index|[
name|p
operator|->
name|mode
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: mode should be one of: "
literal|"ascii column csv html insert line list quote tabs tcl\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
name|p
operator|->
name|cMode
operator|=
name|p
operator|->
name|mode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'n'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"nullvalue"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|==
literal|2
condition|)
block|{
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|nullValue
argument_list|)
argument_list|,
name|p
operator|->
name|nullValue
argument_list|,
literal|"%.*s"
argument_list|,
operator|(
name|int
operator|)
name|ArraySize
argument_list|(
name|p
operator|->
name|nullValue
argument_list|)
operator|-
literal|1
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .nullvalue STRING\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'o'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"open"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|&&
name|n
operator|>=
literal|2
condition|)
block|{
name|char
modifier|*
name|zNewFilename
decl_stmt|;
comment|/* Name of the database file to open */
name|int
name|iName
init|=
literal|1
decl_stmt|;
comment|/* Index in azArg[] of the filename */
name|int
name|newFlag
init|=
literal|0
decl_stmt|;
comment|/* True to delete file before opening */
comment|/* Close the existing database */
name|session_close_all
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sqlite3_close
argument_list|(
name|p
operator|->
name|db
argument_list|)
expr_stmt|;
name|p
operator|->
name|db
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|zDbFilename
operator|=
literal|0
expr_stmt|;
name|sqlite3_free
argument_list|(
name|p
operator|->
name|zFreeOnClose
argument_list|)
expr_stmt|;
name|p
operator|->
name|zFreeOnClose
operator|=
literal|0
expr_stmt|;
comment|/* Check for command-line arguments */
for|for
control|(
name|iName
operator|=
literal|1
init|;
name|iName
operator|<
name|nArg
operator|&&
name|azArg
index|[
name|iName
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|;
name|iName
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|z
init|=
name|azArg
index|[
name|iName
index|]
decl_stmt|;
if|if
condition|(
name|optionMatch
argument_list|(
name|z
argument_list|,
literal|"new"
argument_list|)
condition|)
block|{
name|newFlag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|z
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"unknown option: %s\n"
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
block|}
comment|/* If a filename is specified, try to open it first */
name|zNewFilename
operator|=
name|nArg
operator|>
name|iName
condition|?
name|sqlite3_mprintf
argument_list|(
literal|"%s"
argument_list|,
name|azArg
index|[
name|iName
index|]
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|zNewFilename
condition|)
block|{
if|if
condition|(
name|newFlag
condition|)
name|shellDeleteFile
argument_list|(
name|zNewFilename
argument_list|)
expr_stmt|;
name|p
operator|->
name|zDbFilename
operator|=
name|zNewFilename
expr_stmt|;
name|open_db
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|db
operator|==
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: cannot open '%s'\n"
argument_list|,
name|zNewFilename
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zNewFilename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|zFreeOnClose
operator|=
name|zNewFilename
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|db
operator|==
literal|0
condition|)
block|{
comment|/* As a fall-back open a TEMP database */
name|p
operator|->
name|zDbFilename
operator|=
literal|0
expr_stmt|;
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'o'
operator|&&
operator|(
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"output"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"once"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|zFile
init|=
name|nArg
operator|>=
literal|2
condition|?
name|azArg
index|[
literal|1
index|]
else|:
literal|"stdout"
decl_stmt|;
if|if
condition|(
name|nArg
operator|>
literal|2
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .%s FILE\n"
argument_list|,
name|azArg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
if|if
condition|(
name|n
operator|>
literal|1
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"once"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|<
literal|2
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .once FILE\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
name|p
operator|->
name|outCount
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|outCount
operator|=
literal|0
expr_stmt|;
block|}
name|output_reset
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|zFile
index|[
literal|0
index|]
operator|==
literal|'|'
condition|)
block|{
ifdef|#
directive|ifdef
name|SQLITE_OMIT_POPEN
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: pipes are not supported in this OS\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|out
operator|=
name|stdout
expr_stmt|;
else|#
directive|else
name|p
operator|->
name|out
operator|=
name|popen
argument_list|(
name|zFile
operator|+
literal|1
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|out
operator|==
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: cannot open pipe \"%s\"\n"
argument_list|,
name|zFile
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|->
name|out
operator|=
name|stdout
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|outfile
argument_list|)
argument_list|,
name|p
operator|->
name|outfile
argument_list|,
literal|"%s"
argument_list|,
name|zFile
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|p
operator|->
name|out
operator|=
name|output_file_open
argument_list|(
name|zFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|out
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|zFile
argument_list|,
literal|"off"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: cannot write to \"%s\"\n"
argument_list|,
name|zFile
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|out
operator|=
name|stdout
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|outfile
argument_list|)
argument_list|,
name|p
operator|->
name|outfile
argument_list|,
literal|"%s"
argument_list|,
name|zFile
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'p'
operator|&&
name|n
operator|>=
literal|3
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"print"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|1
condition|)
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'p'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"prompt"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|>=
literal|2
condition|)
block|{
name|strncpy
argument_list|(
name|mainPrompt
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|,
operator|(
name|int
operator|)
name|ArraySize
argument_list|(
name|mainPrompt
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nArg
operator|>=
literal|3
condition|)
block|{
name|strncpy
argument_list|(
name|continuePrompt
argument_list|,
name|azArg
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|)
name|ArraySize
argument_list|(
name|continuePrompt
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'q'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"quit"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'r'
operator|&&
name|n
operator|>=
literal|3
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"read"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|FILE
modifier|*
name|alt
decl_stmt|;
if|if
condition|(
name|nArg
operator|!=
literal|2
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .read FILE\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
name|alt
operator|=
name|fopen
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|alt
operator|==
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: cannot open \"%s\"\n"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|process_input
argument_list|(
name|p
argument_list|,
name|alt
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|alt
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'r'
operator|&&
name|n
operator|>=
literal|3
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"restore"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|zSrcFile
decl_stmt|;
specifier|const
name|char
modifier|*
name|zDb
decl_stmt|;
name|sqlite3
modifier|*
name|pSrc
decl_stmt|;
name|sqlite3_backup
modifier|*
name|pBackup
decl_stmt|;
name|int
name|nTimeout
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nArg
operator|==
literal|2
condition|)
block|{
name|zSrcFile
operator|=
name|azArg
index|[
literal|1
index|]
expr_stmt|;
name|zDb
operator|=
literal|"main"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nArg
operator|==
literal|3
condition|)
block|{
name|zSrcFile
operator|=
name|azArg
index|[
literal|2
index|]
expr_stmt|;
name|zDb
operator|=
name|azArg
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .restore ?DB? FILE\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
name|rc
operator|=
name|sqlite3_open
argument_list|(
name|zSrcFile
argument_list|,
operator|&
name|pSrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: cannot open \"%s\"\n"
argument_list|,
name|zSrcFile
argument_list|)
expr_stmt|;
name|sqlite3_close
argument_list|(
name|pSrc
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pBackup
operator|=
name|sqlite3_backup_init
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zDb
argument_list|,
name|pSrc
argument_list|,
literal|"main"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pBackup
operator|==
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|sqlite3_close
argument_list|(
name|pSrc
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
while|while
condition|(
operator|(
name|rc
operator|=
name|sqlite3_backup_step
argument_list|(
name|pBackup
argument_list|,
literal|100
argument_list|)
operator|)
operator|==
name|SQLITE_OK
operator|||
name|rc
operator|==
name|SQLITE_BUSY
condition|)
block|{
if|if
condition|(
name|rc
operator|==
name|SQLITE_BUSY
condition|)
block|{
if|if
condition|(
name|nTimeout
operator|++
operator|>=
literal|3
condition|)
break|break;
name|sqlite3_sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
name|sqlite3_backup_finish
argument_list|(
name|pBackup
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|SQLITE_DONE
condition|)
block|{
name|rc
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|==
name|SQLITE_BUSY
operator|||
name|rc
operator|==
name|SQLITE_LOCKED
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: source database is busy\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
name|sqlite3_close
argument_list|(
name|pSrc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'s'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"scanstats"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|==
literal|2
condition|)
block|{
name|p
operator|->
name|scanstatsOn
operator|=
name|booleanValue
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SQLITE_ENABLE_STMT_SCANSTATUS
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: .scanstats not available in this build.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .scanstats on|off\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'s'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"schema"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ShellText
name|sSelect
decl_stmt|;
name|ShellState
name|data
decl_stmt|;
name|char
modifier|*
name|zErrMsg
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|zDiv
init|=
literal|0
decl_stmt|;
name|int
name|iSchema
init|=
literal|0
decl_stmt|;
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|data
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|showHeader
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|cMode
operator|=
name|data
operator|.
name|mode
operator|=
name|MODE_Semi
expr_stmt|;
name|initText
argument_list|(
operator|&
name|sSelect
argument_list|)
expr_stmt|;
if|if
condition|(
name|nArg
operator|>=
literal|2
operator|&&
name|optionMatch
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"indent"
argument_list|)
condition|)
block|{
name|data
operator|.
name|cMode
operator|=
name|data
operator|.
name|mode
operator|=
name|MODE_Pretty
expr_stmt|;
name|nArg
operator|--
expr_stmt|;
if|if
condition|(
name|nArg
operator|==
literal|2
condition|)
name|azArg
index|[
literal|1
index|]
operator|=
name|azArg
index|[
literal|2
index|]
expr_stmt|;
block|}
if|if
condition|(
name|nArg
operator|==
literal|2
operator|&&
name|azArg
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|azArg
index|[
literal|1
index|]
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|azArg
index|[
literal|1
index|]
index|[
name|i
index|]
operator|=
name|ToLower
argument_list|(
name|azArg
index|[
literal|1
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"sqlite_master"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|new_argv
index|[
literal|2
index|]
decl_stmt|,
modifier|*
name|new_colv
index|[
literal|2
index|]
decl_stmt|;
name|new_argv
index|[
literal|0
index|]
operator|=
literal|"CREATE TABLE sqlite_master (\n"
literal|"  type text,\n"
literal|"  name text,\n"
literal|"  tbl_name text,\n"
literal|"  rootpage integer,\n"
literal|"  sql text\n"
literal|")"
expr_stmt|;
name|new_argv
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|new_colv
index|[
literal|0
index|]
operator|=
literal|"sql"
expr_stmt|;
name|new_colv
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|callback
argument_list|(
operator|&
name|data
argument_list|,
literal|1
argument_list|,
name|new_argv
argument_list|,
name|new_colv
argument_list|)
expr_stmt|;
name|rc
operator|=
name|SQLITE_OK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"sqlite_temp_master"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|new_argv
index|[
literal|2
index|]
decl_stmt|,
modifier|*
name|new_colv
index|[
literal|2
index|]
decl_stmt|;
name|new_argv
index|[
literal|0
index|]
operator|=
literal|"CREATE TEMP TABLE sqlite_temp_master (\n"
literal|"  type text,\n"
literal|"  name text,\n"
literal|"  tbl_name text,\n"
literal|"  rootpage integer,\n"
literal|"  sql text\n"
literal|")"
expr_stmt|;
name|new_argv
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|new_colv
index|[
literal|0
index|]
operator|=
literal|"sql"
expr_stmt|;
name|new_colv
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|callback
argument_list|(
operator|&
name|data
argument_list|,
literal|1
argument_list|,
name|new_argv
argument_list|,
name|new_colv
argument_list|)
expr_stmt|;
name|rc
operator|=
name|SQLITE_OK
expr_stmt|;
block|}
else|else
block|{
name|zDiv
operator|=
literal|"("
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nArg
operator|==
literal|1
condition|)
block|{
name|zDiv
operator|=
literal|"("
expr_stmt|;
block|}
else|else
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .schema ?--indent? ?LIKE-PATTERN?\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
if|if
condition|(
name|zDiv
condition|)
block|{
name|sqlite3_stmt
modifier|*
name|pStmt
init|=
literal|0
decl_stmt|;
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"SELECT name FROM pragma_database_list"
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
name|appendText
argument_list|(
operator|&
name|sSelect
argument_list|,
literal|"SELECT sql FROM"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iSchema
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sqlite3_step
argument_list|(
name|pStmt
argument_list|)
operator|==
name|SQLITE_ROW
condition|)
block|{
specifier|const
name|char
modifier|*
name|zDb
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pStmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|char
name|zScNum
index|[
literal|30
index|]
decl_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|zScNum
argument_list|)
argument_list|,
name|zScNum
argument_list|,
literal|"%d"
argument_list|,
operator|++
name|iSchema
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|sSelect
argument_list|,
name|zDiv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zDiv
operator|=
literal|" UNION ALL "
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|zDb
argument_list|,
literal|"main"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|appendText
argument_list|(
operator|&
name|sSelect
argument_list|,
literal|"SELECT shell_add_schema(sql,"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|sSelect
argument_list|,
name|zDb
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|sSelect
argument_list|,
literal|") AS sql, type, tbl_name, name, rowid,"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|sSelect
argument_list|,
name|zScNum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|sSelect
argument_list|,
literal|" AS snum, "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|sSelect
argument_list|,
name|zDb
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|sSelect
argument_list|,
literal|" AS sname FROM "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|sSelect
argument_list|,
name|zDb
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|sSelect
argument_list|,
literal|".sqlite_master"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|appendText
argument_list|(
operator|&
name|sSelect
argument_list|,
literal|"SELECT sql, type, tbl_name, name, rowid, "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|sSelect
argument_list|,
name|zScNum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|sSelect
argument_list|,
literal|" AS snum, 'main' AS sname FROM sqlite_master"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|sSelect
argument_list|,
literal|") WHERE "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nArg
operator|>
literal|1
condition|)
block|{
name|char
modifier|*
name|zQarg
init|=
name|sqlite3_mprintf
argument_list|(
literal|"%Q"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|'.'
argument_list|)
condition|)
block|{
name|appendText
argument_list|(
operator|&
name|sSelect
argument_list|,
literal|"lower(printf('%s.%s',sname,tbl_name))"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|appendText
argument_list|(
operator|&
name|sSelect
argument_list|,
literal|"lower(tbl_name)"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|appendText
argument_list|(
operator|&
name|sSelect
argument_list|,
name|strchr
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|'*'
argument_list|)
condition|?
literal|" GLOB "
else|:
literal|" LIKE "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|sSelect
argument_list|,
name|zQarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|sSelect
argument_list|,
literal|" AND "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zQarg
argument_list|)
expr_stmt|;
block|}
name|appendText
argument_list|(
operator|&
name|sSelect
argument_list|,
literal|"type!='meta' AND sql IS NOT NULL"
literal|" ORDER BY snum, rowid"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|sSelect
operator|.
name|z
argument_list|,
name|callback
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
name|freeText
argument_list|(
operator|&
name|sSelect
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zErrMsg
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|zErrMsg
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zErrMsg
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: querying schema information\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|SQLITE_ENABLE_SELECTTRACE
argument_list|)
if|if
condition|(
name|c
operator|==
literal|'s'
operator|&&
name|n
operator|==
literal|11
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"selecttrace"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sqlite3SelectTrace
operator|=
operator|(
name|int
operator|)
name|integerValue
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_ENABLE_SESSION
argument_list|)
if|if
condition|(
name|c
operator|==
literal|'s'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"session"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|&&
name|n
operator|>=
literal|3
condition|)
block|{
name|OpenSession
modifier|*
name|pSession
init|=
operator|&
name|p
operator|->
name|aSession
index|[
literal|0
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|azCmd
init|=
operator|&
name|azArg
index|[
literal|1
index|]
decl_stmt|;
name|int
name|iSes
init|=
literal|0
decl_stmt|;
name|int
name|nCmd
init|=
name|nArg
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|nArg
operator|<=
literal|1
condition|)
goto|goto
name|session_syntax_error
goto|;
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nArg
operator|>=
literal|3
condition|)
block|{
for|for
control|(
name|iSes
operator|=
literal|0
init|;
name|iSes
operator|<
name|p
operator|->
name|nSession
condition|;
name|iSes
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|aSession
index|[
name|iSes
index|]
operator|.
name|zName
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|iSes
operator|<
name|p
operator|->
name|nSession
condition|)
block|{
name|pSession
operator|=
operator|&
name|p
operator|->
name|aSession
index|[
name|iSes
index|]
expr_stmt|;
name|azCmd
operator|++
expr_stmt|;
name|nCmd
operator|--
expr_stmt|;
block|}
else|else
block|{
name|pSession
operator|=
operator|&
name|p
operator|->
name|aSession
index|[
literal|0
index|]
expr_stmt|;
name|iSes
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* .session attach TABLE     ** Invoke the sqlite3session_attach() interface to attach a particular     ** table so that it is never filtered.     */
if|if
condition|(
name|strcmp
argument_list|(
name|azCmd
index|[
literal|0
index|]
argument_list|,
literal|"attach"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nCmd
operator|!=
literal|2
condition|)
goto|goto
name|session_syntax_error
goto|;
if|if
condition|(
name|pSession
operator|->
name|p
operator|==
literal|0
condition|)
block|{
name|session_not_open
label|:
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: No sessions are open\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|sqlite3session_attach
argument_list|(
name|pSession
operator|->
name|p
argument_list|,
name|azCmd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: sqlite3session_attach() returns %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
elseif|else
comment|/* .session changeset FILE     ** .session patchset FILE     ** Write a changeset or patchset into a file.  The file is overwritten.     */
if|if
condition|(
name|strcmp
argument_list|(
name|azCmd
index|[
literal|0
index|]
argument_list|,
literal|"changeset"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|azCmd
index|[
literal|0
index|]
argument_list|,
literal|"patchset"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|FILE
modifier|*
name|out
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nCmd
operator|!=
literal|2
condition|)
goto|goto
name|session_syntax_error
goto|;
if|if
condition|(
name|pSession
operator|->
name|p
operator|==
literal|0
condition|)
goto|goto
name|session_not_open
goto|;
name|out
operator|=
name|fopen
argument_list|(
name|azCmd
index|[
literal|1
index|]
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: cannot open \"%s\" for writing\n"
argument_list|,
name|azCmd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|szChng
decl_stmt|;
name|void
modifier|*
name|pChng
decl_stmt|;
if|if
condition|(
name|azCmd
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'c'
condition|)
block|{
name|rc
operator|=
name|sqlite3session_changeset
argument_list|(
name|pSession
operator|->
name|p
argument_list|,
operator|&
name|szChng
argument_list|,
operator|&
name|pChng
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|sqlite3session_patchset
argument_list|(
name|pSession
operator|->
name|p
argument_list|,
operator|&
name|szChng
argument_list|,
operator|&
name|pChng
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
condition|)
block|{
name|printf
argument_list|(
literal|"Error: error code %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pChng
operator|&&
name|fwrite
argument_list|(
name|pChng
argument_list|,
name|szChng
argument_list|,
literal|1
argument_list|,
name|out
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: Failed to write entire %d-byte output\n"
argument_list|,
name|szChng
argument_list|)
expr_stmt|;
block|}
name|sqlite3_free
argument_list|(
name|pChng
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
comment|/* .session close     ** Close the identified session     */
if|if
condition|(
name|strcmp
argument_list|(
name|azCmd
index|[
literal|0
index|]
argument_list|,
literal|"close"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nCmd
operator|!=
literal|1
condition|)
goto|goto
name|session_syntax_error
goto|;
if|if
condition|(
name|p
operator|->
name|nSession
condition|)
block|{
name|session_close
argument_list|(
name|pSession
argument_list|)
expr_stmt|;
name|p
operator|->
name|aSession
index|[
name|iSes
index|]
operator|=
name|p
operator|->
name|aSession
index|[
operator|--
name|p
operator|->
name|nSession
index|]
expr_stmt|;
block|}
block|}
elseif|else
comment|/* .session enable ?BOOLEAN?     ** Query or set the enable flag     */
if|if
condition|(
name|strcmp
argument_list|(
name|azCmd
index|[
literal|0
index|]
argument_list|,
literal|"enable"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|ii
decl_stmt|;
if|if
condition|(
name|nCmd
operator|>
literal|2
condition|)
goto|goto
name|session_syntax_error
goto|;
name|ii
operator|=
name|nCmd
operator|==
literal|1
condition|?
operator|-
literal|1
else|:
name|booleanValue
argument_list|(
name|azCmd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|nSession
condition|)
block|{
name|ii
operator|=
name|sqlite3session_enable
argument_list|(
name|pSession
operator|->
name|p
argument_list|,
name|ii
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"session %s enable flag = %d\n"
argument_list|,
name|pSession
operator|->
name|zName
argument_list|,
name|ii
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
comment|/* .session filter GLOB ....     ** Set a list of GLOB patterns of table names to be excluded.     */
if|if
condition|(
name|strcmp
argument_list|(
name|azCmd
index|[
literal|0
index|]
argument_list|,
literal|"filter"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|ii
decl_stmt|,
name|nByte
decl_stmt|;
if|if
condition|(
name|nCmd
operator|<
literal|2
condition|)
goto|goto
name|session_syntax_error
goto|;
if|if
condition|(
name|p
operator|->
name|nSession
condition|)
block|{
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|pSession
operator|->
name|nFilter
condition|;
name|ii
operator|++
control|)
block|{
name|sqlite3_free
argument_list|(
name|pSession
operator|->
name|azFilter
index|[
name|ii
index|]
argument_list|)
expr_stmt|;
block|}
name|sqlite3_free
argument_list|(
name|pSession
operator|->
name|azFilter
argument_list|)
expr_stmt|;
name|nByte
operator|=
sizeof|sizeof
argument_list|(
name|pSession
operator|->
name|azFilter
index|[
literal|0
index|]
argument_list|)
operator|*
operator|(
name|nCmd
operator|-
literal|1
operator|)
expr_stmt|;
name|pSession
operator|->
name|azFilter
operator|=
name|sqlite3_malloc
argument_list|(
name|nByte
argument_list|)
expr_stmt|;
if|if
condition|(
name|pSession
operator|->
name|azFilter
operator|==
literal|0
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: out or memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ii
operator|=
literal|1
init|;
name|ii
operator|<
name|nCmd
condition|;
name|ii
operator|++
control|)
block|{
name|pSession
operator|->
name|azFilter
index|[
name|ii
operator|-
literal|1
index|]
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"%s"
argument_list|,
name|azCmd
index|[
name|ii
index|]
argument_list|)
expr_stmt|;
block|}
name|pSession
operator|->
name|nFilter
operator|=
name|ii
operator|-
literal|1
expr_stmt|;
block|}
block|}
elseif|else
comment|/* .session indirect ?BOOLEAN?     ** Query or set the indirect flag     */
if|if
condition|(
name|strcmp
argument_list|(
name|azCmd
index|[
literal|0
index|]
argument_list|,
literal|"indirect"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|ii
decl_stmt|;
if|if
condition|(
name|nCmd
operator|>
literal|2
condition|)
goto|goto
name|session_syntax_error
goto|;
name|ii
operator|=
name|nCmd
operator|==
literal|1
condition|?
operator|-
literal|1
else|:
name|booleanValue
argument_list|(
name|azCmd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|nSession
condition|)
block|{
name|ii
operator|=
name|sqlite3session_indirect
argument_list|(
name|pSession
operator|->
name|p
argument_list|,
name|ii
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"session %s indirect flag = %d\n"
argument_list|,
name|pSession
operator|->
name|zName
argument_list|,
name|ii
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
comment|/* .session isempty     ** Determine if the session is empty     */
if|if
condition|(
name|strcmp
argument_list|(
name|azCmd
index|[
literal|0
index|]
argument_list|,
literal|"isempty"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|ii
decl_stmt|;
if|if
condition|(
name|nCmd
operator|!=
literal|1
condition|)
goto|goto
name|session_syntax_error
goto|;
if|if
condition|(
name|p
operator|->
name|nSession
condition|)
block|{
name|ii
operator|=
name|sqlite3session_isempty
argument_list|(
name|pSession
operator|->
name|p
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"session %s isempty flag = %d\n"
argument_list|,
name|pSession
operator|->
name|zName
argument_list|,
name|ii
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
comment|/* .session list     ** List all currently open sessions     */
if|if
condition|(
name|strcmp
argument_list|(
name|azCmd
index|[
literal|0
index|]
argument_list|,
literal|"list"
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|nSession
condition|;
name|i
operator|++
control|)
block|{
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%d %s\n"
argument_list|,
name|i
argument_list|,
name|p
operator|->
name|aSession
index|[
name|i
index|]
operator|.
name|zName
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
comment|/* .session open DB NAME     ** Open a new session called NAME on the attached database DB.     ** DB is normally "main".     */
if|if
condition|(
name|strcmp
argument_list|(
name|azCmd
index|[
literal|0
index|]
argument_list|,
literal|"open"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|zName
decl_stmt|;
if|if
condition|(
name|nCmd
operator|!=
literal|3
condition|)
goto|goto
name|session_syntax_error
goto|;
name|zName
operator|=
name|azCmd
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|zName
index|[
literal|0
index|]
operator|==
literal|0
condition|)
goto|goto
name|session_syntax_error
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|nSession
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|aSession
index|[
name|i
index|]
operator|.
name|zName
argument_list|,
name|zName
argument_list|)
operator|==
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Session \"%s\" already exists\n"
argument_list|,
name|zName
argument_list|)
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|nSession
operator|>=
name|ArraySize
argument_list|(
name|p
operator|->
name|aSession
argument_list|)
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Maximum of %d sessions\n"
argument_list|,
name|ArraySize
argument_list|(
name|p
operator|->
name|aSession
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
name|pSession
operator|=
operator|&
name|p
operator|->
name|aSession
index|[
name|p
operator|->
name|nSession
index|]
expr_stmt|;
name|rc
operator|=
name|sqlite3session_create
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|azCmd
index|[
literal|1
index|]
argument_list|,
operator|&
name|pSession
operator|->
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot open session: error code=%d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
name|pSession
operator|->
name|nFilter
operator|=
literal|0
expr_stmt|;
name|sqlite3session_table_filter
argument_list|(
name|pSession
operator|->
name|p
argument_list|,
name|session_filter
argument_list|,
name|pSession
argument_list|)
expr_stmt|;
name|p
operator|->
name|nSession
operator|++
expr_stmt|;
name|pSession
operator|->
name|zName
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"%s"
argument_list|,
name|zName
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* If no command name matches, show a syntax error */
name|session_syntax_error
label|:
name|session_help
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SQLITE_DEBUG
comment|/* Undocumented commands for internal testing.  Subject to change   ** without notice. */
if|if
condition|(
name|c
operator|==
literal|'s'
operator|&&
name|n
operator|>=
literal|10
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"selftest-"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
operator|+
literal|9
argument_list|,
literal|"boolean"
argument_list|,
name|n
operator|-
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|,
name|v
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
name|booleanValue
argument_list|(
name|azArg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s: %d 0x%x\n"
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|,
name|v
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
operator|+
literal|9
argument_list|,
literal|"integer"
argument_list|,
name|n
operator|-
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|sqlite3_int64
name|v
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|char
name|zBuf
index|[
literal|200
index|]
decl_stmt|;
name|v
operator|=
name|integerValue
argument_list|(
name|azArg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|zBuf
argument_list|)
argument_list|,
name|zBuf
argument_list|,
literal|"%s: %lld 0x%llx\n"
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|,
name|v
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|zBuf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
literal|'s'
operator|&&
name|n
operator|>=
literal|4
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"selftest"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|bIsInit
init|=
literal|0
decl_stmt|;
comment|/* True to initialize the SELFTEST table */
name|int
name|bVerbose
init|=
literal|0
decl_stmt|;
comment|/* Verbose output */
name|int
name|bSelftestExists
decl_stmt|;
comment|/* True if SELFTEST already exists */
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
comment|/* Loop counters */
name|int
name|nTest
init|=
literal|0
decl_stmt|;
comment|/* Number of tests runs */
name|int
name|nErr
init|=
literal|0
decl_stmt|;
comment|/* Number of errors seen */
name|ShellText
name|str
decl_stmt|;
comment|/* Answer for a query */
name|sqlite3_stmt
modifier|*
name|pStmt
init|=
literal|0
decl_stmt|;
comment|/* Query against the SELFTEST table */
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|z
init|=
name|azArg
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|z
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|z
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
name|z
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-init"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bIsInit
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-v"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bVerbose
operator|++
expr_stmt|;
block|}
else|else
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown option \"%s\" on \"%s\"\n"
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|,
name|azArg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Should be one of: --init -v\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
block|}
if|if
condition|(
name|sqlite3_table_column_metadata
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"main"
argument_list|,
literal|"selftest"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
name|SQLITE_OK
condition|)
block|{
name|bSelftestExists
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bSelftestExists
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bIsInit
condition|)
block|{
name|createSelftestTable
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|bSelftestExists
operator|=
literal|1
expr_stmt|;
block|}
name|initText
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|str
argument_list|,
literal|"x"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
name|bSelftestExists
init|;
name|k
operator|>=
literal|0
condition|;
name|k
operator|--
control|)
block|{
if|if
condition|(
name|k
operator|==
literal|1
condition|)
block|{
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"SELECT tno,op,cmd,ans FROM selftest ORDER BY tno"
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"VALUES(0,'memo','Missing SELFTEST table - default checks only',''),"
literal|"      (1,'run','PRAGMA integrity_check','ok')"
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error querying the selftest table\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|sqlite3_step
argument_list|(
name|pStmt
argument_list|)
operator|==
name|SQLITE_ROW
condition|;
name|i
operator|++
control|)
block|{
name|int
name|tno
init|=
name|sqlite3_column_int
argument_list|(
name|pStmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|zOp
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pStmt
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|zSql
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pStmt
argument_list|,
literal|2
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|zAns
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pStmt
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bVerbose
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|zQuote
init|=
name|sqlite3_mprintf
argument_list|(
literal|"%q"
argument_list|,
name|zSql
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"%d: %s %s\n"
argument_list|,
name|tno
argument_list|,
name|zOp
argument_list|,
name|zSql
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zQuote
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|zOp
argument_list|,
literal|"memo"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s\n"
argument_list|,
name|zSql
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|zOp
argument_list|,
literal|"run"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|zErrMsg
init|=
literal|0
decl_stmt|;
name|str
operator|.
name|n
operator|=
literal|0
expr_stmt|;
name|str
operator|.
name|z
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zSql
argument_list|,
name|captureOutputCallback
argument_list|,
operator|&
name|str
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
name|nTest
operator|++
expr_stmt|;
if|if
condition|(
name|bVerbose
condition|)
block|{
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"Result: %s\n"
argument_list|,
name|str
operator|.
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|||
name|zErrMsg
condition|)
block|{
name|nErr
operator|++
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%d: error-code-%d: %s\n"
argument_list|,
name|tno
argument_list|,
name|rc
argument_list|,
name|zErrMsg
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zErrMsg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|zAns
argument_list|,
name|str
operator|.
name|z
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nErr
operator|++
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%d: Expected: [%s]\n"
argument_list|,
name|tno
argument_list|,
name|zAns
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%d:      Got: [%s]\n"
argument_list|,
name|tno
argument_list|,
name|str
operator|.
name|z
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown operation \"%s\" on selftest line %d\n"
argument_list|,
name|zOp
argument_list|,
name|tno
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* End loop over rows of content from SELFTEST */
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
block|}
comment|/* End loop over k */
name|freeText
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%d errors out of %d tests\n"
argument_list|,
name|nErr
argument_list|,
name|nTest
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'s'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"separator"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|<
literal|2
operator|||
name|nArg
operator|>
literal|3
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .separator COL ?ROW?\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|nArg
operator|>=
literal|2
condition|)
block|{
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|colSeparator
argument_list|)
argument_list|,
name|p
operator|->
name|colSeparator
argument_list|,
literal|"%.*s"
argument_list|,
operator|(
name|int
operator|)
name|ArraySize
argument_list|(
name|p
operator|->
name|colSeparator
argument_list|)
operator|-
literal|1
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nArg
operator|>=
literal|3
condition|)
block|{
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|rowSeparator
argument_list|)
argument_list|,
name|p
operator|->
name|rowSeparator
argument_list|,
literal|"%.*s"
argument_list|,
operator|(
name|int
operator|)
name|ArraySize
argument_list|(
name|p
operator|->
name|rowSeparator
argument_list|)
operator|-
literal|1
argument_list|,
name|azArg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'s'
operator|&&
name|n
operator|>=
literal|4
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"sha3sum"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|zLike
init|=
literal|0
decl_stmt|;
comment|/* Which table to checksum. 0 means everything */
name|int
name|i
decl_stmt|;
comment|/* Loop counter */
name|int
name|bSchema
init|=
literal|0
decl_stmt|;
comment|/* Also hash the schema */
name|int
name|bSeparate
init|=
literal|0
decl_stmt|;
comment|/* Hash each table separately */
name|int
name|iSize
init|=
literal|224
decl_stmt|;
comment|/* Hash algorithm to use */
name|int
name|bDebug
init|=
literal|0
decl_stmt|;
comment|/* Only show the query that would have run */
name|sqlite3_stmt
modifier|*
name|pStmt
decl_stmt|;
comment|/* For querying tables names */
name|char
modifier|*
name|zSql
decl_stmt|;
comment|/* SQL to be run */
name|char
modifier|*
name|zSep
decl_stmt|;
comment|/* Separator */
name|ShellText
name|sSql
decl_stmt|;
comment|/* Complete SQL for the query to run the hash */
name|ShellText
name|sQuery
decl_stmt|;
comment|/* Set of queries used to read all content */
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|z
init|=
name|azArg
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|z
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|z
operator|++
expr_stmt|;
if|if
condition|(
name|z
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|z
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"schema"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bSchema
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"sha3-224"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"sha3-256"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"sha3-384"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"sha3-512"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|iSize
operator|=
name|atoi
argument_list|(
operator|&
name|z
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"debug"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bDebug
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown option \"%s\" on \"%s\"\n"
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|,
name|azArg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Should be one of: --schema"
literal|" --sha3-224 --sha3-255 --sha3-384 --sha3-512\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|zLike
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .sha3sum ?OPTIONS? ?LIKE-PATTERN?\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
else|else
block|{
name|zLike
operator|=
name|z
expr_stmt|;
name|bSeparate
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sqlite3_strlike
argument_list|(
literal|"sqlite_%"
argument_list|,
name|zLike
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|bSchema
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bSchema
condition|)
block|{
name|zSql
operator|=
literal|"SELECT lower(name) FROM sqlite_master"
literal|" WHERE type='table' AND coalesce(rootpage,0)>1"
literal|" UNION ALL SELECT 'sqlite_master'"
literal|" ORDER BY 1 collate nocase"
expr_stmt|;
block|}
else|else
block|{
name|zSql
operator|=
literal|"SELECT lower(name) FROM sqlite_master"
literal|" WHERE type='table' AND coalesce(rootpage,0)>1"
literal|" AND name NOT LIKE 'sqlite_%'"
literal|" ORDER BY 1 collate nocase"
expr_stmt|;
block|}
name|sqlite3_prepare_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zSql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initText
argument_list|(
operator|&
name|sQuery
argument_list|)
expr_stmt|;
name|initText
argument_list|(
operator|&
name|sSql
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|sSql
argument_list|,
literal|"WITH [sha3sum$query](a,b) AS("
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zSep
operator|=
literal|"VALUES("
expr_stmt|;
while|while
condition|(
name|SQLITE_ROW
operator|==
name|sqlite3_step
argument_list|(
name|pStmt
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|zTab
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pStmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|zLike
operator|&&
name|sqlite3_strlike
argument_list|(
name|zLike
argument_list|,
name|zTab
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strncmp
argument_list|(
name|zTab
argument_list|,
literal|"sqlite_"
argument_list|,
literal|7
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|appendText
argument_list|(
operator|&
name|sQuery
argument_list|,
literal|"SELECT * FROM "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|sQuery
argument_list|,
name|zTab
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|sQuery
argument_list|,
literal|" NOT INDEXED;"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|zTab
argument_list|,
literal|"sqlite_master"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|appendText
argument_list|(
operator|&
name|sQuery
argument_list|,
literal|"SELECT type,name,tbl_name,sql FROM sqlite_master"
literal|" ORDER BY name;"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|zTab
argument_list|,
literal|"sqlite_sequence"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|appendText
argument_list|(
operator|&
name|sQuery
argument_list|,
literal|"SELECT name,seq FROM sqlite_sequence"
literal|" ORDER BY name;"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|zTab
argument_list|,
literal|"sqlite_stat1"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|appendText
argument_list|(
operator|&
name|sQuery
argument_list|,
literal|"SELECT tbl,idx,stat FROM sqlite_stat1"
literal|" ORDER BY tbl,idx;"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|zTab
argument_list|,
literal|"sqlite_stat3"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|zTab
argument_list|,
literal|"sqlite_stat4"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|appendText
argument_list|(
operator|&
name|sQuery
argument_list|,
literal|"SELECT * FROM "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|sQuery
argument_list|,
name|zTab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|sQuery
argument_list|,
literal|" ORDER BY tbl, idx, rowid;\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|appendText
argument_list|(
operator|&
name|sSql
argument_list|,
name|zSep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|sSql
argument_list|,
name|sQuery
operator|.
name|z
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
name|sQuery
operator|.
name|n
operator|=
literal|0
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|sSql
argument_list|,
literal|","
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|sSql
argument_list|,
name|zTab
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
name|zSep
operator|=
literal|"),("
expr_stmt|;
block|}
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|bSeparate
condition|)
block|{
name|zSql
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"%s))"
literal|" SELECT lower(hex(sha3_query(a,%d))) AS hash, b AS label"
literal|"   FROM [sha3sum$query]"
argument_list|,
name|sSql
operator|.
name|z
argument_list|,
name|iSize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zSql
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"%s))"
literal|" SELECT lower(hex(sha3_query(group_concat(a,''),%d))) AS hash"
literal|"   FROM [sha3sum$query]"
argument_list|,
name|sSql
operator|.
name|z
argument_list|,
name|iSize
argument_list|)
expr_stmt|;
block|}
name|freeText
argument_list|(
operator|&
name|sQuery
argument_list|)
expr_stmt|;
name|freeText
argument_list|(
operator|&
name|sSql
argument_list|)
expr_stmt|;
if|if
condition|(
name|bDebug
condition|)
block|{
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s\n"
argument_list|,
name|zSql
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|shell_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zSql
argument_list|,
name|shell_callback
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sqlite3_free
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'s'
operator|&&
operator|(
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"shell"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"system"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|char
modifier|*
name|zCmd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|x
decl_stmt|;
if|if
condition|(
name|nArg
operator|<
literal|2
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .system COMMAND\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
name|zCmd
operator|=
name|sqlite3_mprintf
argument_list|(
name|strchr
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|' '
argument_list|)
operator|==
literal|0
condition|?
literal|"%s"
else|:
literal|"\"%s\""
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|zCmd
operator|=
name|sqlite3_mprintf
argument_list|(
name|strchr
argument_list|(
name|azArg
index|[
name|i
index|]
argument_list|,
literal|' '
argument_list|)
operator|==
literal|0
condition|?
literal|"%z %s"
else|:
literal|"%z \"%s\""
argument_list|,
name|zCmd
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|system
argument_list|(
name|zCmd
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zCmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
condition|)
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"System command returns %d\n"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'s'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"show"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|azBool
index|[]
init|=
block|{
literal|"off"
block|,
literal|"on"
block|,
literal|"full"
block|,
literal|"unk"
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|nArg
operator|!=
literal|1
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .show\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%12.12s: %s\n"
argument_list|,
literal|"echo"
argument_list|,
name|azBool
index|[
name|ShellHasFlag
argument_list|(
name|p
argument_list|,
name|SHFLG_Echo
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%12.12s: %s\n"
argument_list|,
literal|"eqp"
argument_list|,
name|azBool
index|[
name|p
operator|->
name|autoEQP
operator|&
literal|3
index|]
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%12.12s: %s\n"
argument_list|,
literal|"explain"
argument_list|,
name|p
operator|->
name|mode
operator|==
name|MODE_Explain
condition|?
literal|"on"
else|:
name|p
operator|->
name|autoExplain
condition|?
literal|"auto"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%12.12s: %s\n"
argument_list|,
literal|"headers"
argument_list|,
name|azBool
index|[
name|p
operator|->
name|showHeader
operator|!=
literal|0
index|]
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%12.12s: %s\n"
argument_list|,
literal|"mode"
argument_list|,
name|modeDescr
index|[
name|p
operator|->
name|mode
index|]
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%12.12s: "
argument_list|,
literal|"nullvalue"
argument_list|)
expr_stmt|;
name|output_c_string
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|p
operator|->
name|nullValue
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%12.12s: %s\n"
argument_list|,
literal|"output"
argument_list|,
name|strlen30
argument_list|(
name|p
operator|->
name|outfile
argument_list|)
condition|?
name|p
operator|->
name|outfile
else|:
literal|"stdout"
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%12.12s: "
argument_list|,
literal|"colseparator"
argument_list|)
expr_stmt|;
name|output_c_string
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|p
operator|->
name|colSeparator
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%12.12s: "
argument_list|,
literal|"rowseparator"
argument_list|)
expr_stmt|;
name|output_c_string
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|p
operator|->
name|rowSeparator
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%12.12s: %s\n"
argument_list|,
literal|"stats"
argument_list|,
name|azBool
index|[
name|p
operator|->
name|statsOn
operator|!=
literal|0
index|]
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%12.12s: "
argument_list|,
literal|"width"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|ArraySize
argument_list|(
name|p
operator|->
name|colWidth
argument_list|)
operator|&&
name|p
operator|->
name|colWidth
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%d "
argument_list|,
name|p
operator|->
name|colWidth
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%12.12s: %s\n"
argument_list|,
literal|"filename"
argument_list|,
name|p
operator|->
name|zDbFilename
condition|?
name|p
operator|->
name|zDbFilename
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'s'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"stats"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|==
literal|2
condition|)
block|{
name|p
operator|->
name|statsOn
operator|=
name|booleanValue
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nArg
operator|==
literal|1
condition|)
block|{
name|display_stats
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .stats ?on|off?\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'t'
operator|&&
name|n
operator|>
literal|1
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"tables"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|c
operator|==
literal|'i'
operator|&&
operator|(
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"indices"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"indexes"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|sqlite3_stmt
modifier|*
name|pStmt
decl_stmt|;
name|char
modifier|*
modifier|*
name|azResult
decl_stmt|;
name|int
name|nRow
decl_stmt|,
name|nAlloc
decl_stmt|;
name|int
name|ii
decl_stmt|;
name|ShellText
name|s
decl_stmt|;
name|initText
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"PRAGMA database_list"
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|shellDatabaseError
argument_list|(
name|p
operator|->
name|db
argument_list|)
return|;
if|if
condition|(
name|nArg
operator|>
literal|2
operator|&&
name|c
operator|==
literal|'i'
condition|)
block|{
comment|/* It is an historical accident that the .indexes command shows an error       ** when called with the wrong number of arguments whereas the .tables       ** command does not. */
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .indexes ?LIKE-PATTERN?\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|sqlite3_step
argument_list|(
name|pStmt
argument_list|)
operator|==
name|SQLITE_ROW
condition|;
name|ii
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|zDbName
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pStmt
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|zDbName
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|s
operator|.
name|z
operator|&&
name|s
operator|.
name|z
index|[
literal|0
index|]
condition|)
name|appendText
argument_list|(
operator|&
name|s
argument_list|,
literal|" UNION ALL "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sqlite3_stricmp
argument_list|(
name|zDbName
argument_list|,
literal|"main"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|appendText
argument_list|(
operator|&
name|s
argument_list|,
literal|"SELECT name FROM "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|appendText
argument_list|(
operator|&
name|s
argument_list|,
literal|"SELECT "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|s
argument_list|,
name|zDbName
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|s
argument_list|,
literal|"||'.'||name FROM "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|appendText
argument_list|(
operator|&
name|s
argument_list|,
name|zDbName
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|s
argument_list|,
literal|".sqlite_master "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'t'
condition|)
block|{
name|appendText
argument_list|(
operator|&
name|s
argument_list|,
literal|" WHERE type IN ('table','view')"
literal|"   AND name NOT LIKE 'sqlite_%'"
literal|"   AND name LIKE ?1"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|appendText
argument_list|(
operator|&
name|s
argument_list|,
literal|" WHERE type='index'"
literal|"   AND tbl_name LIKE ?1"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|rc
operator|=
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|appendText
argument_list|(
operator|&
name|s
argument_list|,
literal|" ORDER BY 1"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|s
operator|.
name|z
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|freeText
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|shellDatabaseError
argument_list|(
name|p
operator|->
name|db
argument_list|)
return|;
comment|/* Run the SQL statement prepared by the above block. Store the results     ** as an array of nul-terminated strings in azResult[].  */
name|nRow
operator|=
name|nAlloc
operator|=
literal|0
expr_stmt|;
name|azResult
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nArg
operator|>
literal|1
condition|)
block|{
name|sqlite3_bind_text
argument_list|(
name|pStmt
argument_list|,
literal|1
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|,
operator|-
literal|1
argument_list|,
name|SQLITE_TRANSIENT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sqlite3_bind_text
argument_list|(
name|pStmt
argument_list|,
literal|1
argument_list|,
literal|"%"
argument_list|,
operator|-
literal|1
argument_list|,
name|SQLITE_STATIC
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|sqlite3_step
argument_list|(
name|pStmt
argument_list|)
operator|==
name|SQLITE_ROW
condition|)
block|{
if|if
condition|(
name|nRow
operator|>=
name|nAlloc
condition|)
block|{
name|char
modifier|*
modifier|*
name|azNew
decl_stmt|;
name|int
name|n2
init|=
name|nAlloc
operator|*
literal|2
operator|+
literal|10
decl_stmt|;
name|azNew
operator|=
name|sqlite3_realloc64
argument_list|(
name|azResult
argument_list|,
sizeof|sizeof
argument_list|(
name|azResult
index|[
literal|0
index|]
argument_list|)
operator|*
name|n2
argument_list|)
expr_stmt|;
if|if
condition|(
name|azNew
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|shellNomemError
argument_list|()
expr_stmt|;
break|break;
block|}
name|nAlloc
operator|=
name|n2
expr_stmt|;
name|azResult
operator|=
name|azNew
expr_stmt|;
block|}
name|azResult
index|[
name|nRow
index|]
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"%s"
argument_list|,
name|sqlite3_column_text
argument_list|(
name|pStmt
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|azResult
index|[
name|nRow
index|]
condition|)
block|{
name|rc
operator|=
name|shellNomemError
argument_list|()
expr_stmt|;
break|break;
block|}
name|nRow
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
operator|!=
name|SQLITE_OK
condition|)
block|{
name|rc
operator|=
name|shellDatabaseError
argument_list|(
name|p
operator|->
name|db
argument_list|)
expr_stmt|;
block|}
comment|/* Pretty-print the contents of array azResult[] to the output */
if|if
condition|(
name|rc
operator|==
literal|0
operator|&&
name|nRow
operator|>
literal|0
condition|)
block|{
name|int
name|len
decl_stmt|,
name|maxlen
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|nPrintCol
decl_stmt|,
name|nPrintRow
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nRow
condition|;
name|i
operator|++
control|)
block|{
name|len
operator|=
name|strlen30
argument_list|(
name|azResult
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|maxlen
condition|)
name|maxlen
operator|=
name|len
expr_stmt|;
block|}
name|nPrintCol
operator|=
literal|80
operator|/
operator|(
name|maxlen
operator|+
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|nPrintCol
operator|<
literal|1
condition|)
name|nPrintCol
operator|=
literal|1
expr_stmt|;
name|nPrintRow
operator|=
operator|(
name|nRow
operator|+
name|nPrintCol
operator|-
literal|1
operator|)
operator|/
name|nPrintCol
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nPrintRow
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|nRow
condition|;
name|j
operator|+=
name|nPrintRow
control|)
block|{
name|char
modifier|*
name|zSp
init|=
name|j
operator|<
name|nPrintRow
condition|?
literal|""
else|:
literal|"  "
decl_stmt|;
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s%-*s"
argument_list|,
name|zSp
argument_list|,
name|maxlen
argument_list|,
name|azResult
index|[
name|j
index|]
condition|?
name|azResult
index|[
name|j
index|]
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|nRow
condition|;
name|ii
operator|++
control|)
name|sqlite3_free
argument_list|(
name|azResult
index|[
name|ii
index|]
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|azResult
argument_list|)
expr_stmt|;
block|}
elseif|else
comment|/* Begin redirecting output to the file "testcase-out.txt" */
if|if
condition|(
name|c
operator|==
literal|'t'
operator|&&
name|strcmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"testcase"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|output_reset
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|out
operator|=
name|output_file_open
argument_list|(
literal|"testcase-out.txt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|out
operator|==
literal|0
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: cannot open 'testcase-out.txt'\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nArg
operator|>=
literal|2
condition|)
block|{
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|zTestcase
argument_list|)
argument_list|,
name|p
operator|->
name|zTestcase
argument_list|,
literal|"%s"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|zTestcase
argument_list|)
argument_list|,
name|p
operator|->
name|zTestcase
argument_list|,
literal|"?"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
ifndef|#
directive|ifndef
name|SQLITE_UNTESTABLE
if|if
condition|(
name|c
operator|==
literal|'t'
operator|&&
name|n
operator|>=
literal|8
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"testctrl"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|&&
name|nArg
operator|>=
literal|2
condition|)
block|{
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|zCtrlName
decl_stmt|;
comment|/* Name of a test-control option */
name|int
name|ctrlCode
decl_stmt|;
comment|/* Integer code for that option */
block|}
name|aCtrl
index|[]
init|=
block|{
block|{
literal|"prng_save"
block|,
name|SQLITE_TESTCTRL_PRNG_SAVE
block|}
block|,
block|{
literal|"prng_restore"
block|,
name|SQLITE_TESTCTRL_PRNG_RESTORE
block|}
block|,
block|{
literal|"prng_reset"
block|,
name|SQLITE_TESTCTRL_PRNG_RESET
block|}
block|,
block|{
literal|"bitvec_test"
block|,
name|SQLITE_TESTCTRL_BITVEC_TEST
block|}
block|,
block|{
literal|"fault_install"
block|,
name|SQLITE_TESTCTRL_FAULT_INSTALL
block|}
block|,
block|{
literal|"benign_malloc_hooks"
block|,
name|SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS
block|}
block|,
block|{
literal|"pending_byte"
block|,
name|SQLITE_TESTCTRL_PENDING_BYTE
block|}
block|,
block|{
literal|"assert"
block|,
name|SQLITE_TESTCTRL_ASSERT
block|}
block|,
block|{
literal|"always"
block|,
name|SQLITE_TESTCTRL_ALWAYS
block|}
block|,
block|{
literal|"reserve"
block|,
name|SQLITE_TESTCTRL_RESERVE
block|}
block|,
block|{
literal|"optimizations"
block|,
name|SQLITE_TESTCTRL_OPTIMIZATIONS
block|}
block|,
block|{
literal|"iskeyword"
block|,
name|SQLITE_TESTCTRL_ISKEYWORD
block|}
block|,
block|{
literal|"scratchmalloc"
block|,
name|SQLITE_TESTCTRL_SCRATCHMALLOC
block|}
block|,
block|{
literal|"byteorder"
block|,
name|SQLITE_TESTCTRL_BYTEORDER
block|}
block|,
block|{
literal|"never_corrupt"
block|,
name|SQLITE_TESTCTRL_NEVER_CORRUPT
block|}
block|,
block|{
literal|"imposter"
block|,
name|SQLITE_TESTCTRL_IMPOSTER
block|}
block|,     }
struct|;
name|int
name|testctrl
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|rc2
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n2
decl_stmt|;
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* convert testctrl text option to value. allow any unique prefix     ** of the option name, or a numerical value. */
name|n2
operator|=
name|strlen30
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|aCtrl
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
name|aCtrl
index|[
name|i
index|]
operator|.
name|zCtrlName
argument_list|,
name|n2
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|testctrl
operator|<
literal|0
condition|)
block|{
name|testctrl
operator|=
name|aCtrl
index|[
name|i
index|]
operator|.
name|ctrlCode
expr_stmt|;
block|}
else|else
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"ambiguous option name: \"%s\"\n"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|testctrl
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|testctrl
operator|<
literal|0
condition|)
name|testctrl
operator|=
operator|(
name|int
operator|)
name|integerValue
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|testctrl
operator|<
name|SQLITE_TESTCTRL_FIRST
operator|)
operator|||
operator|(
name|testctrl
operator|>
name|SQLITE_TESTCTRL_LAST
operator|)
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: invalid testctrl option: %s\n"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|testctrl
condition|)
block|{
comment|/* sqlite3_test_control(int, db, int) */
case|case
name|SQLITE_TESTCTRL_OPTIMIZATIONS
case|:
case|case
name|SQLITE_TESTCTRL_RESERVE
case|:
if|if
condition|(
name|nArg
operator|==
literal|3
condition|)
block|{
name|int
name|opt
init|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|azArg
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rc2
operator|=
name|sqlite3_test_control
argument_list|(
name|testctrl
argument_list|,
name|p
operator|->
name|db
argument_list|,
name|opt
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%d (0x%08x)\n"
argument_list|,
name|rc2
argument_list|,
name|rc2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: testctrl %s takes a single int option\n"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* sqlite3_test_control(int) */
case|case
name|SQLITE_TESTCTRL_PRNG_SAVE
case|:
case|case
name|SQLITE_TESTCTRL_PRNG_RESTORE
case|:
case|case
name|SQLITE_TESTCTRL_PRNG_RESET
case|:
case|case
name|SQLITE_TESTCTRL_BYTEORDER
case|:
if|if
condition|(
name|nArg
operator|==
literal|2
condition|)
block|{
name|rc2
operator|=
name|sqlite3_test_control
argument_list|(
name|testctrl
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%d (0x%08x)\n"
argument_list|,
name|rc2
argument_list|,
name|rc2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: testctrl %s takes no options\n"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* sqlite3_test_control(int, uint) */
case|case
name|SQLITE_TESTCTRL_PENDING_BYTE
case|:
if|if
condition|(
name|nArg
operator|==
literal|3
condition|)
block|{
name|unsigned
name|int
name|opt
init|=
operator|(
name|unsigned
name|int
operator|)
name|integerValue
argument_list|(
name|azArg
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|rc2
operator|=
name|sqlite3_test_control
argument_list|(
name|testctrl
argument_list|,
name|opt
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%d (0x%08x)\n"
argument_list|,
name|rc2
argument_list|,
name|rc2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: testctrl %s takes a single unsigned"
literal|" int option\n"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* sqlite3_test_control(int, int) */
case|case
name|SQLITE_TESTCTRL_ASSERT
case|:
case|case
name|SQLITE_TESTCTRL_ALWAYS
case|:
case|case
name|SQLITE_TESTCTRL_NEVER_CORRUPT
case|:
if|if
condition|(
name|nArg
operator|==
literal|3
condition|)
block|{
name|int
name|opt
init|=
name|booleanValue
argument_list|(
name|azArg
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|rc2
operator|=
name|sqlite3_test_control
argument_list|(
name|testctrl
argument_list|,
name|opt
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%d (0x%08x)\n"
argument_list|,
name|rc2
argument_list|,
name|rc2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: testctrl %s takes a single int option\n"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* sqlite3_test_control(int, char *) */
ifdef|#
directive|ifdef
name|SQLITE_N_KEYWORD
case|case
name|SQLITE_TESTCTRL_ISKEYWORD
case|:
if|if
condition|(
name|nArg
operator|==
literal|3
condition|)
block|{
specifier|const
name|char
modifier|*
name|opt
init|=
name|azArg
index|[
literal|2
index|]
decl_stmt|;
name|rc2
operator|=
name|sqlite3_test_control
argument_list|(
name|testctrl
argument_list|,
name|opt
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%d (0x%08x)\n"
argument_list|,
name|rc2
argument_list|,
name|rc2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: testctrl %s takes a single char * option\n"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
name|SQLITE_TESTCTRL_IMPOSTER
case|:
if|if
condition|(
name|nArg
operator|==
literal|5
condition|)
block|{
name|rc2
operator|=
name|sqlite3_test_control
argument_list|(
name|testctrl
argument_list|,
name|p
operator|->
name|db
argument_list|,
name|azArg
index|[
literal|2
index|]
argument_list|,
name|integerValue
argument_list|(
name|azArg
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|integerValue
argument_list|(
name|azArg
index|[
literal|4
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%d (0x%08x)\n"
argument_list|,
name|rc2
argument_list|,
name|rc2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .testctrl imposter dbName onoff tnum\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SQLITE_TESTCTRL_BITVEC_TEST
case|:
case|case
name|SQLITE_TESTCTRL_FAULT_INSTALL
case|:
case|case
name|SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS
case|:
case|case
name|SQLITE_TESTCTRL_SCRATCHMALLOC
case|:
default|default:
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: CLI support for testctrl %s not implemented\n"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
endif|#
directive|endif
comment|/* !defined(SQLITE_UNTESTABLE) */
if|if
condition|(
name|c
operator|==
literal|'t'
operator|&&
name|n
operator|>
literal|4
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"timeout"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_busy_timeout
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|nArg
operator|>=
literal|2
condition|?
operator|(
name|int
operator|)
name|integerValue
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'t'
operator|&&
name|n
operator|>=
literal|5
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"timer"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|==
literal|2
condition|)
block|{
name|enableTimer
operator|=
name|booleanValue
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|enableTimer
operator|&&
operator|!
name|HAS_TIMER
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: timer not available on this system.\n"
argument_list|)
expr_stmt|;
name|enableTimer
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .timer on|off\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'t'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"trace"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nArg
operator|!=
literal|2
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .trace FILE|off\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
name|output_file_close
argument_list|(
name|p
operator|->
name|traceOut
argument_list|)
expr_stmt|;
name|p
operator|->
name|traceOut
operator|=
name|output_file_open
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SQLITE_OMIT_TRACE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SQLITE_OMIT_FLOATING_POINT
argument_list|)
if|if
condition|(
name|p
operator|->
name|traceOut
operator|==
literal|0
condition|)
block|{
name|sqlite3_trace_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sqlite3_trace_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|SQLITE_TRACE_STMT
argument_list|,
name|sql_trace_callback
argument_list|,
name|p
operator|->
name|traceOut
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
elseif|else
if|#
directive|if
name|SQLITE_USER_AUTHENTICATION
if|if
condition|(
name|c
operator|==
literal|'u'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"user"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|<
literal|2
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .user SUBCOMMAND ...\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"login"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|!=
literal|4
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .user login USER PASSWORD\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
name|rc
operator|=
name|sqlite3_user_authenticate
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|azArg
index|[
literal|2
index|]
argument_list|,
name|azArg
index|[
literal|3
index|]
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|azArg
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Authentication failed for user %s\n"
argument_list|,
name|azArg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"add"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|!=
literal|5
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .user add USER PASSWORD ISADMIN\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
name|rc
operator|=
name|sqlite3_user_add
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|azArg
index|[
literal|2
index|]
argument_list|,
name|azArg
index|[
literal|3
index|]
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|azArg
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|booleanValue
argument_list|(
name|azArg
index|[
literal|4
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"User-Add failed: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"edit"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|!=
literal|5
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .user edit USER PASSWORD ISADMIN\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
name|rc
operator|=
name|sqlite3_user_change
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|azArg
index|[
literal|2
index|]
argument_list|,
name|azArg
index|[
literal|3
index|]
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|azArg
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|booleanValue
argument_list|(
name|azArg
index|[
literal|4
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"User-Edit failed: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"delete"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|!=
literal|3
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .user delete USER\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
name|rc
operator|=
name|sqlite3_user_delete
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|azArg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"User-Delete failed: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .user login|add|edit|delete ...\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
block|}
elseif|else
endif|#
directive|endif
comment|/* SQLITE_USER_AUTHENTICATION */
if|if
condition|(
name|c
operator|==
literal|'v'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"version"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"SQLite %s %s\n"
comment|/*extra-version-info*/
argument_list|,
name|sqlite3_libversion
argument_list|()
argument_list|,
name|sqlite3_sourceid
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'v'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"vfsinfo"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|zDbName
init|=
name|nArg
operator|==
literal|2
condition|?
name|azArg
index|[
literal|1
index|]
else|:
literal|"main"
decl_stmt|;
name|sqlite3_vfs
modifier|*
name|pVfs
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|db
condition|)
block|{
name|sqlite3_file_control
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zDbName
argument_list|,
name|SQLITE_FCNTL_VFS_POINTER
argument_list|,
operator|&
name|pVfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|pVfs
condition|)
block|{
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"vfs.zName      = \"%s\"\n"
argument_list|,
name|pVfs
operator|->
name|zName
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"vfs.iVersion   = %d\n"
argument_list|,
name|pVfs
operator|->
name|iVersion
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"vfs.szOsFile   = %d\n"
argument_list|,
name|pVfs
operator|->
name|szOsFile
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"vfs.mxPathname = %d\n"
argument_list|,
name|pVfs
operator|->
name|mxPathname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'v'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"vfslist"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sqlite3_vfs
modifier|*
name|pVfs
decl_stmt|;
name|sqlite3_vfs
modifier|*
name|pCurrent
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|db
condition|)
block|{
name|sqlite3_file_control
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"main"
argument_list|,
name|SQLITE_FCNTL_VFS_POINTER
argument_list|,
operator|&
name|pCurrent
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|pVfs
operator|=
name|sqlite3_vfs_find
argument_list|(
literal|0
argument_list|)
init|;
name|pVfs
condition|;
name|pVfs
operator|=
name|pVfs
operator|->
name|pNext
control|)
block|{
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"vfs.zName      = \"%s\"%s\n"
argument_list|,
name|pVfs
operator|->
name|zName
argument_list|,
name|pVfs
operator|==
name|pCurrent
condition|?
literal|"<--- CURRENT"
else|:
literal|""
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"vfs.iVersion   = %d\n"
argument_list|,
name|pVfs
operator|->
name|iVersion
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"vfs.szOsFile   = %d\n"
argument_list|,
name|pVfs
operator|->
name|szOsFile
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"vfs.mxPathname = %d\n"
argument_list|,
name|pVfs
operator|->
name|mxPathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|pVfs
operator|->
name|pNext
condition|)
block|{
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"-----------------------------------\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'v'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"vfsname"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|zDbName
init|=
name|nArg
operator|==
literal|2
condition|?
name|azArg
index|[
literal|1
index|]
else|:
literal|"main"
decl_stmt|;
name|char
modifier|*
name|zVfsName
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|db
condition|)
block|{
name|sqlite3_file_control
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zDbName
argument_list|,
name|SQLITE_FCNTL_VFSNAME
argument_list|,
operator|&
name|zVfsName
argument_list|)
expr_stmt|;
if|if
condition|(
name|zVfsName
condition|)
block|{
name|utf8_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s\n"
argument_list|,
name|zVfsName
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zVfsName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|SQLITE_ENABLE_WHERETRACE
argument_list|)
if|if
condition|(
name|c
operator|==
literal|'w'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"wheretrace"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sqlite3WhereTrace
operator|=
name|nArg
operator|>=
literal|2
condition|?
name|booleanValue
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
else|:
literal|0xff
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
literal|'w'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"width"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
name|assert
argument_list|(
name|nArg
operator|<=
name|ArraySize
argument_list|(
name|azArg
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|nArg
operator|&&
name|j
operator|<
name|ArraySize
argument_list|(
name|p
operator|->
name|colWidth
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|p
operator|->
name|colWidth
index|[
name|j
operator|-
literal|1
index|]
operator|=
operator|(
name|int
operator|)
name|integerValue
argument_list|(
name|azArg
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: unknown command or invalid arguments: "
literal|" \"%s\". Enter \".help\" for help\n"
argument_list|,
name|azArg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
name|meta_command_exit
label|:
if|if
condition|(
name|p
operator|->
name|outCount
condition|)
block|{
name|p
operator|->
name|outCount
operator|--
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|outCount
operator|==
literal|0
condition|)
name|output_reset
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* ** Return TRUE if a semicolon occurs anywhere in the first N characters ** of string z[]. */
end_comment

begin_function
specifier|static
name|int
name|line_contains_semicolon
parameter_list|(
specifier|const
name|char
modifier|*
name|z
parameter_list|,
name|int
name|N
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|z
index|[
name|i
index|]
operator|==
literal|';'
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ** Test to see if a line consists entirely of whitespace. */
end_comment

begin_function
specifier|static
name|int
name|_all_whitespace
parameter_list|(
specifier|const
name|char
modifier|*
name|z
parameter_list|)
block|{
for|for
control|(
init|;
operator|*
name|z
condition|;
name|z
operator|++
control|)
block|{
if|if
condition|(
name|IsSpace
argument_list|(
name|z
index|[
literal|0
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|*
name|z
operator|==
literal|'/'
operator|&&
name|z
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
name|z
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|z
operator|&&
operator|(
operator|*
name|z
operator|!=
literal|'*'
operator|||
name|z
index|[
literal|1
index|]
operator|!=
literal|'/'
operator|)
condition|)
block|{
name|z
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|z
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|z
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|z
operator|==
literal|'-'
operator|&&
name|z
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
name|z
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|z
operator|&&
operator|*
name|z
operator|!=
literal|'\n'
condition|)
block|{
name|z
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|z
operator|==
literal|0
condition|)
return|return
literal|1
return|;
continue|continue;
block|}
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ** Return TRUE if the line typed in is an SQL command terminator other ** than a semi-colon.  The SQL Server style "go" command is understood ** as is the Oracle "/". */
end_comment

begin_function
specifier|static
name|int
name|line_is_command_terminator
parameter_list|(
specifier|const
name|char
modifier|*
name|zLine
parameter_list|)
block|{
while|while
condition|(
name|IsSpace
argument_list|(
name|zLine
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|zLine
operator|++
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|zLine
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|_all_whitespace
argument_list|(
operator|&
name|zLine
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
comment|/* Oracle */
block|}
if|if
condition|(
name|ToLower
argument_list|(
name|zLine
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'g'
operator|&&
name|ToLower
argument_list|(
name|zLine
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'o'
operator|&&
name|_all_whitespace
argument_list|(
operator|&
name|zLine
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
comment|/* SQL Server */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ** Return true if zSql is a complete SQL statement.  Return false if it ** ends in the middle of a string literal or C-style comment. */
end_comment

begin_function
specifier|static
name|int
name|line_is_complete
parameter_list|(
name|char
modifier|*
name|zSql
parameter_list|,
name|int
name|nSql
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|zSql
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|zSql
index|[
name|nSql
index|]
operator|=
literal|';'
expr_stmt|;
name|zSql
index|[
name|nSql
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|sqlite3_complete
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
name|zSql
index|[
name|nSql
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* ** Run a single line of SQL */
end_comment

begin_function
specifier|static
name|int
name|runOneSqlLine
parameter_list|(
name|ShellState
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|zSql
parameter_list|,
name|FILE
modifier|*
name|in
parameter_list|,
name|int
name|startline
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|char
modifier|*
name|zErrMsg
init|=
literal|0
decl_stmt|;
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ShellHasFlag
argument_list|(
name|p
argument_list|,
name|SHFLG_Backslash
argument_list|)
condition|)
name|resolve_backslashes
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
name|BEGIN_TIMER
expr_stmt|;
name|rc
operator|=
name|shell_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zSql
argument_list|,
name|shell_callback
argument_list|,
name|p
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
name|END_TIMER
expr_stmt|;
if|if
condition|(
name|rc
operator|||
name|zErrMsg
condition|)
block|{
name|char
name|zPrefix
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|in
operator|!=
literal|0
operator|||
operator|!
name|stdin_is_interactive
condition|)
block|{
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|zPrefix
argument_list|)
argument_list|,
name|zPrefix
argument_list|,
literal|"Error: near line %d:"
argument_list|,
name|startline
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|zPrefix
argument_list|)
argument_list|,
name|zPrefix
argument_list|,
literal|"Error:"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zErrMsg
operator|!=
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"%s %s\n"
argument_list|,
name|zPrefix
argument_list|,
name|zErrMsg
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zErrMsg
argument_list|)
expr_stmt|;
name|zErrMsg
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"%s %s\n"
argument_list|,
name|zPrefix
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|ShellHasFlag
argument_list|(
name|p
argument_list|,
name|SHFLG_CountChanges
argument_list|)
condition|)
block|{
name|raw_printf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"changes: %3d   total_changes: %d\n"
argument_list|,
name|sqlite3_changes
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|,
name|sqlite3_total_changes
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ** Read input from *in and process it.  If *in==0 then input ** is interactive - the user is typing it it.  Otherwise, input ** is coming from a file or device.  A prompt is issued and history ** is saved only if input is interactive.  An interrupt signal will ** cause this routine to exit immediately, unless input is interactive. ** ** Return the number of errors. */
end_comment

begin_function
specifier|static
name|int
name|process_input
parameter_list|(
name|ShellState
modifier|*
name|p
parameter_list|,
name|FILE
modifier|*
name|in
parameter_list|)
block|{
name|char
modifier|*
name|zLine
init|=
literal|0
decl_stmt|;
comment|/* A single input line */
name|char
modifier|*
name|zSql
init|=
literal|0
decl_stmt|;
comment|/* Accumulated SQL text */
name|int
name|nLine
decl_stmt|;
comment|/* Length of current line */
name|int
name|nSql
init|=
literal|0
decl_stmt|;
comment|/* Bytes of zSql[] used */
name|int
name|nAlloc
init|=
literal|0
decl_stmt|;
comment|/* Allocated zSql[] space */
name|int
name|nSqlPrior
init|=
literal|0
decl_stmt|;
comment|/* Bytes of zSql[] used by prior line */
name|int
name|rc
decl_stmt|;
comment|/* Error code */
name|int
name|errCnt
init|=
literal|0
decl_stmt|;
comment|/* Number of errors seen */
name|int
name|lineno
init|=
literal|0
decl_stmt|;
comment|/* Current line number */
name|int
name|startline
init|=
literal|0
decl_stmt|;
comment|/* Line number for start of current input */
while|while
condition|(
name|errCnt
operator|==
literal|0
operator|||
operator|!
name|bail_on_error
operator|||
operator|(
name|in
operator|==
literal|0
operator|&&
name|stdin_is_interactive
operator|)
condition|)
block|{
name|fflush
argument_list|(
name|p
operator|->
name|out
argument_list|)
expr_stmt|;
name|zLine
operator|=
name|one_input_line
argument_list|(
name|in
argument_list|,
name|zLine
argument_list|,
name|nSql
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zLine
operator|==
literal|0
condition|)
block|{
comment|/* End of input */
if|if
condition|(
name|in
operator|==
literal|0
operator|&&
name|stdin_is_interactive
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|seenInterrupt
condition|)
block|{
if|if
condition|(
name|in
operator|!=
literal|0
condition|)
break|break;
name|seenInterrupt
operator|=
literal|0
expr_stmt|;
block|}
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|nSql
operator|==
literal|0
operator|&&
name|_all_whitespace
argument_list|(
name|zLine
argument_list|)
condition|)
block|{
if|if
condition|(
name|ShellHasFlag
argument_list|(
name|p
argument_list|,
name|SHFLG_Echo
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|zLine
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|zLine
operator|&&
name|zLine
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|nSql
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ShellHasFlag
argument_list|(
name|p
argument_list|,
name|SHFLG_Echo
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|zLine
argument_list|)
expr_stmt|;
name|rc
operator|=
name|do_meta_command
argument_list|(
name|zLine
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|2
condition|)
block|{
comment|/* exit requested */
break|break;
block|}
elseif|else
if|if
condition|(
name|rc
condition|)
block|{
name|errCnt
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|line_is_command_terminator
argument_list|(
name|zLine
argument_list|)
operator|&&
name|line_is_complete
argument_list|(
name|zSql
argument_list|,
name|nSql
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|zLine
argument_list|,
literal|";"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|nLine
operator|=
name|strlen30
argument_list|(
name|zLine
argument_list|)
expr_stmt|;
if|if
condition|(
name|nSql
operator|+
name|nLine
operator|+
literal|2
operator|>=
name|nAlloc
condition|)
block|{
name|nAlloc
operator|=
name|nSql
operator|+
name|nLine
operator|+
literal|100
expr_stmt|;
name|zSql
operator|=
name|realloc
argument_list|(
name|zSql
argument_list|,
name|nAlloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|zSql
operator|==
literal|0
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|nSqlPrior
operator|=
name|nSql
expr_stmt|;
if|if
condition|(
name|nSql
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|zLine
index|[
name|i
index|]
operator|&&
name|IsSpace
argument_list|(
name|zLine
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{}
name|assert
argument_list|(
name|nAlloc
operator|>
literal|0
operator|&&
name|zSql
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|zSql
argument_list|,
name|zLine
operator|+
name|i
argument_list|,
name|nLine
operator|+
literal|1
operator|-
name|i
argument_list|)
expr_stmt|;
name|startline
operator|=
name|lineno
expr_stmt|;
name|nSql
operator|=
name|nLine
operator|-
name|i
expr_stmt|;
block|}
else|else
block|{
name|zSql
index|[
name|nSql
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|memcpy
argument_list|(
name|zSql
operator|+
name|nSql
argument_list|,
name|zLine
argument_list|,
name|nLine
operator|+
literal|1
argument_list|)
expr_stmt|;
name|nSql
operator|+=
name|nLine
expr_stmt|;
block|}
if|if
condition|(
name|nSql
operator|&&
name|line_contains_semicolon
argument_list|(
operator|&
name|zSql
index|[
name|nSqlPrior
index|]
argument_list|,
name|nSql
operator|-
name|nSqlPrior
argument_list|)
operator|&&
name|sqlite3_complete
argument_list|(
name|zSql
argument_list|)
condition|)
block|{
name|errCnt
operator|+=
name|runOneSqlLine
argument_list|(
name|p
argument_list|,
name|zSql
argument_list|,
name|in
argument_list|,
name|startline
argument_list|)
expr_stmt|;
name|nSql
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|outCount
condition|)
block|{
name|output_reset
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|outCount
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nSql
operator|&&
name|_all_whitespace
argument_list|(
name|zSql
argument_list|)
condition|)
block|{
if|if
condition|(
name|ShellHasFlag
argument_list|(
name|p
argument_list|,
name|SHFLG_Echo
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|zSql
argument_list|)
expr_stmt|;
name|nSql
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nSql
operator|&&
operator|!
name|_all_whitespace
argument_list|(
name|zSql
argument_list|)
condition|)
block|{
name|runOneSqlLine
argument_list|(
name|p
argument_list|,
name|zSql
argument_list|,
name|in
argument_list|,
name|startline
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zLine
argument_list|)
expr_stmt|;
return|return
name|errCnt
operator|>
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ** Return a pathname which is the user's home directory.  A ** 0 return indicates an error of some kind. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|find_home_dir
parameter_list|(
name|int
name|clearFlag
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|home_dir
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|clearFlag
condition|)
block|{
name|free
argument_list|(
name|home_dir
argument_list|)
expr_stmt|;
name|home_dir
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|home_dir
condition|)
return|return
name|home_dir
return|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_WIN32_WCE
argument_list|)
expr|\
operator|&&
operator|!
name|defined
argument_list|(
name|__RTP__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_WRS_KERNEL
argument_list|)
block|{
name|struct
name|passwd
modifier|*
name|pwent
decl_stmt|;
name|uid_t
name|uid
init|=
name|getuid
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|pwent
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|home_dir
operator|=
name|pwent
operator|->
name|pw_dir
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|_WIN32_WCE
argument_list|)
comment|/* Windows CE (arm-wince-mingw32ce-gcc) does not provide getenv()    */
name|home_dir
operator|=
literal|"/"
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
if|if
condition|(
operator|!
name|home_dir
condition|)
block|{
name|home_dir
operator|=
name|getenv
argument_list|(
literal|"USERPROFILE"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|home_dir
condition|)
block|{
name|home_dir
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
if|if
condition|(
operator|!
name|home_dir
condition|)
block|{
name|char
modifier|*
name|zDrive
decl_stmt|,
modifier|*
name|zPath
decl_stmt|;
name|int
name|n
decl_stmt|;
name|zDrive
operator|=
name|getenv
argument_list|(
literal|"HOMEDRIVE"
argument_list|)
expr_stmt|;
name|zPath
operator|=
name|getenv
argument_list|(
literal|"HOMEPATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zDrive
operator|&&
name|zPath
condition|)
block|{
name|n
operator|=
name|strlen30
argument_list|(
name|zDrive
argument_list|)
operator|+
name|strlen30
argument_list|(
name|zPath
argument_list|)
operator|+
literal|1
expr_stmt|;
name|home_dir
operator|=
name|malloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|home_dir
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|sqlite3_snprintf
argument_list|(
name|n
argument_list|,
name|home_dir
argument_list|,
literal|"%s%s"
argument_list|,
name|zDrive
argument_list|,
name|zPath
argument_list|)
expr_stmt|;
return|return
name|home_dir
return|;
block|}
name|home_dir
operator|=
literal|"c:\\"
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* !_WIN32_WCE */
if|if
condition|(
name|home_dir
condition|)
block|{
name|int
name|n
init|=
name|strlen30
argument_list|(
name|home_dir
argument_list|)
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|z
init|=
name|malloc
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|z
condition|)
name|memcpy
argument_list|(
name|z
argument_list|,
name|home_dir
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|home_dir
operator|=
name|z
expr_stmt|;
block|}
return|return
name|home_dir
return|;
block|}
end_function

begin_comment
comment|/* ** Read input from the file given by sqliterc_override.  Or if that ** parameter is NULL, take input from ~/.sqliterc ** ** Returns the number of errors. */
end_comment

begin_function
specifier|static
name|void
name|process_sqliterc
parameter_list|(
name|ShellState
modifier|*
name|p
parameter_list|,
comment|/* Configuration data */
specifier|const
name|char
modifier|*
name|sqliterc_override
comment|/* Name of config file. NULL to use default */
parameter_list|)
block|{
name|char
modifier|*
name|home_dir
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|sqliterc
init|=
name|sqliterc_override
decl_stmt|;
name|char
modifier|*
name|zBuf
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|in
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|sqliterc
operator|==
name|NULL
condition|)
block|{
name|home_dir
operator|=
name|find_home_dir
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|home_dir
operator|==
literal|0
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"-- warning: cannot find home directory;"
literal|" cannot read ~/.sqliterc\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sqlite3_initialize
argument_list|()
expr_stmt|;
name|zBuf
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"%s/.sqliterc"
argument_list|,
name|home_dir
argument_list|)
expr_stmt|;
name|sqliterc
operator|=
name|zBuf
expr_stmt|;
block|}
name|in
operator|=
name|fopen
argument_list|(
name|sqliterc
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
condition|)
block|{
if|if
condition|(
name|stdin_is_interactive
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"-- Loading resources from %s\n"
argument_list|,
name|sqliterc
argument_list|)
expr_stmt|;
block|}
name|process_input
argument_list|(
name|p
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
name|sqlite3_free
argument_list|(
name|zBuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Show available command line options */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|zOptions
index|[]
init|=
literal|"   -ascii               set output mode to 'ascii'\n"
literal|"   -bail                stop after hitting an error\n"
literal|"   -batch               force batch I/O\n"
literal|"   -column              set output mode to 'column'\n"
literal|"   -cmd COMMAND         run \"COMMAND\" before reading stdin\n"
literal|"   -csv                 set output mode to 'csv'\n"
literal|"   -echo                print commands before execution\n"
literal|"   -init FILENAME       read/process named file\n"
literal|"   -[no]header          turn headers on or off\n"
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_ENABLE_MEMSYS3
argument_list|)
operator|||
name|defined
argument_list|(
name|SQLITE_ENABLE_MEMSYS5
argument_list|)
literal|"   -heap SIZE           Size of heap for memsys3 or memsys5\n"
endif|#
directive|endif
literal|"   -help                show this message\n"
literal|"   -html                set output mode to HTML\n"
literal|"   -interactive         force interactive I/O\n"
literal|"   -line                set output mode to 'line'\n"
literal|"   -list                set output mode to 'list'\n"
literal|"   -lookaside SIZE N    use N entries of SZ bytes for lookaside memory\n"
literal|"   -mmap N              default mmap size set to N\n"
ifdef|#
directive|ifdef
name|SQLITE_ENABLE_MULTIPLEX
literal|"   -multiplex           enable the multiplexor VFS\n"
endif|#
directive|endif
literal|"   -newline SEP         set output row separator. Default: '\\n'\n"
literal|"   -nullvalue TEXT      set text string for NULL values. Default ''\n"
literal|"   -pagecache SIZE N    use N slots of SZ bytes each for page cache memory\n"
literal|"   -quote               set output mode to 'quote'\n"
literal|"   -scratch SIZE N      use N slots of SZ bytes each for scratch memory\n"
literal|"   -separator SEP       set output column separator. Default: '|'\n"
literal|"   -stats               print memory stats before each finalize\n"
literal|"   -version             show SQLite version\n"
literal|"   -vfs NAME            use NAME as the default VFS\n"
ifdef|#
directive|ifdef
name|SQLITE_ENABLE_VFSTRACE
literal|"   -vfstrace            enable tracing of all VFS calls\n"
endif|#
directive|endif
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|int
name|showDetail
parameter_list|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [OPTIONS] FILENAME [SQL]\n"
literal|"FILENAME is the name of an SQLite database. A new database is created\n"
literal|"if the file does not previously exist.\n"
argument_list|,
name|Argv0
argument_list|)
expr_stmt|;
if|if
condition|(
name|showDetail
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"OPTIONS include:\n%s"
argument_list|,
name|zOptions
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Use the -help option for additional information\n"
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Initialize the state information in data */
end_comment

begin_function
specifier|static
name|void
name|main_init
parameter_list|(
name|ShellState
modifier|*
name|data
parameter_list|)
block|{
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|normalMode
operator|=
name|data
operator|->
name|cMode
operator|=
name|data
operator|->
name|mode
operator|=
name|MODE_List
expr_stmt|;
name|data
operator|->
name|autoExplain
operator|=
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|data
operator|->
name|colSeparator
argument_list|,
name|SEP_Column
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data
operator|->
name|rowSeparator
argument_list|,
name|SEP_Row
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|data
operator|->
name|showHeader
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|shellFlgs
operator|=
name|SHFLG_Lookaside
expr_stmt|;
name|sqlite3_config
argument_list|(
name|SQLITE_CONFIG_URI
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sqlite3_config
argument_list|(
name|SQLITE_CONFIG_LOG
argument_list|,
name|shellLog
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|sqlite3_config
argument_list|(
name|SQLITE_CONFIG_MULTITHREAD
argument_list|)
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|mainPrompt
argument_list|)
argument_list|,
name|mainPrompt
argument_list|,
literal|"sqlite> "
argument_list|)
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|continuePrompt
argument_list|)
argument_list|,
name|continuePrompt
argument_list|,
literal|"   ...> "
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Output text to the console in a font that attracts extra attention. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_function
specifier|static
name|void
name|printBold
parameter_list|(
specifier|const
name|char
modifier|*
name|zText
parameter_list|)
block|{
name|HANDLE
name|out
init|=
name|GetStdHandle
argument_list|(
name|STD_OUTPUT_HANDLE
argument_list|)
decl_stmt|;
name|CONSOLE_SCREEN_BUFFER_INFO
name|defaultScreenInfo
decl_stmt|;
name|GetConsoleScreenBufferInfo
argument_list|(
name|out
argument_list|,
operator|&
name|defaultScreenInfo
argument_list|)
expr_stmt|;
name|SetConsoleTextAttribute
argument_list|(
name|out
argument_list|,
name|FOREGROUND_RED
operator||
name|FOREGROUND_INTENSITY
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|zText
argument_list|)
expr_stmt|;
name|SetConsoleTextAttribute
argument_list|(
name|out
argument_list|,
name|defaultScreenInfo
operator|.
name|wAttributes
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|printBold
parameter_list|(
specifier|const
name|char
modifier|*
name|zText
parameter_list|)
block|{
name|printf
argument_list|(
literal|"\033[1m%s\033[0m"
argument_list|,
name|zText
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** Get the argument to an --option.  Throw an error and die if no argument ** is available. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|cmdline_option_value
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
operator|==
name|argc
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Error: missing argument to %s\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|argv
index|[
name|i
index|]
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SQLITE_SHELL_IS_UTF8
end_ifndef

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if

begin_define
define|#
directive|define
name|SQLITE_SHELL_IS_UTF8
value|(0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SQLITE_SHELL_IS_UTF8
value|(1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|SQLITE_SHELL_IS_UTF8
end_if

begin_function
name|int
name|SQLITE_CDECL
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
else|#
directive|else
name|int
name|SQLITE_CDECL
name|wmain
parameter_list|(
name|int
name|argc
parameter_list|,
name|wchar_t
modifier|*
modifier|*
name|wargv
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|zErrMsg
init|=
literal|0
decl_stmt|;
name|ShellState
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|zInitFile
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|int
name|warnInmemoryDb
init|=
literal|0
decl_stmt|;
name|int
name|readStdin
init|=
literal|1
decl_stmt|;
name|int
name|nCmd
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|azCmd
init|=
literal|0
decl_stmt|;
name|setBinaryMode
argument_list|(
name|stdin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setvbuf
argument_list|(
name|stderr
argument_list|,
literal|0
argument_list|,
name|_IONBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make sure stderr is unbuffered */
name|stdin_is_interactive
operator|=
name|isatty
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|stdout_is_console
operator|=
name|isatty
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_SYSTEM_SQLITE
operator|+
literal|0
operator|!=
literal|1
if|if
condition|(
name|strcmp
argument_list|(
name|sqlite3_sourceid
argument_list|()
argument_list|,
name|SQLITE_SOURCE_ID
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"SQLite header and source version mismatch\n%s\n%s\n"
argument_list|,
name|sqlite3_sourceid
argument_list|()
argument_list|,
name|SQLITE_SOURCE_ID
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|main_init
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|SQLITE_SHELL_IS_UTF8
name|sqlite3_initialize
argument_list|()
expr_stmt|;
name|argv
operator|=
name|sqlite3_malloc64
argument_list|(
sizeof|sizeof
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|*
name|argc
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
operator|==
literal|0
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|argv
index|[
name|i
index|]
operator|=
name|sqlite3_win32_unicode_to_utf8
argument_list|(
name|wargv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|assert
argument_list|(
name|argc
operator|>=
literal|1
operator|&&
name|argv
operator|&&
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|Argv0
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* Make sure we have a valid signal handler early, before anything   ** else is done.   */
ifdef|#
directive|ifdef
name|SIGINT
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|interrupt_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SQLITE_SHELL_DBNAME_PROC
block|{
comment|/* If the SQLITE_SHELL_DBNAME_PROC macro is defined, then it is the name     ** of a C-function that will provide the name of the database file.  Use     ** this compile-time option to embed this shell program in larger     ** applications. */
specifier|extern
name|void
name|SQLITE_SHELL_DBNAME_PROC
argument_list|(
specifier|const
name|char
operator|*
operator|*
argument_list|)
decl_stmt|;
name|SQLITE_SHELL_DBNAME_PROC
argument_list|(
operator|&
name|data
operator|.
name|zDbFilename
argument_list|)
expr_stmt|;
name|warnInmemoryDb
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Do an initial pass through the command-line argument to locate   ** the name of the database file, the name of the initialization file,   ** the size of the alternative malloc heap,   ** and the first command to execute.   */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|z
decl_stmt|;
name|z
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|z
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
if|if
condition|(
name|data
operator|.
name|zDbFilename
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|zDbFilename
operator|=
name|z
expr_stmt|;
block|}
else|else
block|{
comment|/* Excesss arguments are interpreted as SQL (or dot-commands) and         ** mean that nothing is read from stdin */
name|readStdin
operator|=
literal|0
expr_stmt|;
name|nCmd
operator|++
expr_stmt|;
name|azCmd
operator|=
name|realloc
argument_list|(
name|azCmd
argument_list|,
sizeof|sizeof
argument_list|(
name|azCmd
index|[
literal|0
index|]
argument_list|)
operator|*
name|nCmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|azCmd
operator|==
literal|0
condition|)
block|{
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|azCmd
index|[
name|nCmd
operator|-
literal|1
index|]
operator|=
name|z
expr_stmt|;
block|}
block|}
if|if
condition|(
name|z
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
name|z
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-separator"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-nullvalue"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-newline"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-cmd"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|cmdline_option_value
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|++
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-init"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zInitFile
operator|=
name|cmdline_option_value
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|++
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-batch"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Need to check for batch mode here to so we can avoid printing       ** informational messages (like from process_sqliterc) before       ** we do the actual processing of arguments later in a second pass.       */
name|stdin_is_interactive
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-heap"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_ENABLE_MEMSYS3
argument_list|)
operator|||
name|defined
argument_list|(
name|SQLITE_ENABLE_MEMSYS5
argument_list|)
specifier|const
name|char
modifier|*
name|zSize
decl_stmt|;
name|sqlite3_int64
name|szHeap
decl_stmt|;
name|zSize
operator|=
name|cmdline_option_value
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|++
name|i
argument_list|)
expr_stmt|;
name|szHeap
operator|=
name|integerValue
argument_list|(
name|zSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|szHeap
operator|>
literal|0x7fff0000
condition|)
name|szHeap
operator|=
literal|0x7fff0000
expr_stmt|;
name|sqlite3_config
argument_list|(
name|SQLITE_CONFIG_HEAP
argument_list|,
name|malloc
argument_list|(
operator|(
name|int
operator|)
name|szHeap
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|szHeap
argument_list|,
literal|64
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|cmdline_option_value
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|++
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-scratch"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|n
decl_stmt|,
name|sz
decl_stmt|;
name|sz
operator|=
operator|(
name|int
operator|)
name|integerValue
argument_list|(
name|cmdline_option_value
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|++
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|>
literal|400000
condition|)
name|sz
operator|=
literal|400000
expr_stmt|;
if|if
condition|(
name|sz
operator|<
literal|2500
condition|)
name|sz
operator|=
literal|2500
expr_stmt|;
name|n
operator|=
operator|(
name|int
operator|)
name|integerValue
argument_list|(
name|cmdline_option_value
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|++
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|10
condition|)
name|n
operator|=
literal|10
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|sqlite3_config
argument_list|(
name|SQLITE_CONFIG_SCRATCH
argument_list|,
name|malloc
argument_list|(
name|n
operator|*
name|sz
operator|+
literal|1
argument_list|)
argument_list|,
name|sz
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|data
operator|.
name|shellFlgs
operator||=
name|SHFLG_Scratch
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-pagecache"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|n
decl_stmt|,
name|sz
decl_stmt|;
name|sz
operator|=
operator|(
name|int
operator|)
name|integerValue
argument_list|(
name|cmdline_option_value
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|++
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|>
literal|70000
condition|)
name|sz
operator|=
literal|70000
expr_stmt|;
if|if
condition|(
name|sz
operator|<
literal|0
condition|)
name|sz
operator|=
literal|0
expr_stmt|;
name|n
operator|=
operator|(
name|int
operator|)
name|integerValue
argument_list|(
name|cmdline_option_value
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|++
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|sqlite3_config
argument_list|(
name|SQLITE_CONFIG_PAGECACHE
argument_list|,
operator|(
name|n
operator|>
literal|0
operator|&&
name|sz
operator|>
literal|0
operator|)
condition|?
name|malloc
argument_list|(
name|n
operator|*
name|sz
argument_list|)
else|:
literal|0
argument_list|,
name|sz
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|data
operator|.
name|shellFlgs
operator||=
name|SHFLG_Pagecache
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-lookaside"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|n
decl_stmt|,
name|sz
decl_stmt|;
name|sz
operator|=
operator|(
name|int
operator|)
name|integerValue
argument_list|(
name|cmdline_option_value
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|++
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|<
literal|0
condition|)
name|sz
operator|=
literal|0
expr_stmt|;
name|n
operator|=
operator|(
name|int
operator|)
name|integerValue
argument_list|(
name|cmdline_option_value
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|++
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|n
operator|=
literal|0
expr_stmt|;
name|sqlite3_config
argument_list|(
name|SQLITE_CONFIG_LOOKASIDE
argument_list|,
name|sz
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|*
name|n
operator|==
literal|0
condition|)
name|data
operator|.
name|shellFlgs
operator|&=
operator|~
name|SHFLG_Lookaside
expr_stmt|;
ifdef|#
directive|ifdef
name|SQLITE_ENABLE_VFSTRACE
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-vfstrace"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|extern
name|int
name|vfstrace_register
argument_list|(
specifier|const
name|char
operator|*
name|zTraceName
argument_list|,
specifier|const
name|char
operator|*
name|zOldVfsName
argument_list|,
name|int
argument_list|(
operator|*
name|xOut
argument_list|)
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|void
operator|*
name|pOutArg
argument_list|,
name|int
name|makeDefault
argument_list|)
decl_stmt|;
name|vfstrace_register
argument_list|(
literal|"trace"
argument_list|,
literal|0
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
name|void
operator|*
argument_list|)
operator|)
name|fputs
argument_list|,
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SQLITE_ENABLE_MULTIPLEX
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-multiplex"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|extern
name|int
name|sqlite3_multiple_initialize
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
name|int
argument_list|)
decl_stmt|;
name|sqlite3_multiplex_initialize
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-mmap"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sqlite3_int64
name|sz
init|=
name|integerValue
argument_list|(
name|cmdline_option_value
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|++
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|sqlite3_config
argument_list|(
name|SQLITE_CONFIG_MMAP_SIZE
argument_list|,
name|sz
argument_list|,
name|sz
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-vfs"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sqlite3_vfs
modifier|*
name|pVfs
init|=
name|sqlite3_vfs_find
argument_list|(
name|cmdline_option_value
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|++
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pVfs
condition|)
block|{
name|sqlite3_vfs_register
argument_list|(
name|pVfs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"no such VFS: \"%s\"\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|data
operator|.
name|zDbFilename
operator|==
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|SQLITE_OMIT_MEMORYDB
name|data
operator|.
name|zDbFilename
operator|=
literal|":memory:"
expr_stmt|;
name|warnInmemoryDb
operator|=
name|argc
operator|==
literal|1
expr_stmt|;
else|#
directive|else
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Error: no database filename specified\n"
argument_list|,
name|Argv0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
block|}
name|data
operator|.
name|out
operator|=
name|stdout
expr_stmt|;
comment|/* Go ahead and open the database file if it already exists.  If the   ** file does not exist, delay opening it.  This prevents empty database   ** files from being created if a user mistypes the database name argument   ** to the sqlite command-line tool.   */
if|if
condition|(
name|access
argument_list|(
name|data
operator|.
name|zDbFilename
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|open_db
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Process the initialization file if there is one.  If no -init option   ** is given on the command line, look for a file named ~/.sqliterc and   ** try to process it.   */
name|process_sqliterc
argument_list|(
operator|&
name|data
argument_list|,
name|zInitFile
argument_list|)
expr_stmt|;
comment|/* Make a second pass through the command-line argument and set   ** options.  This second pass is delayed until after the initialization   ** file is processed so that the command-line arguments will override   ** settings in the initialization file.   */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|z
init|=
name|argv
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|z
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
continue|continue;
if|if
condition|(
name|z
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
name|z
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-init"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-html"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|mode
operator|=
name|MODE_Html
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-list"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|mode
operator|=
name|MODE_List
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-quote"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|mode
operator|=
name|MODE_Quote
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-line"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|mode
operator|=
name|MODE_Line
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-column"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|mode
operator|=
name|MODE_Column
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-csv"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|mode
operator|=
name|MODE_Csv
expr_stmt|;
name|memcpy
argument_list|(
name|data
operator|.
name|colSeparator
argument_list|,
literal|","
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-ascii"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|mode
operator|=
name|MODE_Ascii
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|data
operator|.
name|colSeparator
argument_list|)
argument_list|,
name|data
operator|.
name|colSeparator
argument_list|,
name|SEP_Unit
argument_list|)
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|data
operator|.
name|rowSeparator
argument_list|)
argument_list|,
name|data
operator|.
name|rowSeparator
argument_list|,
name|SEP_Record
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-separator"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|data
operator|.
name|colSeparator
argument_list|)
argument_list|,
name|data
operator|.
name|colSeparator
argument_list|,
literal|"%s"
argument_list|,
name|cmdline_option_value
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|++
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-newline"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|data
operator|.
name|rowSeparator
argument_list|)
argument_list|,
name|data
operator|.
name|rowSeparator
argument_list|,
literal|"%s"
argument_list|,
name|cmdline_option_value
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|++
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-nullvalue"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|data
operator|.
name|nullValue
argument_list|)
argument_list|,
name|data
operator|.
name|nullValue
argument_list|,
literal|"%s"
argument_list|,
name|cmdline_option_value
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|++
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-header"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|showHeader
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-noheader"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|showHeader
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-echo"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ShellSetFlag
argument_list|(
operator|&
name|data
argument_list|,
name|SHFLG_Echo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-eqp"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|autoEQP
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-eqpfull"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|autoEQP
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-stats"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|statsOn
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-scanstats"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|scanstatsOn
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-backslash"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Undocumented command-line option: -backslash       ** Causes C-style backslash escapes to be evaluated in SQL statements       ** prior to sending the SQL into SQLite.  Useful for injecting       ** crazy bytes in the middle of SQL statements for testing and debugging.       */
name|ShellSetFlag
argument_list|(
operator|&
name|data
argument_list|,
name|SHFLG_Backslash
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-bail"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bail_on_error
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-version"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s %s\n"
argument_list|,
name|sqlite3_libversion
argument_list|()
argument_list|,
name|sqlite3_sourceid
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-interactive"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|stdin_is_interactive
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-batch"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|stdin_is_interactive
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-heap"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-scratch"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-pagecache"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-lookaside"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-mmap"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-vfs"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SQLITE_ENABLE_VFSTRACE
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-vfstrace"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SQLITE_ENABLE_MULTIPLEX
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-multiplex"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-help"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|usage
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-cmd"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Run commands that follow -cmd first and separately from commands       ** that simply appear on the command-line.  This seems goofy.  It would       ** be better if all commands ran in the order that they appear.  But       ** we retain the goofy behavior for historical compatibility. */
if|if
condition|(
name|i
operator|==
name|argc
operator|-
literal|1
condition|)
break|break;
name|z
operator|=
name|cmdline_option_value
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|++
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
name|rc
operator|=
name|do_meta_command
argument_list|(
name|z
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|&&
name|bail_on_error
condition|)
return|return
name|rc
operator|==
literal|2
condition|?
literal|0
else|:
name|rc
return|;
block|}
else|else
block|{
name|open_db
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|shell_exec
argument_list|(
name|data
operator|.
name|db
argument_list|,
name|z
argument_list|,
name|shell_callback
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|zErrMsg
operator|!=
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|zErrMsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|bail_on_error
condition|)
return|return
name|rc
operator|!=
literal|0
condition|?
name|rc
else|:
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: unable to process SQL \"%s\"\n"
argument_list|,
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|bail_on_error
condition|)
return|return
name|rc
return|;
block|}
block|}
block|}
else|else
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Error: unknown option: %s\n"
argument_list|,
name|Argv0
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|raw_printf
argument_list|(
name|stderr
argument_list|,
literal|"Use -help for a list of options.\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|data
operator|.
name|cMode
operator|=
name|data
operator|.
name|mode
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|readStdin
condition|)
block|{
comment|/* Run all arguments that do not begin with '-' as if they were separate     ** command-line inputs, except for the argToSkip argument which contains     ** the database filename.     */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nCmd
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|azCmd
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
name|rc
operator|=
name|do_meta_command
argument_list|(
name|azCmd
index|[
name|i
index|]
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
operator|==
literal|2
condition|?
literal|0
else|:
name|rc
return|;
block|}
else|else
block|{
name|open_db
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|shell_exec
argument_list|(
name|data
operator|.
name|db
argument_list|,
name|azCmd
index|[
name|i
index|]
argument_list|,
name|shell_callback
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|zErrMsg
operator|!=
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|zErrMsg
argument_list|)
expr_stmt|;
return|return
name|rc
operator|!=
literal|0
condition|?
name|rc
else|:
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|utf8_printf
argument_list|(
name|stderr
argument_list|,
literal|"Error: unable to process SQL: %s\n"
argument_list|,
name|azCmd
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
block|}
block|}
name|free
argument_list|(
name|azCmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Run commands received from standard input     */
if|if
condition|(
name|stdin_is_interactive
condition|)
block|{
name|char
modifier|*
name|zHome
decl_stmt|;
name|char
modifier|*
name|zHistory
init|=
literal|0
decl_stmt|;
name|int
name|nHistory
decl_stmt|;
name|printf
argument_list|(
literal|"SQLite version %s %.19s\n"
comment|/*extra-version-info*/
literal|"Enter \".help\" for usage hints.\n"
argument_list|,
name|sqlite3_libversion
argument_list|()
argument_list|,
name|sqlite3_sourceid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|warnInmemoryDb
condition|)
block|{
name|printf
argument_list|(
literal|"Connected to a "
argument_list|)
expr_stmt|;
name|printBold
argument_list|(
literal|"transient in-memory database"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\nUse \".open FILENAME\" to reopen on a "
literal|"persistent database.\n"
argument_list|)
expr_stmt|;
block|}
name|zHome
operator|=
name|find_home_dir
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zHome
condition|)
block|{
name|nHistory
operator|=
name|strlen30
argument_list|(
name|zHome
argument_list|)
operator|+
literal|20
expr_stmt|;
if|if
condition|(
operator|(
name|zHistory
operator|=
name|malloc
argument_list|(
name|nHistory
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|sqlite3_snprintf
argument_list|(
name|nHistory
argument_list|,
name|zHistory
argument_list|,
literal|"%s/.sqlite_history"
argument_list|,
name|zHome
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zHistory
condition|)
block|{
name|shell_read_history
argument_list|(
name|zHistory
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|HAVE_READLINE
operator|||
name|HAVE_EDITLINE
name|rl_attempted_completion_function
operator|=
name|readline_completion
expr_stmt|;
elif|#
directive|elif
name|HAVE_LINENOISE
name|linenoiseSetCompletionCallback
argument_list|(
name|linenoise_completion
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rc
operator|=
name|process_input
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zHistory
condition|)
block|{
name|shell_stifle_history
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
name|shell_write_history
argument_list|(
name|zHistory
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zHistory
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rc
operator|=
name|process_input
argument_list|(
operator|&
name|data
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
block|}
block|}
name|set_table_name
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|db
condition|)
block|{
name|session_close_all
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
name|sqlite3_close
argument_list|(
name|data
operator|.
name|db
argument_list|)
expr_stmt|;
block|}
name|sqlite3_free
argument_list|(
name|data
operator|.
name|zFreeOnClose
argument_list|)
expr_stmt|;
name|find_home_dir
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|SQLITE_SHELL_IS_UTF8
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|sqlite3_free
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|argv
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|rc
return|;
block|}
end_function

end_unit

