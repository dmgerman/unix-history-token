begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** 2001 September 15 ** ** The author disclaims copyright to this source code.  In place of ** a legal notice, here is a blessing: ** **    May you do good and not evil. **    May you find forgiveness for yourself and forgive others. **    May you share freely, never taking more than you give. ** ************************************************************************* ** This file contains code to implement the "sqlite" command line ** utility for accessing SQLite databases. */
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|_CRT_SECURE_NO_WARNINGS
argument_list|)
end_if

begin_comment
comment|/* This needs to come before any includes for MSVC compiler */
end_comment

begin_define
define|#
directive|define
name|_CRT_SECURE_NO_WARNINGS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** Enable large-file support for fopen() and friends on unix. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SQLITE_DISABLE_LFS
end_ifndef

begin_define
define|#
directive|define
name|_LARGE_FILE
value|1
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|_FILE_OFFSET_BITS
end_ifndef

begin_define
define|#
directive|define
name|_FILE_OFFSET_BITS
value|64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|_LARGEFILE_SOURCE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"sqlite3.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
end_if

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__RTP__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_WRS_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_READLINE
argument_list|)
operator|&&
name|HAVE_READLINE
operator|!=
literal|0
end_if

begin_include
include|#
directive|include
file|<readline/readline.h>
end_include

begin_include
include|#
directive|include
file|<readline/history.h>
end_include

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|HAVE_READLINE
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_EDITLINE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_READLINE
argument_list|)
end_if

begin_define
define|#
directive|define
name|HAVE_READLINE
value|1
end_define

begin_include
include|#
directive|include
file|<editline/readline.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_READLINE
argument_list|)
end_if

begin_define
define|#
directive|define
name|add_history
parameter_list|(
name|X
parameter_list|)
end_define

begin_define
define|#
directive|define
name|read_history
parameter_list|(
name|X
parameter_list|)
end_define

begin_define
define|#
directive|define
name|write_history
parameter_list|(
name|X
parameter_list|)
end_define

begin_define
define|#
directive|define
name|stifle_history
parameter_list|(
name|X
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
end_if

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_define
define|#
directive|define
name|isatty
parameter_list|(
name|h
parameter_list|)
value|_isatty(h)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|access
end_ifndef

begin_define
define|#
directive|define
name|access
parameter_list|(
name|f
parameter_list|,
name|m
parameter_list|)
value|_access((f),(m))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|popen
end_undef

begin_define
define|#
directive|define
name|popen
value|_popen
end_define

begin_undef
undef|#
directive|undef
name|pclose
end_undef

begin_define
define|#
directive|define
name|pclose
value|_pclose
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Make sure isatty() has a prototype. */
end_comment

begin_function_decl
specifier|extern
name|int
name|isatty
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* popen and pclose are not C89 functions and so are sometimes omitted from ** the<stdio.h> header */
end_comment

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|popen
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|pclose
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32_WCE
argument_list|)
end_if

begin_comment
comment|/* Windows CE (arm-wince-mingw32ce-gcc) does not provide isatty()  * thus we always assume that we have a console. That can be  * overridden with the -batch command line option.  */
end_comment

begin_define
define|#
directive|define
name|isatty
parameter_list|(
name|x
parameter_list|)
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ctype macros that work with signed characters */
end_comment

begin_define
define|#
directive|define
name|IsSpace
parameter_list|(
name|X
parameter_list|)
value|isspace((unsigned char)X)
end_define

begin_define
define|#
directive|define
name|IsDigit
parameter_list|(
name|X
parameter_list|)
value|isdigit((unsigned char)X)
end_define

begin_define
define|#
directive|define
name|ToLower
parameter_list|(
name|X
parameter_list|)
value|(char)tolower((unsigned char)X)
end_define

begin_comment
comment|/* True if the timer is enabled */
end_comment

begin_decl_stmt
specifier|static
name|int
name|enableTimer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the current wall-clock time */
end_comment

begin_function
specifier|static
name|sqlite3_int64
name|timeOfDay
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|sqlite3_vfs
modifier|*
name|clockVfs
init|=
literal|0
decl_stmt|;
name|sqlite3_int64
name|t
decl_stmt|;
if|if
condition|(
name|clockVfs
operator|==
literal|0
condition|)
name|clockVfs
operator|=
name|sqlite3_vfs_find
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|clockVfs
operator|->
name|iVersion
operator|>=
literal|1
operator|&&
name|clockVfs
operator|->
name|xCurrentTimeInt64
operator|!=
literal|0
condition|)
block|{
name|clockVfs
operator|->
name|xCurrentTimeInt64
argument_list|(
name|clockVfs
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|double
name|r
decl_stmt|;
name|clockVfs
operator|->
name|xCurrentTime
argument_list|(
name|clockVfs
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|t
operator|=
call|(
name|sqlite3_int64
call|)
argument_list|(
name|r
operator|*
literal|86400000.0
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_WRS_KERNEL
argument_list|)
expr|\
operator|&&
operator|!
name|defined
argument_list|(
name|__minux
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_comment
comment|/* Saved resource information for the beginning of an operation */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|rusage
name|sBegin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CPU time at start */
end_comment

begin_decl_stmt
specifier|static
name|sqlite3_int64
name|iBegin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Wall-clock time at start */
end_comment

begin_comment
comment|/* ** Begin timing an operation */
end_comment

begin_function
specifier|static
name|void
name|beginTimer
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|enableTimer
condition|)
block|{
name|getrusage
argument_list|(
name|RUSAGE_SELF
argument_list|,
operator|&
name|sBegin
argument_list|)
expr_stmt|;
name|iBegin
operator|=
name|timeOfDay
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the difference of two time_structs in seconds */
end_comment

begin_function
specifier|static
name|double
name|timeDiff
parameter_list|(
name|struct
name|timeval
modifier|*
name|pStart
parameter_list|,
name|struct
name|timeval
modifier|*
name|pEnd
parameter_list|)
block|{
return|return
operator|(
name|pEnd
operator|->
name|tv_usec
operator|-
name|pStart
operator|->
name|tv_usec
operator|)
operator|*
literal|0.000001
operator|+
call|(
name|double
call|)
argument_list|(
name|pEnd
operator|->
name|tv_sec
operator|-
name|pStart
operator|->
name|tv_sec
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ** Print the timing results. */
end_comment

begin_function
specifier|static
name|void
name|endTimer
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|enableTimer
condition|)
block|{
name|struct
name|rusage
name|sEnd
decl_stmt|;
name|sqlite3_int64
name|iEnd
init|=
name|timeOfDay
argument_list|()
decl_stmt|;
name|getrusage
argument_list|(
name|RUSAGE_SELF
argument_list|,
operator|&
name|sEnd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Run Time: real %.3f user %f sys %f\n"
argument_list|,
operator|(
name|iEnd
operator|-
name|iBegin
operator|)
operator|*
literal|0.001
argument_list|,
name|timeDiff
argument_list|(
operator|&
name|sBegin
operator|.
name|ru_utime
argument_list|,
operator|&
name|sEnd
operator|.
name|ru_utime
argument_list|)
argument_list|,
name|timeDiff
argument_list|(
operator|&
name|sBegin
operator|.
name|ru_stime
argument_list|,
operator|&
name|sEnd
operator|.
name|ru_stime
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|BEGIN_TIMER
value|beginTimer()
end_define

begin_define
define|#
directive|define
name|END_TIMER
value|endTimer()
end_define

begin_define
define|#
directive|define
name|HAS_TIMER
value|1
end_define

begin_elif
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|)
end_elif

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_comment
comment|/* Saved resource information for the beginning of an operation */
end_comment

begin_decl_stmt
specifier|static
name|HANDLE
name|hProcess
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILETIME
name|ftKernelBegin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILETIME
name|ftUserBegin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sqlite3_int64
name|ftWallBegin
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|BOOL
function_decl|(
name|WINAPI
modifier|*
name|GETPROCTIMES
function_decl|)
parameter_list|(
name|HANDLE
parameter_list|,
name|LPFILETIME
parameter_list|,
name|LPFILETIME
parameter_list|,
name|LPFILETIME
parameter_list|,
name|LPFILETIME
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|static
name|GETPROCTIMES
name|getProcessTimesAddr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** Check to see if we have timer support.  Return 1 if necessary ** support found (or found previously). */
end_comment

begin_function
specifier|static
name|int
name|hasTimer
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|getProcessTimesAddr
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* GetProcessTimes() isn't supported in WIN95 and some other Windows versions.     ** See if the version we are running on has it, and if it does, save off     ** a pointer to it and the current process handle.     */
name|hProcess
operator|=
name|GetCurrentProcess
argument_list|()
expr_stmt|;
if|if
condition|(
name|hProcess
condition|)
block|{
name|HINSTANCE
name|hinstLib
init|=
name|LoadLibrary
argument_list|(
name|TEXT
argument_list|(
literal|"Kernel32.dll"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|hinstLib
condition|)
block|{
name|getProcessTimesAddr
operator|=
operator|(
name|GETPROCTIMES
operator|)
name|GetProcAddress
argument_list|(
name|hinstLib
argument_list|,
literal|"GetProcessTimes"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|getProcessTimesAddr
condition|)
block|{
return|return
literal|1
return|;
block|}
name|FreeLibrary
argument_list|(
name|hinstLib
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ** Begin timing an operation */
end_comment

begin_function
specifier|static
name|void
name|beginTimer
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|enableTimer
operator|&&
name|getProcessTimesAddr
condition|)
block|{
name|FILETIME
name|ftCreation
decl_stmt|,
name|ftExit
decl_stmt|;
name|getProcessTimesAddr
argument_list|(
name|hProcess
argument_list|,
operator|&
name|ftCreation
argument_list|,
operator|&
name|ftExit
argument_list|,
operator|&
name|ftKernelBegin
argument_list|,
operator|&
name|ftUserBegin
argument_list|)
expr_stmt|;
name|ftWallBegin
operator|=
name|timeOfDay
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the difference of two FILETIME structs in seconds */
end_comment

begin_function
specifier|static
name|double
name|timeDiff
parameter_list|(
name|FILETIME
modifier|*
name|pStart
parameter_list|,
name|FILETIME
modifier|*
name|pEnd
parameter_list|)
block|{
name|sqlite_int64
name|i64Start
init|=
operator|*
operator|(
operator|(
name|sqlite_int64
operator|*
operator|)
name|pStart
operator|)
decl_stmt|;
name|sqlite_int64
name|i64End
init|=
operator|*
operator|(
operator|(
name|sqlite_int64
operator|*
operator|)
name|pEnd
operator|)
decl_stmt|;
return|return
call|(
name|double
call|)
argument_list|(
operator|(
name|i64End
operator|-
name|i64Start
operator|)
operator|/
literal|10000000.0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ** Print the timing results. */
end_comment

begin_function
specifier|static
name|void
name|endTimer
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|enableTimer
operator|&&
name|getProcessTimesAddr
condition|)
block|{
name|FILETIME
name|ftCreation
decl_stmt|,
name|ftExit
decl_stmt|,
name|ftKernelEnd
decl_stmt|,
name|ftUserEnd
decl_stmt|;
name|sqlite3_int64
name|ftWallEnd
init|=
name|timeOfDay
argument_list|()
decl_stmt|;
name|getProcessTimesAddr
argument_list|(
name|hProcess
argument_list|,
operator|&
name|ftCreation
argument_list|,
operator|&
name|ftExit
argument_list|,
operator|&
name|ftKernelEnd
argument_list|,
operator|&
name|ftUserEnd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Run Time: real %.3f user %f sys %f\n"
argument_list|,
operator|(
name|ftWallEnd
operator|-
name|ftWallBegin
operator|)
operator|*
literal|0.001
argument_list|,
name|timeDiff
argument_list|(
operator|&
name|ftUserBegin
argument_list|,
operator|&
name|ftUserEnd
argument_list|)
argument_list|,
name|timeDiff
argument_list|(
operator|&
name|ftKernelBegin
argument_list|,
operator|&
name|ftKernelEnd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|BEGIN_TIMER
value|beginTimer()
end_define

begin_define
define|#
directive|define
name|END_TIMER
value|endTimer()
end_define

begin_define
define|#
directive|define
name|HAS_TIMER
value|hasTimer()
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BEGIN_TIMER
end_define

begin_define
define|#
directive|define
name|END_TIMER
end_define

begin_define
define|#
directive|define
name|HAS_TIMER
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** Used to prevent warnings about unused parameters */
end_comment

begin_define
define|#
directive|define
name|UNUSED_PARAMETER
parameter_list|(
name|x
parameter_list|)
value|(void)(x)
end_define

begin_comment
comment|/* ** If the following flag is set, then command execution stops ** at an error if we are not interactive. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bail_on_error
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** Threat stdin as an interactive input if the following variable ** is true.  Otherwise, assume stdin is connected to a file or pipe. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stdin_is_interactive
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** The following is the open SQLite database.  We make a pointer ** to this database a static variable so that it can be accessed ** by the SIGINT handler to interrupt database processing. */
end_comment

begin_decl_stmt
specifier|static
name|sqlite3
modifier|*
name|db
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** True if an interrupt (Control-C) has been received. */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|seenInterrupt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** This is the name of our program. It is set in main(), used ** in a number of other places, mostly for error messages. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|Argv0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** Prompt strings. Initialized in main. Settable with **   .prompt main continue */
end_comment

begin_decl_stmt
specifier|static
name|char
name|mainPrompt
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First line prompt. default: "sqlite> "*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|continuePrompt
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Continuation prompt. default: "   ...> " */
end_comment

begin_comment
comment|/* ** Write I/O traces to the following stream. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SQLITE_ENABLE_IOTRACE
end_ifdef

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|iotrace
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** This routine works like printf in that its first argument is a ** format string and subsequent arguments are values to be substituted ** in place of % fields.  The result of formatting this string ** is written to iotrace. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SQLITE_ENABLE_IOTRACE
end_ifdef

begin_function
specifier|static
name|void
name|iotracePrintf
parameter_list|(
specifier|const
name|char
modifier|*
name|zFormat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|char
modifier|*
name|z
decl_stmt|;
if|if
condition|(
name|iotrace
operator|==
literal|0
condition|)
return|return;
name|va_start
argument_list|(
name|ap
argument_list|,
name|zFormat
argument_list|)
expr_stmt|;
name|z
operator|=
name|sqlite3_vmprintf
argument_list|(
name|zFormat
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|iotrace
argument_list|,
literal|"%s"
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|z
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** Determines if a string is a number of not. */
end_comment

begin_function
specifier|static
name|int
name|isNumber
parameter_list|(
specifier|const
name|char
modifier|*
name|z
parameter_list|,
name|int
modifier|*
name|realnum
parameter_list|)
block|{
if|if
condition|(
operator|*
name|z
operator|==
literal|'-'
operator|||
operator|*
name|z
operator|==
literal|'+'
condition|)
name|z
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|IsDigit
argument_list|(
operator|*
name|z
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
name|z
operator|++
expr_stmt|;
if|if
condition|(
name|realnum
condition|)
operator|*
name|realnum
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|IsDigit
argument_list|(
operator|*
name|z
argument_list|)
condition|)
block|{
name|z
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|z
operator|==
literal|'.'
condition|)
block|{
name|z
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|IsDigit
argument_list|(
operator|*
name|z
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|IsDigit
argument_list|(
operator|*
name|z
argument_list|)
condition|)
block|{
name|z
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|realnum
condition|)
operator|*
name|realnum
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|z
operator|==
literal|'e'
operator|||
operator|*
name|z
operator|==
literal|'E'
condition|)
block|{
name|z
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|z
operator|==
literal|'+'
operator|||
operator|*
name|z
operator|==
literal|'-'
condition|)
name|z
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|IsDigit
argument_list|(
operator|*
name|z
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|IsDigit
argument_list|(
operator|*
name|z
argument_list|)
condition|)
block|{
name|z
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|realnum
condition|)
operator|*
name|realnum
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|*
name|z
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ** A global char* and an SQL function to access its current value  ** from within an SQL statement. This program used to use the  ** sqlite_exec_printf() API to substitue a string into an SQL statement. ** The correct way to do this with sqlite3 is to use the bind API, but ** since the shell is built around the callback paradigm it would be a lot ** of work. Instead just use this hack, which is quite harmless. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|zShellStatic
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|shellstaticFunc
parameter_list|(
name|sqlite3_context
modifier|*
name|context
parameter_list|,
name|int
name|argc
parameter_list|,
name|sqlite3_value
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|assert
argument_list|(
literal|0
operator|==
name|argc
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|zShellStatic
argument_list|)
expr_stmt|;
name|UNUSED_PARAMETER
argument_list|(
name|argc
argument_list|)
expr_stmt|;
name|UNUSED_PARAMETER
argument_list|(
name|argv
argument_list|)
expr_stmt|;
name|sqlite3_result_text
argument_list|(
name|context
argument_list|,
name|zShellStatic
argument_list|,
operator|-
literal|1
argument_list|,
name|SQLITE_STATIC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** This routine reads a line of text from FILE in, stores ** the text in memory obtained from malloc() and returns a pointer ** to the text.  NULL is returned at end of file, or if malloc() ** fails. ** ** If zLine is not NULL then it is a malloced buffer returned from ** a previous call to this routine that may be reused. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|local_getline
parameter_list|(
name|char
modifier|*
name|zLine
parameter_list|,
name|FILE
modifier|*
name|in
parameter_list|)
block|{
name|int
name|nLine
init|=
name|zLine
operator|==
literal|0
condition|?
literal|0
else|:
literal|100
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|n
operator|+
literal|100
operator|>
name|nLine
condition|)
block|{
name|nLine
operator|=
name|nLine
operator|*
literal|2
operator|+
literal|100
expr_stmt|;
name|zLine
operator|=
name|realloc
argument_list|(
name|zLine
argument_list|,
name|nLine
argument_list|)
expr_stmt|;
if|if
condition|(
name|zLine
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fgets
argument_list|(
operator|&
name|zLine
index|[
name|n
index|]
argument_list|,
name|nLine
operator|-
name|n
argument_list|,
name|in
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|zLine
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|zLine
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|zLine
index|[
name|n
index|]
condition|)
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
name|zLine
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|n
operator|--
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
name|zLine
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|'\r'
condition|)
name|n
operator|--
expr_stmt|;
name|zLine
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
return|return
name|zLine
return|;
block|}
end_function

begin_comment
comment|/* ** Retrieve a single line of input text. ** ** If in==0 then read from standard input and prompt before each line. ** If isContinuation is true, then a continuation prompt is appropriate. ** If isContinuation is zero, then the main prompt should be used. ** ** If zPrior is not NULL then it is a buffer from a prior call to this ** routine that can be reused. ** ** The result is stored in space obtained from malloc() and must either ** be freed by the caller or else passed back into this routine via the ** zPrior argument for reuse. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|one_input_line
parameter_list|(
name|FILE
modifier|*
name|in
parameter_list|,
name|char
modifier|*
name|zPrior
parameter_list|,
name|int
name|isContinuation
parameter_list|)
block|{
name|char
modifier|*
name|zPrompt
decl_stmt|;
name|char
modifier|*
name|zResult
decl_stmt|;
if|if
condition|(
name|in
operator|!=
literal|0
condition|)
block|{
name|zResult
operator|=
name|local_getline
argument_list|(
name|zPrior
argument_list|,
name|in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zPrompt
operator|=
name|isContinuation
condition|?
name|continuePrompt
else|:
name|mainPrompt
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_READLINE
argument_list|)
name|free
argument_list|(
name|zPrior
argument_list|)
expr_stmt|;
name|zResult
operator|=
name|readline
argument_list|(
name|zPrompt
argument_list|)
expr_stmt|;
if|if
condition|(
name|zResult
operator|&&
operator|*
name|zResult
condition|)
name|add_history
argument_list|(
name|zResult
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|zPrompt
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|zResult
operator|=
name|local_getline
argument_list|(
name|zPrior
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|zResult
return|;
block|}
end_function

begin_struct
struct|struct
name|previous_mode_data
block|{
name|int
name|valid
decl_stmt|;
comment|/* Is there legit data in here? */
name|int
name|mode
decl_stmt|;
name|int
name|showHeader
decl_stmt|;
name|int
name|colWidth
index|[
literal|100
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ** An pointer to an instance of this structure is passed from ** the main program to the callback.  This is used to communicate ** state and mode information. */
end_comment

begin_struct
struct|struct
name|callback_data
block|{
name|sqlite3
modifier|*
name|db
decl_stmt|;
comment|/* The database */
name|int
name|echoOn
decl_stmt|;
comment|/* True to echo input commands */
name|int
name|autoEQP
decl_stmt|;
comment|/* Run EXPLAIN QUERY PLAN prior to seach SQL stmt */
name|int
name|statsOn
decl_stmt|;
comment|/* True to display memory stats before each finalize */
name|int
name|outCount
decl_stmt|;
comment|/* Revert to stdout when reaching zero */
name|int
name|cnt
decl_stmt|;
comment|/* Number of records displayed so far */
name|FILE
modifier|*
name|out
decl_stmt|;
comment|/* Write results here */
name|FILE
modifier|*
name|traceOut
decl_stmt|;
comment|/* Output for sqlite3_trace() */
name|int
name|nErr
decl_stmt|;
comment|/* Number of errors seen */
name|int
name|mode
decl_stmt|;
comment|/* An output mode setting */
name|int
name|writableSchema
decl_stmt|;
comment|/* True if PRAGMA writable_schema=ON */
name|int
name|showHeader
decl_stmt|;
comment|/* True to show column names in List or Column mode */
name|char
modifier|*
name|zDestTable
decl_stmt|;
comment|/* Name of destination table when MODE_Insert */
name|char
name|separator
index|[
literal|20
index|]
decl_stmt|;
comment|/* Separator character for MODE_List */
name|int
name|colWidth
index|[
literal|100
index|]
decl_stmt|;
comment|/* Requested width of each column when in column mode*/
name|int
name|actualWidth
index|[
literal|100
index|]
decl_stmt|;
comment|/* Actual width of each column */
name|char
name|nullvalue
index|[
literal|20
index|]
decl_stmt|;
comment|/* The text to print when a NULL comes back from                          ** the database */
name|struct
name|previous_mode_data
name|explainPrev
decl_stmt|;
comment|/* Holds the mode information just before                          ** .explain ON */
name|char
name|outfile
index|[
name|FILENAME_MAX
index|]
decl_stmt|;
comment|/* Filename for *out */
specifier|const
name|char
modifier|*
name|zDbFilename
decl_stmt|;
comment|/* name of the database file */
name|char
modifier|*
name|zFreeOnClose
decl_stmt|;
comment|/* Filename to free when closing */
specifier|const
name|char
modifier|*
name|zVfs
decl_stmt|;
comment|/* Name of VFS to use */
name|sqlite3_stmt
modifier|*
name|pStmt
decl_stmt|;
comment|/* Current statement if any. */
name|FILE
modifier|*
name|pLog
decl_stmt|;
comment|/* Write log output here */
name|int
modifier|*
name|aiIndent
decl_stmt|;
comment|/* Array of indents used in MODE_Explain */
name|int
name|nIndent
decl_stmt|;
comment|/* Size of array aiIndent[] */
name|int
name|iIndent
decl_stmt|;
comment|/* Index of current op in aiIndent[] */
block|}
struct|;
end_struct

begin_comment
comment|/* ** These are the allowed modes. */
end_comment

begin_define
define|#
directive|define
name|MODE_Line
value|0
end_define

begin_comment
comment|/* One column per line.  Blank line between records */
end_comment

begin_define
define|#
directive|define
name|MODE_Column
value|1
end_define

begin_comment
comment|/* One record per line in neat columns */
end_comment

begin_define
define|#
directive|define
name|MODE_List
value|2
end_define

begin_comment
comment|/* One record per line with a separator */
end_comment

begin_define
define|#
directive|define
name|MODE_Semi
value|3
end_define

begin_comment
comment|/* Same as MODE_List but append ";" to each line */
end_comment

begin_define
define|#
directive|define
name|MODE_Html
value|4
end_define

begin_comment
comment|/* Generate an XHTML table */
end_comment

begin_define
define|#
directive|define
name|MODE_Insert
value|5
end_define

begin_comment
comment|/* Generate SQL "insert" statements */
end_comment

begin_define
define|#
directive|define
name|MODE_Tcl
value|6
end_define

begin_comment
comment|/* Generate ANSI-C or TCL quoted elements */
end_comment

begin_define
define|#
directive|define
name|MODE_Csv
value|7
end_define

begin_comment
comment|/* Quote strings, numbers are plain */
end_comment

begin_define
define|#
directive|define
name|MODE_Explain
value|8
end_define

begin_comment
comment|/* Like MODE_Column, but do not truncate data */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|modeDescr
index|[]
init|=
block|{
literal|"line"
block|,
literal|"column"
block|,
literal|"list"
block|,
literal|"semi"
block|,
literal|"html"
block|,
literal|"insert"
block|,
literal|"tcl"
block|,
literal|"csv"
block|,
literal|"explain"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** Number of elements in an array */
end_comment

begin_define
define|#
directive|define
name|ArraySize
parameter_list|(
name|X
parameter_list|)
value|(int)(sizeof(X)/sizeof(X[0]))
end_define

begin_comment
comment|/* ** Compute a string length that is limited to what can be stored in ** lower 30 bits of a 32-bit signed integer. */
end_comment

begin_function
specifier|static
name|int
name|strlen30
parameter_list|(
specifier|const
name|char
modifier|*
name|z
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|z2
init|=
name|z
decl_stmt|;
while|while
condition|(
operator|*
name|z2
condition|)
block|{
name|z2
operator|++
expr_stmt|;
block|}
return|return
literal|0x3fffffff
operator|&
call|(
name|int
call|)
argument_list|(
name|z2
operator|-
name|z
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ** A callback for the sqlite3_log() interface. */
end_comment

begin_function
specifier|static
name|void
name|shellLog
parameter_list|(
name|void
modifier|*
name|pArg
parameter_list|,
name|int
name|iErrCode
parameter_list|,
specifier|const
name|char
modifier|*
name|zMsg
parameter_list|)
block|{
name|struct
name|callback_data
modifier|*
name|p
init|=
operator|(
expr|struct
name|callback_data
operator|*
operator|)
name|pArg
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|pLog
operator|==
literal|0
condition|)
return|return;
name|fprintf
argument_list|(
name|p
operator|->
name|pLog
argument_list|,
literal|"(%d) %s\n"
argument_list|,
name|iErrCode
argument_list|,
name|zMsg
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|p
operator|->
name|pLog
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Output the given string as a hex-encoded blob (eg. X'1234' ) */
end_comment

begin_function
specifier|static
name|void
name|output_hex_blob
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|pBlob
parameter_list|,
name|int
name|nBlob
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|zBlob
init|=
operator|(
name|char
operator|*
operator|)
name|pBlob
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"X'"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nBlob
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%02x"
argument_list|,
name|zBlob
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Output the given string as a quoted string using SQL quoting conventions. */
end_comment

begin_function
specifier|static
name|void
name|output_quoted_string
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
specifier|const
name|char
modifier|*
name|z
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|nSingle
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|z
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|z
index|[
name|i
index|]
operator|==
literal|'\''
condition|)
name|nSingle
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nSingle
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"'%s'"
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|z
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|z
index|[
name|i
index|]
operator|&&
name|z
index|[
name|i
index|]
operator|!=
literal|'\''
condition|;
name|i
operator|++
control|)
block|{}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"''"
argument_list|)
expr_stmt|;
name|z
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|z
index|[
name|i
index|]
operator|==
literal|'\''
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%.*s''"
argument_list|,
name|i
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|z
operator|+=
name|i
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s"
argument_list|,
name|z
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** Output the given string as a quoted according to C or TCL quoting rules. */
end_comment

begin_function
specifier|static
name|void
name|output_c_string
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
specifier|const
name|char
modifier|*
name|z
parameter_list|)
block|{
name|unsigned
name|int
name|c
decl_stmt|;
name|fputc
argument_list|(
literal|'"'
argument_list|,
name|out
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|(
name|z
operator|++
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|fputc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|fputc
argument_list|(
literal|'\\'
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'"'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|fputc
argument_list|(
literal|'\\'
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'t'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|fputc
argument_list|(
literal|'\\'
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
block|{
name|fputc
argument_list|(
literal|'\\'
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'r'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isprint
argument_list|(
name|c
operator|&
literal|0xff
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\\%03o"
argument_list|,
name|c
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
name|fputc
argument_list|(
literal|'"'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Output the given string with characters that are special to ** HTML escaped. */
end_comment

begin_function
specifier|static
name|void
name|output_html_string
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
specifier|const
name|char
modifier|*
name|z
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|z
operator|==
literal|0
condition|)
name|z
operator|=
literal|""
expr_stmt|;
while|while
condition|(
operator|*
name|z
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|z
index|[
name|i
index|]
operator|&&
name|z
index|[
name|i
index|]
operator|!=
literal|'<'
operator|&&
name|z
index|[
name|i
index|]
operator|!=
literal|'&'
operator|&&
name|z
index|[
name|i
index|]
operator|!=
literal|'>'
operator|&&
name|z
index|[
name|i
index|]
operator|!=
literal|'\"'
operator|&&
name|z
index|[
name|i
index|]
operator|!=
literal|'\''
condition|;
name|i
operator|++
control|)
block|{}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%.*s"
argument_list|,
name|i
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|z
index|[
name|i
index|]
operator|==
literal|'<'
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"&lt;"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|z
index|[
name|i
index|]
operator|==
literal|'&'
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"&amp;"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|z
index|[
name|i
index|]
operator|==
literal|'>'
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"&gt;"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|z
index|[
name|i
index|]
operator|==
literal|'\"'
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"&quot;"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|z
index|[
name|i
index|]
operator|==
literal|'\''
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"&#39;"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
name|z
operator|+=
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** If a field contains any character identified by a 1 in the following ** array, then the string must be quoted for CSV. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|needCsvQuote
index|[]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,    }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** Output a single term of CSV.  Actually, p->separator is used for ** the separator, which may or may not be a comma.  p->nullvalue is ** the null value.  Strings are quoted if necessary. */
end_comment

begin_function
specifier|static
name|void
name|output_csv
parameter_list|(
name|struct
name|callback_data
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|z
parameter_list|,
name|int
name|bSep
parameter_list|)
block|{
name|FILE
modifier|*
name|out
init|=
name|p
operator|->
name|out
decl_stmt|;
if|if
condition|(
name|z
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|nullvalue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|int
name|nSep
init|=
name|strlen30
argument_list|(
name|p
operator|->
name|separator
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|z
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|needCsvQuote
index|[
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|z
operator|)
index|[
name|i
index|]
index|]
operator|||
operator|(
name|z
index|[
name|i
index|]
operator|==
name|p
operator|->
name|separator
index|[
literal|0
index|]
operator|&&
operator|(
name|nSep
operator|==
literal|1
operator|||
name|memcmp
argument_list|(
name|z
argument_list|,
name|p
operator|->
name|separator
argument_list|,
name|nSep
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|putc
argument_list|(
literal|'"'
argument_list|,
name|out
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|z
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|z
index|[
name|i
index|]
operator|==
literal|'"'
condition|)
name|putc
argument_list|(
literal|'"'
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|z
index|[
name|i
index|]
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'"'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s"
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bSep
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|separator
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SIGINT
end_ifdef

begin_comment
comment|/* ** This routine runs when the user presses Ctrl-C */
end_comment

begin_function
specifier|static
name|void
name|interrupt_handler
parameter_list|(
name|int
name|NotUsed
parameter_list|)
block|{
name|UNUSED_PARAMETER
argument_list|(
name|NotUsed
argument_list|)
expr_stmt|;
name|seenInterrupt
operator|++
expr_stmt|;
if|if
condition|(
name|seenInterrupt
operator|>
literal|2
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
condition|)
name|sqlite3_interrupt
argument_list|(
name|db
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** This is the callback routine that the shell ** invokes for each row of a query result. */
end_comment

begin_function
specifier|static
name|int
name|shell_callback
parameter_list|(
name|void
modifier|*
name|pArg
parameter_list|,
name|int
name|nArg
parameter_list|,
name|char
modifier|*
modifier|*
name|azArg
parameter_list|,
name|char
modifier|*
modifier|*
name|azCol
parameter_list|,
name|int
modifier|*
name|aiType
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|callback_data
modifier|*
name|p
init|=
operator|(
expr|struct
name|callback_data
operator|*
operator|)
name|pArg
decl_stmt|;
switch|switch
condition|(
name|p
operator|->
name|mode
condition|)
block|{
case|case
name|MODE_Line
case|:
block|{
name|int
name|w
init|=
literal|5
decl_stmt|;
if|if
condition|(
name|azArg
operator|==
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
name|strlen30
argument_list|(
name|azCol
index|[
name|i
index|]
condition|?
name|azCol
index|[
name|i
index|]
else|:
literal|""
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|w
condition|)
name|w
operator|=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|cnt
operator|++
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%*s = %s\n"
argument_list|,
name|w
argument_list|,
name|azCol
index|[
name|i
index|]
argument_list|,
name|azArg
index|[
name|i
index|]
condition|?
name|azArg
index|[
name|i
index|]
else|:
name|p
operator|->
name|nullvalue
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|MODE_Explain
case|:
case|case
name|MODE_Column
case|:
block|{
if|if
condition|(
name|p
operator|->
name|cnt
operator|++
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|int
name|w
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
name|i
operator|<
name|ArraySize
argument_list|(
name|p
operator|->
name|colWidth
argument_list|)
condition|)
block|{
name|w
operator|=
name|p
operator|->
name|colWidth
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|w
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|==
literal|0
condition|)
block|{
name|w
operator|=
name|strlen30
argument_list|(
name|azCol
index|[
name|i
index|]
condition|?
name|azCol
index|[
name|i
index|]
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|<
literal|10
condition|)
name|w
operator|=
literal|10
expr_stmt|;
name|n
operator|=
name|strlen30
argument_list|(
name|azArg
operator|&&
name|azArg
index|[
name|i
index|]
condition|?
name|azArg
index|[
name|i
index|]
else|:
name|p
operator|->
name|nullvalue
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|<
name|n
condition|)
name|w
operator|=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|ArraySize
argument_list|(
name|p
operator|->
name|actualWidth
argument_list|)
condition|)
block|{
name|p
operator|->
name|actualWidth
index|[
name|i
index|]
operator|=
name|w
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|showHeader
condition|)
block|{
if|if
condition|(
name|w
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%*.*s%s"
argument_list|,
operator|-
name|w
argument_list|,
operator|-
name|w
argument_list|,
name|azCol
index|[
name|i
index|]
argument_list|,
name|i
operator|==
name|nArg
operator|-
literal|1
condition|?
literal|"\n"
else|:
literal|"  "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%-*.*s%s"
argument_list|,
name|w
argument_list|,
name|w
argument_list|,
name|azCol
index|[
name|i
index|]
argument_list|,
name|i
operator|==
name|nArg
operator|-
literal|1
condition|?
literal|"\n"
else|:
literal|"  "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|p
operator|->
name|showHeader
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|int
name|w
decl_stmt|;
if|if
condition|(
name|i
operator|<
name|ArraySize
argument_list|(
name|p
operator|->
name|actualWidth
argument_list|)
condition|)
block|{
name|w
operator|=
name|p
operator|->
name|actualWidth
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|w
operator|<
literal|0
condition|)
name|w
operator|=
operator|-
name|w
expr_stmt|;
block|}
else|else
block|{
name|w
operator|=
literal|10
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%-*.*s%s"
argument_list|,
name|w
argument_list|,
name|w
argument_list|,
literal|"-----------------------------------"
literal|"----------------------------------------------------------"
argument_list|,
name|i
operator|==
name|nArg
operator|-
literal|1
condition|?
literal|"\n"
else|:
literal|"  "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|azArg
operator|==
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|int
name|w
decl_stmt|;
if|if
condition|(
name|i
operator|<
name|ArraySize
argument_list|(
name|p
operator|->
name|actualWidth
argument_list|)
condition|)
block|{
name|w
operator|=
name|p
operator|->
name|actualWidth
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|w
operator|=
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|mode
operator|==
name|MODE_Explain
operator|&&
name|azArg
index|[
name|i
index|]
operator|&&
name|strlen30
argument_list|(
name|azArg
index|[
name|i
index|]
argument_list|)
operator|>
name|w
condition|)
block|{
name|w
operator|=
name|strlen30
argument_list|(
name|azArg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|1
operator|&&
name|p
operator|->
name|aiIndent
operator|&&
name|p
operator|->
name|pStmt
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|iIndent
operator|<
name|p
operator|->
name|nIndent
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%*.s"
argument_list|,
name|p
operator|->
name|aiIndent
index|[
name|p
operator|->
name|iIndent
index|]
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|iIndent
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%*.*s%s"
argument_list|,
operator|-
name|w
argument_list|,
operator|-
name|w
argument_list|,
name|azArg
index|[
name|i
index|]
condition|?
name|azArg
index|[
name|i
index|]
else|:
name|p
operator|->
name|nullvalue
argument_list|,
name|i
operator|==
name|nArg
operator|-
literal|1
condition|?
literal|"\n"
else|:
literal|"  "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%-*.*s%s"
argument_list|,
name|w
argument_list|,
name|w
argument_list|,
name|azArg
index|[
name|i
index|]
condition|?
name|azArg
index|[
name|i
index|]
else|:
name|p
operator|->
name|nullvalue
argument_list|,
name|i
operator|==
name|nArg
operator|-
literal|1
condition|?
literal|"\n"
else|:
literal|"  "
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|MODE_Semi
case|:
case|case
name|MODE_List
case|:
block|{
if|if
condition|(
name|p
operator|->
name|cnt
operator|++
operator|==
literal|0
operator|&&
name|p
operator|->
name|showHeader
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s%s"
argument_list|,
name|azCol
index|[
name|i
index|]
argument_list|,
name|i
operator|==
name|nArg
operator|-
literal|1
condition|?
literal|"\n"
else|:
name|p
operator|->
name|separator
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|azArg
operator|==
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|z
init|=
name|azArg
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|z
operator|==
literal|0
condition|)
name|z
operator|=
name|p
operator|->
name|nullvalue
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|nArg
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|separator
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|mode
operator|==
name|MODE_Semi
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|MODE_Html
case|:
block|{
if|if
condition|(
name|p
operator|->
name|cnt
operator|++
operator|==
literal|0
operator|&&
name|p
operator|->
name|showHeader
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"<TR>"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"<TH>"
argument_list|)
expr_stmt|;
name|output_html_string
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|azCol
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"</TH>\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"</TR>\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|azArg
operator|==
literal|0
condition|)
break|break;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"<TR>"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"<TD>"
argument_list|)
expr_stmt|;
name|output_html_string
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|azArg
index|[
name|i
index|]
condition|?
name|azArg
index|[
name|i
index|]
else|:
name|p
operator|->
name|nullvalue
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"</TD>\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"</TR>\n"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MODE_Tcl
case|:
block|{
if|if
condition|(
name|p
operator|->
name|cnt
operator|++
operator|==
literal|0
operator|&&
name|p
operator|->
name|showHeader
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|output_c_string
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|azCol
index|[
name|i
index|]
condition|?
name|azCol
index|[
name|i
index|]
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|nArg
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|separator
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|azArg
operator|==
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|output_c_string
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|azArg
index|[
name|i
index|]
condition|?
name|azArg
index|[
name|i
index|]
else|:
name|p
operator|->
name|nullvalue
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|nArg
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|separator
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MODE_Csv
case|:
block|{
if|if
condition|(
name|p
operator|->
name|cnt
operator|++
operator|==
literal|0
operator|&&
name|p
operator|->
name|showHeader
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|output_csv
argument_list|(
name|p
argument_list|,
name|azCol
index|[
name|i
index|]
condition|?
name|azCol
index|[
name|i
index|]
else|:
literal|""
argument_list|,
name|i
operator|<
name|nArg
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|azArg
operator|==
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|output_csv
argument_list|(
name|p
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|,
name|i
operator|<
name|nArg
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MODE_Insert
case|:
block|{
name|p
operator|->
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
name|azArg
operator|==
literal|0
condition|)
break|break;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"INSERT INTO %s VALUES("
argument_list|,
name|p
operator|->
name|zDestTable
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|zSep
init|=
name|i
operator|>
literal|0
condition|?
literal|","
else|:
literal|""
decl_stmt|;
if|if
condition|(
operator|(
name|azArg
index|[
name|i
index|]
operator|==
literal|0
operator|)
operator|||
operator|(
name|aiType
operator|&&
name|aiType
index|[
name|i
index|]
operator|==
name|SQLITE_NULL
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%sNULL"
argument_list|,
name|zSep
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aiType
operator|&&
name|aiType
index|[
name|i
index|]
operator|==
name|SQLITE_TEXT
condition|)
block|{
if|if
condition|(
name|zSep
index|[
literal|0
index|]
condition|)
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|zSep
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aiType
operator|&&
operator|(
name|aiType
index|[
name|i
index|]
operator|==
name|SQLITE_INTEGER
operator|||
name|aiType
index|[
name|i
index|]
operator|==
name|SQLITE_FLOAT
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s%s"
argument_list|,
name|zSep
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aiType
operator|&&
name|aiType
index|[
name|i
index|]
operator|==
name|SQLITE_BLOB
operator|&&
name|p
operator|->
name|pStmt
condition|)
block|{
specifier|const
name|void
modifier|*
name|pBlob
init|=
name|sqlite3_column_blob
argument_list|(
name|p
operator|->
name|pStmt
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|nBlob
init|=
name|sqlite3_column_bytes
argument_list|(
name|p
operator|->
name|pStmt
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|zSep
index|[
literal|0
index|]
condition|)
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|zSep
argument_list|)
expr_stmt|;
name|output_hex_blob
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|pBlob
argument_list|,
name|nBlob
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isNumber
argument_list|(
name|azArg
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s%s"
argument_list|,
name|zSep
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|zSep
index|[
literal|0
index|]
condition|)
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|zSep
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|");\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ** This is the callback routine that the SQLite library ** invokes for each row of a query result. */
end_comment

begin_function
specifier|static
name|int
name|callback
parameter_list|(
name|void
modifier|*
name|pArg
parameter_list|,
name|int
name|nArg
parameter_list|,
name|char
modifier|*
modifier|*
name|azArg
parameter_list|,
name|char
modifier|*
modifier|*
name|azCol
parameter_list|)
block|{
comment|/* since we don't have type info, call the shell_callback with a NULL value */
return|return
name|shell_callback
argument_list|(
name|pArg
argument_list|,
name|nArg
argument_list|,
name|azArg
argument_list|,
name|azCol
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ** Set the destination table field of the callback_data structure to ** the name of the table given.  Escape any quote characters in the ** table name. */
end_comment

begin_function
specifier|static
name|void
name|set_table_name
parameter_list|(
name|struct
name|callback_data
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|zName
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|int
name|needQuote
decl_stmt|;
name|char
modifier|*
name|z
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|zDestTable
condition|)
block|{
name|free
argument_list|(
name|p
operator|->
name|zDestTable
argument_list|)
expr_stmt|;
name|p
operator|->
name|zDestTable
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|zName
operator|==
literal|0
condition|)
return|return;
name|needQuote
operator|=
operator|!
name|isalpha
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|zName
argument_list|)
operator|&&
operator|*
name|zName
operator|!=
literal|'_'
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n
operator|=
literal|0
init|;
name|zName
index|[
name|i
index|]
condition|;
name|i
operator|++
operator|,
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isalnum
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|zName
index|[
name|i
index|]
argument_list|)
operator|&&
name|zName
index|[
name|i
index|]
operator|!=
literal|'_'
condition|)
block|{
name|needQuote
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|zName
index|[
name|i
index|]
operator|==
literal|'\''
condition|)
name|n
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|needQuote
condition|)
name|n
operator|+=
literal|2
expr_stmt|;
name|z
operator|=
name|p
operator|->
name|zDestTable
operator|=
name|malloc
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|needQuote
condition|)
name|z
index|[
name|n
operator|++
index|]
operator|=
literal|'\''
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|zName
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|z
index|[
name|n
operator|++
index|]
operator|=
name|zName
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|zName
index|[
name|i
index|]
operator|==
literal|'\''
condition|)
name|z
index|[
name|n
operator|++
index|]
operator|=
literal|'\''
expr_stmt|;
block|}
if|if
condition|(
name|needQuote
condition|)
name|z
index|[
name|n
operator|++
index|]
operator|=
literal|'\''
expr_stmt|;
name|z
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* zIn is either a pointer to a NULL-terminated string in memory obtained ** from malloc(), or a NULL pointer. The string pointed to by zAppend is ** added to zIn, and the result returned in memory obtained from malloc(). ** zIn, if it was not NULL, is freed. ** ** If the third argument, quote, is not '\0', then it is used as a  ** quote character for zAppend. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|appendText
parameter_list|(
name|char
modifier|*
name|zIn
parameter_list|,
name|char
specifier|const
modifier|*
name|zAppend
parameter_list|,
name|char
name|quote
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|nAppend
init|=
name|strlen30
argument_list|(
name|zAppend
argument_list|)
decl_stmt|;
name|int
name|nIn
init|=
operator|(
name|zIn
condition|?
name|strlen30
argument_list|(
name|zIn
argument_list|)
else|:
literal|0
operator|)
decl_stmt|;
name|len
operator|=
name|nAppend
operator|+
name|nIn
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|quote
condition|)
block|{
name|len
operator|+=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nAppend
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|zAppend
index|[
name|i
index|]
operator|==
name|quote
condition|)
name|len
operator|++
expr_stmt|;
block|}
block|}
name|zIn
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|zIn
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zIn
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|quote
condition|)
block|{
name|char
modifier|*
name|zCsr
init|=
operator|&
name|zIn
index|[
name|nIn
index|]
decl_stmt|;
operator|*
name|zCsr
operator|++
operator|=
name|quote
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nAppend
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|zCsr
operator|++
operator|=
name|zAppend
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|zAppend
index|[
name|i
index|]
operator|==
name|quote
condition|)
operator|*
name|zCsr
operator|++
operator|=
name|quote
expr_stmt|;
block|}
operator|*
name|zCsr
operator|++
operator|=
name|quote
expr_stmt|;
operator|*
name|zCsr
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|assert
argument_list|(
operator|(
name|zCsr
operator|-
name|zIn
operator|)
operator|==
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
operator|&
name|zIn
index|[
name|nIn
index|]
argument_list|,
name|zAppend
argument_list|,
name|nAppend
argument_list|)
expr_stmt|;
name|zIn
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|zIn
return|;
block|}
end_function

begin_comment
comment|/* ** Execute a query statement that will generate SQL output.  Print ** the result columns, comma-separated, on a line and then add a ** semicolon terminator to the end of that line. ** ** If the number of columns is 1 and that column contains text "--" ** then write the semicolon on a separate line.  That way, if a  ** "--" comment occurs at the end of the statement, the comment ** won't consume the semicolon terminator. */
end_comment

begin_function
specifier|static
name|int
name|run_table_dump_query
parameter_list|(
name|struct
name|callback_data
modifier|*
name|p
parameter_list|,
comment|/* Query context */
specifier|const
name|char
modifier|*
name|zSelect
parameter_list|,
comment|/* SELECT statement to extract content */
specifier|const
name|char
modifier|*
name|zFirstRow
comment|/* Print before first row, if not NULL */
parameter_list|)
block|{
name|sqlite3_stmt
modifier|*
name|pSelect
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|int
name|nResult
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zSelect
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pSelect
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
operator|||
operator|!
name|pSelect
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"/**** ERROR: (%d) %s *****/\n"
argument_list|,
name|rc
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|&
literal|0xff
operator|)
operator|!=
name|SQLITE_CORRUPT
condition|)
name|p
operator|->
name|nErr
operator|++
expr_stmt|;
return|return
name|rc
return|;
block|}
name|rc
operator|=
name|sqlite3_step
argument_list|(
name|pSelect
argument_list|)
expr_stmt|;
name|nResult
operator|=
name|sqlite3_column_count
argument_list|(
name|pSelect
argument_list|)
expr_stmt|;
while|while
condition|(
name|rc
operator|==
name|SQLITE_ROW
condition|)
block|{
if|if
condition|(
name|zFirstRow
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|zFirstRow
argument_list|)
expr_stmt|;
name|zFirstRow
operator|=
literal|0
expr_stmt|;
block|}
name|z
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pSelect
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|z
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nResult
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|",%s"
argument_list|,
name|sqlite3_column_text
argument_list|(
name|pSelect
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|z
operator|==
literal|0
condition|)
name|z
operator|=
literal|""
expr_stmt|;
while|while
condition|(
name|z
index|[
literal|0
index|]
operator|&&
operator|(
name|z
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
name|z
index|[
literal|1
index|]
operator|!=
literal|'-'
operator|)
condition|)
name|z
operator|++
expr_stmt|;
if|if
condition|(
name|z
index|[
literal|0
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n;\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|sqlite3_step
argument_list|(
name|pSelect
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|sqlite3_finalize
argument_list|(
name|pSelect
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"/**** ERROR: (%d) %s *****/\n"
argument_list|,
name|rc
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|&
literal|0xff
operator|)
operator|!=
name|SQLITE_CORRUPT
condition|)
name|p
operator|->
name|nErr
operator|++
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* ** Allocate space and save off current error string. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|save_err_msg
parameter_list|(
name|sqlite3
modifier|*
name|db
comment|/* Database to query */
parameter_list|)
block|{
name|int
name|nErrMsg
init|=
literal|1
operator|+
name|strlen30
argument_list|(
name|sqlite3_errmsg
argument_list|(
name|db
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|zErrMsg
init|=
name|sqlite3_malloc
argument_list|(
name|nErrMsg
argument_list|)
decl_stmt|;
if|if
condition|(
name|zErrMsg
condition|)
block|{
name|memcpy
argument_list|(
name|zErrMsg
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|db
argument_list|)
argument_list|,
name|nErrMsg
argument_list|)
expr_stmt|;
block|}
return|return
name|zErrMsg
return|;
block|}
end_function

begin_comment
comment|/* ** Display memory stats. */
end_comment

begin_function
specifier|static
name|int
name|display_stats
parameter_list|(
name|sqlite3
modifier|*
name|db
parameter_list|,
comment|/* Database to query */
name|struct
name|callback_data
modifier|*
name|pArg
parameter_list|,
comment|/* Pointer to struct callback_data */
name|int
name|bReset
comment|/* True to reset the stats */
parameter_list|)
block|{
name|int
name|iCur
decl_stmt|;
name|int
name|iHiwtr
decl_stmt|;
if|if
condition|(
name|pArg
operator|&&
name|pArg
operator|->
name|out
condition|)
block|{
name|iHiwtr
operator|=
name|iCur
operator|=
operator|-
literal|1
expr_stmt|;
name|sqlite3_status
argument_list|(
name|SQLITE_STATUS_MEMORY_USED
argument_list|,
operator|&
name|iCur
argument_list|,
operator|&
name|iHiwtr
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Memory Used:                         %d (max %d) bytes\n"
argument_list|,
name|iCur
argument_list|,
name|iHiwtr
argument_list|)
expr_stmt|;
name|iHiwtr
operator|=
name|iCur
operator|=
operator|-
literal|1
expr_stmt|;
name|sqlite3_status
argument_list|(
name|SQLITE_STATUS_MALLOC_COUNT
argument_list|,
operator|&
name|iCur
argument_list|,
operator|&
name|iHiwtr
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Number of Outstanding Allocations:   %d (max %d)\n"
argument_list|,
name|iCur
argument_list|,
name|iHiwtr
argument_list|)
expr_stmt|;
comment|/* ** Not currently used by the CLI. **    iHiwtr = iCur = -1; **    sqlite3_status(SQLITE_STATUS_PAGECACHE_USED,&iCur,&iHiwtr, bReset); **    fprintf(pArg->out, "Number of Pcache Pages Used:         %d (max %d) pages\n", iCur, iHiwtr); */
name|iHiwtr
operator|=
name|iCur
operator|=
operator|-
literal|1
expr_stmt|;
name|sqlite3_status
argument_list|(
name|SQLITE_STATUS_PAGECACHE_OVERFLOW
argument_list|,
operator|&
name|iCur
argument_list|,
operator|&
name|iHiwtr
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Number of Pcache Overflow Bytes:     %d (max %d) bytes\n"
argument_list|,
name|iCur
argument_list|,
name|iHiwtr
argument_list|)
expr_stmt|;
comment|/* ** Not currently used by the CLI. **    iHiwtr = iCur = -1; **    sqlite3_status(SQLITE_STATUS_SCRATCH_USED,&iCur,&iHiwtr, bReset); **    fprintf(pArg->out, "Number of Scratch Allocations Used:  %d (max %d)\n", iCur, iHiwtr); */
name|iHiwtr
operator|=
name|iCur
operator|=
operator|-
literal|1
expr_stmt|;
name|sqlite3_status
argument_list|(
name|SQLITE_STATUS_SCRATCH_OVERFLOW
argument_list|,
operator|&
name|iCur
argument_list|,
operator|&
name|iHiwtr
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Number of Scratch Overflow Bytes:    %d (max %d) bytes\n"
argument_list|,
name|iCur
argument_list|,
name|iHiwtr
argument_list|)
expr_stmt|;
name|iHiwtr
operator|=
name|iCur
operator|=
operator|-
literal|1
expr_stmt|;
name|sqlite3_status
argument_list|(
name|SQLITE_STATUS_MALLOC_SIZE
argument_list|,
operator|&
name|iCur
argument_list|,
operator|&
name|iHiwtr
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Largest Allocation:                  %d bytes\n"
argument_list|,
name|iHiwtr
argument_list|)
expr_stmt|;
name|iHiwtr
operator|=
name|iCur
operator|=
operator|-
literal|1
expr_stmt|;
name|sqlite3_status
argument_list|(
name|SQLITE_STATUS_PAGECACHE_SIZE
argument_list|,
operator|&
name|iCur
argument_list|,
operator|&
name|iHiwtr
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Largest Pcache Allocation:           %d bytes\n"
argument_list|,
name|iHiwtr
argument_list|)
expr_stmt|;
name|iHiwtr
operator|=
name|iCur
operator|=
operator|-
literal|1
expr_stmt|;
name|sqlite3_status
argument_list|(
name|SQLITE_STATUS_SCRATCH_SIZE
argument_list|,
operator|&
name|iCur
argument_list|,
operator|&
name|iHiwtr
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Largest Scratch Allocation:          %d bytes\n"
argument_list|,
name|iHiwtr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|YYTRACKMAXSTACKDEPTH
name|iHiwtr
operator|=
name|iCur
operator|=
operator|-
literal|1
expr_stmt|;
name|sqlite3_status
argument_list|(
name|SQLITE_STATUS_PARSER_STACK
argument_list|,
operator|&
name|iCur
argument_list|,
operator|&
name|iHiwtr
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Deepest Parser Stack:                %d (max %d)\n"
argument_list|,
name|iCur
argument_list|,
name|iHiwtr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|pArg
operator|&&
name|pArg
operator|->
name|out
operator|&&
name|db
condition|)
block|{
name|iHiwtr
operator|=
name|iCur
operator|=
operator|-
literal|1
expr_stmt|;
name|sqlite3_db_status
argument_list|(
name|db
argument_list|,
name|SQLITE_DBSTATUS_LOOKASIDE_USED
argument_list|,
operator|&
name|iCur
argument_list|,
operator|&
name|iHiwtr
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Lookaside Slots Used:                %d (max %d)\n"
argument_list|,
name|iCur
argument_list|,
name|iHiwtr
argument_list|)
expr_stmt|;
name|sqlite3_db_status
argument_list|(
name|db
argument_list|,
name|SQLITE_DBSTATUS_LOOKASIDE_HIT
argument_list|,
operator|&
name|iCur
argument_list|,
operator|&
name|iHiwtr
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Successful lookaside attempts:       %d\n"
argument_list|,
name|iHiwtr
argument_list|)
expr_stmt|;
name|sqlite3_db_status
argument_list|(
name|db
argument_list|,
name|SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE
argument_list|,
operator|&
name|iCur
argument_list|,
operator|&
name|iHiwtr
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Lookaside failures due to size:      %d\n"
argument_list|,
name|iHiwtr
argument_list|)
expr_stmt|;
name|sqlite3_db_status
argument_list|(
name|db
argument_list|,
name|SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL
argument_list|,
operator|&
name|iCur
argument_list|,
operator|&
name|iHiwtr
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Lookaside failures due to OOM:       %d\n"
argument_list|,
name|iHiwtr
argument_list|)
expr_stmt|;
name|iHiwtr
operator|=
name|iCur
operator|=
operator|-
literal|1
expr_stmt|;
name|sqlite3_db_status
argument_list|(
name|db
argument_list|,
name|SQLITE_DBSTATUS_CACHE_USED
argument_list|,
operator|&
name|iCur
argument_list|,
operator|&
name|iHiwtr
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Pager Heap Usage:                    %d bytes\n"
argument_list|,
name|iCur
argument_list|)
expr_stmt|;
name|iHiwtr
operator|=
name|iCur
operator|=
operator|-
literal|1
expr_stmt|;
name|sqlite3_db_status
argument_list|(
name|db
argument_list|,
name|SQLITE_DBSTATUS_CACHE_HIT
argument_list|,
operator|&
name|iCur
argument_list|,
operator|&
name|iHiwtr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Page cache hits:                     %d\n"
argument_list|,
name|iCur
argument_list|)
expr_stmt|;
name|iHiwtr
operator|=
name|iCur
operator|=
operator|-
literal|1
expr_stmt|;
name|sqlite3_db_status
argument_list|(
name|db
argument_list|,
name|SQLITE_DBSTATUS_CACHE_MISS
argument_list|,
operator|&
name|iCur
argument_list|,
operator|&
name|iHiwtr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Page cache misses:                   %d\n"
argument_list|,
name|iCur
argument_list|)
expr_stmt|;
name|iHiwtr
operator|=
name|iCur
operator|=
operator|-
literal|1
expr_stmt|;
name|sqlite3_db_status
argument_list|(
name|db
argument_list|,
name|SQLITE_DBSTATUS_CACHE_WRITE
argument_list|,
operator|&
name|iCur
argument_list|,
operator|&
name|iHiwtr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Page cache writes:                   %d\n"
argument_list|,
name|iCur
argument_list|)
expr_stmt|;
name|iHiwtr
operator|=
name|iCur
operator|=
operator|-
literal|1
expr_stmt|;
name|sqlite3_db_status
argument_list|(
name|db
argument_list|,
name|SQLITE_DBSTATUS_SCHEMA_USED
argument_list|,
operator|&
name|iCur
argument_list|,
operator|&
name|iHiwtr
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Schema Heap Usage:                   %d bytes\n"
argument_list|,
name|iCur
argument_list|)
expr_stmt|;
name|iHiwtr
operator|=
name|iCur
operator|=
operator|-
literal|1
expr_stmt|;
name|sqlite3_db_status
argument_list|(
name|db
argument_list|,
name|SQLITE_DBSTATUS_STMT_USED
argument_list|,
operator|&
name|iCur
argument_list|,
operator|&
name|iHiwtr
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Statement Heap/Lookaside Usage:      %d bytes\n"
argument_list|,
name|iCur
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pArg
operator|&&
name|pArg
operator|->
name|out
operator|&&
name|db
operator|&&
name|pArg
operator|->
name|pStmt
condition|)
block|{
name|iCur
operator|=
name|sqlite3_stmt_status
argument_list|(
name|pArg
operator|->
name|pStmt
argument_list|,
name|SQLITE_STMTSTATUS_FULLSCAN_STEP
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Fullscan Steps:                      %d\n"
argument_list|,
name|iCur
argument_list|)
expr_stmt|;
name|iCur
operator|=
name|sqlite3_stmt_status
argument_list|(
name|pArg
operator|->
name|pStmt
argument_list|,
name|SQLITE_STMTSTATUS_SORT
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Sort Operations:                     %d\n"
argument_list|,
name|iCur
argument_list|)
expr_stmt|;
name|iCur
operator|=
name|sqlite3_stmt_status
argument_list|(
name|pArg
operator|->
name|pStmt
argument_list|,
name|SQLITE_STMTSTATUS_AUTOINDEX
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Autoindex Inserts:                   %d\n"
argument_list|,
name|iCur
argument_list|)
expr_stmt|;
name|iCur
operator|=
name|sqlite3_stmt_status
argument_list|(
name|pArg
operator|->
name|pStmt
argument_list|,
name|SQLITE_STMTSTATUS_VM_STEP
argument_list|,
name|bReset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"Virtual Machine Steps:               %d\n"
argument_list|,
name|iCur
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ** Parameter azArray points to a zero-terminated array of strings. zStr ** points to a single nul-terminated string. Return non-zero if zStr ** is equal, according to strcmp(), to any of the strings in the array. ** Otherwise, return zero. */
end_comment

begin_function
specifier|static
name|int
name|str_in_array
parameter_list|(
specifier|const
name|char
modifier|*
name|zStr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|azArray
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|azArray
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|zStr
argument_list|,
name|azArray
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ** If compiled statement pSql appears to be an EXPLAIN statement, allocate ** and populate the callback_data.aiIndent[] array with the number of ** spaces each opcode should be indented before it is output.  ** ** The indenting rules are: ** **     * For each "Next", "Prev", "VNext" or "VPrev" instruction, indent **       all opcodes that occur between the p2 jump destination and the opcode **       itself by 2 spaces. ** **     * For each "Goto", if the jump destination is earlier in the program **       and ends on one of: **          Yield  SeekGt  SeekLt  RowSetRead  Rewind **       or if the P1 parameter is one instead of zero, **       then indent all opcodes between the earlier instruction **       and "Goto" by 2 spaces. */
end_comment

begin_function
specifier|static
name|void
name|explain_data_prepare
parameter_list|(
name|struct
name|callback_data
modifier|*
name|p
parameter_list|,
name|sqlite3_stmt
modifier|*
name|pSql
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|zSql
decl_stmt|;
comment|/* The text of the SQL statement */
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
comment|/* Used to check if this is an EXPLAIN */
name|int
modifier|*
name|abYield
init|=
literal|0
decl_stmt|;
comment|/* True if op is an OP_Yield */
name|int
name|nAlloc
init|=
literal|0
decl_stmt|;
comment|/* Allocated size of p->aiIndent[], abYield */
name|int
name|iOp
decl_stmt|;
comment|/* Index of operation in p->aiIndent[] */
specifier|const
name|char
modifier|*
name|azNext
index|[]
init|=
block|{
literal|"Next"
block|,
literal|"Prev"
block|,
literal|"VPrev"
block|,
literal|"VNext"
block|,
literal|"SorterNext"
block|,
literal|"NextIfOpen"
block|,
literal|"PrevIfOpen"
block|,
literal|0
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|azYield
index|[]
init|=
block|{
literal|"Yield"
block|,
literal|"SeekLT"
block|,
literal|"SeekGT"
block|,
literal|"RowSetRead"
block|,
literal|"Rewind"
block|,
literal|0
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|azGoto
index|[]
init|=
block|{
literal|"Goto"
block|,
literal|0
block|}
decl_stmt|;
comment|/* Try to figure out if this is really an EXPLAIN statement. If this   ** cannot be verified, return early.  */
name|zSql
operator|=
name|sqlite3_sql
argument_list|(
name|pSql
argument_list|)
expr_stmt|;
if|if
condition|(
name|zSql
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|z
operator|=
name|zSql
init|;
operator|*
name|z
operator|==
literal|' '
operator|||
operator|*
name|z
operator|==
literal|'\t'
operator|||
operator|*
name|z
operator|==
literal|'\n'
operator|||
operator|*
name|z
operator|==
literal|'\f'
operator|||
operator|*
name|z
operator|==
literal|'\r'
condition|;
name|z
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|sqlite3_strnicmp
argument_list|(
name|z
argument_list|,
literal|"explain"
argument_list|,
literal|7
argument_list|)
condition|)
return|return;
for|for
control|(
name|iOp
operator|=
literal|0
init|;
name|SQLITE_ROW
operator|==
name|sqlite3_step
argument_list|(
name|pSql
argument_list|)
condition|;
name|iOp
operator|++
control|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|iAddr
init|=
name|sqlite3_column_int
argument_list|(
name|pSql
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|zOp
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pSql
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Set p2 to the P2 field of the current opcode. Then, assuming that     ** p2 is an instruction address, set variable p2op to the index of that     ** instruction in the aiIndent[] array. p2 and p2op may be different if     ** the current instruction is part of a sub-program generated by an     ** SQL trigger or foreign key.  */
name|int
name|p2
init|=
name|sqlite3_column_int
argument_list|(
name|pSql
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|int
name|p2op
init|=
operator|(
name|p2
operator|+
operator|(
name|iOp
operator|-
name|iAddr
operator|)
operator|)
decl_stmt|;
comment|/* Grow the p->aiIndent array as required */
if|if
condition|(
name|iOp
operator|>=
name|nAlloc
condition|)
block|{
name|nAlloc
operator|+=
literal|100
expr_stmt|;
name|p
operator|->
name|aiIndent
operator|=
operator|(
name|int
operator|*
operator|)
name|sqlite3_realloc
argument_list|(
name|p
operator|->
name|aiIndent
argument_list|,
name|nAlloc
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|abYield
operator|=
operator|(
name|int
operator|*
operator|)
name|sqlite3_realloc
argument_list|(
name|abYield
argument_list|,
name|nAlloc
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|abYield
index|[
name|iOp
index|]
operator|=
name|str_in_array
argument_list|(
name|zOp
argument_list|,
name|azYield
argument_list|)
expr_stmt|;
name|p
operator|->
name|aiIndent
index|[
name|iOp
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|nIndent
operator|=
name|iOp
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|str_in_array
argument_list|(
name|zOp
argument_list|,
name|azNext
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|p2op
init|;
name|i
operator|<
name|iOp
condition|;
name|i
operator|++
control|)
name|p
operator|->
name|aiIndent
index|[
name|i
index|]
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|str_in_array
argument_list|(
name|zOp
argument_list|,
name|azGoto
argument_list|)
operator|&&
name|p2op
operator|<
name|p
operator|->
name|nIndent
operator|&&
operator|(
name|abYield
index|[
name|p2op
index|]
operator|||
name|sqlite3_column_int
argument_list|(
name|pSql
argument_list|,
literal|2
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|p2op
operator|+
literal|1
init|;
name|i
operator|<
name|iOp
condition|;
name|i
operator|++
control|)
name|p
operator|->
name|aiIndent
index|[
name|i
index|]
operator|+=
literal|2
expr_stmt|;
block|}
block|}
name|p
operator|->
name|iIndent
operator|=
literal|0
expr_stmt|;
name|sqlite3_free
argument_list|(
name|abYield
argument_list|)
expr_stmt|;
name|sqlite3_reset
argument_list|(
name|pSql
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Free the array allocated by explain_data_prepare(). */
end_comment

begin_function
specifier|static
name|void
name|explain_data_delete
parameter_list|(
name|struct
name|callback_data
modifier|*
name|p
parameter_list|)
block|{
name|sqlite3_free
argument_list|(
name|p
operator|->
name|aiIndent
argument_list|)
expr_stmt|;
name|p
operator|->
name|aiIndent
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|nIndent
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|iIndent
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Execute a statement or set of statements.  Print  ** any result rows/columns depending on the current mode  ** set via the supplied callback. ** ** This is very similar to SQLite's built-in sqlite3_exec()  ** function except it takes a slightly different callback  ** and callback data argument. */
end_comment

begin_function
specifier|static
name|int
name|shell_exec
parameter_list|(
name|sqlite3
modifier|*
name|db
parameter_list|,
comment|/* An open database */
specifier|const
name|char
modifier|*
name|zSql
parameter_list|,
comment|/* SQL to be evaluated */
name|int
function_decl|(
modifier|*
name|xCallback
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
parameter_list|,
comment|/* Callback function */
comment|/* (not the same as sqlite3_exec) */
name|struct
name|callback_data
modifier|*
name|pArg
parameter_list|,
comment|/* Pointer to struct callback_data */
name|char
modifier|*
modifier|*
name|pzErrMsg
comment|/* Error msg written here */
parameter_list|)
block|{
name|sqlite3_stmt
modifier|*
name|pStmt
init|=
name|NULL
decl_stmt|;
comment|/* Statement to execute. */
name|int
name|rc
init|=
name|SQLITE_OK
decl_stmt|;
comment|/* Return Code */
name|int
name|rc2
decl_stmt|;
specifier|const
name|char
modifier|*
name|zLeftover
decl_stmt|;
comment|/* Tail of unprocessed SQL */
if|if
condition|(
name|pzErrMsg
condition|)
block|{
operator|*
name|pzErrMsg
operator|=
name|NULL
expr_stmt|;
block|}
while|while
condition|(
name|zSql
index|[
literal|0
index|]
operator|&&
operator|(
name|SQLITE_OK
operator|==
name|rc
operator|)
condition|)
block|{
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|db
argument_list|,
name|zSql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pStmt
argument_list|,
operator|&
name|zLeftover
argument_list|)
expr_stmt|;
if|if
condition|(
name|SQLITE_OK
operator|!=
name|rc
condition|)
block|{
if|if
condition|(
name|pzErrMsg
condition|)
block|{
operator|*
name|pzErrMsg
operator|=
name|save_err_msg
argument_list|(
name|db
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|pStmt
condition|)
block|{
comment|/* this happens for a comment or white-space */
name|zSql
operator|=
name|zLeftover
expr_stmt|;
while|while
condition|(
name|IsSpace
argument_list|(
name|zSql
index|[
literal|0
index|]
argument_list|)
condition|)
name|zSql
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* save off the prepared statment handle and reset row count */
if|if
condition|(
name|pArg
condition|)
block|{
name|pArg
operator|->
name|pStmt
operator|=
name|pStmt
expr_stmt|;
name|pArg
operator|->
name|cnt
operator|=
literal|0
expr_stmt|;
block|}
comment|/* echo the sql statement if echo on */
if|if
condition|(
name|pArg
operator|&&
name|pArg
operator|->
name|echoOn
condition|)
block|{
specifier|const
name|char
modifier|*
name|zStmtSql
init|=
name|sqlite3_sql
argument_list|(
name|pStmt
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"%s\n"
argument_list|,
name|zStmtSql
condition|?
name|zStmtSql
else|:
name|zSql
argument_list|)
expr_stmt|;
block|}
comment|/* Show the EXPLAIN QUERY PLAN if .eqp is on */
if|if
condition|(
name|pArg
operator|&&
name|pArg
operator|->
name|autoEQP
condition|)
block|{
name|sqlite3_stmt
modifier|*
name|pExplain
decl_stmt|;
name|char
modifier|*
name|zEQP
init|=
name|sqlite3_mprintf
argument_list|(
literal|"EXPLAIN QUERY PLAN %s"
argument_list|,
name|sqlite3_sql
argument_list|(
name|pStmt
argument_list|)
argument_list|)
decl_stmt|;
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|db
argument_list|,
name|zEQP
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pExplain
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|SQLITE_OK
condition|)
block|{
while|while
condition|(
name|sqlite3_step
argument_list|(
name|pExplain
argument_list|)
operator|==
name|SQLITE_ROW
condition|)
block|{
name|fprintf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"--EQP-- %d,"
argument_list|,
name|sqlite3_column_int
argument_list|(
name|pExplain
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"%d,"
argument_list|,
name|sqlite3_column_int
argument_list|(
name|pExplain
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"%d,"
argument_list|,
name|sqlite3_column_int
argument_list|(
name|pExplain
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"%s\n"
argument_list|,
name|sqlite3_column_text
argument_list|(
name|pExplain
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|sqlite3_finalize
argument_list|(
name|pExplain
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zEQP
argument_list|)
expr_stmt|;
block|}
comment|/* Output TESTCTRL_EXPLAIN text of requested */
if|if
condition|(
name|pArg
operator|&&
name|pArg
operator|->
name|mode
operator|==
name|MODE_Explain
condition|)
block|{
specifier|const
name|char
modifier|*
name|zExplain
init|=
literal|0
decl_stmt|;
name|sqlite3_test_control
argument_list|(
name|SQLITE_TESTCTRL_EXPLAIN_STMT
argument_list|,
name|pStmt
argument_list|,
operator|&
name|zExplain
argument_list|)
expr_stmt|;
if|if
condition|(
name|zExplain
operator|&&
name|zExplain
index|[
literal|0
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|pArg
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|zExplain
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the shell is currently in ".explain" mode, gather the extra       ** data required to add indents to the output.*/
if|if
condition|(
name|pArg
operator|&&
name|pArg
operator|->
name|mode
operator|==
name|MODE_Explain
condition|)
block|{
name|explain_data_prepare
argument_list|(
name|pArg
argument_list|,
name|pStmt
argument_list|)
expr_stmt|;
block|}
comment|/* perform the first step.  this will tell us if we       ** have a result set or not and how wide it is.       */
name|rc
operator|=
name|sqlite3_step
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
comment|/* if we have a result set... */
if|if
condition|(
name|SQLITE_ROW
operator|==
name|rc
condition|)
block|{
comment|/* if we have a callback... */
if|if
condition|(
name|xCallback
condition|)
block|{
comment|/* allocate space for col name ptr, value ptr, and type */
name|int
name|nCol
init|=
name|sqlite3_column_count
argument_list|(
name|pStmt
argument_list|)
decl_stmt|;
name|void
modifier|*
name|pData
init|=
name|sqlite3_malloc
argument_list|(
literal|3
operator|*
name|nCol
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|pData
condition|)
block|{
name|rc
operator|=
name|SQLITE_NOMEM
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
modifier|*
name|azCols
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|pData
decl_stmt|;
comment|/* Names of result columns */
name|char
modifier|*
modifier|*
name|azVals
init|=
operator|&
name|azCols
index|[
name|nCol
index|]
decl_stmt|;
comment|/* Results */
name|int
modifier|*
name|aiTypes
init|=
operator|(
name|int
operator|*
operator|)
operator|&
name|azVals
index|[
name|nCol
index|]
decl_stmt|;
comment|/* Result types */
name|int
name|i
decl_stmt|,
name|x
decl_stmt|;
name|assert
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* save off ptrs to column names */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nCol
condition|;
name|i
operator|++
control|)
block|{
name|azCols
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|sqlite3_column_name
argument_list|(
name|pStmt
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
do|do
block|{
comment|/* extract the data and data types */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nCol
condition|;
name|i
operator|++
control|)
block|{
name|aiTypes
index|[
name|i
index|]
operator|=
name|x
operator|=
name|sqlite3_column_type
argument_list|(
name|pStmt
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|SQLITE_BLOB
operator|&&
name|pArg
operator|&&
name|pArg
operator|->
name|mode
operator|==
name|MODE_Insert
condition|)
block|{
name|azVals
index|[
name|i
index|]
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|azVals
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pStmt
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|azVals
index|[
name|i
index|]
operator|&&
operator|(
name|aiTypes
index|[
name|i
index|]
operator|!=
name|SQLITE_NULL
operator|)
condition|)
block|{
name|rc
operator|=
name|SQLITE_NOMEM
expr_stmt|;
break|break;
comment|/* from for */
block|}
block|}
comment|/* end for */
comment|/* if data and types extracted successfully... */
if|if
condition|(
name|SQLITE_ROW
operator|==
name|rc
condition|)
block|{
comment|/* call the supplied callback with the result row data */
if|if
condition|(
name|xCallback
argument_list|(
name|pArg
argument_list|,
name|nCol
argument_list|,
name|azVals
argument_list|,
name|azCols
argument_list|,
name|aiTypes
argument_list|)
condition|)
block|{
name|rc
operator|=
name|SQLITE_ABORT
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|sqlite3_step
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|SQLITE_ROW
operator|==
name|rc
condition|)
do|;
name|sqlite3_free
argument_list|(
name|pData
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
do|do
block|{
name|rc
operator|=
name|sqlite3_step
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rc
operator|==
name|SQLITE_ROW
condition|)
do|;
block|}
block|}
name|explain_data_delete
argument_list|(
name|pArg
argument_list|)
expr_stmt|;
comment|/* print usage stats if stats on */
if|if
condition|(
name|pArg
operator|&&
name|pArg
operator|->
name|statsOn
condition|)
block|{
name|display_stats
argument_list|(
name|db
argument_list|,
name|pArg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Finalize the statement just executed. If this fails, save a        ** copy of the error message. Otherwise, set zSql to point to the       ** next statement to execute. */
name|rc2
operator|=
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_NOMEM
condition|)
name|rc
operator|=
name|rc2
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|SQLITE_OK
condition|)
block|{
name|zSql
operator|=
name|zLeftover
expr_stmt|;
while|while
condition|(
name|IsSpace
argument_list|(
name|zSql
index|[
literal|0
index|]
argument_list|)
condition|)
name|zSql
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pzErrMsg
condition|)
block|{
operator|*
name|pzErrMsg
operator|=
name|save_err_msg
argument_list|(
name|db
argument_list|)
expr_stmt|;
block|}
comment|/* clear saved stmt handle */
if|if
condition|(
name|pArg
condition|)
block|{
name|pArg
operator|->
name|pStmt
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
comment|/* end while */
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* ** This is a different callback routine used for dumping the database. ** Each row received by this callback consists of a table name, ** the table type ("index" or "table") and SQL to create the table. ** This routine should print text sufficient to recreate the table. */
end_comment

begin_function
specifier|static
name|int
name|dump_callback
parameter_list|(
name|void
modifier|*
name|pArg
parameter_list|,
name|int
name|nArg
parameter_list|,
name|char
modifier|*
modifier|*
name|azArg
parameter_list|,
name|char
modifier|*
modifier|*
name|azCol
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
specifier|const
name|char
modifier|*
name|zTable
decl_stmt|;
specifier|const
name|char
modifier|*
name|zType
decl_stmt|;
specifier|const
name|char
modifier|*
name|zSql
decl_stmt|;
specifier|const
name|char
modifier|*
name|zPrepStmt
init|=
literal|0
decl_stmt|;
name|struct
name|callback_data
modifier|*
name|p
init|=
operator|(
expr|struct
name|callback_data
operator|*
operator|)
name|pArg
decl_stmt|;
name|UNUSED_PARAMETER
argument_list|(
name|azCol
argument_list|)
expr_stmt|;
if|if
condition|(
name|nArg
operator|!=
literal|3
condition|)
return|return
literal|1
return|;
name|zTable
operator|=
name|azArg
index|[
literal|0
index|]
expr_stmt|;
name|zType
operator|=
name|azArg
index|[
literal|1
index|]
expr_stmt|;
name|zSql
operator|=
name|azArg
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|zTable
argument_list|,
literal|"sqlite_sequence"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zPrepStmt
operator|=
literal|"DELETE FROM sqlite_sequence;\n"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sqlite3_strglob
argument_list|(
literal|"sqlite_stat?"
argument_list|,
name|zTable
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"ANALYZE sqlite_master;\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|zTable
argument_list|,
literal|"sqlite_"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|zSql
argument_list|,
literal|"CREATE VIRTUAL TABLE"
argument_list|,
literal|20
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|zIns
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|writableSchema
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"PRAGMA writable_schema=ON;\n"
argument_list|)
expr_stmt|;
name|p
operator|->
name|writableSchema
operator|=
literal|1
expr_stmt|;
block|}
name|zIns
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"INSERT INTO sqlite_master(type,name,tbl_name,rootpage,sql)"
literal|"VALUES('table','%q','%q',0,'%q');"
argument_list|,
name|zTable
argument_list|,
name|zTable
argument_list|,
name|zSql
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s\n"
argument_list|,
name|zIns
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zIns
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s;\n"
argument_list|,
name|zSql
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|zType
argument_list|,
literal|"table"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sqlite3_stmt
modifier|*
name|pTableInfo
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|zSelect
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|zTableInfo
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|zTmp
init|=
literal|0
decl_stmt|;
name|int
name|nRow
init|=
literal|0
decl_stmt|;
name|zTableInfo
operator|=
name|appendText
argument_list|(
name|zTableInfo
argument_list|,
literal|"PRAGMA table_info("
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zTableInfo
operator|=
name|appendText
argument_list|(
name|zTableInfo
argument_list|,
name|zTable
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
name|zTableInfo
operator|=
name|appendText
argument_list|(
name|zTableInfo
argument_list|,
literal|");"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zTableInfo
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pTableInfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zTableInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
operator|||
operator|!
name|pTableInfo
condition|)
block|{
return|return
literal|1
return|;
block|}
name|zSelect
operator|=
name|appendText
argument_list|(
name|zSelect
argument_list|,
literal|"SELECT 'INSERT INTO ' || "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Always quote the table name, even if it appears to be pure ascii,     ** in case it is a keyword. Ex:  INSERT INTO "table" ... */
name|zTmp
operator|=
name|appendText
argument_list|(
name|zTmp
argument_list|,
name|zTable
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
if|if
condition|(
name|zTmp
condition|)
block|{
name|zSelect
operator|=
name|appendText
argument_list|(
name|zSelect
argument_list|,
name|zTmp
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zTmp
argument_list|)
expr_stmt|;
block|}
name|zSelect
operator|=
name|appendText
argument_list|(
name|zSelect
argument_list|,
literal|" || ' VALUES(' || "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_step
argument_list|(
name|pTableInfo
argument_list|)
expr_stmt|;
while|while
condition|(
name|rc
operator|==
name|SQLITE_ROW
condition|)
block|{
specifier|const
name|char
modifier|*
name|zText
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pTableInfo
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|zSelect
operator|=
name|appendText
argument_list|(
name|zSelect
argument_list|,
literal|"quote("
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zSelect
operator|=
name|appendText
argument_list|(
name|zSelect
argument_list|,
name|zText
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_step
argument_list|(
name|pTableInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|SQLITE_ROW
condition|)
block|{
name|zSelect
operator|=
name|appendText
argument_list|(
name|zSelect
argument_list|,
literal|"), "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zSelect
operator|=
name|appendText
argument_list|(
name|zSelect
argument_list|,
literal|") "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|nRow
operator|++
expr_stmt|;
block|}
name|rc
operator|=
name|sqlite3_finalize
argument_list|(
name|pTableInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
operator|||
name|nRow
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|zSelect
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|zSelect
operator|=
name|appendText
argument_list|(
name|zSelect
argument_list|,
literal|"|| ')' FROM  "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zSelect
operator|=
name|appendText
argument_list|(
name|zSelect
argument_list|,
name|zTable
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
name|rc
operator|=
name|run_table_dump_query
argument_list|(
name|p
argument_list|,
name|zSelect
argument_list|,
name|zPrepStmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|SQLITE_CORRUPT
condition|)
block|{
name|zSelect
operator|=
name|appendText
argument_list|(
name|zSelect
argument_list|,
literal|" ORDER BY rowid DESC"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|run_table_dump_query
argument_list|(
name|p
argument_list|,
name|zSelect
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|zSelect
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ** Run zQuery.  Use dump_callback() as the callback routine so that ** the contents of the query are output as SQL statements. ** ** If we get a SQLITE_CORRUPT error, rerun the query after appending ** "ORDER BY rowid DESC" to the end. */
end_comment

begin_function
specifier|static
name|int
name|run_schema_dump_query
parameter_list|(
name|struct
name|callback_data
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|zQuery
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|char
modifier|*
name|zErr
init|=
literal|0
decl_stmt|;
name|rc
operator|=
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zQuery
argument_list|,
name|dump_callback
argument_list|,
name|p
argument_list|,
operator|&
name|zErr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|SQLITE_CORRUPT
condition|)
block|{
name|char
modifier|*
name|zQ2
decl_stmt|;
name|int
name|len
init|=
name|strlen30
argument_list|(
name|zQuery
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"/****** CORRUPTION ERROR *******/\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zErr
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"/****** %s ******/\n"
argument_list|,
name|zErr
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zErr
argument_list|)
expr_stmt|;
name|zErr
operator|=
literal|0
expr_stmt|;
block|}
name|zQ2
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|zQ2
operator|==
literal|0
condition|)
return|return
name|rc
return|;
name|sqlite3_snprintf
argument_list|(
name|len
operator|+
literal|100
argument_list|,
name|zQ2
argument_list|,
literal|"%s ORDER BY rowid DESC"
argument_list|,
name|zQuery
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zQ2
argument_list|,
name|dump_callback
argument_list|,
name|p
argument_list|,
operator|&
name|zErr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"/****** ERROR: %s ******/\n"
argument_list|,
name|zErr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|SQLITE_CORRUPT
expr_stmt|;
block|}
name|sqlite3_free
argument_list|(
name|zErr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zQ2
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* ** Text of a help message */
end_comment

begin_decl_stmt
specifier|static
name|char
name|zHelp
index|[]
init|=
literal|".backup ?DB? FILE      Backup DB (default \"main\") to FILE\n"
literal|".bail on|off           Stop after hitting an error.  Default OFF\n"
literal|".clone NEWDB           Clone data into NEWDB from the existing database\n"
literal|".databases             List names and files of attached databases\n"
literal|".dump ?TABLE? ...      Dump the database in an SQL text format\n"
literal|"                         If TABLE specified, only dump tables matching\n"
literal|"                         LIKE pattern TABLE.\n"
literal|".echo on|off           Turn command echo on or off\n"
literal|".exit                  Exit this program\n"
literal|".explain ?on|off?      Turn output mode suitable for EXPLAIN on or off.\n"
literal|"                         With no args, it turns EXPLAIN on.\n"
literal|".headers on|off        Turn display of headers on or off\n"
literal|".help                  Show this message\n"
literal|".import FILE TABLE     Import data from FILE into TABLE\n"
literal|".indices ?TABLE?       Show names of all indices\n"
literal|"                         If TABLE specified, only show indices for tables\n"
literal|"                         matching LIKE pattern TABLE.\n"
ifdef|#
directive|ifdef
name|SQLITE_ENABLE_IOTRACE
literal|".iotrace FILE          Enable I/O diagnostic logging to FILE\n"
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SQLITE_OMIT_LOAD_EXTENSION
literal|".load FILE ?ENTRY?     Load an extension library\n"
endif|#
directive|endif
literal|".log FILE|off          Turn logging on or off.  FILE can be stderr/stdout\n"
literal|".mode MODE ?TABLE?     Set output mode where MODE is one of:\n"
literal|"                         csv      Comma-separated values\n"
literal|"                         column   Left-aligned columns.  (See .width)\n"
literal|"                         html     HTML<table> code\n"
literal|"                         insert   SQL insert statements for TABLE\n"
literal|"                         line     One value per line\n"
literal|"                         list     Values delimited by .separator string\n"
literal|"                         tabs     Tab-separated values\n"
literal|"                         tcl      TCL list elements\n"
literal|".nullvalue STRING      Use STRING in place of NULL values\n"
literal|".once FILENAME         Output for the next SQL command only to FILENAME\n"
literal|".open ?FILENAME?       Close existing database and reopen FILENAME\n"
literal|".output ?FILENAME?     Send output to FILENAME or stdout\n"
literal|".print STRING...       Print literal STRING\n"
literal|".prompt MAIN CONTINUE  Replace the standard prompts\n"
literal|".quit                  Exit this program\n"
literal|".read FILENAME         Execute SQL in FILENAME\n"
literal|".restore ?DB? FILE     Restore content of DB (default \"main\") from FILE\n"
literal|".save FILE             Write in-memory database into FILE\n"
literal|".schema ?TABLE?        Show the CREATE statements\n"
literal|"                         If TABLE specified, only show tables matching\n"
literal|"                         LIKE pattern TABLE.\n"
literal|".separator STRING      Change separator used by output mode and .import\n"
literal|".shell CMD ARGS...     Run CMD ARGS... in a system shell\n"
literal|".show                  Show the current values for various settings\n"
literal|".stats on|off          Turn stats on or off\n"
literal|".system CMD ARGS...    Run CMD ARGS... in a system shell\n"
literal|".tables ?TABLE?        List names of tables\n"
literal|"                         If TABLE specified, only list tables matching\n"
literal|"                         LIKE pattern TABLE.\n"
literal|".timeout MS            Try opening locked tables for MS milliseconds\n"
literal|".timer on|off          Turn SQL timer on or off\n"
literal|".trace FILE|off        Output each SQL statement as it is run\n"
literal|".vfsname ?AUX?         Print the name of the VFS stack\n"
literal|".width NUM1 NUM2 ...   Set column widths for \"column\" mode\n"
literal|"                         Negative values right-justify\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward reference */
end_comment

begin_function_decl
specifier|static
name|int
name|process_input
parameter_list|(
name|struct
name|callback_data
modifier|*
name|p
parameter_list|,
name|FILE
modifier|*
name|in
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ** Make sure the database is open.  If it is not, then open it.  If ** the database fails to open, print an error message and exit. */
end_comment

begin_function
specifier|static
name|void
name|open_db
parameter_list|(
name|struct
name|callback_data
modifier|*
name|p
parameter_list|,
name|int
name|keepAlive
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|db
operator|==
literal|0
condition|)
block|{
name|sqlite3_initialize
argument_list|()
expr_stmt|;
name|sqlite3_open
argument_list|(
name|p
operator|->
name|zDbFilename
argument_list|,
operator|&
name|p
operator|->
name|db
argument_list|)
expr_stmt|;
name|db
operator|=
name|p
operator|->
name|db
expr_stmt|;
if|if
condition|(
name|db
operator|&&
name|sqlite3_errcode
argument_list|(
name|db
argument_list|)
operator|==
name|SQLITE_OK
condition|)
block|{
name|sqlite3_create_function
argument_list|(
name|db
argument_list|,
literal|"shellstatic"
argument_list|,
literal|0
argument_list|,
name|SQLITE_UTF8
argument_list|,
literal|0
argument_list|,
name|shellstaticFunc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|db
operator|==
literal|0
operator|||
name|SQLITE_OK
operator|!=
name|sqlite3_errcode
argument_list|(
name|db
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: unable to open database \"%s\": %s\n"
argument_list|,
name|p
operator|->
name|zDbFilename
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|keepAlive
condition|)
return|return;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|SQLITE_OMIT_LOAD_EXTENSION
name|sqlite3_enable_load_extension
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* ** Do C-language style dequoting. ** **    \t    -> tab **    \n    -> newline **    \r    -> carriage return **    \"    -> " **    \NNN  -> ascii character NNN in octal **    \\    -> backslash */
end_comment

begin_function
specifier|static
name|void
name|resolve_backslashes
parameter_list|(
name|char
modifier|*
name|z
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|*
name|z
operator|&&
operator|*
name|z
operator|!=
literal|'\\'
condition|)
name|z
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
operator|(
name|c
operator|=
name|z
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|z
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'n'
condition|)
block|{
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'t'
condition|)
block|{
name|c
operator|=
literal|'\t'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'r'
condition|)
block|{
name|c
operator|=
literal|'\r'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
literal|'\\'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'7'
condition|)
block|{
name|c
operator|-=
literal|'0'
expr_stmt|;
if|if
condition|(
name|z
index|[
name|i
operator|+
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|z
index|[
name|i
operator|+
literal|1
index|]
operator|<=
literal|'7'
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|c
operator|=
operator|(
name|c
operator|<<
literal|3
operator|)
operator|+
name|z
index|[
name|i
index|]
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|z
index|[
name|i
operator|+
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|z
index|[
name|i
operator|+
literal|1
index|]
operator|<=
literal|'7'
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|c
operator|=
operator|(
name|c
operator|<<
literal|3
operator|)
operator|+
name|z
index|[
name|i
index|]
operator|-
literal|'0'
expr_stmt|;
block|}
block|}
block|}
block|}
name|z
index|[
name|j
index|]
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|<
name|i
condition|)
name|z
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Return the value of a hexadecimal digit.  Return -1 if the input ** is not a hex digit. */
end_comment

begin_function
specifier|static
name|int
name|hexDigitValue
parameter_list|(
name|char
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
return|return
name|c
operator|-
literal|'0'
return|;
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
return|return
name|c
operator|-
literal|'a'
operator|+
literal|10
return|;
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
condition|)
return|return
name|c
operator|-
literal|'A'
operator|+
literal|10
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ** Interpret zArg as an integer value, possibly with suffixes. */
end_comment

begin_function
specifier|static
name|sqlite3_int64
name|integerValue
parameter_list|(
specifier|const
name|char
modifier|*
name|zArg
parameter_list|)
block|{
name|sqlite3_int64
name|v
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
struct|struct
block|{
name|char
modifier|*
name|zSuffix
decl_stmt|;
name|int
name|iMult
decl_stmt|;
block|}
name|aMult
index|[]
init|=
block|{
block|{
literal|"KiB"
block|,
literal|1024
block|}
block|,
block|{
literal|"MiB"
block|,
literal|1024
operator|*
literal|1024
block|}
block|,
block|{
literal|"GiB"
block|,
literal|1024
operator|*
literal|1024
operator|*
literal|1024
block|}
block|,
block|{
literal|"KB"
block|,
literal|1000
block|}
block|,
block|{
literal|"MB"
block|,
literal|1000000
block|}
block|,
block|{
literal|"GB"
block|,
literal|1000000000
block|}
block|,
block|{
literal|"K"
block|,
literal|1000
block|}
block|,
block|{
literal|"M"
block|,
literal|1000000
block|}
block|,
block|{
literal|"G"
block|,
literal|1000000000
block|}
block|,   }
struct|;
name|int
name|i
decl_stmt|;
name|int
name|isNeg
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|zArg
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|isNeg
operator|=
literal|1
expr_stmt|;
name|zArg
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zArg
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
block|{
name|zArg
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|zArg
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|zArg
index|[
literal|1
index|]
operator|==
literal|'x'
condition|)
block|{
name|int
name|x
decl_stmt|;
name|zArg
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|(
name|x
operator|=
name|hexDigitValue
argument_list|(
name|zArg
index|[
literal|0
index|]
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|v
operator|=
operator|(
name|v
operator|<<
literal|4
operator|)
operator|+
name|x
expr_stmt|;
name|zArg
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|IsDigit
argument_list|(
name|zArg
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|v
operator|=
name|v
operator|*
literal|10
operator|+
name|zArg
index|[
literal|0
index|]
operator|-
literal|'0'
expr_stmt|;
name|zArg
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ArraySize
argument_list|(
name|aMult
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sqlite3_stricmp
argument_list|(
name|aMult
index|[
name|i
index|]
operator|.
name|zSuffix
argument_list|,
name|zArg
argument_list|)
operator|==
literal|0
condition|)
block|{
name|v
operator|*=
name|aMult
index|[
name|i
index|]
operator|.
name|iMult
expr_stmt|;
break|break;
block|}
block|}
return|return
name|isNeg
condition|?
operator|-
name|v
else|:
name|v
return|;
block|}
end_function

begin_comment
comment|/* ** Interpret zArg as either an integer or a boolean value.  Return 1 or 0 ** for TRUE and FALSE.  Return the integer value if appropriate. */
end_comment

begin_function
specifier|static
name|int
name|booleanValue
parameter_list|(
name|char
modifier|*
name|zArg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|zArg
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|zArg
index|[
literal|1
index|]
operator|==
literal|'x'
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|2
init|;
name|hexDigitValue
argument_list|(
name|zArg
index|[
name|i
index|]
argument_list|)
operator|>=
literal|0
condition|;
name|i
operator|++
control|)
block|{}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|zArg
index|[
name|i
index|]
operator|>=
literal|'0'
operator|&&
name|zArg
index|[
name|i
index|]
operator|<=
literal|'9'
condition|;
name|i
operator|++
control|)
block|{}
block|}
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|zArg
index|[
name|i
index|]
operator|==
literal|0
condition|)
return|return
call|(
name|int
call|)
argument_list|(
name|integerValue
argument_list|(
name|zArg
argument_list|)
operator|&
literal|0xffffffff
argument_list|)
return|;
if|if
condition|(
name|sqlite3_stricmp
argument_list|(
name|zArg
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
operator|||
name|sqlite3_stricmp
argument_list|(
name|zArg
argument_list|,
literal|"yes"
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
name|sqlite3_stricmp
argument_list|(
name|zArg
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
operator|||
name|sqlite3_stricmp
argument_list|(
name|zArg
argument_list|,
literal|"no"
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: Not a boolean value: \"%s\". Assuming \"no\".\n"
argument_list|,
name|zArg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ** Close an output file, assuming it is not stderr or stdout */
end_comment

begin_function
specifier|static
name|void
name|output_file_close
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
if|if
condition|(
name|f
operator|&&
name|f
operator|!=
name|stdout
operator|&&
name|f
operator|!=
name|stderr
condition|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Try to open an output file.   The names "stdout" and "stderr" are ** recognized and do the right thing.  NULL is returned if the output  ** filename is "off". */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|output_file_open
parameter_list|(
specifier|const
name|char
modifier|*
name|zFile
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|zFile
argument_list|,
literal|"stdout"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|f
operator|=
name|stdout
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|zFile
argument_list|,
literal|"stderr"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|f
operator|=
name|stderr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|zFile
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|f
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|f
operator|=
name|fopen
argument_list|(
name|zFile
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: cannot open \"%s\"\n"
argument_list|,
name|zFile
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|f
return|;
block|}
end_function

begin_comment
comment|/* ** A routine for handling output from sqlite3_trace(). */
end_comment

begin_function
specifier|static
name|void
name|sql_trace_callback
parameter_list|(
name|void
modifier|*
name|pArg
parameter_list|,
specifier|const
name|char
modifier|*
name|z
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
operator|(
name|FILE
operator|*
operator|)
name|pArg
decl_stmt|;
if|if
condition|(
name|f
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\n"
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** A no-op routine that runs with the ".breakpoint" doc-command.  This is ** a useful spot to set a debugger breakpoint. */
end_comment

begin_function
specifier|static
name|void
name|test_breakpoint
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|nCall
init|=
literal|0
decl_stmt|;
name|nCall
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** An object used to read a CSV file */
end_comment

begin_typedef
typedef|typedef
name|struct
name|CSVReader
name|CSVReader
typedef|;
end_typedef

begin_struct
struct|struct
name|CSVReader
block|{
specifier|const
name|char
modifier|*
name|zFile
decl_stmt|;
comment|/* Name of the input file */
name|FILE
modifier|*
name|in
decl_stmt|;
comment|/* Read the CSV text from this input stream */
name|char
modifier|*
name|z
decl_stmt|;
comment|/* Accumulated text for a field */
name|int
name|n
decl_stmt|;
comment|/* Number of bytes in z */
name|int
name|nAlloc
decl_stmt|;
comment|/* Space allocated for z[] */
name|int
name|nLine
decl_stmt|;
comment|/* Current line number */
name|int
name|cTerm
decl_stmt|;
comment|/* Character that terminated the most recent field */
name|int
name|cSeparator
decl_stmt|;
comment|/* The separator character.  (Usually ",") */
block|}
struct|;
end_struct

begin_comment
comment|/* Append a single byte to z[] */
end_comment

begin_function
specifier|static
name|void
name|csv_append_char
parameter_list|(
name|CSVReader
modifier|*
name|p
parameter_list|,
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|n
operator|+
literal|1
operator|>=
name|p
operator|->
name|nAlloc
condition|)
block|{
name|p
operator|->
name|nAlloc
operator|+=
name|p
operator|->
name|nAlloc
operator|+
literal|100
expr_stmt|;
name|p
operator|->
name|z
operator|=
name|sqlite3_realloc
argument_list|(
name|p
operator|->
name|z
argument_list|,
name|p
operator|->
name|nAlloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|z
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|p
operator|->
name|z
index|[
name|p
operator|->
name|n
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a single field of CSV text.  Compatible with rfc4180 and extended ** with the option of having a separator other than ",". ** **   +  Input comes from p->in. **   +  Store results in p->z of length p->n.  Space to hold p->z comes **      from sqlite3_malloc(). **   +  Use p->cSep as the separator.  The default is ",". **   +  Keep track of the line number in p->nLine. **   +  Store the character that terminates the field in p->cTerm.  Store **      EOF on end-of-file. **   +  Report syntax errors on stderr */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|csv_read_one_field
parameter_list|(
name|CSVReader
modifier|*
name|p
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|pc
decl_stmt|,
name|ppc
decl_stmt|;
name|int
name|cSep
init|=
name|p
operator|->
name|cSeparator
decl_stmt|;
name|p
operator|->
name|n
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|fgetc
argument_list|(
name|p
operator|->
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
operator|||
name|seenInterrupt
condition|)
block|{
name|p
operator|->
name|cTerm
operator|=
name|EOF
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|int
name|startLine
init|=
name|p
operator|->
name|nLine
decl_stmt|;
name|int
name|cQuote
init|=
name|c
decl_stmt|;
name|pc
operator|=
name|ppc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|fgetc
argument_list|(
name|p
operator|->
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|p
operator|->
name|nLine
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|cQuote
condition|)
block|{
if|if
condition|(
name|pc
operator|==
name|cQuote
condition|)
block|{
name|pc
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|(
name|c
operator|==
name|cSep
operator|&&
name|pc
operator|==
name|cQuote
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\n'
operator|&&
name|pc
operator|==
name|cQuote
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\n'
operator|&&
name|pc
operator|==
literal|'\r'
operator|&&
name|ppc
operator|==
name|cQuote
operator|)
operator|||
operator|(
name|c
operator|==
name|EOF
operator|&&
name|pc
operator|==
name|cQuote
operator|)
condition|)
block|{
do|do
block|{
name|p
operator|->
name|n
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|->
name|z
index|[
name|p
operator|->
name|n
index|]
operator|!=
name|cQuote
condition|)
do|;
name|p
operator|->
name|cTerm
operator|=
name|c
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pc
operator|==
name|cQuote
operator|&&
name|c
operator|!=
literal|'\r'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: unescaped %c character\n"
argument_list|,
name|p
operator|->
name|zFile
argument_list|,
name|p
operator|->
name|nLine
argument_list|,
name|cQuote
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: unterminated %c-quoted field\n"
argument_list|,
name|p
operator|->
name|zFile
argument_list|,
name|startLine
argument_list|,
name|cQuote
argument_list|)
expr_stmt|;
name|p
operator|->
name|cTerm
operator|=
name|EOF
expr_stmt|;
break|break;
block|}
name|csv_append_char
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|ppc
operator|=
name|pc
expr_stmt|;
name|pc
operator|=
name|c
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|c
operator|!=
name|EOF
operator|&&
name|c
operator|!=
name|cSep
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
block|{
name|csv_append_char
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|fgetc
argument_list|(
name|p
operator|->
name|in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|p
operator|->
name|nLine
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|n
operator|>
literal|0
operator|&&
name|p
operator|->
name|z
index|[
name|p
operator|->
name|n
operator|-
literal|1
index|]
operator|==
literal|'\r'
condition|)
name|p
operator|->
name|n
operator|--
expr_stmt|;
block|}
name|p
operator|->
name|cTerm
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|z
condition|)
name|p
operator|->
name|z
index|[
name|p
operator|->
name|n
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|p
operator|->
name|z
return|;
block|}
end_function

begin_comment
comment|/* ** Try to transfer data for table zTable.  If an error is seen while ** moving forward, try to go backwards.  The backwards movement won't ** work for WITHOUT ROWID tables. */
end_comment

begin_function
specifier|static
name|void
name|tryToCloneData
parameter_list|(
name|struct
name|callback_data
modifier|*
name|p
parameter_list|,
name|sqlite3
modifier|*
name|newDb
parameter_list|,
specifier|const
name|char
modifier|*
name|zTable
parameter_list|)
block|{
name|sqlite3_stmt
modifier|*
name|pQuery
init|=
literal|0
decl_stmt|;
name|sqlite3_stmt
modifier|*
name|pInsert
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|zQuery
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|zInsert
init|=
literal|0
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|;
name|int
name|nTable
init|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|zTable
argument_list|)
decl_stmt|;
name|int
name|k
init|=
literal|0
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
specifier|const
name|int
name|spinRate
init|=
literal|10000
decl_stmt|;
name|zQuery
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"SELECT * FROM \"%w\""
argument_list|,
name|zTable
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zQuery
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pQuery
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error %d: %s on [%s]\n"
argument_list|,
name|sqlite3_extended_errcode
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|,
name|zQuery
argument_list|)
expr_stmt|;
goto|goto
name|end_data_xfer
goto|;
block|}
name|n
operator|=
name|sqlite3_column_count
argument_list|(
name|pQuery
argument_list|)
expr_stmt|;
name|zInsert
operator|=
name|sqlite3_malloc
argument_list|(
literal|200
operator|+
name|nTable
operator|+
name|n
operator|*
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|zInsert
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"out of memory\n"
argument_list|)
expr_stmt|;
goto|goto
name|end_data_xfer
goto|;
block|}
name|sqlite3_snprintf
argument_list|(
literal|200
operator|+
name|nTable
argument_list|,
name|zInsert
argument_list|,
literal|"INSERT OR IGNORE INTO \"%s\" VALUES(?"
argument_list|,
name|zTable
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|zInsert
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|zInsert
operator|+
name|i
argument_list|,
literal|",?"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|zInsert
operator|+
name|i
argument_list|,
literal|");"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|newDb
argument_list|,
name|zInsert
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pInsert
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error %d: %s on [%s]\n"
argument_list|,
name|sqlite3_extended_errcode
argument_list|(
name|newDb
argument_list|)
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|newDb
argument_list|)
argument_list|,
name|zQuery
argument_list|)
expr_stmt|;
goto|goto
name|end_data_xfer
goto|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|2
condition|;
name|k
operator|++
control|)
block|{
while|while
condition|(
operator|(
name|rc
operator|=
name|sqlite3_step
argument_list|(
name|pQuery
argument_list|)
operator|)
operator|==
name|SQLITE_ROW
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|sqlite3_column_type
argument_list|(
name|pQuery
argument_list|,
name|i
argument_list|)
condition|)
block|{
case|case
name|SQLITE_NULL
case|:
block|{
name|sqlite3_bind_null
argument_list|(
name|pInsert
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SQLITE_INTEGER
case|:
block|{
name|sqlite3_bind_int64
argument_list|(
name|pInsert
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|sqlite3_column_int64
argument_list|(
name|pQuery
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SQLITE_FLOAT
case|:
block|{
name|sqlite3_bind_double
argument_list|(
name|pInsert
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|sqlite3_column_double
argument_list|(
name|pQuery
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SQLITE_TEXT
case|:
block|{
name|sqlite3_bind_text
argument_list|(
name|pInsert
argument_list|,
name|i
operator|+
literal|1
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pQuery
argument_list|,
name|i
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
name|SQLITE_STATIC
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SQLITE_BLOB
case|:
block|{
name|sqlite3_bind_blob
argument_list|(
name|pInsert
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|sqlite3_column_blob
argument_list|(
name|pQuery
argument_list|,
name|i
argument_list|)
argument_list|,
name|sqlite3_column_bytes
argument_list|(
name|pQuery
argument_list|,
name|i
argument_list|)
argument_list|,
name|SQLITE_STATIC
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* End for */
name|rc
operator|=
name|sqlite3_step
argument_list|(
name|pInsert
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
operator|&&
name|rc
operator|!=
name|SQLITE_ROW
operator|&&
name|rc
operator|!=
name|SQLITE_DONE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error %d: %s\n"
argument_list|,
name|sqlite3_extended_errcode
argument_list|(
name|newDb
argument_list|)
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|newDb
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sqlite3_reset
argument_list|(
name|pInsert
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|cnt
operator|%
name|spinRate
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%c\b"
argument_list|,
literal|"|/-\\"
index|[
operator|(
name|cnt
operator|/
name|spinRate
operator|)
operator|%
literal|4
index|]
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* End while */
if|if
condition|(
name|rc
operator|==
name|SQLITE_DONE
condition|)
break|break;
name|sqlite3_finalize
argument_list|(
name|pQuery
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zQuery
argument_list|)
expr_stmt|;
name|zQuery
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"SELECT * FROM \"%w\" ORDER BY rowid DESC;"
argument_list|,
name|zTable
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zQuery
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pQuery
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: cannot step \"%s\" backwards"
argument_list|,
name|zTable
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* End for(k=0...) */
name|end_data_xfer
label|:
name|sqlite3_finalize
argument_list|(
name|pQuery
argument_list|)
expr_stmt|;
name|sqlite3_finalize
argument_list|(
name|pInsert
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zQuery
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zInsert
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Try to transfer all rows of the schema that match zWhere.  For ** each row, invoke xForEach() on the object defined by that row. ** If an error is encountered while moving forward through the ** sqlite_master table, try again moving backwards. */
end_comment

begin_function
specifier|static
name|void
name|tryToCloneSchema
parameter_list|(
name|struct
name|callback_data
modifier|*
name|p
parameter_list|,
name|sqlite3
modifier|*
name|newDb
parameter_list|,
specifier|const
name|char
modifier|*
name|zWhere
parameter_list|,
name|void
function_decl|(
modifier|*
name|xForEach
function_decl|)
parameter_list|(
name|struct
name|callback_data
modifier|*
parameter_list|,
name|sqlite3
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
parameter_list|)
block|{
name|sqlite3_stmt
modifier|*
name|pQuery
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|zQuery
init|=
literal|0
decl_stmt|;
name|int
name|rc
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|zName
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|zSql
decl_stmt|;
name|char
modifier|*
name|zErrMsg
init|=
literal|0
decl_stmt|;
name|zQuery
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"SELECT name, sql FROM sqlite_master"
literal|" WHERE %s"
argument_list|,
name|zWhere
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zQuery
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pQuery
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: (%d) %s on [%s]\n"
argument_list|,
name|sqlite3_extended_errcode
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|,
name|zQuery
argument_list|)
expr_stmt|;
goto|goto
name|end_schema_xfer
goto|;
block|}
while|while
condition|(
operator|(
name|rc
operator|=
name|sqlite3_step
argument_list|(
name|pQuery
argument_list|)
operator|)
operator|==
name|SQLITE_ROW
condition|)
block|{
name|zName
operator|=
name|sqlite3_column_text
argument_list|(
name|pQuery
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zSql
operator|=
name|sqlite3_column_text
argument_list|(
name|pQuery
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s... "
argument_list|,
name|zName
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sqlite3_exec
argument_list|(
name|newDb
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|zSql
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|zErrMsg
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\nSQL: [%s]\n"
argument_list|,
name|zErrMsg
argument_list|,
name|zSql
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zErrMsg
argument_list|)
expr_stmt|;
name|zErrMsg
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|xForEach
condition|)
block|{
name|xForEach
argument_list|(
name|p
argument_list|,
name|newDb
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|zName
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|!=
name|SQLITE_DONE
condition|)
block|{
name|sqlite3_finalize
argument_list|(
name|pQuery
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zQuery
argument_list|)
expr_stmt|;
name|zQuery
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"SELECT name, sql FROM sqlite_master"
literal|" WHERE %s ORDER BY rowid DESC"
argument_list|,
name|zWhere
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zQuery
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pQuery
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: (%d) %s on [%s]\n"
argument_list|,
name|sqlite3_extended_errcode
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|,
name|zQuery
argument_list|)
expr_stmt|;
goto|goto
name|end_schema_xfer
goto|;
block|}
while|while
condition|(
operator|(
name|rc
operator|=
name|sqlite3_step
argument_list|(
name|pQuery
argument_list|)
operator|)
operator|==
name|SQLITE_ROW
condition|)
block|{
name|zName
operator|=
name|sqlite3_column_text
argument_list|(
name|pQuery
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zSql
operator|=
name|sqlite3_column_text
argument_list|(
name|pQuery
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s... "
argument_list|,
name|zName
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sqlite3_exec
argument_list|(
name|newDb
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|zSql
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|zErrMsg
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\nSQL: [%s]\n"
argument_list|,
name|zErrMsg
argument_list|,
name|zSql
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zErrMsg
argument_list|)
expr_stmt|;
name|zErrMsg
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|xForEach
condition|)
block|{
name|xForEach
argument_list|(
name|p
argument_list|,
name|newDb
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|zName
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|end_schema_xfer
label|:
name|sqlite3_finalize
argument_list|(
name|pQuery
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zQuery
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Open a new database file named "zNewDb".  Try to recover as much information ** as possible out of the main database (which might be corrupt) and write it ** into zNewDb. */
end_comment

begin_function
specifier|static
name|void
name|tryToClone
parameter_list|(
name|struct
name|callback_data
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|zNewDb
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|sqlite3
modifier|*
name|newDb
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|access
argument_list|(
name|zNewDb
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"File \"%s\" already exists.\n"
argument_list|,
name|zNewDb
argument_list|)
expr_stmt|;
return|return;
block|}
name|rc
operator|=
name|sqlite3_open
argument_list|(
name|zNewDb
argument_list|,
operator|&
name|newDb
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot create output database: %s\n"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|newDb
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"PRAGMA writable_schema=ON;"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_exec
argument_list|(
name|newDb
argument_list|,
literal|"BEGIN EXCLUSIVE;"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tryToCloneSchema
argument_list|(
name|p
argument_list|,
name|newDb
argument_list|,
literal|"type='table'"
argument_list|,
name|tryToCloneData
argument_list|)
expr_stmt|;
name|tryToCloneSchema
argument_list|(
name|p
argument_list|,
name|newDb
argument_list|,
literal|"type!='table'"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_exec
argument_list|(
name|newDb
argument_list|,
literal|"COMMIT;"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"PRAGMA writable_schema=OFF;"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sqlite3_close
argument_list|(
name|newDb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Change the output file back to stdout */
end_comment

begin_function
specifier|static
name|void
name|output_reset
parameter_list|(
name|struct
name|callback_data
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|outfile
index|[
literal|0
index|]
operator|==
literal|'|'
condition|)
block|{
name|pclose
argument_list|(
name|p
operator|->
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_file_close
argument_list|(
name|p
operator|->
name|out
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|outfile
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|out
operator|=
name|stdout
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** If an input line begins with "." then invoke this routine to ** process that line. ** ** Return 1 on error, 2 to exit, and 0 otherwise. */
end_comment

begin_function
specifier|static
name|int
name|do_meta_command
parameter_list|(
name|char
modifier|*
name|zLine
parameter_list|,
name|struct
name|callback_data
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
init|=
literal|1
decl_stmt|;
name|int
name|nArg
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|,
name|c
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|azArg
index|[
literal|50
index|]
decl_stmt|;
comment|/* Parse the input line into tokens.   */
while|while
condition|(
name|zLine
index|[
name|i
index|]
operator|&&
name|nArg
operator|<
name|ArraySize
argument_list|(
name|azArg
argument_list|)
condition|)
block|{
while|while
condition|(
name|IsSpace
argument_list|(
name|zLine
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|zLine
index|[
name|i
index|]
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|zLine
index|[
name|i
index|]
operator|==
literal|'\''
operator|||
name|zLine
index|[
name|i
index|]
operator|==
literal|'"'
condition|)
block|{
name|int
name|delim
init|=
name|zLine
index|[
name|i
operator|++
index|]
decl_stmt|;
name|azArg
index|[
name|nArg
operator|++
index|]
operator|=
operator|&
name|zLine
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|zLine
index|[
name|i
index|]
operator|&&
name|zLine
index|[
name|i
index|]
operator|!=
name|delim
condition|)
block|{
if|if
condition|(
name|zLine
index|[
name|i
index|]
operator|==
literal|'\\'
operator|&&
name|delim
operator|==
literal|'"'
operator|&&
name|zLine
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|0
condition|)
name|i
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|zLine
index|[
name|i
index|]
operator|==
name|delim
condition|)
block|{
name|zLine
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|delim
operator|==
literal|'"'
condition|)
name|resolve_backslashes
argument_list|(
name|azArg
index|[
name|nArg
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|azArg
index|[
name|nArg
operator|++
index|]
operator|=
operator|&
name|zLine
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|zLine
index|[
name|i
index|]
operator|&&
operator|!
name|IsSpace
argument_list|(
name|zLine
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|zLine
index|[
name|i
index|]
condition|)
name|zLine
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|resolve_backslashes
argument_list|(
name|azArg
index|[
name|nArg
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process the input line.   */
if|if
condition|(
name|nArg
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* no tokens, no error */
name|n
operator|=
name|strlen30
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|c
operator|=
name|azArg
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'b'
operator|&&
name|n
operator|>=
literal|3
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"backup"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|c
operator|==
literal|'s'
operator|&&
name|n
operator|>=
literal|3
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"save"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|zDestFile
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|zDb
init|=
literal|0
decl_stmt|;
name|sqlite3
modifier|*
name|pDest
decl_stmt|;
name|sqlite3_backup
modifier|*
name|pBackup
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|nArg
condition|;
name|j
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|z
init|=
name|azArg
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|z
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
while|while
condition|(
name|z
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|z
operator|++
expr_stmt|;
comment|/* No options to process at this time */
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unknown option: %s\n"
argument_list|,
name|azArg
index|[
name|j
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|zDestFile
operator|==
literal|0
condition|)
block|{
name|zDestFile
operator|=
name|azArg
index|[
name|j
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zDb
operator|==
literal|0
condition|)
block|{
name|zDb
operator|=
name|zDestFile
expr_stmt|;
name|zDestFile
operator|=
name|azArg
index|[
name|j
index|]
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"too many arguments to .backup\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|zDestFile
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"missing FILENAME argument on .backup\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|zDb
operator|==
literal|0
condition|)
name|zDb
operator|=
literal|"main"
expr_stmt|;
name|rc
operator|=
name|sqlite3_open
argument_list|(
name|zDestFile
argument_list|,
operator|&
name|pDest
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: cannot open \"%s\"\n"
argument_list|,
name|zDestFile
argument_list|)
expr_stmt|;
name|sqlite3_close
argument_list|(
name|pDest
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pBackup
operator|=
name|sqlite3_backup_init
argument_list|(
name|pDest
argument_list|,
literal|"main"
argument_list|,
name|p
operator|->
name|db
argument_list|,
name|zDb
argument_list|)
expr_stmt|;
if|if
condition|(
name|pBackup
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|pDest
argument_list|)
argument_list|)
expr_stmt|;
name|sqlite3_close
argument_list|(
name|pDest
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
while|while
condition|(
operator|(
name|rc
operator|=
name|sqlite3_backup_step
argument_list|(
name|pBackup
argument_list|,
literal|100
argument_list|)
operator|)
operator|==
name|SQLITE_OK
condition|)
block|{}
name|sqlite3_backup_finish
argument_list|(
name|pBackup
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|SQLITE_DONE
condition|)
block|{
name|rc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|pDest
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
name|sqlite3_close
argument_list|(
name|pDest
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'b'
operator|&&
name|n
operator|>=
literal|3
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"bail"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|==
literal|2
condition|)
block|{
name|bail_on_error
operator|=
name|booleanValue
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .bail on|off\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
comment|/* The undocumented ".breakpoint" command causes a call to the no-op   ** routine named test_breakpoint().   */
if|if
condition|(
name|c
operator|==
literal|'b'
operator|&&
name|n
operator|>=
literal|3
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"breakpoint"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|test_breakpoint
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'c'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"clone"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|==
literal|2
condition|)
block|{
name|tryToClone
argument_list|(
name|p
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .clone FILENAME\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'d'
operator|&&
name|n
operator|>
literal|1
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"databases"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|callback_data
name|data
decl_stmt|;
name|char
modifier|*
name|zErrMsg
init|=
literal|0
decl_stmt|;
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|data
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|showHeader
operator|=
literal|1
expr_stmt|;
name|data
operator|.
name|mode
operator|=
name|MODE_Column
expr_stmt|;
name|data
operator|.
name|colWidth
index|[
literal|0
index|]
operator|=
literal|3
expr_stmt|;
name|data
operator|.
name|colWidth
index|[
literal|1
index|]
operator|=
literal|15
expr_stmt|;
name|data
operator|.
name|colWidth
index|[
literal|2
index|]
operator|=
literal|58
expr_stmt|;
name|data
operator|.
name|cnt
operator|=
literal|0
expr_stmt|;
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"PRAGMA database_list; "
argument_list|,
name|callback
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|zErrMsg
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|zErrMsg
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zErrMsg
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'d'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"dump"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* When playing back a "dump", the content might appear in an order     ** which causes immediate foreign key constraints to be violated.     ** So disable foreign-key constraint enforcement to prevent problems. */
if|if
condition|(
name|nArg
operator|!=
literal|1
operator|&&
name|nArg
operator|!=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .dump ?LIKE-PATTERN?\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"PRAGMA foreign_keys=OFF;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"BEGIN TRANSACTION;\n"
argument_list|)
expr_stmt|;
name|p
operator|->
name|writableSchema
operator|=
literal|0
expr_stmt|;
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"SAVEPOINT dump; PRAGMA writable_schema=ON"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|nErr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nArg
operator|==
literal|1
condition|)
block|{
name|run_schema_dump_query
argument_list|(
name|p
argument_list|,
literal|"SELECT name, type, sql FROM sqlite_master "
literal|"WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence'"
argument_list|)
expr_stmt|;
name|run_schema_dump_query
argument_list|(
name|p
argument_list|,
literal|"SELECT name, type, sql FROM sqlite_master "
literal|"WHERE name=='sqlite_sequence'"
argument_list|)
expr_stmt|;
name|run_table_dump_query
argument_list|(
name|p
argument_list|,
literal|"SELECT sql FROM sqlite_master "
literal|"WHERE sql NOT NULL AND type IN ('index','trigger','view')"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|zShellStatic
operator|=
name|azArg
index|[
name|i
index|]
expr_stmt|;
name|run_schema_dump_query
argument_list|(
name|p
argument_list|,
literal|"SELECT name, type, sql FROM sqlite_master "
literal|"WHERE tbl_name LIKE shellstatic() AND type=='table'"
literal|"  AND sql NOT NULL"
argument_list|)
expr_stmt|;
name|run_table_dump_query
argument_list|(
name|p
argument_list|,
literal|"SELECT sql FROM sqlite_master "
literal|"WHERE sql NOT NULL"
literal|"  AND type IN ('index','trigger','view')"
literal|"  AND tbl_name LIKE shellstatic()"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zShellStatic
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|writableSchema
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"PRAGMA writable_schema=OFF;\n"
argument_list|)
expr_stmt|;
name|p
operator|->
name|writableSchema
operator|=
literal|0
expr_stmt|;
block|}
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"PRAGMA writable_schema=OFF;"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"RELEASE dump;"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|p
operator|->
name|nErr
condition|?
literal|"ROLLBACK; -- due to errors\n"
else|:
literal|"COMMIT;\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'e'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"echo"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|==
literal|2
condition|)
block|{
name|p
operator|->
name|echoOn
operator|=
name|booleanValue
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .echo on|off\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'e'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"eqp"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|==
literal|2
condition|)
block|{
name|p
operator|->
name|autoEQP
operator|=
name|booleanValue
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .eqp on|off\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'e'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"exit"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|>
literal|1
operator|&&
operator|(
name|rc
operator|=
operator|(
name|int
operator|)
name|integerValue
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|exit
argument_list|(
name|rc
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'e'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"explain"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|val
init|=
name|nArg
operator|>=
literal|2
condition|?
name|booleanValue
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
else|:
literal|1
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|explainPrev
operator|.
name|valid
condition|)
block|{
name|p
operator|->
name|explainPrev
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|explainPrev
operator|.
name|mode
operator|=
name|p
operator|->
name|mode
expr_stmt|;
name|p
operator|->
name|explainPrev
operator|.
name|showHeader
operator|=
name|p
operator|->
name|showHeader
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|explainPrev
operator|.
name|colWidth
argument_list|,
name|p
operator|->
name|colWidth
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|colWidth
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We could put this code under the !p->explainValid       ** condition so that it does not execute if we are already in       ** explain mode. However, always executing it allows us an easy       ** was to reset to explain mode in case the user previously       ** did an .explain followed by a .width, .mode or .header       ** command.       */
name|p
operator|->
name|mode
operator|=
name|MODE_Explain
expr_stmt|;
name|p
operator|->
name|showHeader
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
name|p
operator|->
name|colWidth
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|colWidth
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|colWidth
index|[
literal|0
index|]
operator|=
literal|4
expr_stmt|;
comment|/* addr */
name|p
operator|->
name|colWidth
index|[
literal|1
index|]
operator|=
literal|13
expr_stmt|;
comment|/* opcode */
name|p
operator|->
name|colWidth
index|[
literal|2
index|]
operator|=
literal|4
expr_stmt|;
comment|/* P1 */
name|p
operator|->
name|colWidth
index|[
literal|3
index|]
operator|=
literal|4
expr_stmt|;
comment|/* P2 */
name|p
operator|->
name|colWidth
index|[
literal|4
index|]
operator|=
literal|4
expr_stmt|;
comment|/* P3 */
name|p
operator|->
name|colWidth
index|[
literal|5
index|]
operator|=
literal|13
expr_stmt|;
comment|/* P4 */
name|p
operator|->
name|colWidth
index|[
literal|6
index|]
operator|=
literal|2
expr_stmt|;
comment|/* P5 */
name|p
operator|->
name|colWidth
index|[
literal|7
index|]
operator|=
literal|13
expr_stmt|;
comment|/* Comment */
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|explainPrev
operator|.
name|valid
condition|)
block|{
name|p
operator|->
name|explainPrev
operator|.
name|valid
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|mode
operator|=
name|p
operator|->
name|explainPrev
operator|.
name|mode
expr_stmt|;
name|p
operator|->
name|showHeader
operator|=
name|p
operator|->
name|explainPrev
operator|.
name|showHeader
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|colWidth
argument_list|,
name|p
operator|->
name|explainPrev
operator|.
name|colWidth
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|colWidth
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'h'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"headers"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|==
literal|2
condition|)
block|{
name|p
operator|->
name|showHeader
operator|=
name|booleanValue
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .headers on|off\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'h'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"help"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|zHelp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'i'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"import"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|zTable
decl_stmt|;
comment|/* Insert data into this table */
name|char
modifier|*
name|zFile
decl_stmt|;
comment|/* Name of file to extra content from */
name|sqlite3_stmt
modifier|*
name|pStmt
init|=
name|NULL
decl_stmt|;
comment|/* A statement */
name|int
name|nCol
decl_stmt|;
comment|/* Number of columns in the table */
name|int
name|nByte
decl_stmt|;
comment|/* Number of bytes in an SQL string */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Loop counters */
name|int
name|needCommit
decl_stmt|;
comment|/* True to COMMIT or ROLLBACK at end */
name|int
name|nSep
decl_stmt|;
comment|/* Number of bytes in p->separator[] */
name|char
modifier|*
name|zSql
decl_stmt|;
comment|/* An SQL statement */
name|CSVReader
name|sCsv
decl_stmt|;
comment|/* Reader context */
name|int
function_decl|(
modifier|*
name|xCloser
function_decl|)
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
comment|/* Procedure to close th3 connection */
if|if
condition|(
name|nArg
operator|!=
literal|3
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .import FILE TABLE\n"
argument_list|)
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
name|zFile
operator|=
name|azArg
index|[
literal|1
index|]
expr_stmt|;
name|zTable
operator|=
name|azArg
index|[
literal|2
index|]
expr_stmt|;
name|seenInterrupt
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sCsv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sCsv
argument_list|)
argument_list|)
expr_stmt|;
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nSep
operator|=
name|strlen30
argument_list|(
name|p
operator|->
name|separator
argument_list|)
expr_stmt|;
if|if
condition|(
name|nSep
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: non-null separator required for import\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|nSep
operator|>
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: multi-character separators not allowed"
literal|" for import\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|sCsv
operator|.
name|zFile
operator|=
name|zFile
expr_stmt|;
name|sCsv
operator|.
name|nLine
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sCsv
operator|.
name|zFile
index|[
literal|0
index|]
operator|==
literal|'|'
condition|)
block|{
name|sCsv
operator|.
name|in
operator|=
name|popen
argument_list|(
name|sCsv
operator|.
name|zFile
operator|+
literal|1
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|sCsv
operator|.
name|zFile
operator|=
literal|"<pipe>"
expr_stmt|;
name|xCloser
operator|=
name|pclose
expr_stmt|;
block|}
else|else
block|{
name|sCsv
operator|.
name|in
operator|=
name|fopen
argument_list|(
name|sCsv
operator|.
name|zFile
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
name|xCloser
operator|=
name|fclose
expr_stmt|;
block|}
if|if
condition|(
name|sCsv
operator|.
name|in
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: cannot open \"%s\"\n"
argument_list|,
name|zFile
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|sCsv
operator|.
name|cSeparator
operator|=
name|p
operator|->
name|separator
index|[
literal|0
index|]
expr_stmt|;
name|zSql
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"SELECT * FROM %s"
argument_list|,
name|zTable
argument_list|)
expr_stmt|;
if|if
condition|(
name|zSql
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: out of memory\n"
argument_list|)
expr_stmt|;
name|xCloser
argument_list|(
name|sCsv
operator|.
name|in
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|nByte
operator|=
name|strlen30
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zSql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|csv_append_char
argument_list|(
operator|&
name|sCsv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* To ensure sCsv.z is allocated */
if|if
condition|(
name|rc
operator|&&
name|sqlite3_strglob
argument_list|(
literal|"no such table: *"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|db
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|zCreate
init|=
name|sqlite3_mprintf
argument_list|(
literal|"CREATE TABLE %s"
argument_list|,
name|zTable
argument_list|)
decl_stmt|;
name|char
name|cSep
init|=
literal|'('
decl_stmt|;
while|while
condition|(
name|csv_read_one_field
argument_list|(
operator|&
name|sCsv
argument_list|)
condition|)
block|{
name|zCreate
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"%z%c\n  \"%s\" TEXT"
argument_list|,
name|zCreate
argument_list|,
name|cSep
argument_list|,
name|sCsv
operator|.
name|z
argument_list|)
expr_stmt|;
name|cSep
operator|=
literal|','
expr_stmt|;
if|if
condition|(
name|sCsv
operator|.
name|cTerm
operator|!=
name|sCsv
operator|.
name|cSeparator
condition|)
break|break;
block|}
if|if
condition|(
name|cSep
operator|==
literal|'('
condition|)
block|{
name|sqlite3_free
argument_list|(
name|zCreate
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|sCsv
operator|.
name|z
argument_list|)
expr_stmt|;
name|xCloser
argument_list|(
name|sCsv
operator|.
name|in
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: empty file\n"
argument_list|,
name|sCsv
operator|.
name|zFile
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|zCreate
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"%z\n)"
argument_list|,
name|zCreate
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zCreate
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zCreate
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"CREATE TABLE %s(...) failed: %s\n"
argument_list|,
name|zTable
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|sCsv
operator|.
name|z
argument_list|)
expr_stmt|;
name|xCloser
argument_list|(
name|sCsv
operator|.
name|in
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zSql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sqlite3_free
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
if|if
condition|(
name|pStmt
condition|)
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|xCloser
argument_list|(
name|sCsv
operator|.
name|in
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|nCol
operator|=
name|sqlite3_column_count
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|pStmt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nCol
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* no columns, no error */
name|zSql
operator|=
name|sqlite3_malloc
argument_list|(
name|nByte
operator|*
literal|2
operator|+
literal|20
operator|+
name|nCol
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|zSql
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: out of memory\n"
argument_list|)
expr_stmt|;
name|xCloser
argument_list|(
name|sCsv
operator|.
name|in
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|sqlite3_snprintf
argument_list|(
name|nByte
operator|+
literal|20
argument_list|,
name|zSql
argument_list|,
literal|"INSERT INTO \"%w\" VALUES(?"
argument_list|,
name|zTable
argument_list|)
expr_stmt|;
name|j
operator|=
name|strlen30
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nCol
condition|;
name|i
operator|++
control|)
block|{
name|zSql
index|[
name|j
operator|++
index|]
operator|=
literal|','
expr_stmt|;
name|zSql
index|[
name|j
operator|++
index|]
operator|=
literal|'?'
expr_stmt|;
block|}
name|zSql
index|[
name|j
operator|++
index|]
operator|=
literal|')'
expr_stmt|;
name|zSql
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zSql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pStmt
condition|)
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|xCloser
argument_list|(
name|sCsv
operator|.
name|in
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|needCommit
operator|=
name|sqlite3_get_autocommit
argument_list|(
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|needCommit
condition|)
name|sqlite3_exec
argument_list|(
name|db
argument_list|,
literal|"BEGIN"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
do|do
block|{
name|int
name|startLine
init|=
name|sCsv
operator|.
name|nLine
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nCol
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|z
init|=
name|csv_read_one_field
argument_list|(
operator|&
name|sCsv
argument_list|)
decl_stmt|;
if|if
condition|(
name|z
operator|==
literal|0
operator|&&
name|i
operator|==
literal|0
condition|)
break|break;
name|sqlite3_bind_text
argument_list|(
name|pStmt
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|z
argument_list|,
operator|-
literal|1
argument_list|,
name|SQLITE_TRANSIENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|nCol
operator|-
literal|1
operator|&&
name|sCsv
operator|.
name|cTerm
operator|!=
name|sCsv
operator|.
name|cSeparator
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: expected %d columns but found %d - "
literal|"filling the rest with NULL\n"
argument_list|,
name|sCsv
operator|.
name|zFile
argument_list|,
name|startLine
argument_list|,
name|nCol
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|nCol
condition|)
block|{
name|sqlite3_bind_null
argument_list|(
name|pStmt
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|sCsv
operator|.
name|cTerm
operator|==
name|sCsv
operator|.
name|cSeparator
condition|)
block|{
do|do
block|{
name|csv_read_one_field
argument_list|(
operator|&
name|sCsv
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|sCsv
operator|.
name|cTerm
operator|==
name|sCsv
operator|.
name|cSeparator
condition|)
do|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: expected %d columns but found %d - "
literal|"extras ignored\n"
argument_list|,
name|sCsv
operator|.
name|zFile
argument_list|,
name|startLine
argument_list|,
name|nCol
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|nCol
condition|)
block|{
name|sqlite3_step
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_reset
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: INSERT failed: %s\n"
argument_list|,
name|sCsv
operator|.
name|zFile
argument_list|,
name|startLine
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|sCsv
operator|.
name|cTerm
operator|!=
name|EOF
condition|)
do|;
name|xCloser
argument_list|(
name|sCsv
operator|.
name|in
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|sCsv
operator|.
name|z
argument_list|)
expr_stmt|;
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|needCommit
condition|)
name|sqlite3_exec
argument_list|(
name|db
argument_list|,
literal|"COMMIT"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'i'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"indices"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|callback_data
name|data
decl_stmt|;
name|char
modifier|*
name|zErrMsg
init|=
literal|0
decl_stmt|;
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|data
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|showHeader
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|mode
operator|=
name|MODE_List
expr_stmt|;
if|if
condition|(
name|nArg
operator|==
literal|1
condition|)
block|{
name|rc
operator|=
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"SELECT name FROM sqlite_master "
literal|"WHERE type='index' AND name NOT LIKE 'sqlite_%' "
literal|"UNION ALL "
literal|"SELECT name FROM sqlite_temp_master "
literal|"WHERE type='index' "
literal|"ORDER BY 1"
argument_list|,
name|callback
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nArg
operator|==
literal|2
condition|)
block|{
name|zShellStatic
operator|=
name|azArg
index|[
literal|1
index|]
expr_stmt|;
name|rc
operator|=
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"SELECT name FROM sqlite_master "
literal|"WHERE type='index' AND tbl_name LIKE shellstatic() "
literal|"UNION ALL "
literal|"SELECT name FROM sqlite_temp_master "
literal|"WHERE type='index' AND tbl_name LIKE shellstatic() "
literal|"ORDER BY 1"
argument_list|,
name|callback
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
name|zShellStatic
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .indices ?LIKE-PATTERN?\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
if|if
condition|(
name|zErrMsg
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|zErrMsg
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zErrMsg
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: querying sqlite_master and sqlite_temp_master\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
ifdef|#
directive|ifdef
name|SQLITE_ENABLE_IOTRACE
if|if
condition|(
name|c
operator|==
literal|'i'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"iotrace"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|extern
name|void
function_decl|(
modifier|*
name|sqlite3IoTrace
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
if|if
condition|(
name|iotrace
operator|&&
name|iotrace
operator|!=
name|stdout
condition|)
name|fclose
argument_list|(
name|iotrace
argument_list|)
expr_stmt|;
name|iotrace
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nArg
operator|<
literal|2
condition|)
block|{
name|sqlite3IoTrace
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sqlite3IoTrace
operator|=
name|iotracePrintf
expr_stmt|;
name|iotrace
operator|=
name|stdout
expr_stmt|;
block|}
else|else
block|{
name|iotrace
operator|=
name|fopen
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|iotrace
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: cannot open \"%s\"\n"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sqlite3IoTrace
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sqlite3IoTrace
operator|=
name|iotracePrintf
expr_stmt|;
block|}
block|}
block|}
elseif|else
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SQLITE_OMIT_LOAD_EXTENSION
if|if
condition|(
name|c
operator|==
literal|'l'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"load"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|zFile
decl_stmt|,
modifier|*
name|zProc
decl_stmt|;
name|char
modifier|*
name|zErrMsg
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nArg
operator|<
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .load FILE ?ENTRYPOINT?\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
name|zFile
operator|=
name|azArg
index|[
literal|1
index|]
expr_stmt|;
name|zProc
operator|=
name|nArg
operator|>=
literal|3
condition|?
name|azArg
index|[
literal|2
index|]
else|:
literal|0
expr_stmt|;
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_load_extension
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zFile
argument_list|,
name|zProc
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|zErrMsg
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zErrMsg
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
literal|'l'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"log"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|!=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .log FILENAME\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|zFile
init|=
name|azArg
index|[
literal|1
index|]
decl_stmt|;
name|output_file_close
argument_list|(
name|p
operator|->
name|pLog
argument_list|)
expr_stmt|;
name|p
operator|->
name|pLog
operator|=
name|output_file_open
argument_list|(
name|zFile
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'m'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"mode"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|zMode
init|=
name|nArg
operator|>=
literal|2
condition|?
name|azArg
index|[
literal|1
index|]
else|:
literal|""
decl_stmt|;
name|int
name|n2
init|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|zMode
argument_list|)
decl_stmt|;
name|int
name|c2
init|=
name|zMode
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|c2
operator|==
literal|'l'
operator|&&
name|n2
operator|>
literal|2
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"lines"
argument_list|,
name|n2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|mode
operator|=
name|MODE_Line
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c2
operator|==
literal|'c'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"columns"
argument_list|,
name|n2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|mode
operator|=
name|MODE_Column
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c2
operator|==
literal|'l'
operator|&&
name|n2
operator|>
literal|2
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"list"
argument_list|,
name|n2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|mode
operator|=
name|MODE_List
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c2
operator|==
literal|'h'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"html"
argument_list|,
name|n2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|mode
operator|=
name|MODE_Html
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c2
operator|==
literal|'t'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"tcl"
argument_list|,
name|n2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|mode
operator|=
name|MODE_Tcl
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|separator
argument_list|)
argument_list|,
name|p
operator|->
name|separator
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c2
operator|==
literal|'c'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"csv"
argument_list|,
name|n2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|mode
operator|=
name|MODE_Csv
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|separator
argument_list|)
argument_list|,
name|p
operator|->
name|separator
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c2
operator|==
literal|'t'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"tabs"
argument_list|,
name|n2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|mode
operator|=
name|MODE_List
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|separator
argument_list|)
argument_list|,
name|p
operator|->
name|separator
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c2
operator|==
literal|'i'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"insert"
argument_list|,
name|n2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|mode
operator|=
name|MODE_Insert
expr_stmt|;
name|set_table_name
argument_list|(
name|p
argument_list|,
name|nArg
operator|>=
literal|3
condition|?
name|azArg
index|[
literal|2
index|]
else|:
literal|"table"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: mode should be one of: "
literal|"column csv html insert line list tabs tcl\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'n'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"nullvalue"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|==
literal|2
condition|)
block|{
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|nullvalue
argument_list|)
argument_list|,
name|p
operator|->
name|nullvalue
argument_list|,
literal|"%.*s"
argument_list|,
operator|(
name|int
operator|)
name|ArraySize
argument_list|(
name|p
operator|->
name|nullvalue
argument_list|)
operator|-
literal|1
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .nullvalue STRING\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'o'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"open"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|&&
name|n
operator|>=
literal|2
condition|)
block|{
name|sqlite3
modifier|*
name|savedDb
init|=
name|p
operator|->
name|db
decl_stmt|;
specifier|const
name|char
modifier|*
name|zSavedFilename
init|=
name|p
operator|->
name|zDbFilename
decl_stmt|;
name|char
modifier|*
name|zNewFilename
init|=
literal|0
decl_stmt|;
name|p
operator|->
name|db
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nArg
operator|>=
literal|2
condition|)
block|{
name|p
operator|->
name|zDbFilename
operator|=
name|zNewFilename
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"%s"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|open_db
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|db
operator|!=
literal|0
condition|)
block|{
name|sqlite3_close
argument_list|(
name|savedDb
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|p
operator|->
name|zFreeOnClose
argument_list|)
expr_stmt|;
name|p
operator|->
name|zFreeOnClose
operator|=
name|zNewFilename
expr_stmt|;
block|}
else|else
block|{
name|sqlite3_free
argument_list|(
name|zNewFilename
argument_list|)
expr_stmt|;
name|p
operator|->
name|db
operator|=
name|savedDb
expr_stmt|;
name|p
operator|->
name|zDbFilename
operator|=
name|zSavedFilename
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'o'
operator|&&
operator|(
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"output"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"once"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|zFile
init|=
name|nArg
operator|>=
literal|2
condition|?
name|azArg
index|[
literal|1
index|]
else|:
literal|"stdout"
decl_stmt|;
if|if
condition|(
name|nArg
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .%s FILE\n"
argument_list|,
name|azArg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
if|if
condition|(
name|n
operator|>
literal|1
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"once"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|<
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .once FILE\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
name|p
operator|->
name|outCount
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|outCount
operator|=
literal|0
expr_stmt|;
block|}
name|output_reset
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|zFile
index|[
literal|0
index|]
operator|==
literal|'|'
condition|)
block|{
name|p
operator|->
name|out
operator|=
name|popen
argument_list|(
name|zFile
operator|+
literal|1
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|out
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: cannot open pipe \"%s\"\n"
argument_list|,
name|zFile
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|->
name|out
operator|=
name|stdout
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|outfile
argument_list|)
argument_list|,
name|p
operator|->
name|outfile
argument_list|,
literal|"%s"
argument_list|,
name|zFile
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|p
operator|->
name|out
operator|=
name|output_file_open
argument_list|(
name|zFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|out
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|zFile
argument_list|,
literal|"off"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: cannot write to \"%s\"\n"
argument_list|,
name|zFile
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|out
operator|=
name|stdout
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|outfile
argument_list|)
argument_list|,
name|p
operator|->
name|outfile
argument_list|,
literal|"%s"
argument_list|,
name|zFile
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'p'
operator|&&
name|n
operator|>=
literal|3
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"print"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'p'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"prompt"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|>=
literal|2
condition|)
block|{
name|strncpy
argument_list|(
name|mainPrompt
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|,
operator|(
name|int
operator|)
name|ArraySize
argument_list|(
name|mainPrompt
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nArg
operator|>=
literal|3
condition|)
block|{
name|strncpy
argument_list|(
name|continuePrompt
argument_list|,
name|azArg
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|)
name|ArraySize
argument_list|(
name|continuePrompt
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'q'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"quit"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'r'
operator|&&
name|n
operator|>=
literal|3
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"read"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|FILE
modifier|*
name|alt
decl_stmt|;
if|if
condition|(
name|nArg
operator|!=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .read FILE\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
name|alt
operator|=
name|fopen
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|alt
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: cannot open \"%s\"\n"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|process_input
argument_list|(
name|p
argument_list|,
name|alt
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|alt
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'r'
operator|&&
name|n
operator|>=
literal|3
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"restore"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|zSrcFile
decl_stmt|;
specifier|const
name|char
modifier|*
name|zDb
decl_stmt|;
name|sqlite3
modifier|*
name|pSrc
decl_stmt|;
name|sqlite3_backup
modifier|*
name|pBackup
decl_stmt|;
name|int
name|nTimeout
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nArg
operator|==
literal|2
condition|)
block|{
name|zSrcFile
operator|=
name|azArg
index|[
literal|1
index|]
expr_stmt|;
name|zDb
operator|=
literal|"main"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nArg
operator|==
literal|3
condition|)
block|{
name|zSrcFile
operator|=
name|azArg
index|[
literal|2
index|]
expr_stmt|;
name|zDb
operator|=
name|azArg
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .restore ?DB? FILE\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
name|rc
operator|=
name|sqlite3_open
argument_list|(
name|zSrcFile
argument_list|,
operator|&
name|pSrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: cannot open \"%s\"\n"
argument_list|,
name|zSrcFile
argument_list|)
expr_stmt|;
name|sqlite3_close
argument_list|(
name|pSrc
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pBackup
operator|=
name|sqlite3_backup_init
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zDb
argument_list|,
name|pSrc
argument_list|,
literal|"main"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pBackup
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|sqlite3_close
argument_list|(
name|pSrc
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
while|while
condition|(
operator|(
name|rc
operator|=
name|sqlite3_backup_step
argument_list|(
name|pBackup
argument_list|,
literal|100
argument_list|)
operator|)
operator|==
name|SQLITE_OK
operator|||
name|rc
operator|==
name|SQLITE_BUSY
condition|)
block|{
if|if
condition|(
name|rc
operator|==
name|SQLITE_BUSY
condition|)
block|{
if|if
condition|(
name|nTimeout
operator|++
operator|>=
literal|3
condition|)
break|break;
name|sqlite3_sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
name|sqlite3_backup_finish
argument_list|(
name|pBackup
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|SQLITE_DONE
condition|)
block|{
name|rc
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|==
name|SQLITE_BUSY
operator|||
name|rc
operator|==
name|SQLITE_LOCKED
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: source database is busy\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
name|sqlite3_close
argument_list|(
name|pSrc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'s'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"schema"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|callback_data
name|data
decl_stmt|;
name|char
modifier|*
name|zErrMsg
init|=
literal|0
decl_stmt|;
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|data
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|showHeader
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|mode
operator|=
name|MODE_Semi
expr_stmt|;
if|if
condition|(
name|nArg
operator|==
literal|2
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|azArg
index|[
literal|1
index|]
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|azArg
index|[
literal|1
index|]
index|[
name|i
index|]
operator|=
name|ToLower
argument_list|(
name|azArg
index|[
literal|1
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"sqlite_master"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|new_argv
index|[
literal|2
index|]
decl_stmt|,
modifier|*
name|new_colv
index|[
literal|2
index|]
decl_stmt|;
name|new_argv
index|[
literal|0
index|]
operator|=
literal|"CREATE TABLE sqlite_master (\n"
literal|"  type text,\n"
literal|"  name text,\n"
literal|"  tbl_name text,\n"
literal|"  rootpage integer,\n"
literal|"  sql text\n"
literal|")"
expr_stmt|;
name|new_argv
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|new_colv
index|[
literal|0
index|]
operator|=
literal|"sql"
expr_stmt|;
name|new_colv
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|callback
argument_list|(
operator|&
name|data
argument_list|,
literal|1
argument_list|,
name|new_argv
argument_list|,
name|new_colv
argument_list|)
expr_stmt|;
name|rc
operator|=
name|SQLITE_OK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"sqlite_temp_master"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|new_argv
index|[
literal|2
index|]
decl_stmt|,
modifier|*
name|new_colv
index|[
literal|2
index|]
decl_stmt|;
name|new_argv
index|[
literal|0
index|]
operator|=
literal|"CREATE TEMP TABLE sqlite_temp_master (\n"
literal|"  type text,\n"
literal|"  name text,\n"
literal|"  tbl_name text,\n"
literal|"  rootpage integer,\n"
literal|"  sql text\n"
literal|")"
expr_stmt|;
name|new_argv
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|new_colv
index|[
literal|0
index|]
operator|=
literal|"sql"
expr_stmt|;
name|new_colv
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|callback
argument_list|(
operator|&
name|data
argument_list|,
literal|1
argument_list|,
name|new_argv
argument_list|,
name|new_colv
argument_list|)
expr_stmt|;
name|rc
operator|=
name|SQLITE_OK
expr_stmt|;
block|}
else|else
block|{
name|zShellStatic
operator|=
name|azArg
index|[
literal|1
index|]
expr_stmt|;
name|rc
operator|=
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"SELECT sql FROM "
literal|"  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"
literal|"     FROM sqlite_master UNION ALL"
literal|"   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "
literal|"WHERE lower(tbl_name) LIKE shellstatic()"
literal|"  AND type!='meta' AND sql NOTNULL "
literal|"ORDER BY rowid"
argument_list|,
name|callback
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
name|zShellStatic
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nArg
operator|==
literal|1
condition|)
block|{
name|rc
operator|=
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"SELECT sql FROM "
literal|"  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"
literal|"     FROM sqlite_master UNION ALL"
literal|"   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "
literal|"WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"
literal|"ORDER BY rowid"
argument_list|,
name|callback
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .schema ?LIKE-PATTERN?\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
if|if
condition|(
name|zErrMsg
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|zErrMsg
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zErrMsg
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: querying schema information\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
ifdef|#
directive|ifdef
name|SQLITE_DEBUG
comment|/* Undocumented commands for internal testing.  Subject to change   ** without notice. */
if|if
condition|(
name|c
operator|==
literal|'s'
operator|&&
name|n
operator|>=
literal|10
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"selftest-"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
operator|+
literal|9
argument_list|,
literal|"boolean"
argument_list|,
name|n
operator|-
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|,
name|v
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
name|booleanValue
argument_list|(
name|azArg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s: %d 0x%x\n"
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|,
name|v
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
operator|+
literal|9
argument_list|,
literal|"integer"
argument_list|,
name|n
operator|-
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|sqlite3_int64
name|v
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|char
name|zBuf
index|[
literal|200
index|]
decl_stmt|;
name|v
operator|=
name|integerValue
argument_list|(
name|azArg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|zBuf
argument_list|)
argument_list|,
name|zBuf
argument_list|,
literal|"%s: %lld 0x%llx\n"
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|,
name|v
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|zBuf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
literal|'s'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"separator"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|==
literal|2
condition|)
block|{
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|separator
argument_list|)
argument_list|,
name|p
operator|->
name|separator
argument_list|,
literal|"%.*s"
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|p
operator|->
name|separator
argument_list|)
operator|-
literal|1
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .separator STRING\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'s'
operator|&&
operator|(
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"shell"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"system"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|char
modifier|*
name|zCmd
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|nArg
operator|<
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .system COMMAND\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
name|zCmd
operator|=
name|sqlite3_mprintf
argument_list|(
name|strchr
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|' '
argument_list|)
operator|==
literal|0
condition|?
literal|"%s"
else|:
literal|"\"%s\""
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|zCmd
operator|=
name|sqlite3_mprintf
argument_list|(
name|strchr
argument_list|(
name|azArg
index|[
name|i
index|]
argument_list|,
literal|' '
argument_list|)
operator|==
literal|0
condition|?
literal|"%z %s"
else|:
literal|"%z \"%s\""
argument_list|,
name|zCmd
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|system
argument_list|(
name|zCmd
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zCmd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'s'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"show"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|nArg
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .show\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%9.9s: %s\n"
argument_list|,
literal|"echo"
argument_list|,
name|p
operator|->
name|echoOn
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%9.9s: %s\n"
argument_list|,
literal|"eqp"
argument_list|,
name|p
operator|->
name|autoEQP
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%9.9s: %s\n"
argument_list|,
literal|"explain"
argument_list|,
name|p
operator|->
name|explainPrev
operator|.
name|valid
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%9.9s: %s\n"
argument_list|,
literal|"headers"
argument_list|,
name|p
operator|->
name|showHeader
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%9.9s: %s\n"
argument_list|,
literal|"mode"
argument_list|,
name|modeDescr
index|[
name|p
operator|->
name|mode
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%9.9s: "
argument_list|,
literal|"nullvalue"
argument_list|)
expr_stmt|;
name|output_c_string
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|p
operator|->
name|nullvalue
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%9.9s: %s\n"
argument_list|,
literal|"output"
argument_list|,
name|strlen30
argument_list|(
name|p
operator|->
name|outfile
argument_list|)
condition|?
name|p
operator|->
name|outfile
else|:
literal|"stdout"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%9.9s: "
argument_list|,
literal|"separator"
argument_list|)
expr_stmt|;
name|output_c_string
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|p
operator|->
name|separator
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%9.9s: %s\n"
argument_list|,
literal|"stats"
argument_list|,
name|p
operator|->
name|statsOn
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%9.9s: "
argument_list|,
literal|"width"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|ArraySize
argument_list|(
name|p
operator|->
name|colWidth
argument_list|)
operator|&&
name|p
operator|->
name|colWidth
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%d "
argument_list|,
name|p
operator|->
name|colWidth
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'s'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"stats"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|==
literal|2
condition|)
block|{
name|p
operator|->
name|statsOn
operator|=
name|booleanValue
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .stats on|off\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'t'
operator|&&
name|n
operator|>
literal|1
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"tables"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sqlite3_stmt
modifier|*
name|pStmt
decl_stmt|;
name|char
modifier|*
modifier|*
name|azResult
decl_stmt|;
name|int
name|nRow
decl_stmt|,
name|nAlloc
decl_stmt|;
name|char
modifier|*
name|zSql
init|=
literal|0
decl_stmt|;
name|int
name|ii
decl_stmt|;
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"PRAGMA database_list"
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
name|zSql
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"SELECT name FROM sqlite_master"
literal|" WHERE type IN ('table','view')"
literal|"   AND name NOT LIKE 'sqlite_%%'"
literal|"   AND name LIKE ?1"
argument_list|)
expr_stmt|;
while|while
condition|(
name|sqlite3_step
argument_list|(
name|pStmt
argument_list|)
operator|==
name|SQLITE_ROW
condition|)
block|{
specifier|const
name|char
modifier|*
name|zDbName
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pStmt
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|zDbName
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|zDbName
argument_list|,
literal|"main"
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|zDbName
argument_list|,
literal|"temp"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zSql
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"%z UNION ALL "
literal|"SELECT 'temp.' || name FROM sqlite_temp_master"
literal|" WHERE type IN ('table','view')"
literal|"   AND name NOT LIKE 'sqlite_%%'"
literal|"   AND name LIKE ?1"
argument_list|,
name|zSql
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zSql
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"%z UNION ALL "
literal|"SELECT '%q.' || name FROM \"%w\".sqlite_master"
literal|" WHERE type IN ('table','view')"
literal|"   AND name NOT LIKE 'sqlite_%%'"
literal|"   AND name LIKE ?1"
argument_list|,
name|zSql
argument_list|,
name|zDbName
argument_list|,
name|zDbName
argument_list|)
expr_stmt|;
block|}
block|}
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|zSql
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"%z ORDER BY 1"
argument_list|,
name|zSql
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_prepare_v2
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zSql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
name|nRow
operator|=
name|nAlloc
operator|=
literal|0
expr_stmt|;
name|azResult
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nArg
operator|>
literal|1
condition|)
block|{
name|sqlite3_bind_text
argument_list|(
name|pStmt
argument_list|,
literal|1
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|,
operator|-
literal|1
argument_list|,
name|SQLITE_TRANSIENT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sqlite3_bind_text
argument_list|(
name|pStmt
argument_list|,
literal|1
argument_list|,
literal|"%"
argument_list|,
operator|-
literal|1
argument_list|,
name|SQLITE_STATIC
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|sqlite3_step
argument_list|(
name|pStmt
argument_list|)
operator|==
name|SQLITE_ROW
condition|)
block|{
if|if
condition|(
name|nRow
operator|>=
name|nAlloc
condition|)
block|{
name|char
modifier|*
modifier|*
name|azNew
decl_stmt|;
name|int
name|n
init|=
name|nAlloc
operator|*
literal|2
operator|+
literal|10
decl_stmt|;
name|azNew
operator|=
name|sqlite3_realloc
argument_list|(
name|azResult
argument_list|,
sizeof|sizeof
argument_list|(
name|azResult
index|[
literal|0
index|]
argument_list|)
operator|*
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|azNew
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: out of memory\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|nAlloc
operator|=
name|n
expr_stmt|;
name|azResult
operator|=
name|azNew
expr_stmt|;
block|}
name|azResult
index|[
name|nRow
index|]
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"%s"
argument_list|,
name|sqlite3_column_text
argument_list|(
name|pStmt
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|azResult
index|[
name|nRow
index|]
condition|)
name|nRow
operator|++
expr_stmt|;
block|}
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|nRow
operator|>
literal|0
condition|)
block|{
name|int
name|len
decl_stmt|,
name|maxlen
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|nPrintCol
decl_stmt|,
name|nPrintRow
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nRow
condition|;
name|i
operator|++
control|)
block|{
name|len
operator|=
name|strlen30
argument_list|(
name|azResult
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|maxlen
condition|)
name|maxlen
operator|=
name|len
expr_stmt|;
block|}
name|nPrintCol
operator|=
literal|80
operator|/
operator|(
name|maxlen
operator|+
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|nPrintCol
operator|<
literal|1
condition|)
name|nPrintCol
operator|=
literal|1
expr_stmt|;
name|nPrintRow
operator|=
operator|(
name|nRow
operator|+
name|nPrintCol
operator|-
literal|1
operator|)
operator|/
name|nPrintCol
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nPrintRow
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|nRow
condition|;
name|j
operator|+=
name|nPrintRow
control|)
block|{
name|char
modifier|*
name|zSp
init|=
name|j
operator|<
name|nPrintRow
condition|?
literal|""
else|:
literal|"  "
decl_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s%-*s"
argument_list|,
name|zSp
argument_list|,
name|maxlen
argument_list|,
name|azResult
index|[
name|j
index|]
condition|?
name|azResult
index|[
name|j
index|]
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|nRow
condition|;
name|ii
operator|++
control|)
name|sqlite3_free
argument_list|(
name|azResult
index|[
name|ii
index|]
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|azResult
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'t'
operator|&&
name|n
operator|>=
literal|8
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"testctrl"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|&&
name|nArg
operator|>=
literal|2
condition|)
block|{
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|zCtrlName
decl_stmt|;
comment|/* Name of a test-control option */
name|int
name|ctrlCode
decl_stmt|;
comment|/* Integer code for that option */
block|}
name|aCtrl
index|[]
init|=
block|{
block|{
literal|"prng_save"
block|,
name|SQLITE_TESTCTRL_PRNG_SAVE
block|}
block|,
block|{
literal|"prng_restore"
block|,
name|SQLITE_TESTCTRL_PRNG_RESTORE
block|}
block|,
block|{
literal|"prng_reset"
block|,
name|SQLITE_TESTCTRL_PRNG_RESET
block|}
block|,
block|{
literal|"bitvec_test"
block|,
name|SQLITE_TESTCTRL_BITVEC_TEST
block|}
block|,
block|{
literal|"fault_install"
block|,
name|SQLITE_TESTCTRL_FAULT_INSTALL
block|}
block|,
block|{
literal|"benign_malloc_hooks"
block|,
name|SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS
block|}
block|,
block|{
literal|"pending_byte"
block|,
name|SQLITE_TESTCTRL_PENDING_BYTE
block|}
block|,
block|{
literal|"assert"
block|,
name|SQLITE_TESTCTRL_ASSERT
block|}
block|,
block|{
literal|"always"
block|,
name|SQLITE_TESTCTRL_ALWAYS
block|}
block|,
block|{
literal|"reserve"
block|,
name|SQLITE_TESTCTRL_RESERVE
block|}
block|,
block|{
literal|"optimizations"
block|,
name|SQLITE_TESTCTRL_OPTIMIZATIONS
block|}
block|,
block|{
literal|"iskeyword"
block|,
name|SQLITE_TESTCTRL_ISKEYWORD
block|}
block|,
block|{
literal|"scratchmalloc"
block|,
name|SQLITE_TESTCTRL_SCRATCHMALLOC
block|}
block|,
block|{
literal|"byteorder"
block|,
name|SQLITE_TESTCTRL_BYTEORDER
block|}
block|,     }
struct|;
name|int
name|testctrl
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* convert testctrl text option to value. allow any unique prefix     ** of the option name, or a numerical value. */
name|n
operator|=
name|strlen30
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|aCtrl
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|aCtrl
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
name|aCtrl
index|[
name|i
index|]
operator|.
name|zCtrlName
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|testctrl
operator|<
literal|0
condition|)
block|{
name|testctrl
operator|=
name|aCtrl
index|[
name|i
index|]
operator|.
name|ctrlCode
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ambiguous option name: \"%s\"\n"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|testctrl
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|testctrl
operator|<
literal|0
condition|)
name|testctrl
operator|=
operator|(
name|int
operator|)
name|integerValue
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|testctrl
operator|<
name|SQLITE_TESTCTRL_FIRST
operator|)
operator|||
operator|(
name|testctrl
operator|>
name|SQLITE_TESTCTRL_LAST
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: invalid testctrl option: %s\n"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|testctrl
condition|)
block|{
comment|/* sqlite3_test_control(int, db, int) */
case|case
name|SQLITE_TESTCTRL_OPTIMIZATIONS
case|:
case|case
name|SQLITE_TESTCTRL_RESERVE
case|:
if|if
condition|(
name|nArg
operator|==
literal|3
condition|)
block|{
name|int
name|opt
init|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|azArg
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rc
operator|=
name|sqlite3_test_control
argument_list|(
name|testctrl
argument_list|,
name|p
operator|->
name|db
argument_list|,
name|opt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%d (0x%08x)\n"
argument_list|,
name|rc
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: testctrl %s takes a single int option\n"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* sqlite3_test_control(int) */
case|case
name|SQLITE_TESTCTRL_PRNG_SAVE
case|:
case|case
name|SQLITE_TESTCTRL_PRNG_RESTORE
case|:
case|case
name|SQLITE_TESTCTRL_PRNG_RESET
case|:
case|case
name|SQLITE_TESTCTRL_BYTEORDER
case|:
if|if
condition|(
name|nArg
operator|==
literal|2
condition|)
block|{
name|rc
operator|=
name|sqlite3_test_control
argument_list|(
name|testctrl
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%d (0x%08x)\n"
argument_list|,
name|rc
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: testctrl %s takes no options\n"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* sqlite3_test_control(int, uint) */
case|case
name|SQLITE_TESTCTRL_PENDING_BYTE
case|:
if|if
condition|(
name|nArg
operator|==
literal|3
condition|)
block|{
name|unsigned
name|int
name|opt
init|=
operator|(
name|unsigned
name|int
operator|)
name|integerValue
argument_list|(
name|azArg
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|rc
operator|=
name|sqlite3_test_control
argument_list|(
name|testctrl
argument_list|,
name|opt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%d (0x%08x)\n"
argument_list|,
name|rc
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: testctrl %s takes a single unsigned"
literal|" int option\n"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* sqlite3_test_control(int, int) */
case|case
name|SQLITE_TESTCTRL_ASSERT
case|:
case|case
name|SQLITE_TESTCTRL_ALWAYS
case|:
if|if
condition|(
name|nArg
operator|==
literal|3
condition|)
block|{
name|int
name|opt
init|=
name|booleanValue
argument_list|(
name|azArg
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|rc
operator|=
name|sqlite3_test_control
argument_list|(
name|testctrl
argument_list|,
name|opt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%d (0x%08x)\n"
argument_list|,
name|rc
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: testctrl %s takes a single int option\n"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* sqlite3_test_control(int, char *) */
ifdef|#
directive|ifdef
name|SQLITE_N_KEYWORD
case|case
name|SQLITE_TESTCTRL_ISKEYWORD
case|:
if|if
condition|(
name|nArg
operator|==
literal|3
condition|)
block|{
specifier|const
name|char
modifier|*
name|opt
init|=
name|azArg
index|[
literal|2
index|]
decl_stmt|;
name|rc
operator|=
name|sqlite3_test_control
argument_list|(
name|testctrl
argument_list|,
name|opt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%d (0x%08x)\n"
argument_list|,
name|rc
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: testctrl %s takes a single char * option\n"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
name|SQLITE_TESTCTRL_BITVEC_TEST
case|:
case|case
name|SQLITE_TESTCTRL_FAULT_INSTALL
case|:
case|case
name|SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS
case|:
case|case
name|SQLITE_TESTCTRL_SCRATCHMALLOC
case|:
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: CLI support for testctrl %s not implemented\n"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'t'
operator|&&
name|n
operator|>
literal|4
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"timeout"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_busy_timeout
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|nArg
operator|>=
literal|2
condition|?
operator|(
name|int
operator|)
name|integerValue
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'t'
operator|&&
name|n
operator|>=
literal|5
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"timer"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nArg
operator|==
literal|2
condition|)
block|{
name|enableTimer
operator|=
name|booleanValue
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|enableTimer
operator|&&
operator|!
name|HAS_TIMER
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: timer not available on this system.\n"
argument_list|)
expr_stmt|;
name|enableTimer
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .timer on|off\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'t'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"trace"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output_file_close
argument_list|(
name|p
operator|->
name|traceOut
argument_list|)
expr_stmt|;
if|if
condition|(
name|nArg
operator|!=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: .trace FILE|off\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|meta_command_exit
goto|;
block|}
name|p
operator|->
name|traceOut
operator|=
name|output_file_open
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SQLITE_OMIT_TRACE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SQLITE_OMIT_FLOATING_POINT
argument_list|)
if|if
condition|(
name|p
operator|->
name|traceOut
operator|==
literal|0
condition|)
block|{
name|sqlite3_trace
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sqlite3_trace
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|sql_trace_callback
argument_list|,
name|p
operator|->
name|traceOut
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'v'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"version"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"SQLite %s %s\n"
comment|/*extra-version-info*/
argument_list|,
name|sqlite3_libversion
argument_list|()
argument_list|,
name|sqlite3_sourceid
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'v'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"vfsname"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|zDbName
init|=
name|nArg
operator|==
literal|2
condition|?
name|azArg
index|[
literal|1
index|]
else|:
literal|"main"
decl_stmt|;
name|char
modifier|*
name|zVfsName
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|db
condition|)
block|{
name|sqlite3_file_control
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zDbName
argument_list|,
name|SQLITE_FCNTL_VFSNAME
argument_list|,
operator|&
name|zVfsName
argument_list|)
expr_stmt|;
if|if
condition|(
name|zVfsName
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s\n"
argument_list|,
name|zVfsName
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zVfsName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|SQLITE_ENABLE_WHERETRACE
argument_list|)
if|if
condition|(
name|c
operator|==
literal|'w'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"wheretrace"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|extern
name|int
name|sqlite3WhereTrace
decl_stmt|;
name|sqlite3WhereTrace
operator|=
name|nArg
operator|>=
literal|2
condition|?
name|booleanValue
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
else|:
literal|0xff
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
literal|'w'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"width"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
name|assert
argument_list|(
name|nArg
operator|<=
name|ArraySize
argument_list|(
name|azArg
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|nArg
operator|&&
name|j
operator|<
name|ArraySize
argument_list|(
name|p
operator|->
name|colWidth
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|p
operator|->
name|colWidth
index|[
name|j
operator|-
literal|1
index|]
operator|=
operator|(
name|int
operator|)
name|integerValue
argument_list|(
name|azArg
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: unknown command or invalid arguments: "
literal|" \"%s\". Enter \".help\" for help\n"
argument_list|,
name|azArg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
name|meta_command_exit
label|:
if|if
condition|(
name|p
operator|->
name|outCount
condition|)
block|{
name|p
operator|->
name|outCount
operator|--
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|outCount
operator|==
literal|0
condition|)
name|output_reset
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* ** Return TRUE if a semicolon occurs anywhere in the first N characters ** of string z[]. */
end_comment

begin_function
specifier|static
name|int
name|line_contains_semicolon
parameter_list|(
specifier|const
name|char
modifier|*
name|z
parameter_list|,
name|int
name|N
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|z
index|[
name|i
index|]
operator|==
literal|';'
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ** Test to see if a line consists entirely of whitespace. */
end_comment

begin_function
specifier|static
name|int
name|_all_whitespace
parameter_list|(
specifier|const
name|char
modifier|*
name|z
parameter_list|)
block|{
for|for
control|(
init|;
operator|*
name|z
condition|;
name|z
operator|++
control|)
block|{
if|if
condition|(
name|IsSpace
argument_list|(
name|z
index|[
literal|0
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|*
name|z
operator|==
literal|'/'
operator|&&
name|z
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
name|z
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|z
operator|&&
operator|(
operator|*
name|z
operator|!=
literal|'*'
operator|||
name|z
index|[
literal|1
index|]
operator|!=
literal|'/'
operator|)
condition|)
block|{
name|z
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|z
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|z
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|z
operator|==
literal|'-'
operator|&&
name|z
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
name|z
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|z
operator|&&
operator|*
name|z
operator|!=
literal|'\n'
condition|)
block|{
name|z
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|z
operator|==
literal|0
condition|)
return|return
literal|1
return|;
continue|continue;
block|}
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ** Return TRUE if the line typed in is an SQL command terminator other ** than a semi-colon.  The SQL Server style "go" command is understood ** as is the Oracle "/". */
end_comment

begin_function
specifier|static
name|int
name|line_is_command_terminator
parameter_list|(
specifier|const
name|char
modifier|*
name|zLine
parameter_list|)
block|{
while|while
condition|(
name|IsSpace
argument_list|(
name|zLine
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|zLine
operator|++
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|zLine
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|_all_whitespace
argument_list|(
operator|&
name|zLine
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
comment|/* Oracle */
block|}
if|if
condition|(
name|ToLower
argument_list|(
name|zLine
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'g'
operator|&&
name|ToLower
argument_list|(
name|zLine
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'o'
operator|&&
name|_all_whitespace
argument_list|(
operator|&
name|zLine
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
comment|/* SQL Server */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ** Return true if zSql is a complete SQL statement.  Return false if it ** ends in the middle of a string literal or C-style comment. */
end_comment

begin_function
specifier|static
name|int
name|line_is_complete
parameter_list|(
name|char
modifier|*
name|zSql
parameter_list|,
name|int
name|nSql
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|zSql
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|zSql
index|[
name|nSql
index|]
operator|=
literal|';'
expr_stmt|;
name|zSql
index|[
name|nSql
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|sqlite3_complete
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
name|zSql
index|[
name|nSql
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* ** Read input from *in and process it.  If *in==0 then input ** is interactive - the user is typing it it.  Otherwise, input ** is coming from a file or device.  A prompt is issued and history ** is saved only if input is interactive.  An interrupt signal will ** cause this routine to exit immediately, unless input is interactive. ** ** Return the number of errors. */
end_comment

begin_function
specifier|static
name|int
name|process_input
parameter_list|(
name|struct
name|callback_data
modifier|*
name|p
parameter_list|,
name|FILE
modifier|*
name|in
parameter_list|)
block|{
name|char
modifier|*
name|zLine
init|=
literal|0
decl_stmt|;
comment|/* A single input line */
name|char
modifier|*
name|zSql
init|=
literal|0
decl_stmt|;
comment|/* Accumulated SQL text */
name|int
name|nLine
decl_stmt|;
comment|/* Length of current line */
name|int
name|nSql
init|=
literal|0
decl_stmt|;
comment|/* Bytes of zSql[] used */
name|int
name|nAlloc
init|=
literal|0
decl_stmt|;
comment|/* Allocated zSql[] space */
name|int
name|nSqlPrior
init|=
literal|0
decl_stmt|;
comment|/* Bytes of zSql[] used by prior line */
name|char
modifier|*
name|zErrMsg
decl_stmt|;
comment|/* Error message returned */
name|int
name|rc
decl_stmt|;
comment|/* Error code */
name|int
name|errCnt
init|=
literal|0
decl_stmt|;
comment|/* Number of errors seen */
name|int
name|lineno
init|=
literal|0
decl_stmt|;
comment|/* Current line number */
name|int
name|startline
init|=
literal|0
decl_stmt|;
comment|/* Line number for start of current input */
while|while
condition|(
name|errCnt
operator|==
literal|0
operator|||
operator|!
name|bail_on_error
operator|||
operator|(
name|in
operator|==
literal|0
operator|&&
name|stdin_is_interactive
operator|)
condition|)
block|{
name|fflush
argument_list|(
name|p
operator|->
name|out
argument_list|)
expr_stmt|;
name|zLine
operator|=
name|one_input_line
argument_list|(
name|in
argument_list|,
name|zLine
argument_list|,
name|nSql
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zLine
operator|==
literal|0
condition|)
block|{
comment|/* End of input */
if|if
condition|(
name|stdin_is_interactive
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|seenInterrupt
condition|)
block|{
if|if
condition|(
name|in
operator|!=
literal|0
condition|)
break|break;
name|seenInterrupt
operator|=
literal|0
expr_stmt|;
block|}
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|nSql
operator|==
literal|0
operator|&&
name|_all_whitespace
argument_list|(
name|zLine
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|echoOn
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|zLine
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|zLine
operator|&&
name|zLine
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|nSql
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|echoOn
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|zLine
argument_list|)
expr_stmt|;
name|rc
operator|=
name|do_meta_command
argument_list|(
name|zLine
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|2
condition|)
block|{
comment|/* exit requested */
break|break;
block|}
elseif|else
if|if
condition|(
name|rc
condition|)
block|{
name|errCnt
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|line_is_command_terminator
argument_list|(
name|zLine
argument_list|)
operator|&&
name|line_is_complete
argument_list|(
name|zSql
argument_list|,
name|nSql
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|zLine
argument_list|,
literal|";"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|nLine
operator|=
name|strlen30
argument_list|(
name|zLine
argument_list|)
expr_stmt|;
if|if
condition|(
name|nSql
operator|+
name|nLine
operator|+
literal|2
operator|>=
name|nAlloc
condition|)
block|{
name|nAlloc
operator|=
name|nSql
operator|+
name|nLine
operator|+
literal|100
expr_stmt|;
name|zSql
operator|=
name|realloc
argument_list|(
name|zSql
argument_list|,
name|nAlloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|zSql
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|nSqlPrior
operator|=
name|nSql
expr_stmt|;
if|if
condition|(
name|nSql
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|zLine
index|[
name|i
index|]
operator|&&
name|IsSpace
argument_list|(
name|zLine
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{}
name|assert
argument_list|(
name|nAlloc
operator|>
literal|0
operator|&&
name|zSql
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|zSql
argument_list|,
name|zLine
operator|+
name|i
argument_list|,
name|nLine
operator|+
literal|1
operator|-
name|i
argument_list|)
expr_stmt|;
name|startline
operator|=
name|lineno
expr_stmt|;
name|nSql
operator|=
name|nLine
operator|-
name|i
expr_stmt|;
block|}
else|else
block|{
name|zSql
index|[
name|nSql
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|memcpy
argument_list|(
name|zSql
operator|+
name|nSql
argument_list|,
name|zLine
argument_list|,
name|nLine
operator|+
literal|1
argument_list|)
expr_stmt|;
name|nSql
operator|+=
name|nLine
expr_stmt|;
block|}
if|if
condition|(
name|nSql
operator|&&
name|line_contains_semicolon
argument_list|(
operator|&
name|zSql
index|[
name|nSqlPrior
index|]
argument_list|,
name|nSql
operator|-
name|nSqlPrior
argument_list|)
operator|&&
name|sqlite3_complete
argument_list|(
name|zSql
argument_list|)
condition|)
block|{
name|p
operator|->
name|cnt
operator|=
literal|0
expr_stmt|;
name|open_db
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BEGIN_TIMER
expr_stmt|;
name|rc
operator|=
name|shell_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zSql
argument_list|,
name|shell_callback
argument_list|,
name|p
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
name|END_TIMER
expr_stmt|;
if|if
condition|(
name|rc
operator|||
name|zErrMsg
condition|)
block|{
name|char
name|zPrefix
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|in
operator|!=
literal|0
operator|||
operator|!
name|stdin_is_interactive
condition|)
block|{
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|zPrefix
argument_list|)
argument_list|,
name|zPrefix
argument_list|,
literal|"Error: near line %d:"
argument_list|,
name|startline
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|zPrefix
argument_list|)
argument_list|,
name|zPrefix
argument_list|,
literal|"Error:"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zErrMsg
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s %s\n"
argument_list|,
name|zPrefix
argument_list|,
name|zErrMsg
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zErrMsg
argument_list|)
expr_stmt|;
name|zErrMsg
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s %s\n"
argument_list|,
name|zPrefix
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|errCnt
operator|++
expr_stmt|;
block|}
name|nSql
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|outCount
condition|)
block|{
name|output_reset
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|outCount
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nSql
operator|&&
name|_all_whitespace
argument_list|(
name|zSql
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|echoOn
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|zSql
argument_list|)
expr_stmt|;
name|nSql
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nSql
condition|)
block|{
if|if
condition|(
operator|!
name|_all_whitespace
argument_list|(
name|zSql
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: incomplete SQL: %s\n"
argument_list|,
name|zSql
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|zLine
argument_list|)
expr_stmt|;
return|return
name|errCnt
operator|>
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ** Return a pathname which is the user's home directory.  A ** 0 return indicates an error of some kind. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|find_home_dir
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|home_dir
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|home_dir
condition|)
return|return
name|home_dir
return|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_WIN32_WCE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__RTP__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_WRS_KERNEL
argument_list|)
block|{
name|struct
name|passwd
modifier|*
name|pwent
decl_stmt|;
name|uid_t
name|uid
init|=
name|getuid
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|pwent
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|home_dir
operator|=
name|pwent
operator|->
name|pw_dir
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|_WIN32_WCE
argument_list|)
comment|/* Windows CE (arm-wince-mingw32ce-gcc) does not provide getenv()    */
name|home_dir
operator|=
literal|"/"
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
if|if
condition|(
operator|!
name|home_dir
condition|)
block|{
name|home_dir
operator|=
name|getenv
argument_list|(
literal|"USERPROFILE"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|home_dir
condition|)
block|{
name|home_dir
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
if|if
condition|(
operator|!
name|home_dir
condition|)
block|{
name|char
modifier|*
name|zDrive
decl_stmt|,
modifier|*
name|zPath
decl_stmt|;
name|int
name|n
decl_stmt|;
name|zDrive
operator|=
name|getenv
argument_list|(
literal|"HOMEDRIVE"
argument_list|)
expr_stmt|;
name|zPath
operator|=
name|getenv
argument_list|(
literal|"HOMEPATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zDrive
operator|&&
name|zPath
condition|)
block|{
name|n
operator|=
name|strlen30
argument_list|(
name|zDrive
argument_list|)
operator|+
name|strlen30
argument_list|(
name|zPath
argument_list|)
operator|+
literal|1
expr_stmt|;
name|home_dir
operator|=
name|malloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|home_dir
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|sqlite3_snprintf
argument_list|(
name|n
argument_list|,
name|home_dir
argument_list|,
literal|"%s%s"
argument_list|,
name|zDrive
argument_list|,
name|zPath
argument_list|)
expr_stmt|;
return|return
name|home_dir
return|;
block|}
name|home_dir
operator|=
literal|"c:\\"
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* !_WIN32_WCE */
if|if
condition|(
name|home_dir
condition|)
block|{
name|int
name|n
init|=
name|strlen30
argument_list|(
name|home_dir
argument_list|)
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|z
init|=
name|malloc
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|z
condition|)
name|memcpy
argument_list|(
name|z
argument_list|,
name|home_dir
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|home_dir
operator|=
name|z
expr_stmt|;
block|}
return|return
name|home_dir
return|;
block|}
end_function

begin_comment
comment|/* ** Read input from the file given by sqliterc_override.  Or if that ** parameter is NULL, take input from ~/.sqliterc ** ** Returns the number of errors. */
end_comment

begin_function
specifier|static
name|int
name|process_sqliterc
parameter_list|(
name|struct
name|callback_data
modifier|*
name|p
parameter_list|,
comment|/* Configuration data */
specifier|const
name|char
modifier|*
name|sqliterc_override
comment|/* Name of config file. NULL to use default */
parameter_list|)
block|{
name|char
modifier|*
name|home_dir
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|sqliterc
init|=
name|sqliterc_override
decl_stmt|;
name|char
modifier|*
name|zBuf
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|in
init|=
name|NULL
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sqliterc
operator|==
name|NULL
condition|)
block|{
name|home_dir
operator|=
name|find_home_dir
argument_list|()
expr_stmt|;
if|if
condition|(
name|home_dir
operator|==
literal|0
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__RTP__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_WRS_KERNEL
argument_list|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Error: cannot locate your home directory\n"
argument_list|,
name|Argv0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
name|sqlite3_initialize
argument_list|()
expr_stmt|;
name|zBuf
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"%s/.sqliterc"
argument_list|,
name|home_dir
argument_list|)
expr_stmt|;
name|sqliterc
operator|=
name|zBuf
expr_stmt|;
block|}
name|in
operator|=
name|fopen
argument_list|(
name|sqliterc
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
condition|)
block|{
if|if
condition|(
name|stdin_is_interactive
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-- Loading resources from %s\n"
argument_list|,
name|sqliterc
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|process_input
argument_list|(
name|p
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
name|sqlite3_free
argument_list|(
name|zBuf
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* ** Show available command line options */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|zOptions
index|[]
init|=
literal|"   -bail                stop after hitting an error\n"
literal|"   -batch               force batch I/O\n"
literal|"   -column              set output mode to 'column'\n"
literal|"   -cmd COMMAND         run \"COMMAND\" before reading stdin\n"
literal|"   -csv                 set output mode to 'csv'\n"
literal|"   -echo                print commands before execution\n"
literal|"   -init FILENAME       read/process named file\n"
literal|"   -[no]header          turn headers on or off\n"
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_ENABLE_MEMSYS3
argument_list|)
operator|||
name|defined
argument_list|(
name|SQLITE_ENABLE_MEMSYS5
argument_list|)
literal|"   -heap SIZE           Size of heap for memsys3 or memsys5\n"
endif|#
directive|endif
literal|"   -help                show this message\n"
literal|"   -html                set output mode to HTML\n"
literal|"   -interactive         force interactive I/O\n"
literal|"   -line                set output mode to 'line'\n"
literal|"   -list                set output mode to 'list'\n"
literal|"   -mmap N              default mmap size set to N\n"
ifdef|#
directive|ifdef
name|SQLITE_ENABLE_MULTIPLEX
literal|"   -multiplex           enable the multiplexor VFS\n"
endif|#
directive|endif
literal|"   -nullvalue TEXT      set text string for NULL values. Default ''\n"
literal|"   -separator SEP       set output field separator. Default: '|'\n"
literal|"   -stats               print memory stats before each finalize\n"
literal|"   -version             show SQLite version\n"
literal|"   -vfs NAME            use NAME as the default VFS\n"
ifdef|#
directive|ifdef
name|SQLITE_ENABLE_VFSTRACE
literal|"   -vfstrace            enable tracing of all VFS calls\n"
endif|#
directive|endif
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|int
name|showDetail
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [OPTIONS] FILENAME [SQL]\n"
literal|"FILENAME is the name of an SQLite database. A new database is created\n"
literal|"if the file does not previously exist.\n"
argument_list|,
name|Argv0
argument_list|)
expr_stmt|;
if|if
condition|(
name|showDetail
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"OPTIONS include:\n%s"
argument_list|,
name|zOptions
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Use the -help option for additional information\n"
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Initialize the state information in data */
end_comment

begin_function
specifier|static
name|void
name|main_init
parameter_list|(
name|struct
name|callback_data
modifier|*
name|data
parameter_list|)
block|{
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|mode
operator|=
name|MODE_List
expr_stmt|;
name|memcpy
argument_list|(
name|data
operator|->
name|separator
argument_list|,
literal|"|"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|data
operator|->
name|showHeader
operator|=
literal|0
expr_stmt|;
name|sqlite3_config
argument_list|(
name|SQLITE_CONFIG_URI
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sqlite3_config
argument_list|(
name|SQLITE_CONFIG_LOG
argument_list|,
name|shellLog
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|mainPrompt
argument_list|)
argument_list|,
name|mainPrompt
argument_list|,
literal|"sqlite> "
argument_list|)
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|continuePrompt
argument_list|)
argument_list|,
name|continuePrompt
argument_list|,
literal|"   ...> "
argument_list|)
expr_stmt|;
name|sqlite3_config
argument_list|(
name|SQLITE_CONFIG_SINGLETHREAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Output text to the console in a font that attracts extra attention. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_function
specifier|static
name|void
name|printBold
parameter_list|(
specifier|const
name|char
modifier|*
name|zText
parameter_list|)
block|{
name|HANDLE
name|out
init|=
name|GetStdHandle
argument_list|(
name|STD_OUTPUT_HANDLE
argument_list|)
decl_stmt|;
name|CONSOLE_SCREEN_BUFFER_INFO
name|defaultScreenInfo
decl_stmt|;
name|GetConsoleScreenBufferInfo
argument_list|(
name|out
argument_list|,
operator|&
name|defaultScreenInfo
argument_list|)
expr_stmt|;
name|SetConsoleTextAttribute
argument_list|(
name|out
argument_list|,
name|FOREGROUND_RED
operator||
name|FOREGROUND_INTENSITY
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|zText
argument_list|)
expr_stmt|;
name|SetConsoleTextAttribute
argument_list|(
name|out
argument_list|,
name|defaultScreenInfo
operator|.
name|wAttributes
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|printBold
parameter_list|(
specifier|const
name|char
modifier|*
name|zText
parameter_list|)
block|{
name|printf
argument_list|(
literal|"\033[1m%s\033[0m"
argument_list|,
name|zText
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** Get the argument to an --option.  Throw an error and die if no argument ** is available. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|cmdline_option_value
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
operator|==
name|argc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Error: missing argument to %s\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|argv
index|[
name|i
index|]
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|zErrMsg
init|=
literal|0
decl_stmt|;
name|struct
name|callback_data
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|zInitFile
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|zFirstCmd
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|int
name|warnInmemoryDb
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|USE_SYSTEM_SQLITE
operator|+
literal|0
operator|!=
literal|1
if|if
condition|(
name|strcmp
argument_list|(
name|sqlite3_sourceid
argument_list|()
argument_list|,
name|SQLITE_SOURCE_ID
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"SQLite header and source version mismatch\n%s\n%s\n"
argument_list|,
name|sqlite3_sourceid
argument_list|()
argument_list|,
name|SQLITE_SOURCE_ID
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|Argv0
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|main_init
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
name|stdin_is_interactive
operator|=
name|isatty
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Make sure we have a valid signal handler early, before anything   ** else is done.   */
ifdef|#
directive|ifdef
name|SIGINT
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|interrupt_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Do an initial pass through the command-line argument to locate   ** the name of the database file, the name of the initialization file,   ** the size of the alternative malloc heap,   ** and the first command to execute.   */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|z
decl_stmt|;
name|z
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|z
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
if|if
condition|(
name|data
operator|.
name|zDbFilename
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|zDbFilename
operator|=
name|z
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|zFirstCmd
operator|==
literal|0
condition|)
block|{
name|zFirstCmd
operator|=
name|z
expr_stmt|;
continue|continue;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Error: too many options: \"%s\"\n"
argument_list|,
name|Argv0
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Use -help for a list of options.\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|z
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
name|z
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-separator"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-nullvalue"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-cmd"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|cmdline_option_value
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|++
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-init"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zInitFile
operator|=
name|cmdline_option_value
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|++
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-batch"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Need to check for batch mode here to so we can avoid printing       ** informational messages (like from process_sqliterc) before        ** we do the actual processing of arguments later in a second pass.       */
name|stdin_is_interactive
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-heap"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SQLITE_ENABLE_MEMSYS3
argument_list|)
operator|||
name|defined
argument_list|(
name|SQLITE_ENABLE_MEMSYS5
argument_list|)
specifier|const
name|char
modifier|*
name|zSize
decl_stmt|;
name|sqlite3_int64
name|szHeap
decl_stmt|;
name|zSize
operator|=
name|cmdline_option_value
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|++
name|i
argument_list|)
expr_stmt|;
name|szHeap
operator|=
name|integerValue
argument_list|(
name|zSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|szHeap
operator|>
literal|0x7fff0000
condition|)
name|szHeap
operator|=
literal|0x7fff0000
expr_stmt|;
name|sqlite3_config
argument_list|(
name|SQLITE_CONFIG_HEAP
argument_list|,
name|malloc
argument_list|(
operator|(
name|int
operator|)
name|szHeap
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|szHeap
argument_list|,
literal|64
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SQLITE_ENABLE_VFSTRACE
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-vfstrace"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|extern
name|int
name|vfstrace_register
argument_list|(
specifier|const
name|char
operator|*
name|zTraceName
argument_list|,
specifier|const
name|char
operator|*
name|zOldVfsName
argument_list|,
name|int
argument_list|(
operator|*
name|xOut
argument_list|)
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|void
operator|*
name|pOutArg
argument_list|,
name|int
name|makeDefault
argument_list|)
decl_stmt|;
name|vfstrace_register
argument_list|(
literal|"trace"
argument_list|,
literal|0
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
name|void
operator|*
argument_list|)
operator|)
name|fputs
argument_list|,
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SQLITE_ENABLE_MULTIPLEX
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-multiplex"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|extern
name|int
name|sqlite3_multiple_initialize
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
name|int
argument_list|)
decl_stmt|;
name|sqlite3_multiplex_initialize
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-mmap"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sqlite3_int64
name|sz
init|=
name|integerValue
argument_list|(
name|cmdline_option_value
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|++
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|sqlite3_config
argument_list|(
name|SQLITE_CONFIG_MMAP_SIZE
argument_list|,
name|sz
argument_list|,
name|sz
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-vfs"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sqlite3_vfs
modifier|*
name|pVfs
init|=
name|sqlite3_vfs_find
argument_list|(
name|cmdline_option_value
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|++
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pVfs
condition|)
block|{
name|sqlite3_vfs_register
argument_list|(
name|pVfs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no such VFS: \"%s\"\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|data
operator|.
name|zDbFilename
operator|==
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|SQLITE_OMIT_MEMORYDB
name|data
operator|.
name|zDbFilename
operator|=
literal|":memory:"
expr_stmt|;
name|warnInmemoryDb
operator|=
name|argc
operator|==
literal|1
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Error: no database filename specified\n"
argument_list|,
name|Argv0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SQLITE_SHELL_DBNAME_PROC
block|{
specifier|extern
name|void
name|SQLITE_SHELL_DBNAME_PROC
argument_list|(
specifier|const
name|char
operator|*
operator|*
argument_list|)
decl_stmt|;
name|SQLITE_SHELL_DBNAME_PROC
argument_list|(
operator|&
name|data
operator|.
name|zDbFilename
argument_list|)
expr_stmt|;
name|warnInmemoryDb
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|data
operator|.
name|out
operator|=
name|stdout
expr_stmt|;
comment|/* Go ahead and open the database file if it already exists.  If the   ** file does not exist, delay opening it.  This prevents empty database   ** files from being created if a user mistypes the database name argument   ** to the sqlite command-line tool.   */
if|if
condition|(
name|access
argument_list|(
name|data
operator|.
name|zDbFilename
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|open_db
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Process the initialization file if there is one.  If no -init option   ** is given on the command line, look for a file named ~/.sqliterc and   ** try to process it.   */
name|rc
operator|=
name|process_sqliterc
argument_list|(
operator|&
name|data
argument_list|,
name|zInitFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
block|{
return|return
name|rc
return|;
block|}
comment|/* Make a second pass through the command-line argument and set   ** options.  This second pass is delayed until after the initialization   ** file is processed so that the command-line arguments will override   ** settings in the initialization file.   */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|z
init|=
name|argv
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|z
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
continue|continue;
if|if
condition|(
name|z
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
name|z
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-init"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-html"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|mode
operator|=
name|MODE_Html
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-list"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|mode
operator|=
name|MODE_List
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-line"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|mode
operator|=
name|MODE_Line
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-column"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|mode
operator|=
name|MODE_Column
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-csv"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|mode
operator|=
name|MODE_Csv
expr_stmt|;
name|memcpy
argument_list|(
name|data
operator|.
name|separator
argument_list|,
literal|","
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-separator"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|data
operator|.
name|separator
argument_list|)
argument_list|,
name|data
operator|.
name|separator
argument_list|,
literal|"%s"
argument_list|,
name|cmdline_option_value
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|++
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-nullvalue"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|data
operator|.
name|nullvalue
argument_list|)
argument_list|,
name|data
operator|.
name|nullvalue
argument_list|,
literal|"%s"
argument_list|,
name|cmdline_option_value
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|++
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-header"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|showHeader
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-noheader"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|showHeader
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-echo"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|echoOn
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-eqp"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|autoEQP
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-stats"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|statsOn
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-bail"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bail_on_error
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-version"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s %s\n"
argument_list|,
name|sqlite3_libversion
argument_list|()
argument_list|,
name|sqlite3_sourceid
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-interactive"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|stdin_is_interactive
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-batch"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|stdin_is_interactive
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-heap"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-mmap"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-vfs"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SQLITE_ENABLE_VFSTRACE
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-vfstrace"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SQLITE_ENABLE_MULTIPLEX
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-multiplex"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-help"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|usage
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-cmd"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|argc
operator|-
literal|1
condition|)
break|break;
name|z
operator|=
name|cmdline_option_value
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|++
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
name|rc
operator|=
name|do_meta_command
argument_list|(
name|z
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|&&
name|bail_on_error
condition|)
return|return
name|rc
operator|==
literal|2
condition|?
literal|0
else|:
name|rc
return|;
block|}
else|else
block|{
name|open_db
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|shell_exec
argument_list|(
name|data
operator|.
name|db
argument_list|,
name|z
argument_list|,
name|shell_callback
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|zErrMsg
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|zErrMsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|bail_on_error
condition|)
return|return
name|rc
operator|!=
literal|0
condition|?
name|rc
else|:
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: unable to process SQL \"%s\"\n"
argument_list|,
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|bail_on_error
condition|)
return|return
name|rc
return|;
block|}
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Error: unknown option: %s\n"
argument_list|,
name|Argv0
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Use -help for a list of options.\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|zFirstCmd
condition|)
block|{
comment|/* Run just the command that follows the database name     */
if|if
condition|(
name|zFirstCmd
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
name|rc
operator|=
name|do_meta_command
argument_list|(
name|zFirstCmd
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|2
condition|)
name|rc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|open_db
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|shell_exec
argument_list|(
name|data
operator|.
name|db
argument_list|,
name|zFirstCmd
argument_list|,
name|shell_callback
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|zErrMsg
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|zErrMsg
argument_list|)
expr_stmt|;
return|return
name|rc
operator|!=
literal|0
condition|?
name|rc
else|:
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: unable to process SQL \"%s\"\n"
argument_list|,
name|zFirstCmd
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* Run commands received from standard input     */
if|if
condition|(
name|stdin_is_interactive
condition|)
block|{
name|char
modifier|*
name|zHome
decl_stmt|;
name|char
modifier|*
name|zHistory
init|=
literal|0
decl_stmt|;
name|int
name|nHistory
decl_stmt|;
name|printf
argument_list|(
literal|"SQLite version %s %.19s\n"
comment|/*extra-version-info*/
literal|"Enter \".help\" for usage hints.\n"
argument_list|,
name|sqlite3_libversion
argument_list|()
argument_list|,
name|sqlite3_sourceid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|warnInmemoryDb
condition|)
block|{
name|printf
argument_list|(
literal|"Connected to a "
argument_list|)
expr_stmt|;
name|printBold
argument_list|(
literal|"transient in-memory database"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\nUse \".open FILENAME\" to reopen on a "
literal|"persistent database.\n"
argument_list|)
expr_stmt|;
block|}
name|zHome
operator|=
name|find_home_dir
argument_list|()
expr_stmt|;
if|if
condition|(
name|zHome
condition|)
block|{
name|nHistory
operator|=
name|strlen30
argument_list|(
name|zHome
argument_list|)
operator|+
literal|20
expr_stmt|;
if|if
condition|(
operator|(
name|zHistory
operator|=
name|malloc
argument_list|(
name|nHistory
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|sqlite3_snprintf
argument_list|(
name|nHistory
argument_list|,
name|zHistory
argument_list|,
literal|"%s/.sqlite_history"
argument_list|,
name|zHome
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_READLINE
argument_list|)
if|if
condition|(
name|zHistory
condition|)
name|read_history
argument_list|(
name|zHistory
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rc
operator|=
name|process_input
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zHistory
condition|)
block|{
name|stifle_history
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|write_history
argument_list|(
name|zHistory
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zHistory
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rc
operator|=
name|process_input
argument_list|(
operator|&
name|data
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
block|}
block|}
name|set_table_name
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|db
condition|)
block|{
name|sqlite3_close
argument_list|(
name|data
operator|.
name|db
argument_list|)
expr_stmt|;
block|}
name|sqlite3_free
argument_list|(
name|data
operator|.
name|zFreeOnClose
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

end_unit

