begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1997, 1998, 1999 Free Software Foundation, Inc. This file is part of GNU Fortran libU77 library.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  GNU Fortran is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with GNU Fortran; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_if
if|#
directive|if
name|TIME_WITH_SYS_TIME
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HAVE_SYS_TIME_H
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"f2c.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KR_headers
end_ifdef

begin_function_decl
name|VOID
name|s_copy
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
name|void
name|s_copy
parameter_list|(
specifier|register
name|char
modifier|*
name|a
parameter_list|,
specifier|register
name|char
modifier|*
name|b
parameter_list|,
name|ftnlen
name|la
parameter_list|,
name|ftnlen
name|lb
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|G77_date_and_time_0
parameter_list|(
name|char
modifier|*
name|date
parameter_list|,
name|char
modifier|*
name|fftime
parameter_list|,
name|char
modifier|*
name|zone
parameter_list|,
name|integer
modifier|*
name|values
parameter_list|,
name|ftnlen
name|date_len
parameter_list|,
name|ftnlen
name|fftime_len
parameter_list|,
name|ftnlen
name|zone_len
parameter_list|)
block|{
name|time_t
name|lt
init|=
name|time
argument_list|(
operator|&
name|lt
argument_list|)
decl_stmt|;
name|struct
name|tm
name|ltime
init|=
operator|*
name|localtime
argument_list|(
operator|&
name|lt
argument_list|)
decl_stmt|,
name|gtime
init|=
operator|*
name|gmtime
argument_list|(
operator|&
name|lt
argument_list|)
decl_stmt|;
name|char
name|dat
index|[
literal|9
index|]
decl_stmt|,
name|zon
index|[
literal|6
index|]
decl_stmt|,
name|ftim
index|[
literal|11
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|vals
index|[
literal|8
index|]
decl_stmt|;
name|vals
index|[
literal|0
index|]
operator|=
literal|1900
operator|+
name|ltime
operator|.
name|tm_year
expr_stmt|;
name|vals
index|[
literal|1
index|]
operator|=
literal|1
operator|+
name|ltime
operator|.
name|tm_mon
expr_stmt|;
name|vals
index|[
literal|2
index|]
operator|=
name|ltime
operator|.
name|tm_mday
expr_stmt|;
comment|/* fixme: year boundaries */
name|vals
index|[
literal|3
index|]
operator|=
operator|(
name|ltime
operator|.
name|tm_min
operator|-
name|gtime
operator|.
name|tm_min
operator|+
literal|60
operator|*
operator|(
name|ltime
operator|.
name|tm_hour
operator|-
name|gtime
operator|.
name|tm_hour
operator|+
literal|24
operator|*
operator|(
name|ltime
operator|.
name|tm_yday
operator|-
name|gtime
operator|.
name|tm_yday
operator|)
operator|)
operator|)
expr_stmt|;
name|vals
index|[
literal|4
index|]
operator|=
name|ltime
operator|.
name|tm_hour
expr_stmt|;
name|vals
index|[
literal|5
index|]
operator|=
name|ltime
operator|.
name|tm_min
expr_stmt|;
name|vals
index|[
literal|6
index|]
operator|=
name|ltime
operator|.
name|tm_sec
expr_stmt|;
name|vals
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
comment|/* no STDC/POSIX way to get this */
comment|/* GNUish way; maybe use `ftime' on other systems. */
if|#
directive|if
name|HAVE_GETTIMEOFDAY
block|{
name|struct
name|timeval
name|tp
decl_stmt|;
if|#
directive|if
name|GETTIMEOFDAY_ONE_ARGUMENT
if|if
condition|(
operator|!
name|gettimeofday
argument_list|(
operator|&
name|tp
argument_list|)
condition|)
else|#
directive|else
if|#
directive|if
name|HAVE_STRUCT_TIMEZONE
name|struct
name|timezone
name|tzp
decl_stmt|;
comment|/* Some systems such as HPUX, do have struct timezone, but        gettimeofday takes void* as the 2nd arg.  However, the effect        of passing anything other than a null pointer is unspecified on        HPUX.  Configure checks if gettimeofday actually fails with a        non-NULL arg and pretends that struct timezone is missing if it        does fail.  */
if|if
condition|(
operator|!
name|gettimeofday
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|tzp
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
operator|!
name|gettimeofday
argument_list|(
operator|&
name|tp
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
condition|)
endif|#
directive|endif
comment|/* HAVE_STRUCT_TIMEZONE */
endif|#
directive|endif
comment|/* GETTIMEOFDAY_ONE_ARGUMENT */
name|vals
index|[
literal|7
index|]
operator|=
name|tp
operator|.
name|tv_usec
operator|/
literal|1000
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_GETTIMEOFDAY */
if|if
condition|(
name|values
condition|)
comment|/* null pointer for missing optional */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|7
condition|;
name|i
operator|++
control|)
name|values
index|[
name|i
index|]
operator|=
name|vals
index|[
name|i
index|]
expr_stmt|;
name|sprintf
argument_list|(
name|dat
argument_list|,
literal|"%04d%02d%02d"
argument_list|,
name|vals
index|[
literal|0
index|]
argument_list|,
name|vals
index|[
literal|1
index|]
argument_list|,
name|vals
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|s_copy
argument_list|(
name|date
argument_list|,
name|dat
argument_list|,
name|date_len
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
condition|)
block|{
name|sprintf
argument_list|(
name|zon
argument_list|,
literal|"%+03d%02d"
argument_list|,
name|vals
index|[
literal|3
index|]
operator|/
literal|60
argument_list|,
name|abs
argument_list|(
name|vals
index|[
literal|3
index|]
operator|%
literal|60
argument_list|)
argument_list|)
expr_stmt|;
name|s_copy
argument_list|(
name|zone
argument_list|,
name|zon
argument_list|,
name|zone_len
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fftime
condition|)
block|{
name|sprintf
argument_list|(
name|ftim
argument_list|,
literal|"%02d%02d%02d.%03d"
argument_list|,
name|vals
index|[
literal|4
index|]
argument_list|,
name|vals
index|[
literal|5
index|]
argument_list|,
name|vals
index|[
literal|6
index|]
argument_list|,
name|vals
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|s_copy
argument_list|(
name|fftime
argument_list|,
name|ftim
argument_list|,
name|fftime_len
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

