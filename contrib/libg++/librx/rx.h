begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|RXH
argument_list|)
operator|||
name|defined
argument_list|(
name|RX_WANT_SE_DEFS
argument_list|)
end_if

begin_define
define|#
directive|define
name|RXH
end_define

begin_comment
comment|/*	Copyright (C) 1992, 1993 Free Software Foundation, Inc.  This file is part of the librx library.  Librx is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  Librx is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU Library General Public License along with this software; see the file COPYING.LIB.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*  t. lord	Wed Sep 23 18:20:57 1992	*/
end_comment

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|RX_WANT_SE_DEFS
end_ifndef

begin_comment
comment|/* This page: Bitsets */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|RX_subset
end_ifndef

begin_typedef
typedef|typedef
name|unsigned
name|int
name|RX_subset
typedef|;
end_typedef

begin_define
define|#
directive|define
name|RX_subset_bits
value|(32)
end_define

begin_define
define|#
directive|define
name|RX_subset_mask
value|(RX_subset_bits - 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|RX_subset
modifier|*
name|rx_Bitset
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|rx_bitset_iterator
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
name|member_index
parameter_list|)
function_decl|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|rx_bitset_iterator
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|rx_bitset_subset
parameter_list|(
name|N
parameter_list|)
value|((N) / RX_subset_bits)
end_define

begin_define
define|#
directive|define
name|rx_bitset_subset_val
parameter_list|(
name|B
parameter_list|,
name|N
parameter_list|)
value|((B)[rx_bitset_subset(N)])
end_define

begin_define
define|#
directive|define
name|RX_bitset_access
parameter_list|(
name|B
parameter_list|,
name|N
parameter_list|,
name|OP
parameter_list|)
define|\
value|((B)[rx_bitset_subset(N)] OP rx_subset_singletons[(N)& RX_subset_mask])
end_define

begin_define
define|#
directive|define
name|RX_bitset_member
parameter_list|(
name|B
parameter_list|,
name|N
parameter_list|)
value|RX_bitset_access(B, N,&)
end_define

begin_define
define|#
directive|define
name|RX_bitset_enjoin
parameter_list|(
name|B
parameter_list|,
name|N
parameter_list|)
value|RX_bitset_access(B, N, |=)
end_define

begin_define
define|#
directive|define
name|RX_bitset_remove
parameter_list|(
name|B
parameter_list|,
name|N
parameter_list|)
value|RX_bitset_access(B, N,&= ~)
end_define

begin_define
define|#
directive|define
name|RX_bitset_toggle
parameter_list|(
name|B
parameter_list|,
name|N
parameter_list|)
value|RX_bitset_access(B, N, ^= )
end_define

begin_define
define|#
directive|define
name|rx_bitset_numb_subsets
parameter_list|(
name|N
parameter_list|)
value|(((N) + RX_subset_bits - 1) / RX_subset_bits)
end_define

begin_define
define|#
directive|define
name|rx_sizeof_bitset
parameter_list|(
name|N
parameter_list|)
value|(rx_bitset_numb_subsets(N) * sizeof(RX_subset))
end_define

begin_escape
end_escape

begin_comment
comment|/* This page: Splay trees. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|rx_sp_comparer
function_decl|)
parameter_list|(
name|void
modifier|*
name|a
parameter_list|,
name|void
modifier|*
name|b
parameter_list|)
function_decl|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|rx_sp_comparer
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|rx_sp_node
block|{
name|void
modifier|*
name|key
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|struct
name|rx_sp_node
modifier|*
name|kids
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|rx_sp_key_data_freer
function_decl|)
parameter_list|(
name|struct
name|rx_sp_node
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|rx_sp_key_data_freer
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* giant inflatable hash trees */
end_comment

begin_struct
struct|struct
name|rx_hash_item
block|{
name|struct
name|rx_hash_item
modifier|*
name|next_same_hash
decl_stmt|;
name|struct
name|rx_hash
modifier|*
name|table
decl_stmt|;
name|unsigned
name|long
name|hash
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|void
modifier|*
name|binding
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|rx_hash
block|{
name|struct
name|rx_hash
modifier|*
name|parent
decl_stmt|;
name|int
name|refs
decl_stmt|;
name|struct
name|rx_hash
modifier|*
name|children
index|[
literal|13
index|]
decl_stmt|;
name|struct
name|rx_hash_item
modifier|*
name|buckets
index|[
literal|13
index|]
decl_stmt|;
name|int
name|bucket_size
index|[
literal|13
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct_decl
struct_decl|struct
name|rx_hash_rules
struct_decl|;
end_struct_decl

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_comment
comment|/* should return like == */
end_comment

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|rx_hash_eq
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|rx_hash
modifier|*
function_decl|(
modifier|*
name|rx_alloc_hash
function_decl|)
parameter_list|(
name|struct
name|rx_hash_rules
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|rx_free_hash
function_decl|)
parameter_list|(
name|struct
name|rx_hash
modifier|*
parameter_list|,
name|struct
name|rx_hash_rules
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|rx_hash_item
modifier|*
function_decl|(
modifier|*
name|rx_alloc_hash_item
function_decl|)
parameter_list|(
name|struct
name|rx_hash_rules
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|rx_free_hash_item
function_decl|)
parameter_list|(
name|struct
name|rx_hash_item
modifier|*
parameter_list|,
name|struct
name|rx_hash_rules
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|rx_hash_eq
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|rx_hash
modifier|*
function_decl|(
modifier|*
name|rx_alloc_hash
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|rx_free_hash
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|rx_hash_item
modifier|*
function_decl|(
modifier|*
name|rx_alloc_hash_item
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|rx_free_hash_item
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|rx_hash_rules
block|{
name|rx_hash_eq
name|eq
decl_stmt|;
name|rx_alloc_hash
name|hash_alloc
decl_stmt|;
name|rx_free_hash
name|free_hash
decl_stmt|;
name|rx_alloc_hash_item
name|hash_item_alloc
decl_stmt|;
name|rx_free_hash_item
name|free_hash_item
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* Forward declarations */
end_comment

begin_struct_decl
struct_decl|struct
name|rx_cache
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|rx_superset
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|rx
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|rx_se_list
struct_decl|;
end_struct_decl

begin_escape
end_escape

begin_comment
comment|/*   * GLOSSARY  *  * regexp  * regular expression  * expression  * pattern - a `regular' expression.  The expression  *       need not be formally regular -- it can contain  *       constructs that don't correspond to purely regular  *       expressions.  *  * buffer  * string - the string (or strings) being searched or matched.  *  * pattern buffer - a structure of type `struct re_pattern_buffer'  *       This in turn contains a `struct rx', which holds the  *       NFA compiled from a pattern, as well as some of the state  *       of a matcher using the pattern.  *  * NFA - nondeterministic finite automata.  Some people  *       use this term to a member of the class of   *       regular automata (those corresponding to a regular  *       language).  However, in this code, the meaning is  *       more general.  The automata used by Rx are comperable  *       in power to what are usually called `push down automata'.  *  *       Two NFA are built by rx for every pattern.  One is built  *       by the compiler.  The other is built from the first, on  *       the fly, by the matcher.  The latter is called the `superstate  *       NFA' because its states correspond to sets of states from  *       the first NFA.  (Joe Keane gets credit for the name  *       `superstate NFA').  *  * NFA edges  * epsilon edges  * side-effect edges - The NFA compiled from a pattern can have three  *       kinds of edges.  Epsilon edges can be taken freely anytime  *       their source state is reached.  Character set edges can be  *       taken when their source state is reached and when the next   *       character in the buffer is a member of the set.  Side effect  *       edges imply a transition that can only be taken after the  *       indicated side effect has been successfully accomplished.  *       Some examples of side effects are:  *  *		Storing the current match position to record the  *              location of a parentesized subexpression.  *  *              Advancing the matcher over N characters if they  *              match the N characters previously matched by a   *              parentesized subexpression.  *  *       Both of those kinds of edges occur in the NFA generated  *       by the pattern:  \(.\)\1  *  *       Epsilon and side effect edges are similar.  Unfortunately,  *       some of the code uses the name `epsilon edge' to mean  *       both epsilon and side effect edges.  For example,  the  *       function has_non_idempotent_epsilon_path computes the existance  *       of a non-trivial path containing only a mix of epsilon and  *       side effect edges.  In that case `nonidempotent epsilon' is being  *       used to mean `side effect'.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* LOW LEVEL PATTERN BUFFERS */
end_comment

begin_comment
comment|/* Suppose that from some NFA state, more than one path through  * side-effect edges is possible.  In what order should the paths  * be tried?  A function of type rx_se_list_order answers that  * question.  It compares two lists of side effects, and says  * which list comes first.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|rx_se_list_order
function_decl|)
parameter_list|(
name|struct
name|rx
modifier|*
parameter_list|,
name|struct
name|rx_se_list
modifier|*
parameter_list|,
name|struct
name|rx_se_list
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|rx_se_list_order
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Struct RX holds a compiled regular expression - that is, an nfa  * ready to be converted on demand to a more efficient superstate nfa.  * This is for the low level interface.  The high-level interfaces enclose  * this in a `struct re_pattern_buffer'.    */
end_comment

begin_struct
struct|struct
name|rx
block|{
comment|/* The compiler assigns a unique id to every pattern.    * Like sequence numbers in X, there is a subtle bug here    * if you use Rx in a system that runs for a long time.    * But, because of the way the caches work out, it is almost    * impossible to trigger the Rx version of this bug.    *    * The id is used to validate superstates found in a cache    * of superstates.  It isn't sufficient to let a superstate    * point back to the rx for which it was compiled -- the caller    * may be re-using a `struct rx' in which case the superstate    * is not really valid.  So instead, superstates are validated    * by checking the sequence number of the pattern for which    * they were built.    */
name|int
name|rx_id
decl_stmt|;
comment|/* This is memory mgt. state for superstates.  This may be     * shared by more than one struct rx.    */
name|struct
name|rx_cache
modifier|*
name|cache
decl_stmt|;
comment|/* Every regex defines the size of its own character set.     * A superstate has an array of this size, with each element    * a `struct rx_inx'.  So, don't make this number too large.    * In particular, don't make it 2^16.    */
name|int
name|local_cset_size
decl_stmt|;
comment|/* After the NFA is built, it is copied into a contiguous region    * of memory (mostly for compatability with GNU regex).    * Here is that region, and it's size:    */
name|void
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|long
name|allocated
decl_stmt|;
comment|/* Clients of RX can ask for some extra storage in the space pointed    * to by BUFFER.  The field RESERVED is an input parameter to the    * compiler.  After compilation, this much space will be available     * at (buffer + allocated - reserved)    */
name|unsigned
name|long
name|reserved
decl_stmt|;
comment|/* --------- The remaining fields are for internal use only. --------- */
comment|/* --------- But! they must be initialized to 0.	       --------- */
comment|/* NODEC is the number of nodes in the NFA with non-epsilon    * transitions.     */
name|int
name|nodec
decl_stmt|;
comment|/* EPSNODEC is the number of nodes with only epsilon transitions. */
name|int
name|epsnodec
decl_stmt|;
comment|/* The sum (NODEC + EPSNODEC) is the total number of states in the    * compiled NFA.    */
comment|/* Lists of side effects as stored in the NFA are `hash consed'..meaning    * that lists with the same elements are ==.  During compilation,     * this table facilitates hash-consing.    */
name|struct
name|rx_hash
name|se_list_memo
decl_stmt|;
comment|/* Lists of NFA states are also hashed.     */
name|struct
name|rx_hash
name|set_list_memo
decl_stmt|;
comment|/* The compiler and matcher must build a number of instruction frames.    * The format of these frames is fixed (c.f. struct rx_inx).  The values    * of the instructions is not fixed.    *    * An enumerated type (enum rx_opcode) defines the set of instructions    * that the compiler or matcher might generate.  When filling an instruction    * frame, the INX field is found by indexing this instruction table    * with an opcode:    */
name|void
modifier|*
modifier|*
name|instruction_table
decl_stmt|;
comment|/* The list of all states in an NFA.    * During compilation, the NEXT field of NFA states links this list.    * After compilation, all the states are compacted into an array,    * ordered by state id numbers.  At that time, this points to the base     * of that array.    */
name|struct
name|rx_nfa_state
modifier|*
name|nfa_states
decl_stmt|;
comment|/* Every nfa begins with one distinguished starting state:    */
name|struct
name|rx_nfa_state
modifier|*
name|start
decl_stmt|;
comment|/* This orders the search through super-nfa paths.    * See the comment near the typedef of rx_se_list_order.    */
name|rx_se_list_order
name|se_list_cmp
decl_stmt|;
name|struct
name|rx_superset
modifier|*
name|start_set
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* SYNTAX TREES */
end_comment

begin_comment
comment|/* Compilation is in stages.    *  * In the first stage, a pattern specified by a string is   * translated into a syntax tree.  Later stages will convert  * the syntax tree into an NFA optimized for conversion to a  * superstate-NFA.  *  * This page is about syntax trees.  */
end_comment

begin_enum
enum|enum
name|rexp_node_type
block|{
name|r_cset
block|,
comment|/* Match from a character set. `a' or `[a-z]'*/
name|r_concat
block|,
comment|/* Concat two subexpressions.   `ab' */
name|r_alternate
block|,
comment|/* Choose one of two subexpressions. `a\|b' */
name|r_opt
block|,
comment|/* Optional subexpression. `a?' */
name|r_star
block|,
comment|/* Repeated subexpression. `a*' */
comment|/* A 2phase-star is a variation on a repeated subexpression.    * In this case, there are two subexpressions.  The first, if matched,    * begins a repitition (otherwise, the whole expression is matches the    * empth string).      *     * After matching the first subexpression, a 2phase star either finishes,    * or matches the second subexpression.  If the second subexpression is    * matched, then the whole construct repeats.    *    * 2phase stars are used in two circumstances.  First, they    * are used as part of the implementation of POSIX intervals (counted    * repititions).  Second, they are used to implement proper star    * semantics when the repeated subexpression contains paths of    * only side effects.  See rx_compile for more information.    */
name|r_2phase_star
block|,
comment|/* c.f. "typedef void * rx_side_effect" */
name|r_side_effect
block|,
comment|/* This is an extension type:  It is for transient use in source->source    * transformations (implemented over syntax trees).    */
name|r_data
block|}
enum|;
end_enum

begin_comment
comment|/* A side effect is a matcher-specific action associated with  * transitions in the NFA.  The details of side effects are up  * to the matcher.  To the compiler and superstate constructors  * side effects are opaque:  */
end_comment

begin_typedef
typedef|typedef
name|void
modifier|*
name|rx_side_effect
typedef|;
end_typedef

begin_comment
comment|/* Nodes in a syntax tree are of this type:  */
end_comment

begin_struct
struct|struct
name|rexp_node
block|{
name|enum
name|rexp_node_type
name|type
decl_stmt|;
union|union
block|{
name|rx_Bitset
name|cset
decl_stmt|;
name|rx_side_effect
name|side_effect
decl_stmt|;
struct|struct
block|{
name|struct
name|rexp_node
modifier|*
name|left
decl_stmt|;
name|struct
name|rexp_node
modifier|*
name|right
decl_stmt|;
block|}
name|pair
struct|;
name|void
modifier|*
name|data
decl_stmt|;
block|}
name|params
union|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* NFA  *  * A syntax tree is compiled into an NFA.  This page defines the structure  * of that NFA.  */
end_comment

begin_struct
struct|struct
name|rx_nfa_state
block|{
comment|/* These are kept in a list as the NFA is being built. */
name|struct
name|rx_nfa_state
modifier|*
name|next
decl_stmt|;
comment|/* After the NFA is built, states are given integer id's.    * States whose outgoing transitions are all either epsilon or     * side effect edges are given ids less than 0.  Other states    * are given successive non-negative ids starting from 0.    */
name|int
name|id
decl_stmt|;
comment|/* The list of NFA edges that go from this state to some other. */
name|struct
name|rx_nfa_edge
modifier|*
name|edges
decl_stmt|;
comment|/* If you land in this state, then you implicitly land    * in all other states reachable by only epsilon translations.    * Call the set of maximal paths to such states the epsilon closure    * of this state.    *    * There may be other states that are reachable by a mixture of    * epsilon and side effect edges.  Consider the set of maximal paths    * of that sort from this state.  Call it the epsilon-side-effect    * closure of the state.    *     * The epsilon closure of the state is a subset of the epsilon-side-    * effect closure.  It consists of all the paths that contain     * no side effects -- only epsilon edges.    *     * The paths in the epsilon-side-effect closure  can be partitioned    * into equivalance sets. Two paths are equivalant if they have the    * same set of side effects, in the same order.  The epsilon-closure    * is one of these equivalance sets.  Let's call these equivalance    * sets: observably equivalant path sets.  That name is chosen    * because equivalance of two paths means they cause the same side    * effects -- so they lead to the same subsequent observations other    * than that they may wind up in different target states.    *    * The superstate nfa, which is derived from this nfa, is based on    * the observation that all of the paths in an observably equivalant    * path set can be explored at the same time, provided that the    * matcher keeps track not of a single nfa state, but of a set of    * states.   In particular, after following all the paths in an    * observably equivalant set, you wind up at a set of target states.    * That set of target states corresponds to one state in the    * superstate NFA.    *    * Staticly, before matching begins, it is convenient to analyze the    * nfa.  Each state is labeled with a list of the observably    * equivalant path sets who's union covers all the    * epsilon-side-effect paths beginning in this state.  This list is    * called the possible futures of the state.    *    * A trivial example is this NFA:    *             s1    *         A  --->  B    *    *             s2      *            --->  C    *    *             epsilon           s1    *            --------->  D   ------> E    *     *     * In this example, A has two possible futures.    * One invokes the side effect `s1' and contains two paths,    * one ending in state B, the other in state E.    * The other invokes the side effect `s2' and contains only    * one path, landing in state C.    */
name|struct
name|rx_possible_future
modifier|*
name|futures
decl_stmt|;
comment|/* There are exactly two distinguished states in every NFA: */
name|unsigned
name|int
name|is_final
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|is_start
range|:
literal|1
decl_stmt|;
comment|/* These are used during NFA construction... */
name|unsigned
name|int
name|eclosure_needed
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|mark
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* An edge in an NFA is typed: */
end_comment

begin_enum
enum|enum
name|rx_nfa_etype
block|{
comment|/* A cset edge is labled with a set of characters one of which    * must be matched for the edge to be taken.    */
name|ne_cset
block|,
comment|/* An epsilon edge is taken whenever its starting state is    * reached.     */
name|ne_epsilon
block|,
comment|/* A side effect edge is taken whenever its starting state is    * reached.  Side effects may cause the match to fail or the    * position of the matcher to advance.    */
name|ne_side_effect
comment|/* A special kind of epsilon. */
block|}
enum|;
end_enum

begin_struct
struct|struct
name|rx_nfa_edge
block|{
name|struct
name|rx_nfa_edge
modifier|*
name|next
decl_stmt|;
name|enum
name|rx_nfa_etype
name|type
decl_stmt|;
name|struct
name|rx_nfa_state
modifier|*
name|dest
decl_stmt|;
union|union
block|{
name|rx_Bitset
name|cset
decl_stmt|;
name|rx_side_effect
name|side_effect
decl_stmt|;
block|}
name|params
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* A possible future consists of a list of side effects  * and a set of destination states.  Below are their  * representations.  These structures are hash-consed which  * means that lists with the same elements share a representation  * (their addresses are ==).  */
end_comment

begin_struct
struct|struct
name|rx_nfa_state_set
block|{
name|struct
name|rx_nfa_state
modifier|*
name|car
decl_stmt|;
name|struct
name|rx_nfa_state_set
modifier|*
name|cdr
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|rx_se_list
block|{
name|rx_side_effect
name|car
decl_stmt|;
name|struct
name|rx_se_list
modifier|*
name|cdr
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|rx_possible_future
block|{
name|struct
name|rx_possible_future
modifier|*
name|next
decl_stmt|;
name|struct
name|rx_se_list
modifier|*
name|effects
decl_stmt|;
name|struct
name|rx_nfa_state_set
modifier|*
name|destset
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* This begins the description of the superstate NFA.  *  * The superstate NFA corresponds to the NFA in these ways:  *  * Every superstate NFA states SUPER correspond to sets of NFA states,  * nfa_states(SUPER).  *  * Superstate edges correspond to NFA paths.  *  * The superstate has no epsilon transitions;  * every edge has a character label, and a (possibly empty) side  * effect label.   The side effect label corresponds to a list of  * side effects that occur in the NFA.  These parts are referred  * to as:   superedge_character(EDGE) and superedge_sides(EDGE).  *  * For a superstate edge EDGE starting in some superstate SUPER,  * the following is true (in pseudo-notation :-):  *  *       exists DEST in nfa_states s.t.   *         exists nfaEDGE in nfa_edges s.t.  *                 origin (nfaEDGE) == DEST  *&& origin (nfaEDGE) is a member of nfa_states(SUPER)  *&& exists PF in possible_futures(dest(nfaEDGE)) s.t.  * 	                sides_of_possible_future (PF) == superedge_sides (EDGE)  *  * also:  *  *      let SUPER2 := superedge_destination(EDGE)  *          nfa_states(SUPER2)  *           == union of all nfa state sets S s.t.  *                          exists PF in possible_futures(dest(nfaEDGE)) s.t.  * 	                       sides_of_possible_future (PF) == superedge_sides (EDGE)  *&& S == dests_of_possible_future (PF) }  *  * Or in english, every superstate is a set of nfa states.  A given  * character and a superstate implies many transitions in the NFA --  * those that begin with an edge labeled with that character from a  * state in the set corresponding to the superstate.  *   * The destinations of those transitions each have a set of possible  * futures.  A possible future is a list of side effects and a set of  * destination NFA states.  Two sets of possible futures can be  * `merged' by combining all pairs of possible futures that have the  * same side effects.  A pair is combined by creating a new future  * with the same side effect but the union of the two destination sets.  * In this way, all the possible futures suggested by a superstate  * and a character can be merged into a set of possible futures where  * no two elements of the set have the same set of side effects.  *  * The destination of a possible future, being a set of NFA states,   * corresponds to a supernfa state.  So, the merged set of possible  * futures we just created can serve as a set of edges in the  * supernfa.  *  * The representation of the superstate nfa and the nfa is critical.  * The nfa has to be compact, but has to facilitate the rapid  * computation of missing superstates.  The superstate nfa has to   * be fast to interpret, lazilly constructed, and bounded in space.  *  * To facilitate interpretation, the superstate data structures are   * peppered with `instruction frames'.  There is an instruction set  * defined below which matchers using the supernfa must be able to  * interpret.  *  * We'd like to make it possible but not mandatory to use code  * addresses to represent instructions (c.f. gcc's computed goto).  * Therefore, we define an enumerated type of opcodes, and when  * writing one of these instructions into a data structure, use  * the opcode as an index into a table of instruction values.  *   * Here are the opcodes that occur in the superstate nfa:  */
end_comment

begin_comment
comment|/* Every superstate contains a table of instruction frames indexed   * by characters.  A normal `move' in a matcher is to fetch the next  * character and use it as an index into a superstates transition  * table.  *  * In the fasted case, only one edge follows from that character.  * In other cases there is more work to do.  *   * The descriptions of the opcodes refer to data structures that are  * described further below.   */
end_comment

begin_enum
enum|enum
name|rx_opcode
block|{
comment|/*     * BACKTRACK_POINT is invoked when a character transition in     * a superstate leads to more than one edge.  In that case,    * the edges have to be explored independently using a backtracking    * strategy.    *    * A BACKTRACK_POINT instruction is stored in a superstate's     * transition table for some character when it is known that that    * character crosses more than one edge.  On encountering this    * instruction, the matcher saves enough state to backtrack to this    * point in the match later.    */
name|rx_backtrack_point
init|=
literal|0
block|,
comment|/* data is (struct transition_class *) */
comment|/*     * RX_DO_SIDE_EFFECTS evaluates the side effects of an epsilon path.    * There is one occurence of this instruction per rx_distinct_future.    * This instruction is skipped if a rx_distinct_future has no side effects.    */
name|rx_do_side_effects
init|=
name|rx_backtrack_point
operator|+
literal|1
block|,
comment|/* data is (struct rx_distinct_future *) */
comment|/*     * RX_CACHE_MISS instructions are stored in rx_distinct_futures whose    * destination superstate has been reclaimed (or was never built).    * It recomputes the destination superstate.    * RX_CACHE_MISS is also stored in a superstate transition table before    * any of its edges have been built.    */
name|rx_cache_miss
init|=
name|rx_do_side_effects
operator|+
literal|1
block|,
comment|/* data is (struct rx_distinct_future *) */
comment|/*     * RX_NEXT_CHAR is called to consume the next character and take the    * corresponding transition.  This is the only instruction that uses     * the DATA field of the instruction frame instead of DATA_2.    * (see EXPLORE_FUTURE in regex.c).    */
name|rx_next_char
init|=
name|rx_cache_miss
operator|+
literal|1
block|,
comment|/* data is (struct superstate *) */
comment|/* RX_BACKTRACK indicates that a transition fails.    */
name|rx_backtrack
init|=
name|rx_next_char
operator|+
literal|1
block|,
comment|/* no data */
comment|/*     * RX_ERROR_INX is stored only in places that should never be executed.    */
name|rx_error_inx
init|=
name|rx_backtrack
operator|+
literal|1
block|,
comment|/* Not supposed to occur. */
name|rx_num_instructions
init|=
name|rx_error_inx
operator|+
literal|1
block|}
enum|;
end_enum

begin_comment
comment|/* An id_instruction_table holds the values stored in instruction  * frames.  The table is indexed by the enums declared above.  */
end_comment

begin_decl_stmt
specifier|extern
name|void
modifier|*
name|rx_id_instruction_table
index|[
name|rx_num_instructions
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The heart of the matcher is a `word-code-interpreter'   * (like a byte-code interpreter, except that instructions  * are a full word wide).  *  * Instructions are not stored in a vector of code, instead,  * they are scattered throughout the data structures built  * by the regexp compiler and the matcher.  One word-code instruction,  * together with the arguments to that instruction, constitute  * an instruction frame (struct rx_inx).  *  * This structure type is padded by hand to a power of 2 because  * in one of the dominant cases, we dispatch by indexing a table  * of instruction frames.  If that indexing can be accomplished  * by just a shift of the index, we're happy.  *  * Instructions take at most one argument, but there are two  * slots in an instruction frame that might hold that argument.  * These are called data and data_2.  The data slot is only  * used for one instruction (RX_NEXT_CHAR).  For all other   * instructions, data should be set to 0.  *  * RX_NEXT_CHAR is the most important instruction by far.  * By reserving the data field for its exclusive use,   * instruction dispatch is sped up in that case.  There is  * no need to fetch both the instruction and the data,  * only the data is needed.  In other words, a `cycle' begins  * by fetching the field data.  If that is non-0, then it must  * be the destination state of a next_char transition, so  * make that value the current state, advance the match position  * by one character, and start a new cycle.  On the other hand,  * if data is 0, fetch the instruction and do a more complicated  * dispatch on that.  */
end_comment

begin_struct
struct|struct
name|rx_inx
block|{
name|void
modifier|*
name|data
decl_stmt|;
name|void
modifier|*
name|data_2
decl_stmt|;
name|void
modifier|*
name|inx
decl_stmt|;
name|void
modifier|*
name|fnord
decl_stmt|;
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|RX_TAIL_ARRAY
end_ifndef

begin_define
define|#
directive|define
name|RX_TAIL_ARRAY
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* A superstate corresponds to a set of nfa states.  Those sets are  * represented by STRUCT RX_SUPERSET.  The constructors  * guarantee that only one (shared) structure is created for a given set.  */
end_comment

begin_struct
struct|struct
name|rx_superset
block|{
name|int
name|refs
decl_stmt|;
comment|/* This is a reference counted structure. */
comment|/* We keep these sets in a cache because (in an unpredictable way),    * the same set is often created again and again.  But that is also    * problematic -- compatibility with POSIX and GNU regex requires    * that we not be able to tell when a program discards a particular    * NFA (thus invalidating the supersets created from it).    *    * But when a cache hit appears to occur, we will have in hand the    * nfa for which it may have happened.  That is why every nfa is given    * its own sequence number.  On a cache hit, the cache is validated    * by comparing the nfa sequence number to this field:    */
name|int
name|id
decl_stmt|;
name|struct
name|rx_nfa_state
modifier|*
name|car
decl_stmt|;
comment|/* May or may not be a valid addr. */
name|struct
name|rx_superset
modifier|*
name|cdr
decl_stmt|;
comment|/* If the corresponding superstate exists: */
name|struct
name|rx_superstate
modifier|*
name|superstate
decl_stmt|;
comment|/* There is another bookkeeping problem.  It is expensive to     * compute the starting nfa state set for an nfa.  So, once computed,    * it is cached in the `struct rx'.    *    * But, the state set can be flushed from the superstate cache.    * When that happens, we can't know if the corresponding `struct rx'    * is still alive or if it has been freed or re-used by the program.    * So, the cached pointer to this set in a struct rx might be invalid    * and we need a way to validate it.    *    * Fortunately, even if this set is flushed from the cache, it is    * not freed.  It just goes on the free-list of supersets.    * So we can still examine it.      *    * So to validate a starting set memo, check to see if the    * starts_for field still points back to the struct rx in question,    * and if the ID matches the rx sequence number.    */
name|struct
name|rx
modifier|*
name|starts_for
decl_stmt|;
comment|/* This is used to link into a hash bucket so these objects can    * be `hash-consed'.    */
name|struct
name|rx_hash_item
name|hash_item
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|rx_protect_superset
parameter_list|(
name|RX
parameter_list|,
name|CON
parameter_list|)
value|(++(CON)->refs)
end_define

begin_comment
comment|/* The terminology may be confusing (rename this structure?).  * Every character occurs in at most one rx_super_edge per super-state.  * But, that structure might have more than one option, indicating a point  * of non-determinism.   *  * In other words, this structure holds a list of superstate edges  * sharing a common starting state and character label.  The edges  * are in the field OPTIONS.  All superstate edges sharing the same  * starting state and character are in this list.  */
end_comment

begin_struct
struct|struct
name|rx_super_edge
block|{
name|struct
name|rx_super_edge
modifier|*
name|next
decl_stmt|;
name|struct
name|rx_inx
name|rx_backtrack_frame
decl_stmt|;
name|int
name|cset_size
decl_stmt|;
name|rx_Bitset
name|cset
decl_stmt|;
name|struct
name|rx_distinct_future
modifier|*
name|options
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A superstate is a set of nfa states (RX_SUPERSET) along  * with a transition table.  Superstates are built on demand and reclaimed  * without warning.  To protect a superstate from this ghastly fate,  * use LOCK_SUPERSTATE.   */
end_comment

begin_struct
struct|struct
name|rx_superstate
block|{
name|int
name|rx_id
decl_stmt|;
comment|/* c.f. the id field of rx_superset */
name|int
name|locks
decl_stmt|;
comment|/* protection from reclamation */
comment|/* Within a superstate cache, all the superstates are kept in a big    * queue.  The tail of the queue is the state most likely to be    * reclaimed.  The *recyclable fields hold the queue position of     * this state.    */
name|struct
name|rx_superstate
modifier|*
name|next_recyclable
decl_stmt|;
name|struct
name|rx_superstate
modifier|*
name|prev_recyclable
decl_stmt|;
comment|/* The supernfa edges that exist in the cache and that have    * this state as their destination are kept in this list:    */
name|struct
name|rx_distinct_future
modifier|*
name|transition_refs
decl_stmt|;
comment|/* The list of nfa states corresponding to this superstate: */
name|struct
name|rx_superset
modifier|*
name|contents
decl_stmt|;
comment|/* The list of edges in the cache beginning from this state. */
name|struct
name|rx_super_edge
modifier|*
name|edges
decl_stmt|;
comment|/* A tail of the recyclable queue is marked as semifree.  A semifree    * state has no incoming next_char transitions -- any transition    * into a semifree state causes a complex dispatch with the side    * effect of rescuing the state from its semifree state.    *    * An alternative to this might be to make next_char more expensive,    * and to move a state to the head of the recyclable queue whenever    * it is entered.  That way, popular states would never be recycled.    *    * But unilaterally making next_char more expensive actually loses.    * So, incoming transitions are only made expensive for states near    * the tail of the recyclable queue.  The more cache contention    * there is, the more frequently a state will have to prove itself    * and be moved back to the front of the queue.  If there is less     * contention, then popular states just aggregate in the front of     * the queue and stay there.    */
name|int
name|is_semifree
decl_stmt|;
comment|/* This keeps track of the size of the transition table for this    * state.  There is a half-hearted attempt to support variable sized    * superstates.    */
name|int
name|trans_size
decl_stmt|;
comment|/* Indexed by characters... */
name|struct
name|rx_inx
name|transitions
index|[
name|RX_TAIL_ARRAY
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A list of distinct futures define the edges that leave from a   * given superstate on a given character.  c.f. rx_super_edge.  */
end_comment

begin_struct
struct|struct
name|rx_distinct_future
block|{
name|struct
name|rx_distinct_future
modifier|*
name|next_same_super_edge
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|rx_distinct_future
modifier|*
name|next_same_dest
decl_stmt|;
name|struct
name|rx_distinct_future
modifier|*
name|prev_same_dest
decl_stmt|;
name|struct
name|rx_superstate
modifier|*
name|present
decl_stmt|;
comment|/* source state */
name|struct
name|rx_superstate
modifier|*
name|future
decl_stmt|;
comment|/* destination state */
name|struct
name|rx_super_edge
modifier|*
name|edge
decl_stmt|;
comment|/* The future_frame holds the instruction that should be executed    * after all the side effects are done, when it is time to complete    * the transition to the next state.    *    * Normally this is a next_char instruction, but it may be a    * cache_miss instruction as well, depending on whether or not    * the superstate is in the cache and semifree.    *     * If this is the only future for a given superstate/char, and    * if there are no side effects to be performed, this frame is    * not used (directly) at all.  Instead, its contents are copied    * into the transition table of the starting state of this dist. future.    */
name|struct
name|rx_inx
name|future_frame
decl_stmt|;
name|struct
name|rx_inx
name|side_effects_frame
decl_stmt|;
name|struct
name|rx_se_list
modifier|*
name|effects
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|rx_lock_superstate
parameter_list|(
name|R
parameter_list|,
name|S
parameter_list|)
value|((S)->locks++)
end_define

begin_define
define|#
directive|define
name|rx_unlock_superstate
parameter_list|(
name|R
parameter_list|,
name|S
parameter_list|)
value|(--(S)->locks)
end_define

begin_escape
end_escape

begin_comment
comment|/* This page destined for rx.h */
end_comment

begin_struct
struct|struct
name|rx_blocklist
block|{
name|struct
name|rx_blocklist
modifier|*
name|next
decl_stmt|;
name|int
name|bytes
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|rx_freelist
block|{
name|struct
name|rx_freelist
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct_decl
struct_decl|struct
name|rx_cache
struct_decl|;
end_struct_decl

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|rx_morecore_fn
function_decl|)
parameter_list|(
name|struct
name|rx_cache
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|rx_morecore_fn
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* You use this to control the allocation of superstate data   * during matching.  Most of it should be initialized to 0.  *  * A MORECORE function is necessary.  It should allocate  * a new block of memory or return 0.  * A default that uses malloc is called `rx_morecore'.  *  * The number of SUPERSTATES_ALLOWED indirectly limits how much memory  * the system will try to allocate.  The default is 128.  Batch style  * applications that are very regexp intensive should use as high a number  * as possible without thrashing.  *   * The LOCAL_CSET_SIZE is the number of characters in a character set.  * It is therefore the number of entries in a superstate transition table.  * Generally, it should be 256.  If your character set has 16 bits,   * it is better to translate your regexps into equivalent 8 bit patterns.  */
end_comment

begin_struct
struct|struct
name|rx_cache
block|{
name|struct
name|rx_hash_rules
name|superset_hash_rules
decl_stmt|;
comment|/* Objects are allocated by incrementing a pointer that     * scans across rx_blocklists.    */
name|struct
name|rx_blocklist
modifier|*
name|memory
decl_stmt|;
name|struct
name|rx_blocklist
modifier|*
name|memory_pos
decl_stmt|;
name|int
name|bytes_left
decl_stmt|;
name|char
modifier|*
name|memory_addr
decl_stmt|;
name|rx_morecore_fn
name|morecore
decl_stmt|;
comment|/* Freelists. */
name|struct
name|rx_freelist
modifier|*
name|free_superstates
decl_stmt|;
name|struct
name|rx_freelist
modifier|*
name|free_transition_classes
decl_stmt|;
name|struct
name|rx_freelist
modifier|*
name|free_discernable_futures
decl_stmt|;
name|struct
name|rx_freelist
modifier|*
name|free_supersets
decl_stmt|;
name|struct
name|rx_freelist
modifier|*
name|free_hash
decl_stmt|;
comment|/* Two sets of superstates -- those that are semifreed, and those    * that are being used.    */
name|struct
name|rx_superstate
modifier|*
name|lru_superstate
decl_stmt|;
name|struct
name|rx_superstate
modifier|*
name|semifree_superstate
decl_stmt|;
name|struct
name|rx_superset
modifier|*
name|empty_superset
decl_stmt|;
name|int
name|superstates
decl_stmt|;
name|int
name|semifree_superstates
decl_stmt|;
name|int
name|hits
decl_stmt|;
name|int
name|misses
decl_stmt|;
name|int
name|superstates_allowed
decl_stmt|;
name|int
name|local_cset_size
decl_stmt|;
name|void
modifier|*
modifier|*
name|instruction_table
decl_stmt|;
name|struct
name|rx_hash
name|superset_table
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* The lowest-level search function supports arbitrarily fragmented  * strings and (optionally) suspendable/resumable searches.  *  * Callers have to provide a few hooks.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__GNUC__
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|__const__
value|const
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|__const__
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This holds a matcher position */
end_comment

begin_struct
struct|struct
name|rx_string_position
block|{
name|__const__
name|unsigned
name|char
modifier|*
name|pos
decl_stmt|;
comment|/* The current pos. */
name|__const__
name|unsigned
name|char
modifier|*
name|string
decl_stmt|;
comment|/* The current string burst. */
name|__const__
name|unsigned
name|char
modifier|*
name|end
decl_stmt|;
comment|/* First invalid position>= POS. */
name|int
name|offset
decl_stmt|;
comment|/* Integer address of the current burst. */
name|int
name|size
decl_stmt|;
comment|/* Current string's size. */
name|int
name|search_direction
decl_stmt|;
comment|/* 1 or -1 */
name|int
name|search_end
decl_stmt|;
comment|/* First position to not try. */
block|}
struct|;
end_struct

begin_enum
enum|enum
name|rx_get_burst_return
block|{
name|rx_get_burst_continuation
block|,
name|rx_get_burst_error
block|,
name|rx_get_burst_ok
block|,
name|rx_get_burst_no_more
block|}
enum|;
end_enum

begin_comment
comment|/* A call to get burst should make POS valid.  It might be invalid  * if the STRING field doesn't point to a burst that actually  * contains POS.  *  * GET_BURST should take a clue from SEARCH_DIRECTION (1 or -1) as to  * whether or not to pad to the left.  Padding to the right is always  * appropriate, but need not go past the point indicated by STOP.  *  * If a continuation is returned, then the reentering call to  * a search function will retry the get_burst.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_typedef
typedef|typedef
name|enum
name|rx_get_burst_return
function_decl|(
modifier|*
name|rx_get_burst_fn
function_decl|)
parameter_list|(
name|struct
name|rx_string_position
modifier|*
name|pos
parameter_list|,
name|void
modifier|*
name|app_closure
parameter_list|,
name|int
name|stop
parameter_list|)
function_decl|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|enum
name|rx_get_burst_return
function_decl|(
modifier|*
name|rx_get_burst_fn
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_enum
enum|enum
name|rx_back_check_return
block|{
name|rx_back_check_continuation
block|,
name|rx_back_check_error
block|,
name|rx_back_check_pass
block|,
name|rx_back_check_fail
block|}
enum|;
end_enum

begin_comment
comment|/* Back_check should advance the position it is passed   * over rparen - lparen characters and return pass iff  * the characters starting at POS match those indexed  * by [LPAREN..RPAREN].  *  * If a continuation is returned, then the reentering call to  * a search function will retry the back_check.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_typedef
typedef|typedef
name|enum
name|rx_back_check_return
function_decl|(
modifier|*
name|rx_back_check_fn
function_decl|)
parameter_list|(
name|struct
name|rx_string_position
modifier|*
name|pos
parameter_list|,
name|int
name|lparen
parameter_list|,
name|int
name|rparen
parameter_list|,
name|unsigned
name|char
modifier|*
name|translate
parameter_list|,
name|void
modifier|*
name|app_closure
parameter_list|,
name|int
name|stop
parameter_list|)
function_decl|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|enum
name|rx_back_check_return
function_decl|(
modifier|*
name|rx_back_check_fn
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* A call to fetch_char should return the character at POS or POS + 1.  * Returning continuations here isn't supported.  OFFSET is either 0 or 1  * and indicates which characters is desired.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|rx_fetch_char_fn
function_decl|)
parameter_list|(
name|struct
name|rx_string_position
modifier|*
name|pos
parameter_list|,
name|int
name|offset
parameter_list|,
name|void
modifier|*
name|app_closure
parameter_list|,
name|int
name|stop
parameter_list|)
function_decl|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|rx_fetch_char_fn
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_enum
enum|enum
name|rx_search_return
block|{
name|rx_search_continuation
init|=
operator|-
literal|4
block|,
name|rx_search_error
init|=
operator|-
literal|3
block|,
name|rx_search_soft_fail
init|=
operator|-
literal|2
block|,
comment|/* failed by running out of string */
name|rx_search_fail
init|=
operator|-
literal|1
comment|/* failed only by reaching failure states */
comment|/* return values>= 0 indicate the position of a successful match */
block|}
enum|;
end_enum

begin_escape
end_escape

begin_comment
comment|/* regex.h  *   * The remaining declarations replace regex.h.  */
end_comment

begin_comment
comment|/* This is an array of error messages corresponding to the error codes.  */
end_comment

begin_decl_stmt
specifier|extern
name|__const__
name|char
modifier|*
name|re_error_msg
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If any error codes are removed, changed, or added, update the    `re_error_msg' table in regex.c.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|REG_NOERROR
init|=
literal|0
block|,
comment|/* Success.  */
name|REG_NOMATCH
block|,
comment|/* Didn't find a match (for regexec).  */
comment|/* POSIX regcomp return error codes.  (In the order listed in the      standard.)  */
name|REG_BADPAT
block|,
comment|/* Invalid pattern.  */
name|REG_ECOLLATE
block|,
comment|/* Not implemented.  */
name|REG_ECTYPE
block|,
comment|/* Invalid character class name.  */
name|REG_EESCAPE
block|,
comment|/* Trailing backslash.  */
name|REG_ESUBREG
block|,
comment|/* Invalid back reference.  */
name|REG_EBRACK
block|,
comment|/* Unmatched left bracket.  */
name|REG_EPAREN
block|,
comment|/* Parenthesis imbalance.  */
name|REG_EBRACE
block|,
comment|/* Unmatched \{.  */
name|REG_BADBR
block|,
comment|/* Invalid contents of \{\}.  */
name|REG_ERANGE
block|,
comment|/* Invalid range end.  */
name|REG_ESPACE
block|,
comment|/* Ran out of memory.  */
name|REG_BADRPT
block|,
comment|/* No preceding re for repetition op.  */
comment|/* Error codes we've added.  */
name|REG_EEND
block|,
comment|/* Premature end.  */
name|REG_ESIZE
block|,
comment|/* Compiled pattern bigger than 2^16 bytes.  */
name|REG_ERPAREN
comment|/* Unmatched ) or \); not returned from regcomp.  */
block|}
name|reg_errcode_t
typedef|;
end_typedef

begin_comment
comment|/* The regex.c support, as a client of rx, defines a set of possible  * side effects that can be added to the edge lables of nfa edges.  * Here is the list of sidef effects in use.  */
end_comment

begin_enum
enum|enum
name|re_side_effects
block|{
define|#
directive|define
name|RX_WANT_SE_DEFS
value|1
undef|#
directive|undef
name|RX_DEF_SE
undef|#
directive|undef
name|RX_DEF_CPLX_SE
define|#
directive|define
name|RX_DEF_SE
parameter_list|(
name|IDEM
parameter_list|,
name|NAME
parameter_list|,
name|VALUE
parameter_list|)
value|NAME VALUE,
define|#
directive|define
name|RX_DEF_CPLX_SE
parameter_list|(
name|IDEM
parameter_list|,
name|NAME
parameter_list|,
name|VALUE
parameter_list|)
value|NAME VALUE,
include|#
directive|include
file|"rx.h"
undef|#
directive|undef
name|RX_DEF_SE
undef|#
directive|undef
name|RX_DEF_CPLX_SE
undef|#
directive|undef
name|RX_WANT_SE_DEFS
name|re_floogle_flap
init|=
literal|65533
block|}
enum|;
end_enum

begin_comment
comment|/* These hold paramaters for the kinds of side effects that are possible  * in the supported pattern languages.  These include things like the   * numeric bounds of {} operators and the index of paren registers for   * subexpression measurement or backreferencing.  */
end_comment

begin_struct
struct|struct
name|re_se_params
block|{
name|enum
name|re_side_effects
name|se
decl_stmt|;
name|int
name|op1
decl_stmt|;
name|int
name|op2
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|unsigned
name|reg_syntax_t
typedef|;
end_typedef

begin_struct
struct|struct
name|re_pattern_buffer
block|{
name|struct
name|rx
name|rx
decl_stmt|;
name|reg_syntax_t
name|syntax
decl_stmt|;
comment|/* See below for syntax bit definitions. */
name|unsigned
name|int
name|no_sub
range|:
literal|1
decl_stmt|;
comment|/* If set, don't  return register offsets. */
name|unsigned
name|int
name|not_bol
range|:
literal|1
decl_stmt|;
comment|/* If set, the anchors ('^' and '$') don't */
name|unsigned
name|int
name|not_eol
range|:
literal|1
decl_stmt|;
comment|/*     match at the ends of the string.  */
name|unsigned
name|int
name|newline_anchor
range|:
literal|1
decl_stmt|;
comment|/* If true, an anchor at a newline matches.*/
name|unsigned
name|int
name|least_subs
range|:
literal|1
decl_stmt|;
comment|/* If set, and returning registers, return 				 * as few values as possible.  Only  				 * backreferenced groups and group 0 (the whole 				 * match) will be returned. 				 */
comment|/* If true, this says that the matcher should keep registers on its    * backtracking stack.  For many patterns, we can easily determine that    * this isn't necessary.    */
name|unsigned
name|int
name|match_regs_on_stack
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|search_regs_on_stack
range|:
literal|1
decl_stmt|;
comment|/* is_anchored and begbuf_only are filled in by rx_compile. */
name|unsigned
name|int
name|is_anchored
range|:
literal|1
decl_stmt|;
comment|/* Anchorded by ^? */
name|unsigned
name|int
name|begbuf_only
range|:
literal|1
decl_stmt|;
comment|/* Anchored to char position 0? */
comment|/* If REGS_UNALLOCATED, allocate space in the `regs' structure    * for `max (RE_NREGS, re_nsub + 1)' groups.    * If REGS_REALLOCATE, reallocate space if necessary.    * If REGS_FIXED, use what's there.      */
define|#
directive|define
name|REGS_UNALLOCATED
value|0
define|#
directive|define
name|REGS_REALLOCATE
value|1
define|#
directive|define
name|REGS_FIXED
value|2
name|unsigned
name|int
name|regs_allocated
range|:
literal|2
decl_stmt|;
comment|/* Either a translate table to apply to all characters before    * comparing them, or zero for no translation.  The translation    * is applied to a pattern when it is compiled and to a string    * when it is matched.    */
name|unsigned
name|char
modifier|*
name|translate
decl_stmt|;
comment|/* If this is a valid pointer, it tells rx not to store the extents of     * certain subexpressions (those corresponding to non-zero entries).    * Passing 0x1 is the same as passing an array of all ones.  Passing 0x0    * is the same as passing an array of all zeros.    * The array should contain as many entries as their are subexps in the     * regexp.    *    * For POSIX compatability, when using regcomp and regexec this field    * is zeroed and ignored.    */
name|char
modifier|*
name|syntax_parens
decl_stmt|;
comment|/* Number of subexpressions found by the compiler.  */
name|size_t
name|re_nsub
decl_stmt|;
name|void
modifier|*
name|buffer
decl_stmt|;
comment|/* Malloced memory for the nfa. */
name|unsigned
name|long
name|allocated
decl_stmt|;
comment|/* Size of that memory. */
comment|/* Pointer to a fastmap, if any, otherwise zero.  re_search uses    * the fastmap, if there is one, to skip over impossible    * starting points for matches.  */
name|char
modifier|*
name|fastmap
decl_stmt|;
name|unsigned
name|int
name|fastmap_accurate
range|:
literal|1
decl_stmt|;
comment|/* These three are internal. */
name|unsigned
name|int
name|can_match_empty
range|:
literal|1
decl_stmt|;
name|struct
name|rx_nfa_state
modifier|*
name|start
decl_stmt|;
comment|/* The nfa starting state. */
comment|/* This is the list of iterator bounds for {lo,hi} constructs.    * The memory pointed to is part of the rx->buffer.    */
name|struct
name|re_se_params
modifier|*
name|se_params
decl_stmt|;
comment|/* This is a bitset representation of the fastmap.    * This is a true fastmap that already takes the translate    * table into account.    */
name|rx_Bitset
name|fastset
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Type for byte offsets within the string.  POSIX mandates this.  */
end_comment

begin_typedef
typedef|typedef
name|int
name|regoff_t
typedef|;
end_typedef

begin_comment
comment|/* This is the structure we store register match data in.  See    regex.texinfo for a full description of what registers match.  */
end_comment

begin_struct
struct|struct
name|re_registers
block|{
name|unsigned
name|num_regs
decl_stmt|;
name|regoff_t
modifier|*
name|start
decl_stmt|;
name|regoff_t
modifier|*
name|end
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|re_pattern_buffer
name|regex_t
typedef|;
end_typedef

begin_comment
comment|/* POSIX specification for registers.  Aside from the different names than    `re_registers', POSIX uses an array of structures, instead of a    structure of arrays.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|regoff_t
name|rm_so
decl_stmt|;
comment|/* Byte offset from string's start to substring's start.  */
name|regoff_t
name|rm_eo
decl_stmt|;
comment|/* Byte offset from string's start to substring's end.  */
block|}
name|regmatch_t
typedef|;
end_typedef

begin_escape
end_escape

begin_comment
comment|/* The following bits are used to determine the regexp syntax we    recognize.  The set/not-set meanings are chosen so that Emacs syntax    remains the value 0.  The bits are given in alphabetical order, and    the definitions shifted by one from the previous bit; thus, when we    add or remove a bit, only one other definition need change.  */
end_comment

begin_comment
comment|/* If this bit is not set, then \ inside a bracket expression is literal.    If set, then such a \ quotes the following character.  */
end_comment

begin_define
define|#
directive|define
name|RE_BACKSLASH_ESCAPE_IN_LISTS
value|(1)
end_define

begin_comment
comment|/* If this bit is not set, then + and ? are operators, and \+ and \? are      literals.     If set, then \+ and \? are operators and + and ? are literals.  */
end_comment

begin_define
define|#
directive|define
name|RE_BK_PLUS_QM
value|(RE_BACKSLASH_ESCAPE_IN_LISTS<< 1)
end_define

begin_comment
comment|/* If this bit is set, then character classes are supported.  They are:      [:alpha:], [:upper:], [:lower:],  [:digit:], [:alnum:], [:xdigit:],      [:space:], [:print:], [:punct:], [:graph:], and [:cntrl:].    If not set, then character classes are not supported.  */
end_comment

begin_define
define|#
directive|define
name|RE_CHAR_CLASSES
value|(RE_BK_PLUS_QM<< 1)
end_define

begin_comment
comment|/* If this bit is set, then ^ and $ are always anchors (outside bracket      expressions, of course).    If this bit is not set, then it depends:         ^  is an anchor if it is at the beginning of a regular            expression or after an open-group or an alternation operator;         $  is an anchor if it is at the end of a regular expression, or            before a close-group or an alternation operator.       This bit could be (re)combined with RE_CONTEXT_INDEP_OPS, because    POSIX draft 11.2 says that * etc. in leading positions is undefined.    We already implemented a previous draft which made those constructs    invalid, though, so we haven't changed the code back.  */
end_comment

begin_define
define|#
directive|define
name|RE_CONTEXT_INDEP_ANCHORS
value|(RE_CHAR_CLASSES<< 1)
end_define

begin_comment
comment|/* If this bit is set, then special characters are always special      regardless of where they are in the pattern.    If this bit is not set, then special characters are special only in      some contexts; otherwise they are ordinary.  Specifically,       * + ? and intervals are only special when not after the beginning,      open-group, or alternation operator.  */
end_comment

begin_define
define|#
directive|define
name|RE_CONTEXT_INDEP_OPS
value|(RE_CONTEXT_INDEP_ANCHORS<< 1)
end_define

begin_comment
comment|/* If this bit is set, then *, +, ?, and { cannot be first in an re or      immediately after an alternation or begin-group operator.  */
end_comment

begin_define
define|#
directive|define
name|RE_CONTEXT_INVALID_OPS
value|(RE_CONTEXT_INDEP_OPS<< 1)
end_define

begin_comment
comment|/* If this bit is set, then . matches newline.    If not set, then it doesn't.  */
end_comment

begin_define
define|#
directive|define
name|RE_DOT_NEWLINE
value|(RE_CONTEXT_INVALID_OPS<< 1)
end_define

begin_comment
comment|/* If this bit is set, then . doesn't match NUL.    If not set, then it does.  */
end_comment

begin_define
define|#
directive|define
name|RE_DOT_NOT_NULL
value|(RE_DOT_NEWLINE<< 1)
end_define

begin_comment
comment|/* If this bit is set, nonmatching lists [^...] do not match newline.    If not set, they do.  */
end_comment

begin_define
define|#
directive|define
name|RE_HAT_LISTS_NOT_NEWLINE
value|(RE_DOT_NOT_NULL<< 1)
end_define

begin_comment
comment|/* If this bit is set, either \{...\} or {...} defines an      interval, depending on RE_NO_BK_BRACES.     If not set, \{, \}, {, and } are literals.  */
end_comment

begin_define
define|#
directive|define
name|RE_INTERVALS
value|(RE_HAT_LISTS_NOT_NEWLINE<< 1)
end_define

begin_comment
comment|/* If this bit is set, +, ? and | aren't recognized as operators.    If not set, they are.  */
end_comment

begin_define
define|#
directive|define
name|RE_LIMITED_OPS
value|(RE_INTERVALS<< 1)
end_define

begin_comment
comment|/* If this bit is set, newline is an alternation operator.    If not set, newline is literal.  */
end_comment

begin_define
define|#
directive|define
name|RE_NEWLINE_ALT
value|(RE_LIMITED_OPS<< 1)
end_define

begin_comment
comment|/* If this bit is set, then `{...}' defines an interval, and \{ and \}      are literals.   If not set, then `\{...\}' defines an interval.  */
end_comment

begin_define
define|#
directive|define
name|RE_NO_BK_BRACES
value|(RE_NEWLINE_ALT<< 1)
end_define

begin_comment
comment|/* If this bit is set, (...) defines a group, and \( and \) are literals.    If not set, \(...\) defines a group, and ( and ) are literals.  */
end_comment

begin_define
define|#
directive|define
name|RE_NO_BK_PARENS
value|(RE_NO_BK_BRACES<< 1)
end_define

begin_comment
comment|/* If this bit is set, then \<digit> matches<digit>.    If not set, then \<digit> is a back-reference.  */
end_comment

begin_define
define|#
directive|define
name|RE_NO_BK_REFS
value|(RE_NO_BK_PARENS<< 1)
end_define

begin_comment
comment|/* If this bit is set, then | is an alternation operator, and \| is literal.     If not set, then \| is an alternation operator, and | is literal.  */
end_comment

begin_define
define|#
directive|define
name|RE_NO_BK_VBAR
value|(RE_NO_BK_REFS<< 1)
end_define

begin_comment
comment|/* If this bit is set, then an ending range point collating higher      than the starting range point, as in [z-a], is invalid.    If not set, then when ending range point collates higher than the      starting range point, the range is ignored.  */
end_comment

begin_define
define|#
directive|define
name|RE_NO_EMPTY_RANGES
value|(RE_NO_BK_VBAR<< 1)
end_define

begin_comment
comment|/* If this bit is set, then an unmatched ) is ordinary.    If not set, then an unmatched ) is invalid.  */
end_comment

begin_define
define|#
directive|define
name|RE_UNMATCHED_RIGHT_PAREN_ORD
value|(RE_NO_EMPTY_RANGES<< 1)
end_define

begin_comment
comment|/* This global variable defines the particular regexp syntax to use (for    some interfaces).  When a regexp is compiled, the syntax used is    stored in the pattern buffer, so changing this does not affect    already-compiled regexps.  */
end_comment

begin_decl_stmt
specifier|extern
name|reg_syntax_t
name|re_syntax_options
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Define combinations of the above bits for the standard possibilities.    (The [[[ comments delimit what gets put into the Texinfo file, so    don't delete them!)  */
end_comment

begin_comment
comment|/* [[[begin syntaxes]]] */
end_comment

begin_define
define|#
directive|define
name|RE_SYNTAX_EMACS
value|0
end_define

begin_define
define|#
directive|define
name|RE_SYNTAX_AWK
define|\
value|(RE_BACKSLASH_ESCAPE_IN_LISTS | RE_DOT_NOT_NULL			\    | RE_NO_BK_PARENS            | RE_NO_BK_REFS				\    | RE_NO_BK_VBAR               | RE_NO_EMPTY_RANGES			\    | RE_UNMATCHED_RIGHT_PAREN_ORD)
end_define

begin_define
define|#
directive|define
name|RE_SYNTAX_POSIX_AWK
define|\
value|(RE_SYNTAX_POSIX_EXTENDED | RE_BACKSLASH_ESCAPE_IN_LISTS)
end_define

begin_define
define|#
directive|define
name|RE_SYNTAX_GREP
define|\
value|(RE_BK_PLUS_QM              | RE_CHAR_CLASSES				\    | RE_HAT_LISTS_NOT_NEWLINE | RE_INTERVALS				\    | RE_NEWLINE_ALT)
end_define

begin_define
define|#
directive|define
name|RE_SYNTAX_EGREP
define|\
value|(RE_CHAR_CLASSES        | RE_CONTEXT_INDEP_ANCHORS			\    | RE_CONTEXT_INDEP_OPS | RE_HAT_LISTS_NOT_NEWLINE			\    | RE_NEWLINE_ALT       | RE_NO_BK_PARENS				\    | RE_NO_BK_VBAR)
end_define

begin_define
define|#
directive|define
name|RE_SYNTAX_POSIX_EGREP
define|\
value|(RE_SYNTAX_EGREP | RE_INTERVALS | RE_NO_BK_BRACES)
end_define

begin_define
define|#
directive|define
name|RE_SYNTAX_SED
value|RE_SYNTAX_POSIX_BASIC
end_define

begin_comment
comment|/* Syntax bits common to both basic and extended POSIX regex syntax.  */
end_comment

begin_define
define|#
directive|define
name|_RE_SYNTAX_POSIX_COMMON
define|\
value|(RE_CHAR_CLASSES | RE_DOT_NEWLINE      | RE_DOT_NOT_NULL		\    | RE_INTERVALS  | RE_NO_EMPTY_RANGES)
end_define

begin_define
define|#
directive|define
name|RE_SYNTAX_POSIX_BASIC
define|\
value|(_RE_SYNTAX_POSIX_COMMON | RE_BK_PLUS_QM)
end_define

begin_comment
comment|/* Differs from ..._POSIX_BASIC only in that RE_BK_PLUS_QM becomes    RE_LIMITED_OPS, i.e., \? \+ \| are not recognized.  Actually, this    isn't minimal, since other operators, such as \`, aren't disabled.  */
end_comment

begin_define
define|#
directive|define
name|RE_SYNTAX_POSIX_MINIMAL_BASIC
define|\
value|(_RE_SYNTAX_POSIX_COMMON | RE_LIMITED_OPS)
end_define

begin_define
define|#
directive|define
name|RE_SYNTAX_POSIX_EXTENDED
define|\
value|(_RE_SYNTAX_POSIX_COMMON | RE_CONTEXT_INDEP_ANCHORS			\    | RE_CONTEXT_INDEP_OPS  | RE_NO_BK_BRACES				\    | RE_NO_BK_PARENS       | RE_NO_BK_VBAR				\    | RE_UNMATCHED_RIGHT_PAREN_ORD)
end_define

begin_comment
comment|/* Differs from ..._POSIX_EXTENDED in that RE_CONTEXT_INVALID_OPS    replaces RE_CONTEXT_INDEP_OPS and RE_NO_BK_REFS is added.  */
end_comment

begin_define
define|#
directive|define
name|RE_SYNTAX_POSIX_MINIMAL_EXTENDED
define|\
value|(_RE_SYNTAX_POSIX_COMMON  | RE_CONTEXT_INDEP_ANCHORS			\    | RE_CONTEXT_INVALID_OPS | RE_NO_BK_BRACES				\    | RE_NO_BK_PARENS        | RE_NO_BK_REFS				\    | RE_NO_BK_VBAR	    | RE_UNMATCHED_RIGHT_PAREN_ORD)
end_define

begin_comment
comment|/* [[[end syntaxes]]] */
end_comment

begin_comment
comment|/* Maximum number of duplicates an interval can allow.  Some systems    (erroneously) define this in other header files, but we want our    value, so remove any previous define.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RE_DUP_MAX
end_ifdef

begin_undef
undef|#
directive|undef
name|RE_DUP_MAX
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|RE_DUP_MAX
value|((1<< 15) - 1)
end_define

begin_comment
comment|/* POSIX `cflags' bits (i.e., information for `regcomp').  */
end_comment

begin_comment
comment|/* If this bit is set, then use extended regular expression syntax.    If not set, then use basic regular expression syntax.  */
end_comment

begin_define
define|#
directive|define
name|REG_EXTENDED
value|1
end_define

begin_comment
comment|/* If this bit is set, then ignore case when matching.    If not set, then case is significant.  */
end_comment

begin_define
define|#
directive|define
name|REG_ICASE
value|(REG_EXTENDED<< 1)
end_define

begin_comment
comment|/* If this bit is set, then anchors do not match at newline      characters in the string.    If not set, then anchors do match at newlines.  */
end_comment

begin_define
define|#
directive|define
name|REG_NEWLINE
value|(REG_ICASE<< 1)
end_define

begin_comment
comment|/* If this bit is set, then report only success or fail in regexec.    If not set, then returns differ between not matching and errors.  */
end_comment

begin_define
define|#
directive|define
name|REG_NOSUB
value|(REG_NEWLINE<< 1)
end_define

begin_comment
comment|/* POSIX `eflags' bits (i.e., information for regexec).  */
end_comment

begin_comment
comment|/* If this bit is set, then the beginning-of-line operator doesn't match      the beginning of the string (presumably because it's not the      beginning of a line).    If not set, then the beginning-of-line operator does match the      beginning of the string.  */
end_comment

begin_define
define|#
directive|define
name|REG_NOTBOL
value|1
end_define

begin_comment
comment|/* Like REG_NOTBOL, except for the end-of-line.  */
end_comment

begin_define
define|#
directive|define
name|REG_NOTEOL
value|(1<< 1)
end_define

begin_comment
comment|/* If `regs_allocated' is REGS_UNALLOCATED in the pattern buffer,  * `re_match_2' returns information about at least this many registers  * the first time a `regs' structure is passed.   *  * Also, this is the greatest number of backreferenced subexpressions  * allowed in a pattern being matched without caller-supplied registers.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|RE_NREGS
end_ifndef

begin_define
define|#
directive|define
name|RE_NREGS
value|30
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|rx_cache_bound
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|rx_version_string
index|[]
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|RX_WANT_RX_DEFS
end_ifdef

begin_comment
comment|/* This is decls to the interesting subsystems and lower layers  * of rx.  Everything which doesn't have a public counterpart in   * regex.c is declared here.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|rx_hash_freefn
function_decl|)
parameter_list|(
name|struct
name|rx_hash_item
modifier|*
name|it
parameter_list|)
function_decl|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ndef __STDC__ */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|rx_hash_freefn
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ndef __STDC__ */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function_decl
name|RX_DECL
name|int
name|rx_bitset_is_equal
parameter_list|(
name|int
name|size
parameter_list|,
name|rx_Bitset
name|a
parameter_list|,
name|rx_Bitset
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|int
name|rx_bitset_is_subset
parameter_list|(
name|int
name|size
parameter_list|,
name|rx_Bitset
name|a
parameter_list|,
name|rx_Bitset
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|int
name|rx_bitset_empty
parameter_list|(
name|int
name|size
parameter_list|,
name|rx_Bitset
name|set
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_bitset_null
parameter_list|(
name|int
name|size
parameter_list|,
name|rx_Bitset
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_bitset_universe
parameter_list|(
name|int
name|size
parameter_list|,
name|rx_Bitset
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_bitset_complement
parameter_list|(
name|int
name|size
parameter_list|,
name|rx_Bitset
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_bitset_assign
parameter_list|(
name|int
name|size
parameter_list|,
name|rx_Bitset
name|a
parameter_list|,
name|rx_Bitset
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_bitset_union
parameter_list|(
name|int
name|size
parameter_list|,
name|rx_Bitset
name|a
parameter_list|,
name|rx_Bitset
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_bitset_intersection
parameter_list|(
name|int
name|size
parameter_list|,
name|rx_Bitset
name|a
parameter_list|,
name|rx_Bitset
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_bitset_difference
parameter_list|(
name|int
name|size
parameter_list|,
name|rx_Bitset
name|a
parameter_list|,
name|rx_Bitset
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_bitset_revdifference
parameter_list|(
name|int
name|size
parameter_list|,
name|rx_Bitset
name|a
parameter_list|,
name|rx_Bitset
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_bitset_xor
parameter_list|(
name|int
name|size
parameter_list|,
name|rx_Bitset
name|a
parameter_list|,
name|rx_Bitset
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|unsigned
name|long
name|rx_bitset_hash
parameter_list|(
name|int
name|size
parameter_list|,
name|rx_Bitset
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rx_hash_item
modifier|*
name|rx_hash_find
parameter_list|(
name|struct
name|rx_hash
modifier|*
name|table
parameter_list|,
name|unsigned
name|long
name|hash
parameter_list|,
name|void
modifier|*
name|value
parameter_list|,
name|struct
name|rx_hash_rules
modifier|*
name|rules
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rx_hash_item
modifier|*
name|rx_hash_store
parameter_list|(
name|struct
name|rx_hash
modifier|*
name|table
parameter_list|,
name|unsigned
name|long
name|hash
parameter_list|,
name|void
modifier|*
name|value
parameter_list|,
name|struct
name|rx_hash_rules
modifier|*
name|rules
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_hash_free
parameter_list|(
name|struct
name|rx_hash_item
modifier|*
name|it
parameter_list|,
name|struct
name|rx_hash_rules
modifier|*
name|rules
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_free_hash_table
parameter_list|(
name|struct
name|rx_hash
modifier|*
name|tab
parameter_list|,
name|rx_hash_freefn
name|freefn
parameter_list|,
name|struct
name|rx_hash_rules
modifier|*
name|rules
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|rx_Bitset
name|rx_cset
parameter_list|(
name|struct
name|rx
modifier|*
name|rx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|rx_Bitset
name|rx_copy_cset
parameter_list|(
name|struct
name|rx
modifier|*
name|rx
parameter_list|,
name|rx_Bitset
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_free_cset
parameter_list|(
name|struct
name|rx
modifier|*
name|rx
parameter_list|,
name|rx_Bitset
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rexp_node
modifier|*
name|rexp_node
parameter_list|(
name|struct
name|rx
modifier|*
name|rx
parameter_list|,
name|enum
name|rexp_node_type
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rexp_node
modifier|*
name|rx_mk_r_cset
parameter_list|(
name|struct
name|rx
modifier|*
name|rx
parameter_list|,
name|rx_Bitset
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rexp_node
modifier|*
name|rx_mk_r_concat
parameter_list|(
name|struct
name|rx
modifier|*
name|rx
parameter_list|,
name|struct
name|rexp_node
modifier|*
name|a
parameter_list|,
name|struct
name|rexp_node
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rexp_node
modifier|*
name|rx_mk_r_alternate
parameter_list|(
name|struct
name|rx
modifier|*
name|rx
parameter_list|,
name|struct
name|rexp_node
modifier|*
name|a
parameter_list|,
name|struct
name|rexp_node
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rexp_node
modifier|*
name|rx_mk_r_opt
parameter_list|(
name|struct
name|rx
modifier|*
name|rx
parameter_list|,
name|struct
name|rexp_node
modifier|*
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rexp_node
modifier|*
name|rx_mk_r_star
parameter_list|(
name|struct
name|rx
modifier|*
name|rx
parameter_list|,
name|struct
name|rexp_node
modifier|*
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rexp_node
modifier|*
name|rx_mk_r_2phase_star
parameter_list|(
name|struct
name|rx
modifier|*
name|rx
parameter_list|,
name|struct
name|rexp_node
modifier|*
name|a
parameter_list|,
name|struct
name|rexp_node
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rexp_node
modifier|*
name|rx_mk_r_side_effect
parameter_list|(
name|struct
name|rx
modifier|*
name|rx
parameter_list|,
name|rx_side_effect
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rexp_node
modifier|*
name|rx_mk_r_data
parameter_list|(
name|struct
name|rx
modifier|*
name|rx
parameter_list|,
name|void
modifier|*
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_free_rexp
parameter_list|(
name|struct
name|rx
modifier|*
name|rx
parameter_list|,
name|struct
name|rexp_node
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rexp_node
modifier|*
name|rx_copy_rexp
parameter_list|(
name|struct
name|rx
modifier|*
name|rx
parameter_list|,
name|struct
name|rexp_node
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rx_nfa_state
modifier|*
name|rx_nfa_state
parameter_list|(
name|struct
name|rx
modifier|*
name|rx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_free_nfa_state
parameter_list|(
name|struct
name|rx_nfa_state
modifier|*
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rx_nfa_state
modifier|*
name|rx_id_to_nfa_state
parameter_list|(
name|struct
name|rx
modifier|*
name|rx
parameter_list|,
name|int
name|id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rx_nfa_edge
modifier|*
name|rx_nfa_edge
parameter_list|(
name|struct
name|rx
modifier|*
name|rx
parameter_list|,
name|enum
name|rx_nfa_etype
name|type
parameter_list|,
name|struct
name|rx_nfa_state
modifier|*
name|start
parameter_list|,
name|struct
name|rx_nfa_state
modifier|*
name|dest
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_free_nfa_edge
parameter_list|(
name|struct
name|rx_nfa_edge
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_free_nfa
parameter_list|(
name|struct
name|rx
modifier|*
name|rx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|int
name|rx_build_nfa
parameter_list|(
name|struct
name|rx
modifier|*
name|rx
parameter_list|,
name|struct
name|rexp_node
modifier|*
name|rexp
parameter_list|,
name|struct
name|rx_nfa_state
modifier|*
modifier|*
name|start
parameter_list|,
name|struct
name|rx_nfa_state
modifier|*
modifier|*
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_name_nfa_states
parameter_list|(
name|struct
name|rx
modifier|*
name|rx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|int
name|rx_eclose_nfa
parameter_list|(
name|struct
name|rx
modifier|*
name|rx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_delete_epsilon_transitions
parameter_list|(
name|struct
name|rx
modifier|*
name|rx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|int
name|rx_compactify_nfa
parameter_list|(
name|struct
name|rx
modifier|*
name|rx
parameter_list|,
name|void
modifier|*
modifier|*
name|mem
parameter_list|,
name|unsigned
name|long
modifier|*
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_release_superset
parameter_list|(
name|struct
name|rx
modifier|*
name|rx
parameter_list|,
name|struct
name|rx_superset
modifier|*
name|set
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rx_superset
modifier|*
name|rx_superset_cons
parameter_list|(
name|struct
name|rx
modifier|*
name|rx
parameter_list|,
name|struct
name|rx_nfa_state
modifier|*
name|car
parameter_list|,
name|struct
name|rx_superset
modifier|*
name|cdr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rx_superset
modifier|*
name|rx_superstate_eclosure_union
parameter_list|(
name|struct
name|rx
modifier|*
name|rx
parameter_list|,
name|struct
name|rx_superset
modifier|*
name|set
parameter_list|,
name|struct
name|rx_nfa_state_set
modifier|*
name|ecl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rx_superstate
modifier|*
name|rx_superstate
parameter_list|(
name|struct
name|rx
modifier|*
name|rx
parameter_list|,
name|struct
name|rx_superset
modifier|*
name|set
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rx_inx
modifier|*
name|rx_handle_cache_miss
parameter_list|(
name|struct
name|rx
modifier|*
name|rx
parameter_list|,
name|struct
name|rx_superstate
modifier|*
name|super
parameter_list|,
name|unsigned
name|char
name|chr
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|reg_errcode_t
name|rx_compile
parameter_list|(
name|__const__
name|char
modifier|*
name|pattern
parameter_list|,
name|int
name|size
parameter_list|,
name|reg_syntax_t
name|syntax
parameter_list|,
name|struct
name|re_pattern_buffer
modifier|*
name|rxb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_blow_up_fastmap
parameter_list|(
name|struct
name|re_pattern_buffer
modifier|*
name|rxb
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* STDC */
end_comment

begin_function_decl
name|RX_DECL
name|int
name|rx_bitset_is_equal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|int
name|rx_bitset_is_subset
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|int
name|rx_bitset_empty
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_bitset_null
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_bitset_universe
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_bitset_complement
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_bitset_assign
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_bitset_union
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_bitset_intersection
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_bitset_difference
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_bitset_revdifference
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_bitset_xor
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|unsigned
name|long
name|rx_bitset_hash
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rx_hash_item
modifier|*
name|rx_hash_find
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rx_hash_item
modifier|*
name|rx_hash_store
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_hash_free
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_free_hash_table
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|rx_Bitset
name|rx_cset
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|rx_Bitset
name|rx_copy_cset
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_free_cset
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rexp_node
modifier|*
name|rexp_node
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rexp_node
modifier|*
name|rx_mk_r_cset
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rexp_node
modifier|*
name|rx_mk_r_concat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rexp_node
modifier|*
name|rx_mk_r_alternate
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rexp_node
modifier|*
name|rx_mk_r_opt
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rexp_node
modifier|*
name|rx_mk_r_star
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rexp_node
modifier|*
name|rx_mk_r_2phase_star
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rexp_node
modifier|*
name|rx_mk_r_side_effect
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rexp_node
modifier|*
name|rx_mk_r_data
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_free_rexp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rexp_node
modifier|*
name|rx_copy_rexp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rx_nfa_state
modifier|*
name|rx_nfa_state
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_free_nfa_state
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rx_nfa_state
modifier|*
name|rx_id_to_nfa_state
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rx_nfa_edge
modifier|*
name|rx_nfa_edge
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_free_nfa_edge
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_free_nfa
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|int
name|rx_build_nfa
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_name_nfa_states
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|int
name|rx_eclose_nfa
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_delete_epsilon_transitions
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|int
name|rx_compactify_nfa
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_release_superset
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rx_superset
modifier|*
name|rx_superset_cons
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rx_superset
modifier|*
name|rx_superstate_eclosure_union
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rx_superstate
modifier|*
name|rx_superstate
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|struct
name|rx_inx
modifier|*
name|rx_handle_cache_miss
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|reg_errcode_t
name|rx_compile
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RX_DECL
name|void
name|rx_blow_up_fastmap
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STDC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RX_WANT_RX_DEFS */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function_decl
specifier|extern
name|int
name|re_search_2
parameter_list|(
name|struct
name|re_pattern_buffer
modifier|*
name|rxb
parameter_list|,
name|__const__
name|char
modifier|*
name|string1
parameter_list|,
name|int
name|size1
parameter_list|,
name|__const__
name|char
modifier|*
name|string2
parameter_list|,
name|int
name|size2
parameter_list|,
name|int
name|startpos
parameter_list|,
name|int
name|range
parameter_list|,
name|struct
name|re_registers
modifier|*
name|regs
parameter_list|,
name|int
name|stop
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|re_search
parameter_list|(
name|struct
name|re_pattern_buffer
modifier|*
name|rxb
parameter_list|,
name|__const__
name|char
modifier|*
name|string
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|startpos
parameter_list|,
name|int
name|range
parameter_list|,
name|struct
name|re_registers
modifier|*
name|regs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|re_match_2
parameter_list|(
name|struct
name|re_pattern_buffer
modifier|*
name|rxb
parameter_list|,
name|__const__
name|char
modifier|*
name|string1
parameter_list|,
name|int
name|size1
parameter_list|,
name|__const__
name|char
modifier|*
name|string2
parameter_list|,
name|int
name|size2
parameter_list|,
name|int
name|pos
parameter_list|,
name|struct
name|re_registers
modifier|*
name|regs
parameter_list|,
name|int
name|stop
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|re_match
parameter_list|(
name|struct
name|re_pattern_buffer
modifier|*
name|rxb
parameter_list|,
name|__const__
name|char
modifier|*
name|string
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|pos
parameter_list|,
name|struct
name|re_registers
modifier|*
name|regs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|reg_syntax_t
name|re_set_syntax
parameter_list|(
name|reg_syntax_t
name|syntax
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|re_set_registers
parameter_list|(
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
parameter_list|,
name|struct
name|re_registers
modifier|*
name|regs
parameter_list|,
name|unsigned
name|num_regs
parameter_list|,
name|regoff_t
modifier|*
name|starts
parameter_list|,
name|regoff_t
modifier|*
name|ends
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|__const__
name|char
modifier|*
name|re_compile_pattern
parameter_list|(
name|__const__
name|char
modifier|*
name|pattern
parameter_list|,
name|int
name|length
parameter_list|,
name|struct
name|re_pattern_buffer
modifier|*
name|rxb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|re_compile_fastmap
parameter_list|(
name|struct
name|re_pattern_buffer
modifier|*
name|rxb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|re_comp
parameter_list|(
name|__const__
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|re_exec
parameter_list|(
name|__const__
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|regcomp
parameter_list|(
name|regex_t
modifier|*
name|preg
parameter_list|,
name|__const__
name|char
modifier|*
name|pattern
parameter_list|,
name|int
name|cflags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|regexec
parameter_list|(
name|__const__
name|regex_t
modifier|*
name|preg
parameter_list|,
name|__const__
name|char
modifier|*
name|string
parameter_list|,
name|size_t
name|nmatch
parameter_list|,
name|regmatch_t
name|pmatch
index|[]
parameter_list|,
name|int
name|eflags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|size_t
name|regerror
parameter_list|(
name|int
name|errcode
parameter_list|,
name|__const__
name|regex_t
modifier|*
name|preg
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|,
name|size_t
name|errbuf_size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|regfree
parameter_list|(
name|regex_t
modifier|*
name|preg
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* STDC */
end_comment

begin_function_decl
specifier|extern
name|int
name|re_search_2
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|re_search
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|re_match_2
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|re_match
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|reg_syntax_t
name|re_set_syntax
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|re_set_registers
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|__const__
name|char
modifier|*
name|re_compile_pattern
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|re_compile_fastmap
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|re_comp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|re_exec
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|regcomp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|regexec
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|size_t
name|regerror
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|regfree
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STDC */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|RX_WANT_RX_DEFS
end_ifdef

begin_struct
struct|struct
name|rx_counter_frame
block|{
name|int
name|tag
decl_stmt|;
name|int
name|val
decl_stmt|;
name|struct
name|rx_counter_frame
modifier|*
name|inherited_from
decl_stmt|;
comment|/* If this is a copy. */
name|struct
name|rx_counter_frame
modifier|*
name|cdr
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|rx_backtrack_frame
block|{
name|char
modifier|*
name|counter_stack_sp
decl_stmt|;
comment|/* A frame is used to save the matchers state when it crosses a     * backtracking point.  The `stk_' fields correspond to variables    * in re_search_2 (just strip off thes `stk_').  They are documented    * tere.    */
name|struct
name|rx_superstate
modifier|*
name|stk_super
decl_stmt|;
name|unsigned
name|int
name|stk_c
decl_stmt|;
name|struct
name|rx_string_position
name|stk_test_pos
decl_stmt|;
name|int
name|stk_last_l
decl_stmt|;
name|int
name|stk_last_r
decl_stmt|;
name|int
name|stk_test_ret
decl_stmt|;
comment|/* This is the list of options left to explore at the backtrack    * point for which this frame was created.     */
name|struct
name|rx_distinct_future
modifier|*
name|df
decl_stmt|;
name|struct
name|rx_distinct_future
modifier|*
name|first_df
decl_stmt|;
ifdef|#
directive|ifdef
name|RX_DEBUG
name|int
name|stk_line_no
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_struct
struct|struct
name|rx_stack_chunk
block|{
name|struct
name|rx_stack_chunk
modifier|*
name|next_chunk
decl_stmt|;
name|int
name|bytes_left
decl_stmt|;
name|char
modifier|*
name|sp
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|rx_outer_entry
block|{
name|rx_outer_start
block|,
name|rx_outer_fastmap
block|,
name|rx_outer_test
block|,
name|rx_outer_restore_pos
block|}
enum|;
end_enum

begin_enum
enum|enum
name|rx_fastmap_return
block|{
name|rx_fastmap_continuation
block|,
name|rx_fastmap_error
block|,
name|rx_fastmap_ok
block|,
name|rx_fastmap_fail
block|}
enum|;
end_enum

begin_enum
enum|enum
name|rx_fastmap_entry
block|{
name|rx_fastmap_start
block|,
name|rx_fastmap_string_break
block|}
enum|;
end_enum

begin_enum
enum|enum
name|rx_test_return
block|{
name|rx_test_continuation
block|,
name|rx_test_error
block|,
name|rx_test_fail
block|,
name|rx_test_ok
block|}
enum|;
end_enum

begin_enum
enum|enum
name|rx_test_internal_return
block|{
name|rx_test_internal_error
block|,
name|rx_test_found_first
block|,
name|rx_test_line_finished
block|}
enum|;
end_enum

begin_enum
enum|enum
name|rx_test_match_entry
block|{
name|rx_test_start
block|,
name|rx_test_cache_hit_loop
block|,
name|rx_test_backreference_check
block|,
name|rx_test_backtrack_return
block|}
enum|;
end_enum

begin_struct
struct|struct
name|rx_search_state
block|{
comment|/* Two groups of registers are kept.  The group with the register state    * of the current test match, and the group that holds the state at the end    * of the best known match, if any.    *    * For some patterns, there may also be registers saved on the stack.    */
name|unsigned
name|num_regs
decl_stmt|;
comment|/* Includes an element for register zero. */
name|regoff_t
modifier|*
name|lparen
decl_stmt|;
comment|/* scratch space for register returns */
name|regoff_t
modifier|*
name|rparen
decl_stmt|;
name|regoff_t
modifier|*
name|best_lpspace
decl_stmt|;
comment|/* in case the user doesn't want these */
name|regoff_t
modifier|*
name|best_rpspace
decl_stmt|;
comment|/* values, we still need space to store 				 * them.  Normally, this memoryis unused 				 * and the space pointed to by REGS is  				 * used instead. 				 */
name|int
name|last_l
decl_stmt|;
comment|/* Highest index of a valid lparen. */
name|int
name|last_r
decl_stmt|;
comment|/* It's dual. */
name|int
modifier|*
name|best_lparen
decl_stmt|;
comment|/* This contains the best known register */
name|int
modifier|*
name|best_rparen
decl_stmt|;
comment|/* assignments.  				 * This may point to the same mem as 				 * best_lpspace, or it might point to memory 				 * passed by the caller. 				 */
name|int
name|best_last_l
decl_stmt|;
comment|/* best_last_l:best_lparen::last_l:lparen */
name|int
name|best_last_r
decl_stmt|;
name|unsigned
name|char
modifier|*
name|translate
decl_stmt|;
name|struct
name|rx_string_position
name|outer_pos
decl_stmt|;
name|struct
name|rx_superstate
modifier|*
name|start_super
decl_stmt|;
name|int
name|nfa_choice
decl_stmt|;
name|int
name|first_found
decl_stmt|;
comment|/* If true, return after finding any match. */
name|int
name|ret_val
decl_stmt|;
comment|/* For continuations... */
name|enum
name|rx_outer_entry
name|outer_search_resume_pt
decl_stmt|;
name|struct
name|re_pattern_buffer
modifier|*
name|saved_rxb
decl_stmt|;
name|int
name|saved_startpos
decl_stmt|;
name|int
name|saved_range
decl_stmt|;
name|int
name|saved_stop
decl_stmt|;
name|int
name|saved_total_size
decl_stmt|;
name|rx_get_burst_fn
name|saved_get_burst
decl_stmt|;
name|rx_back_check_fn
name|saved_back_check
decl_stmt|;
name|struct
name|re_registers
modifier|*
name|saved_regs
decl_stmt|;
comment|/**    ** state for fastmap    **/
name|char
modifier|*
name|fastmap
decl_stmt|;
name|int
name|fastmap_chr
decl_stmt|;
name|int
name|fastmap_val
decl_stmt|;
comment|/* for continuations in the fastmap procedure: */
name|enum
name|rx_fastmap_entry
name|fastmap_resume_pt
decl_stmt|;
comment|/**    ** state for test_match     **/
comment|/* The current superNFA position of the matcher. */
name|struct
name|rx_superstate
modifier|*
name|super
decl_stmt|;
comment|/* The matcher interprets a series of instruction frames.    * This is the `instruction counter' for the interpretation.    */
name|struct
name|rx_inx
modifier|*
name|ifr
decl_stmt|;
comment|/* We insert a ghost character in the string to prime    * the nfa.  test_pos.pos, test_pos.str_half, and test_pos.end_half    * keep track of the test-match position and string-half.    */
name|unsigned
name|char
name|c
decl_stmt|;
comment|/* Position within the string. */
name|struct
name|rx_string_position
name|test_pos
decl_stmt|;
name|struct
name|rx_stack_chunk
modifier|*
name|counter_stack
decl_stmt|;
name|struct
name|rx_stack_chunk
modifier|*
name|backtrack_stack
decl_stmt|;
name|int
name|backtrack_frame_bytes
decl_stmt|;
name|int
name|chunk_bytes
decl_stmt|;
name|struct
name|rx_stack_chunk
modifier|*
name|free_chunks
decl_stmt|;
comment|/* To return from this function, set test_ret and     * `goto test_do_return'.    *    * Possible return values are:    *     1   --- end of string while the superNFA is still going    *     0   --- internal error (out of memory)    *	-1   --- search completed by reaching the superNFA fail state    *    -2   --- a match was found, maybe not the longest.    *    * When the search is complete (-1), best_last_r indicates whether    * a match was found.    *    * -2 is return only if search_state.first_found is non-zero.    *    * if search_state.first_found is non-zero, a return of -1 indicates no match,    * otherwise, best_last_r has to be checked.    */
name|int
name|test_ret
decl_stmt|;
name|int
name|could_have_continued
decl_stmt|;
ifdef|#
directive|ifdef
name|RX_DEBUG
name|int
name|backtrack_depth
decl_stmt|;
comment|/* There is a search tree with every node as set of deterministic    * transitions in the super nfa.  For every branch of a     * backtrack point is an edge in the tree.    * This counts up a pre-order of nodes in that tree.    * It's saved on the search stack and printed when debugging.     */
name|int
name|line_no
decl_stmt|;
name|int
name|lines_found
decl_stmt|;
endif|#
directive|endif
comment|/* For continuations within the match tester */
name|enum
name|rx_test_match_entry
name|test_match_resume_pt
decl_stmt|;
name|struct
name|rx_inx
modifier|*
name|saved_next_tr_table
decl_stmt|;
name|struct
name|rx_inx
modifier|*
name|saved_this_tr_table
decl_stmt|;
name|int
name|saved_reg
decl_stmt|;
name|struct
name|rx_backtrack_frame
modifier|*
name|saved_bf
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|char
name|rx_slowmap
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|char
name|rx_id_translation
index|[]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|__inline__
name|void
name|init_fastmap
parameter_list|(
name|rxb
parameter_list|,
name|search_state
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|rxb
decl_stmt|;
name|struct
name|rx_search_state
modifier|*
name|search_state
decl_stmt|;
block|{
name|search_state
operator|->
name|fastmap
operator|=
operator|(
name|rxb
operator|->
name|fastmap
condition|?
operator|(
name|char
operator|*
operator|)
name|rxb
operator|->
name|fastmap
else|:
operator|(
name|char
operator|*
operator|)
name|rx_slowmap
operator|)
expr_stmt|;
comment|/* Update the fastmap now if not correct already.     * When the regexp was compiled, the fastmap was computed    * and stored in a bitset.  This expands the bitset into a    * character array containing 1s and 0s.    */
if|if
condition|(
operator|(
name|search_state
operator|->
name|fastmap
operator|==
name|rxb
operator|->
name|fastmap
operator|)
operator|&&
operator|!
name|rxb
operator|->
name|fastmap_accurate
condition|)
name|rx_blow_up_fastmap
argument_list|(
name|rxb
argument_list|)
expr_stmt|;
name|search_state
operator|->
name|fastmap_chr
operator|=
operator|-
literal|1
expr_stmt|;
name|search_state
operator|->
name|fastmap_val
operator|=
literal|0
expr_stmt|;
name|search_state
operator|->
name|fastmap_resume_pt
operator|=
name|rx_fastmap_start
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline__
name|void
name|uninit_fastmap
parameter_list|(
name|rxb
parameter_list|,
name|search_state
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|rxb
decl_stmt|;
name|struct
name|rx_search_state
modifier|*
name|search_state
decl_stmt|;
block|{
comment|/* Unset the fastmap sentinel */
if|if
condition|(
name|search_state
operator|->
name|fastmap_chr
operator|>=
literal|0
condition|)
name|search_state
operator|->
name|fastmap
index|[
name|search_state
operator|->
name|fastmap_chr
index|]
operator|=
name|search_state
operator|->
name|fastmap_val
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline__
name|int
name|fastmap_search
parameter_list|(
name|rxb
parameter_list|,
name|stop
parameter_list|,
name|get_burst
parameter_list|,
name|app_closure
parameter_list|,
name|search_state
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|rxb
decl_stmt|;
name|int
name|stop
decl_stmt|;
name|rx_get_burst_fn
name|get_burst
decl_stmt|;
name|void
modifier|*
name|app_closure
decl_stmt|;
name|struct
name|rx_search_state
modifier|*
name|search_state
decl_stmt|;
block|{
name|enum
name|rx_fastmap_entry
name|pc
decl_stmt|;
if|if
condition|(
literal|0
condition|)
block|{
name|return_continuation
label|:
name|search_state
operator|->
name|fastmap_resume_pt
operator|=
name|pc
expr_stmt|;
return|return
name|rx_fastmap_continuation
return|;
block|}
name|pc
operator|=
name|search_state
operator|->
name|fastmap_resume_pt
expr_stmt|;
switch|switch
condition|(
name|pc
condition|)
block|{
default|default:
return|return
name|rx_fastmap_error
return|;
case|case
name|rx_fastmap_start
case|:
name|init_fastmap_sentinal
label|:
comment|/* For the sake of fast fastmapping, set a sentinal in the fastmap.        * This sentinal will trap the fastmap loop when it reaches the last        * valid character in a string half.        *        * This must be reset when the fastmap/search loop crosses a string         * boundry, and before returning to the caller.  So sometimes,        * the fastmap loop is restarted with `continue', othertimes by        * `goto init_fastmap_sentinal'.        */
if|if
condition|(
name|search_state
operator|->
name|outer_pos
operator|.
name|size
condition|)
block|{
name|search_state
operator|->
name|fastmap_chr
operator|=
operator|(
operator|(
name|search_state
operator|->
name|outer_pos
operator|.
name|search_direction
operator|==
literal|1
operator|)
condition|?
operator|*
operator|(
name|search_state
operator|->
name|outer_pos
operator|.
name|end
operator|-
literal|1
operator|)
else|:
operator|*
name|search_state
operator|->
name|outer_pos
operator|.
name|string
operator|)
expr_stmt|;
name|search_state
operator|->
name|fastmap_val
operator|=
name|search_state
operator|->
name|fastmap
index|[
name|search_state
operator|->
name|fastmap_chr
index|]
expr_stmt|;
name|search_state
operator|->
name|fastmap
index|[
name|search_state
operator|->
name|fastmap_chr
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|search_state
operator|->
name|fastmap_chr
operator|=
operator|-
literal|1
expr_stmt|;
name|search_state
operator|->
name|fastmap_val
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|search_state
operator|->
name|outer_pos
operator|.
name|pos
operator|>=
name|search_state
operator|->
name|outer_pos
operator|.
name|end
condition|)
goto|goto
name|fastmap_hit_bound
goto|;
else|else
block|{
if|if
condition|(
name|search_state
operator|->
name|outer_pos
operator|.
name|search_direction
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|search_state
operator|->
name|fastmap_val
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|!
name|search_state
operator|->
name|fastmap
index|[
operator|*
name|search_state
operator|->
name|outer_pos
operator|.
name|pos
index|]
condition|)
operator|++
name|search_state
operator|->
name|outer_pos
operator|.
name|pos
expr_stmt|;
return|return
name|rx_fastmap_ok
return|;
block|}
block|}
else|else
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|!
name|search_state
operator|->
name|fastmap
index|[
operator|*
name|search_state
operator|->
name|outer_pos
operator|.
name|pos
index|]
condition|)
operator|++
name|search_state
operator|->
name|outer_pos
operator|.
name|pos
expr_stmt|;
if|if
condition|(
operator|*
name|search_state
operator|->
name|outer_pos
operator|.
name|pos
operator|!=
name|search_state
operator|->
name|fastmap_chr
condition|)
return|return
name|rx_fastmap_ok
return|;
else|else
block|{
operator|++
name|search_state
operator|->
name|outer_pos
operator|.
name|pos
expr_stmt|;
if|if
condition|(
name|search_state
operator|->
name|outer_pos
operator|.
name|pos
operator|==
name|search_state
operator|->
name|outer_pos
operator|.
name|end
condition|)
goto|goto
name|fastmap_hit_bound
goto|;
block|}
block|}
block|}
block|}
else|else
block|{
name|__const__
name|unsigned
name|char
modifier|*
name|bound
decl_stmt|;
name|bound
operator|=
name|search_state
operator|->
name|outer_pos
operator|.
name|string
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|search_state
operator|->
name|fastmap_val
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|!
name|search_state
operator|->
name|fastmap
index|[
operator|*
name|search_state
operator|->
name|outer_pos
operator|.
name|pos
index|]
condition|)
operator|--
name|search_state
operator|->
name|outer_pos
operator|.
name|pos
expr_stmt|;
return|return
name|rx_fastmap_ok
return|;
block|}
block|}
else|else
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|!
name|search_state
operator|->
name|fastmap
index|[
operator|*
name|search_state
operator|->
name|outer_pos
operator|.
name|pos
index|]
condition|)
operator|--
name|search_state
operator|->
name|outer_pos
operator|.
name|pos
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|search_state
operator|->
name|outer_pos
operator|.
name|pos
operator|!=
name|search_state
operator|->
name|fastmap_chr
operator|)
operator|||
name|search_state
operator|->
name|fastmap_val
condition|)
return|return
name|rx_fastmap_ok
return|;
else|else
block|{
operator|--
name|search_state
operator|->
name|outer_pos
operator|.
name|pos
expr_stmt|;
if|if
condition|(
name|search_state
operator|->
name|outer_pos
operator|.
name|pos
operator|==
name|bound
condition|)
goto|goto
name|fastmap_hit_bound
goto|;
block|}
block|}
block|}
block|}
block|}
case|case
name|rx_fastmap_string_break
case|:
name|fastmap_hit_bound
label|:
block|{
comment|/* If we hit a bound, it may be time to fetch another burst 	 * of string, or it may be time to return a continuation to   	 * the caller, or it might be time to fail. 	 */
name|int
name|burst_state
decl_stmt|;
name|burst_state
operator|=
name|get_burst
argument_list|(
operator|&
name|search_state
operator|->
name|outer_pos
argument_list|,
name|app_closure
argument_list|,
name|stop
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|burst_state
condition|)
block|{
default|default:
case|case
name|rx_get_burst_error
case|:
return|return
name|rx_fastmap_error
return|;
case|case
name|rx_get_burst_continuation
case|:
block|{
name|pc
operator|=
name|rx_fastmap_string_break
expr_stmt|;
goto|goto
name|return_continuation
goto|;
block|}
case|case
name|rx_get_burst_ok
case|:
goto|goto
name|init_fastmap_sentinal
goto|;
case|case
name|rx_get_burst_no_more
case|:
comment|/* ...not a string split, simply no more string.  	     * 	     * When searching backward, running out of string 	     * is reason to quit. 	     * 	     * When searching forward, we allow the possibility 	     * of an (empty) match after the last character in the 	     * virtual string.  So, fall through to the matcher 	     */
return|return
operator|(
operator|(
name|search_state
operator|->
name|outer_pos
operator|.
name|search_direction
operator|==
literal|1
operator|)
condition|?
name|rx_fastmap_ok
else|:
name|rx_fastmap_fail
operator|)
return|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|emacs
end_ifdef

begin_comment
comment|/* The `emacs' switch turns on certain matching commands  * that make sense only in Emacs.   */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"syntax.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* emacs */
end_comment

begin_comment
comment|/* Setting RX_MEMDBUG is useful if you have dbmalloc.  Maybe with similar  * packages too.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RX_MEMDBUG
end_ifdef

begin_include
include|#
directive|include
file|<malloc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RX_RX_MEMDBUG */
end_comment

begin_comment
comment|/* We used to test for `BSTRING' here, but only GCC and Emacs define  * `BSTRING', as far as I know, and neither of them use this code.    */
end_comment

begin_if
if|#
directive|if
name|HAVE_STRING_H
operator|||
name|STDC_HEADERS
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|bcmp
end_ifndef

begin_define
define|#
directive|define
name|bcmp
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|n
parameter_list|)
value|memcmp ((s1), (s2), (n))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|bcopy
end_ifndef

begin_define
define|#
directive|define
name|bcopy
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|,
name|n
parameter_list|)
value|memcpy ((d), (s), (n))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|bzero
end_ifndef

begin_define
define|#
directive|define
name|bzero
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
value|memset ((s), 0, (n))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  HAVE_STRING_H || STDC_HEADERS */
end_comment

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not (HAVE_STRING_H || STDC_HEADERS) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|STDC_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not STDC_HEADERS */
end_comment

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|realloc
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not STDC_HEADERS */
end_comment

begin_escape
end_escape

begin_comment
comment|/* How many characters in the character set.  */
end_comment

begin_define
define|#
directive|define
name|CHAR_SET_SIZE
value|(1<< CHARBITS)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|emacs
end_ifndef

begin_comment
comment|/* Define the syntax basics for \<, \>, etc.  * This must be nonzero for the wordchar and notwordchar pattern  * commands in re_match_2.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|Sword
end_ifndef

begin_define
define|#
directive|define
name|Sword
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SYNTAX
parameter_list|(
name|c
parameter_list|)
value|re_syntax_table[c]
end_define

begin_decl_stmt
name|RX_DECL
name|char
name|re_syntax_table
index|[
name|CHAR_SET_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not emacs */
end_comment

begin_comment
comment|/* Test if at very beginning or at very end of the virtual concatenation  *  of `string1' and `string2'.  If only one string, it's `string2'.    */
end_comment

begin_define
define|#
directive|define
name|AT_STRINGS_BEG
parameter_list|()
define|\
value|(   -1		 \    == ((search_state.test_pos.pos - search_state.test_pos.string) \        + search_state.test_pos.offset))
end_define

begin_define
define|#
directive|define
name|AT_STRINGS_END
parameter_list|()
define|\
value|(   (total_size - 1)	 \    == ((search_state.test_pos.pos - search_state.test_pos.string) \        + search_state.test_pos.offset))
end_define

begin_comment
comment|/* Test if POS + 1 points to a character which is word-constituent.  We have  * two special cases to check for: if past the end of string1, look at  * the first character in string2; and if before the beginning of  * string2, look at the last character in string1.  *  * Assumes `string1' exists, so use in conjunction with AT_STRINGS_BEG ().    */
end_comment

begin_define
define|#
directive|define
name|LETTER_P
parameter_list|(
name|POS
parameter_list|,
name|OFF
parameter_list|)
define|\
value|(   SYNTAX (fetch_char(POS, OFF, app_closure, stop))			\    == Sword)
end_define

begin_comment
comment|/* Test if the character at D and the one after D differ with respect  * to being word-constituent.    */
end_comment

begin_define
define|#
directive|define
name|AT_WORD_BOUNDARY
parameter_list|(
name|d
parameter_list|)
define|\
value|(AT_STRINGS_BEG () || AT_STRINGS_END () || LETTER_P (d,0) != LETTER_P (d, 1))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|RX_SUPPORT_CONTINUATIONS
end_ifdef

begin_define
define|#
directive|define
name|RX_STACK_ALLOC
parameter_list|(
name|BYTES
parameter_list|)
value|malloc(BYTES)
end_define

begin_define
define|#
directive|define
name|RX_STACK_FREE
parameter_list|(
name|MEM
parameter_list|)
value|free(MEM)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RX_STACK_ALLOC
parameter_list|(
name|BYTES
parameter_list|)
value|alloca(BYTES)
end_define

begin_define
define|#
directive|define
name|RX_STACK_FREE
parameter_list|(
name|MEM
parameter_list|)
define|\
value|((struct rx_stack_chunk *)MEM)->next_chunk = search_state.free_chunks; \       search_state.free_chunks = ((struct rx_stack_chunk *)MEM);
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PUSH
parameter_list|(
name|CHUNK_VAR
parameter_list|,
name|BYTES
parameter_list|)
define|\
value|if (!CHUNK_VAR || (CHUNK_VAR->bytes_left< (BYTES)))  \     {					\       struct rx_stack_chunk * new_chunk;	\       if (search_state.free_chunks)			\ 	{				\ 	  new_chunk = search_state.free_chunks;	\ 	  search_state.free_chunks = search_state.free_chunks->next_chunk; \ 	}				\       else				\ 	{				\ 	  new_chunk = (struct rx_stack_chunk *)RX_STACK_ALLOC(search_state.chunk_bytes); \ 	  if (!new_chunk)		\ 	    {				\ 	      search_state.ret_val = 0;		\ 	      goto test_do_return;	\ 	    }				\ 	}				\       new_chunk->sp = (char *)new_chunk + sizeof (struct rx_stack_chunk); \       new_chunk->bytes_left = (search_state.chunk_bytes \ 			       - (BYTES) \ 			       - sizeof (struct rx_stack_chunk)); \       new_chunk->next_chunk = CHUNK_VAR; \       CHUNK_VAR = new_chunk;		\     } \   else \     (CHUNK_VAR->sp += (BYTES)), (CHUNK_VAR->bytes_left -= (BYTES))
end_define

begin_define
define|#
directive|define
name|POP
parameter_list|(
name|CHUNK_VAR
parameter_list|,
name|BYTES
parameter_list|)
define|\
value|if (CHUNK_VAR->sp == ((char *)CHUNK_VAR + sizeof(*CHUNK_VAR))) \     { \       struct rx_stack_chunk * new_chunk = CHUNK_VAR->next_chunk; \       RX_STACK_FREE(CHUNK_VAR); \       CHUNK_VAR = new_chunk; \     } \   else \     (CHUNK_VAR->sp -= BYTES), (CHUNK_VAR->bytes_left += BYTES)
end_define

begin_define
define|#
directive|define
name|SRCH_TRANSLATE
parameter_list|(
name|C
parameter_list|)
value|search_state.translate[(unsigned char) (C)]
end_define

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
name|RX_DECL
name|__inline__
name|int
name|rx_search
argument_list|(
expr|struct
name|re_pattern_buffer
operator|*
name|rxb
argument_list|,
name|int
name|startpos
argument_list|,
name|int
name|range
argument_list|,
name|int
name|stop
argument_list|,
name|int
name|total_size
argument_list|,
name|rx_get_burst_fn
name|get_burst
argument_list|,
name|rx_back_check_fn
name|back_check
argument_list|,
name|rx_fetch_char_fn
name|fetch_char
argument_list|,
name|void
operator|*
name|app_closure
argument_list|,
expr|struct
name|re_registers
operator|*
name|regs
argument_list|,
expr|struct
name|rx_search_state
operator|*
name|resume_state
argument_list|,
expr|struct
name|rx_search_state
operator|*
name|save_state
argument_list|)
else|#
directive|else
name|RX_DECL
name|__inline__
name|int
name|rx_search
argument_list|(
name|rxb
argument_list|,
name|startpos
argument_list|,
name|range
argument_list|,
name|stop
argument_list|,
name|total_size
argument_list|,
name|get_burst
argument_list|,
name|back_check
argument_list|,
name|fetch_char
argument_list|,
name|app_closure
argument_list|,
name|regs
argument_list|,
name|resume_state
argument_list|,
name|save_state
argument_list|)
decl|struct
name|re_pattern_buffer
modifier|*
name|rxb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|startpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|range
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|stop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|total_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_get_burst_fn
name|get_burst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_back_check_fn
name|back_check
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rx_fetch_char_fn
name|fetch_char
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|app_closure
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|re_registers
modifier|*
name|regs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_search_state
modifier|*
name|resume_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rx_search_state
modifier|*
name|save_state
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|pc
decl_stmt|;
name|int
name|test_state
decl_stmt|;
name|struct
name|rx_search_state
name|search_state
decl_stmt|;
name|search_state
operator|.
name|free_chunks
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|resume_state
condition|)
name|pc
operator|=
name|rx_outer_start
expr_stmt|;
else|else
block|{
name|search_state
operator|=
operator|*
name|resume_state
expr_stmt|;
name|regs
operator|=
name|search_state
operator|.
name|saved_regs
expr_stmt|;
name|rxb
operator|=
name|search_state
operator|.
name|saved_rxb
expr_stmt|;
name|startpos
operator|=
name|search_state
operator|.
name|saved_startpos
expr_stmt|;
name|range
operator|=
name|search_state
operator|.
name|saved_range
expr_stmt|;
name|stop
operator|=
name|search_state
operator|.
name|saved_stop
expr_stmt|;
name|total_size
operator|=
name|search_state
operator|.
name|saved_total_size
expr_stmt|;
name|get_burst
operator|=
name|search_state
operator|.
name|saved_get_burst
expr_stmt|;
name|back_check
operator|=
name|search_state
operator|.
name|saved_back_check
expr_stmt|;
name|pc
operator|=
name|search_state
operator|.
name|outer_search_resume_pt
expr_stmt|;
if|if
condition|(
literal|0
condition|)
block|{
name|return_continuation
label|:
if|if
condition|(
name|save_state
condition|)
block|{
operator|*
name|save_state
operator|=
name|search_state
expr_stmt|;
name|save_state
operator|->
name|saved_regs
operator|=
name|regs
expr_stmt|;
name|save_state
operator|->
name|saved_rxb
operator|=
name|rxb
expr_stmt|;
name|save_state
operator|->
name|saved_startpos
operator|=
name|startpos
expr_stmt|;
name|save_state
operator|->
name|saved_range
operator|=
name|range
expr_stmt|;
name|save_state
operator|->
name|saved_stop
operator|=
name|stop
expr_stmt|;
name|save_state
operator|->
name|saved_total_size
operator|=
name|total_size
expr_stmt|;
name|save_state
operator|->
name|saved_get_burst
operator|=
name|get_burst
expr_stmt|;
name|save_state
operator|->
name|saved_back_check
operator|=
name|back_check
expr_stmt|;
name|save_state
operator|->
name|outer_search_resume_pt
operator|=
name|pc
expr_stmt|;
block|}
return|return
name|rx_search_continuation
return|;
block|}
block|}
switch|switch
condition|(
name|pc
condition|)
block|{
case|case
name|rx_outer_start
case|:
name|search_state
operator|.
name|ret_val
operator|=
name|rx_search_fail
expr_stmt|;
operator|(
name|search_state
operator|.
name|lparen
operator|=
name|search_state
operator|.
name|rparen
operator|=
name|search_state
operator|.
name|best_lpspace
operator|=
name|search_state
operator|.
name|best_rpspace
operator|=
literal|0
operator|)
expr_stmt|;
comment|/* figure the number of registers we may need for use in backreferences.        * the number here includes an element for register zero.          */
name|search_state
operator|.
name|num_regs
operator|=
name|rxb
operator|->
name|re_nsub
operator|+
literal|1
expr_stmt|;
comment|/* check for out-of-range startpos.  */
if|if
condition|(
operator|(
name|startpos
operator|<
literal|0
operator|)
operator|||
operator|(
name|startpos
operator|>
name|total_size
operator|)
condition|)
return|return
name|rx_search_fail
return|;
comment|/* fix up range if it might eventually take us outside the string. */
block|{
name|int
name|endpos
decl_stmt|;
name|endpos
operator|=
name|startpos
operator|+
name|range
expr_stmt|;
if|if
condition|(
name|endpos
operator|<
operator|-
literal|1
condition|)
name|range
operator|=
operator|(
operator|-
literal|1
operator|-
name|startpos
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|endpos
operator|>
operator|(
name|total_size
operator|+
literal|1
operator|)
condition|)
name|range
operator|=
name|total_size
operator|-
name|startpos
expr_stmt|;
block|}
comment|/* if the search isn't to be a backwards one, don't waste time in a        * long search for a pattern that says it is anchored.        */
if|if
condition|(
name|rxb
operator|->
name|begbuf_only
operator|&&
operator|(
name|range
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|startpos
operator|>
literal|0
condition|)
return|return
name|rx_search_fail
return|;
else|else
name|range
operator|=
literal|1
expr_stmt|;
block|}
comment|/* decide whether to use internal or user-provided reg buffers. */
if|if
condition|(
operator|!
name|regs
operator|||
name|rxb
operator|->
name|no_sub
condition|)
block|{
name|search_state
operator|.
name|best_lpspace
operator|=
operator|(
name|regoff_t
operator|*
operator|)
name|REGEX_ALLOCATE
argument_list|(
name|search_state
operator|.
name|num_regs
operator|*
sizeof|sizeof
argument_list|(
name|regoff_t
argument_list|)
argument_list|)
expr_stmt|;
name|search_state
operator|.
name|best_rpspace
operator|=
operator|(
name|regoff_t
operator|*
operator|)
name|REGEX_ALLOCATE
argument_list|(
name|search_state
operator|.
name|num_regs
operator|*
sizeof|sizeof
argument_list|(
name|regoff_t
argument_list|)
argument_list|)
expr_stmt|;
name|search_state
operator|.
name|best_lparen
operator|=
name|search_state
operator|.
name|best_lpspace
expr_stmt|;
name|search_state
operator|.
name|best_rparen
operator|=
name|search_state
operator|.
name|best_rpspace
expr_stmt|;
block|}
else|else
block|{
comment|/* have the register data arrays been allocated?  */
if|if
condition|(
name|rxb
operator|->
name|regs_allocated
operator|==
name|REGS_UNALLOCATED
condition|)
block|{
comment|/* no.  so allocate them with malloc.  we need one 		 extra element beyond `search_state.num_regs' for the `-1' marker 		 gnu code uses.  */
name|regs
operator|->
name|num_regs
operator|=
name|MAX
argument_list|(
name|RE_NREGS
argument_list|,
name|rxb
operator|->
name|re_nsub
operator|+
literal|1
argument_list|)
expr_stmt|;
name|regs
operator|->
name|start
operator|=
operator|(
operator|(
name|regoff_t
operator|*
operator|)
name|malloc
argument_list|(
name|regs
operator|->
name|num_regs
operator|*
sizeof|sizeof
argument_list|(
name|regoff_t
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|regs
operator|->
name|end
operator|=
operator|(
operator|(
name|regoff_t
operator|*
operator|)
name|malloc
argument_list|(
name|regs
operator|->
name|num_regs
operator|*
sizeof|sizeof
argument_list|(
name|regoff_t
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|regs
operator|->
name|start
operator|==
literal|0
operator|||
name|regs
operator|->
name|end
operator|==
literal|0
condition|)
return|return
name|rx_search_error
return|;
name|rxb
operator|->
name|regs_allocated
operator|=
name|REGS_REALLOCATE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rxb
operator|->
name|regs_allocated
operator|==
name|REGS_REALLOCATE
condition|)
block|{
comment|/* yes.  if we need more elements than were already 		 allocated, reallocate them.  if we need fewer, just 		 leave it alone.  */
if|if
condition|(
name|regs
operator|->
name|num_regs
operator|<
name|search_state
operator|.
name|num_regs
operator|+
literal|1
condition|)
block|{
name|regs
operator|->
name|num_regs
operator|=
name|search_state
operator|.
name|num_regs
operator|+
literal|1
expr_stmt|;
name|regs
operator|->
name|start
operator|=
operator|(
operator|(
name|regoff_t
operator|*
operator|)
name|realloc
argument_list|(
name|regs
operator|->
name|start
argument_list|,
name|regs
operator|->
name|num_regs
operator|*
sizeof|sizeof
argument_list|(
name|regoff_t
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|regs
operator|->
name|end
operator|=
operator|(
operator|(
name|regoff_t
operator|*
operator|)
name|realloc
argument_list|(
name|regs
operator|->
name|end
argument_list|,
name|regs
operator|->
name|num_regs
operator|*
sizeof|sizeof
argument_list|(
name|regoff_t
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|regs
operator|->
name|start
operator|==
literal|0
operator|||
name|regs
operator|->
name|end
operator|==
literal|0
condition|)
return|return
name|rx_search_error
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|rxb
operator|->
name|regs_allocated
operator|!=
name|REGS_FIXED
condition|)
return|return
name|rx_search_error
return|;
if|if
condition|(
name|regs
operator|->
name|num_regs
operator|<
name|search_state
operator|.
name|num_regs
operator|+
literal|1
condition|)
block|{
name|search_state
operator|.
name|best_lpspace
operator|=
operator|(
operator|(
name|regoff_t
operator|*
operator|)
name|REGEX_ALLOCATE
argument_list|(
name|search_state
operator|.
name|num_regs
operator|*
sizeof|sizeof
argument_list|(
name|regoff_t
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|search_state
operator|.
name|best_rpspace
operator|=
operator|(
operator|(
name|regoff_t
operator|*
operator|)
name|REGEX_ALLOCATE
argument_list|(
name|search_state
operator|.
name|num_regs
operator|*
sizeof|sizeof
argument_list|(
name|regoff_t
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|search_state
operator|.
name|best_lparen
operator|=
name|search_state
operator|.
name|best_lpspace
expr_stmt|;
name|search_state
operator|.
name|best_rparen
operator|=
name|search_state
operator|.
name|best_rpspace
expr_stmt|;
block|}
else|else
block|{
name|search_state
operator|.
name|best_lparen
operator|=
name|regs
operator|->
name|start
expr_stmt|;
name|search_state
operator|.
name|best_rparen
operator|=
name|regs
operator|->
name|end
expr_stmt|;
block|}
block|}
name|search_state
operator|.
name|lparen
operator|=
operator|(
name|regoff_t
operator|*
operator|)
name|REGEX_ALLOCATE
argument_list|(
name|search_state
operator|.
name|num_regs
operator|*
sizeof|sizeof
argument_list|(
name|regoff_t
argument_list|)
argument_list|)
expr_stmt|;
name|search_state
operator|.
name|rparen
operator|=
operator|(
name|regoff_t
operator|*
operator|)
name|REGEX_ALLOCATE
argument_list|(
name|search_state
operator|.
name|num_regs
operator|*
sizeof|sizeof
argument_list|(
name|regoff_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|search_state
operator|.
name|best_rparen
operator|&&
name|search_state
operator|.
name|best_lparen
operator|&&
name|search_state
operator|.
name|lparen
operator|&&
name|search_state
operator|.
name|rparen
operator|)
condition|)
return|return
name|rx_search_error
return|;
name|search_state
operator|.
name|best_last_l
operator|=
name|search_state
operator|.
name|best_last_r
operator|=
operator|-
literal|1
expr_stmt|;
name|search_state
operator|.
name|translate
operator|=
operator|(
name|rxb
operator|->
name|translate
condition|?
name|rxb
operator|->
name|translate
else|:
name|rx_id_translation
operator|)
expr_stmt|;
comment|/*        * two nfa's were compiled.          * `0' is complete.        * `1' faster but gets registers wrong and ends too soon.        */
name|search_state
operator|.
name|nfa_choice
operator|=
operator|(
name|regs
operator|&&
operator|!
name|rxb
operator|->
name|least_subs
operator|)
condition|?
literal|'\0'
else|:
literal|'\1'
expr_stmt|;
comment|/* we have the option to look for the best match or the first        * one we can find.  if the user isn't asking for register information,        * we don't need to find the best match.        */
name|search_state
operator|.
name|first_found
operator|=
operator|!
name|regs
expr_stmt|;
if|if
condition|(
name|range
operator|>=
literal|0
condition|)
block|{
name|search_state
operator|.
name|outer_pos
operator|.
name|search_end
operator|=
name|startpos
operator|+
name|range
expr_stmt|;
name|search_state
operator|.
name|outer_pos
operator|.
name|search_direction
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|search_state
operator|.
name|outer_pos
operator|.
name|search_end
operator|=
name|startpos
operator|+
name|range
expr_stmt|;
name|search_state
operator|.
name|outer_pos
operator|.
name|search_direction
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* the vacuous search always turns up nothing. */
if|if
condition|(
operator|(
name|search_state
operator|.
name|outer_pos
operator|.
name|search_direction
operator|==
literal|1
operator|)
condition|?
operator|(
name|startpos
operator|>
name|search_state
operator|.
name|outer_pos
operator|.
name|search_end
operator|)
else|:
operator|(
name|startpos
operator|<
name|search_state
operator|.
name|outer_pos
operator|.
name|search_end
operator|)
condition|)
return|return
name|rx_search_fail
return|;
comment|/* now we build the starting state of the supernfa. */
block|{
name|struct
name|rx_superset
modifier|*
name|start_contents
decl_stmt|;
name|struct
name|rx_nfa_state_set
modifier|*
name|start_nfa_set
decl_stmt|;
comment|/* we presume here that the nfa start state has only one 	 * possible future with no side effects.   	 */
name|start_nfa_set
operator|=
name|rxb
operator|->
name|start
operator|->
name|futures
operator|->
name|destset
expr_stmt|;
if|if
condition|(
name|rxb
operator|->
name|rx
operator|.
name|start_set
operator|&&
operator|(
name|rxb
operator|->
name|rx
operator|.
name|start_set
operator|->
name|starts_for
operator|==
operator|&
name|rxb
operator|->
name|rx
operator|)
condition|)
name|start_contents
operator|=
name|rxb
operator|->
name|rx
operator|.
name|start_set
expr_stmt|;
else|else
block|{
name|start_contents
operator|=
name|rx_superstate_eclosure_union
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|rx_superset_cons
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|start_nfa_set
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|start_contents
condition|)
return|return
name|rx_search_fail
return|;
name|start_contents
operator|->
name|starts_for
operator|=
operator|&
name|rxb
operator|->
name|rx
expr_stmt|;
name|rxb
operator|->
name|rx
operator|.
name|start_set
operator|=
name|start_contents
expr_stmt|;
block|}
if|if
condition|(
name|start_contents
operator|->
name|superstate
operator|&&
operator|(
name|start_contents
operator|->
name|superstate
operator|->
name|rx_id
operator|==
name|rxb
operator|->
name|rx
operator|.
name|rx_id
operator|)
condition|)
block|{
name|search_state
operator|.
name|start_super
operator|=
name|start_contents
operator|->
name|superstate
expr_stmt|;
name|rx_lock_superstate
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|search_state
operator|.
name|start_super
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rx_protect_superset
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|start_contents
argument_list|)
expr_stmt|;
name|search_state
operator|.
name|start_super
operator|=
name|rx_superstate
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|start_contents
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|search_state
operator|.
name|start_super
condition|)
return|return
name|rx_search_fail
return|;
name|rx_lock_superstate
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|search_state
operator|.
name|start_super
argument_list|)
expr_stmt|;
name|rx_release_superset
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|start_contents
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The outer_pos tracks the position within the strings        * as seen by loop that calls fastmap_search.        *        * The caller supplied get_burst function actually         * gives us pointers to chars.        *         * Communication with the get_burst function is through an        * rx_string_position structure.  Here, the structure for        * outer_pos is initialized.   It is set to point to the        * NULL string, at an offset of STARTPOS.  STARTPOS is out        * of range of the NULL string, so the first call to         * getburst will patch up the rx_string_position to point        * to valid characters.        */
operator|(
name|search_state
operator|.
name|outer_pos
operator|.
name|string
operator|=
name|search_state
operator|.
name|outer_pos
operator|.
name|end
operator|=
literal|0
operator|)
expr_stmt|;
name|search_state
operator|.
name|outer_pos
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|search_state
operator|.
name|outer_pos
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|search_state
operator|.
name|outer_pos
operator|.
name|pos
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|startpos
expr_stmt|;
name|init_fastmap
argument_list|(
name|rxb
argument_list|,
operator|&
name|search_state
argument_list|)
expr_stmt|;
name|search_state
operator|.
name|fastmap_resume_pt
operator|=
name|rx_fastmap_start
expr_stmt|;
case|case
name|rx_outer_fastmap
case|:
comment|/* do { */
name|pseudo_do
label|:
block|{
block|{
name|int
name|fastmap_state
decl_stmt|;
name|fastmap_state
operator|=
name|fastmap_search
argument_list|(
name|rxb
argument_list|,
name|stop
argument_list|,
name|get_burst
argument_list|,
name|app_closure
argument_list|,
operator|&
name|search_state
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fastmap_state
condition|)
block|{
case|case
name|rx_fastmap_continuation
case|:
name|pc
operator|=
name|rx_outer_fastmap
expr_stmt|;
goto|goto
name|return_continuation
goto|;
case|case
name|rx_fastmap_fail
case|:
goto|goto
name|finish
goto|;
case|case
name|rx_fastmap_ok
case|:
break|break;
block|}
block|}
comment|/* now the fastmap loop has brought us to a plausible  	 * starting point for a match.  so, it's time to run the 	 * nfa and see if a match occured. 	 */
name|startpos
operator|=
operator|(
name|search_state
operator|.
name|outer_pos
operator|.
name|pos
operator|-
name|search_state
operator|.
name|outer_pos
operator|.
name|string
operator|+
name|search_state
operator|.
name|outer_pos
operator|.
name|offset
operator|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/*|*/
block|if ((range> 0)&& (startpos == search_state.outer_pos.search_end))
comment|/*|*/
block|goto finish;
endif|#
directive|endif
block|}
name|search_state
operator|.
name|test_match_resume_pt
operator|=
name|rx_test_start
expr_stmt|;
comment|/* do interrupted for entry point... */
case|case
name|rx_outer_test
case|:
comment|/* ...do continued */
block|{
goto|goto
name|test_match
goto|;
name|test_returns_to_search
label|:
switch|switch
condition|(
name|test_state
condition|)
block|{
case|case
name|rx_test_continuation
case|:
name|pc
operator|=
name|rx_outer_test
expr_stmt|;
goto|goto
name|return_continuation
goto|;
case|case
name|rx_test_error
case|:
name|search_state
operator|.
name|ret_val
operator|=
name|rx_search_error
expr_stmt|;
goto|goto
name|finish
goto|;
case|case
name|rx_test_fail
case|:
break|break;
case|case
name|rx_test_ok
case|:
goto|goto
name|finish
goto|;
block|}
name|search_state
operator|.
name|outer_pos
operator|.
name|pos
operator|+=
name|search_state
operator|.
name|outer_pos
operator|.
name|search_direction
expr_stmt|;
name|startpos
operator|+=
name|search_state
operator|.
name|outer_pos
operator|.
name|search_direction
expr_stmt|;
if|#
directive|if
literal|0
comment|/*|*/
block|if (search_state.test_pos.pos< search_state.test_pos.end)
comment|/*|*/
block|break;
endif|#
directive|endif
block|}
comment|/* do interrupted for entry point... */
case|case
name|rx_outer_restore_pos
case|:
block|{
name|int
name|x
decl_stmt|;
name|x
operator|=
name|get_burst
argument_list|(
operator|&
name|search_state
operator|.
name|outer_pos
argument_list|,
name|app_closure
argument_list|,
name|stop
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|x
condition|)
block|{
case|case
name|rx_get_burst_continuation
case|:
name|pc
operator|=
name|rx_outer_restore_pos
expr_stmt|;
goto|goto
name|return_continuation
goto|;
case|case
name|rx_get_burst_error
case|:
name|search_state
operator|.
name|ret_val
operator|=
name|rx_search_error
expr_stmt|;
goto|goto
name|finish
goto|;
case|case
name|rx_get_burst_no_more
case|:
if|if
condition|(
name|rxb
operator|->
name|can_match_empty
condition|)
break|break;
goto|goto
name|finish
goto|;
case|case
name|rx_get_burst_ok
case|:
break|break;
block|}
block|}
comment|/* } while (...see below...) */
if|if
condition|(
operator|(
name|search_state
operator|.
name|outer_pos
operator|.
name|search_direction
operator|==
literal|1
operator|)
condition|?
operator|(
name|startpos
operator|<=
name|search_state
operator|.
name|outer_pos
operator|.
name|search_end
operator|)
else|:
operator|(
name|startpos
operator|>
name|search_state
operator|.
name|outer_pos
operator|.
name|search_end
operator|)
condition|)
goto|goto
name|pseudo_do
goto|;
name|finish
label|:
name|uninit_fastmap
argument_list|(
name|rxb
argument_list|,
operator|&
name|search_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|search_state
operator|.
name|start_super
condition|)
name|rx_unlock_superstate
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|search_state
operator|.
name|start_super
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|regex_malloc
if|if
condition|(
name|search_state
operator|.
name|lparen
condition|)
name|free
argument_list|(
name|search_state
operator|.
name|lparen
argument_list|)
expr_stmt|;
if|if
condition|(
name|search_state
operator|.
name|rparen
condition|)
name|free
argument_list|(
name|search_state
operator|.
name|rparen
argument_list|)
expr_stmt|;
if|if
condition|(
name|search_state
operator|.
name|best_lpspace
condition|)
name|free
argument_list|(
name|search_state
operator|.
name|best_lpspace
argument_list|)
expr_stmt|;
if|if
condition|(
name|search_state
operator|.
name|best_rpspace
condition|)
name|free
argument_list|(
name|search_state
operator|.
name|best_rpspace
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|search_state
operator|.
name|ret_val
return|;
block|}
name|test_match
label|:
block|{
name|enum
name|rx_test_match_entry
name|test_pc
decl_stmt|;
name|int
name|inx
decl_stmt|;
name|test_pc
operator|=
name|search_state
operator|.
name|test_match_resume_pt
expr_stmt|;
if|if
condition|(
name|test_pc
operator|==
name|rx_test_start
condition|)
block|{
ifdef|#
directive|ifdef
name|RX_DEBUG
name|search_state
operator|.
name|backtrack_depth
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|search_state
operator|.
name|last_l
operator|=
name|search_state
operator|.
name|last_r
operator|=
literal|0
expr_stmt|;
name|search_state
operator|.
name|lparen
index|[
literal|0
index|]
operator|=
name|startpos
expr_stmt|;
name|search_state
operator|.
name|super
operator|=
name|search_state
operator|.
name|start_super
expr_stmt|;
name|search_state
operator|.
name|c
operator|=
name|search_state
operator|.
name|nfa_choice
expr_stmt|;
name|search_state
operator|.
name|test_pos
operator|.
name|pos
operator|=
name|search_state
operator|.
name|outer_pos
operator|.
name|pos
operator|-
literal|1
expr_stmt|;
name|search_state
operator|.
name|test_pos
operator|.
name|string
operator|=
name|search_state
operator|.
name|outer_pos
operator|.
name|string
expr_stmt|;
name|search_state
operator|.
name|test_pos
operator|.
name|end
operator|=
name|search_state
operator|.
name|outer_pos
operator|.
name|end
expr_stmt|;
name|search_state
operator|.
name|test_pos
operator|.
name|offset
operator|=
name|search_state
operator|.
name|outer_pos
operator|.
name|offset
expr_stmt|;
name|search_state
operator|.
name|test_pos
operator|.
name|size
operator|=
name|search_state
operator|.
name|outer_pos
operator|.
name|size
expr_stmt|;
name|search_state
operator|.
name|test_pos
operator|.
name|search_direction
operator|=
literal|1
expr_stmt|;
name|search_state
operator|.
name|counter_stack
operator|=
literal|0
expr_stmt|;
name|search_state
operator|.
name|backtrack_stack
operator|=
literal|0
expr_stmt|;
name|search_state
operator|.
name|backtrack_frame_bytes
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|rx_backtrack_frame
argument_list|)
operator|+
operator|(
name|rxb
operator|->
name|match_regs_on_stack
condition|?
sizeof|sizeof
argument_list|(
name|regoff_t
argument_list|)
operator|*
operator|(
name|search_state
operator|.
name|num_regs
operator|+
literal|1
operator|)
operator|*
literal|2
else|:
literal|0
operator|)
operator|)
expr_stmt|;
name|search_state
operator|.
name|chunk_bytes
operator|=
name|search_state
operator|.
name|backtrack_frame_bytes
operator|*
literal|64
expr_stmt|;
name|search_state
operator|.
name|test_ret
operator|=
name|rx_test_line_finished
expr_stmt|;
name|search_state
operator|.
name|could_have_continued
operator|=
literal|0
expr_stmt|;
block|}
comment|/* This is while (1)...except that the body of the loop is interrupted       * by some alternative entry points.      */
name|pseudo_while_1
label|:
switch|switch
condition|(
name|test_pc
condition|)
block|{
case|case
name|rx_test_cache_hit_loop
case|:
goto|goto
name|resume_continuation_1
goto|;
case|case
name|rx_test_backreference_check
case|:
goto|goto
name|resume_continuation_2
goto|;
case|case
name|rx_test_backtrack_return
case|:
goto|goto
name|resume_continuation_3
goto|;
case|case
name|rx_test_start
case|:
ifdef|#
directive|ifdef
name|RX_DEBUG
comment|/* There is a search tree with every node as set of deterministic 	 * transitions in the super nfa.  For every branch of a  	 * backtrack point is an edge in the tree. 	 * This counts up a pre-order of nodes in that tree. 	 * It's saved on the search stack and printed when debugging.  	 */
name|search_state
operator|.
name|line_no
operator|=
literal|0
expr_stmt|;
name|search_state
operator|.
name|lines_found
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|top_of_cycle
label|:
comment|/* A superstate is basicly a transition table, indexed by  	 * characters from the string being tested, and containing  	 * RX_INX (`instruction frame') structures. 	 */
name|search_state
operator|.
name|ifr
operator|=
operator|&
name|search_state
operator|.
name|super
operator|->
name|transitions
index|[
name|search_state
operator|.
name|c
index|]
expr_stmt|;
name|recurse_test_match
label|:
comment|/* This is the point to which control is sent when the 	 * test matcher `recurses'.  Before jumping here, some variables 	 * need to be saved on the stack and the next instruction frame 	 * has to be computed. 	 */
name|restart
label|:
comment|/* Some instructions don't advance the matcher, but just 	 * carry out some side effects and fetch a new instruction. 	 * To dispatch that new instruction, `goto restart'. 	 */
block|{
name|struct
name|rx_inx
modifier|*
name|next_tr_table
decl_stmt|;
name|struct
name|rx_inx
modifier|*
name|this_tr_table
decl_stmt|;
comment|/* The fastest route through the loop is when the instruction  	   * is RX_NEXT_CHAR.  This case is detected when SEARCH_STATE.IFR->DATA 	   * is non-zero.  In that case, it points to the next 	   * superstate.  	   * 	   * This allows us to not bother fetching the bytecode. 	   */
name|next_tr_table
operator|=
operator|(
expr|struct
name|rx_inx
operator|*
operator|)
name|search_state
operator|.
name|ifr
operator|->
name|data
expr_stmt|;
name|this_tr_table
operator|=
name|search_state
operator|.
name|super
operator|->
name|transitions
expr_stmt|;
while|while
condition|(
name|next_tr_table
condition|)
block|{
ifdef|#
directive|ifdef
name|RX_DEBUG_0
if|if
condition|(
name|rx_debug_trace
condition|)
block|{
name|struct
name|rx_superset
modifier|*
name|setp
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d %d>> re_next_char @ %d (%d)"
argument_list|,
name|search_state
operator|.
name|line_no
argument_list|,
name|search_state
operator|.
name|backtrack_depth
argument_list|,
operator|(
name|search_state
operator|.
name|test_pos
operator|.
name|pos
operator|-
name|search_state
operator|.
name|test_pos
operator|.
name|string
operator|+
name|search_state
operator|.
name|test_pos
operator|.
name|offset
operator|)
argument_list|,
name|search_state
operator|.
name|c
argument_list|)
expr_stmt|;
name|search_state
operator|.
name|super
operator|=
operator|(
operator|(
expr|struct
name|rx_superstate
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|this_tr_table
operator|-
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
expr|struct
name|rx_superstate
operator|*
operator|)
literal|0
argument_list|)
operator|->
name|transitions
operator|)
operator|)
operator|)
expr_stmt|;
name|setp
operator|=
name|search_state
operator|.
name|super
operator|->
name|contents
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"   superstet (rx=%d,&=%x: "
argument_list|,
name|rxb
operator|->
name|rx
operator|.
name|rx_id
argument_list|,
name|setp
argument_list|)
expr_stmt|;
while|while
condition|(
name|setp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d "
argument_list|,
name|setp
operator|->
name|id
argument_list|)
expr_stmt|;
name|setp
operator|=
name|setp
operator|->
name|cdr
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|this_tr_table
operator|=
name|next_tr_table
expr_stmt|;
operator|++
name|search_state
operator|.
name|test_pos
operator|.
name|pos
expr_stmt|;
if|if
condition|(
name|search_state
operator|.
name|test_pos
operator|.
name|pos
operator|==
name|search_state
operator|.
name|test_pos
operator|.
name|end
condition|)
block|{
name|int
name|burst_state
decl_stmt|;
name|try_burst_1
label|:
name|burst_state
operator|=
name|get_burst
argument_list|(
operator|&
name|search_state
operator|.
name|test_pos
argument_list|,
name|app_closure
argument_list|,
name|stop
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|burst_state
condition|)
block|{
case|case
name|rx_get_burst_continuation
case|:
name|search_state
operator|.
name|saved_this_tr_table
operator|=
name|this_tr_table
expr_stmt|;
name|search_state
operator|.
name|saved_next_tr_table
operator|=
name|next_tr_table
expr_stmt|;
name|test_pc
operator|=
name|rx_test_cache_hit_loop
expr_stmt|;
goto|goto
name|test_return_continuation
goto|;
name|resume_continuation_1
label|:
comment|/* Continuation one jumps here to do its work: */
name|search_state
operator|.
name|saved_this_tr_table
operator|=
name|this_tr_table
expr_stmt|;
name|search_state
operator|.
name|saved_next_tr_table
operator|=
name|next_tr_table
expr_stmt|;
goto|goto
name|try_burst_1
goto|;
case|case
name|rx_get_burst_ok
case|:
comment|/* get_burst succeeded...keep going */
break|break;
case|case
name|rx_get_burst_no_more
case|:
name|search_state
operator|.
name|test_ret
operator|=
name|rx_test_line_finished
expr_stmt|;
name|search_state
operator|.
name|could_have_continued
operator|=
literal|1
expr_stmt|;
goto|goto
name|test_do_return
goto|;
case|case
name|rx_get_burst_error
case|:
comment|/* An error... */
name|search_state
operator|.
name|test_ret
operator|=
name|rx_test_internal_error
expr_stmt|;
goto|goto
name|test_do_return
goto|;
block|}
block|}
name|search_state
operator|.
name|c
operator|=
operator|*
name|search_state
operator|.
name|test_pos
operator|.
name|pos
expr_stmt|;
name|search_state
operator|.
name|ifr
operator|=
name|this_tr_table
operator|+
name|search_state
operator|.
name|c
expr_stmt|;
name|next_tr_table
operator|=
operator|(
expr|struct
name|rx_inx
operator|*
operator|)
name|search_state
operator|.
name|ifr
operator|->
name|data
expr_stmt|;
block|}
comment|/* Fast loop through cached transition tables */
comment|/* Here when we ran out of cached next-char transitions.  	   * So, it will be necessary to do a more expensive 	   * dispatch on the current instruction.  The superstate 	   * pointer is allowed to become invalid during next-char 	   * transitions -- now we must bring it up to date. 	   */
name|search_state
operator|.
name|super
operator|=
operator|(
operator|(
expr|struct
name|rx_superstate
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|this_tr_table
operator|-
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
expr|struct
name|rx_superstate
operator|*
operator|)
literal|0
argument_list|)
operator|->
name|transitions
operator|)
operator|)
operator|)
expr_stmt|;
block|}
comment|/* We've encountered an instruction other than next-char. 	 * Dispatch that instruction: 	 */
name|inx
operator|=
operator|(
name|int
operator|)
name|search_state
operator|.
name|ifr
operator|->
name|inx
expr_stmt|;
ifdef|#
directive|ifdef
name|RX_DEBUG_0
if|if
condition|(
name|rx_debug_trace
condition|)
block|{
name|struct
name|rx_superset
modifier|*
name|setp
init|=
name|search_state
operator|.
name|super
operator|->
name|contents
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d %d>> %s @ %d (%d)"
argument_list|,
name|search_state
operator|.
name|line_no
argument_list|,
name|search_state
operator|.
name|backtrack_depth
argument_list|,
name|inx_names
index|[
name|inx
index|]
argument_list|,
operator|(
name|search_state
operator|.
name|test_pos
operator|.
name|pos
operator|-
name|search_state
operator|.
name|test_pos
operator|.
name|string
operator|+
operator|(
name|test_pos
operator|.
name|half
operator|==
literal|0
condition|?
literal|0
else|:
name|size1
operator|)
operator|)
argument_list|,
name|search_state
operator|.
name|c
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"   superstet (rx=%d,&=%x: "
argument_list|,
name|rxb
operator|->
name|rx
operator|.
name|rx_id
argument_list|,
name|setp
argument_list|)
expr_stmt|;
while|while
condition|(
name|setp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d "
argument_list|,
name|setp
operator|->
name|id
argument_list|)
expr_stmt|;
name|setp
operator|=
name|setp
operator|->
name|cdr
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
operator|(
expr|enum
name|rx_opcode
operator|)
name|inx
condition|)
block|{
case|case
name|rx_do_side_effects
case|:
comment|/*  RX_DO_SIDE_EFFECTS occurs when we cross epsilon  	     *  edges associated with parentheses, backreferencing, etc. 	     */
block|{
name|struct
name|rx_distinct_future
modifier|*
name|df
init|=
operator|(
expr|struct
name|rx_distinct_future
operator|*
operator|)
name|search_state
operator|.
name|ifr
operator|->
name|data_2
decl_stmt|;
name|struct
name|rx_se_list
modifier|*
name|el
init|=
name|df
operator|->
name|effects
decl_stmt|;
comment|/* Side effects come in lists.  This walks down 	       * a list, dispatching. 	       */
while|while
condition|(
name|el
condition|)
block|{
name|long
name|effect
decl_stmt|;
name|effect
operator|=
operator|(
name|long
operator|)
name|el
operator|->
name|car
expr_stmt|;
if|if
condition|(
name|effect
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|RX_DEBUG_0
if|if
condition|(
name|rx_debug_trace
condition|)
block|{
name|struct
name|rx_superset
modifier|*
name|setp
init|=
name|search_state
operator|.
name|super
operator|->
name|contents
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"....%d %d>> %s\n"
argument_list|,
name|search_state
operator|.
name|line_no
argument_list|,
name|search_state
operator|.
name|backtrack_depth
argument_list|,
name|efnames
index|[
operator|-
name|effect
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
operator|(
expr|enum
name|re_side_effects
operator|)
name|effect
condition|)
block|{
case|case
name|re_se_pushback
case|:
name|search_state
operator|.
name|ifr
operator|=
operator|&
name|df
operator|->
name|future_frame
expr_stmt|;
if|if
condition|(
operator|!
name|search_state
operator|.
name|ifr
operator|->
name|data
condition|)
block|{
name|struct
name|rx_superstate
modifier|*
name|sup
decl_stmt|;
name|sup
operator|=
name|search_state
operator|.
name|super
expr_stmt|;
name|rx_lock_superstate
argument_list|(
name|rx
argument_list|,
name|sup
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rx_handle_cache_miss
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|search_state
operator|.
name|super
argument_list|,
name|search_state
operator|.
name|c
argument_list|,
operator|(
name|search_state
operator|.
name|ifr
operator|->
name|data_2
operator|)
argument_list|)
condition|)
block|{
name|rx_unlock_superstate
argument_list|(
name|rx
argument_list|,
name|sup
argument_list|)
expr_stmt|;
name|search_state
operator|.
name|test_ret
operator|=
name|rx_test_internal_error
expr_stmt|;
goto|goto
name|test_do_return
goto|;
block|}
name|rx_unlock_superstate
argument_list|(
name|rx
argument_list|,
name|sup
argument_list|)
expr_stmt|;
block|}
comment|/* --search_state.test_pos.pos; */
name|search_state
operator|.
name|c
operator|=
literal|'t'
expr_stmt|;
name|search_state
operator|.
name|super
operator|=
operator|(
operator|(
expr|struct
name|rx_superstate
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|search_state
operator|.
name|ifr
operator|->
name|data
operator|-
call|(
name|long
call|)
argument_list|(
operator|(
operator|(
expr|struct
name|rx_superstate
operator|*
operator|)
literal|0
operator|)
operator|->
name|transitions
argument_list|)
operator|)
operator|)
expr_stmt|;
goto|goto
name|top_of_cycle
goto|;
break|break;
case|case
name|re_se_push0
case|:
block|{
name|struct
name|rx_counter_frame
modifier|*
name|old_cf
init|=
operator|(
name|search_state
operator|.
name|counter_stack
condition|?
operator|(
operator|(
expr|struct
name|rx_counter_frame
operator|*
operator|)
name|search_state
operator|.
name|counter_stack
operator|->
name|sp
operator|)
else|:
literal|0
operator|)
decl_stmt|;
name|struct
name|rx_counter_frame
modifier|*
name|cf
decl_stmt|;
name|PUSH
argument_list|(
name|search_state
operator|.
name|counter_stack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rx_counter_frame
argument_list|)
argument_list|)
expr_stmt|;
name|cf
operator|=
operator|(
operator|(
expr|struct
name|rx_counter_frame
operator|*
operator|)
name|search_state
operator|.
name|counter_stack
operator|->
name|sp
operator|)
expr_stmt|;
name|cf
operator|->
name|tag
operator|=
name|re_se_iter
expr_stmt|;
name|cf
operator|->
name|val
operator|=
literal|0
expr_stmt|;
name|cf
operator|->
name|inherited_from
operator|=
literal|0
expr_stmt|;
name|cf
operator|->
name|cdr
operator|=
name|old_cf
expr_stmt|;
break|break;
block|}
case|case
name|re_se_fail
case|:
goto|goto
name|test_do_return
goto|;
case|case
name|re_se_begbuf
case|:
if|if
condition|(
operator|!
name|AT_STRINGS_BEG
argument_list|()
condition|)
goto|goto
name|test_do_return
goto|;
break|break;
case|case
name|re_se_endbuf
case|:
if|if
condition|(
operator|!
name|AT_STRINGS_END
argument_list|()
condition|)
goto|goto
name|test_do_return
goto|;
break|break;
case|case
name|re_se_wordbeg
case|:
if|if
condition|(
name|LETTER_P
argument_list|(
operator|&
name|search_state
operator|.
name|test_pos
argument_list|,
literal|1
argument_list|)
operator|&&
operator|(
name|AT_STRINGS_BEG
argument_list|()
operator|||
operator|!
name|LETTER_P
argument_list|(
operator|&
name|search_state
operator|.
name|test_pos
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
break|break;
else|else
goto|goto
name|test_do_return
goto|;
case|case
name|re_se_wordend
case|:
if|if
condition|(
operator|!
name|AT_STRINGS_BEG
argument_list|()
operator|&&
name|LETTER_P
argument_list|(
operator|&
name|search_state
operator|.
name|test_pos
argument_list|,
literal|0
argument_list|)
operator|&&
operator|(
name|AT_STRINGS_END
argument_list|()
operator|||
operator|!
name|LETTER_P
argument_list|(
operator|&
name|search_state
operator|.
name|test_pos
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
break|break;
else|else
goto|goto
name|test_do_return
goto|;
case|case
name|re_se_wordbound
case|:
if|if
condition|(
name|AT_WORD_BOUNDARY
argument_list|(
operator|&
name|search_state
operator|.
name|test_pos
argument_list|)
condition|)
break|break;
else|else
goto|goto
name|test_do_return
goto|;
case|case
name|re_se_notwordbound
case|:
if|if
condition|(
operator|!
name|AT_WORD_BOUNDARY
argument_list|(
operator|&
name|search_state
operator|.
name|test_pos
argument_list|)
condition|)
break|break;
else|else
goto|goto
name|test_do_return
goto|;
case|case
name|re_se_hat
case|:
if|if
condition|(
name|AT_STRINGS_BEG
argument_list|()
condition|)
block|{
if|if
condition|(
name|rxb
operator|->
name|not_bol
condition|)
goto|goto
name|test_do_return
goto|;
else|else
break|break;
block|}
else|else
block|{
name|char
name|pos_c
init|=
operator|*
name|search_state
operator|.
name|test_pos
operator|.
name|pos
decl_stmt|;
if|if
condition|(
operator|(
name|SRCH_TRANSLATE
argument_list|(
name|pos_c
argument_list|)
operator|==
name|SRCH_TRANSLATE
argument_list|(
literal|'\n'
argument_list|)
operator|)
operator|&&
name|rxb
operator|->
name|newline_anchor
condition|)
break|break;
else|else
goto|goto
name|test_do_return
goto|;
block|}
case|case
name|re_se_dollar
case|:
if|if
condition|(
name|AT_STRINGS_END
argument_list|()
condition|)
block|{
if|if
condition|(
name|rxb
operator|->
name|not_eol
condition|)
goto|goto
name|test_do_return
goto|;
else|else
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|SRCH_TRANSLATE
argument_list|(
name|fetch_char
argument_list|(
operator|&
name|search_state
operator|.
name|test_pos
argument_list|,
literal|1
argument_list|,
name|app_closure
argument_list|,
name|stop
argument_list|)
argument_list|)
operator|==
name|SRCH_TRANSLATE
argument_list|(
literal|'\n'
argument_list|)
operator|)
operator|&&
name|rxb
operator|->
name|newline_anchor
condition|)
break|break;
else|else
goto|goto
name|test_do_return
goto|;
block|}
case|case
name|re_se_try
case|:
comment|/* This is the first side effect in every 			   * expression. 			   * 			   *  FOR NO GOOD REASON...get rid of it... 			   */
break|break;
case|case
name|re_se_pushpos
case|:
block|{
name|int
name|urhere
init|=
operator|(
call|(
name|int
call|)
argument_list|(
name|search_state
operator|.
name|test_pos
operator|.
name|pos
operator|-
name|search_state
operator|.
name|test_pos
operator|.
name|string
argument_list|)
operator|+
name|search_state
operator|.
name|test_pos
operator|.
name|offset
operator|)
decl_stmt|;
name|struct
name|rx_counter_frame
modifier|*
name|old_cf
init|=
operator|(
name|search_state
operator|.
name|counter_stack
condition|?
operator|(
operator|(
expr|struct
name|rx_counter_frame
operator|*
operator|)
name|search_state
operator|.
name|counter_stack
operator|->
name|sp
operator|)
else|:
literal|0
operator|)
decl_stmt|;
name|struct
name|rx_counter_frame
modifier|*
name|cf
decl_stmt|;
name|PUSH
argument_list|(
name|search_state
operator|.
name|counter_stack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rx_counter_frame
argument_list|)
argument_list|)
expr_stmt|;
name|cf
operator|=
operator|(
operator|(
expr|struct
name|rx_counter_frame
operator|*
operator|)
name|search_state
operator|.
name|counter_stack
operator|->
name|sp
operator|)
expr_stmt|;
name|cf
operator|->
name|tag
operator|=
name|re_se_pushpos
expr_stmt|;
name|cf
operator|->
name|val
operator|=
name|urhere
expr_stmt|;
name|cf
operator|->
name|inherited_from
operator|=
literal|0
expr_stmt|;
name|cf
operator|->
name|cdr
operator|=
name|old_cf
expr_stmt|;
break|break;
block|}
case|case
name|re_se_chkpos
case|:
block|{
name|int
name|urhere
init|=
operator|(
call|(
name|int
call|)
argument_list|(
name|search_state
operator|.
name|test_pos
operator|.
name|pos
operator|-
name|search_state
operator|.
name|test_pos
operator|.
name|string
argument_list|)
operator|+
name|search_state
operator|.
name|test_pos
operator|.
name|offset
operator|)
decl_stmt|;
name|struct
name|rx_counter_frame
modifier|*
name|cf
init|=
operator|(
operator|(
expr|struct
name|rx_counter_frame
operator|*
operator|)
name|search_state
operator|.
name|counter_stack
operator|->
name|sp
operator|)
decl_stmt|;
if|if
condition|(
name|cf
operator|->
name|val
operator|==
name|urhere
condition|)
goto|goto
name|test_do_return
goto|;
name|cf
operator|->
name|val
operator|=
name|urhere
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|re_se_poppos
case|:
name|POP
argument_list|(
name|search_state
operator|.
name|counter_stack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rx_counter_frame
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|re_se_at_dot
case|:
case|case
name|re_se_syntax
case|:
case|case
name|re_se_not_syntax
case|:
ifdef|#
directive|ifdef
name|emacs
comment|/*  			   * this release lacks emacs support 			   */
endif|#
directive|endif
break|break;
case|case
name|re_se_win
case|:
case|case
name|re_se_lparen
case|:
case|case
name|re_se_rparen
case|:
case|case
name|re_se_backref
case|:
case|case
name|re_se_iter
case|:
case|case
name|re_se_end_iter
case|:
case|case
name|re_se_tv
case|:
case|case
name|re_floogle_flap
case|:
name|search_state
operator|.
name|ret_val
operator|=
literal|0
expr_stmt|;
goto|goto
name|test_do_return
goto|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|RX_DEBUG_0
if|if
condition|(
name|rx_debug_trace
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"....%d %d>> %s %d %d\n"
argument_list|,
name|search_state
operator|.
name|line_no
argument_list|,
name|search_state
operator|.
name|backtrack_depth
argument_list|,
name|efnames2
index|[
name|rxb
operator|->
name|se_params
index|[
name|effect
index|]
operator|.
name|se
index|]
argument_list|,
name|rxb
operator|->
name|se_params
index|[
name|effect
index|]
operator|.
name|op1
argument_list|,
name|rxb
operator|->
name|se_params
index|[
name|effect
index|]
operator|.
name|op2
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|rxb
operator|->
name|se_params
index|[
name|effect
index|]
operator|.
name|se
condition|)
block|{
case|case
name|re_se_win
case|:
comment|/* This side effect indicates that we've  			   * found a match, though not necessarily the  			   * best match.  This is a fancy assignment to  			   * register 0 unless the caller didn't  			   * care about registers.  In which case, 			   * this stops the match. 			   */
block|{
name|int
name|urhere
init|=
operator|(
call|(
name|int
call|)
argument_list|(
name|search_state
operator|.
name|test_pos
operator|.
name|pos
operator|-
name|search_state
operator|.
name|test_pos
operator|.
name|string
argument_list|)
operator|+
name|search_state
operator|.
name|test_pos
operator|.
name|offset
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|search_state
operator|.
name|best_last_r
operator|<
literal|0
operator|)
operator|||
operator|(
name|urhere
operator|+
literal|1
operator|>
name|search_state
operator|.
name|best_rparen
index|[
literal|0
index|]
operator|)
condition|)
block|{
comment|/* Record the best known and keep 				 * looking. 				 */
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<=
name|search_state
operator|.
name|last_l
condition|;
operator|++
name|x
control|)
name|search_state
operator|.
name|best_lparen
index|[
name|x
index|]
operator|=
name|search_state
operator|.
name|lparen
index|[
name|x
index|]
expr_stmt|;
name|search_state
operator|.
name|best_last_l
operator|=
name|search_state
operator|.
name|last_l
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<=
name|search_state
operator|.
name|last_r
condition|;
operator|++
name|x
control|)
name|search_state
operator|.
name|best_rparen
index|[
name|x
index|]
operator|=
name|search_state
operator|.
name|rparen
index|[
name|x
index|]
expr_stmt|;
name|search_state
operator|.
name|best_rparen
index|[
literal|0
index|]
operator|=
name|urhere
operator|+
literal|1
expr_stmt|;
name|search_state
operator|.
name|best_last_r
operator|=
name|search_state
operator|.
name|last_r
expr_stmt|;
block|}
comment|/* If we're not reporting the match-length  			     * or other register info, we need look no 			     * further. 			     */
if|if
condition|(
name|search_state
operator|.
name|first_found
condition|)
block|{
name|search_state
operator|.
name|test_ret
operator|=
name|rx_test_found_first
expr_stmt|;
goto|goto
name|test_do_return
goto|;
block|}
block|}
break|break;
case|case
name|re_se_lparen
case|:
block|{
name|int
name|urhere
init|=
operator|(
call|(
name|int
call|)
argument_list|(
name|search_state
operator|.
name|test_pos
operator|.
name|pos
operator|-
name|search_state
operator|.
name|test_pos
operator|.
name|string
argument_list|)
operator|+
name|search_state
operator|.
name|test_pos
operator|.
name|offset
operator|)
decl_stmt|;
name|int
name|reg
init|=
name|rxb
operator|->
name|se_params
index|[
name|effect
index|]
operator|.
name|op1
decl_stmt|;
if|#
directive|if
literal|0
block|if (reg> search_state.last_l)
endif|#
directive|endif
block|{
name|search_state
operator|.
name|lparen
index|[
name|reg
index|]
operator|=
name|urhere
operator|+
literal|1
expr_stmt|;
comment|/* In addition to making this assignment, 				 * we now know that lower numbered regs 				 * that haven't already been assigned, 				 * won't be.  We make sure they're 				 * filled with -1, so they can be 				 * recognized as unassigned. 				 */
if|if
condition|(
name|search_state
operator|.
name|last_l
operator|<
name|reg
condition|)
while|while
condition|(
operator|++
name|search_state
operator|.
name|last_l
operator|<
name|reg
condition|)
name|search_state
operator|.
name|lparen
index|[
name|search_state
operator|.
name|last_l
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
break|break;
block|}
case|case
name|re_se_rparen
case|:
block|{
name|int
name|urhere
init|=
operator|(
call|(
name|int
call|)
argument_list|(
name|search_state
operator|.
name|test_pos
operator|.
name|pos
operator|-
name|search_state
operator|.
name|test_pos
operator|.
name|string
argument_list|)
operator|+
name|search_state
operator|.
name|test_pos
operator|.
name|offset
operator|)
decl_stmt|;
name|int
name|reg
init|=
name|rxb
operator|->
name|se_params
index|[
name|effect
index|]
operator|.
name|op1
decl_stmt|;
name|search_state
operator|.
name|rparen
index|[
name|reg
index|]
operator|=
name|urhere
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|search_state
operator|.
name|last_r
operator|<
name|reg
condition|)
block|{
while|while
condition|(
operator|++
name|search_state
operator|.
name|last_r
operator|<
name|reg
condition|)
name|search_state
operator|.
name|rparen
index|[
name|search_state
operator|.
name|last_r
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
break|break;
block|}
case|case
name|re_se_backref
case|:
block|{
name|int
name|reg
init|=
name|rxb
operator|->
name|se_params
index|[
name|effect
index|]
operator|.
name|op1
decl_stmt|;
if|if
condition|(
name|reg
operator|>
name|search_state
operator|.
name|last_r
operator|||
name|search_state
operator|.
name|rparen
index|[
name|reg
index|]
operator|<
literal|0
condition|)
goto|goto
name|test_do_return
goto|;
block|{
name|int
name|backref_status
decl_stmt|;
name|check_backreference
label|:
name|backref_status
operator|=
name|back_check
argument_list|(
operator|&
name|search_state
operator|.
name|test_pos
argument_list|,
name|search_state
operator|.
name|lparen
index|[
name|reg
index|]
argument_list|,
name|search_state
operator|.
name|rparen
index|[
name|reg
index|]
argument_list|,
name|search_state
operator|.
name|translate
argument_list|,
name|app_closure
argument_list|,
name|stop
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|backref_status
condition|)
block|{
case|case
name|rx_back_check_continuation
case|:
name|search_state
operator|.
name|saved_reg
operator|=
name|reg
expr_stmt|;
name|test_pc
operator|=
name|rx_test_backreference_check
expr_stmt|;
goto|goto
name|test_return_continuation
goto|;
name|resume_continuation_2
label|:
name|reg
operator|=
name|search_state
operator|.
name|saved_reg
expr_stmt|;
goto|goto
name|check_backreference
goto|;
case|case
name|rx_back_check_fail
case|:
comment|/* Fail */
goto|goto
name|test_do_return
goto|;
case|case
name|rx_back_check_pass
case|:
comment|/* pass -- 				   * test_pos now advanced to last 				   * char matched by backref 				   */
break|break;
block|}
block|}
break|break;
block|}
case|case
name|re_se_iter
case|:
block|{
name|struct
name|rx_counter_frame
modifier|*
name|csp
init|=
operator|(
operator|(
expr|struct
name|rx_counter_frame
operator|*
operator|)
name|search_state
operator|.
name|counter_stack
operator|->
name|sp
operator|)
decl_stmt|;
if|if
condition|(
name|csp
operator|->
name|val
operator|==
name|rxb
operator|->
name|se_params
index|[
name|effect
index|]
operator|.
name|op2
condition|)
goto|goto
name|test_do_return
goto|;
else|else
operator|++
name|csp
operator|->
name|val
expr_stmt|;
break|break;
block|}
case|case
name|re_se_end_iter
case|:
block|{
name|struct
name|rx_counter_frame
modifier|*
name|csp
init|=
operator|(
operator|(
expr|struct
name|rx_counter_frame
operator|*
operator|)
name|search_state
operator|.
name|counter_stack
operator|->
name|sp
operator|)
decl_stmt|;
if|if
condition|(
name|csp
operator|->
name|val
operator|<
name|rxb
operator|->
name|se_params
index|[
name|effect
index|]
operator|.
name|op1
condition|)
goto|goto
name|test_do_return
goto|;
else|else
block|{
name|struct
name|rx_counter_frame
modifier|*
name|source
init|=
name|csp
decl_stmt|;
while|while
condition|(
name|source
operator|->
name|inherited_from
condition|)
name|source
operator|=
name|source
operator|->
name|inherited_from
expr_stmt|;
if|if
condition|(
operator|!
name|source
operator|||
operator|!
name|source
operator|->
name|cdr
condition|)
block|{
name|POP
argument_list|(
name|search_state
operator|.
name|counter_stack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rx_counter_frame
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|source
operator|=
name|source
operator|->
name|cdr
expr_stmt|;
name|csp
operator|->
name|val
operator|=
name|source
operator|->
name|val
expr_stmt|;
name|csp
operator|->
name|tag
operator|=
name|source
operator|->
name|tag
expr_stmt|;
name|csp
operator|->
name|cdr
operator|=
literal|0
expr_stmt|;
name|csp
operator|->
name|inherited_from
operator|=
name|source
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|re_se_tv
case|:
comment|/* is a noop */
break|break;
case|case
name|re_se_try
case|:
case|case
name|re_se_pushback
case|:
case|case
name|re_se_push0
case|:
case|case
name|re_se_pushpos
case|:
case|case
name|re_se_chkpos
case|:
case|case
name|re_se_poppos
case|:
case|case
name|re_se_at_dot
case|:
case|case
name|re_se_syntax
case|:
case|case
name|re_se_not_syntax
case|:
case|case
name|re_se_begbuf
case|:
case|case
name|re_se_hat
case|:
case|case
name|re_se_wordbeg
case|:
case|case
name|re_se_wordbound
case|:
case|case
name|re_se_notwordbound
case|:
case|case
name|re_se_wordend
case|:
case|case
name|re_se_endbuf
case|:
case|case
name|re_se_dollar
case|:
case|case
name|re_se_fail
case|:
case|case
name|re_floogle_flap
case|:
name|search_state
operator|.
name|ret_val
operator|=
literal|0
expr_stmt|;
goto|goto
name|test_do_return
goto|;
block|}
block|}
name|el
operator|=
name|el
operator|->
name|cdr
expr_stmt|;
block|}
comment|/* Now the side effects are done, 	       * so get the next instruction. 	       * and move on. 	       */
name|search_state
operator|.
name|ifr
operator|=
operator|&
name|df
operator|->
name|future_frame
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
case|case
name|rx_backtrack_point
case|:
block|{
comment|/* A backtrack point indicates that we've reached a 	       * non-determinism in the superstate NFA.  This is a 	       * loop that exhaustively searches the possibilities. 	       * 	       * A backtracking strategy is used.  We keep track of what 	       * registers are valid so we can erase side effects. 	       * 	       * First, make sure there is some stack space to hold  	       * our state. 	       */
name|struct
name|rx_backtrack_frame
modifier|*
name|bf
decl_stmt|;
name|PUSH
argument_list|(
name|search_state
operator|.
name|backtrack_stack
argument_list|,
name|search_state
operator|.
name|backtrack_frame_bytes
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RX_DEBUG_0
operator|++
name|search_state
operator|.
name|backtrack_depth
expr_stmt|;
endif|#
directive|endif
name|bf
operator|=
operator|(
operator|(
expr|struct
name|rx_backtrack_frame
operator|*
operator|)
name|search_state
operator|.
name|backtrack_stack
operator|->
name|sp
operator|)
expr_stmt|;
block|{
name|bf
operator|->
name|stk_super
operator|=
name|search_state
operator|.
name|super
expr_stmt|;
comment|/* We prevent the current superstate from being 		 * deleted from the superstate cache. 		 */
name|rx_lock_superstate
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|search_state
operator|.
name|super
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RX_DEBUG_0
name|bf
operator|->
name|stk_search_state
operator|.
name|line_no
operator|=
name|search_state
operator|.
name|line_no
expr_stmt|;
endif|#
directive|endif
name|bf
operator|->
name|stk_c
operator|=
name|search_state
operator|.
name|c
expr_stmt|;
name|bf
operator|->
name|stk_test_pos
operator|=
name|search_state
operator|.
name|test_pos
expr_stmt|;
name|bf
operator|->
name|stk_last_l
operator|=
name|search_state
operator|.
name|last_l
expr_stmt|;
name|bf
operator|->
name|stk_last_r
operator|=
name|search_state
operator|.
name|last_r
expr_stmt|;
name|bf
operator|->
name|df
operator|=
operator|(
operator|(
expr|struct
name|rx_super_edge
operator|*
operator|)
name|search_state
operator|.
name|ifr
operator|->
name|data_2
operator|)
operator|->
name|options
expr_stmt|;
name|bf
operator|->
name|first_df
operator|=
name|bf
operator|->
name|df
expr_stmt|;
name|bf
operator|->
name|counter_stack_sp
operator|=
operator|(
name|search_state
operator|.
name|counter_stack
condition|?
name|search_state
operator|.
name|counter_stack
operator|->
name|sp
else|:
literal|0
operator|)
expr_stmt|;
name|bf
operator|->
name|stk_test_ret
operator|=
name|search_state
operator|.
name|test_ret
expr_stmt|;
if|if
condition|(
name|rxb
operator|->
name|match_regs_on_stack
condition|)
block|{
name|int
name|x
decl_stmt|;
name|regoff_t
modifier|*
name|stk
init|=
operator|(
name|regoff_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|bf
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|bf
argument_list|)
operator|)
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<=
name|search_state
operator|.
name|last_l
condition|;
operator|++
name|x
control|)
name|stk
index|[
name|x
index|]
operator|=
name|search_state
operator|.
name|lparen
index|[
name|x
index|]
expr_stmt|;
name|stk
operator|+=
name|x
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<=
name|search_state
operator|.
name|last_r
condition|;
operator|++
name|x
control|)
name|stk
index|[
name|x
index|]
operator|=
name|search_state
operator|.
name|rparen
index|[
name|x
index|]
expr_stmt|;
block|}
block|}
comment|/* Here is a while loop whose body is mainly a function 	       * call and some code to handle a return from that 	       * function. 	       * 	       * From here on for the rest of `case backtrack_point' it 	       * is unsafe to assume that the search_state copies of  	       * variables saved on the backtracking stack are valid 	       * -- so read their values from the backtracking stack. 	       * 	       * This lets us use one generation fewer stack saves in 	       * the call-graph of a search. 	       */
name|while_non_det_options
label|:
ifdef|#
directive|ifdef
name|RX_DEBUG_0
operator|++
name|search_state
operator|.
name|lines_found
expr_stmt|;
if|if
condition|(
name|rx_debug_trace
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"@@@ %d calls %d @@@\n"
argument_list|,
name|search_state
operator|.
name|line_no
argument_list|,
name|search_state
operator|.
name|lines_found
argument_list|)
expr_stmt|;
name|search_state
operator|.
name|line_no
operator|=
name|search_state
operator|.
name|lines_found
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bf
operator|->
name|df
operator|->
name|next_same_super_edge
index|[
literal|0
index|]
operator|==
name|bf
operator|->
name|first_df
condition|)
block|{
comment|/* This is a tail-call optimization -- we don't recurse 		   * for the last of the possible futures. 		   */
name|search_state
operator|.
name|ifr
operator|=
operator|(
name|bf
operator|->
name|df
operator|->
name|effects
condition|?
operator|&
name|bf
operator|->
name|df
operator|->
name|side_effects_frame
else|:
operator|&
name|bf
operator|->
name|df
operator|->
name|future_frame
operator|)
expr_stmt|;
name|rx_unlock_superstate
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|search_state
operator|.
name|super
argument_list|)
expr_stmt|;
name|POP
argument_list|(
name|search_state
operator|.
name|backtrack_stack
argument_list|,
name|search_state
operator|.
name|backtrack_frame_bytes
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RX_DEBUG
operator|--
name|search_state
operator|.
name|backtrack_depth
expr_stmt|;
endif|#
directive|endif
goto|goto
name|restart
goto|;
block|}
else|else
block|{
if|if
condition|(
name|search_state
operator|.
name|counter_stack
condition|)
block|{
name|struct
name|rx_counter_frame
modifier|*
name|old_cf
init|=
operator|(
operator|(
expr|struct
name|rx_counter_frame
operator|*
operator|)
name|search_state
operator|.
name|counter_stack
operator|->
name|sp
operator|)
decl_stmt|;
name|struct
name|rx_counter_frame
modifier|*
name|cf
decl_stmt|;
name|PUSH
argument_list|(
name|search_state
operator|.
name|counter_stack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rx_counter_frame
argument_list|)
argument_list|)
expr_stmt|;
name|cf
operator|=
operator|(
operator|(
expr|struct
name|rx_counter_frame
operator|*
operator|)
name|search_state
operator|.
name|counter_stack
operator|->
name|sp
operator|)
expr_stmt|;
name|cf
operator|->
name|tag
operator|=
name|old_cf
operator|->
name|tag
expr_stmt|;
name|cf
operator|->
name|val
operator|=
name|old_cf
operator|->
name|val
expr_stmt|;
name|cf
operator|->
name|inherited_from
operator|=
name|old_cf
expr_stmt|;
name|cf
operator|->
name|cdr
operator|=
literal|0
expr_stmt|;
block|}
comment|/* `Call' this test-match block */
name|search_state
operator|.
name|ifr
operator|=
operator|(
name|bf
operator|->
name|df
operator|->
name|effects
condition|?
operator|&
name|bf
operator|->
name|df
operator|->
name|side_effects_frame
else|:
operator|&
name|bf
operator|->
name|df
operator|->
name|future_frame
operator|)
expr_stmt|;
goto|goto
name|recurse_test_match
goto|;
block|}
comment|/* Returns in this block are accomplished by 	       * goto test_do_return.  There are two cases. 	       * If there is some search-stack left, 	       * then it is a return from a `recursive' call. 	       * If there is no search-stack left, then 	       * we should return to the fastmap/search loop. 	       */
name|test_do_return
label|:
if|if
condition|(
operator|!
name|search_state
operator|.
name|backtrack_stack
condition|)
block|{
ifdef|#
directive|ifdef
name|RX_DEBUG_0
if|if
condition|(
name|rx_debug_trace
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"!!! %d bails returning %d !!!\n"
argument_list|,
name|search_state
operator|.
name|line_no
argument_list|,
name|search_state
operator|.
name|test_ret
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* No more search-stack -- this test is done. */
if|if
condition|(
name|search_state
operator|.
name|test_ret
operator|!=
name|rx_test_internal_error
condition|)
goto|goto
name|return_from_test_match
goto|;
else|else
goto|goto
name|error_in_testing_match
goto|;
block|}
comment|/* Returning from a recursive call to  	       * the test match block: 	       */
name|bf
operator|=
operator|(
operator|(
expr|struct
name|rx_backtrack_frame
operator|*
operator|)
name|search_state
operator|.
name|backtrack_stack
operator|->
name|sp
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RX_DEBUG_0
if|if
condition|(
name|rx_debug_trace
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"+++ %d returns %d (to %d)+++\n"
argument_list|,
name|search_state
operator|.
name|line_no
argument_list|,
name|search_state
operator|.
name|test_ret
argument_list|,
name|bf
operator|->
name|stk_search_state
operator|.
name|line_no
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|search_state
operator|.
name|counter_stack
operator|&&
operator|(
operator|!
name|bf
operator|->
name|counter_stack_sp
operator|||
operator|(
name|bf
operator|->
name|counter_stack_sp
operator|!=
name|search_state
operator|.
name|counter_stack
operator|->
name|sp
operator|)
operator|)
condition|)
block|{
name|POP
argument_list|(
name|search_state
operator|.
name|counter_stack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rx_counter_frame
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|search_state
operator|.
name|test_ret
operator|==
name|rx_test_internal_error
condition|)
block|{
name|POP
argument_list|(
name|search_state
operator|.
name|backtrack_stack
argument_list|,
name|search_state
operator|.
name|backtrack_frame_bytes
argument_list|)
expr_stmt|;
name|search_state
operator|.
name|test_ret
operator|=
name|rx_test_internal_error
expr_stmt|;
goto|goto
name|test_do_return
goto|;
block|}
comment|/* If a non-longest match was found and that is good  	       * enough, return immediately. 	       */
if|if
condition|(
operator|(
name|search_state
operator|.
name|test_ret
operator|==
name|rx_test_found_first
operator|)
operator|&&
name|search_state
operator|.
name|first_found
condition|)
block|{
name|rx_unlock_superstate
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|bf
operator|->
name|stk_super
argument_list|)
expr_stmt|;
name|POP
argument_list|(
name|search_state
operator|.
name|backtrack_stack
argument_list|,
name|search_state
operator|.
name|backtrack_frame_bytes
argument_list|)
expr_stmt|;
goto|goto
name|test_do_return
goto|;
block|}
name|search_state
operator|.
name|test_ret
operator|=
name|bf
operator|->
name|stk_test_ret
expr_stmt|;
name|search_state
operator|.
name|last_l
operator|=
name|bf
operator|->
name|stk_last_l
expr_stmt|;
name|search_state
operator|.
name|last_r
operator|=
name|bf
operator|->
name|stk_last_r
expr_stmt|;
name|bf
operator|->
name|df
operator|=
name|bf
operator|->
name|df
operator|->
name|next_same_super_edge
index|[
literal|0
index|]
expr_stmt|;
name|search_state
operator|.
name|super
operator|=
name|bf
operator|->
name|stk_super
expr_stmt|;
name|search_state
operator|.
name|c
operator|=
name|bf
operator|->
name|stk_c
expr_stmt|;
ifdef|#
directive|ifdef
name|RX_DEBUG_0
name|search_state
operator|.
name|line_no
operator|=
name|bf
operator|->
name|stk_search_state
operator|.
name|line_no
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rxb
operator|->
name|match_regs_on_stack
condition|)
block|{
name|int
name|x
decl_stmt|;
name|regoff_t
modifier|*
name|stk
init|=
operator|(
name|regoff_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|bf
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|bf
argument_list|)
operator|)
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<=
name|search_state
operator|.
name|last_l
condition|;
operator|++
name|x
control|)
name|search_state
operator|.
name|lparen
index|[
name|x
index|]
operator|=
name|stk
index|[
name|x
index|]
expr_stmt|;
name|stk
operator|+=
name|x
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<=
name|search_state
operator|.
name|last_r
condition|;
operator|++
name|x
control|)
name|search_state
operator|.
name|rparen
index|[
name|x
index|]
operator|=
name|stk
index|[
name|x
index|]
expr_stmt|;
block|}
block|{
name|int
name|x
decl_stmt|;
name|try_burst_2
label|:
name|x
operator|=
name|get_burst
argument_list|(
operator|&
name|bf
operator|->
name|stk_test_pos
argument_list|,
name|app_closure
argument_list|,
name|stop
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|x
condition|)
block|{
case|case
name|rx_get_burst_continuation
case|:
name|search_state
operator|.
name|saved_bf
operator|=
name|bf
expr_stmt|;
name|test_pc
operator|=
name|rx_test_backtrack_return
expr_stmt|;
goto|goto
name|test_return_continuation
goto|;
name|resume_continuation_3
label|:
name|bf
operator|=
name|search_state
operator|.
name|saved_bf
expr_stmt|;
goto|goto
name|try_burst_2
goto|;
case|case
name|rx_get_burst_no_more
case|:
comment|/* Since we've been here before, it is some kind of 		     * error that we can't return. 		     */
case|case
name|rx_get_burst_error
case|:
name|search_state
operator|.
name|test_ret
operator|=
name|rx_test_internal_error
expr_stmt|;
goto|goto
name|test_do_return
goto|;
case|case
name|rx_get_burst_ok
case|:
break|break;
block|}
block|}
name|search_state
operator|.
name|test_pos
operator|=
name|bf
operator|->
name|stk_test_pos
expr_stmt|;
goto|goto
name|while_non_det_options
goto|;
block|}
case|case
name|rx_cache_miss
case|:
comment|/* Because the superstate NFA is lazily constructed, 	     * and in fact may erode from underneath us, we sometimes 	     * have to construct the next instruction from the hard way. 	     * This invokes one step in the lazy-conversion. 	     */
name|search_state
operator|.
name|ifr
operator|=
name|rx_handle_cache_miss
argument_list|(
operator|&
name|rxb
operator|->
name|rx
argument_list|,
name|search_state
operator|.
name|super
argument_list|,
name|search_state
operator|.
name|c
argument_list|,
name|search_state
operator|.
name|ifr
operator|->
name|data_2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|search_state
operator|.
name|ifr
condition|)
block|{
name|search_state
operator|.
name|test_ret
operator|=
name|rx_test_internal_error
expr_stmt|;
goto|goto
name|test_do_return
goto|;
block|}
goto|goto
name|restart
goto|;
case|case
name|rx_backtrack
case|:
comment|/* RX_BACKTRACK means that we've reached the empty 	     * superstate, indicating that match can't succeed 	     * from this point. 	     */
goto|goto
name|test_do_return
goto|;
case|case
name|rx_next_char
case|:
case|case
name|rx_error_inx
case|:
case|case
name|rx_num_instructions
case|:
name|search_state
operator|.
name|ret_val
operator|=
literal|0
expr_stmt|;
goto|goto
name|test_do_return
goto|;
block|}
goto|goto
name|pseudo_while_1
goto|;
block|}
comment|/* Healthy exits from the test-match loop do a       * `goto return_from_test_match'   On the other hand,       * we might end up here.      */
name|error_in_testing_match
label|:
name|test_state
operator|=
name|rx_test_error
expr_stmt|;
goto|goto
name|test_returns_to_search
goto|;
comment|/***** fastmap/search loop body      *	      considering the results testing for a match      */
name|return_from_test_match
label|:
if|if
condition|(
name|search_state
operator|.
name|best_last_l
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|regs
operator|&&
operator|(
name|regs
operator|->
name|start
operator|!=
name|search_state
operator|.
name|best_lparen
operator|)
condition|)
block|{
name|bcopy
argument_list|(
name|search_state
operator|.
name|best_lparen
argument_list|,
name|regs
operator|->
name|start
argument_list|,
name|regs
operator|->
name|num_regs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|search_state
operator|.
name|best_rparen
argument_list|,
name|regs
operator|->
name|end
argument_list|,
name|regs
operator|->
name|num_regs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regs
operator|&&
operator|!
name|rxb
operator|->
name|no_sub
condition|)
block|{
name|int
name|q
decl_stmt|;
name|int
name|bound
init|=
operator|(
name|regs
operator|->
name|num_regs
operator|>
name|search_state
operator|.
name|num_regs
condition|?
name|regs
operator|->
name|num_regs
else|:
name|search_state
operator|.
name|num_regs
operator|)
decl_stmt|;
name|regoff_t
modifier|*
name|s
init|=
name|regs
operator|->
name|start
decl_stmt|;
name|regoff_t
modifier|*
name|e
init|=
name|regs
operator|->
name|end
decl_stmt|;
for|for
control|(
name|q
operator|=
name|search_state
operator|.
name|best_last_l
operator|+
literal|1
init|;
name|q
operator|<
name|bound
condition|;
operator|++
name|q
control|)
name|s
index|[
name|q
index|]
operator|=
name|e
index|[
name|q
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|search_state
operator|.
name|ret_val
operator|=
name|search_state
operator|.
name|best_lparen
index|[
literal|0
index|]
expr_stmt|;
name|test_state
operator|=
name|rx_test_ok
expr_stmt|;
goto|goto
name|test_returns_to_search
goto|;
block|}
else|else
block|{
name|test_state
operator|=
name|rx_test_fail
expr_stmt|;
goto|goto
name|test_returns_to_search
goto|;
block|}
name|test_return_continuation
label|:
name|search_state
operator|.
name|test_match_resume_pt
operator|=
name|test_pc
expr_stmt|;
name|test_state
operator|=
name|rx_test_continuation
expr_stmt|;
goto|goto
name|test_returns_to_search
goto|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RX_WANT_RX_DEFS */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* RX_WANT_SE_DEFS */
end_comment

begin_comment
comment|/* Integers are used to represent side effects.    *    * Simple side effects are given negative integer names by these enums.    *     * Non-negative names are reserved for complex effects.    *    * Complex effects are those that take arguments.  For example,     * a register assignment associated with a group is complex because    * it requires an argument to tell which group is being matched.    *     * The integer name of a complex effect is an index into rxb->se_params.    */
end_comment

begin_macro
name|RX_DEF_SE
argument_list|(
literal|1
argument_list|,
argument|re_se_try
argument_list|,
argument|= -
literal|1
argument_list|)
end_macro

begin_comment
comment|/* Epsilon from start state */
end_comment

begin_macro
name|RX_DEF_SE
argument_list|(
literal|0
argument_list|,
argument|re_se_pushback
argument_list|,
argument|= re_se_try -
literal|1
argument_list|)
end_macro

begin_macro
name|RX_DEF_SE
argument_list|(
literal|0
argument_list|,
argument|re_se_push0
argument_list|,
argument|= re_se_pushback -
literal|1
argument_list|)
end_macro

begin_macro
name|RX_DEF_SE
argument_list|(
literal|0
argument_list|,
argument|re_se_pushpos
argument_list|,
argument|= re_se_push0 -
literal|1
argument_list|)
end_macro

begin_macro
name|RX_DEF_SE
argument_list|(
literal|0
argument_list|,
argument|re_se_chkpos
argument_list|,
argument|= re_se_pushpos -
literal|1
argument_list|)
end_macro

begin_macro
name|RX_DEF_SE
argument_list|(
literal|0
argument_list|,
argument|re_se_poppos
argument_list|,
argument|= re_se_chkpos -
literal|1
argument_list|)
end_macro

begin_macro
name|RX_DEF_SE
argument_list|(
literal|1
argument_list|,
argument|re_se_at_dot
argument_list|,
argument|= re_se_poppos -
literal|1
argument_list|)
end_macro

begin_comment
comment|/* Emacs only */
end_comment

begin_macro
name|RX_DEF_SE
argument_list|(
literal|0
argument_list|,
argument|re_se_syntax
argument_list|,
argument|= re_se_at_dot -
literal|1
argument_list|)
end_macro

begin_comment
comment|/* Emacs only */
end_comment

begin_macro
name|RX_DEF_SE
argument_list|(
literal|0
argument_list|,
argument|re_se_not_syntax
argument_list|,
argument|= re_se_syntax -
literal|1
argument_list|)
end_macro

begin_comment
comment|/* Emacs only */
end_comment

begin_macro
name|RX_DEF_SE
argument_list|(
literal|1
argument_list|,
argument|re_se_begbuf
argument_list|,
argument|= re_se_not_syntax -
literal|1
argument_list|)
end_macro

begin_comment
comment|/* match beginning of buffer */
end_comment

begin_macro
name|RX_DEF_SE
argument_list|(
literal|1
argument_list|,
argument|re_se_hat
argument_list|,
argument|= re_se_begbuf -
literal|1
argument_list|)
end_macro

begin_comment
comment|/* match beginning of line */
end_comment

begin_macro
name|RX_DEF_SE
argument_list|(
literal|1
argument_list|,
argument|re_se_wordbeg
argument_list|,
argument|= re_se_hat -
literal|1
argument_list|)
end_macro

begin_macro
name|RX_DEF_SE
argument_list|(
literal|1
argument_list|,
argument|re_se_wordbound
argument_list|,
argument|= re_se_wordbeg -
literal|1
argument_list|)
end_macro

begin_macro
name|RX_DEF_SE
argument_list|(
literal|1
argument_list|,
argument|re_se_notwordbound
argument_list|,
argument|= re_se_wordbound -
literal|1
argument_list|)
end_macro

begin_macro
name|RX_DEF_SE
argument_list|(
literal|1
argument_list|,
argument|re_se_wordend
argument_list|,
argument|= re_se_notwordbound -
literal|1
argument_list|)
end_macro

begin_macro
name|RX_DEF_SE
argument_list|(
literal|1
argument_list|,
argument|re_se_endbuf
argument_list|,
argument|= re_se_wordend -
literal|1
argument_list|)
end_macro

begin_comment
comment|/* This fails except at the end of a line.     * It deserves to go here since it is typicly one of the last steps     * in a match.    */
end_comment

begin_macro
name|RX_DEF_SE
argument_list|(
literal|1
argument_list|,
argument|re_se_dollar
argument_list|,
argument|= re_se_endbuf -
literal|1
argument_list|)
end_macro

begin_comment
comment|/* Simple effects: */
end_comment

begin_macro
name|RX_DEF_SE
argument_list|(
literal|1
argument_list|,
argument|re_se_fail
argument_list|,
argument|= re_se_dollar -
literal|1
argument_list|)
end_macro

begin_comment
comment|/* Complex effects.  These are used in the 'se' field of     * a struct re_se_params.  Indexes into the se array    * are stored as instructions on nfa edges.    */
end_comment

begin_macro
name|RX_DEF_CPLX_SE
argument_list|(
literal|1
argument_list|,
argument|re_se_win
argument_list|,
argument|=
literal|0
argument_list|)
end_macro

begin_macro
name|RX_DEF_CPLX_SE
argument_list|(
literal|1
argument_list|,
argument|re_se_lparen
argument_list|,
argument|= re_se_win +
literal|1
argument_list|)
end_macro

begin_macro
name|RX_DEF_CPLX_SE
argument_list|(
literal|1
argument_list|,
argument|re_se_rparen
argument_list|,
argument|= re_se_lparen +
literal|1
argument_list|)
end_macro

begin_macro
name|RX_DEF_CPLX_SE
argument_list|(
literal|0
argument_list|,
argument|re_se_backref
argument_list|,
argument|= re_se_rparen +
literal|1
argument_list|)
end_macro

begin_macro
name|RX_DEF_CPLX_SE
argument_list|(
literal|0
argument_list|,
argument|re_se_iter
argument_list|,
argument|= re_se_backref +
literal|1
argument_list|)
end_macro

begin_macro
name|RX_DEF_CPLX_SE
argument_list|(
literal|0
argument_list|,
argument|re_se_end_iter
argument_list|,
argument|= re_se_iter +
literal|1
argument_list|)
end_macro

begin_macro
name|RX_DEF_CPLX_SE
argument_list|(
literal|0
argument_list|,
argument|re_se_tv
argument_list|,
argument|= re_se_end_iter +
literal|1
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

