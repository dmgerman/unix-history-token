begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * Copyright (c) 1994  * Hewlett-Packard Company  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Hewlett-Packard Company makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FUNCTION_H
end_ifndef

begin_define
define|#
directive|define
name|FUNCTION_H
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|__GNUG__
end_ifndef

begin_include
include|#
directive|include
file|<bool.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|template
operator|<
name|class
name|T1
operator|,
name|class
name|T2
operator|>
specifier|inline
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|T1
operator|&
name|x
operator|,
specifier|const
name|T2
operator|&
name|y
operator|)
block|{
return|return
operator|!
operator|(
name|x
operator|==
name|y
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T1
operator|,
name|class
name|T2
operator|>
specifier|inline
name|bool
name|operator
operator|>
operator|(
specifier|const
name|T1
operator|&
name|x
operator|,
specifier|const
name|T2
operator|&
name|y
operator|)
block|{
return|return
name|y
operator|<
name|x
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T1
operator|,
name|class
name|T2
operator|>
specifier|inline
name|bool
name|operator
operator|<=
operator|(
specifier|const
name|T1
operator|&
name|x
operator|,
specifier|const
name|T2
operator|&
name|y
operator|)
block|{
return|return
operator|!
operator|(
name|y
operator|<
name|x
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|T1
operator|,
name|class
name|T2
operator|>
specifier|inline
name|bool
name|operator
operator|>=
operator|(
specifier|const
name|T1
operator|&
name|x
operator|,
specifier|const
name|T2
operator|&
name|y
operator|)
block|{
return|return
operator|!
operator|(
name|x
operator|<
name|y
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Arg
operator|,
name|class
name|Result
operator|>
expr|struct
name|unary_function
block|{
typedef|typedef
name|Arg
name|argument_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|Result
name|result_type
typedef|;
end_typedef

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Arg1
operator|,
name|class
name|Arg2
operator|,
name|class
name|Result
operator|>
expr|struct
name|binary_function
block|{
typedef|typedef
name|Arg1
name|first_argument_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|Arg2
name|second_argument_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|Result
name|result_type
typedef|;
end_typedef

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|plus
operator|:
name|binary_function
operator|<
name|T
operator|,
name|T
operator|,
name|T
operator|>
block|{
name|T
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|,
specifier|const
name|T
operator|&
name|y
operator|)
specifier|const
block|{
return|return
name|x
operator|+
name|y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|minus
operator|:
name|binary_function
operator|<
name|T
operator|,
name|T
operator|,
name|T
operator|>
block|{
name|T
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|,
specifier|const
name|T
operator|&
name|y
operator|)
specifier|const
block|{
return|return
name|x
operator|-
name|y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|times
operator|:
name|binary_function
operator|<
name|T
operator|,
name|T
operator|,
name|T
operator|>
block|{
name|T
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|,
specifier|const
name|T
operator|&
name|y
operator|)
specifier|const
block|{
return|return
name|x
operator|*
name|y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|divides
operator|:
name|binary_function
operator|<
name|T
operator|,
name|T
operator|,
name|T
operator|>
block|{
name|T
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|,
specifier|const
name|T
operator|&
name|y
operator|)
specifier|const
block|{
return|return
name|x
operator|/
name|y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
ifdef|#
directive|ifdef
name|__GNU__
expr|struct
name|modulus
block|{
typedef|typedef
name|T
name|first_argument_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|T
name|second_argument_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|T
name|result_type
typedef|;
end_typedef

begin_expr_stmt
name|T
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|,
specifier|const
name|T
operator|&
name|y
operator|)
specifier|const
block|{
return|return
name|x
operator|%
name|y
return|;
block|}
end_expr_stmt

begin_else
unit|};
else|#
directive|else
end_else

begin_decl_stmt
name|struct
name|modulus
range|:
name|binary_function
operator|<
name|T
decl_stmt|,
name|T
decl_stmt|,
name|T
decl|>
block|{
name|T
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|,
specifier|const
name|T
operator|&
name|y
operator|)
specifier|const
block|{
return|return
name|x
operator|%
name|y
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|negate
operator|:
name|unary_function
operator|<
name|T
operator|,
name|T
operator|>
block|{
name|T
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|)
specifier|const
block|{
return|return
operator|-
name|x
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|equal_to
operator|:
name|binary_function
operator|<
name|T
operator|,
name|T
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|,
specifier|const
name|T
operator|&
name|y
operator|)
specifier|const
block|{
return|return
name|x
operator|==
name|y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|not_equal_to
operator|:
name|binary_function
operator|<
name|T
operator|,
name|T
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|,
specifier|const
name|T
operator|&
name|y
operator|)
specifier|const
block|{
return|return
name|x
operator|!=
name|y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|greater
operator|:
name|binary_function
operator|<
name|T
operator|,
name|T
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|,
specifier|const
name|T
operator|&
name|y
operator|)
specifier|const
block|{
return|return
name|x
operator|>
name|y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|less
operator|:
name|binary_function
operator|<
name|T
operator|,
name|T
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|,
specifier|const
name|T
operator|&
name|y
operator|)
specifier|const
block|{
return|return
name|x
operator|<
name|y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|greater_equal
operator|:
name|binary_function
operator|<
name|T
operator|,
name|T
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|,
specifier|const
name|T
operator|&
name|y
operator|)
specifier|const
block|{
return|return
name|x
operator|>=
name|y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|less_equal
operator|:
name|binary_function
operator|<
name|T
operator|,
name|T
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|,
specifier|const
name|T
operator|&
name|y
operator|)
specifier|const
block|{
return|return
name|x
operator|<=
name|y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|logical_and
operator|:
name|binary_function
operator|<
name|T
operator|,
name|T
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|,
specifier|const
name|T
operator|&
name|y
operator|)
specifier|const
block|{
return|return
name|x
operator|&&
name|y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|logical_or
operator|:
name|binary_function
operator|<
name|T
operator|,
name|T
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|,
specifier|const
name|T
operator|&
name|y
operator|)
specifier|const
block|{
return|return
name|x
operator|||
name|y
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|logical_not
operator|:
name|unary_function
operator|<
name|T
operator|,
name|bool
operator|>
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|T
operator|&
name|x
operator|)
specifier|const
block|{
return|return
operator|!
name|x
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Predicate
operator|>
name|class
name|unary_negate
operator|:
name|public
name|unary_function
operator|<
name|Predicate
operator|::
name|argument_type
operator|,
name|bool
operator|>
block|{
name|protected
operator|:
name|Predicate
name|pred
block|;
name|public
operator|:
name|unary_negate
argument_list|(
specifier|const
name|Predicate
operator|&
name|x
argument_list|)
operator|:
name|pred
argument_list|(
argument|x
argument_list|)
block|{}
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|argument_type
operator|&
name|x
operator|)
specifier|const
block|{
return|return
operator|!
name|pred
argument_list|(
name|x
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Predicate
operator|>
name|unary_negate
operator|<
name|Predicate
operator|>
name|not1
argument_list|(
argument|const Predicate& pred
argument_list|)
block|{
return|return
name|unary_negate
operator|<
name|Predicate
operator|>
operator|(
name|pred
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Predicate
operator|>
name|class
name|binary_negate
operator|:
name|public
name|binary_function
operator|<
name|Predicate
operator|::
name|first_argument_type
operator|,
name|Predicate
operator|::
name|second_argument_type
operator|,
name|bool
operator|>
block|{
name|protected
operator|:
name|Predicate
name|pred
block|;
name|public
operator|:
name|binary_negate
argument_list|(
specifier|const
name|Predicate
operator|&
name|x
argument_list|)
operator|:
name|pred
argument_list|(
argument|x
argument_list|)
block|{}
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|first_argument_type
operator|&
name|x
operator|,
specifier|const
name|second_argument_type
operator|&
name|y
operator|)
specifier|const
block|{
return|return
operator|!
name|pred
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Predicate
operator|>
name|binary_negate
operator|<
name|Predicate
operator|>
name|not2
argument_list|(
argument|const Predicate& pred
argument_list|)
block|{
return|return
name|binary_negate
operator|<
name|Predicate
operator|>
operator|(
name|pred
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Operation
operator|>
name|class
name|binder1st
operator|:
name|public
name|unary_function
operator|<
name|Operation
operator|::
name|second_argument_type
operator|,
name|Operation
operator|::
name|result_type
operator|>
block|{
name|protected
operator|:
name|Operation
name|op
block|;
name|Operation
operator|::
name|first_argument_type
name|value
block|;
name|public
operator|:
name|binder1st
argument_list|(
specifier|const
name|Operation
operator|&
name|x
argument_list|,
specifier|const
name|Operation
operator|::
name|first_argument_type
operator|&
name|y
argument_list|)
operator|:
name|op
argument_list|(
name|x
argument_list|)
block|,
name|value
argument_list|(
argument|y
argument_list|)
block|{}
name|result_type
name|operator
argument_list|()
operator|(
specifier|const
name|argument_type
operator|&
name|x
operator|)
specifier|const
block|{
return|return
name|op
argument_list|(
name|value
argument_list|,
name|x
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Operation
operator|,
name|class
name|T
operator|>
name|binder1st
operator|<
name|Operation
operator|>
name|bind1st
argument_list|(
argument|const Operation& op
argument_list|,
argument|const T& x
argument_list|)
block|{
return|return
name|binder1st
operator|<
name|Operation
operator|>
operator|(
name|op
operator|,
name|Operation
operator|::
name|first_argument_type
argument_list|(
name|x
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Operation
operator|>
name|class
name|binder2nd
operator|:
name|public
name|unary_function
operator|<
name|Operation
operator|::
name|first_argument_type
operator|,
name|Operation
operator|::
name|result_type
operator|>
block|{
name|protected
operator|:
name|Operation
name|op
block|;
name|Operation
operator|::
name|second_argument_type
name|value
block|;
name|public
operator|:
name|binder2nd
argument_list|(
specifier|const
name|Operation
operator|&
name|x
argument_list|,
specifier|const
name|Operation
operator|::
name|second_argument_type
operator|&
name|y
argument_list|)
operator|:
name|op
argument_list|(
name|x
argument_list|)
block|,
name|value
argument_list|(
argument|y
argument_list|)
block|{}
name|result_type
name|operator
argument_list|()
operator|(
specifier|const
name|argument_type
operator|&
name|x
operator|)
specifier|const
block|{
return|return
name|op
argument_list|(
name|x
argument_list|,
name|value
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Operation
operator|,
name|class
name|T
operator|>
name|binder2nd
operator|<
name|Operation
operator|>
name|bind2nd
argument_list|(
argument|const Operation& op
argument_list|,
argument|const T& x
argument_list|)
block|{
return|return
name|binder2nd
operator|<
name|Operation
operator|>
operator|(
name|op
operator|,
name|Operation
operator|::
name|second_argument_type
argument_list|(
name|x
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Operation1
operator|,
name|class
name|Operation2
operator|>
name|class
name|unary_compose
operator|:
name|public
name|unary_function
operator|<
name|Operation2
operator|::
name|argument_type
operator|,
name|Operation1
operator|::
name|result_type
operator|>
block|{
name|protected
operator|:
name|Operation1
name|op1
block|;
name|Operation2
name|op2
block|;
name|public
operator|:
name|unary_compose
argument_list|(
specifier|const
name|Operation1
operator|&
name|x
argument_list|,
specifier|const
name|Operation2
operator|&
name|y
argument_list|)
operator|:
name|op1
argument_list|(
name|x
argument_list|)
block|,
name|op2
argument_list|(
argument|y
argument_list|)
block|{}
name|result_type
name|operator
argument_list|()
operator|(
specifier|const
name|argument_type
operator|&
name|x
operator|)
specifier|const
block|{
return|return
name|op1
argument_list|(
name|op2
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Operation1
operator|,
name|class
name|Operation2
operator|>
name|unary_compose
operator|<
name|Operation1
operator|,
name|Operation2
operator|>
name|compose1
argument_list|(
argument|const Operation1& op1
argument_list|,
argument|const Operation2& op2
argument_list|)
block|{
return|return
name|unary_compose
operator|<
name|Operation1
operator|,
name|Operation2
operator|>
operator|(
name|op1
operator|,
name|op2
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Operation1
operator|,
name|class
name|Operation2
operator|,
name|class
name|Operation3
operator|>
name|class
name|binary_compose
operator|:
name|public
name|unary_function
operator|<
name|Operation2
operator|::
name|argument_type
operator|,
name|Operation1
operator|::
name|result_type
operator|>
block|{
name|protected
operator|:
name|Operation1
name|op1
block|;
name|Operation2
name|op2
block|;
name|Operation3
name|op3
block|;
name|public
operator|:
name|binary_compose
argument_list|(
specifier|const
name|Operation1
operator|&
name|x
argument_list|,
specifier|const
name|Operation2
operator|&
name|y
argument_list|,
specifier|const
name|Operation3
operator|&
name|z
argument_list|)
operator|:
name|op1
argument_list|(
name|x
argument_list|)
block|,
name|op2
argument_list|(
name|y
argument_list|)
block|,
name|op3
argument_list|(
argument|z
argument_list|)
block|{ }
name|result_type
name|operator
argument_list|()
operator|(
specifier|const
name|argument_type
operator|&
name|x
operator|)
specifier|const
block|{
return|return
name|op1
argument_list|(
name|op2
argument_list|(
name|x
argument_list|)
argument_list|,
name|op3
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Operation1
operator|,
name|class
name|Operation2
operator|,
name|class
name|Operation3
operator|>
name|binary_compose
operator|<
name|Operation1
operator|,
name|Operation2
operator|,
name|Operation3
operator|>
name|compose2
argument_list|(
argument|const Operation1& op1
argument_list|,
argument|const Operation2& op2
argument_list|,
argument|const Operation3& op3
argument_list|)
block|{
return|return
name|binary_compose
operator|<
name|Operation1
operator|,
name|Operation2
operator|,
name|Operation3
operator|>
operator|(
name|op1
operator|,
name|op2
operator|,
name|op3
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Arg
operator|,
name|class
name|Result
operator|>
name|class
name|pointer_to_unary_function
operator|:
name|public
name|unary_function
operator|<
name|Arg
operator|,
name|Result
operator|>
block|{
name|protected
operator|:
name|Result
argument_list|(
operator|*
name|ptr
argument_list|)
argument_list|(
name|Arg
argument_list|)
block|;
name|public
operator|:
name|pointer_to_unary_function
argument_list|()
block|{}
name|pointer_to_unary_function
argument_list|(
name|Result
argument_list|(
operator|*
name|x
argument_list|)
argument_list|(
name|Arg
argument_list|)
argument_list|)
operator|:
name|ptr
argument_list|(
argument|x
argument_list|)
block|{}
name|Result
name|operator
argument_list|()
operator|(
name|Arg
name|x
operator|)
specifier|const
block|{
return|return
name|ptr
argument_list|(
name|x
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Arg
operator|,
name|class
name|Result
operator|>
name|pointer_to_unary_function
operator|<
name|Arg
operator|,
name|Result
operator|>
name|ptr_fun
argument_list|(
argument|Result (*x)(Arg)
argument_list|)
block|{
return|return
name|pointer_to_unary_function
operator|<
name|Arg
operator|,
name|Result
operator|>
operator|(
name|x
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Arg1
operator|,
name|class
name|Arg2
operator|,
name|class
name|Result
operator|>
name|class
name|pointer_to_binary_function
operator|:
name|public
name|binary_function
operator|<
name|Arg1
operator|,
name|Arg2
operator|,
name|Result
operator|>
block|{
name|protected
operator|:
name|Result
argument_list|(
operator|*
name|ptr
argument_list|)
argument_list|(
name|Arg1
argument_list|,
name|Arg2
argument_list|)
block|;
name|public
operator|:
name|pointer_to_binary_function
argument_list|()
block|{}
name|pointer_to_binary_function
argument_list|(
name|Result
argument_list|(
operator|*
name|x
argument_list|)
argument_list|(
name|Arg1
argument_list|,
name|Arg2
argument_list|)
argument_list|)
operator|:
name|ptr
argument_list|(
argument|x
argument_list|)
block|{}
name|Result
name|operator
argument_list|()
operator|(
name|Arg1
name|x
operator|,
name|Arg2
name|y
operator|)
specifier|const
block|{
return|return
name|ptr
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Arg1
operator|,
name|class
name|Arg2
operator|,
name|class
name|Result
operator|>
name|pointer_to_binary_function
operator|<
name|Arg1
operator|,
name|Arg2
operator|,
name|Result
operator|>
name|ptr_fun
argument_list|(
argument|Result (*x)(Arg1, Arg2)
argument_list|)
block|{
return|return
name|pointer_to_binary_function
operator|<
name|Arg1
operator|,
name|Arg2
operator|,
name|Result
operator|>
operator|(
name|x
operator|)
return|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

