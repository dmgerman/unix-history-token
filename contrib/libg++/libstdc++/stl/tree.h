begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * Copyright (c) 1994  * Hewlett-Packard Company  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Hewlett-Packard Company makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TREE_H
end_ifndef

begin_define
define|#
directive|define
name|TREE_H
end_define

begin_comment
comment|/*  Red-black tree class, designed for use in implementing STL associative containers (set, multiset, map, and multimap). The insertion and deletion algorithms are based on those in Cormen, Leiserson, and Rivest, Introduction to Algorithms (MIT Press, 1990), except that  (1) the header cell is maintained with links not only to the root but also to the leftmost node of the tree, to enable constant time begin(), and to the rightmost node of the tree, to enable linear time performance when used with the generic set algorithms (set_union, etc.);  (2) when a node being deleted has two children its successor node is relinked into its place, rather than copied, so that the only iterators invalidated are those referring to the deleted node.  */
end_comment

begin_include
include|#
directive|include
file|<algobase.h>
end_include

begin_include
include|#
directive|include
file|<iterator.h>
end_include

begin_include
include|#
directive|include
file|<function.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__GNUG__
end_ifndef

begin_include
include|#
directive|include
file|<bool.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<projectn.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|rb_tree
end_ifndef

begin_define
define|#
directive|define
name|rb_tree
value|rb_tree
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_enum
enum|enum
name|__rb_color_type
block|{
name|red
block|,
name|black
block|}
enum|;
end_enum

begin_struct
struct|struct
name|__rb_tree_node_base
block|{
name|enum
name|__rb_color_type
name|color_field
decl_stmt|;
name|void
modifier|*
name|parent_link
decl_stmt|;
name|void
modifier|*
name|left_link
decl_stmt|;
name|void
modifier|*
name|right_link
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|__rb_tree_node_base
name|__rb_NIL
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
name|class
name|rb_tree
block|{
name|protected
operator|:
typedef|typedef
name|enum
name|__rb_color_type
name|color_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|Allocator
operator|<
name|void
operator|>
operator|::
name|pointer
name|void_pointer
expr_stmt|;
end_typedef

begin_struct_decl
struct_decl|struct
name|rb_tree_node
struct_decl|;
end_struct_decl

begin_decl_stmt
name|friend
name|rb_tree_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rb_tree_node
range|:
name|public
name|__rb_tree_node_base
block|{
name|Value
name|value_field
block|;     }
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|__GNUG__
end_ifndef

begin_expr_stmt
specifier|static
name|Allocator
operator|<
name|rb_tree_node
operator|>
name|rb_tree_node_allocator
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|Allocator
operator|<
name|Value
operator|>
name|value_allocator
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_label
name|public
label|:
end_label

begin_typedef
typedef|typedef
name|Key
name|key_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|Value
name|value_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|Allocator
operator|<
name|Value
operator|>
operator|::
name|pointer
name|pointer
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Allocator
operator|<
name|Value
operator|>
operator|::
name|reference
name|reference
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Allocator
operator|<
name|Value
operator|>
operator|::
name|const_reference
name|const_reference
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Allocator
operator|<
name|rb_tree_node
operator|>
name|rb_tree_node_allocator_type
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Allocator
operator|<
name|rb_tree_node
operator|>
operator|::
name|pointer
name|link_type
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Allocator
operator|<
name|rb_tree_node
operator|>
operator|::
name|size_type
name|size_type
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Allocator
operator|<
name|rb_tree_node
operator|>
operator|::
name|difference_type
name|difference_type
expr_stmt|;
end_typedef

begin_label
name|protected
label|:
end_label

begin_ifndef
ifndef|#
directive|ifndef
name|__GNUG__
end_ifndef

begin_function
name|size_type
name|buffer_size
parameter_list|()
block|{
return|return
name|rb_tree_node_allocator
operator|.
name|init_page_size
argument_list|()
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_struct_decl
struct_decl|struct
name|rb_tree_node_buffer
struct_decl|;
end_struct_decl

begin_decl_stmt
name|friend
name|rb_tree_node_buffer
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|rb_tree_node_buffer
block|{
name|void_pointer
name|next_buffer
decl_stmt|;
name|link_type
name|buffer
decl_stmt|;
block|}
struct|;
end_struct

begin_label
name|public
label|:
end_label

begin_typedef
typedef|typedef
name|Allocator
operator|<
name|rb_tree_node_buffer
operator|>
name|buffer_allocator_type
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Allocator
operator|<
name|rb_tree_node_buffer
operator|>
operator|::
name|pointer
name|buffer_pointer
expr_stmt|;
end_typedef

begin_label
name|protected
label|:
end_label

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUG__
end_ifdef

begin_expr_stmt
specifier|static
name|Allocator
operator|<
name|rb_tree_node_buffer
operator|>
name|buffer_allocator
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|buffer_pointer
name|buffer_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|link_type
name|free_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|link_type
name|next_avail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|link_type
name|last
decl_stmt|;
end_decl_stmt

begin_function
name|link_type
name|get_node
parameter_list|()
block|{
return|return
operator|(
name|link_type
operator|)
name|operator
name|new
argument_list|(
sizeof|sizeof
argument_list|(
name|rb_tree_node
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|put_node
parameter_list|(
name|link_type
name|p
parameter_list|)
block|{
name|operator
name|delete
argument_list|(
name|p
argument_list|)
decl_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|add_new_buffer
parameter_list|()
block|{
name|buffer_pointer
name|tmp
init|=
name|buffer_allocator
operator|.
name|allocate
argument_list|(
operator|(
name|size_type
operator|)
literal|1
argument_list|)
decl_stmt|;
name|tmp
operator|->
name|buffer
operator|=
name|rb_tree_node_allocator
operator|.
name|allocate
argument_list|(
name|buffer_size
argument_list|()
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|next_buffer
operator|=
name|buffer_list
expr_stmt|;
name|buffer_list
operator|=
name|tmp
expr_stmt|;
name|next_avail
operator|=
name|buffer_list
operator|->
name|buffer
expr_stmt|;
name|last
operator|=
name|next_avail
operator|+
name|buffer_size
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|size_type
name|number_of_trees
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|deallocate_buffers
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|link_type
name|get_node
parameter_list|()
block|{
name|link_type
name|tmp
init|=
name|free_list
decl_stmt|;
return|return
name|free_list
condition|?
operator|(
name|free_list
operator|=
call|(
name|link_type
call|)
argument_list|(
name|free_list
operator|->
name|right_link
argument_list|)
operator|,
name|tmp
operator|)
else|:
operator|(
name|next_avail
operator|==
name|last
condition|?
operator|(
name|add_new_buffer
argument_list|()
operator|,
name|next_avail
operator|++
operator|)
else|:
name|next_avail
operator|++
operator|)
return|;
comment|// ugly code for inlining - avoids multiple returns
block|}
end_function

begin_function
name|void
name|put_node
parameter_list|(
name|link_type
name|p
parameter_list|)
block|{
name|p
operator|->
name|right_link
operator|=
name|free_list
expr_stmt|;
name|free_list
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_label
name|protected
label|:
end_label

begin_decl_stmt
name|link_type
name|header
decl_stmt|;
end_decl_stmt

begin_function
name|link_type
modifier|&
name|root
parameter_list|()
block|{
return|return
name|parent
argument_list|(
name|header
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|link_type
operator|&
name|root
argument_list|()
specifier|const
block|{
return|return
name|parent
argument_list|(
name|header
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|link_type
modifier|&
name|leftmost
parameter_list|()
block|{
return|return
name|left
argument_list|(
name|header
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|link_type
operator|&
name|leftmost
argument_list|()
specifier|const
block|{
return|return
name|left
argument_list|(
name|header
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|link_type
modifier|&
name|rightmost
parameter_list|()
block|{
return|return
name|right
argument_list|(
name|header
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|link_type
operator|&
name|rightmost
argument_list|()
specifier|const
block|{
return|return
name|right
argument_list|(
name|header
argument_list|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|size_type
name|node_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|// keeps track of size of tree
end_comment

begin_decl_stmt
name|bool
name|insert_always
decl_stmt|;
end_decl_stmt

begin_comment
comment|// controls whether an element already in the
end_comment

begin_comment
comment|// tree is inserted again
end_comment

begin_comment
comment|//public:
end_comment

begin_decl_stmt
name|Compare
name|key_compare
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|link_type
modifier|&
name|left
parameter_list|(
name|link_type
name|x
parameter_list|)
block|{
return|return
operator|(
name|link_type
operator|&
operator|)
operator|(
operator|(
operator|*
name|x
operator|)
operator|.
name|left_link
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|link_type
modifier|&
name|right
parameter_list|(
name|link_type
name|x
parameter_list|)
block|{
return|return
operator|(
name|link_type
operator|&
operator|)
operator|(
operator|(
operator|*
name|x
operator|)
operator|.
name|right_link
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|link_type
modifier|&
name|parent
parameter_list|(
name|link_type
name|x
parameter_list|)
block|{
return|return
operator|(
name|link_type
operator|&
operator|)
operator|(
operator|(
operator|*
name|x
operator|)
operator|.
name|parent_link
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|reference
name|value
parameter_list|(
name|link_type
name|x
parameter_list|)
block|{
return|return
operator|(
operator|*
name|x
operator|)
operator|.
name|value_field
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|Allocator
operator|<
name|Key
operator|>
operator|::
name|const_reference
name|key
argument_list|(
argument|link_type x
argument_list|)
block|{
return|return
name|KeyOfValue
argument_list|()
argument_list|(
name|value
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|color_type
modifier|&
name|color
parameter_list|(
name|link_type
name|x
parameter_list|)
block|{
return|return
operator|(
name|color_type
operator|&
operator|)
operator|(
operator|*
name|x
operator|)
operator|.
name|color_field
return|;
block|}
end_function

begin_function
specifier|static
name|link_type
name|minimum
parameter_list|(
name|link_type
name|x
parameter_list|)
block|{
while|while
condition|(
name|left
argument_list|(
name|x
argument_list|)
operator|!=
operator|&
name|__rb_NIL
condition|)
name|x
operator|=
name|left
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_function
specifier|static
name|link_type
name|maximum
parameter_list|(
name|link_type
name|x
parameter_list|)
block|{
while|while
condition|(
name|right
argument_list|(
name|x
argument_list|)
operator|!=
operator|&
name|__rb_NIL
condition|)
name|x
operator|=
name|right
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_label
name|public
label|:
end_label

begin_decl_stmt
name|class
name|iterator
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|friend
name|iterator
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|class
name|const_iterator
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|friend
name|const_iterator
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|class
name|iterator
range|:
name|public
name|bidirectional_iterator
operator|<
name|Value
decl_stmt|,
name|difference_type
decl|>
block|{
name|friend
name|class
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
expr_stmt|;
name|friend
name|class
name|const_iterator
decl_stmt|;
comment|/*           friend bool operator==(const iterator& x, const iterator& y) {         return x.node == y.node;     } */
name|protected
label|:
name|link_type
name|node
decl_stmt|;
name|iterator
argument_list|(
argument|link_type x
argument_list|)
block|:
name|node
argument_list|(
argument|x
argument_list|)
block|{}
name|public
label|:
name|iterator
argument_list|()
block|{}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|iterator
operator|&
name|y
operator|)
specifier|const
block|{
return|return
name|node
operator|==
name|y
operator|.
name|node
return|;
block|}
name|reference
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|value
argument_list|(
name|node
argument_list|)
return|;
block|}
name|iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
if|if
condition|(
name|right
argument_list|(
name|node
argument_list|)
operator|!=
operator|&
name|__rb_NIL
condition|)
block|{
name|node
operator|=
name|right
argument_list|(
name|node
argument_list|)
expr_stmt|;
while|while
condition|(
name|left
argument_list|(
name|node
argument_list|)
operator|!=
operator|&
name|__rb_NIL
condition|)
name|node
operator|=
name|left
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|link_type
name|y
init|=
name|parent
argument_list|(
name|node
argument_list|)
decl_stmt|;
while|while
condition|(
name|node
operator|==
name|right
argument_list|(
name|y
argument_list|)
condition|)
block|{
name|node
operator|=
name|y
expr_stmt|;
name|y
operator|=
name|parent
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|right
argument_list|(
name|node
argument_list|)
operator|!=
name|y
condition|)
comment|// necessary because of rightmost
name|node
operator|=
name|y
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
name|iterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
name|iterator
name|tmp
operator|=
operator|*
name|this
block|;
operator|++
operator|*
name|this
block|;
return|return
name|tmp
return|;
block|}
name|iterator
operator|&
name|operator
operator|--
operator|(
operator|)
block|{
if|if
condition|(
name|color
argument_list|(
name|node
argument_list|)
operator|==
name|red
operator|&&
name|parent
argument_list|(
name|parent
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
name|node
condition|)
comment|// check for header
name|node
operator|=
name|right
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|// return rightmost
elseif|else
if|if
condition|(
name|left
argument_list|(
name|node
argument_list|)
operator|!=
operator|&
name|__rb_NIL
condition|)
block|{
name|link_type
name|y
init|=
name|left
argument_list|(
name|node
argument_list|)
decl_stmt|;
while|while
condition|(
name|right
argument_list|(
name|y
argument_list|)
operator|!=
operator|&
name|__rb_NIL
condition|)
name|y
operator|=
name|right
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|node
operator|=
name|y
expr_stmt|;
block|}
else|else
block|{
name|link_type
name|y
init|=
name|parent
argument_list|(
name|node
argument_list|)
decl_stmt|;
while|while
condition|(
name|node
operator|==
name|left
argument_list|(
name|y
argument_list|)
condition|)
block|{
name|node
operator|=
name|y
expr_stmt|;
name|y
operator|=
name|parent
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
name|node
operator|=
name|y
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
name|iterator
name|operator
operator|--
operator|(
name|int
operator|)
block|{
name|iterator
name|tmp
operator|=
operator|*
name|this
block|;
operator|--
operator|*
name|this
block|;
return|return
name|tmp
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|const_iterator
range|:
name|public
name|bidirectional_iterator
operator|<
name|Value
decl_stmt|,
name|difference_type
decl|>
block|{
name|friend
name|class
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
expr_stmt|;
name|friend
name|class
name|iterator
decl_stmt|;
comment|/*           friend bool operator==(const const_iterator& x, const const_iterator& y) {         return x.node == y.node;     } */
name|protected
label|:
name|link_type
name|node
decl_stmt|;
name|const_iterator
argument_list|(
argument|link_type x
argument_list|)
block|:
name|node
argument_list|(
argument|x
argument_list|)
block|{}
name|public
label|:
name|const_iterator
argument_list|()
block|{}
name|const_iterator
argument_list|(
specifier|const
name|iterator
operator|&
name|x
argument_list|)
operator|:
name|node
argument_list|(
argument|x.node
argument_list|)
block|{}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|const_iterator
operator|&
name|y
operator|)
specifier|const
block|{
return|return
name|node
operator|==
name|y
operator|.
name|node
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|const_iterator
operator|&
name|y
operator|)
specifier|const
block|{
return|return
name|node
operator|!=
name|y
operator|.
name|node
return|;
block|}
name|const_reference
name|operator
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|value
argument_list|(
name|node
argument_list|)
return|;
block|}
name|const_iterator
operator|&
name|operator
operator|++
operator|(
operator|)
block|{
if|if
condition|(
name|right
argument_list|(
name|node
argument_list|)
operator|!=
operator|&
name|__rb_NIL
condition|)
block|{
name|node
operator|=
name|right
argument_list|(
name|node
argument_list|)
expr_stmt|;
while|while
condition|(
name|left
argument_list|(
name|node
argument_list|)
operator|!=
operator|&
name|__rb_NIL
condition|)
name|node
operator|=
name|left
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|link_type
name|y
init|=
name|parent
argument_list|(
name|node
argument_list|)
decl_stmt|;
while|while
condition|(
name|node
operator|==
name|right
argument_list|(
name|y
argument_list|)
condition|)
block|{
name|node
operator|=
name|y
expr_stmt|;
name|y
operator|=
name|parent
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|right
argument_list|(
name|node
argument_list|)
operator|!=
name|y
condition|)
comment|// necessary because of rightmost
name|node
operator|=
name|y
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
name|const_iterator
name|operator
operator|++
operator|(
name|int
operator|)
block|{
name|const_iterator
name|tmp
operator|=
operator|*
name|this
block|;
operator|++
operator|*
name|this
block|;
return|return
name|tmp
return|;
block|}
name|const_iterator
operator|&
name|operator
operator|--
operator|(
operator|)
block|{
if|if
condition|(
name|color
argument_list|(
name|node
argument_list|)
operator|==
name|red
operator|&&
name|parent
argument_list|(
name|parent
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
name|node
condition|)
comment|// check for header
name|node
operator|=
name|right
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|// return rightmost
elseif|else
if|if
condition|(
name|left
argument_list|(
name|node
argument_list|)
operator|!=
operator|&
name|__rb_NIL
condition|)
block|{
name|link_type
name|y
init|=
name|left
argument_list|(
name|node
argument_list|)
decl_stmt|;
while|while
condition|(
name|right
argument_list|(
name|y
argument_list|)
operator|!=
operator|&
name|__rb_NIL
condition|)
name|y
operator|=
name|right
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|node
operator|=
name|y
expr_stmt|;
block|}
else|else
block|{
name|link_type
name|y
init|=
name|parent
argument_list|(
name|node
argument_list|)
decl_stmt|;
while|while
condition|(
name|node
operator|==
name|left
argument_list|(
name|y
argument_list|)
condition|)
block|{
name|node
operator|=
name|y
expr_stmt|;
name|y
operator|=
name|parent
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
name|node
operator|=
name|y
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
name|const_iterator
name|operator
operator|--
operator|(
name|int
operator|)
block|{
name|const_iterator
name|tmp
operator|=
operator|*
name|this
block|;
operator|--
operator|*
name|this
block|;
return|return
name|tmp
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_typedef
typedef|typedef
name|reverse_bidirectional_iterator
operator|<
name|iterator
operator|,
name|value_type
operator|,
name|reference
operator|,
name|difference_type
operator|>
name|reverse_iterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|reverse_bidirectional_iterator
operator|<
name|const_iterator
operator|,
name|value_type
operator|,
name|const_reference
operator|,
name|difference_type
operator|>
name|const_reverse_iterator
expr_stmt|;
end_typedef

begin_label
name|private
label|:
end_label

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_expr_stmt
name|rb_tree_iterator
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
name|__insert
argument_list|(
name|void
operator|*
name|x
argument_list|,
name|void
operator|*
name|y
argument_list|,
specifier|const
name|value_type
operator|&
name|v
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|link_type
name|__copy
parameter_list|(
name|link_type
name|x
parameter_list|,
name|link_type
name|p
parameter_list|)
block|{
return|return
operator|(
name|link_type
operator|)
name|__copy_hack
argument_list|(
name|x
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_function_decl
name|void
modifier|*
name|__copy_hack
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_label
name|public
label|:
end_label

begin_function_decl
name|void
name|__erase
parameter_list|(
name|void
modifier|*
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
name|iterator
name|__insert
parameter_list|(
name|link_type
name|x
parameter_list|,
name|link_type
name|y
parameter_list|,
specifier|const
name|value_type
modifier|&
name|v
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|link_type
name|__copy
parameter_list|(
name|link_type
name|x
parameter_list|,
name|link_type
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__erase
parameter_list|(
name|link_type
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|init
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|__GNUG__
operator|++
name|number_of_trees
expr_stmt|;
endif|#
directive|endif
name|header
operator|=
name|get_node
argument_list|()
expr_stmt|;
name|color
argument_list|(
name|header
argument_list|)
operator|=
name|red
expr_stmt|;
comment|// used to distinguish header from root,
comment|// in iterator.operator++
name|header
operator|->
name|parent_link
operator|=
operator|&
name|__rb_NIL
expr_stmt|;
name|leftmost
argument_list|()
operator|=
name|header
expr_stmt|;
name|rightmost
argument_list|()
operator|=
name|header
expr_stmt|;
block|}
end_function

begin_label
name|public
label|:
end_label

begin_comment
comment|// allocation/deallocation
end_comment

begin_macro
name|rb_tree
argument_list|(
argument|const Compare& comp = Compare()
argument_list|,
argument|bool always = true
argument_list|)
end_macro

begin_expr_stmt
unit|:
name|node_count
argument_list|(
literal|0
argument_list|)
operator|,
name|insert_always
argument_list|(
name|always
argument_list|)
operator|,
name|key_compare
argument_list|(
argument|comp
argument_list|)
block|{
name|init
argument_list|()
block|;     }
name|rb_tree
argument_list|(
argument|const value_type* first
argument_list|,
argument|const value_type* last
argument_list|,
argument|const Compare& comp = Compare()
argument_list|,
argument|bool always = true
argument_list|)
operator|:
name|node_count
argument_list|(
literal|0
argument_list|)
operator|,
name|insert_always
argument_list|(
name|always
argument_list|)
operator|,
name|key_compare
argument_list|(
argument|comp
argument_list|)
block|{
name|init
argument_list|()
block|;
name|insert
argument_list|(
name|first
argument_list|,
name|last
argument_list|)
block|;     }
name|rb_tree
argument_list|(
argument|const rb_tree<Key
argument_list|,
argument|Value
argument_list|,
argument|KeyOfValue
argument_list|,
argument|Compare>& x
argument_list|,
argument|bool always = true
argument_list|)
operator|:
name|node_count
argument_list|(
name|x
operator|.
name|node_count
argument_list|)
operator|,
name|insert_always
argument_list|(
name|always
argument_list|)
operator|,
name|key_compare
argument_list|(
argument|x.key_compare
argument_list|)
block|{
ifndef|#
directive|ifndef
name|__GNUG__
operator|++
name|number_of_trees
block|;
endif|#
directive|endif
name|header
operator|=
name|get_node
argument_list|()
block|;
name|color
argument_list|(
name|header
argument_list|)
operator|=
name|red
block|;
name|root
argument_list|()
operator|=
name|__copy
argument_list|(
name|x
operator|.
name|root
argument_list|()
argument_list|,
name|header
argument_list|)
block|;
if|if
condition|(
name|root
argument_list|()
operator|==
operator|&
name|__rb_NIL
condition|)
block|{
name|leftmost
argument_list|()
operator|=
name|header
expr_stmt|;
name|rightmost
argument_list|()
operator|=
name|header
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|leftmost
argument_list|()
operator|=
name|minimum
argument_list|(
name|root
argument_list|()
argument_list|)
expr_stmt|;
name|rightmost
argument_list|()
operator|=
name|maximum
argument_list|(
name|root
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_else

begin_macro
unit|}     ~
name|rb_tree
argument_list|()
end_macro

begin_block
block|{
name|erase
argument_list|(
name|begin
argument_list|()
argument_list|,
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|put_node
argument_list|(
name|header
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__GNUG__
if|if
condition|(
operator|--
name|number_of_trees
operator|==
literal|0
condition|)
block|{
name|deallocate_buffers
argument_list|()
expr_stmt|;
name|free_list
operator|=
literal|0
expr_stmt|;
name|next_avail
operator|=
literal|0
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_expr_stmt
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|&
name|operator
operator|=
operator|(
specifier|const
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|&
name|x
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// accessors:
end_comment

begin_expr_stmt
name|Compare
name|key_comp
argument_list|()
specifier|const
block|{
return|return
name|key_compare
return|;
block|}
end_expr_stmt

begin_function
name|iterator
name|begin
parameter_list|()
block|{
return|return
name|leftmost
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
name|const_iterator
name|begin
argument_list|()
specifier|const
block|{
return|return
name|leftmost
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
name|iterator
name|end
parameter_list|()
block|{
return|return
name|header
return|;
block|}
end_function

begin_expr_stmt
name|const_iterator
name|end
argument_list|()
specifier|const
block|{
return|return
name|header
return|;
block|}
end_expr_stmt

begin_function
name|reverse_iterator
name|rbegin
parameter_list|()
block|{
return|return
name|reverse_iterator
argument_list|(
name|end
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|const_reverse_iterator
name|rbegin
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
argument_list|(
name|end
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|reverse_iterator
name|rend
parameter_list|()
block|{
return|return
name|reverse_iterator
argument_list|(
name|begin
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|const_reverse_iterator
name|rend
argument_list|()
specifier|const
block|{
return|return
name|const_reverse_iterator
argument_list|(
name|begin
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|node_count
operator|==
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|size_type
name|size
argument_list|()
specifier|const
block|{
return|return
name|node_count
return|;
block|}
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|__GNUG__
end_ifndef

begin_expr_stmt
name|size_type
name|max_size
argument_list|()
specifier|const
block|{
return|return
name|rb_tree_node_allocator
operator|.
name|max_size
argument_list|()
return|;
block|}
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|size_type
name|max_size
argument_list|()
specifier|const
block|{
return|return
name|rb_tree_node_allocator_type
operator|::
name|max_size
argument_list|()
return|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|void
name|swap
argument_list|(
name|rb_tree
operator|<
name|Key
argument_list|,
name|Value
argument_list|,
name|KeyOfValue
argument_list|,
name|Compare
operator|>
operator|&
name|t
argument_list|)
block|{
operator|::
name|swap
argument_list|(
name|header
argument_list|,
name|t
operator|.
name|header
argument_list|)
expr_stmt|;
operator|::
name|swap
argument_list|(
name|node_count
argument_list|,
name|t
operator|.
name|node_count
argument_list|)
expr_stmt|;
operator|::
name|swap
argument_list|(
name|insert_always
argument_list|,
name|t
operator|.
name|insert_always
argument_list|)
expr_stmt|;
operator|::
name|swap
argument_list|(
name|key_compare
argument_list|,
name|t
operator|.
name|key_compare
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// insert/erase
end_comment

begin_typedef
typedef|typedef
name|pair
operator|<
name|iterator
operator|,
name|bool
operator|>
name|pair_iterator_bool
expr_stmt|;
end_typedef

begin_comment
comment|// typedef done to get around compiler bug
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUG__
end_ifdef

begin_function
name|pair_iterator_bool
name|insert
parameter_list|(
specifier|const
name|value_type
modifier|&
name|x
parameter_list|)
block|{
return|return
name|insert_hack
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_expr_stmt
name|rb_tree_pair_iterator_bool
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
name|insert_hack
argument_list|(
specifier|const
name|Value
operator|&
name|v
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_function
name|iterator
name|insert
parameter_list|(
name|iterator
name|position
parameter_list|,
specifier|const
name|value_type
modifier|&
name|x
parameter_list|)
block|{
return|return
name|insert_hack
argument_list|(
name|position
argument_list|,
name|x
argument_list|)
return|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_expr_stmt
name|rb_tree_iterator
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
name|insert_hack
argument_list|(
name|rb_tree_iterator
operator|<
name|Key
argument_list|,
name|Value
argument_list|,
name|KeyOfValue
argument_list|,
name|Compare
operator|>
name|posn
argument_list|,
specifier|const
name|Value
operator|&
name|v
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_function
name|void
name|insert
parameter_list|(
name|iterator
name|first
parameter_list|,
name|iterator
name|last
parameter_list|)
block|{
while|while
condition|(
name|first
operator|!=
name|last
condition|)
name|insert
argument_list|(
operator|*
name|first
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|insert
parameter_list|(
specifier|const
name|value_type
modifier|*
name|first
parameter_list|,
specifier|const
name|value_type
modifier|*
name|last
parameter_list|)
block|{
while|while
condition|(
name|first
operator|!=
name|last
condition|)
name|insert
argument_list|(
operator|*
name|first
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|erase
parameter_list|(
name|iterator
name|position
parameter_list|)
block|{
name|erase_hack
argument_list|(
name|position
argument_list|)
expr_stmt|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|void
name|erase_hack
argument_list|(
name|rb_tree_iterator
operator|<
name|Key
argument_list|,
name|Value
argument_list|,
name|KeyOfValue
argument_list|,
name|Compare
operator|>
name|position
argument_list|)
decl_stmt|;
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_function_decl
name|size_type
name|erase
parameter_list|(
specifier|const
name|key_type
modifier|&
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|erase
parameter_list|(
name|iterator
name|first
parameter_list|,
name|iterator
name|last
parameter_list|)
block|{
while|while
condition|(
name|first
operator|!=
name|last
condition|)
name|erase
argument_list|(
name|first
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function_decl
name|pair_iterator_bool
name|insert
parameter_list|(
specifier|const
name|value_type
modifier|&
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|iterator
name|insert
parameter_list|(
name|iterator
name|position
parameter_list|,
specifier|const
name|value_type
modifier|&
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|insert
parameter_list|(
name|iterator
name|first
parameter_list|,
name|iterator
name|last
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|insert
parameter_list|(
specifier|const
name|value_type
modifier|*
name|first
parameter_list|,
specifier|const
name|value_type
modifier|*
name|last
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|erase
parameter_list|(
name|iterator
name|position
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|size_type
name|erase
parameter_list|(
specifier|const
name|key_type
modifier|&
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|erase
parameter_list|(
name|iterator
name|first
parameter_list|,
name|iterator
name|last
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|erase
parameter_list|(
specifier|const
name|key_type
modifier|*
name|first
parameter_list|,
specifier|const
name|key_type
modifier|*
name|last
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// set operations:
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUG__
end_ifdef

begin_function
name|iterator
name|find
parameter_list|(
specifier|const
name|key_type
modifier|&
name|x
parameter_list|)
block|{
return|return
name|find_hack
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|const_iterator
name|find
argument_list|(
specifier|const
name|key_type
operator|&
name|x
argument_list|)
decl|const
block|{
return|return
name|find_hack
argument_list|(
name|x
argument_list|)
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_expr_stmt
name|rb_tree_iterator
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
name|find_hack
argument_list|(
specifier|const
name|key_type
operator|&
name|x
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|rb_tree_const_iterator
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
name|find_hack
argument_list|(
argument|const Key& k
argument_list|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_decl_stmt
name|size_type
name|count
argument_list|(
specifier|const
name|key_type
operator|&
name|x
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_function
name|iterator
name|lower_bound
parameter_list|(
specifier|const
name|key_type
modifier|&
name|x
parameter_list|)
block|{
return|return
name|lower_bound_hack
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|const_iterator
name|lower_bound
argument_list|(
specifier|const
name|key_type
operator|&
name|x
argument_list|)
decl|const
block|{
return|return
name|lower_bound_hack
argument_list|(
name|x
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
name|iterator
name|upper_bound
parameter_list|(
specifier|const
name|key_type
modifier|&
name|x
parameter_list|)
block|{
return|return
name|upper_bound_hack
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|const_iterator
name|upper_bound
argument_list|(
specifier|const
name|key_type
operator|&
name|x
argument_list|)
decl|const
block|{
return|return
name|upper_bound_hack
argument_list|(
name|x
argument_list|)
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_expr_stmt
name|rb_tree_iterator
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
name|lower_bound_hack
argument_list|(
specifier|const
name|key_type
operator|&
name|x
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|rb_tree_const_iterator
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
name|lower_bound_hack
argument_list|(
argument|const Key& k
argument_list|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|rb_tree_iterator
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
name|upper_bound_hack
argument_list|(
specifier|const
name|key_type
operator|&
name|x
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|rb_tree_const_iterator
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
name|upper_bound_hack
argument_list|(
argument|const Key& k
argument_list|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_typedef
typedef|typedef
name|pair
operator|<
name|iterator
operator|,
name|iterator
operator|>
name|pair_iterator_iterator
expr_stmt|;
end_typedef

begin_comment
comment|// typedef done to get around compiler bug
end_comment

begin_function
name|pair_iterator_iterator
name|equal_range
parameter_list|(
specifier|const
name|key_type
modifier|&
name|x
parameter_list|)
block|{
return|return
name|pair_iterator_iterator
argument_list|(
name|lower_bound
argument_list|(
name|x
argument_list|)
argument_list|,
name|upper_bound
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
name|pair
operator|<
name|const_iterator
operator|,
name|const_iterator
operator|>
name|pair_citerator_citerator
expr_stmt|;
end_typedef

begin_comment
comment|// typedef done to get around compiler bug
end_comment

begin_decl_stmt
name|pair_citerator_citerator
name|equal_range
argument_list|(
specifier|const
name|key_type
operator|&
name|x
argument_list|)
decl|const
block|{
return|return
name|pair_citerator_citerator
argument_list|(
name|lower_bound
argument_list|(
name|x
argument_list|)
argument_list|,
name|upper_bound
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
specifier|inline
name|void
name|rotate_left
parameter_list|(
name|link_type
name|x
parameter_list|)
block|{
name|link_type
name|y
init|=
name|right
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|right
argument_list|(
name|x
argument_list|)
operator|=
name|left
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
argument_list|(
name|y
argument_list|)
operator|!=
operator|&
name|__rb_NIL
condition|)
name|parent
argument_list|(
name|left
argument_list|(
name|y
argument_list|)
argument_list|)
operator|=
name|x
expr_stmt|;
name|parent
argument_list|(
name|y
argument_list|)
operator|=
name|parent
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|root
argument_list|()
condition|)
name|root
argument_list|()
operator|=
name|y
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|left
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|left
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|y
expr_stmt|;
else|else
name|right
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|y
expr_stmt|;
name|left
argument_list|(
name|y
argument_list|)
operator|=
name|x
expr_stmt|;
name|parent
argument_list|(
name|x
argument_list|)
operator|=
name|y
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
name|void
name|rotate_right
parameter_list|(
name|link_type
name|x
parameter_list|)
block|{
name|link_type
name|y
init|=
name|left
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|left
argument_list|(
name|x
argument_list|)
operator|=
name|right
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|right
argument_list|(
name|y
argument_list|)
operator|!=
operator|&
name|__rb_NIL
condition|)
name|parent
argument_list|(
name|right
argument_list|(
name|y
argument_list|)
argument_list|)
operator|=
name|x
expr_stmt|;
name|parent
argument_list|(
name|y
argument_list|)
operator|=
name|parent
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|root
argument_list|()
condition|)
name|root
argument_list|()
operator|=
name|y
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|right
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|right
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|y
expr_stmt|;
else|else
name|left
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|y
expr_stmt|;
name|right
argument_list|(
name|y
argument_list|)
operator|=
name|x
expr_stmt|;
name|parent
argument_list|(
name|x
argument_list|)
operator|=
name|y
expr_stmt|;
block|}
end_function

begin_function
name|friend
name|bidirectional_iterator_tag
name|iterator_category
parameter_list|(
name|iterator
parameter_list|)
block|{
return|return
name|bidirectional_iterator_tag
argument_list|()
return|;
block|}
end_function

begin_function
name|friend
name|bidirectional_iterator_tag
name|iterator_category
parameter_list|(
name|const_iterator
parameter_list|)
block|{
return|return
name|bidirectional_iterator_tag
argument_list|()
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function_decl
name|iterator
name|find
parameter_list|(
specifier|const
name|key_type
modifier|&
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|const_iterator
name|find
argument_list|(
specifier|const
name|key_type
operator|&
name|x
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_type
name|count
argument_list|(
specifier|const
name|key_type
operator|&
name|x
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_function_decl
name|iterator
name|lower_bound
parameter_list|(
specifier|const
name|key_type
modifier|&
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|const_iterator
name|lower_bound
argument_list|(
specifier|const
name|key_type
operator|&
name|x
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_function_decl
name|iterator
name|upper_bound
parameter_list|(
specifier|const
name|key_type
modifier|&
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|const_iterator
name|upper_bound
argument_list|(
specifier|const
name|key_type
operator|&
name|x
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|pair
operator|<
name|iterator
operator|,
name|iterator
operator|>
name|pair_iterator_iterator
expr_stmt|;
end_typedef

begin_comment
comment|// typedef done to get around compiler bug
end_comment

begin_function_decl
name|pair_iterator_iterator
name|equal_range
parameter_list|(
specifier|const
name|key_type
modifier|&
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
name|pair
operator|<
name|const_iterator
operator|,
name|const_iterator
operator|>
name|pair_citerator_citerator
expr_stmt|;
end_typedef

begin_comment
comment|// typedef done to get around compiler bug
end_comment

begin_decl_stmt
name|pair_citerator_citerator
name|equal_range
argument_list|(
specifier|const
name|key_type
operator|&
name|x
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|inline
name|void
name|rotate_left
parameter_list|(
name|link_type
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|inline
name|void
name|rotate_right
parameter_list|(
name|link_type
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
unit|};
ifndef|#
directive|ifndef
name|__GNUG__
end_ifndef

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|buffer_pointer
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|buffer_list
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|link_type
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|free_list
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|link_type
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|next_avail
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|link_type
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|last
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|size_type
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|number_of_trees
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|rb_tree_node_allocator_type
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|rb_tree_node_allocator
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
name|Allocator
operator|<
name|Value
operator|>
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|value_allocator
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|buffer_allocator_type
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|buffer_allocator
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
name|void
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|deallocate_buffers
argument_list|()
block|{
while|while
condition|(
name|buffer_list
condition|)
block|{
name|buffer_pointer
name|tmp
init|=
name|buffer_list
decl_stmt|;
name|buffer_list
operator|=
call|(
name|buffer_pointer
call|)
argument_list|(
name|buffer_list
operator|->
name|next_buffer
argument_list|)
expr_stmt|;
name|rb_tree_node_allocator
operator|.
name|deallocate
argument_list|(
name|tmp
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|buffer_allocator
operator|.
name|deallocate
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_expr_stmt
unit|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
expr|struct
name|rb_tree_iterator
block|{
name|rb_tree
operator|<
name|Key
block|,
name|Value
block|,
name|KeyOfValue
block|,
name|Compare
operator|>
operator|::
name|iterator
name|it
block|;
name|rb_tree_iterator
argument_list|(
argument|rb_tree<Key
argument_list|,
argument|Value
argument_list|,
argument|KeyOfValue
argument_list|,
argument|Compare>::iterator i
argument_list|)
operator|:
name|it
argument_list|(
argument|i
argument_list|)
block|{}
name|operator
name|rb_tree
operator|<
name|Key
block|,
name|Value
block|,
name|KeyOfValue
block|,
name|Compare
operator|>
operator|::
name|iterator
argument_list|()
block|{
return|return
name|it
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
specifier|inline
name|Value
operator|*
name|value_type
argument_list|(
argument|const rb_tree_iterator<Key
argument_list|,
argument|Value
argument_list|,
argument|KeyOfValue
argument_list|,
argument|Compare>&
argument_list|)
block|{
return|return
operator|(
name|Value
operator|*
operator|)
operator|(
literal|0
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
expr|struct
name|rb_tree_const_iterator
block|{
name|rb_tree
operator|<
name|Key
block|,
name|Value
block|,
name|KeyOfValue
block|,
name|Compare
operator|>
operator|::
name|const_iterator
name|it
block|;
name|rb_tree_const_iterator
argument_list|(
argument|rb_tree<Key
argument_list|,
argument|Value
argument_list|,
argument|KeyOfValue
argument_list|,
argument|Compare>::const_iterator i
argument_list|)
operator|:
name|it
argument_list|(
argument|i
argument_list|)
block|{}
name|operator
name|rb_tree
operator|<
name|Key
block|,
name|Value
block|,
name|KeyOfValue
block|,
name|Compare
operator|>
operator|::
name|const_iterator
argument_list|()
block|{
return|return
name|it
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
specifier|inline
name|Value
operator|*
name|value_type
argument_list|(
argument|const rb_tree_const_iterator<Key
argument_list|,
argument|Value
argument_list|,
argument|KeyOfValue
argument_list|,
argument|Compare>&
argument_list|)
block|{
return|return
operator|(
name|Value
operator|*
operator|)
operator|(
literal|0
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
expr|struct
name|rb_tree_pair_iterator_bool
block|{
name|rb_tree
operator|<
name|Key
block|,
name|Value
block|,
name|KeyOfValue
block|,
name|Compare
operator|>
operator|::
name|pair_iterator_bool
name|it
block|;
name|rb_tree_pair_iterator_bool
argument_list|(
argument|rb_tree<Key
argument_list|,
argument|Value
argument_list|,
argument|KeyOfValue
argument_list|,
argument|Compare>::pair_iterator_bool i
argument_list|)
operator|:
name|it
argument_list|(
argument|i
argument_list|)
block|{}
name|operator
name|rb_tree
operator|<
name|Key
block|,
name|Value
block|,
name|KeyOfValue
block|,
name|Compare
operator|>
operator|::
name|pair_iterator_bool
argument_list|()
block|{
return|return
name|it
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
specifier|inline
name|Value
operator|*
name|value_type
argument_list|(
argument|rb_tree_pair_iterator_bool<Key
argument_list|,
argument|Value
argument_list|,
argument|KeyOfValue
argument_list|,
argument|Compare>&
argument_list|)
block|{
return|return
operator|(
name|Value
operator|*
operator|)
operator|(
literal|0
operator|)
return|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|&
name|x
operator|,
specifier|const
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|&
name|y
operator|)
block|{
return|return
name|x
operator|.
name|size
argument_list|()
operator|==
name|y
operator|.
name|size
argument_list|()
operator|&&
name|equal
argument_list|(
name|x
operator|.
name|begin
argument_list|()
argument_list|,
name|x
operator|.
name|end
argument_list|()
argument_list|,
name|y
operator|.
name|begin
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|&
name|x
operator|,
specifier|const
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|&
name|y
operator|)
block|{
return|return
name|lexicographical_compare
argument_list|(
name|x
operator|.
name|begin
argument_list|()
argument_list|,
name|x
operator|.
name|end
argument_list|()
argument_list|,
name|y
operator|.
name|begin
argument_list|()
argument_list|,
name|y
operator|.
name|end
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|&
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|operator
operator|=
operator|(
specifier|const
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|&
name|x
operator|)
block|{
if|if
condition|(
name|this
operator|!=
operator|&
name|x
condition|)
block|{
comment|// can't be done as in list because Key may be a constant type
name|erase
argument_list|(
name|begin
argument_list|()
argument_list|,
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|root
argument_list|()
operator|=
name|__copy
argument_list|(
name|x
operator|.
name|root
argument_list|()
argument_list|,
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
argument_list|()
operator|==
operator|&
name|__rb_NIL
condition|)
block|{
name|leftmost
argument_list|()
operator|=
name|header
expr_stmt|;
name|rightmost
argument_list|()
operator|=
name|header
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|leftmost
argument_list|()
operator|=
name|minimum
argument_list|(
name|root
argument_list|()
argument_list|)
expr_stmt|;
name|rightmost
argument_list|()
operator|=
name|maximum
argument_list|(
name|root
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_else

begin_expr_stmt
name|node_count
operator|=
name|x
operator|.
name|node_count
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}     return
operator|*
name|this
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
ifdef|#
directive|ifdef
name|__GNUC__
name|rb_tree_iterator
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|__insert
argument_list|(
argument|void* xa
argument_list|,
argument|void* ya
argument_list|,
argument|const Value& v
argument_list|)
block|{
name|link_type
name|x
operator|=
operator|(
name|link_type
operator|)
name|xa
block|;
name|link_type
name|y
operator|=
operator|(
name|link_type
operator|)
name|ya
block|;
else|#
directive|else
name|rb_tree
operator|<
name|Key
block|,
name|Value
block|,
name|KeyOfValue
block|,
name|Compare
operator|>
operator|::
name|iterator
name|rb_tree
operator|<
name|Key
block|,
name|Value
block|,
name|KeyOfValue
block|,
name|Compare
operator|>
operator|::
name|__insert
argument_list|(
argument|link_type x
argument_list|,
argument|link_type y
argument_list|,
argument|const Value& v
argument_list|)
block|{
endif|#
directive|endif
operator|++
name|node_count
block|;
name|link_type
name|z
operator|=
name|get_node
argument_list|()
block|;
ifdef|#
directive|ifdef
name|__GNUG__
name|construct
argument_list|(
operator|&
operator|(
name|value
argument_list|(
name|z
argument_list|)
operator|)
argument_list|,
name|v
argument_list|)
block|;
else|#
directive|else
name|construct
argument_list|(
name|value_allocator
operator|.
name|address
argument_list|(
name|value
argument_list|(
name|z
argument_list|)
argument_list|)
argument_list|,
name|v
argument_list|)
block|;
endif|#
directive|endif
if|if
condition|(
name|y
operator|==
name|header
operator|||
name|x
operator|!=
operator|&
name|__rb_NIL
operator|||
name|key_compare
argument_list|(
name|KeyOfValue
argument_list|()
argument_list|(
name|v
argument_list|)
argument_list|,
name|key
argument_list|(
name|y
argument_list|)
argument_list|)
condition|)
block|{
name|left
argument_list|(
name|y
argument_list|)
operator|=
name|z
expr_stmt|;
comment|// also makes leftmost() = z when y == header
if|if
condition|(
name|y
operator|==
name|header
condition|)
block|{
name|root
argument_list|()
operator|=
name|z
expr_stmt|;
name|rightmost
argument_list|()
operator|=
name|z
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y
operator|==
name|leftmost
argument_list|()
condition|)
name|leftmost
argument_list|()
operator|=
name|z
expr_stmt|;
comment|// maintain leftmost() pointing to minimum node
block|}
end_expr_stmt

begin_else
else|else
block|{
name|right
argument_list|(
name|y
argument_list|)
operator|=
name|z
expr_stmt|;
if|if
condition|(
name|y
operator|==
name|rightmost
argument_list|()
condition|)
name|rightmost
argument_list|()
operator|=
name|z
expr_stmt|;
comment|// maintain rightmost() pointing to maximum node
block|}
end_else

begin_expr_stmt
name|parent
argument_list|(
name|z
argument_list|)
operator|=
name|y
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|z
operator|->
name|left_link
operator|=
operator|&
name|__rb_NIL
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|z
operator|->
name|right_link
operator|=
operator|&
name|__rb_NIL
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|x
operator|=
name|z
expr_stmt|;
end_expr_stmt

begin_comment
comment|// recolor and rebalance the tree
end_comment

begin_expr_stmt
name|color
argument_list|(
name|x
argument_list|)
operator|=
name|red
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|x
operator|!=
name|root
argument_list|()
operator|&&
name|color
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|red
condition|)
if|if
condition|(
name|parent
argument_list|(
name|x
argument_list|)
operator|==
name|left
argument_list|(
name|parent
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|y
operator|=
name|right
argument_list|(
name|parent
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
argument_list|(
name|y
argument_list|)
operator|==
name|red
condition|)
block|{
name|color
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|black
expr_stmt|;
name|color
argument_list|(
name|y
argument_list|)
operator|=
name|black
expr_stmt|;
name|color
argument_list|(
name|parent
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|=
name|red
expr_stmt|;
name|x
operator|=
name|parent
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|x
operator|==
name|right
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|x
operator|=
name|parent
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|rotate_left
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|color
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|black
expr_stmt|;
name|color
argument_list|(
name|parent
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|=
name|red
expr_stmt|;
name|rotate_right
argument_list|(
name|parent
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|y
operator|=
name|left
argument_list|(
name|parent
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
argument_list|(
name|y
argument_list|)
operator|==
name|red
condition|)
block|{
name|color
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|black
expr_stmt|;
name|color
argument_list|(
name|y
argument_list|)
operator|=
name|black
expr_stmt|;
name|color
argument_list|(
name|parent
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|=
name|red
expr_stmt|;
name|x
operator|=
name|parent
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|x
operator|==
name|left
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|x
operator|=
name|parent
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|rotate_right
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|color
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|black
expr_stmt|;
name|color
argument_list|(
name|parent
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|=
name|red
expr_stmt|;
name|rotate_left
argument_list|(
name|parent
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_while

begin_expr_stmt
name|color
argument_list|(
name|root
argument_list|()
argument_list|)
operator|=
name|black
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|iterator
argument_list|(
name|z
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
ifdef|#
directive|ifdef
name|__GNUC__
name|rb_tree_pair_iterator_bool
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|insert_hack
argument_list|(
argument|const Value& v
argument_list|)
block|{
else|#
directive|else
name|rb_tree
operator|<
name|Key
block|,
name|Value
block|,
name|KeyOfValue
block|,
name|Compare
operator|>
operator|::
name|pair_iterator_bool
name|rb_tree
operator|<
name|Key
block|,
name|Value
block|,
name|KeyOfValue
block|,
name|Compare
operator|>
operator|::
name|insert
argument_list|(
argument|const Value& v
argument_list|)
block|{
endif|#
directive|endif
name|link_type
name|y
operator|=
name|header
block|;
name|link_type
name|x
operator|=
name|root
argument_list|()
block|;
name|bool
name|comp
operator|=
name|true
block|;
while|while
condition|(
name|x
operator|!=
operator|&
name|__rb_NIL
condition|)
block|{
name|y
operator|=
name|x
expr_stmt|;
name|comp
operator|=
name|key_compare
argument_list|(
name|KeyOfValue
argument_list|()
argument_list|(
name|v
argument_list|)
argument_list|,
name|key
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|comp
condition|?
name|left
argument_list|(
name|x
argument_list|)
else|:
name|right
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|insert_always
condition|)
return|return
name|pair_iterator_bool
argument_list|(
name|__insert
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|v
argument_list|)
argument_list|,
name|true
argument_list|)
return|;
name|iterator
name|j
operator|=
name|iterator
argument_list|(
name|y
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|comp
condition|)
if|if
condition|(
name|j
operator|==
name|begin
argument_list|()
condition|)
return|return
name|pair_iterator_bool
argument_list|(
name|__insert
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|v
argument_list|)
argument_list|,
name|true
argument_list|)
return|;
else|else
operator|--
name|j
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|key_compare
argument_list|(
name|key
argument_list|(
name|j
operator|.
name|node
argument_list|)
argument_list|,
name|KeyOfValue
argument_list|()
argument_list|(
name|v
argument_list|)
argument_list|)
condition|)
return|return
name|pair_iterator_bool
argument_list|(
name|__insert
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|v
argument_list|)
argument_list|,
name|true
argument_list|)
return|;
end_if

begin_return
return|return
name|pair_iterator_bool
argument_list|(
name|j
argument_list|,
name|false
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
ifdef|#
directive|ifdef
name|__GNUC__
name|rb_tree_iterator
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|insert_hack
argument_list|(
argument|rb_tree_iterator<Key
argument_list|,
argument|Value
argument_list|,
argument|KeyOfValue
argument_list|,
argument|Compare> posn
argument_list|,
argument|const Value& v
argument_list|)
block|{
name|iterator
name|position
operator|=
name|posn
block|;
else|#
directive|else
name|rb_tree
operator|<
name|Key
block|,
name|Value
block|,
name|KeyOfValue
block|,
name|Compare
operator|>
operator|::
name|iterator
name|rb_tree
operator|<
name|Key
block|,
name|Value
block|,
name|KeyOfValue
block|,
name|Compare
operator|>
operator|::
name|insert
argument_list|(
argument|iterator position
argument_list|,
argument|const Value& v
argument_list|)
block|{
endif|#
directive|endif
if|if
condition|(
name|position
operator|==
name|iterator
argument_list|(
name|begin
argument_list|()
argument_list|)
condition|)
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
operator|&&
name|key_compare
argument_list|(
name|KeyOfValue
argument_list|()
argument_list|(
name|v
argument_list|)
argument_list|,
name|key
argument_list|(
name|position
operator|.
name|node
argument_list|)
argument_list|)
condition|)
return|return
name|__insert
argument_list|(
name|position
operator|.
name|node
argument_list|,
name|position
operator|.
name|node
argument_list|,
name|v
argument_list|)
return|;
comment|// first argument just needs to be non-&__rb_NIL
else|else
return|return
name|insert
argument_list|(
name|v
argument_list|)
operator|.
name|first
return|;
elseif|else
if|if
condition|(
name|position
operator|==
name|iterator
argument_list|(
name|end
argument_list|()
argument_list|)
condition|)
if|if
condition|(
name|key_compare
argument_list|(
name|key
argument_list|(
name|rightmost
argument_list|()
argument_list|)
argument_list|,
name|KeyOfValue
argument_list|()
argument_list|(
name|v
argument_list|)
argument_list|)
condition|)
return|return
name|__insert
argument_list|(
operator|&
name|__rb_NIL
argument_list|,
name|rightmost
argument_list|()
argument_list|,
name|v
argument_list|)
return|;
else|else
return|return
name|insert
argument_list|(
name|v
argument_list|)
operator|.
name|first
return|;
else|else
block|{
name|iterator
name|before
init|=
operator|--
name|position
decl_stmt|;
if|if
condition|(
name|key_compare
argument_list|(
name|key
argument_list|(
name|before
operator|.
name|node
argument_list|)
argument_list|,
name|KeyOfValue
argument_list|()
argument_list|(
name|v
argument_list|)
argument_list|)
operator|&&
name|key_compare
argument_list|(
name|KeyOfValue
argument_list|()
argument_list|(
name|v
argument_list|)
argument_list|,
name|key
argument_list|(
name|position
operator|.
name|node
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|right
argument_list|(
name|before
operator|.
name|node
argument_list|)
operator|==
operator|&
name|__rb_NIL
condition|)
return|return
name|__insert
argument_list|(
operator|&
name|__rb_NIL
argument_list|,
name|before
operator|.
name|node
argument_list|,
name|v
argument_list|)
return|;
else|else
return|return
name|__insert
argument_list|(
name|position
operator|.
name|node
argument_list|,
name|position
operator|.
name|node
argument_list|,
name|v
argument_list|)
return|;
comment|// first argument just needs to be non-&__rb_NIL
else|else
return|return
name|insert
argument_list|(
name|v
argument_list|)
operator|.
name|first
return|;
block|}
block|}
ifndef|#
directive|ifndef
name|__GNUC__
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
name|void
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|insert
argument_list|(
argument|iterator first
argument_list|,
argument|iterator last
argument_list|)
block|{
while|while
condition|(
name|first
operator|!=
name|last
condition|)
name|insert
argument_list|(
operator|*
name|first
operator|++
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
name|void
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|insert
argument_list|(
argument|const Value* first
argument_list|,
argument|const Value* last
argument_list|)
block|{
while|while
condition|(
name|first
operator|!=
name|last
condition|)
name|insert
argument_list|(
operator|*
name|first
operator|++
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
ifdef|#
directive|ifdef
name|__GNUC__
name|void
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|erase_hack
argument_list|(
argument|rb_tree_iterator<Key
argument_list|,
argument|Value
argument_list|,
argument|KeyOfValue
argument_list|,
argument|Compare> posn
argument_list|)
block|{
name|iterator
name|position
operator|=
name|posn
block|;
else|#
directive|else
name|void
name|rb_tree
operator|<
name|Key
block|,
name|Value
block|,
name|KeyOfValue
block|,
name|Compare
operator|>
operator|::
name|erase
argument_list|(
argument|iterator position
argument_list|)
block|{
endif|#
directive|endif
name|link_type
name|z
operator|=
name|position
operator|.
name|node
block|;
name|link_type
name|y
operator|=
name|z
block|;
name|link_type
name|x
block|;
if|if
condition|(
name|left
argument_list|(
name|y
argument_list|)
operator|==
operator|&
name|__rb_NIL
condition|)
name|x
operator|=
name|right
argument_list|(
name|y
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|right
argument_list|(
name|y
argument_list|)
operator|==
operator|&
name|__rb_NIL
condition|)
name|x
operator|=
name|left
argument_list|(
name|y
argument_list|)
expr_stmt|;
else|else
block|{
name|y
operator|=
name|right
argument_list|(
name|y
argument_list|)
expr_stmt|;
while|while
condition|(
name|left
argument_list|(
name|y
argument_list|)
operator|!=
operator|&
name|__rb_NIL
condition|)
name|y
operator|=
name|left
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|x
operator|=
name|right
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|!=
name|z
condition|)
block|{
comment|// relink y in place of z
name|parent
argument_list|(
name|left
argument_list|(
name|z
argument_list|)
argument_list|)
operator|=
name|y
expr_stmt|;
name|left
argument_list|(
name|y
argument_list|)
operator|=
name|left
argument_list|(
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|!=
name|right
argument_list|(
name|z
argument_list|)
condition|)
block|{
name|parent
argument_list|(
name|x
argument_list|)
operator|=
name|parent
argument_list|(
name|y
argument_list|)
expr_stmt|;
comment|// possibly x ==&__rb_NIL
name|left
argument_list|(
name|parent
argument_list|(
name|y
argument_list|)
argument_list|)
operator|=
name|x
expr_stmt|;
comment|// y must be a left child
name|right
argument_list|(
name|y
argument_list|)
operator|=
name|right
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|parent
argument_list|(
name|right
argument_list|(
name|z
argument_list|)
argument_list|)
operator|=
name|y
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
name|parent
argument_list|(
name|x
argument_list|)
operator|=
name|y
expr_stmt|;
end_else

begin_comment
comment|// needed in case x ==&__rb_NIL
end_comment

begin_if
if|if
condition|(
name|root
argument_list|()
operator|==
name|z
condition|)
name|root
argument_list|()
operator|=
name|y
expr_stmt|;
elseif|else
if|if
condition|(
name|left
argument_list|(
name|parent
argument_list|(
name|z
argument_list|)
argument_list|)
operator|==
name|z
condition|)
name|left
argument_list|(
name|parent
argument_list|(
name|z
argument_list|)
argument_list|)
operator|=
name|y
expr_stmt|;
else|else
name|right
argument_list|(
name|parent
argument_list|(
name|z
argument_list|)
argument_list|)
operator|=
name|y
expr_stmt|;
end_if

begin_expr_stmt
name|parent
argument_list|(
name|y
argument_list|)
operator|=
name|parent
argument_list|(
name|z
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|::
name|swap
argument_list|(
name|color
argument_list|(
name|y
argument_list|)
argument_list|,
name|color
argument_list|(
name|z
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|::
name|swap
argument_list|(
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// y points to node to be actually deleted,
end_comment

begin_comment
comment|// z points to old z's former successor
end_comment

begin_block
unit|} else
block|{
comment|// y == z
name|parent
argument_list|(
name|x
argument_list|)
operator|=
name|parent
argument_list|(
name|y
argument_list|)
expr_stmt|;
comment|// possibly x ==&__rb_NIL
if|if
condition|(
name|root
argument_list|()
operator|==
name|z
condition|)
name|root
argument_list|()
operator|=
name|x
expr_stmt|;
elseif|else
if|if
condition|(
name|left
argument_list|(
name|parent
argument_list|(
name|z
argument_list|)
argument_list|)
operator|==
name|z
condition|)
name|left
argument_list|(
name|parent
argument_list|(
name|z
argument_list|)
argument_list|)
operator|=
name|x
expr_stmt|;
else|else
name|right
argument_list|(
name|parent
argument_list|(
name|z
argument_list|)
argument_list|)
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|leftmost
argument_list|()
operator|==
name|z
condition|)
if|if
condition|(
name|right
argument_list|(
name|z
argument_list|)
operator|==
operator|&
name|__rb_NIL
condition|)
comment|// left(z) must be&__rb_NIL also
name|leftmost
argument_list|()
operator|=
name|parent
argument_list|(
name|z
argument_list|)
expr_stmt|;
comment|// makes leftmost() == header if z == root()
else|else
name|leftmost
argument_list|()
operator|=
name|minimum
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|rightmost
argument_list|()
operator|==
name|z
condition|)
if|if
condition|(
name|left
argument_list|(
name|z
argument_list|)
operator|==
operator|&
name|__rb_NIL
condition|)
comment|// right(z) must be&__rb_NIL also
name|rightmost
argument_list|()
operator|=
name|parent
argument_list|(
name|z
argument_list|)
expr_stmt|;
comment|// makes rightmost() == header if z == root()
else|else
comment|// x == left(z)
name|rightmost
argument_list|()
operator|=
name|maximum
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_block

begin_if
if|if
condition|(
name|color
argument_list|(
name|y
argument_list|)
operator|!=
name|red
condition|)
block|{
while|while
condition|(
name|x
operator|!=
name|root
argument_list|()
operator|&&
name|color
argument_list|(
name|x
argument_list|)
operator|==
name|black
condition|)
if|if
condition|(
name|x
operator|==
name|left
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|link_type
name|w
init|=
name|right
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|color
argument_list|(
name|w
argument_list|)
operator|==
name|red
condition|)
block|{
name|color
argument_list|(
name|w
argument_list|)
operator|=
name|black
expr_stmt|;
name|color
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|red
expr_stmt|;
name|rotate_left
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|=
name|right
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|color
argument_list|(
name|left
argument_list|(
name|w
argument_list|)
argument_list|)
operator|==
name|black
operator|&&
name|color
argument_list|(
name|right
argument_list|(
name|w
argument_list|)
argument_list|)
operator|==
name|black
condition|)
block|{
name|color
argument_list|(
name|w
argument_list|)
operator|=
name|red
expr_stmt|;
name|x
operator|=
name|parent
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|color
argument_list|(
name|right
argument_list|(
name|w
argument_list|)
argument_list|)
operator|==
name|black
condition|)
block|{
name|color
argument_list|(
name|left
argument_list|(
name|w
argument_list|)
argument_list|)
operator|=
name|black
expr_stmt|;
name|color
argument_list|(
name|w
argument_list|)
operator|=
name|red
expr_stmt|;
name|rotate_right
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|w
operator|=
name|right
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|color
argument_list|(
name|w
argument_list|)
operator|=
name|color
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|color
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|black
expr_stmt|;
name|color
argument_list|(
name|right
argument_list|(
name|w
argument_list|)
argument_list|)
operator|=
name|black
expr_stmt|;
name|rotate_left
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|// same as then clause with "right" and "left" exchanged
name|link_type
name|w
init|=
name|left
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|color
argument_list|(
name|w
argument_list|)
operator|==
name|red
condition|)
block|{
name|color
argument_list|(
name|w
argument_list|)
operator|=
name|black
expr_stmt|;
name|color
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|red
expr_stmt|;
name|rotate_right
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|=
name|left
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|color
argument_list|(
name|right
argument_list|(
name|w
argument_list|)
argument_list|)
operator|==
name|black
operator|&&
name|color
argument_list|(
name|left
argument_list|(
name|w
argument_list|)
argument_list|)
operator|==
name|black
condition|)
block|{
name|color
argument_list|(
name|w
argument_list|)
operator|=
name|red
expr_stmt|;
name|x
operator|=
name|parent
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|color
argument_list|(
name|left
argument_list|(
name|w
argument_list|)
argument_list|)
operator|==
name|black
condition|)
block|{
name|color
argument_list|(
name|right
argument_list|(
name|w
argument_list|)
argument_list|)
operator|=
name|black
expr_stmt|;
name|color
argument_list|(
name|w
argument_list|)
operator|=
name|red
expr_stmt|;
name|rotate_left
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|w
operator|=
name|left
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|color
argument_list|(
name|w
argument_list|)
operator|=
name|color
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|color
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|black
expr_stmt|;
name|color
argument_list|(
name|left
argument_list|(
name|w
argument_list|)
argument_list|)
operator|=
name|black
expr_stmt|;
name|rotate_right
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|color
argument_list|(
name|x
argument_list|)
operator|=
name|black
expr_stmt|;
block|}
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUG__
end_ifdef

begin_decl_stmt
name|delete
name|y
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|destroy
argument_list|(
name|value_allocator
operator|.
name|address
argument_list|(
name|value
argument_list|(
name|y
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|put_node
argument_list|(
name|y
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
operator|--
name|node_count
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
ifdef|#
directive|ifdef
name|__GNUC__
ifndef|#
directive|ifndef
name|__SIZE_TYPE__
define|#
directive|define
name|__SIZE_TYPE__
value|long unsigned int
endif|#
directive|endif
name|__SIZE_TYPE__
else|#
directive|else
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|size_type
endif|#
directive|endif
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|erase
argument_list|(
argument|const Key& x
argument_list|)
block|{
name|pair_iterator_iterator
name|p
operator|=
name|equal_range
argument_list|(
name|x
argument_list|)
block|;
name|size_type
name|n
operator|=
literal|0
block|;
name|distance
argument_list|(
name|p
operator|.
name|first
argument_list|,
name|p
operator|.
name|second
argument_list|,
name|n
argument_list|)
block|;
name|erase
argument_list|(
name|p
operator|.
name|first
argument_list|,
name|p
operator|.
name|second
argument_list|)
block|;
return|return
name|n
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
ifdef|#
directive|ifdef
name|__GNUG__
name|void
operator|*
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|__copy_hack
argument_list|(
argument|void* xa
argument_list|,
argument|void* pa
argument_list|)
block|{
name|link_type
name|x
operator|=
operator|(
name|link_type
operator|)
name|xa
block|;
name|link_type
name|p
operator|=
operator|(
name|link_type
operator|)
name|pa
block|;
else|#
directive|else
name|rb_tree
operator|<
name|Key
block|,
name|Value
block|,
name|KeyOfValue
block|,
name|Compare
operator|>
operator|::
name|link_type
name|rb_tree
operator|<
name|Key
block|,
name|Value
block|,
name|KeyOfValue
block|,
name|Compare
operator|>
operator|::
name|__copy
argument_list|(
argument|link_type x
argument_list|,
argument|link_type p
argument_list|)
block|{
endif|#
directive|endif
comment|// structural copy
name|link_type
name|r
operator|=
name|x
block|;
while|while
condition|(
name|x
operator|!=
operator|&
name|__rb_NIL
condition|)
block|{
name|link_type
name|y
init|=
name|get_node
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|x
condition|)
name|r
operator|=
name|y
expr_stmt|;
comment|// save for return value
ifdef|#
directive|ifdef
name|__GNUG__
name|construct
argument_list|(
operator|&
operator|(
name|value
argument_list|(
name|y
argument_list|)
operator|)
argument_list|,
name|value
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|construct
argument_list|(
name|value_allocator
operator|.
name|address
argument_list|(
name|value
argument_list|(
name|y
argument_list|)
argument_list|)
argument_list|,
name|value
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|left
argument_list|(
name|p
argument_list|)
operator|=
name|y
expr_stmt|;
name|parent
argument_list|(
name|y
argument_list|)
operator|=
name|p
expr_stmt|;
name|color
argument_list|(
name|y
argument_list|)
operator|=
name|color
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|right
argument_list|(
name|y
argument_list|)
operator|=
name|__copy
argument_list|(
name|right
argument_list|(
name|x
argument_list|)
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|p
operator|=
name|y
expr_stmt|;
name|x
operator|=
name|left
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|left
argument_list|(
name|p
argument_list|)
operator|=
operator|(
name|link_type
operator|)
operator|&
name|__rb_NIL
block|;
return|return
name|r
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
ifdef|#
directive|ifdef
name|__GNUG__
name|void
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|__erase
argument_list|(
argument|void* xa
argument_list|)
block|{
name|link_type
name|x
operator|=
operator|(
name|link_type
operator|)
name|xa
block|;
else|#
directive|else
name|void
name|rb_tree
operator|<
name|Key
block|,
name|Value
block|,
name|KeyOfValue
block|,
name|Compare
operator|>
operator|::
name|__erase
argument_list|(
argument|link_type x
argument_list|)
block|{
endif|#
directive|endif
comment|// erase without rebalancing
while|while
condition|(
name|x
operator|!=
operator|&
name|__rb_NIL
condition|)
block|{
name|__erase
argument_list|(
name|right
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|link_type
name|y
init|=
name|left
argument_list|(
name|x
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|__GNUG__
name|delete
name|x
decl_stmt|;
else|#
directive|else
name|destroy
argument_list|(
name|value_allocator
operator|.
name|address
argument_list|(
name|value
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|put_node
argument_list|(
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|x
operator|=
name|y
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|__GNUC__
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
name|void
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|erase
argument_list|(
argument|iterator first
argument_list|,
argument|iterator last
argument_list|)
block|{
if|if
condition|(
name|first
operator|==
name|begin
argument_list|()
operator|&&
name|last
operator|==
name|end
argument_list|()
operator|&&
name|node_count
operator|!=
literal|0
condition|)
block|{
name|__erase
argument_list|(
name|root
argument_list|()
argument_list|)
expr_stmt|;
name|leftmost
argument_list|()
operator|=
name|header
expr_stmt|;
name|root
argument_list|()
operator|=
name|NIL
expr_stmt|;
name|rightmost
argument_list|()
operator|=
name|header
expr_stmt|;
name|node_count
operator|=
literal|0
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
while|while
condition|(
name|first
operator|!=
name|last
condition|)
name|erase
argument_list|(
name|first
operator|++
argument_list|)
expr_stmt|;
end_else

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_expr_stmt
unit|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
name|void
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|erase
argument_list|(
argument|const Key* first
argument_list|,
argument|const Key* last
argument_list|)
block|{
while|while
condition|(
name|first
operator|!=
name|last
condition|)
name|erase
argument_list|(
operator|*
name|first
operator|++
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
ifdef|#
directive|ifdef
name|__GNUC__
name|rb_tree_iterator
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|find_hack
argument_list|(
argument|const Key& k
argument_list|)
block|{
else|#
directive|else
name|rb_tree
operator|<
name|Key
block|,
name|Value
block|,
name|KeyOfValue
block|,
name|Compare
operator|>
operator|::
name|iterator
name|rb_tree
operator|<
name|Key
block|,
name|Value
block|,
name|KeyOfValue
block|,
name|Compare
operator|>
operator|::
name|find
argument_list|(
argument|const Key& k
argument_list|)
block|{
endif|#
directive|endif
name|link_type
name|y
operator|=
name|header
block|;
name|link_type
name|x
operator|=
name|root
argument_list|()
block|;
name|bool
name|comp
operator|=
name|false
block|;
while|while
condition|(
name|x
operator|!=
operator|&
name|__rb_NIL
condition|)
block|{
name|y
operator|=
name|x
expr_stmt|;
name|comp
operator|=
name|key_compare
argument_list|(
name|key
argument_list|(
name|x
argument_list|)
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|x
operator|=
name|comp
condition|?
name|right
argument_list|(
name|x
argument_list|)
else|:
name|left
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|iterator
name|j
operator|=
name|iterator
argument_list|(
name|y
argument_list|)
block|;
if|if
condition|(
name|comp
condition|)
operator|++
name|j
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|j
operator|==
name|end
argument_list|()
operator|||
name|key_compare
argument_list|(
name|k
argument_list|,
name|key
argument_list|(
name|j
operator|.
name|node
argument_list|)
argument_list|)
operator|)
condition|?
name|end
argument_list|()
else|:
name|j
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
ifdef|#
directive|ifdef
name|__GNUC__
name|rb_tree_const_iterator
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|find_hack
argument_list|(
argument|const Key& k
argument_list|)
specifier|const
block|{
else|#
directive|else
name|rb_tree
operator|<
name|Key
block|,
name|Value
block|,
name|KeyOfValue
block|,
name|Compare
operator|>
operator|::
name|const_iterator
name|rb_tree
operator|<
name|Key
block|,
name|Value
block|,
name|KeyOfValue
block|,
name|Compare
operator|>
operator|::
name|find
argument_list|(
argument|const Key& k
argument_list|)
specifier|const
block|{
endif|#
directive|endif
name|link_type
name|y
operator|=
name|header
block|;
name|link_type
name|x
operator|=
name|root
argument_list|()
block|;
name|bool
name|comp
operator|=
name|false
block|;
while|while
condition|(
name|x
operator|!=
operator|&
name|__rb_NIL
condition|)
block|{
name|y
operator|=
name|x
expr_stmt|;
name|comp
operator|=
name|key_compare
argument_list|(
name|key
argument_list|(
name|x
argument_list|)
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|x
operator|=
name|comp
condition|?
name|right
argument_list|(
name|x
argument_list|)
else|:
name|left
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|const_iterator
name|j
operator|=
name|const_iterator
argument_list|(
name|y
argument_list|)
block|;
if|if
condition|(
name|comp
condition|)
operator|++
name|j
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|j
operator|==
name|end
argument_list|()
operator|||
name|key_compare
argument_list|(
name|k
argument_list|,
name|key
argument_list|(
name|j
operator|.
name|node
argument_list|)
argument_list|)
operator|)
condition|?
name|end
argument_list|()
else|:
name|j
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
ifdef|#
directive|ifdef
name|__GNUG__
name|__SIZE_TYPE__
else|#
directive|else
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|size_type
endif|#
directive|endif
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|count
argument_list|(
argument|const Key& k
argument_list|)
specifier|const
block|{
name|pair
operator|<
name|const_iterator
block|,
name|const_iterator
operator|>
name|p
operator|=
name|equal_range
argument_list|(
name|k
argument_list|)
block|;
name|size_type
name|n
operator|=
literal|0
block|;
name|distance
argument_list|(
name|p
operator|.
name|first
argument_list|,
name|p
operator|.
name|second
argument_list|,
name|n
argument_list|)
block|;
return|return
name|n
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
ifdef|#
directive|ifdef
name|__GNUC__
name|rb_tree_iterator
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|lower_bound_hack
argument_list|(
argument|const Key& k
argument_list|)
block|{
else|#
directive|else
name|rb_tree
operator|<
name|Key
block|,
name|Value
block|,
name|KeyOfValue
block|,
name|Compare
operator|>
operator|::
name|iterator
name|rb_tree
operator|<
name|Key
block|,
name|Value
block|,
name|KeyOfValue
block|,
name|Compare
operator|>
operator|::
name|lower_bound
argument_list|(
argument|const Key& k
argument_list|)
block|{
endif|#
directive|endif
name|link_type
name|y
operator|=
name|header
block|;
name|link_type
name|x
operator|=
name|root
argument_list|()
block|;
name|bool
name|comp
operator|=
name|false
block|;
while|while
condition|(
name|x
operator|!=
operator|&
name|__rb_NIL
condition|)
block|{
name|y
operator|=
name|x
expr_stmt|;
name|comp
operator|=
name|key_compare
argument_list|(
name|key
argument_list|(
name|x
argument_list|)
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|x
operator|=
name|comp
condition|?
name|right
argument_list|(
name|x
argument_list|)
else|:
name|left
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|iterator
name|j
operator|=
name|iterator
argument_list|(
name|y
argument_list|)
block|;
return|return
name|comp
condition|?
operator|++
name|j
else|:
name|j
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
ifdef|#
directive|ifdef
name|__GNUC__
name|rb_tree_const_iterator
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|lower_bound_hack
argument_list|(
argument|const Key& k
argument_list|)
specifier|const
block|{
else|#
directive|else
name|rb_tree
operator|<
name|Key
block|,
name|Value
block|,
name|KeyOfValue
block|,
name|Compare
operator|>
operator|::
name|const_iterator
name|rb_tree
operator|<
name|Key
block|,
name|Value
block|,
name|KeyOfValue
block|,
name|Compare
operator|>
operator|::
name|lower_bound
argument_list|(
argument|const Key& k
argument_list|)
specifier|const
block|{
endif|#
directive|endif
name|link_type
name|y
operator|=
name|header
block|;
name|link_type
name|x
operator|=
name|root
argument_list|()
block|;
name|bool
name|comp
operator|=
name|false
block|;
while|while
condition|(
name|x
operator|!=
operator|&
name|__rb_NIL
condition|)
block|{
name|y
operator|=
name|x
expr_stmt|;
name|comp
operator|=
name|key_compare
argument_list|(
name|key
argument_list|(
name|x
argument_list|)
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|x
operator|=
name|comp
condition|?
name|right
argument_list|(
name|x
argument_list|)
else|:
name|left
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|const_iterator
name|j
operator|=
name|const_iterator
argument_list|(
name|y
argument_list|)
block|;
return|return
name|comp
condition|?
operator|++
name|j
else|:
name|j
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
ifdef|#
directive|ifdef
name|__GNUC__
name|rb_tree_iterator
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|upper_bound_hack
argument_list|(
argument|const Key& k
argument_list|)
block|{
else|#
directive|else
name|rb_tree
operator|<
name|Key
block|,
name|Value
block|,
name|KeyOfValue
block|,
name|Compare
operator|>
operator|::
name|iterator
name|rb_tree
operator|<
name|Key
block|,
name|Value
block|,
name|KeyOfValue
block|,
name|Compare
operator|>
operator|::
name|upper_bound
argument_list|(
argument|const Key& k
argument_list|)
block|{
endif|#
directive|endif
name|link_type
name|y
operator|=
name|header
block|;
name|link_type
name|x
operator|=
name|root
argument_list|()
block|;
name|bool
name|comp
operator|=
name|true
block|;
while|while
condition|(
name|x
operator|!=
operator|&
name|__rb_NIL
condition|)
block|{
name|y
operator|=
name|x
expr_stmt|;
name|comp
operator|=
name|key_compare
argument_list|(
name|k
argument_list|,
name|key
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|comp
condition|?
name|left
argument_list|(
name|x
argument_list|)
else|:
name|right
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|iterator
name|j
operator|=
name|iterator
argument_list|(
name|y
argument_list|)
block|;
return|return
name|comp
condition|?
name|j
else|:
operator|++
name|j
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
ifdef|#
directive|ifdef
name|__GNUC__
name|rb_tree_const_iterator
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|upper_bound_hack
argument_list|(
argument|const Key& k
argument_list|)
specifier|const
block|{
else|#
directive|else
name|rb_tree
operator|<
name|Key
block|,
name|Value
block|,
name|KeyOfValue
block|,
name|Compare
operator|>
operator|::
name|const_iterator
name|rb_tree
operator|<
name|Key
block|,
name|Value
block|,
name|KeyOfValue
block|,
name|Compare
operator|>
operator|::
name|upper_bound
argument_list|(
argument|const Key& k
argument_list|)
specifier|const
block|{
endif|#
directive|endif
name|link_type
name|y
operator|=
name|header
block|;
name|link_type
name|x
operator|=
name|root
argument_list|()
block|;
name|bool
name|comp
operator|=
name|true
block|;
while|while
condition|(
name|x
operator|!=
operator|&
name|__rb_NIL
condition|)
block|{
name|y
operator|=
name|x
expr_stmt|;
name|comp
operator|=
name|key_compare
argument_list|(
name|k
argument_list|,
name|key
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|comp
condition|?
name|left
argument_list|(
name|x
argument_list|)
else|:
name|right
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|const_iterator
name|j
operator|=
name|const_iterator
argument_list|(
name|y
argument_list|)
block|;
return|return
name|comp
condition|?
name|j
else|:
operator|++
name|j
return|;
block|}
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|__GNUC__
end_ifndef

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|pair_iterator_iterator
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|equal_range
argument_list|(
argument|const Key& k
argument_list|)
block|{
return|return
name|pair_iterator_iterator
argument_list|(
name|lower_bound
argument_list|(
name|k
argument_list|)
argument_list|,
name|upper_bound
argument_list|(
name|k
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|pair_citerator_citerator
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|equal_range
argument_list|(
argument|const Key& k
argument_list|)
specifier|const
block|{
return|return
name|pair_citerator_citerator
argument_list|(
name|lower_bound
argument_list|(
name|k
argument_list|)
argument_list|,
name|upper_bound
argument_list|(
name|k
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
specifier|inline
name|void
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|rotate_left
argument_list|(
argument|link_type x
argument_list|)
block|{
name|link_type
name|y
operator|=
name|right
argument_list|(
name|x
argument_list|)
block|;
name|right
argument_list|(
name|x
argument_list|)
operator|=
name|left
argument_list|(
name|y
argument_list|)
block|;
if|if
condition|(
name|left
argument_list|(
name|y
argument_list|)
operator|!=
operator|&
name|__rb_NIL
condition|)
name|parent
argument_list|(
name|left
argument_list|(
name|y
argument_list|)
argument_list|)
operator|=
name|x
expr_stmt|;
name|parent
argument_list|(
name|y
argument_list|)
operator|=
name|parent
argument_list|(
name|x
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|x
operator|==
name|root
argument_list|()
condition|)
name|root
argument_list|()
operator|=
name|y
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|left
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|left
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|y
expr_stmt|;
else|else
name|right
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|y
expr_stmt|;
end_if

begin_expr_stmt
name|left
argument_list|(
name|y
argument_list|)
operator|=
name|x
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|parent
argument_list|(
name|x
argument_list|)
operator|=
name|y
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|Key
operator|,
name|class
name|Value
operator|,
name|class
name|KeyOfValue
operator|,
name|class
name|Compare
operator|>
specifier|inline
name|void
name|rb_tree
operator|<
name|Key
operator|,
name|Value
operator|,
name|KeyOfValue
operator|,
name|Compare
operator|>
operator|::
name|rotate_right
argument_list|(
argument|link_type x
argument_list|)
block|{
name|link_type
name|y
operator|=
name|left
argument_list|(
name|x
argument_list|)
block|;
name|left
argument_list|(
name|x
argument_list|)
operator|=
name|right
argument_list|(
name|y
argument_list|)
block|;
if|if
condition|(
name|right
argument_list|(
name|y
argument_list|)
operator|!=
operator|&
name|__rb_NIL
condition|)
name|parent
argument_list|(
name|right
argument_list|(
name|y
argument_list|)
argument_list|)
operator|=
name|x
expr_stmt|;
name|parent
argument_list|(
name|y
argument_list|)
operator|=
name|parent
argument_list|(
name|x
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|x
operator|==
name|root
argument_list|()
condition|)
name|root
argument_list|()
operator|=
name|y
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|right
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|right
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|y
expr_stmt|;
else|else
name|left
argument_list|(
name|parent
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|y
expr_stmt|;
end_if

begin_expr_stmt
name|right
argument_list|(
name|y
argument_list|)
operator|=
name|x
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|parent
argument_list|(
name|x
argument_list|)
operator|=
name|y
expr_stmt|;
end_expr_stmt

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

