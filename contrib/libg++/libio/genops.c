begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 1993, 1995 Free Software Foundation  This file is part of the GNU IO Library.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this library; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.  As a special exception, if you link this library with files compiled with a GNU compiler to produce an executable, this does not cause the resulting executable to be covered by the GNU General Public License. This exception does not however invalidate any other reasons why the executable file might be covered by the GNU General Public License. */
end_comment

begin_comment
comment|/* Generic or default I/O operations. */
end_comment

begin_include
include|#
directive|include
file|"libioP.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|_IO_un_link
argument_list|,
operator|(
name|fp
operator|)
argument_list|,
name|_IO_FILE
operator|*
name|fp
argument_list|)
block|{
if|if
condition|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_LINKED
condition|)
block|{
name|_IO_FILE
modifier|*
modifier|*
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
operator|&
name|_IO_list_all
init|;
operator|*
name|f
operator|!=
name|NULL
condition|;
name|f
operator|=
operator|&
operator|(
operator|*
name|f
operator|)
operator|->
name|_chain
control|)
block|{
if|if
condition|(
operator|*
name|f
operator|==
name|fp
condition|)
block|{
operator|*
name|f
operator|=
name|fp
operator|->
name|_chain
expr_stmt|;
break|break;
block|}
block|}
name|fp
operator|->
name|_flags
operator|&=
operator|~
name|_IO_LINKED
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|_IO_link_in
argument_list|,
operator|(
name|fp
operator|)
argument_list|,
name|_IO_FILE
operator|*
name|fp
argument_list|)
block|{
if|if
condition|(
operator|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_LINKED
operator|)
operator|==
literal|0
condition|)
block|{
name|fp
operator|->
name|_flags
operator||=
name|_IO_LINKED
expr_stmt|;
name|fp
operator|->
name|_chain
operator|=
name|_IO_list_all
expr_stmt|;
name|_IO_list_all
operator|=
name|fp
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Return minimum _pos markers    Assumes the current get area is the main get area. */
end_comment

begin_decl_stmt
name|_IO_size_t
name|DEFUN
argument_list|(
name|_IO_least_marker
argument_list|,
operator|(
name|fp
operator|)
argument_list|,
specifier|register
name|_IO_FILE
operator|*
name|fp
argument_list|)
block|{
name|_IO_ssize_t
name|least_so_far
init|=
name|fp
operator|->
name|_IO_read_end
operator|-
name|fp
operator|->
name|_IO_read_base
decl_stmt|;
specifier|register
name|struct
name|_IO_marker
modifier|*
name|mark
decl_stmt|;
for|for
control|(
name|mark
operator|=
name|fp
operator|->
name|_markers
init|;
name|mark
operator|!=
name|NULL
condition|;
name|mark
operator|=
name|mark
operator|->
name|_next
control|)
if|if
condition|(
name|mark
operator|->
name|_pos
operator|<
name|least_so_far
condition|)
name|least_so_far
operator|=
name|mark
operator|->
name|_pos
expr_stmt|;
return|return
name|least_so_far
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Switch current get area from backup buffer to (start of) main get area. */
end_comment

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|_IO_switch_to_main_get_area
argument_list|,
operator|(
name|fp
operator|)
argument_list|,
name|_IO_FILE
operator|*
name|fp
argument_list|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|fp
operator|->
name|_flags
operator|&=
operator|~
name|_IO_IN_BACKUP
expr_stmt|;
comment|/* Swap _IO_read_end and _IO_save_end. */
name|tmp
operator|=
name|fp
operator|->
name|_IO_read_end
expr_stmt|;
name|fp
operator|->
name|_IO_read_end
operator|=
name|fp
operator|->
name|_IO_save_end
expr_stmt|;
name|fp
operator|->
name|_IO_save_end
operator|=
name|tmp
expr_stmt|;
comment|/* Swap _IO_read_base and _IO_save_base. */
name|tmp
operator|=
name|fp
operator|->
name|_IO_read_base
expr_stmt|;
name|fp
operator|->
name|_IO_read_base
operator|=
name|fp
operator|->
name|_IO_save_base
expr_stmt|;
name|fp
operator|->
name|_IO_save_base
operator|=
name|tmp
expr_stmt|;
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_IO_read_base
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Switch current get area from main get area to (end of) backup area. */
end_comment

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|_IO_switch_to_backup_area
argument_list|,
operator|(
name|fp
operator|)
argument_list|,
specifier|register
name|_IO_FILE
operator|*
name|fp
argument_list|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|fp
operator|->
name|_flags
operator||=
name|_IO_IN_BACKUP
expr_stmt|;
comment|/* Swap _IO_read_end and _IO_save_end. */
name|tmp
operator|=
name|fp
operator|->
name|_IO_read_end
expr_stmt|;
name|fp
operator|->
name|_IO_read_end
operator|=
name|fp
operator|->
name|_IO_save_end
expr_stmt|;
name|fp
operator|->
name|_IO_save_end
operator|=
name|tmp
expr_stmt|;
comment|/* Swap _gbase and _IO_save_base. */
name|tmp
operator|=
name|fp
operator|->
name|_IO_read_base
expr_stmt|;
name|fp
operator|->
name|_IO_read_base
operator|=
name|fp
operator|->
name|_IO_save_base
expr_stmt|;
name|fp
operator|->
name|_IO_save_base
operator|=
name|tmp
expr_stmt|;
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_IO_read_end
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|DEFUN
argument_list|(
name|_IO_switch_to_get_mode
argument_list|,
operator|(
name|fp
operator|)
argument_list|,
specifier|register
name|_IO_FILE
operator|*
name|fp
argument_list|)
block|{
if|if
condition|(
name|fp
operator|->
name|_IO_write_ptr
operator|>
name|fp
operator|->
name|_IO_write_base
condition|)
if|if
condition|(
name|_IO_OVERFLOW
argument_list|(
name|fp
argument_list|,
name|EOF
argument_list|)
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
if|if
condition|(
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
name|fp
operator|->
name|_IO_read_base
operator|=
name|fp
operator|->
name|_IO_backup_base
expr_stmt|;
else|else
block|{
name|fp
operator|->
name|_IO_read_base
operator|=
name|fp
operator|->
name|_IO_buf_base
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|_IO_write_ptr
operator|>
name|fp
operator|->
name|_IO_read_end
condition|)
name|fp
operator|->
name|_IO_read_end
operator|=
name|fp
operator|->
name|_IO_write_ptr
expr_stmt|;
block|}
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_IO_write_ptr
expr_stmt|;
name|fp
operator|->
name|_IO_write_base
operator|=
name|fp
operator|->
name|_IO_write_ptr
operator|=
name|fp
operator|->
name|_IO_write_end
operator|=
name|fp
operator|->
name|_IO_read_ptr
expr_stmt|;
name|fp
operator|->
name|_flags
operator|&=
operator|~
name|_IO_CURRENTLY_PUTTING
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|_IO_free_backup_area
argument_list|,
operator|(
name|fp
operator|)
argument_list|,
specifier|register
name|_IO_FILE
operator|*
name|fp
argument_list|)
block|{
if|if
condition|(
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
name|_IO_switch_to_main_get_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Just in case. */
name|free
argument_list|(
name|fp
operator|->
name|_IO_save_base
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_save_base
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|_IO_save_end
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|_IO_backup_base
operator|=
name|NULL
expr_stmt|;
block|}
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|int DEFUN(_IO_switch_to_put_mode, (fp),       register _IO_FILE *fp) {   fp->_IO_write_base = fp->_IO_read_ptr;   fp->_IO_write_ptr = fp->_IO_read_ptr;
comment|/* Following is wrong if line- or un-buffered? */
end_comment

begin_endif
unit|fp->_IO_write_end = fp->_flags& _IO_IN_BACKUP ? fp->_IO_read_end : fp->_IO_buf_end;    fp->_IO_read_ptr = fp->_IO_read_end;   fp->_IO_read_base = fp->_IO_read_end;    fp->_flags |= _IO_CURRENTLY_PUTTING;   return 0; }
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|DEFUN
argument_list|(
name|__overflow
argument_list|,
operator|(
name|f
operator|,
name|ch
operator|)
argument_list|,
name|_IO_FILE
operator|*
name|f
name|AND
name|int
name|ch
argument_list|)
block|{
return|return
name|_IO_OVERFLOW
argument_list|(
name|f
argument_list|,
name|ch
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DEFUN
argument_list|(
name|save_for_backup
argument_list|,
operator|(
name|fp
operator|)
argument_list|,
name|_IO_FILE
operator|*
name|fp
argument_list|)
block|{
comment|/* Append [_IO_read_base.._IO_read_end] to backup area. */
name|int
name|least_mark
init|=
name|_IO_least_marker
argument_list|(
name|fp
argument_list|)
decl_stmt|;
comment|/* needed_size is how much space we need in the backup area. */
name|int
name|needed_size
init|=
operator|(
name|fp
operator|->
name|_IO_read_end
operator|-
name|fp
operator|->
name|_IO_read_base
operator|)
operator|-
name|least_mark
decl_stmt|;
name|int
name|current_Bsize
init|=
name|fp
operator|->
name|_IO_save_end
operator|-
name|fp
operator|->
name|_IO_save_base
decl_stmt|;
name|int
name|avail
decl_stmt|;
comment|/* Extra space available for future expansion. */
name|int
name|delta
decl_stmt|;
name|struct
name|_IO_marker
modifier|*
name|mark
decl_stmt|;
if|if
condition|(
name|needed_size
operator|>
name|current_Bsize
condition|)
block|{
name|char
modifier|*
name|new_buffer
decl_stmt|;
name|avail
operator|=
literal|100
expr_stmt|;
name|new_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|avail
operator|+
name|needed_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_buffer
operator|==
name|NULL
condition|)
return|return
name|EOF
return|;
comment|/* FIXME */
if|if
condition|(
name|least_mark
operator|<
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|new_buffer
operator|+
name|avail
argument_list|,
name|fp
operator|->
name|_IO_save_end
operator|+
name|least_mark
argument_list|,
operator|-
name|least_mark
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_buffer
operator|+
name|avail
operator|-
name|least_mark
argument_list|,
name|fp
operator|->
name|_IO_read_base
argument_list|,
name|fp
operator|->
name|_IO_read_end
operator|-
name|fp
operator|->
name|_IO_read_base
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|new_buffer
operator|+
name|avail
argument_list|,
name|fp
operator|->
name|_IO_read_base
operator|+
name|least_mark
argument_list|,
name|needed_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|_IO_save_base
condition|)
name|free
argument_list|(
name|fp
operator|->
name|_IO_save_base
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_save_base
operator|=
name|new_buffer
expr_stmt|;
name|fp
operator|->
name|_IO_save_end
operator|=
name|new_buffer
operator|+
name|avail
operator|+
name|needed_size
expr_stmt|;
block|}
else|else
block|{
name|avail
operator|=
name|current_Bsize
operator|-
name|needed_size
expr_stmt|;
if|if
condition|(
name|least_mark
operator|<
literal|0
condition|)
block|{
name|memmove
argument_list|(
name|fp
operator|->
name|_IO_save_base
operator|+
name|avail
argument_list|,
name|fp
operator|->
name|_IO_save_end
operator|+
name|least_mark
argument_list|,
operator|-
name|least_mark
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fp
operator|->
name|_IO_save_base
operator|+
name|avail
operator|-
name|least_mark
argument_list|,
name|fp
operator|->
name|_IO_read_base
argument_list|,
name|fp
operator|->
name|_IO_read_end
operator|-
name|fp
operator|->
name|_IO_read_base
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|needed_size
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|fp
operator|->
name|_IO_save_base
operator|+
name|avail
argument_list|,
name|fp
operator|->
name|_IO_read_base
operator|+
name|least_mark
argument_list|,
name|needed_size
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: Dubious arithmetic if pointers are NULL */
name|fp
operator|->
name|_IO_backup_base
operator|=
name|fp
operator|->
name|_IO_save_base
operator|+
name|avail
expr_stmt|;
comment|/* Adjust all the streammarkers. */
name|delta
operator|=
name|fp
operator|->
name|_IO_read_end
operator|-
name|fp
operator|->
name|_IO_read_base
expr_stmt|;
for|for
control|(
name|mark
operator|=
name|fp
operator|->
name|_markers
init|;
name|mark
operator|!=
name|NULL
condition|;
name|mark
operator|=
name|mark
operator|->
name|_next
control|)
name|mark
operator|->
name|_pos
operator|-=
name|delta
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|DEFUN
argument_list|(
name|__underflow
argument_list|,
operator|(
name|fp
operator|)
argument_list|,
name|_IO_FILE
operator|*
name|fp
argument_list|)
block|{
if|if
condition|(
name|_IO_in_put_mode
argument_list|(
name|fp
argument_list|)
condition|)
if|if
condition|(
name|_IO_switch_to_get_mode
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
if|if
condition|(
name|fp
operator|->
name|_IO_read_ptr
operator|<
name|fp
operator|->
name|_IO_read_end
condition|)
return|return
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fp
operator|->
name|_IO_read_ptr
return|;
if|if
condition|(
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|_IO_switch_to_main_get_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|_IO_read_ptr
operator|<
name|fp
operator|->
name|_IO_read_end
condition|)
return|return
operator|*
name|fp
operator|->
name|_IO_read_ptr
return|;
block|}
if|if
condition|(
name|_IO_have_markers
argument_list|(
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
name|save_for_backup
argument_list|(
name|fp
argument_list|)
condition|)
return|return
name|EOF
return|;
block|}
elseif|else
if|if
condition|(
name|_IO_have_backup
argument_list|(
name|fp
argument_list|)
condition|)
name|_IO_free_backup_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|_IO_UNDERFLOW
argument_list|(
name|fp
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|DEFUN
argument_list|(
name|__uflow
argument_list|,
operator|(
name|fp
operator|)
argument_list|,
name|_IO_FILE
operator|*
name|fp
argument_list|)
block|{
if|if
condition|(
name|_IO_in_put_mode
argument_list|(
name|fp
argument_list|)
condition|)
if|if
condition|(
name|_IO_switch_to_get_mode
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
if|if
condition|(
name|fp
operator|->
name|_IO_read_ptr
operator|<
name|fp
operator|->
name|_IO_read_end
condition|)
return|return
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fp
operator|->
name|_IO_read_ptr
operator|++
return|;
if|if
condition|(
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|_IO_switch_to_main_get_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|_IO_read_ptr
operator|<
name|fp
operator|->
name|_IO_read_end
condition|)
return|return
operator|*
name|fp
operator|->
name|_IO_read_ptr
operator|++
return|;
block|}
if|if
condition|(
name|_IO_have_markers
argument_list|(
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
name|save_for_backup
argument_list|(
name|fp
argument_list|)
condition|)
return|return
name|EOF
return|;
block|}
elseif|else
if|if
condition|(
name|_IO_have_backup
argument_list|(
name|fp
argument_list|)
condition|)
name|_IO_free_backup_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|_IO_UFLOW
argument_list|(
name|fp
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|_IO_setb
argument_list|,
operator|(
name|f
operator|,
name|b
operator|,
name|eb
operator|,
name|a
operator|)
argument_list|,
name|_IO_FILE
operator|*
name|f
name|AND
name|char
operator|*
name|b
name|AND
name|char
operator|*
name|eb
name|AND
name|int
name|a
argument_list|)
block|{
if|if
condition|(
name|f
operator|->
name|_IO_buf_base
operator|&&
operator|!
operator|(
name|f
operator|->
name|_flags
operator|&
name|_IO_USER_BUF
operator|)
condition|)
name|FREE_BUF
argument_list|(
name|f
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
name|f
operator|->
name|_IO_buf_base
operator|=
name|b
expr_stmt|;
name|f
operator|->
name|_IO_buf_end
operator|=
name|eb
expr_stmt|;
if|if
condition|(
name|a
condition|)
name|f
operator|->
name|_flags
operator|&=
operator|~
name|_IO_USER_BUF
expr_stmt|;
else|else
name|f
operator|->
name|_flags
operator||=
name|_IO_USER_BUF
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|_IO_doallocbuf
argument_list|,
operator|(
name|fp
operator|)
argument_list|,
specifier|register
name|_IO_FILE
operator|*
name|fp
argument_list|)
block|{
if|if
condition|(
name|fp
operator|->
name|_IO_buf_base
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_UNBUFFERED
operator|)
condition|)
if|if
condition|(
name|_IO_DOALLOCATE
argument_list|(
name|fp
argument_list|)
operator|!=
name|EOF
condition|)
return|return;
name|_IO_setb
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_shortbuf
argument_list|,
name|fp
operator|->
name|_shortbuf
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|DEFUN
argument_list|(
name|_IO_default_underflow
argument_list|,
operator|(
name|fp
operator|)
argument_list|,
name|_IO_FILE
operator|*
name|fp
argument_list|)
block|{
return|return
name|EOF
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|DEFUN
argument_list|(
name|_IO_default_uflow
argument_list|,
operator|(
name|fp
operator|)
argument_list|,
name|_IO_FILE
operator|*
name|fp
argument_list|)
block|{
name|int
name|ch
init|=
name|_IO_UNDERFLOW
argument_list|(
name|fp
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
return|return
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fp
operator|->
name|_IO_read_ptr
operator|++
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|_IO_size_t
name|DEFUN
argument_list|(
name|_IO_default_xsputn
argument_list|,
operator|(
name|f
operator|,
name|data
operator|,
name|n
operator|)
argument_list|,
specifier|register
name|_IO_FILE
operator|*
name|f
name|AND
specifier|const
name|void
operator|*
name|data
name|AND
name|_IO_size_t
name|n
argument_list|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|s
init|=
operator|(
name|char
operator|*
operator|)
name|data
decl_stmt|;
specifier|register
name|_IO_size_t
name|more
init|=
name|n
decl_stmt|;
if|if
condition|(
name|more
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|_IO_ssize_t
name|count
init|=
name|f
operator|->
name|_IO_write_end
operator|-
name|f
operator|->
name|_IO_write_ptr
decl_stmt|;
comment|/* Space available. */
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|>
name|more
condition|)
name|count
operator|=
name|more
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|20
condition|)
block|{
name|memcpy
argument_list|(
name|f
operator|->
name|_IO_write_ptr
argument_list|,
name|s
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|s
operator|+=
name|count
expr_stmt|;
name|f
operator|->
name|_IO_write_ptr
operator|+=
name|count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
name|count
operator|=
literal|0
expr_stmt|;
else|else
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|f
operator|->
name|_IO_write_ptr
decl_stmt|;
specifier|register
name|_IO_ssize_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|count
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|f
operator|->
name|_IO_write_ptr
operator|=
name|p
expr_stmt|;
block|}
name|more
operator|-=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|more
operator|==
literal|0
operator|||
name|__overflow
argument_list|(
name|f
argument_list|,
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
operator|++
argument_list|)
operator|==
name|EOF
condition|)
break|break;
name|more
operator|--
expr_stmt|;
block|}
return|return
name|n
operator|-
name|more
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|_IO_size_t
name|DEFUN
argument_list|(
name|_IO_sgetn
argument_list|,
operator|(
name|fp
operator|,
name|data
operator|,
name|n
operator|)
argument_list|,
name|_IO_FILE
operator|*
name|fp
name|AND
name|void
operator|*
name|data
name|AND
name|_IO_size_t
name|n
argument_list|)
block|{
comment|/* FIXME handle putback buffer here! */
return|return
name|_IO_XSGETN
argument_list|(
name|fp
argument_list|,
name|data
argument_list|,
name|n
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|_IO_size_t
name|DEFUN
argument_list|(
name|_IO_default_xsgetn
argument_list|,
operator|(
name|fp
operator|,
name|data
operator|,
name|n
operator|)
argument_list|,
name|_IO_FILE
operator|*
name|fp
name|AND
name|void
operator|*
name|data
name|AND
name|_IO_size_t
name|n
argument_list|)
block|{
specifier|register
name|_IO_size_t
name|more
init|=
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
init|=
operator|(
name|char
operator|*
operator|)
name|data
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|_IO_ssize_t
name|count
init|=
name|fp
operator|->
name|_IO_read_end
operator|-
name|fp
operator|->
name|_IO_read_ptr
decl_stmt|;
comment|/* Data available. */
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|>
name|more
condition|)
name|count
operator|=
name|more
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|20
condition|)
block|{
name|memcpy
argument_list|(
name|s
argument_list|,
name|fp
operator|->
name|_IO_read_ptr
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|s
operator|+=
name|count
expr_stmt|;
name|fp
operator|->
name|_IO_read_ptr
operator|+=
name|count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
name|count
operator|=
literal|0
expr_stmt|;
else|else
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|fp
operator|->
name|_IO_read_ptr
decl_stmt|;
specifier|register
name|int
name|i
init|=
operator|(
name|int
operator|)
name|count
decl_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
operator|*
name|s
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|p
expr_stmt|;
block|}
name|more
operator|-=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|more
operator|==
literal|0
operator|||
name|__underflow
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
break|break;
block|}
return|return
name|n
operator|-
name|more
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|DEFUN
argument_list|(
name|_IO_sync
argument_list|,
operator|(
name|fp
operator|)
argument_list|,
specifier|register
name|_IO_FILE
operator|*
name|fp
argument_list|)
block|{
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|_IO_FILE
modifier|*
name|DEFUN
argument_list|(
name|_IO_default_setbuf
argument_list|,
operator|(
name|fp
operator|,
name|p
operator|,
name|len
operator|)
argument_list|,
specifier|register
name|_IO_FILE
operator|*
name|fp
name|AND
name|char
operator|*
name|p
name|AND
name|_IO_ssize_t
name|len
argument_list|)
block|{
if|if
condition|(
name|_IO_SYNC
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|len
operator|==
literal|0
condition|)
block|{
name|fp
operator|->
name|_flags
operator||=
name|_IO_UNBUFFERED
expr_stmt|;
name|_IO_setb
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|_shortbuf
argument_list|,
name|fp
operator|->
name|_shortbuf
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|->
name|_flags
operator|&=
operator|~
name|_IO_UNBUFFERED
expr_stmt|;
name|_IO_setb
argument_list|(
name|fp
argument_list|,
name|p
argument_list|,
name|p
operator|+
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|fp
operator|->
name|_IO_write_base
operator|=
name|fp
operator|->
name|_IO_write_ptr
operator|=
name|fp
operator|->
name|_IO_write_end
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|_IO_read_base
operator|=
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_IO_read_end
operator|=
literal|0
expr_stmt|;
return|return
name|fp
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|_IO_pos_t
name|DEFUN
argument_list|(
name|_IO_default_seekpos
argument_list|,
operator|(
name|fp
operator|,
name|pos
operator|,
name|mode
operator|)
argument_list|,
name|_IO_FILE
operator|*
name|fp
name|AND
name|_IO_pos_t
name|pos
name|AND
name|int
name|mode
argument_list|)
block|{
return|return
name|_IO_SEEKOFF
argument_list|(
name|fp
argument_list|,
name|_IO_pos_as_off
argument_list|(
name|pos
argument_list|)
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|DEFUN
argument_list|(
name|_IO_default_doallocate
argument_list|,
operator|(
name|fp
operator|)
argument_list|,
name|_IO_FILE
operator|*
name|fp
argument_list|)
block|{
name|char
modifier|*
name|buf
init|=
name|ALLOC_BUF
argument_list|(
name|_IO_BUFSIZ
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
name|EOF
return|;
name|_IO_setb
argument_list|(
name|fp
argument_list|,
name|buf
argument_list|,
name|buf
operator|+
name|_IO_BUFSIZ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|_IO_init
argument_list|,
operator|(
name|fp
operator|,
name|flags
operator|)
argument_list|,
specifier|register
name|_IO_FILE
operator|*
name|fp
name|AND
name|int
name|flags
argument_list|)
block|{
name|fp
operator|->
name|_flags
operator|=
name|_IO_MAGIC
operator||
name|flags
expr_stmt|;
name|fp
operator|->
name|_IO_buf_base
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|_IO_buf_end
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|_IO_read_base
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|_IO_read_end
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|_IO_write_base
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|_IO_write_ptr
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|_IO_write_end
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|_chain
operator|=
name|NULL
expr_stmt|;
comment|/* Not necessary. */
name|fp
operator|->
name|_IO_save_base
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|_IO_backup_base
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|_IO_save_end
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|_markers
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|_cur_column
operator|=
literal|0
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|DEFUN
argument_list|(
name|_IO_default_sync
argument_list|,
operator|(
name|fp
operator|)
argument_list|,
name|_IO_FILE
operator|*
name|fp
argument_list|)
block|{
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|/* The way the C++ classes are mapped into the C functions in the    current implementation, this function can get called twice! */
end_comment

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|_IO_default_finish
argument_list|,
operator|(
name|fp
operator|)
argument_list|,
name|_IO_FILE
operator|*
name|fp
argument_list|)
block|{
name|struct
name|_IO_marker
modifier|*
name|mark
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|_IO_buf_base
operator|&&
operator|!
operator|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_USER_BUF
operator|)
condition|)
block|{
name|FREE_BUF
argument_list|(
name|fp
operator|->
name|_IO_buf_base
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_buf_base
operator|=
name|fp
operator|->
name|_IO_buf_end
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|mark
operator|=
name|fp
operator|->
name|_markers
init|;
name|mark
operator|!=
name|NULL
condition|;
name|mark
operator|=
name|mark
operator|->
name|_next
control|)
name|mark
operator|->
name|_sbuf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|_IO_save_base
condition|)
block|{
name|free
argument_list|(
name|fp
operator|->
name|_IO_save_base
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_save_base
operator|=
name|NULL
expr_stmt|;
block|}
name|_IO_un_link
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|_IO_pos_t
name|DEFUN
argument_list|(
name|_IO_default_seekoff
argument_list|,
operator|(
name|fp
operator|,
name|offset
operator|,
name|dir
operator|,
name|mode
operator|)
argument_list|,
specifier|register
name|_IO_FILE
operator|*
name|fp
name|AND
name|_IO_off_t
name|offset
name|AND
name|int
name|dir
name|AND
name|int
name|mode
argument_list|)
block|{
return|return
name|_IO_pos_BAD
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|DEFUN
argument_list|(
name|_IO_sputbackc
argument_list|,
operator|(
name|fp
operator|,
name|c
operator|)
argument_list|,
specifier|register
name|_IO_FILE
operator|*
name|fp
name|AND
name|int
name|c
argument_list|)
block|{
name|int
name|result
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|_IO_read_ptr
operator|>
name|fp
operator|->
name|_IO_read_base
operator|&&
operator|(
name|unsigned
name|char
operator|)
name|fp
operator|->
name|_IO_read_ptr
index|[
operator|-
literal|1
index|]
operator|==
operator|(
name|unsigned
name|char
operator|)
name|c
condition|)
block|{
name|fp
operator|->
name|_IO_read_ptr
operator|--
expr_stmt|;
name|result
operator|=
operator|(
name|unsigned
name|char
operator|)
name|c
expr_stmt|;
block|}
else|else
name|result
operator|=
name|_IO_PBACKFAIL
argument_list|(
name|fp
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|EOF
condition|)
name|fp
operator|->
name|_flags
operator|&=
operator|~
name|_IO_EOF_SEEN
expr_stmt|;
return|return
name|result
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|DEFUN
argument_list|(
name|_IO_sungetc
argument_list|,
operator|(
name|fp
operator|)
argument_list|,
specifier|register
name|_IO_FILE
operator|*
name|fp
argument_list|)
block|{
name|int
name|result
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|_IO_read_ptr
operator|>
name|fp
operator|->
name|_IO_read_base
condition|)
block|{
name|fp
operator|->
name|_IO_read_ptr
operator|--
expr_stmt|;
name|result
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|fp
operator|->
name|_IO_read_ptr
expr_stmt|;
block|}
else|else
name|result
operator|=
name|_IO_PBACKFAIL
argument_list|(
name|fp
argument_list|,
name|EOF
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|EOF
condition|)
name|fp
operator|->
name|_flags
operator|&=
operator|~
name|_IO_EOF_SEEN
expr_stmt|;
return|return
name|result
return|;
block|}
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Work in progress */
end_comment

begin_else
unit|void DEFUN(_IO_set_column, (fp, c),       register _IO_FILE *fp AND int c) {   if (c == -1)     fp->_column = -1;   else     fp->_column = c - (fp->_IO_write_ptr - fp->_IO_write_base); }
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|DEFUN
argument_list|(
name|_IO_set_column
argument_list|,
operator|(
name|fp
operator|,
name|i
operator|)
argument_list|,
specifier|register
name|_IO_FILE
operator|*
name|fp
name|AND
name|int
name|i
argument_list|)
block|{
name|fp
operator|->
name|_cur_column
operator|=
name|i
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|unsigned
name|DEFUN
argument_list|(
name|_IO_adjust_column
argument_list|,
operator|(
name|start
operator|,
name|line
operator|,
name|count
operator|)
argument_list|,
name|unsigned
name|start
name|AND
specifier|const
name|char
operator|*
name|line
name|AND
name|int
name|count
argument_list|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|ptr
init|=
name|line
operator|+
name|count
decl_stmt|;
while|while
condition|(
name|ptr
operator|>
name|line
condition|)
if|if
condition|(
operator|*
operator|--
name|ptr
operator|==
literal|'\n'
condition|)
return|return
name|line
operator|+
name|count
operator|-
name|ptr
operator|-
literal|1
return|;
return|return
name|start
operator|+
name|count
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|DEFUN
argument_list|(
name|_IO_get_column
argument_list|,
operator|(
name|fp
operator|)
argument_list|,
specifier|register
name|_IO_FILE
operator|*
name|fp
argument_list|)
block|{
if|if
condition|(
name|fp
operator|->
name|_cur_column
condition|)
return|return
name|_IO_adjust_column
argument_list|(
name|fp
operator|->
name|_cur_column
operator|-
literal|1
argument_list|,
name|fp
operator|->
name|_IO_write_base
argument_list|,
name|fp
operator|->
name|_IO_write_ptr
operator|-
name|fp
operator|->
name|_IO_write_base
argument_list|)
return|;
return|return
operator|-
literal|1
return|;
block|}
end_decl_stmt

begin_function
name|int
name|DEFUN_VOID
parameter_list|(
name|_IO_flush_all
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|fp
operator|=
name|_IO_list_all
init|;
name|fp
operator|!=
name|NULL
condition|;
name|fp
operator|=
name|fp
operator|->
name|_chain
control|)
if|if
condition|(
name|fp
operator|->
name|_IO_write_ptr
operator|>
name|fp
operator|->
name|_IO_write_base
operator|&&
name|_IO_OVERFLOW
argument_list|(
name|fp
argument_list|,
name|EOF
argument_list|)
operator|==
name|EOF
condition|)
name|result
operator|=
name|EOF
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|void
name|DEFUN_VOID
parameter_list|(
name|_IO_flush_all_linebuffered
parameter_list|)
block|{
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|fp
operator|=
name|_IO_list_all
init|;
name|fp
operator|!=
name|NULL
condition|;
name|fp
operator|=
name|fp
operator|->
name|_chain
control|)
if|if
condition|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_LINE_BUF
condition|)
name|_IO_OVERFLOW
argument_list|(
name|fp
argument_list|,
name|EOF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|DEFUN_VOID
parameter_list|(
name|_IO_unbuffer_all
parameter_list|)
block|{
name|_IO_FILE
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|fp
operator|=
name|_IO_list_all
init|;
name|fp
operator|!=
name|NULL
condition|;
name|fp
operator|=
name|fp
operator|->
name|_chain
control|)
if|if
condition|(
operator|!
operator|(
name|fp
operator|->
name|_flags
operator|&
name|_IO_UNBUFFERED
operator|)
condition|)
name|_IO_SETBUF
argument_list|(
name|fp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|DEFUN_VOID
parameter_list|(
name|_IO_cleanup
parameter_list|)
block|{
name|_IO_flush_all
argument_list|()
expr_stmt|;
comment|/* We currently don't have a reliable mechanism for making sure that      C++ static destructors are executed in the correct order.      So it is possible that other static destructord might want to      write to cout - and they're supposed to be able to do so.       The following will make the standard streambufs be unbuffered,       which forces any output from late destructors to be written out. */
name|_IO_unbuffer_all
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|_IO_init_marker
argument_list|,
operator|(
name|marker
operator|,
name|fp
operator|)
argument_list|,
expr|struct
name|_IO_marker
operator|*
name|marker
name|AND
name|_IO_FILE
operator|*
name|fp
argument_list|)
block|{
name|marker
operator|->
name|_sbuf
operator|=
name|fp
expr_stmt|;
if|if
condition|(
name|_IO_in_put_mode
argument_list|(
name|fp
argument_list|)
condition|)
name|_IO_switch_to_get_mode
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
name|marker
operator|->
name|_pos
operator|=
name|fp
operator|->
name|_IO_read_ptr
operator|-
name|fp
operator|->
name|_IO_read_end
expr_stmt|;
else|else
name|marker
operator|->
name|_pos
operator|=
name|fp
operator|->
name|_IO_read_ptr
operator|-
name|fp
operator|->
name|_IO_read_base
expr_stmt|;
comment|/* Should perhaps sort the chain? */
name|marker
operator|->
name|_next
operator|=
name|fp
operator|->
name|_markers
expr_stmt|;
name|fp
operator|->
name|_markers
operator|=
name|marker
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|_IO_remove_marker
argument_list|,
operator|(
name|marker
operator|)
argument_list|,
specifier|register
expr|struct
name|_IO_marker
operator|*
name|marker
argument_list|)
block|{
comment|/* Unlink from sb's chain. */
specifier|register
name|struct
name|_IO_marker
modifier|*
modifier|*
name|ptr
init|=
operator|&
name|marker
operator|->
name|_sbuf
operator|->
name|_markers
decl_stmt|;
for|for
control|(
init|;
condition|;
name|ptr
operator|=
operator|&
operator|(
operator|*
name|ptr
operator|)
operator|->
name|_next
control|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|==
name|NULL
condition|)
break|break;
elseif|else
if|if
condition|(
operator|*
name|ptr
operator|==
name|marker
condition|)
block|{
operator|*
name|ptr
operator|=
name|marker
operator|->
name|_next
expr_stmt|;
return|return;
block|}
block|}
if|#
directive|if
literal|0
block|if _sbuf has a backup area that is no longer needed, should we delete     it now, or wait until the next underflow?
endif|#
directive|endif
block|}
end_decl_stmt

begin_define
define|#
directive|define
name|BAD_DELTA
value|EOF
end_define

begin_decl_stmt
name|int
name|DEFUN
argument_list|(
name|_IO_marker_difference
argument_list|,
operator|(
name|mark1
operator|,
name|mark2
operator|)
argument_list|,
expr|struct
name|_IO_marker
operator|*
name|mark1
name|AND
expr|struct
name|_IO_marker
operator|*
name|mark2
argument_list|)
block|{
return|return
name|mark1
operator|->
name|_pos
operator|-
name|mark2
operator|->
name|_pos
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Return difference between MARK and current posistion of MARK's stream. */
end_comment

begin_decl_stmt
name|int
name|DEFUN
argument_list|(
name|_IO_marker_delta
argument_list|,
operator|(
name|mark
operator|)
argument_list|,
expr|struct
name|_IO_marker
operator|*
name|mark
argument_list|)
block|{
name|int
name|cur_pos
decl_stmt|;
if|if
condition|(
name|mark
operator|->
name|_sbuf
operator|==
name|NULL
condition|)
return|return
name|BAD_DELTA
return|;
if|if
condition|(
name|_IO_in_backup
argument_list|(
name|mark
operator|->
name|_sbuf
argument_list|)
condition|)
name|cur_pos
operator|=
name|mark
operator|->
name|_sbuf
operator|->
name|_IO_read_ptr
operator|-
name|mark
operator|->
name|_sbuf
operator|->
name|_IO_read_end
expr_stmt|;
else|else
name|cur_pos
operator|=
name|mark
operator|->
name|_sbuf
operator|->
name|_IO_read_ptr
operator|-
name|mark
operator|->
name|_sbuf
operator|->
name|_IO_read_base
expr_stmt|;
return|return
name|mark
operator|->
name|_pos
operator|-
name|cur_pos
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|DEFUN
argument_list|(
name|_IO_seekmark
argument_list|,
operator|(
name|fp
operator|,
name|mark
operator|,
name|delta
operator|)
argument_list|,
name|_IO_FILE
operator|*
name|fp
name|AND
expr|struct
name|_IO_marker
operator|*
name|mark
name|AND
name|int
name|delta
argument_list|)
block|{
if|if
condition|(
name|mark
operator|->
name|_sbuf
operator|!=
name|fp
condition|)
return|return
name|EOF
return|;
if|if
condition|(
name|mark
operator|->
name|_pos
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
name|_IO_switch_to_main_get_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_IO_read_base
operator|+
name|mark
operator|->
name|_pos
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
name|_IO_switch_to_backup_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|fp
operator|->
name|_IO_read_end
operator|+
name|mark
operator|->
name|_pos
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|_IO_unsave_markers
argument_list|,
operator|(
name|fp
operator|)
argument_list|,
specifier|register
name|_IO_FILE
operator|*
name|fp
argument_list|)
block|{
specifier|register
name|struct
name|_IO_marker
modifier|*
name|mark
init|=
name|fp
operator|->
name|_markers
decl_stmt|;
if|if
condition|(
name|mark
condition|)
block|{
ifdef|#
directive|ifdef
name|TODO
name|streampos
name|offset
init|=
name|seekoff
argument_list|(
literal|0
argument_list|,
name|ios
operator|::
name|cur
argument_list|,
name|ios
operator|::
name|in
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|!=
name|EOF
condition|)
block|{
name|offset
operator|+=
name|eGptr
argument_list|()
operator|-
name|Gbase
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|mark
operator|!=
name|NULL
condition|;
name|mark
operator|=
name|mark
operator|->
name|_next
control|)
name|mark
operator|->
name|set_streampos
argument_list|(
name|mark
operator|->
name|_pos
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|mark
operator|!=
name|NULL
condition|;
name|mark
operator|=
name|mark
operator|->
name|_next
control|)
name|mark
operator|->
name|set_streampos
argument_list|(
name|EOF
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|fp
operator|->
name|_markers
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|_IO_have_backup
argument_list|(
name|fp
argument_list|)
condition|)
name|_IO_free_backup_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|DEFUN
argument_list|(
name|_IO_nobackup_pbackfail
argument_list|,
operator|(
name|fp
operator|,
name|c
operator|)
argument_list|,
specifier|register
name|_IO_FILE
operator|*
name|fp
name|AND
name|int
name|c
argument_list|)
block|{
if|if
condition|(
name|fp
operator|->
name|_IO_read_ptr
operator|>
name|fp
operator|->
name|_IO_read_base
condition|)
name|fp
operator|->
name|_IO_read_ptr
operator|--
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
operator|&&
operator|*
name|fp
operator|->
name|_IO_read_ptr
operator|!=
name|c
condition|)
operator|*
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|unsigned
name|char
operator|)
name|c
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|DEFUN
argument_list|(
name|_IO_default_pbackfail
argument_list|,
operator|(
name|fp
operator|,
name|c
operator|)
argument_list|,
specifier|register
name|_IO_FILE
operator|*
name|fp
name|AND
name|int
name|c
argument_list|)
block|{
if|if
condition|(
name|fp
operator|->
name|_IO_read_ptr
operator|<=
name|fp
operator|->
name|_IO_read_base
condition|)
block|{
comment|/* Need to handle a filebuf in write mode (switch to read mode). FIXME!*/
if|if
condition|(
name|_IO_have_backup
argument_list|(
name|fp
argument_list|)
operator|&&
operator|!
name|_IO_in_backup
argument_list|(
name|fp
argument_list|)
condition|)
name|_IO_switch_to_backup_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|_IO_have_backup
argument_list|(
name|fp
argument_list|)
condition|)
block|{
comment|/* No backup buffer: allocate one. */
comment|/* Use nshort buffer, if unused? (probably not)  FIXME */
name|int
name|backup_size
init|=
literal|128
decl_stmt|;
name|char
modifier|*
name|bbuf
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|backup_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|bbuf
operator|==
name|NULL
condition|)
return|return
name|EOF
return|;
name|fp
operator|->
name|_IO_save_base
operator|=
name|bbuf
expr_stmt|;
name|fp
operator|->
name|_IO_save_end
operator|=
name|fp
operator|->
name|_IO_save_base
operator|+
name|backup_size
expr_stmt|;
name|fp
operator|->
name|_IO_backup_base
operator|=
name|fp
operator|->
name|_IO_save_end
expr_stmt|;
name|_IO_switch_to_backup_area
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fp
operator|->
name|_IO_read_ptr
operator|<=
name|fp
operator|->
name|_IO_read_base
condition|)
block|{
comment|/* Increase size of existing backup buffer. */
name|_IO_size_t
name|new_size
decl_stmt|;
name|_IO_size_t
name|old_size
init|=
name|fp
operator|->
name|_IO_read_end
operator|-
name|fp
operator|->
name|_IO_read_base
decl_stmt|;
name|char
modifier|*
name|new_buf
decl_stmt|;
name|new_size
operator|=
literal|2
operator|*
name|old_size
expr_stmt|;
name|new_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|new_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_buf
operator|==
name|NULL
condition|)
return|return
name|EOF
return|;
name|memcpy
argument_list|(
name|new_buf
operator|+
operator|(
name|new_size
operator|-
name|old_size
operator|)
argument_list|,
name|fp
operator|->
name|_IO_read_base
argument_list|,
name|old_size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fp
operator|->
name|_IO_read_base
argument_list|)
expr_stmt|;
name|_IO_setg
argument_list|(
name|fp
argument_list|,
name|new_buf
argument_list|,
name|new_buf
operator|+
operator|(
name|new_size
operator|-
name|old_size
operator|)
argument_list|,
name|new_buf
operator|+
name|new_size
argument_list|)
expr_stmt|;
name|fp
operator|->
name|_IO_backup_base
operator|=
name|fp
operator|->
name|_IO_read_ptr
expr_stmt|;
block|}
block|}
name|fp
operator|->
name|_IO_read_ptr
operator|--
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
operator|&&
operator|*
name|fp
operator|->
name|_IO_read_ptr
operator|!=
name|c
condition|)
operator|*
name|fp
operator|->
name|_IO_read_ptr
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|unsigned
name|char
operator|)
operator|*
name|fp
operator|->
name|_IO_read_ptr
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|_IO_pos_t
name|DEFUN
argument_list|(
name|_IO_default_seek
argument_list|,
operator|(
name|fp
operator|,
name|offset
operator|,
name|dir
operator|)
argument_list|,
name|_IO_FILE
operator|*
name|fp
name|AND
name|_IO_off_t
name|offset
name|AND
name|int
name|dir
argument_list|)
block|{
return|return
name|_IO_pos_BAD
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|DEFUN
argument_list|(
name|_IO_default_stat
argument_list|,
operator|(
name|fp
operator|,
name|st
operator|)
argument_list|,
name|_IO_FILE
operator|*
name|fp
name|AND
name|void
operator|*
name|st
argument_list|)
block|{
return|return
name|EOF
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|_IO_ssize_t
name|DEFUN
argument_list|(
name|_IO_default_read
argument_list|,
operator|(
name|fp
operator|,
name|data
operator|,
name|n
operator|)
argument_list|,
specifier|register
name|_IO_FILE
operator|*
name|fp
name|AND
name|void
operator|*
name|data
name|AND
name|_IO_ssize_t
name|n
argument_list|)
block|{
return|return
operator|-
literal|1
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|_IO_ssize_t
name|DEFUN
argument_list|(
name|_IO_default_write
argument_list|,
operator|(
name|fp
operator|,
name|data
operator|,
name|n
operator|)
argument_list|,
specifier|register
name|_IO_FILE
operator|*
name|fp
name|AND
specifier|const
name|void
operator|*
name|data
name|AND
name|_IO_ssize_t
name|n
argument_list|)
block|{
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TODO
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|linux
argument_list|)
end_if

begin_define
define|#
directive|define
name|IO_CLEANUP
value|;
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IO_CLEANUP
end_ifdef

begin_macro
name|IO_CLEANUP
end_macro

begin_else
else|#
directive|else
end_else

begin_struct
struct|struct
name|__io_defs
block|{
name|__io_defs
argument_list|()
block|{ }
operator|~
name|__io_defs
argument_list|()
block|{
name|_IO_cleanup
argument_list|()
block|; }
block|}
struct|;
end_struct

begin_decl_stmt
name|__io_defs
name|io_defs__
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TODO */
end_comment

end_unit

