begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_include
include|#
directive|include
file|<libuutil.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<libzfs.h>
end_include

begin_include
include|#
directive|include
file|"zfs_util.h"
end_include

begin_include
include|#
directive|include
file|"zfs_iter.h"
end_include

begin_comment
comment|/*  * This is a private interface used to gather up all the datasets specified on  * the command line so that we can iterate over them in order.  *  * First, we iterate over all filesystems, gathering them together into an  * AVL tree.  We report errors for any explicitly specified datasets  * that we couldn't open.  *  * When finished, we have an AVL tree of ZFS handles.  We go through and execute  * the provided callback for each one, passing whatever data the user supplied.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|zfs_node
block|{
name|zfs_handle_t
modifier|*
name|zn_handle
decl_stmt|;
name|uu_avl_node_t
name|zn_avlnode
decl_stmt|;
block|}
name|zfs_node_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|callback_data
block|{
name|uu_avl_t
modifier|*
name|cb_avl
decl_stmt|;
name|int
name|cb_recurse
decl_stmt|;
name|zfs_type_t
name|cb_types
decl_stmt|;
name|zfs_sort_column_t
modifier|*
name|cb_sortcol
decl_stmt|;
name|zfs_proplist_t
modifier|*
modifier|*
name|cb_proplist
decl_stmt|;
block|}
name|callback_data_t
typedef|;
end_typedef

begin_decl_stmt
name|uu_avl_pool_t
modifier|*
name|avl_pool
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Called for each dataset.  If the object the object is of an appropriate type,  * add it to the avl tree and recurse over any children as necessary.  */
end_comment

begin_function
name|int
name|zfs_callback
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|callback_data_t
modifier|*
name|cb
init|=
name|data
decl_stmt|;
name|int
name|dontclose
init|=
literal|0
decl_stmt|;
comment|/* 	 * If this object is of the appropriate type, add it to the AVL tree. 	 */
if|if
condition|(
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
operator|&
name|cb
operator|->
name|cb_types
condition|)
block|{
name|uu_avl_index_t
name|idx
decl_stmt|;
name|zfs_node_t
modifier|*
name|node
init|=
name|safe_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zfs_node_t
argument_list|)
argument_list|)
decl_stmt|;
name|node
operator|->
name|zn_handle
operator|=
name|zhp
expr_stmt|;
name|uu_avl_node_init
argument_list|(
name|node
argument_list|,
operator|&
name|node
operator|->
name|zn_avlnode
argument_list|,
name|avl_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|uu_avl_find
argument_list|(
name|cb
operator|->
name|cb_avl
argument_list|,
name|node
argument_list|,
name|cb
operator|->
name|cb_sortcol
argument_list|,
operator|&
name|idx
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|cb
operator|->
name|cb_proplist
operator|&&
name|zfs_expand_proplist
argument_list|(
name|zhp
argument_list|,
name|cb
operator|->
name|cb_proplist
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|uu_avl_insert
argument_list|(
name|cb
operator|->
name|cb_avl
argument_list|,
name|node
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|dontclose
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Recurse if necessary. 	 */
if|if
condition|(
name|cb
operator|->
name|cb_recurse
operator|&&
operator|(
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
operator|==
name|ZFS_TYPE_FILESYSTEM
operator|||
operator|(
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
operator|==
name|ZFS_TYPE_VOLUME
operator|&&
operator|(
name|cb
operator|->
name|cb_types
operator|&
name|ZFS_TYPE_SNAPSHOT
operator|)
operator|)
operator|)
condition|)
operator|(
name|void
operator|)
name|zfs_iter_children
argument_list|(
name|zhp
argument_list|,
name|zfs_callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dontclose
condition|)
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_add_sort_column
parameter_list|(
name|zfs_sort_column_t
modifier|*
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|boolean_t
name|reverse
parameter_list|)
block|{
name|zfs_sort_column_t
modifier|*
name|col
decl_stmt|;
name|zfs_prop_t
name|prop
decl_stmt|;
if|if
condition|(
operator|(
name|prop
operator|=
name|zfs_name_to_prop
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|ZFS_PROP_INVAL
operator|&&
operator|!
name|zfs_prop_user
argument_list|(
name|name
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|col
operator|=
name|safe_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zfs_sort_column_t
argument_list|)
argument_list|)
expr_stmt|;
name|col
operator|->
name|sc_prop
operator|=
name|prop
expr_stmt|;
name|col
operator|->
name|sc_reverse
operator|=
name|reverse
expr_stmt|;
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_INVAL
condition|)
block|{
name|col
operator|->
name|sc_user_prop
operator|=
name|safe_malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|col
operator|->
name|sc_user_prop
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|sc
operator|==
name|NULL
condition|)
block|{
name|col
operator|->
name|sc_last
operator|=
name|col
expr_stmt|;
operator|*
name|sc
operator|=
name|col
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|sc
operator|)
operator|->
name|sc_last
operator|->
name|sc_next
operator|=
name|col
expr_stmt|;
operator|(
operator|*
name|sc
operator|)
operator|->
name|sc_last
operator|=
name|col
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zfs_free_sort_columns
parameter_list|(
name|zfs_sort_column_t
modifier|*
name|sc
parameter_list|)
block|{
name|zfs_sort_column_t
modifier|*
name|col
decl_stmt|;
while|while
condition|(
name|sc
operator|!=
name|NULL
condition|)
block|{
name|col
operator|=
name|sc
operator|->
name|sc_next
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sc_user_prop
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|=
name|col
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|larg
parameter_list|,
specifier|const
name|void
modifier|*
name|rarg
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|l
init|=
operator|(
operator|(
name|zfs_node_t
operator|*
operator|)
name|larg
operator|)
operator|->
name|zn_handle
decl_stmt|;
name|zfs_handle_t
modifier|*
name|r
init|=
operator|(
operator|(
name|zfs_node_t
operator|*
operator|)
name|rarg
operator|)
operator|->
name|zn_handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|lname
init|=
name|zfs_get_name
argument_list|(
name|l
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|rname
init|=
name|zfs_get_name
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|char
modifier|*
name|lat
decl_stmt|,
modifier|*
name|rat
decl_stmt|;
name|uint64_t
name|lcreate
decl_stmt|,
name|rcreate
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|lat
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|lname
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
name|rat
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|rname
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|lat
operator|!=
name|NULL
condition|)
operator|*
name|lat
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|rat
operator|!=
name|NULL
condition|)
operator|*
name|rat
operator|=
literal|'\0'
expr_stmt|;
name|ret
operator|=
name|strcmp
argument_list|(
name|lname
argument_list|,
name|rname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If we're comparing a dataset to one of its snapshots, we 		 * always make the full dataset first. 		 */
if|if
condition|(
name|lat
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rat
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If we have two snapshots from the same dataset, then 			 * we want to sort them according to creation time.  We 			 * use the hidden CREATETXG property to get an absolute 			 * ordering of snapshots. 			 */
name|lcreate
operator|=
name|zfs_prop_get_int
argument_list|(
name|l
argument_list|,
name|ZFS_PROP_CREATETXG
argument_list|)
expr_stmt|;
name|rcreate
operator|=
name|zfs_prop_get_int
argument_list|(
name|r
argument_list|,
name|ZFS_PROP_CREATETXG
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcreate
operator|<
name|rcreate
condition|)
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|lcreate
operator|>
name|rcreate
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lat
operator|!=
name|NULL
condition|)
operator|*
name|lat
operator|=
literal|'@'
expr_stmt|;
if|if
condition|(
name|rat
operator|!=
name|NULL
condition|)
operator|*
name|rat
operator|=
literal|'@'
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sort datasets by specified columns.  *  * o  Numeric types sort in ascending order.  * o  String types sort in alphabetical order.  * o  Types inappropriate for a row sort that row to the literal  *    bottom, regardless of the specified ordering.  *  * If no sort columns are specified, or two datasets compare equally  * across all specified columns, they are sorted alphabetically by name  * with snapshots grouped under their parents.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_sort
parameter_list|(
specifier|const
name|void
modifier|*
name|larg
parameter_list|,
specifier|const
name|void
modifier|*
name|rarg
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|l
init|=
operator|(
operator|(
name|zfs_node_t
operator|*
operator|)
name|larg
operator|)
operator|->
name|zn_handle
decl_stmt|;
name|zfs_handle_t
modifier|*
name|r
init|=
operator|(
operator|(
name|zfs_node_t
operator|*
operator|)
name|rarg
operator|)
operator|->
name|zn_handle
decl_stmt|;
name|zfs_sort_column_t
modifier|*
name|sc
init|=
operator|(
name|zfs_sort_column_t
operator|*
operator|)
name|data
decl_stmt|;
name|zfs_sort_column_t
modifier|*
name|psc
decl_stmt|;
for|for
control|(
name|psc
operator|=
name|sc
init|;
name|psc
operator|!=
name|NULL
condition|;
name|psc
operator|=
name|psc
operator|->
name|sc_next
control|)
block|{
name|char
name|lbuf
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|,
name|rbuf
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
name|char
modifier|*
name|lstr
decl_stmt|,
modifier|*
name|rstr
decl_stmt|;
name|uint64_t
name|lnum
decl_stmt|,
name|rnum
decl_stmt|;
name|boolean_t
name|lvalid
decl_stmt|,
name|rvalid
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* 		 * We group the checks below the generic code.  If 'lstr' and 		 * 'rstr' are non-NULL, then we do a string based comparison. 		 * Otherwise, we compare 'lnum' and 'rnum'. 		 */
name|lstr
operator|=
name|rstr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|psc
operator|->
name|sc_prop
operator|==
name|ZFS_PROP_INVAL
condition|)
block|{
name|nvlist_t
modifier|*
name|luser
decl_stmt|,
modifier|*
name|ruser
decl_stmt|;
name|nvlist_t
modifier|*
name|lval
decl_stmt|,
modifier|*
name|rval
decl_stmt|;
name|luser
operator|=
name|zfs_get_user_props
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|ruser
operator|=
name|zfs_get_user_props
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|lvalid
operator|=
operator|(
name|nvlist_lookup_nvlist
argument_list|(
name|luser
argument_list|,
name|psc
operator|->
name|sc_user_prop
argument_list|,
operator|&
name|lval
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|rvalid
operator|=
operator|(
name|nvlist_lookup_nvlist
argument_list|(
name|ruser
argument_list|,
name|psc
operator|->
name|sc_user_prop
argument_list|,
operator|&
name|rval
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|lvalid
condition|)
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|lval
argument_list|,
name|ZFS_PROP_VALUE
argument_list|,
operator|&
name|lstr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rvalid
condition|)
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|rval
argument_list|,
name|ZFS_PROP_VALUE
argument_list|,
operator|&
name|rstr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zfs_prop_is_string
argument_list|(
name|psc
operator|->
name|sc_prop
argument_list|)
condition|)
block|{
name|lvalid
operator|=
operator|(
name|zfs_prop_get
argument_list|(
name|l
argument_list|,
name|psc
operator|->
name|sc_prop
argument_list|,
name|lbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|lbuf
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_TRUE
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|rvalid
operator|=
operator|(
name|zfs_prop_get
argument_list|(
name|r
argument_list|,
name|psc
operator|->
name|sc_prop
argument_list|,
name|rbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|rbuf
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_TRUE
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|lstr
operator|=
name|lbuf
expr_stmt|;
name|rstr
operator|=
name|rbuf
expr_stmt|;
block|}
else|else
block|{
name|lvalid
operator|=
name|zfs_prop_valid_for_type
argument_list|(
name|psc
operator|->
name|sc_prop
argument_list|,
name|zfs_get_type
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|rvalid
operator|=
name|zfs_prop_valid_for_type
argument_list|(
name|psc
operator|->
name|sc_prop
argument_list|,
name|zfs_get_type
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvalid
condition|)
operator|(
name|void
operator|)
name|zfs_prop_get_numeric
argument_list|(
name|l
argument_list|,
name|psc
operator|->
name|sc_prop
argument_list|,
operator|&
name|lnum
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rvalid
condition|)
operator|(
name|void
operator|)
name|zfs_prop_get_numeric
argument_list|(
name|r
argument_list|,
name|psc
operator|->
name|sc_prop
argument_list|,
operator|&
name|rnum
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|lvalid
operator|&&
operator|!
name|rvalid
condition|)
continue|continue;
elseif|else
if|if
condition|(
operator|!
name|lvalid
condition|)
return|return
operator|(
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
operator|!
name|rvalid
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|lstr
condition|)
name|ret
operator|=
name|strcmp
argument_list|(
name|lstr
argument_list|,
name|rstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnum
operator|<
name|rnum
condition|)
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|lnum
operator|>
name|rnum
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|psc
operator|->
name|sc_reverse
operator|==
name|B_TRUE
condition|)
name|ret
operator|=
operator|(
name|ret
operator|<
literal|0
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
return|return
operator|(
name|zfs_compare
argument_list|(
name|larg
argument_list|,
name|rarg
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_for_each
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|boolean_t
name|recurse
parameter_list|,
name|zfs_type_t
name|types
parameter_list|,
name|zfs_sort_column_t
modifier|*
name|sortcol
parameter_list|,
name|zfs_proplist_t
modifier|*
modifier|*
name|proplist
parameter_list|,
name|zfs_iter_f
name|callback
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|boolean_t
name|args_can_be_paths
parameter_list|)
block|{
name|callback_data_t
name|cb
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|zfs_node_t
modifier|*
name|node
decl_stmt|;
name|uu_avl_walk_t
modifier|*
name|walk
decl_stmt|;
name|avl_pool
operator|=
name|uu_avl_pool_create
argument_list|(
literal|"zfs_pool"
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zfs_node_t
argument_list|,
name|zn_avlnode
argument_list|)
argument_list|,
name|zfs_sort
argument_list|,
name|UU_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|avl_pool
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal error: out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|cb
operator|.
name|cb_sortcol
operator|=
name|sortcol
expr_stmt|;
name|cb
operator|.
name|cb_recurse
operator|=
name|recurse
expr_stmt|;
name|cb
operator|.
name|cb_proplist
operator|=
name|proplist
expr_stmt|;
name|cb
operator|.
name|cb_types
operator|=
name|types
expr_stmt|;
if|if
condition|(
operator|(
name|cb
operator|.
name|cb_avl
operator|=
name|uu_avl_create
argument_list|(
name|avl_pool
argument_list|,
name|NULL
argument_list|,
name|UU_DEFAULT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal error: out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If given no arguments, iterate over all datasets. 		 */
name|cb
operator|.
name|cb_recurse
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|zfs_iter_root
argument_list|(
name|g_zfs
argument_list|,
name|zfs_callback
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|zfs_type_t
name|argtype
decl_stmt|;
comment|/* 		 * If we're recursive, then we always allow filesystems as 		 * arguments.  If we also are interested in snapshots, then we 		 * can take volumes as well. 		 */
name|argtype
operator|=
name|types
expr_stmt|;
if|if
condition|(
name|recurse
condition|)
block|{
name|argtype
operator||=
name|ZFS_TYPE_FILESYSTEM
expr_stmt|;
if|if
condition|(
name|types
operator|&
name|ZFS_TYPE_SNAPSHOT
condition|)
name|argtype
operator||=
name|ZFS_TYPE_VOLUME
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|args_can_be_paths
condition|)
block|{
name|zhp
operator|=
name|zfs_path_to_zhandle
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|argtype
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zhp
operator|=
name|zfs_open
argument_list|(
name|g_zfs
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|argtype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zhp
operator|!=
name|NULL
condition|)
name|ret
operator||=
name|zfs_callback
argument_list|(
name|zhp
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * At this point we've got our AVL tree full of zfs handles, so iterate 	 * over each one and execute the real user callback. 	 */
for|for
control|(
name|node
operator|=
name|uu_avl_first
argument_list|(
name|cb
operator|.
name|cb_avl
argument_list|)
init|;
name|node
operator|!=
name|NULL
condition|;
name|node
operator|=
name|uu_avl_next
argument_list|(
name|cb
operator|.
name|cb_avl
argument_list|,
name|node
argument_list|)
control|)
name|ret
operator||=
name|callback
argument_list|(
name|node
operator|->
name|zn_handle
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* 	 * Finally, clean up the AVL tree. 	 */
if|if
condition|(
operator|(
name|walk
operator|=
name|uu_avl_walk_start
argument_list|(
name|cb
operator|.
name|cb_avl
argument_list|,
name|UU_WALK_ROBUST
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"internal error: out of memory"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|node
operator|=
name|uu_avl_walk_next
argument_list|(
name|walk
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|uu_avl_remove
argument_list|(
name|cb
operator|.
name|cb_avl
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|node
operator|->
name|zn_handle
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|uu_avl_walk_end
argument_list|(
name|walk
argument_list|)
expr_stmt|;
name|uu_avl_destroy
argument_list|(
name|cb
operator|.
name|cb_avl
argument_list|)
expr_stmt|;
name|uu_avl_pool_destroy
argument_list|(
name|avl_pool
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

