begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_comment
comment|/*  * Pool import support functions.  *  * To import a pool, we rely on reading the configuration information from the  * ZFS label of each device.  If we successfully read the label, then we  * organize the configuration information in the following hierarchy:  *  * 	pool guid -> toplevel vdev guid -> label txg  *  * Duplicate entries matching this same tuple will be discarded.  Once we have  * examined every device, we pick the best label txg config for each toplevel  * vdev.  We then arrange these toplevel vdevs into a complete pool config, and  * update any paths that have changed.  Finally, we attempt to import the pool  * using our derived config, and record the results.  */
end_comment

begin_include
include|#
directive|include
file|<devid.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<libgeom.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|"libzfs.h"
end_include

begin_include
include|#
directive|include
file|"libzfs_impl.h"
end_include

begin_comment
comment|/*  * Intermediate structures used to gather configuration information.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|config_entry
block|{
name|uint64_t
name|ce_txg
decl_stmt|;
name|nvlist_t
modifier|*
name|ce_config
decl_stmt|;
name|struct
name|config_entry
modifier|*
name|ce_next
decl_stmt|;
block|}
name|config_entry_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|vdev_entry
block|{
name|uint64_t
name|ve_guid
decl_stmt|;
name|config_entry_t
modifier|*
name|ve_configs
decl_stmt|;
name|struct
name|vdev_entry
modifier|*
name|ve_next
decl_stmt|;
block|}
name|vdev_entry_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|pool_entry
block|{
name|uint64_t
name|pe_guid
decl_stmt|;
name|vdev_entry_t
modifier|*
name|pe_vdevs
decl_stmt|;
name|struct
name|pool_entry
modifier|*
name|pe_next
decl_stmt|;
block|}
name|pool_entry_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|name_entry
block|{
name|char
modifier|*
name|ne_name
decl_stmt|;
name|uint64_t
name|ne_guid
decl_stmt|;
name|struct
name|name_entry
modifier|*
name|ne_next
decl_stmt|;
block|}
name|name_entry_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|pool_list
block|{
name|pool_entry_t
modifier|*
name|pools
decl_stmt|;
name|name_entry_t
modifier|*
name|names
decl_stmt|;
block|}
name|pool_list_t
typedef|;
end_typedef

begin_function
specifier|static
name|char
modifier|*
name|get_devid
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|ddi_devid_t
name|devid
decl_stmt|;
name|char
modifier|*
name|minor
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|minor
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|devid_get
argument_list|(
name|fd
argument_list|,
operator|&
name|devid
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|devid_get_minor_name
argument_list|(
name|fd
argument_list|,
operator|&
name|minor
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
name|devid_str_encode
argument_list|(
name|devid
argument_list|,
name|minor
argument_list|)
expr_stmt|;
if|if
condition|(
name|minor
operator|!=
name|NULL
condition|)
name|devid_str_free
argument_list|(
name|minor
argument_list|)
expr_stmt|;
name|devid_free
argument_list|(
name|devid
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Go through and fix up any path and/or devid information for the given vdev  * configuration.  */
end_comment

begin_function
specifier|static
name|int
name|fix_paths
parameter_list|(
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|name_entry_t
modifier|*
name|names
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|;
name|name_entry_t
modifier|*
name|ne
decl_stmt|,
modifier|*
name|best
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|devid
decl_stmt|;
name|int
name|matched
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|fix_paths
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|names
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * This is a leaf (file or disk) vdev.  In either case, go through 	 * the name list and see if we find a matching guid.  If so, replace 	 * the path and see if we can calculate a new devid. 	 * 	 * There may be multiple names associated with a particular guid, in 	 * which case we have overlapping slices or multiple paths to the same 	 * disk.  If this is the case, then we want to pick the path that is 	 * the most similar to the original, where "most similar" is the number 	 * of matching characters starting from the end of the path.  This will 	 * preserve slice numbers even if the disks have been reorganized, and 	 * will also catch preferred disk names if multiple paths exist. 	 */
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
operator|&
name|path
argument_list|)
operator|!=
literal|0
condition|)
name|path
operator|=
name|NULL
expr_stmt|;
name|matched
operator|=
literal|0
expr_stmt|;
name|best
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ne
operator|=
name|names
init|;
name|ne
operator|!=
name|NULL
condition|;
name|ne
operator|=
name|ne
operator|->
name|ne_next
control|)
block|{
if|if
condition|(
name|ne
operator|->
name|ne_guid
operator|==
name|guid
condition|)
block|{
specifier|const
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|best
operator|=
name|ne
expr_stmt|;
break|break;
block|}
name|src
operator|=
name|ne
operator|->
name|ne_name
operator|+
name|strlen
argument_list|(
name|ne
operator|->
name|ne_name
argument_list|)
operator|-
literal|1
expr_stmt|;
name|dst
operator|=
name|path
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|src
operator|>=
name|ne
operator|->
name|ne_name
operator|&&
name|dst
operator|>=
name|path
condition|;
name|src
operator|--
operator|,
name|dst
operator|--
operator|,
name|count
operator|++
control|)
if|if
condition|(
operator|*
name|src
operator|!=
operator|*
name|dst
condition|)
break|break;
comment|/* 			 * At this point, 'count' is the number of characters 			 * matched from the end. 			 */
if|if
condition|(
name|count
operator|>
name|matched
operator|||
name|best
operator|==
name|NULL
condition|)
block|{
name|best
operator|=
name|ne
expr_stmt|;
name|matched
operator|=
name|count
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|best
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
name|best
operator|->
name|ne_name
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|devid
operator|=
name|get_devid
argument_list|(
name|best
operator|->
name|ne_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|nvlist_remove_all
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_DEVID
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_DEVID
argument_list|,
name|devid
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|devid_str_free
argument_list|(
name|devid
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add the given configuration to the list of known devices.  */
end_comment

begin_function
specifier|static
name|int
name|add_config
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|pool_list_t
modifier|*
name|pl
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|)
block|{
name|uint64_t
name|pool_guid
decl_stmt|,
name|vdev_guid
decl_stmt|,
name|top_guid
decl_stmt|,
name|txg
decl_stmt|,
name|state
decl_stmt|;
name|pool_entry_t
modifier|*
name|pe
decl_stmt|;
name|vdev_entry_t
modifier|*
name|ve
decl_stmt|;
name|config_entry_t
modifier|*
name|ce
decl_stmt|;
name|name_entry_t
modifier|*
name|ne
decl_stmt|;
comment|/* 	 * If this is a hot spare not currently in use, add it to the list of 	 * names to translate, but don't do anything else. 	 */
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
operator|&
name|state
argument_list|)
operator|==
literal|0
operator|&&
name|state
operator|==
name|POOL_STATE_SPARE
operator|&&
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|vdev_guid
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ne
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|name_entry_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|ne
operator|->
name|ne_name
operator|=
name|zfs_strdup
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ne
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ne
operator|->
name|ne_guid
operator|=
name|vdev_guid
expr_stmt|;
name|ne
operator|->
name|ne_next
operator|=
name|pl
operator|->
name|names
expr_stmt|;
name|pl
operator|->
name|names
operator|=
name|ne
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If we have a valid config but cannot read any of these fields, then 	 * it means we have a half-initialized label.  In vdev_label_init() 	 * we write a label with txg == 0 so that we can identify the device 	 * in case the user refers to the same disk later on.  If we fail to 	 * create the pool, we'll be left with a label in this state 	 * which should not be considered part of a valid pool. 	 */
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
operator|&
name|pool_guid
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|vdev_guid
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_TOP_GUID
argument_list|,
operator|&
name|top_guid
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_TXG
argument_list|,
operator|&
name|txg
argument_list|)
operator|!=
literal|0
operator|||
name|txg
operator|==
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * First, see if we know about this pool.  If not, then add it to the 	 * list of known pools. 	 */
for|for
control|(
name|pe
operator|=
name|pl
operator|->
name|pools
init|;
name|pe
operator|!=
name|NULL
condition|;
name|pe
operator|=
name|pe
operator|->
name|pe_next
control|)
block|{
if|if
condition|(
name|pe
operator|->
name|pe_guid
operator|==
name|pool_guid
condition|)
break|break;
block|}
if|if
condition|(
name|pe
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|pe
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|pool_entry_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pe
operator|->
name|pe_guid
operator|=
name|pool_guid
expr_stmt|;
name|pe
operator|->
name|pe_next
operator|=
name|pl
operator|->
name|pools
expr_stmt|;
name|pl
operator|->
name|pools
operator|=
name|pe
expr_stmt|;
block|}
comment|/* 	 * Second, see if we know about this toplevel vdev.  Add it if its 	 * missing. 	 */
for|for
control|(
name|ve
operator|=
name|pe
operator|->
name|pe_vdevs
init|;
name|ve
operator|!=
name|NULL
condition|;
name|ve
operator|=
name|ve
operator|->
name|ve_next
control|)
block|{
if|if
condition|(
name|ve
operator|->
name|ve_guid
operator|==
name|top_guid
condition|)
break|break;
block|}
if|if
condition|(
name|ve
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ve
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_entry_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ve
operator|->
name|ve_guid
operator|=
name|top_guid
expr_stmt|;
name|ve
operator|->
name|ve_next
operator|=
name|pe
operator|->
name|pe_vdevs
expr_stmt|;
name|pe
operator|->
name|pe_vdevs
operator|=
name|ve
expr_stmt|;
block|}
comment|/* 	 * Third, see if we have a config with a matching transaction group.  If 	 * so, then we do nothing.  Otherwise, add it to the list of known 	 * configs. 	 */
for|for
control|(
name|ce
operator|=
name|ve
operator|->
name|ve_configs
init|;
name|ce
operator|!=
name|NULL
condition|;
name|ce
operator|=
name|ce
operator|->
name|ce_next
control|)
block|{
if|if
condition|(
name|ce
operator|->
name|ce_txg
operator|==
name|txg
condition|)
break|break;
block|}
if|if
condition|(
name|ce
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ce
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|config_entry_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ce
operator|->
name|ce_txg
operator|=
name|txg
expr_stmt|;
name|ce
operator|->
name|ce_config
operator|=
name|config
expr_stmt|;
name|ce
operator|->
name|ce_next
operator|=
name|ve
operator|->
name|ve_configs
expr_stmt|;
name|ve
operator|->
name|ve_configs
operator|=
name|ce
expr_stmt|;
block|}
else|else
block|{
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * At this point we've successfully added our config to the list of 	 * known configs.  The last thing to do is add the vdev guid -> path 	 * mappings so that we can fix up the configuration as necessary before 	 * doing the import. 	 */
if|if
condition|(
operator|(
name|ne
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|name_entry_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|ne
operator|->
name|ne_name
operator|=
name|zfs_strdup
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ne
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ne
operator|->
name|ne_guid
operator|=
name|vdev_guid
expr_stmt|;
name|ne
operator|->
name|ne_next
operator|=
name|pl
operator|->
name|names
expr_stmt|;
name|pl
operator|->
name|names
operator|=
name|ne
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns true if the named pool matches the given GUID.  */
end_comment

begin_function
specifier|static
name|int
name|pool_active
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|boolean_t
modifier|*
name|isactive
parameter_list|)
block|{
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|uint64_t
name|theguid
decl_stmt|;
if|if
condition|(
name|zpool_open_silent
argument_list|(
name|hdl
argument_list|,
name|name
argument_list|,
operator|&
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
block|{
operator|*
name|isactive
operator|=
name|B_FALSE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|zhp
operator|->
name|zpool_config
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
operator|&
name|theguid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
operator|*
name|isactive
operator|=
operator|(
name|theguid
operator|==
name|guid
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert our list of pools into the definitive set of configurations.  We  * start by picking the best config for each toplevel vdev.  Once that's done,  * we assemble the toplevel vdevs into a full config for the pool.  We make a  * pass to fix up any incorrect paths, and then add it to the main list to  * return to the user.  */
end_comment

begin_function
specifier|static
name|nvlist_t
modifier|*
name|get_configs
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|pool_list_t
modifier|*
name|pl
parameter_list|)
block|{
name|pool_entry_t
modifier|*
name|pe
decl_stmt|;
name|vdev_entry_t
modifier|*
name|ve
decl_stmt|;
name|config_entry_t
modifier|*
name|ce
decl_stmt|;
name|nvlist_t
modifier|*
name|ret
init|=
name|NULL
decl_stmt|,
modifier|*
name|config
init|=
name|NULL
decl_stmt|,
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|nvtop
decl_stmt|,
modifier|*
name|nvroot
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|spares
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|nspares
decl_stmt|;
name|boolean_t
name|config_seen
decl_stmt|;
name|uint64_t
name|best_txg
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|hostname
decl_stmt|;
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|uint64_t
name|version
decl_stmt|,
name|guid
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint_t
name|children
init|=
literal|0
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|child
init|=
name|NULL
decl_stmt|;
name|uint_t
name|c
decl_stmt|;
name|boolean_t
name|isactive
decl_stmt|;
name|uint64_t
name|hostid
decl_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|ret
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|nomem
goto|;
for|for
control|(
name|pe
operator|=
name|pl
operator|->
name|pools
init|;
name|pe
operator|!=
name|NULL
condition|;
name|pe
operator|=
name|pe
operator|->
name|pe_next
control|)
block|{
name|uint64_t
name|id
decl_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|config
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|nomem
goto|;
name|config_seen
operator|=
name|B_FALSE
expr_stmt|;
comment|/* 		 * Iterate over all toplevel vdevs.  Grab the pool configuration 		 * from the first one we find, and then go through the rest and 		 * add them as necessary to the 'vdevs' member of the config. 		 */
for|for
control|(
name|ve
operator|=
name|pe
operator|->
name|pe_vdevs
init|;
name|ve
operator|!=
name|NULL
condition|;
name|ve
operator|=
name|ve
operator|->
name|ve_next
control|)
block|{
comment|/* 			 * Determine the best configuration for this vdev by 			 * selecting the config with the latest transaction 			 * group. 			 */
name|best_txg
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ce
operator|=
name|ve
operator|->
name|ve_configs
init|;
name|ce
operator|!=
name|NULL
condition|;
name|ce
operator|=
name|ce
operator|->
name|ce_next
control|)
block|{
if|if
condition|(
name|ce
operator|->
name|ce_txg
operator|>
name|best_txg
condition|)
block|{
name|tmp
operator|=
name|ce
operator|->
name|ce_config
expr_stmt|;
name|best_txg
operator|=
name|ce
operator|->
name|ce_txg
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|config_seen
condition|)
block|{
comment|/* 				 * Copy the relevant pieces of data to the pool 				 * configuration: 				 * 				 *	version 				 * 	pool guid 				 * 	name 				 * 	pool state 				 *	hostid (if available) 				 *	hostname (if available) 				 */
name|uint64_t
name|state
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|tmp
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|,
operator|&
name|version
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|,
name|version
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|nomem
goto|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|tmp
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
name|guid
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|nomem
goto|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|tmp
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
operator|&
name|name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
name|name
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|nomem
goto|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|tmp
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
operator|&
name|state
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
name|state
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|nomem
goto|;
name|hostid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|tmp
argument_list|,
name|ZPOOL_CONFIG_HOSTID
argument_list|,
operator|&
name|hostid
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_HOSTID
argument_list|,
name|hostid
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|nomem
goto|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|tmp
argument_list|,
name|ZPOOL_CONFIG_HOSTNAME
argument_list|,
operator|&
name|hostname
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_HOSTNAME
argument_list|,
name|hostname
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|nomem
goto|;
block|}
name|config_seen
operator|=
name|B_TRUE
expr_stmt|;
block|}
comment|/* 			 * Add this top-level vdev to the child array. 			 */
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|tmp
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvtop
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nvtop
argument_list|,
name|ZPOOL_CONFIG_ID
argument_list|,
operator|&
name|id
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|>=
name|children
condition|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|newchild
decl_stmt|;
name|newchild
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
operator|(
name|id
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|nvlist_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newchild
operator|==
name|NULL
condition|)
goto|goto
name|nomem
goto|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
name|newchild
index|[
name|c
index|]
operator|=
name|child
index|[
name|c
index|]
expr_stmt|;
name|free
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|child
operator|=
name|newchild
expr_stmt|;
name|children
operator|=
name|id
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|nvlist_dup
argument_list|(
name|nvtop
argument_list|,
operator|&
name|child
index|[
name|id
index|]
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|nomem
goto|;
block|}
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Look for any missing top-level vdevs.  If this is the case, 		 * create a faked up 'missing' vdev as a placeholder.  We cannot 		 * simply compress the child array, because the kernel performs 		 * certain checks to make sure the vdev IDs match their location 		 * in the configuration. 		 */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|child
index|[
name|c
index|]
operator|==
name|NULL
condition|)
block|{
name|nvlist_t
modifier|*
name|missing
decl_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|missing
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|nomem
goto|;
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|missing
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
name|VDEV_TYPE_MISSING
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_add_uint64
argument_list|(
name|missing
argument_list|,
name|ZPOOL_CONFIG_ID
argument_list|,
name|c
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_add_uint64
argument_list|(
name|missing
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
literal|0ULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|missing
argument_list|)
expr_stmt|;
goto|goto
name|nomem
goto|;
block|}
name|child
index|[
name|c
index|]
operator|=
name|missing
expr_stmt|;
block|}
comment|/* 		 * Put all of this pool's top-level vdevs into a root vdev. 		 */
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|nvroot
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|nomem
goto|;
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
name|VDEV_TYPE_ROOT
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_add_uint64
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_ID
argument_list|,
literal|0ULL
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_add_uint64
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
name|guid
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_add_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
name|child
argument_list|,
name|children
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
goto|goto
name|nomem
goto|;
block|}
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
name|nvlist_free
argument_list|(
name|child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|children
operator|=
literal|0
expr_stmt|;
name|child
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * Go through and fix up any paths and/or devids based on our 		 * known list of vdev GUID -> path mappings. 		 */
if|if
condition|(
name|fix_paths
argument_list|(
name|nvroot
argument_list|,
name|pl
operator|->
name|names
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
goto|goto
name|nomem
goto|;
block|}
comment|/* 		 * Add the root vdev to this pool's configuration. 		 */
if|if
condition|(
name|nvlist_add_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
name|nvroot
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
goto|goto
name|nomem
goto|;
block|}
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
comment|/* 		 * Determine if this pool is currently active, in which case we 		 * can't actually import it. 		 */
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
operator|&
name|name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool_active
argument_list|(
name|hdl
argument_list|,
name|name
argument_list|,
name|guid
argument_list|,
operator|&
name|isactive
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|isactive
condition|)
block|{
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|config
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Try to do the import in order to get vdev state. 		 */
if|if
condition|(
name|zcmd_write_src_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|config
argument_list|,
operator|&
name|len
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|config
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|zcmd_alloc_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|len
operator|*
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
while|while
condition|(
operator|(
name|err
operator|=
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_POOL_TRYIMPORT
argument_list|,
operator|&
name|zc
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|errno
operator|==
name|ENOMEM
condition|)
block|{
if|if
condition|(
name|zcmd_expand_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
if|if
condition|(
name|err
condition|)
block|{
operator|(
name|void
operator|)
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot discover pools"
argument_list|)
argument_list|)
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|zcmd_read_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
operator|&
name|config
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
comment|/* 		 * Go through and update the paths for spares, now that we have 		 * them. 		 */
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nspares
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fix_paths
argument_list|(
name|spares
index|[
name|i
index|]
argument_list|,
name|pl
operator|->
name|names
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|nomem
goto|;
block|}
block|}
comment|/* 		 * Restore the original information read from the actual label. 		 */
operator|(
name|void
operator|)
name|nvlist_remove
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_HOSTID
argument_list|,
name|DATA_TYPE_UINT64
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_remove
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_HOSTNAME
argument_list|,
name|DATA_TYPE_STRING
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostid
operator|!=
literal|0
condition|)
block|{
name|verify
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_HOSTID
argument_list|,
name|hostid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_add_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_HOSTNAME
argument_list|,
name|hostname
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Add this pool to the list of configs. 		 */
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
operator|&
name|name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_add_nvlist
argument_list|(
name|ret
argument_list|,
name|name
argument_list|,
name|config
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|nomem
goto|;
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|config
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
name|nomem
label|:
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
name|error
label|:
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
name|nvlist_free
argument_list|(
name|child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the offset of the given label.  */
end_comment

begin_function
specifier|static
name|uint64_t
name|label_offset
parameter_list|(
name|size_t
name|size
parameter_list|,
name|int
name|l
parameter_list|)
block|{
return|return
operator|(
name|l
operator|*
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
operator|+
operator|(
name|l
operator|<
name|VDEV_LABELS
operator|/
literal|2
condition|?
literal|0
else|:
name|size
operator|-
name|VDEV_LABELS
operator|*
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a file descriptor, read the label information and return an nvlist  * describing the configuration, if there is one.  */
end_comment

begin_function
name|int
name|zpool_read_label
parameter_list|(
name|int
name|fd
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|config
parameter_list|)
block|{
name|struct
name|stat64
name|statbuf
decl_stmt|;
name|int
name|l
decl_stmt|;
name|vdev_label_t
modifier|*
name|label
decl_stmt|;
name|uint64_t
name|state
decl_stmt|,
name|txg
decl_stmt|;
operator|*
name|config
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fstat64
argument_list|(
name|fd
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|label
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|VDEV_LABELS
condition|;
name|l
operator|++
control|)
block|{
if|if
condition|(
name|pread
argument_list|(
name|fd
argument_list|,
name|label
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
argument_list|,
name|label_offset
argument_list|(
name|statbuf
operator|.
name|st_size
argument_list|,
name|l
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|nvlist_unpack
argument_list|(
name|label
operator|->
name|vl_vdev_phys
operator|.
name|vp_nvlist
argument_list|,
sizeof|sizeof
argument_list|(
name|label
operator|->
name|vl_vdev_phys
operator|.
name|vp_nvlist
argument_list|)
argument_list|,
name|config
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
operator|*
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
operator|&
name|state
argument_list|)
operator|!=
literal|0
operator|||
name|state
operator|>
name|POOL_STATE_SPARE
condition|)
block|{
name|nvlist_free
argument_list|(
operator|*
name|config
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|state
operator|!=
name|POOL_STATE_SPARE
operator|&&
operator|(
name|nvlist_lookup_uint64
argument_list|(
operator|*
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_TXG
argument_list|,
operator|&
name|txg
argument_list|)
operator|!=
literal|0
operator|||
name|txg
operator|==
literal|0
operator|)
condition|)
block|{
name|nvlist_free
argument_list|(
operator|*
name|config
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|free
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|free
argument_list|(
name|label
argument_list|)
expr_stmt|;
operator|*
name|config
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a list of directories to search, find all pools stored on disk.  This  * includes partial pools which are not available to import.  If no args are  * given (argc is 0), then the default directory (/dev) is searched.  */
end_comment

begin_function
name|nvlist_t
modifier|*
name|zpool_find_import
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|char
name|path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|nvlist_t
modifier|*
name|ret
init|=
name|NULL
decl_stmt|,
modifier|*
name|config
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|pool_list_t
name|pools
init|=
block|{
literal|0
block|}
decl_stmt|;
name|pool_entry_t
modifier|*
name|pe
decl_stmt|,
modifier|*
name|penext
decl_stmt|;
name|vdev_entry_t
modifier|*
name|ve
decl_stmt|,
modifier|*
name|venext
decl_stmt|;
name|config_entry_t
modifier|*
name|ce
decl_stmt|,
modifier|*
name|cenext
decl_stmt|;
name|name_entry_t
modifier|*
name|ne
decl_stmt|,
modifier|*
name|nenext
decl_stmt|;
name|struct
name|gmesh
name|mesh
decl_stmt|;
name|struct
name|gclass
modifier|*
name|mp
decl_stmt|;
name|struct
name|ggeom
modifier|*
name|gp
decl_stmt|;
name|struct
name|gprovider
modifier|*
name|pp
decl_stmt|;
comment|/* 	 * Go through and read the label configuration information from every 	 * possible device, organizing the information according to pool GUID 	 * and toplevel GUID. 	 */
name|fd
operator|=
name|geom_gettree
argument_list|(
operator|&
name|mesh
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fd
operator|==
literal|0
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|mp
argument_list|,
argument|&mesh.lg_class
argument_list|,
argument|lg_class
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|gp
argument_list|,
argument|&mp->lg_geom
argument_list|,
argument|lg_geom
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|pp
argument_list|,
argument|&gp->lg_provider
argument_list|,
argument|lg_provider
argument_list|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|_PATH_DEV
argument_list|,
name|pp
operator|->
name|lg_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open64
argument_list|(
name|path
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|zpool_read_label
argument_list|(
name|fd
argument_list|,
operator|&
name|config
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|add_config
argument_list|(
name|hdl
argument_list|,
operator|&
name|pools
argument_list|,
name|path
argument_list|,
name|config
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
block|}
block|}
block|}
name|geom_deletetree
argument_list|(
operator|&
name|mesh
argument_list|)
expr_stmt|;
name|ret
operator|=
name|get_configs
argument_list|(
name|hdl
argument_list|,
operator|&
name|pools
argument_list|)
expr_stmt|;
name|error
label|:
for|for
control|(
name|pe
operator|=
name|pools
operator|.
name|pools
init|;
name|pe
operator|!=
name|NULL
condition|;
name|pe
operator|=
name|penext
control|)
block|{
name|penext
operator|=
name|pe
operator|->
name|pe_next
expr_stmt|;
for|for
control|(
name|ve
operator|=
name|pe
operator|->
name|pe_vdevs
init|;
name|ve
operator|!=
name|NULL
condition|;
name|ve
operator|=
name|venext
control|)
block|{
name|venext
operator|=
name|ve
operator|->
name|ve_next
expr_stmt|;
for|for
control|(
name|ce
operator|=
name|ve
operator|->
name|ve_configs
init|;
name|ce
operator|!=
name|NULL
condition|;
name|ce
operator|=
name|cenext
control|)
block|{
name|cenext
operator|=
name|ce
operator|->
name|ce_next
expr_stmt|;
if|if
condition|(
name|ce
operator|->
name|ce_config
condition|)
name|nvlist_free
argument_list|(
name|ce
operator|->
name|ce_config
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ce
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ve
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ne
operator|=
name|pools
operator|.
name|names
init|;
name|ne
operator|!=
name|NULL
condition|;
name|ne
operator|=
name|nenext
control|)
block|{
name|nenext
operator|=
name|ne
operator|->
name|ne_next
expr_stmt|;
if|if
condition|(
name|ne
operator|->
name|ne_name
condition|)
name|free
argument_list|(
name|ne
operator|->
name|ne_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ne
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|find_guid
parameter_list|(
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|uint64_t
name|guid
parameter_list|)
block|{
name|uint64_t
name|tmp
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|tmp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|guid
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|find_guid
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|guid
argument_list|)
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|spare_cbdata
block|{
name|uint64_t
name|cb_guid
decl_stmt|;
name|zpool_handle_t
modifier|*
name|cb_zhp
decl_stmt|;
block|}
name|spare_cbdata_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|find_spare
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|spare_cbdata_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|spares
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|nspares
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|zhp
operator|->
name|zpool_config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nspares
condition|;
name|i
operator|++
control|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|spares
index|[
name|i
index|]
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|guid
operator|==
name|cbp
operator|->
name|cb_guid
condition|)
block|{
name|cbp
operator|->
name|cb_zhp
operator|=
name|zhp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determines if the pool is in use.  If so, it returns true and the state of  * the pool as well as the name of the pool.  Both strings are allocated and  * must be freed by the caller.  */
end_comment

begin_function
name|int
name|zpool_in_use
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|fd
parameter_list|,
name|pool_state_t
modifier|*
name|state
parameter_list|,
name|char
modifier|*
modifier|*
name|namestr
parameter_list|,
name|boolean_t
modifier|*
name|inuse
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|config
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|boolean_t
name|ret
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|,
name|vdev_guid
decl_stmt|;
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|nvlist_t
modifier|*
name|pool_config
decl_stmt|;
name|uint64_t
name|stateval
decl_stmt|,
name|isspare
decl_stmt|;
name|spare_cbdata_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|boolean_t
name|isactive
decl_stmt|;
operator|*
name|inuse
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|zpool_read_label
argument_list|(
name|fd
argument_list|,
operator|&
name|config
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
operator|&
name|stateval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|vdev_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|stateval
operator|!=
name|POOL_STATE_SPARE
condition|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
operator|&
name|name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|stateval
condition|)
block|{
case|case
name|POOL_STATE_EXPORTED
case|:
name|ret
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
name|POOL_STATE_ACTIVE
case|:
comment|/* 		 * For an active pool, we have to determine if it's really part 		 * of a currently active pool (in which case the pool will exist 		 * and the guid will be the same), or whether it's part of an 		 * active pool that was disconnected without being explicitly 		 * exported. 		 */
if|if
condition|(
name|pool_active
argument_list|(
name|hdl
argument_list|,
name|name
argument_list|,
name|guid
argument_list|,
operator|&
name|isactive
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|isactive
condition|)
block|{
comment|/* 			 * Because the device may have been removed while 			 * offlined, we only report it as active if the vdev is 			 * still present in the config.  Otherwise, pretend like 			 * it's not in use. 			 */
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open_canfail
argument_list|(
name|hdl
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|pool_config
operator|=
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|pool_config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|find_guid
argument_list|(
name|nvroot
argument_list|,
name|vdev_guid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|B_FALSE
expr_stmt|;
block|}
comment|/* 			 * If this is an active spare within another pool, we 			 * treat it like an unused hot spare.  This allows the 			 * user to create a pool with a hot spare that currently 			 * in use within another pool.  Since we return B_TRUE, 			 * libdiskmgt will continue to prevent generic consumers 			 * from using the device. 			 */
if|if
condition|(
name|ret
operator|&&
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_IS_SPARE
argument_list|,
operator|&
name|isspare
argument_list|)
operator|==
literal|0
operator|&&
name|isspare
condition|)
name|stateval
operator|=
name|POOL_STATE_SPARE
expr_stmt|;
if|if
condition|(
name|zhp
operator|!=
name|NULL
condition|)
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stateval
operator|=
name|POOL_STATE_POTENTIALLY_ACTIVE
expr_stmt|;
name|ret
operator|=
name|B_TRUE
expr_stmt|;
block|}
break|break;
case|case
name|POOL_STATE_SPARE
case|:
comment|/* 		 * For a hot spare, it can be either definitively in use, or 		 * potentially active.  To determine if it's in use, we iterate 		 * over all pools in the system and search for one with a spare 		 * with a matching guid. 		 * 		 * Due to the shared nature of spares, we don't actually report 		 * the potentially active case as in use.  This means the user 		 * can freely create pools on the hot spares of exported pools, 		 * but to do otherwise makes the resulting code complicated, and 		 * we end up having to deal with this case anyway. 		 */
name|cb
operator|.
name|cb_zhp
operator|=
name|NULL
expr_stmt|;
name|cb
operator|.
name|cb_guid
operator|=
name|vdev_guid
expr_stmt|;
if|if
condition|(
name|zpool_iter
argument_list|(
name|hdl
argument_list|,
name|find_spare
argument_list|,
operator|&
name|cb
argument_list|)
operator|==
literal|1
condition|)
block|{
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|zpool_get_name
argument_list|(
name|cb
operator|.
name|cb_zhp
argument_list|)
expr_stmt|;
name|ret
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
default|default:
name|ret
operator|=
name|B_FALSE
expr_stmt|;
block|}
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|namestr
operator|=
name|zfs_strdup
argument_list|(
name|hdl
argument_list|,
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|state
operator|=
operator|(
name|pool_state_t
operator|)
name|stateval
expr_stmt|;
block|}
if|if
condition|(
name|cb
operator|.
name|cb_zhp
condition|)
name|zpool_close
argument_list|(
name|cb
operator|.
name|cb_zhp
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
operator|*
name|inuse
operator|=
name|ret
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

