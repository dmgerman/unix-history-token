begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_comment
comment|/*  * Internal utility routines for the ZFS library.  */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/mnttab.h>
end_include

begin_include
include|#
directive|include
file|<sys/mntent.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<libzfs.h>
end_include

begin_include
include|#
directive|include
file|"libzfs_impl.h"
end_include

begin_function
name|int
name|libzfs_errno
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|)
block|{
return|return
operator|(
name|hdl
operator|->
name|libzfs_error
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|libzfs_error_action
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|)
block|{
return|return
operator|(
name|hdl
operator|->
name|libzfs_action
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|libzfs_error_description
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|)
block|{
if|if
condition|(
name|hdl
operator|->
name|libzfs_desc
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
return|return
operator|(
name|hdl
operator|->
name|libzfs_desc
operator|)
return|;
switch|switch
condition|(
name|hdl
operator|->
name|libzfs_error
condition|)
block|{
case|case
name|EZFS_NOMEM
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"out of memory"
argument_list|)
operator|)
return|;
case|case
name|EZFS_BADPROP
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid property value"
argument_list|)
operator|)
return|;
case|case
name|EZFS_PROPREADONLY
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"read only property"
argument_list|)
operator|)
return|;
case|case
name|EZFS_PROPTYPE
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"property doesn't apply to "
literal|"datasets of this type"
argument_list|)
operator|)
return|;
case|case
name|EZFS_PROPNONINHERIT
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"property cannot be inherited"
argument_list|)
operator|)
return|;
case|case
name|EZFS_PROPSPACE
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid quota or reservation"
argument_list|)
operator|)
return|;
case|case
name|EZFS_BADTYPE
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"operation not applicable to "
literal|"datasets of this type"
argument_list|)
operator|)
return|;
case|case
name|EZFS_BUSY
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool or dataset is busy"
argument_list|)
operator|)
return|;
case|case
name|EZFS_EXISTS
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool or dataset exists"
argument_list|)
operator|)
return|;
case|case
name|EZFS_NOENT
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"no such pool or dataset"
argument_list|)
operator|)
return|;
case|case
name|EZFS_BADSTREAM
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid backup stream"
argument_list|)
operator|)
return|;
case|case
name|EZFS_DSREADONLY
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"dataset is read only"
argument_list|)
operator|)
return|;
case|case
name|EZFS_VOLTOOBIG
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"volume size exceeds limit for "
literal|"this system"
argument_list|)
operator|)
return|;
case|case
name|EZFS_VOLHASDATA
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"volume has data"
argument_list|)
operator|)
return|;
case|case
name|EZFS_INVALIDNAME
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid name"
argument_list|)
operator|)
return|;
case|case
name|EZFS_BADRESTORE
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"unable to restore to "
literal|"destination"
argument_list|)
operator|)
return|;
case|case
name|EZFS_BADBACKUP
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"backup failed"
argument_list|)
operator|)
return|;
case|case
name|EZFS_BADTARGET
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid target vdev"
argument_list|)
operator|)
return|;
case|case
name|EZFS_NODEVICE
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"no such device in pool"
argument_list|)
operator|)
return|;
case|case
name|EZFS_BADDEV
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid device"
argument_list|)
operator|)
return|;
case|case
name|EZFS_NOREPLICAS
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"no valid replicas"
argument_list|)
operator|)
return|;
case|case
name|EZFS_RESILVERING
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"currently resilvering"
argument_list|)
operator|)
return|;
case|case
name|EZFS_BADVERSION
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"unsupported version"
argument_list|)
operator|)
return|;
case|case
name|EZFS_POOLUNAVAIL
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool is unavailable"
argument_list|)
operator|)
return|;
case|case
name|EZFS_DEVOVERFLOW
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"too many devices in one vdev"
argument_list|)
operator|)
return|;
case|case
name|EZFS_BADPATH
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"must be an absolute path"
argument_list|)
operator|)
return|;
case|case
name|EZFS_CROSSTARGET
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"operation crosses datasets or "
literal|"pools"
argument_list|)
operator|)
return|;
case|case
name|EZFS_ZONED
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"dataset in use by local zone"
argument_list|)
operator|)
return|;
case|case
name|EZFS_MOUNTFAILED
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"mount failed"
argument_list|)
operator|)
return|;
case|case
name|EZFS_UMOUNTFAILED
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"umount failed"
argument_list|)
operator|)
return|;
case|case
name|EZFS_UNSHARENFSFAILED
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"unshare(1M) failed"
argument_list|)
operator|)
return|;
case|case
name|EZFS_SHARENFSFAILED
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"share(1M) failed"
argument_list|)
operator|)
return|;
case|case
name|EZFS_DEVLINKS
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"failed to create /dev links"
argument_list|)
operator|)
return|;
case|case
name|EZFS_PERM
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"permission denied"
argument_list|)
operator|)
return|;
case|case
name|EZFS_NOSPC
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"out of space"
argument_list|)
operator|)
return|;
case|case
name|EZFS_IO
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"I/O error"
argument_list|)
operator|)
return|;
case|case
name|EZFS_INTR
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"signal received"
argument_list|)
operator|)
return|;
case|case
name|EZFS_ISSPARE
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"device is reserved as a hot "
literal|"spare"
argument_list|)
operator|)
return|;
case|case
name|EZFS_INVALCONFIG
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid vdev configuration"
argument_list|)
operator|)
return|;
case|case
name|EZFS_RECURSIVE
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"recursive dataset dependency"
argument_list|)
operator|)
return|;
case|case
name|EZFS_NOHISTORY
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"no history available"
argument_list|)
operator|)
return|;
case|case
name|EZFS_UNSHAREISCSIFAILED
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"iscsitgtd failed request to unshare"
argument_list|)
operator|)
return|;
case|case
name|EZFS_SHAREISCSIFAILED
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"iscsitgtd failed request to share"
argument_list|)
operator|)
return|;
case|case
name|EZFS_POOLPROPS
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"failed to retrieve "
literal|"pool properties"
argument_list|)
operator|)
return|;
case|case
name|EZFS_POOL_NOTSUP
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"operation not supported "
literal|"on this type of pool"
argument_list|)
operator|)
return|;
case|case
name|EZFS_POOL_INVALARG
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid argument for "
literal|"this pool operation"
argument_list|)
operator|)
return|;
case|case
name|EZFS_UNKNOWN
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"unknown error"
argument_list|)
operator|)
return|;
default|default:
name|assert
argument_list|(
name|hdl
operator|->
name|libzfs_error
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"no error"
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*PRINTFLIKE2*/
end_comment

begin_function
name|void
name|zfs_error_aux
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vsnprintf
argument_list|(
name|hdl
operator|->
name|libzfs_desc
argument_list|,
sizeof|sizeof
argument_list|(
name|hdl
operator|->
name|libzfs_desc
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|hdl
operator|->
name|libzfs_desc_active
operator|=
literal|1
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_verror
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|error
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
operator|(
name|void
operator|)
name|vsnprintf
argument_list|(
name|hdl
operator|->
name|libzfs_action
argument_list|,
sizeof|sizeof
argument_list|(
name|hdl
operator|->
name|libzfs_action
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|hdl
operator|->
name|libzfs_error
operator|=
name|error
expr_stmt|;
if|if
condition|(
name|hdl
operator|->
name|libzfs_desc_active
condition|)
name|hdl
operator|->
name|libzfs_desc_active
operator|=
literal|0
expr_stmt|;
else|else
name|hdl
operator|->
name|libzfs_desc
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|hdl
operator|->
name|libzfs_printerr
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|EZFS_UNKNOWN
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"internal "
literal|"error: %s\n"
argument_list|)
argument_list|,
name|libzfs_error_description
argument_list|(
name|hdl
argument_list|)
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|hdl
operator|->
name|libzfs_action
argument_list|,
name|libzfs_error_description
argument_list|(
name|hdl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EZFS_NOMEM
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|zfs_error
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|error
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
return|return
operator|(
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|error
argument_list|,
literal|"%s"
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*PRINTFLIKE3*/
end_comment

begin_function
name|int
name|zfs_error_fmt
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|error
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|error
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_common_error
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|error
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|EPERM
case|:
case|case
name|EACCES
case|:
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_PERM
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|EIO
case|:
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_IO
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|EINTR
case|:
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_INTR
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_standard_error
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|error
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
return|return
operator|(
name|zfs_standard_error_fmt
argument_list|(
name|hdl
argument_list|,
name|error
argument_list|,
literal|"%s"
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*PRINTFLIKE3*/
end_comment

begin_function
name|int
name|zfs_standard_error_fmt
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|error
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_common_error
argument_list|(
name|hdl
argument_list|,
name|error
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|ENXIO
case|:
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_IO
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENOENT
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"dataset does not exist"
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENOSPC
case|:
case|case
name|EDQUOT
case|:
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOSPC
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|EEXIST
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"dataset already exists"
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_EXISTS
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
case|case
name|EBUSY
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"dataset is busy"
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_BUSY
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
default|default:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_UNKNOWN
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zpool_standard_error
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|error
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
return|return
operator|(
name|zpool_standard_error_fmt
argument_list|(
name|hdl
argument_list|,
name|error
argument_list|,
literal|"%s"
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*PRINTFLIKE3*/
end_comment

begin_function
name|int
name|zpool_standard_error_fmt
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|error
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_common_error
argument_list|(
name|hdl
argument_list|,
name|error
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|ENODEV
case|:
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_NODEVICE
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENOENT
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"no such pool or dataset"
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
case|case
name|EEXIST
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool already exists"
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_EXISTS
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
case|case
name|EBUSY
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool is busy"
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_EXISTS
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENXIO
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"one or more devices is currently unavailable"
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENAMETOOLONG
case|:
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_DEVOVERFLOW
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENOTSUP
case|:
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_POOL_NOTSUP
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
case|case
name|EINVAL
case|:
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_POOL_INVALARG
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
default|default:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|strerror
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_verror
argument_list|(
name|hdl
argument_list|,
name|EZFS_UNKNOWN
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Display an out of memory error message and abort the current program.  */
end_comment

begin_function
name|int
name|no_memory
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|)
block|{
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOMEM
argument_list|,
literal|"internal error"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * A safe form of malloc() which will die if the allocation fails.  */
end_comment

begin_function
name|void
modifier|*
name|zfs_alloc
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|data
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * A safe form of realloc(), which also zeroes newly allocated space.  */
end_comment

begin_function
name|void
modifier|*
name|zfs_realloc
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|newsize
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|newsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ret
operator|+
name|oldsize
argument_list|,
operator|(
name|newsize
operator|-
name|oldsize
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * A safe form of strdup() which will die if the allocation fails.  */
end_comment

begin_function
name|char
modifier|*
name|zfs_strdup
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|strdup
argument_list|(
name|str
argument_list|)
operator|)
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a number to an appropriately human-readable output.  */
end_comment

begin_function
name|void
name|zfs_nicenum
parameter_list|(
name|uint64_t
name|num
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|uint64_t
name|n
init|=
name|num
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
name|char
name|u
decl_stmt|;
while|while
condition|(
name|n
operator|>=
literal|1024
condition|)
block|{
name|n
operator|/=
literal|1024
expr_stmt|;
name|index
operator|++
expr_stmt|;
block|}
name|u
operator|=
literal|" KMGTPE"
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"%llu"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|num
operator|&
operator|(
operator|(
literal|1ULL
operator|<<
literal|10
operator|*
name|index
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If this is an even multiple of the base, always display 		 * without any decimal precision. 		 */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"%llu%c"
argument_list|,
name|n
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We want to choose a precision that reflects the best choice 		 * for fitting in 5 characters.  This can get rather tricky when 		 * we have numbers that are very close to an order of magnitude. 		 * For example, when displaying 10239 (which is really 9.999K), 		 * we want only a single place of precision for 10.0K.  We could 		 * develop some complex heuristics for this, but it's much 		 * easier just to try each combination in turn. 		 */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"%.*f%c"
argument_list|,
name|i
argument_list|,
operator|(
name|double
operator|)
name|num
operator|/
operator|(
literal|1ULL
operator|<<
literal|10
operator|*
name|index
operator|)
argument_list|,
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|<=
literal|5
condition|)
break|break;
block|}
block|}
block|}
end_function

begin_function
name|void
name|libzfs_print_on_error
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|boolean_t
name|printerr
parameter_list|)
block|{
name|hdl
operator|->
name|libzfs_printerr
operator|=
name|printerr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|libzfs_load
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|modfind
argument_list|(
literal|"zfs"
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Not present in kernel, try loading it. */
if|if
condition|(
name|kldload
argument_list|(
literal|"zfs"
argument_list|)
operator|<
literal|0
operator|||
name|modfind
argument_list|(
literal|"zfs"
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EEXIST
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|libzfs_handle_t
modifier|*
name|libzfs_init
parameter_list|(
name|void
parameter_list|)
block|{
name|libzfs_handle_t
modifier|*
name|hdl
decl_stmt|;
if|if
condition|(
operator|(
name|hdl
operator|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|libzfs_handle_t
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|hdl
operator|->
name|libzfs_fd
operator|=
name|open
argument_list|(
name|ZFS_DEV
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|libzfs_load
argument_list|()
operator|==
literal|0
condition|)
name|hdl
operator|->
name|libzfs_fd
operator|=
name|open
argument_list|(
name|ZFS_DEV
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdl
operator|->
name|libzfs_fd
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|hdl
operator|->
name|libzfs_mnttab
operator|=
name|fopen
argument_list|(
name|MNTTAB
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|hdl
operator|->
name|libzfs_sharetab
operator|=
name|fopen
argument_list|(
name|ZFS_EXPORTS_PATH
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
return|return
operator|(
name|hdl
operator|)
return|;
block|}
end_function

begin_function
name|void
name|libzfs_fini
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdl
operator|->
name|libzfs_mnttab
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|hdl
operator|->
name|libzfs_mnttab
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdl
operator|->
name|libzfs_sharetab
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|hdl
operator|->
name|libzfs_sharetab
argument_list|)
expr_stmt|;
name|namespace_clear
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|libzfs_handle_t
modifier|*
name|zpool_get_handle
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
return|return
operator|(
name|zhp
operator|->
name|zpool_hdl
operator|)
return|;
block|}
end_function

begin_function
name|libzfs_handle_t
modifier|*
name|zfs_get_handle
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
return|return
operator|(
name|zhp
operator|->
name|zfs_hdl
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a name, determine whether or not it's a valid path  * (starts with '/' or "./").  If so, walk the mnttab trying  * to match the device number.  If not, treat the path as an  * fs/vol/snap name.  */
end_comment

begin_function
name|zfs_handle_t
modifier|*
name|zfs_path_to_zhandle
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|zfs_type_t
name|argtype
parameter_list|)
block|{
name|struct
name|statfs
name|statbuf
decl_stmt|;
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|&&
name|strncmp
argument_list|(
name|path
argument_list|,
literal|"./"
argument_list|,
name|strlen
argument_list|(
literal|"./"
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * It's not a valid path, assume it's a name of type 'argtype'. 		 */
return|return
operator|(
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|,
name|argtype
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|statfs
argument_list|(
name|path
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|statbuf
operator|.
name|f_fstypename
argument_list|,
name|MNTTYPE_ZFS
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|gettext
argument_list|(
literal|"'%s': not a ZFS filesystem\n"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|statbuf
operator|.
name|f_mntfromname
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the zc_nvlist_dst member to prepare for receiving an nvlist from  * an ioctl().  */
end_comment

begin_function
name|int
name|zcmd_alloc_dst_nvlist
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|zfs_cmd_t
modifier|*
name|zc
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
literal|2048
expr_stmt|;
name|zc
operator|->
name|zc_nvlist_dst_size
operator|=
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|zc
operator|->
name|zc_nvlist_dst
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
name|zc
operator|->
name|zc_nvlist_dst_size
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called when an ioctl() which returns an nvlist fails with ENOMEM.  This will  * expand the nvlist to the size specified in 'zc_nvlist_dst_size', which was  * filled in by the kernel to indicate the actual required size.  */
end_comment

begin_function
name|int
name|zcmd_expand_dst_nvlist
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|zfs_cmd_t
modifier|*
name|zc
parameter_list|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|->
name|zc_nvlist_dst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zc
operator|->
name|zc_nvlist_dst
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
name|zc
operator|->
name|zc_nvlist_dst_size
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called to free the src and dst nvlists stored in the command structure.  */
end_comment

begin_function
name|void
name|zcmd_free_nvlists
parameter_list|(
name|zfs_cmd_t
modifier|*
name|zc
parameter_list|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|->
name|zc_nvlist_src
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|->
name|zc_nvlist_dst
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|zcmd_write_src_nvlist
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|zfs_cmd_t
modifier|*
name|zc
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|char
modifier|*
name|packed
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|verify
argument_list|(
name|nvlist_size
argument_list|(
name|nvl
argument_list|,
operator|&
name|len
argument_list|,
name|NV_ENCODE_NATIVE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|packed
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|verify
argument_list|(
name|nvlist_pack
argument_list|(
name|nvl
argument_list|,
operator|&
name|packed
argument_list|,
operator|&
name|len
argument_list|,
name|NV_ENCODE_NATIVE
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zc
operator|->
name|zc_nvlist_src
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|packed
expr_stmt|;
name|zc
operator|->
name|zc_nvlist_src_size
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|size
condition|)
operator|*
name|size
operator|=
name|len
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unpacks an nvlist from the ZFS ioctl command structure.  */
end_comment

begin_function
name|int
name|zcmd_read_dst_nvlist
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|zfs_cmd_t
modifier|*
name|zc
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nvlp
parameter_list|)
block|{
if|if
condition|(
name|nvlist_unpack
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|->
name|zc_nvlist_dst
argument_list|,
name|zc
operator|->
name|zc_nvlist_dst_size
argument_list|,
name|nvlp
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|no_memory
argument_list|(
name|hdl
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_print_prop_headers
parameter_list|(
name|libzfs_get_cbdata_t
modifier|*
name|cbp
parameter_list|)
block|{
name|zfs_proplist_t
modifier|*
name|pl
init|=
name|cbp
operator|->
name|cb_proplist
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|title
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|cbp
operator|->
name|cb_first
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|cbp
operator|->
name|cb_scripted
condition|)
return|return;
comment|/* 	 * Start with the length of the column headers. 	 */
name|cbp
operator|->
name|cb_colwidths
index|[
name|GET_COL_NAME
index|]
operator|=
name|strlen
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"NAME"
argument_list|)
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_colwidths
index|[
name|GET_COL_PROPERTY
index|]
operator|=
name|strlen
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"PROPERTY"
argument_list|)
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_colwidths
index|[
name|GET_COL_VALUE
index|]
operator|=
name|strlen
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"VALUE"
argument_list|)
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_colwidths
index|[
name|GET_COL_SOURCE
index|]
operator|=
name|strlen
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"SOURCE"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Go through and calculate the widths for each column.  For the 	 * 'source' column, we kludge it up by taking the worst-case scenario of 	 * inheriting from the longest name.  This is acceptable because in the 	 * majority of cases 'SOURCE' is the last column displayed, and we don't 	 * use the width anyway.  Note that the 'VALUE' column can be oversized, 	 * if the name of the property is much longer the any values we find. 	 */
for|for
control|(
name|pl
operator|=
name|cbp
operator|->
name|cb_proplist
init|;
name|pl
operator|!=
name|NULL
condition|;
name|pl
operator|=
name|pl
operator|->
name|pl_next
control|)
block|{
comment|/* 		 * 'PROPERTY' column 		 */
if|if
condition|(
name|pl
operator|->
name|pl_prop
operator|!=
name|ZFS_PROP_INVAL
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|zfs_prop_to_name
argument_list|(
name|pl
operator|->
name|pl_prop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|cbp
operator|->
name|cb_colwidths
index|[
name|GET_COL_PROPERTY
index|]
condition|)
name|cbp
operator|->
name|cb_colwidths
index|[
name|GET_COL_PROPERTY
index|]
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|strlen
argument_list|(
name|pl
operator|->
name|pl_user_prop
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|cbp
operator|->
name|cb_colwidths
index|[
name|GET_COL_PROPERTY
index|]
condition|)
name|cbp
operator|->
name|cb_colwidths
index|[
name|GET_COL_PROPERTY
index|]
operator|=
name|len
expr_stmt|;
block|}
comment|/* 		 * 'VALUE' column 		 */
if|if
condition|(
operator|(
name|pl
operator|->
name|pl_prop
operator|!=
name|ZFS_PROP_NAME
operator|||
operator|!
name|pl
operator|->
name|pl_all
operator|)
operator|&&
name|pl
operator|->
name|pl_width
operator|>
name|cbp
operator|->
name|cb_colwidths
index|[
name|GET_COL_VALUE
index|]
condition|)
name|cbp
operator|->
name|cb_colwidths
index|[
name|GET_COL_VALUE
index|]
operator|=
name|pl
operator|->
name|pl_width
expr_stmt|;
comment|/* 		 * 'NAME' and 'SOURCE' columns 		 */
if|if
condition|(
name|pl
operator|->
name|pl_prop
operator|==
name|ZFS_PROP_NAME
operator|&&
name|pl
operator|->
name|pl_width
operator|>
name|cbp
operator|->
name|cb_colwidths
index|[
name|GET_COL_NAME
index|]
condition|)
block|{
name|cbp
operator|->
name|cb_colwidths
index|[
name|GET_COL_NAME
index|]
operator|=
name|pl
operator|->
name|pl_width
expr_stmt|;
name|cbp
operator|->
name|cb_colwidths
index|[
name|GET_COL_SOURCE
index|]
operator|=
name|pl
operator|->
name|pl_width
operator|+
name|strlen
argument_list|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"inherited from"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Now go through and print the headers. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|cbp
operator|->
name|cb_columns
index|[
name|i
index|]
condition|)
block|{
case|case
name|GET_COL_NAME
case|:
name|title
operator|=
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"NAME"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GET_COL_PROPERTY
case|:
name|title
operator|=
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"PROPERTY"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GET_COL_VALUE
case|:
name|title
operator|=
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"VALUE"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GET_COL_SOURCE
case|:
name|title
operator|=
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"SOURCE"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|title
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|title
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|3
operator|||
name|cbp
operator|->
name|cb_columns
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|title
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-*s  "
argument_list|,
name|cbp
operator|->
name|cb_colwidths
index|[
name|cbp
operator|->
name|cb_columns
index|[
name|i
index|]
index|]
argument_list|,
name|title
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Display a single line of output, according to the settings in the callback  * structure.  */
end_comment

begin_function
name|void
name|libzfs_print_one_property
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|libzfs_get_cbdata_t
modifier|*
name|cbp
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|zfs_source_t
name|sourcetype
parameter_list|,
specifier|const
name|char
modifier|*
name|source
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
comment|/* 	 * Ignore those source types that the user has chosen to ignore. 	 */
if|if
condition|(
operator|(
name|sourcetype
operator|&
name|cbp
operator|->
name|cb_sources
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|cbp
operator|->
name|cb_first
condition|)
name|zfs_print_prop_headers
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|cbp
operator|->
name|cb_columns
index|[
name|i
index|]
condition|)
block|{
case|case
name|GET_COL_NAME
case|:
name|str
operator|=
name|name
expr_stmt|;
break|break;
case|case
name|GET_COL_PROPERTY
case|:
name|str
operator|=
name|propname
expr_stmt|;
break|break;
case|case
name|GET_COL_VALUE
case|:
name|str
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|GET_COL_SOURCE
case|:
switch|switch
condition|(
name|sourcetype
condition|)
block|{
case|case
name|ZFS_SRC_NONE
case|:
name|str
operator|=
literal|"-"
expr_stmt|;
break|break;
case|case
name|ZFS_SRC_DEFAULT
case|:
name|str
operator|=
literal|"default"
expr_stmt|;
break|break;
case|case
name|ZFS_SRC_LOCAL
case|:
name|str
operator|=
literal|"local"
expr_stmt|;
break|break;
case|case
name|ZFS_SRC_TEMPORARY
case|:
name|str
operator|=
literal|"temporary"
expr_stmt|;
break|break;
case|case
name|ZFS_SRC_INHERITED
case|:
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"inherited from %s"
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|str
operator|=
name|buf
expr_stmt|;
break|break;
block|}
break|break;
default|default:
continue|continue;
block|}
if|if
condition|(
name|cbp
operator|->
name|cb_columns
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cbp
operator|->
name|cb_scripted
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s\t"
argument_list|,
name|str
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-*s  "
argument_list|,
name|cbp
operator|->
name|cb_colwidths
index|[
name|cbp
operator|->
name|cb_columns
index|[
name|i
index|]
index|]
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

