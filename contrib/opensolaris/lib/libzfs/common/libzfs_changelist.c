begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_include
include|#
directive|include
file|<libuutil.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<zone.h>
end_include

begin_include
include|#
directive|include
file|<libzfs.h>
end_include

begin_include
include|#
directive|include
file|"libzfs_impl.h"
end_include

begin_comment
comment|/*  * Structure to keep track of dataset state.  Before changing the 'sharenfs' or  * 'mountpoint' property, we record whether the filesystem was previously  * mounted/shared.  This prior state dictates whether we remount/reshare the  * dataset after the property has been changed.  *  * The interface consists of the following sequence of functions:  *  * 	changelist_gather()  * 	changelist_prefix()  *< change property>  * 	changelist_postfix()  * 	changelist_free()  *  * Other interfaces:  *  * changelist_remove() - remove a node from a gathered list  * changelist_rename() - renames all datasets appropriately when doing a rename  * changelist_unshare() - unshares all the nodes in a given changelist  * changelist_haszonedchild() - check if there is any child exported to  *				a local zone  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|prop_changenode
block|{
name|zfs_handle_t
modifier|*
name|cn_handle
decl_stmt|;
name|int
name|cn_shared
decl_stmt|;
name|int
name|cn_mounted
decl_stmt|;
name|int
name|cn_zoned
decl_stmt|;
name|uu_list_node_t
name|cn_listnode
decl_stmt|;
block|}
name|prop_changenode_t
typedef|;
end_typedef

begin_struct
struct|struct
name|prop_changelist
block|{
name|zfs_prop_t
name|cl_prop
decl_stmt|;
name|zfs_prop_t
name|cl_realprop
decl_stmt|;
name|uu_list_pool_t
modifier|*
name|cl_pool
decl_stmt|;
name|uu_list_t
modifier|*
name|cl_list
decl_stmt|;
name|boolean_t
name|cl_waslegacy
decl_stmt|;
name|boolean_t
name|cl_allchildren
decl_stmt|;
name|boolean_t
name|cl_alldependents
decl_stmt|;
name|int
name|cl_flags
decl_stmt|;
name|boolean_t
name|cl_haszonedchild
decl_stmt|;
name|boolean_t
name|cl_sorted
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * If the property is 'mountpoint', go through and unmount filesystems as  * necessary.  We don't do the same for 'sharenfs', because we can just re-share  * with different options without interrupting service.  */
end_comment

begin_function
name|int
name|changelist_prefix
parameter_list|(
name|prop_changelist_t
modifier|*
name|clp
parameter_list|)
block|{
name|prop_changenode_t
modifier|*
name|cn
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|clp
operator|->
name|cl_prop
operator|!=
name|ZFS_PROP_MOUNTPOINT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|cn
operator|=
name|uu_list_first
argument_list|(
name|clp
operator|->
name|cl_list
argument_list|)
init|;
name|cn
operator|!=
name|NULL
condition|;
name|cn
operator|=
name|uu_list_next
argument_list|(
name|clp
operator|->
name|cl_list
argument_list|,
name|cn
argument_list|)
control|)
block|{
comment|/* 		 * If we are in the global zone, but this dataset is exported 		 * to a local zone, do nothing. 		 */
if|if
condition|(
name|getzoneid
argument_list|()
operator|==
name|GLOBAL_ZONEID
operator|&&
name|cn
operator|->
name|cn_zoned
condition|)
continue|continue;
if|if
condition|(
name|ZFS_IS_VOLUME
argument_list|(
name|cn
operator|->
name|cn_handle
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|clp
operator|->
name|cl_realprop
condition|)
block|{
case|case
name|ZFS_PROP_NAME
case|:
comment|/* 				 * If this was a rename, unshare the zvol, and 				 * remove the /dev/zvol links. 				 */
operator|(
name|void
operator|)
name|zfs_unshare_iscsi
argument_list|(
name|cn
operator|->
name|cn_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|zvol_remove_link
argument_list|(
name|cn
operator|->
name|cn_handle
operator|->
name|zfs_hdl
argument_list|,
name|cn
operator|->
name|cn_handle
operator|->
name|zfs_name
argument_list|)
operator|!=
literal|0
condition|)
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_VOLSIZE
case|:
comment|/* 				 * If this was a change to the volume size, we 				 * need to unshare and reshare the volume. 				 */
operator|(
name|void
operator|)
name|zfs_unshare_iscsi
argument_list|(
name|cn
operator|->
name|cn_handle
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|zfs_unmount
argument_list|(
name|cn
operator|->
name|cn_handle
argument_list|,
name|NULL
argument_list|,
name|clp
operator|->
name|cl_flags
argument_list|)
operator|!=
literal|0
condition|)
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If the property is 'mountpoint' or 'sharenfs', go through and remount and/or  * reshare the filesystems as necessary.  In changelist_gather() we recorded  * whether the filesystem was previously shared or mounted.  The action we take  * depends on the previous state, and whether the value was previously 'legacy'.  * For non-legacy properties, we only remount/reshare the filesystem if it was  * previously mounted/shared.  Otherwise, we always remount/reshare the  * filesystem.  */
end_comment

begin_function
name|int
name|changelist_postfix
parameter_list|(
name|prop_changelist_t
modifier|*
name|clp
parameter_list|)
block|{
name|prop_changenode_t
modifier|*
name|cn
decl_stmt|;
name|char
name|shareopts
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* 	 * If we're changing the mountpoint, attempt to destroy the underlying 	 * mountpoint.  All other datasets will have inherited from this dataset 	 * (in which case their mountpoints exist in the filesystem in the new 	 * location), or have explicit mountpoints set (in which case they won't 	 * be in the changelist). 	 */
if|if
condition|(
operator|(
name|cn
operator|=
name|uu_list_last
argument_list|(
name|clp
operator|->
name|cl_list
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|clp
operator|->
name|cl_prop
operator|==
name|ZFS_PROP_MOUNTPOINT
condition|)
name|remove_mountpoint
argument_list|(
name|cn
operator|->
name|cn_handle
argument_list|)
expr_stmt|;
comment|/* 	 * We walk the datasets in reverse, because we want to mount any parent 	 * datasets before mounting the children. 	 */
for|for
control|(
name|cn
operator|=
name|uu_list_last
argument_list|(
name|clp
operator|->
name|cl_list
argument_list|)
init|;
name|cn
operator|!=
name|NULL
condition|;
name|cn
operator|=
name|uu_list_prev
argument_list|(
name|clp
operator|->
name|cl_list
argument_list|,
name|cn
argument_list|)
control|)
block|{
comment|/* 		 * If we are in the global zone, but this dataset is exported 		 * to a local zone, do nothing. 		 */
if|if
condition|(
name|getzoneid
argument_list|()
operator|==
name|GLOBAL_ZONEID
operator|&&
name|cn
operator|->
name|cn_zoned
condition|)
continue|continue;
name|zfs_refresh_properties
argument_list|(
name|cn
operator|->
name|cn_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZFS_IS_VOLUME
argument_list|(
name|cn
operator|->
name|cn_handle
argument_list|)
condition|)
block|{
comment|/* 			 * If we're doing a rename, recreate the /dev/zvol 			 * links. 			 */
if|if
condition|(
name|clp
operator|->
name|cl_realprop
operator|==
name|ZFS_PROP_NAME
operator|&&
name|zvol_create_link
argument_list|(
name|cn
operator|->
name|cn_handle
operator|->
name|zfs_hdl
argument_list|,
name|cn
operator|->
name|cn_handle
operator|->
name|zfs_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cn
operator|->
name|cn_shared
operator|||
name|clp
operator|->
name|cl_prop
operator|==
name|ZFS_PROP_SHAREISCSI
condition|)
block|{
if|if
condition|(
name|zfs_prop_get
argument_list|(
name|cn
operator|->
name|cn_handle
argument_list|,
name|ZFS_PROP_SHAREISCSI
argument_list|,
name|shareopts
argument_list|,
sizeof|sizeof
argument_list|(
name|shareopts
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|shareopts
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|zfs_unshare_iscsi
argument_list|(
name|cn
operator|->
name|cn_handle
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|zfs_share_iscsi
argument_list|(
name|cn
operator|->
name|cn_handle
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue;
block|}
if|if
condition|(
operator|(
name|clp
operator|->
name|cl_waslegacy
operator|||
name|cn
operator|->
name|cn_mounted
operator|)
operator|&&
operator|!
name|zfs_is_mounted
argument_list|(
name|cn
operator|->
name|cn_handle
argument_list|,
name|NULL
argument_list|)
operator|&&
name|zfs_mount
argument_list|(
name|cn
operator|->
name|cn_handle
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 		 * We always re-share even if the filesystem is currently 		 * shared, so that we can adopt any new options. 		 */
if|if
condition|(
name|cn
operator|->
name|cn_shared
operator|||
operator|(
name|clp
operator|->
name|cl_prop
operator|==
name|ZFS_PROP_SHARENFS
operator|&&
name|clp
operator|->
name|cl_waslegacy
operator|)
condition|)
block|{
if|if
condition|(
name|zfs_prop_get
argument_list|(
name|cn
operator|->
name|cn_handle
argument_list|,
name|ZFS_PROP_SHARENFS
argument_list|,
name|shareopts
argument_list|,
sizeof|sizeof
argument_list|(
name|shareopts
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|shareopts
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|zfs_unshare_nfs
argument_list|(
name|cn
operator|->
name|cn_handle
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|zfs_share_nfs
argument_list|(
name|cn
operator|->
name|cn_handle
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Is this "dataset" a child of "parent"?  */
end_comment

begin_function
specifier|static
name|boolean_t
name|isa_child_of
parameter_list|(
specifier|const
name|char
modifier|*
name|dataset
parameter_list|,
specifier|const
name|char
modifier|*
name|parent
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|dataset
argument_list|,
name|parent
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|dataset
index|[
name|len
index|]
operator|==
literal|'@'
operator|||
name|dataset
index|[
name|len
index|]
operator|==
literal|'/'
operator|||
name|dataset
index|[
name|len
index|]
operator|==
literal|'\0'
operator|)
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
else|else
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If we rename a filesystem, child filesystem handles are no longer valid  * since we identify each dataset by its name in the ZFS namespace.  As a  * result, we have to go through and fix up all the names appropriately.  We  * could do this automatically if libzfs kept track of all open handles, but  * this is a lot less work.  */
end_comment

begin_function
name|void
name|changelist_rename
parameter_list|(
name|prop_changelist_t
modifier|*
name|clp
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
specifier|const
name|char
modifier|*
name|dst
parameter_list|)
block|{
name|prop_changenode_t
modifier|*
name|cn
decl_stmt|;
name|char
name|newname
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
for|for
control|(
name|cn
operator|=
name|uu_list_first
argument_list|(
name|clp
operator|->
name|cl_list
argument_list|)
init|;
name|cn
operator|!=
name|NULL
condition|;
name|cn
operator|=
name|uu_list_next
argument_list|(
name|clp
operator|->
name|cl_list
argument_list|,
name|cn
argument_list|)
control|)
block|{
comment|/* 		 * Do not rename a clone that's not in the source hierarchy. 		 */
if|if
condition|(
operator|!
name|isa_child_of
argument_list|(
name|cn
operator|->
name|cn_handle
operator|->
name|zfs_name
argument_list|,
name|src
argument_list|)
condition|)
continue|continue;
comment|/* 		 * Destroy the previous mountpoint if needed. 		 */
name|remove_mountpoint
argument_list|(
name|cn
operator|->
name|cn_handle
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|newname
argument_list|,
name|dst
argument_list|,
sizeof|sizeof
argument_list|(
name|newname
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|newname
argument_list|,
name|cn
operator|->
name|cn_handle
operator|->
name|zfs_name
operator|+
name|strlen
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|cn
operator|->
name|cn_handle
operator|->
name|zfs_name
argument_list|,
name|newname
argument_list|,
sizeof|sizeof
argument_list|(
name|cn
operator|->
name|cn_handle
operator|->
name|zfs_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Given a gathered changelist for the 'sharenfs' property, unshare all the  * datasets in the list.  */
end_comment

begin_function
name|int
name|changelist_unshare
parameter_list|(
name|prop_changelist_t
modifier|*
name|clp
parameter_list|)
block|{
name|prop_changenode_t
modifier|*
name|cn
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|clp
operator|->
name|cl_prop
operator|!=
name|ZFS_PROP_SHARENFS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|cn
operator|=
name|uu_list_first
argument_list|(
name|clp
operator|->
name|cl_list
argument_list|)
init|;
name|cn
operator|!=
name|NULL
condition|;
name|cn
operator|=
name|uu_list_next
argument_list|(
name|clp
operator|->
name|cl_list
argument_list|,
name|cn
argument_list|)
control|)
block|{
if|if
condition|(
name|zfs_unshare_nfs
argument_list|(
name|cn
operator|->
name|cn_handle
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if there is any child exported to a local zone in a given changelist.  * This information has already been recorded while gathering the changelist  * via changelist_gather().  */
end_comment

begin_function
name|int
name|changelist_haszonedchild
parameter_list|(
name|prop_changelist_t
modifier|*
name|clp
parameter_list|)
block|{
return|return
operator|(
name|clp
operator|->
name|cl_haszonedchild
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a node from a gathered list.  */
end_comment

begin_function
name|void
name|changelist_remove
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|prop_changelist_t
modifier|*
name|clp
parameter_list|)
block|{
name|prop_changenode_t
modifier|*
name|cn
decl_stmt|;
for|for
control|(
name|cn
operator|=
name|uu_list_first
argument_list|(
name|clp
operator|->
name|cl_list
argument_list|)
init|;
name|cn
operator|!=
name|NULL
condition|;
name|cn
operator|=
name|uu_list_next
argument_list|(
name|clp
operator|->
name|cl_list
argument_list|,
name|cn
argument_list|)
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|cn
operator|->
name|cn_handle
operator|->
name|zfs_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|uu_list_remove
argument_list|(
name|clp
operator|->
name|cl_list
argument_list|,
name|cn
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|cn
operator|->
name|cn_handle
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cn
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Release any memory associated with a changelist.  */
end_comment

begin_function
name|void
name|changelist_free
parameter_list|(
name|prop_changelist_t
modifier|*
name|clp
parameter_list|)
block|{
name|prop_changenode_t
modifier|*
name|cn
decl_stmt|;
name|uu_list_walk_t
modifier|*
name|walk
decl_stmt|;
if|if
condition|(
name|clp
operator|->
name|cl_list
condition|)
block|{
name|verify
argument_list|(
operator|(
name|walk
operator|=
name|uu_list_walk_start
argument_list|(
name|clp
operator|->
name|cl_list
argument_list|,
name|UU_WALK_ROBUST
argument_list|)
operator|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cn
operator|=
name|uu_list_walk_next
argument_list|(
name|walk
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|uu_list_remove
argument_list|(
name|clp
operator|->
name|cl_list
argument_list|,
name|cn
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|cn
operator|->
name|cn_handle
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cn
argument_list|)
expr_stmt|;
block|}
name|uu_list_walk_end
argument_list|(
name|walk
argument_list|)
expr_stmt|;
name|uu_list_destroy
argument_list|(
name|clp
operator|->
name|cl_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|clp
operator|->
name|cl_pool
condition|)
name|uu_list_pool_destroy
argument_list|(
name|clp
operator|->
name|cl_pool
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|clp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|change_one
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|prop_changelist_t
modifier|*
name|clp
init|=
name|data
decl_stmt|;
name|char
name|property
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
name|char
name|where
index|[
literal|64
index|]
decl_stmt|;
name|prop_changenode_t
modifier|*
name|cn
decl_stmt|;
name|zfs_source_t
name|sourcetype
decl_stmt|;
comment|/* 	 * We only want to unmount/unshare those filesystems that may inherit 	 * from the target filesystem.  If we find any filesystem with a 	 * locally set mountpoint, we ignore any children since changing the 	 * property will not affect them.  If this is a rename, we iterate 	 * over all children regardless, since we need them unmounted in 	 * order to do the rename.  Also, if this is a volume and we're doing 	 * a rename, then always add it to the changelist. 	 */
if|if
condition|(
operator|!
operator|(
name|ZFS_IS_VOLUME
argument_list|(
name|zhp
argument_list|)
operator|&&
name|clp
operator|->
name|cl_realprop
operator|==
name|ZFS_PROP_NAME
operator|)
operator|&&
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|clp
operator|->
name|cl_prop
argument_list|,
name|property
argument_list|,
sizeof|sizeof
argument_list|(
name|property
argument_list|)
argument_list|,
operator|&
name|sourcetype
argument_list|,
name|where
argument_list|,
sizeof|sizeof
argument_list|(
name|where
argument_list|)
argument_list|,
name|B_FALSE
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|clp
operator|->
name|cl_alldependents
operator|||
name|clp
operator|->
name|cl_allchildren
operator|||
name|sourcetype
operator|==
name|ZFS_SRC_DEFAULT
operator|||
name|sourcetype
operator|==
name|ZFS_SRC_INHERITED
condition|)
block|{
if|if
condition|(
operator|(
name|cn
operator|=
name|zfs_alloc
argument_list|(
name|zfs_get_handle
argument_list|(
name|zhp
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|prop_changenode_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cn
operator|->
name|cn_handle
operator|=
name|zhp
expr_stmt|;
name|cn
operator|->
name|cn_mounted
operator|=
name|zfs_is_mounted
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cn
operator|->
name|cn_shared
operator|=
name|zfs_is_shared
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
name|cn
operator|->
name|cn_zoned
operator|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_ZONED
argument_list|)
expr_stmt|;
comment|/* Indicate if any child is exported to a local zone. */
if|if
condition|(
name|getzoneid
argument_list|()
operator|==
name|GLOBAL_ZONEID
operator|&&
name|cn
operator|->
name|cn_zoned
condition|)
name|clp
operator|->
name|cl_haszonedchild
operator|=
name|B_TRUE
expr_stmt|;
name|uu_list_node_init
argument_list|(
name|cn
argument_list|,
operator|&
name|cn
operator|->
name|cn_listnode
argument_list|,
name|clp
operator|->
name|cl_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|->
name|cl_sorted
condition|)
block|{
name|uu_list_index_t
name|idx
decl_stmt|;
operator|(
name|void
operator|)
name|uu_list_find
argument_list|(
name|clp
operator|->
name|cl_list
argument_list|,
name|cn
argument_list|,
name|NULL
argument_list|,
operator|&
name|idx
argument_list|)
expr_stmt|;
name|uu_list_insert
argument_list|(
name|clp
operator|->
name|cl_list
argument_list|,
name|cn
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
operator|!
name|clp
operator|->
name|cl_alldependents
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|uu_list_insert_before
argument_list|(
name|clp
operator|->
name|cl_list
argument_list|,
name|uu_list_first
argument_list|(
name|clp
operator|->
name|cl_list
argument_list|)
argument_list|,
name|cn
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|clp
operator|->
name|cl_alldependents
condition|)
return|return
operator|(
name|zfs_iter_children
argument_list|(
name|zhp
argument_list|,
name|change_one
argument_list|,
name|data
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|compare_mountpoints
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
specifier|const
name|prop_changenode_t
modifier|*
name|ca
init|=
name|a
decl_stmt|;
specifier|const
name|prop_changenode_t
modifier|*
name|cb
init|=
name|b
decl_stmt|;
name|char
name|mounta
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|mountb
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|boolean_t
name|hasmounta
decl_stmt|,
name|hasmountb
decl_stmt|;
comment|/* 	 * When unsharing or unmounting filesystems, we need to do it in 	 * mountpoint order.  This allows the user to have a mountpoint 	 * hierarchy that is different from the dataset hierarchy, and still 	 * allow it to be changed.  However, if either dataset doesn't have a 	 * mountpoint (because it is a volume or a snapshot), we place it at the 	 * end of the list, because it doesn't affect our change at all. 	 */
name|hasmounta
operator|=
operator|(
name|zfs_prop_get
argument_list|(
name|ca
operator|->
name|cn_handle
argument_list|,
name|ZFS_PROP_MOUNTPOINT
argument_list|,
name|mounta
argument_list|,
sizeof|sizeof
argument_list|(
name|mounta
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|hasmountb
operator|=
operator|(
name|zfs_prop_get
argument_list|(
name|cb
operator|->
name|cn_handle
argument_list|,
name|ZFS_PROP_MOUNTPOINT
argument_list|,
name|mountb
argument_list|,
sizeof|sizeof
argument_list|(
name|mountb
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|hasmounta
operator|&&
name|hasmountb
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|hasmounta
operator|&&
operator|!
name|hasmountb
condition|)
return|return
operator|(
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
operator|!
name|hasmounta
operator|&&
operator|!
name|hasmountb
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|strcmp
argument_list|(
name|mountb
argument_list|,
name|mounta
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a ZFS handle and a property, construct a complete list of datasets  * that need to be modified as part of this process.  For anything but the  * 'mountpoint' and 'sharenfs' properties, this just returns an empty list.  * Otherwise, we iterate over all children and look for any datasets that  * inherit the property.  For each such dataset, we add it to the list and  * mark whether it was shared beforehand.  */
end_comment

begin_function
name|prop_changelist_t
modifier|*
name|changelist_gather
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|prop_changelist_t
modifier|*
name|clp
decl_stmt|;
name|prop_changenode_t
modifier|*
name|cn
decl_stmt|;
name|zfs_handle_t
modifier|*
name|temp
decl_stmt|;
name|char
name|property
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
name|uu_compare_fn_t
modifier|*
name|compare
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|clp
operator|=
name|zfs_alloc
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|prop_changelist_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * For mountpoint-related tasks, we want to sort everything by 	 * mountpoint, so that we mount and unmount them in the appropriate 	 * order, regardless of their position in the hierarchy. 	 */
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_NAME
operator|||
name|prop
operator|==
name|ZFS_PROP_ZONED
operator|||
name|prop
operator|==
name|ZFS_PROP_MOUNTPOINT
operator|||
name|prop
operator|==
name|ZFS_PROP_SHARENFS
condition|)
block|{
name|compare
operator|=
name|compare_mountpoints
expr_stmt|;
name|clp
operator|->
name|cl_sorted
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|clp
operator|->
name|cl_pool
operator|=
name|uu_list_pool_create
argument_list|(
literal|"changelist_pool"
argument_list|,
sizeof|sizeof
argument_list|(
name|prop_changenode_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|prop_changenode_t
argument_list|,
name|cn_listnode
argument_list|)
argument_list|,
name|compare
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|->
name|cl_pool
operator|==
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|uu_error
argument_list|()
operator|==
name|UU_ERROR_NO_MEMORY
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|EZFS_NOMEM
argument_list|,
literal|"internal error"
argument_list|)
expr_stmt|;
name|changelist_free
argument_list|(
name|clp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|clp
operator|->
name|cl_list
operator|=
name|uu_list_create
argument_list|(
name|clp
operator|->
name|cl_pool
argument_list|,
name|NULL
argument_list|,
name|clp
operator|->
name|cl_sorted
condition|?
name|UU_LIST_SORTED
else|:
literal|0
argument_list|)
expr_stmt|;
name|clp
operator|->
name|cl_flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|clp
operator|->
name|cl_list
operator|==
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|uu_error
argument_list|()
operator|==
name|UU_ERROR_NO_MEMORY
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|EZFS_NOMEM
argument_list|,
literal|"internal error"
argument_list|)
expr_stmt|;
name|changelist_free
argument_list|(
name|clp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * If this is a rename or the 'zoned' property, we pretend we're 	 * changing the mountpoint and flag it so we can catch all children in 	 * change_one(). 	 * 	 * Flag cl_alldependents to catch all children plus the dependents 	 * (clones) that are not in the hierarchy. 	 */
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_NAME
condition|)
block|{
name|clp
operator|->
name|cl_prop
operator|=
name|ZFS_PROP_MOUNTPOINT
expr_stmt|;
name|clp
operator|->
name|cl_alldependents
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_ZONED
condition|)
block|{
name|clp
operator|->
name|cl_prop
operator|=
name|ZFS_PROP_MOUNTPOINT
expr_stmt|;
name|clp
operator|->
name|cl_allchildren
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_CANMOUNT
condition|)
block|{
name|clp
operator|->
name|cl_prop
operator|=
name|ZFS_PROP_MOUNTPOINT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_VOLSIZE
condition|)
block|{
name|clp
operator|->
name|cl_prop
operator|=
name|ZFS_PROP_MOUNTPOINT
expr_stmt|;
block|}
else|else
block|{
name|clp
operator|->
name|cl_prop
operator|=
name|prop
expr_stmt|;
block|}
name|clp
operator|->
name|cl_realprop
operator|=
name|prop
expr_stmt|;
if|if
condition|(
name|clp
operator|->
name|cl_prop
operator|!=
name|ZFS_PROP_MOUNTPOINT
operator|&&
name|clp
operator|->
name|cl_prop
operator|!=
name|ZFS_PROP_SHARENFS
operator|&&
name|clp
operator|->
name|cl_prop
operator|!=
name|ZFS_PROP_SHAREISCSI
condition|)
return|return
operator|(
name|clp
operator|)
return|;
if|if
condition|(
name|clp
operator|->
name|cl_alldependents
condition|)
block|{
if|if
condition|(
name|zfs_iter_dependents
argument_list|(
name|zhp
argument_list|,
name|B_TRUE
argument_list|,
name|change_one
argument_list|,
name|clp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|changelist_free
argument_list|(
name|clp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|zfs_iter_children
argument_list|(
name|zhp
argument_list|,
name|change_one
argument_list|,
name|clp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|changelist_free
argument_list|(
name|clp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * We have to re-open ourselves because we auto-close all the handles 	 * and can't tell the difference. 	 */
if|if
condition|(
operator|(
name|temp
operator|=
name|zfs_open
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|ZFS_TYPE_ANY
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|changelist_free
argument_list|(
name|clp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Always add ourself to the list.  We add ourselves to the end so that 	 * we're the last to be unmounted. 	 */
if|if
condition|(
operator|(
name|cn
operator|=
name|zfs_alloc
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|prop_changenode_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|zfs_close
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|changelist_free
argument_list|(
name|clp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|cn
operator|->
name|cn_handle
operator|=
name|temp
expr_stmt|;
name|cn
operator|->
name|cn_mounted
operator|=
name|zfs_is_mounted
argument_list|(
name|temp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cn
operator|->
name|cn_shared
operator|=
name|zfs_is_shared
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|cn
operator|->
name|cn_zoned
operator|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_ZONED
argument_list|)
expr_stmt|;
name|uu_list_node_init
argument_list|(
name|cn
argument_list|,
operator|&
name|cn
operator|->
name|cn_listnode
argument_list|,
name|clp
operator|->
name|cl_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|->
name|cl_sorted
condition|)
block|{
name|uu_list_index_t
name|idx
decl_stmt|;
operator|(
name|void
operator|)
name|uu_list_find
argument_list|(
name|clp
operator|->
name|cl_list
argument_list|,
name|cn
argument_list|,
name|NULL
argument_list|,
operator|&
name|idx
argument_list|)
expr_stmt|;
name|uu_list_insert
argument_list|(
name|clp
operator|->
name|cl_list
argument_list|,
name|cn
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|verify
argument_list|(
name|uu_list_insert_after
argument_list|(
name|clp
operator|->
name|cl_list
argument_list|,
name|uu_list_last
argument_list|(
name|clp
operator|->
name|cl_list
argument_list|)
argument_list|,
name|cn
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the property was previously 'legacy' or 'none', record this fact, 	 * as the behavior of changelist_postfix() will be different. 	 */
if|if
condition|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|property
argument_list|,
sizeof|sizeof
argument_list|(
name|property
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|strcmp
argument_list|(
name|property
argument_list|,
literal|"legacy"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|property
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|property
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|clp
operator|->
name|cl_waslegacy
operator|=
name|B_TRUE
expr_stmt|;
return|return
operator|(
name|clp
operator|)
return|;
block|}
end_function

end_unit

