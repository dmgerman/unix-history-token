begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_comment
comment|/*  * Iterate over all children of the current object.  This includes the normal  * dataset hierarchy, but also arbitrary hierarchies due to clones.  We want to  * walk all datasets in the pool, and construct a directed graph of the form:  *  * 			home  *                        |  *                   +----+----+  *                   |         |  *                   v         v             ws  *                  bar       baz             |  *                             |              |  *                             v              v  *                          @yesterday ----> foo  *  * In order to construct this graph, we have to walk every dataset in the pool,  * because the clone parent is stored as a property of the child, not the  * parent.  The parent only keeps track of the number of clones.  *  * In the normal case (without clones) this would be rather expensive.  To avoid  * unnecessary computation, we first try a walk of the subtree hierarchy  * starting from the initial node.  At each dataset, we construct a node in the  * graph and an edge leading from its parent.  If we don't see any snapshots  * with a non-zero clone count, then we are finished.  *  * If we do find a cloned snapshot, then we finish the walk of the current  * subtree, but indicate that we need to do a complete walk.  We then perform a  * global walk of all datasets, avoiding the subtree we already processed.  *  * At the end of this, we'll end up with a directed graph of all relevant (and  * possible some irrelevant) datasets in the system.  We need to both find our  * limiting subgraph and determine a safe ordering in which to destroy the  * datasets.  We do a topological ordering of our graph starting at our target  * dataset, and then walk the results in reverse.  *  * It's possible for the graph to have cycles if, for example, the user renames  * a clone to be the parent of its origin snapshot.  The user can request to  * generate an error in this case, or ignore the cycle and continue.  *  * When removing datasets, we want to destroy the snapshots in chronological  * order (because this is the most efficient method).  In order to accomplish  * this, we store the creation transaction group with each vertex and keep each  * vertex's edges sorted according to this value.  The topological sort will  * automatically walk the snapshots in the correct order.  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<libzfs.h>
end_include

begin_include
include|#
directive|include
file|"libzfs_impl.h"
end_include

begin_include
include|#
directive|include
file|"zfs_namecheck.h"
end_include

begin_define
define|#
directive|define
name|MIN_EDGECOUNT
value|4
end_define

begin_comment
comment|/*  * Vertex structure.  Indexed by dataset name, this structure maintains a list  * of edges to other vertices.  */
end_comment

begin_struct_decl
struct_decl|struct
name|zfs_edge
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
struct|struct
name|zfs_vertex
block|{
name|char
name|zv_dataset
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
name|struct
name|zfs_vertex
modifier|*
name|zv_next
decl_stmt|;
name|int
name|zv_visited
decl_stmt|;
name|uint64_t
name|zv_txg
decl_stmt|;
name|struct
name|zfs_edge
modifier|*
modifier|*
name|zv_edges
decl_stmt|;
name|int
name|zv_edgecount
decl_stmt|;
name|int
name|zv_edgealloc
decl_stmt|;
block|}
name|zfs_vertex_t
typedef|;
end_typedef

begin_enum
enum|enum
block|{
name|VISIT_SEEN
init|=
literal|1
block|,
name|VISIT_SORT_PRE
block|,
name|VISIT_SORT_POST
block|}
enum|;
end_enum

begin_comment
comment|/*  * Edge structure.  Simply maintains a pointer to the destination vertex.  There  * is no need to store the source vertex, since we only use edges in the context  * of the source vertex.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|zfs_edge
block|{
name|zfs_vertex_t
modifier|*
name|ze_dest
decl_stmt|;
name|struct
name|zfs_edge
modifier|*
name|ze_next
decl_stmt|;
block|}
name|zfs_edge_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ZFS_GRAPH_SIZE
value|1027
end_define

begin_comment
comment|/* this could be dynamic some day */
end_comment

begin_comment
comment|/*  * Graph structure.  Vertices are maintained in a hash indexed by dataset name.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|zfs_graph
block|{
name|zfs_vertex_t
modifier|*
modifier|*
name|zg_hash
decl_stmt|;
name|size_t
name|zg_size
decl_stmt|;
name|size_t
name|zg_nvertex
decl_stmt|;
block|}
name|zfs_graph_t
typedef|;
end_typedef

begin_comment
comment|/*  * Allocate a new edge pointing to the target vertex.  */
end_comment

begin_function
specifier|static
name|zfs_edge_t
modifier|*
name|zfs_edge_create
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|zfs_vertex_t
modifier|*
name|dest
parameter_list|)
block|{
name|zfs_edge_t
modifier|*
name|zep
init|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_edge_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|zep
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|zep
operator|->
name|ze_dest
operator|=
name|dest
expr_stmt|;
return|return
operator|(
name|zep
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy an edge.  */
end_comment

begin_function
specifier|static
name|void
name|zfs_edge_destroy
parameter_list|(
name|zfs_edge_t
modifier|*
name|zep
parameter_list|)
block|{
name|free
argument_list|(
name|zep
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new vertex with the given name.  */
end_comment

begin_function
specifier|static
name|zfs_vertex_t
modifier|*
name|zfs_vertex_create
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|dataset
parameter_list|)
block|{
name|zfs_vertex_t
modifier|*
name|zvp
init|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_vertex_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|zvp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|assert
argument_list|(
name|strlen
argument_list|(
name|dataset
argument_list|)
operator|<
name|ZFS_MAXNAMELEN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zvp
operator|->
name|zv_dataset
argument_list|,
name|dataset
argument_list|,
sizeof|sizeof
argument_list|(
name|zvp
operator|->
name|zv_dataset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zvp
operator|->
name|zv_edges
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
name|MIN_EDGECOUNT
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|zvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|zvp
operator|->
name|zv_edgealloc
operator|=
name|MIN_EDGECOUNT
expr_stmt|;
return|return
operator|(
name|zvp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy a vertex.  Frees up any associated edges.  */
end_comment

begin_function
specifier|static
name|void
name|zfs_vertex_destroy
parameter_list|(
name|zfs_vertex_t
modifier|*
name|zvp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zvp
operator|->
name|zv_edgecount
condition|;
name|i
operator|++
control|)
name|zfs_edge_destroy
argument_list|(
name|zvp
operator|->
name|zv_edges
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zvp
operator|->
name|zv_edges
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zvp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a vertex, add an edge to the destination vertex.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_vertex_add_edge
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|zfs_vertex_t
modifier|*
name|zvp
parameter_list|,
name|zfs_vertex_t
modifier|*
name|dest
parameter_list|)
block|{
name|zfs_edge_t
modifier|*
name|zep
init|=
name|zfs_edge_create
argument_list|(
name|hdl
argument_list|,
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|zep
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|zvp
operator|->
name|zv_edgecount
operator|==
name|zvp
operator|->
name|zv_edgealloc
condition|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|zfs_realloc
argument_list|(
name|hdl
argument_list|,
name|zvp
operator|->
name|zv_edges
argument_list|,
name|zvp
operator|->
name|zv_edgealloc
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|zvp
operator|->
name|zv_edgealloc
operator|*
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|zvp
operator|->
name|zv_edges
operator|=
name|ptr
expr_stmt|;
name|zvp
operator|->
name|zv_edgealloc
operator|*=
literal|2
expr_stmt|;
block|}
name|zvp
operator|->
name|zv_edges
index|[
name|zvp
operator|->
name|zv_edgecount
operator|++
index|]
operator|=
name|zep
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_edge_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|zfs_edge_t
modifier|*
name|ea
init|=
operator|*
operator|(
operator|(
name|zfs_edge_t
operator|*
operator|*
operator|)
name|a
operator|)
decl_stmt|;
specifier|const
name|zfs_edge_t
modifier|*
name|eb
init|=
operator|*
operator|(
operator|(
name|zfs_edge_t
operator|*
operator|*
operator|)
name|b
operator|)
decl_stmt|;
if|if
condition|(
name|ea
operator|->
name|ze_dest
operator|->
name|zv_txg
operator|<
name|eb
operator|->
name|ze_dest
operator|->
name|zv_txg
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|ea
operator|->
name|ze_dest
operator|->
name|zv_txg
operator|>
name|eb
operator|->
name|ze_dest
operator|->
name|zv_txg
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sort the given vertex edges according to the creation txg of each vertex.  */
end_comment

begin_function
specifier|static
name|void
name|zfs_vertex_sort_edges
parameter_list|(
name|zfs_vertex_t
modifier|*
name|zvp
parameter_list|)
block|{
if|if
condition|(
name|zvp
operator|->
name|zv_edgecount
operator|==
literal|0
condition|)
return|return;
name|qsort
argument_list|(
name|zvp
operator|->
name|zv_edges
argument_list|,
name|zvp
operator|->
name|zv_edgecount
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|zfs_edge_compare
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Construct a new graph object.  We allow the size to be specified as a  * parameter so in the future we can size the hash according to the number of  * datasets in the pool.  */
end_comment

begin_function
specifier|static
name|zfs_graph_t
modifier|*
name|zfs_graph_create
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|zfs_graph_t
modifier|*
name|zgp
init|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_graph_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|zgp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|zgp
operator|->
name|zg_size
operator|=
name|size
expr_stmt|;
if|if
condition|(
operator|(
name|zgp
operator|->
name|zg_hash
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|zfs_vertex_t
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|zgp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|zgp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy a graph object.  We have to iterate over all the hash chains,  * destroying each vertex in the process.  */
end_comment

begin_function
specifier|static
name|void
name|zfs_graph_destroy
parameter_list|(
name|zfs_graph_t
modifier|*
name|zgp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|zfs_vertex_t
modifier|*
name|current
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zgp
operator|->
name|zg_size
condition|;
name|i
operator|++
control|)
block|{
name|current
operator|=
name|zgp
operator|->
name|zg_hash
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|current
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|current
operator|->
name|zv_next
expr_stmt|;
name|zfs_vertex_destroy
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|current
operator|=
name|next
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|zgp
operator|->
name|zg_hash
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zgp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Graph hash function.  Classic bernstein k=33 hash function, taken from  * usr/src/cmd/sgs/tools/common/strhash.c  */
end_comment

begin_function
specifier|static
name|size_t
name|zfs_graph_hash
parameter_list|(
name|zfs_graph_t
modifier|*
name|zgp
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|size_t
name|hash
init|=
literal|5381
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|str
operator|++
operator|)
operator|!=
literal|0
condition|)
name|hash
operator|=
operator|(
operator|(
name|hash
operator|<<
literal|5
operator|)
operator|+
name|hash
operator|)
operator|+
name|c
expr_stmt|;
comment|/* hash * 33 + c */
return|return
operator|(
name|hash
operator|%
name|zgp
operator|->
name|zg_size
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a dataset name, finds the associated vertex, creating it if necessary.  */
end_comment

begin_function
specifier|static
name|zfs_vertex_t
modifier|*
name|zfs_graph_lookup
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|zfs_graph_t
modifier|*
name|zgp
parameter_list|,
specifier|const
name|char
modifier|*
name|dataset
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|size_t
name|idx
init|=
name|zfs_graph_hash
argument_list|(
name|zgp
argument_list|,
name|dataset
argument_list|)
decl_stmt|;
name|zfs_vertex_t
modifier|*
name|zvp
decl_stmt|;
for|for
control|(
name|zvp
operator|=
name|zgp
operator|->
name|zg_hash
index|[
name|idx
index|]
init|;
name|zvp
operator|!=
name|NULL
condition|;
name|zvp
operator|=
name|zvp
operator|->
name|zv_next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|zvp
operator|->
name|zv_dataset
argument_list|,
name|dataset
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|zvp
operator|->
name|zv_txg
operator|==
literal|0
condition|)
name|zvp
operator|->
name|zv_txg
operator|=
name|txg
expr_stmt|;
return|return
operator|(
name|zvp
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|zvp
operator|=
name|zfs_vertex_create
argument_list|(
name|hdl
argument_list|,
name|dataset
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|zvp
operator|->
name|zv_next
operator|=
name|zgp
operator|->
name|zg_hash
index|[
name|idx
index|]
expr_stmt|;
name|zvp
operator|->
name|zv_txg
operator|=
name|txg
expr_stmt|;
name|zgp
operator|->
name|zg_hash
index|[
name|idx
index|]
operator|=
name|zvp
expr_stmt|;
name|zgp
operator|->
name|zg_nvertex
operator|++
expr_stmt|;
return|return
operator|(
name|zvp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given two dataset names, create an edge between them.  For the source vertex,  * mark 'zv_visited' to indicate that we have seen this vertex, and not simply  * created it as a destination of another edge.  If 'dest' is NULL, then this  * is an individual vertex (i.e. the starting vertex), so don't add an edge.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_graph_add
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|zfs_graph_t
modifier|*
name|zgp
parameter_list|,
specifier|const
name|char
modifier|*
name|source
parameter_list|,
specifier|const
name|char
modifier|*
name|dest
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|zfs_vertex_t
modifier|*
name|svp
decl_stmt|,
modifier|*
name|dvp
decl_stmt|;
if|if
condition|(
operator|(
name|svp
operator|=
name|zfs_graph_lookup
argument_list|(
name|hdl
argument_list|,
name|zgp
argument_list|,
name|source
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|svp
operator|->
name|zv_visited
operator|=
name|VISIT_SEEN
expr_stmt|;
if|if
condition|(
name|dest
operator|!=
name|NULL
condition|)
block|{
name|dvp
operator|=
name|zfs_graph_lookup
argument_list|(
name|hdl
argument_list|,
name|zgp
argument_list|,
name|dest
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dvp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|zfs_vertex_add_edge
argument_list|(
name|hdl
argument_list|,
name|svp
argument_list|,
name|dvp
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate over all children of the given dataset, adding any vertices as  * necessary.  Returns 0 if no cloned snapshots were seen, -1 if there was an  * error, or 1 otherwise.  This is a simple recursive algorithm - the ZFS  * namespace typically is very flat.  We manually invoke the necessary ioctl()  * calls to avoid the overhead and additional semantics of zfs_open().  */
end_comment

begin_function
specifier|static
name|int
name|iterate_children
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|zfs_graph_t
modifier|*
name|zgp
parameter_list|,
specifier|const
name|char
modifier|*
name|dataset
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|err
decl_stmt|;
name|zfs_vertex_t
modifier|*
name|zvp
decl_stmt|;
comment|/* 	 * Look up the source vertex, and avoid it if we've seen it before. 	 */
name|zvp
operator|=
name|zfs_graph_lookup
argument_list|(
name|hdl
argument_list|,
name|zgp
argument_list|,
name|dataset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zvp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|zvp
operator|->
name|zv_visited
operator|==
name|VISIT_SEEN
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * We check the clone parent here instead of within the loop, so that if 	 * the root dataset has been promoted from a clone, we find its parent 	 * appropriately. 	 */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|dataset
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_OBJSET_STATS
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
operator|&&
name|zc
operator|.
name|zc_objset_stats
operator|.
name|dds_clone_of
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|zfs_graph_add
argument_list|(
name|hdl
argument_list|,
name|zgp
argument_list|,
name|zc
operator|.
name|zc_objset_stats
operator|.
name|dds_clone_of
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|,
name|zc
operator|.
name|zc_objset_stats
operator|.
name|dds_creation_txg
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|dataset
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
init|;
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_DATASET_LIST_NEXT
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|dataset
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
control|)
block|{
comment|/* 		 * Ignore private dataset names. 		 */
if|if
condition|(
name|dataset_name_hidden
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
condition|)
continue|continue;
comment|/* 		 * Get statistics for this dataset, to determine the type of the 		 * dataset and clone statistics.  If this fails, the dataset has 		 * since been removed, and we're pretty much screwed anyway. 		 */
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_OBJSET_STATS
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* 		 * Add an edge between the parent and the child. 		 */
if|if
condition|(
name|zfs_graph_add
argument_list|(
name|hdl
argument_list|,
name|zgp
argument_list|,
name|dataset
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|,
name|zc
operator|.
name|zc_objset_stats
operator|.
name|dds_creation_txg
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 		 * Iterate over all children 		 */
name|err
operator|=
name|iterate_children
argument_list|(
name|hdl
argument_list|,
name|zgp
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|err
operator|==
literal|1
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Indicate if we found a dataset with a non-zero clone count. 		 */
if|if
condition|(
name|zc
operator|.
name|zc_objset_stats
operator|.
name|dds_num_clones
operator|!=
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Now iterate over all snapshots. 	 */
name|bzero
argument_list|(
operator|&
name|zc
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|dataset
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
init|;
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_SNAPSHOT_LIST_NEXT
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|dataset
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
control|)
block|{
comment|/* 		 * Get statistics for this dataset, to determine the type of the 		 * dataset and clone statistics.  If this fails, the dataset has 		 * since been removed, and we're pretty much screwed anyway. 		 */
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_OBJSET_STATS
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* 		 * Add an edge between the parent and the child. 		 */
if|if
condition|(
name|zfs_graph_add
argument_list|(
name|hdl
argument_list|,
name|zgp
argument_list|,
name|dataset
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|,
name|zc
operator|.
name|zc_objset_stats
operator|.
name|dds_creation_txg
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 		 * Indicate if we found a dataset with a non-zero clone count. 		 */
if|if
condition|(
name|zc
operator|.
name|zc_objset_stats
operator|.
name|dds_num_clones
operator|!=
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
block|}
name|zvp
operator|->
name|zv_visited
operator|=
name|VISIT_SEEN
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Construct a complete graph of all necessary vertices.  First, we iterate over  * only our object's children.  If we don't find any cloned snapshots, then we  * simple return that.  Otherwise, we have to start at the pool root and iterate  * over all datasets.  */
end_comment

begin_function
specifier|static
name|zfs_graph_t
modifier|*
name|construct_graph
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|dataset
parameter_list|)
block|{
name|zfs_graph_t
modifier|*
name|zgp
init|=
name|zfs_graph_create
argument_list|(
name|hdl
argument_list|,
name|ZFS_GRAPH_SIZE
argument_list|)
decl_stmt|;
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|zgp
operator|==
name|NULL
condition|)
return|return
operator|(
name|zgp
operator|)
return|;
comment|/* 	 * We need to explicitly check whether this dataset has clones or not, 	 * since iterate_children() only checks the children. 	 */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|dataset
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_OBJSET_STATS
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|zc
operator|.
name|zc_objset_stats
operator|.
name|dds_num_clones
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|iterate_children
argument_list|(
name|hdl
argument_list|,
name|zgp
argument_list|,
name|dataset
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Determine pool name and try again. 		 */
name|char
modifier|*
name|pool
decl_stmt|,
modifier|*
name|slash
decl_stmt|;
if|if
condition|(
operator|(
name|slash
operator|=
name|strchr
argument_list|(
name|dataset
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|slash
operator|=
name|strchr
argument_list|(
name|dataset
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pool
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
name|slash
operator|-
name|dataset
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool
operator|==
name|NULL
condition|)
block|{
name|zfs_graph_destroy
argument_list|(
name|zgp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|pool
argument_list|,
name|dataset
argument_list|,
name|slash
operator|-
name|dataset
argument_list|)
expr_stmt|;
name|pool
index|[
name|slash
operator|-
name|dataset
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|iterate_children
argument_list|(
name|hdl
argument_list|,
name|zgp
argument_list|,
name|pool
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|zfs_graph_add
argument_list|(
name|hdl
argument_list|,
name|zgp
argument_list|,
name|pool
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|zfs_graph_destroy
argument_list|(
name|zgp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|free
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
operator|||
name|zfs_graph_add
argument_list|(
name|hdl
argument_list|,
name|zgp
argument_list|,
name|dataset
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_graph_destroy
argument_list|(
name|zgp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|zgp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a graph, do a recursive topological sort into the given array.  This is  * really just a depth first search, so that the deepest nodes appear first.  * hijack the 'zv_visited' marker to avoid visiting the same vertex twice.  */
end_comment

begin_function
specifier|static
name|int
name|topo_sort
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|boolean_t
name|allowrecursion
parameter_list|,
name|char
modifier|*
modifier|*
name|result
parameter_list|,
name|size_t
modifier|*
name|idx
parameter_list|,
name|zfs_vertex_t
modifier|*
name|zgv
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|zgv
operator|->
name|zv_visited
operator|==
name|VISIT_SORT_PRE
operator|&&
operator|!
name|allowrecursion
condition|)
block|{
comment|/* 		 * If we've already seen this vertex as part of our depth-first 		 * search, then we have a cyclic dependency, and we must return 		 * an error. 		 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"recursive dependency at '%s'"
argument_list|)
argument_list|,
name|zgv
operator|->
name|zv_dataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_RECURSIVE
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot determine dependent datasets"
argument_list|)
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|zgv
operator|->
name|zv_visited
operator|>=
name|VISIT_SORT_PRE
condition|)
block|{
comment|/* 		 * If we've already processed this as part of the topological 		 * sort, then don't bother doing so again. 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|zgv
operator|->
name|zv_visited
operator|=
name|VISIT_SORT_PRE
expr_stmt|;
comment|/* avoid doing a search if we don't have to */
name|zfs_vertex_sort_edges
argument_list|(
name|zgv
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zgv
operator|->
name|zv_edgecount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|topo_sort
argument_list|(
name|hdl
argument_list|,
name|allowrecursion
argument_list|,
name|result
argument_list|,
name|idx
argument_list|,
name|zgv
operator|->
name|zv_edges
index|[
name|i
index|]
operator|->
name|ze_dest
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* we may have visited this in the course of the above */
if|if
condition|(
name|zgv
operator|->
name|zv_visited
operator|==
name|VISIT_SORT_POST
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|result
index|[
operator|*
name|idx
index|]
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
name|strlen
argument_list|(
name|zgv
operator|->
name|zv_dataset
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|result
index|[
operator|*
name|idx
index|]
argument_list|,
name|zgv
operator|->
name|zv_dataset
argument_list|)
expr_stmt|;
operator|*
name|idx
operator|+=
literal|1
expr_stmt|;
name|zgv
operator|->
name|zv_visited
operator|=
name|VISIT_SORT_POST
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The only public interface for this file.  Do the dirty work of constructing a  * child list for the given object.  Construct the graph, do the toplogical  * sort, and then return the array of strings to the caller.  *  * The 'allowrecursion' parameter controls behavior when cycles are found.  If  * it is set, the the cycle is ignored and the results returned as if the cycle  * did not exist.  If it is not set, then the routine will generate an error if  * a cycle is found.  */
end_comment

begin_function
name|int
name|get_dependents
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|boolean_t
name|allowrecursion
parameter_list|,
specifier|const
name|char
modifier|*
name|dataset
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|result
parameter_list|,
name|size_t
modifier|*
name|count
parameter_list|)
block|{
name|zfs_graph_t
modifier|*
name|zgp
decl_stmt|;
name|zfs_vertex_t
modifier|*
name|zvp
decl_stmt|;
if|if
condition|(
operator|(
name|zgp
operator|=
name|construct_graph
argument_list|(
name|hdl
argument_list|,
name|dataset
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
operator|*
name|result
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
name|zgp
operator|->
name|zg_nvertex
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|zfs_graph_destroy
argument_list|(
name|zgp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|zvp
operator|=
name|zfs_graph_lookup
argument_list|(
name|hdl
argument_list|,
name|zgp
argument_list|,
name|dataset
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|*
name|result
argument_list|)
expr_stmt|;
name|zfs_graph_destroy
argument_list|(
name|zgp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|topo_sort
argument_list|(
name|hdl
argument_list|,
name|allowrecursion
argument_list|,
operator|*
name|result
argument_list|,
name|count
argument_list|,
name|zvp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
operator|*
name|result
argument_list|)
expr_stmt|;
name|zfs_graph_destroy
argument_list|(
name|zgp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Get rid of the last entry, which is our starting vertex and not 	 * strictly a dependent. 	 */
name|assert
argument_list|(
operator|*
name|count
operator|>
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
operator|*
name|result
operator|)
index|[
operator|*
name|count
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
operator|*
name|count
operator|)
operator|--
expr_stmt|;
name|zfs_graph_destroy
argument_list|(
name|zgp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

