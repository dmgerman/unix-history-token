begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<devid.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<umem.h>
end_include

begin_include
include|#
directive|include
file|"zfs_namecheck.h"
end_include

begin_include
include|#
directive|include
file|"zfs_prop.h"
end_include

begin_include
include|#
directive|include
file|"libzfs_impl.h"
end_include

begin_comment
comment|/*  * Validate the given pool name, optionally putting an extended error message in  * 'buf'.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|zpool_name_valid
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|boolean_t
name|isopen
parameter_list|,
specifier|const
name|char
modifier|*
name|pool
parameter_list|)
block|{
name|namecheck_err_t
name|why
decl_stmt|;
name|char
name|what
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|pool_namecheck
argument_list|(
name|pool
argument_list|,
operator|&
name|why
argument_list|,
operator|&
name|what
argument_list|)
expr_stmt|;
comment|/* 	 * The rules for reserved pool names were extended at a later point. 	 * But we need to support users with existing pools that may now be 	 * invalid.  So we only check for this expanded set of names during a 	 * create (or import), and only in userland. 	 */
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
operator|!
name|isopen
operator|&&
operator|(
name|strncmp
argument_list|(
name|pool
argument_list|,
literal|"mirror"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|pool
argument_list|,
literal|"raidz"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|pool
argument_list|,
literal|"spare"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"name is reserved"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|hdl
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|why
condition|)
block|{
case|case
name|NAME_ERR_TOOLONG
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"name is too long"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_INVALCHAR
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid character "
literal|"'%c' in pool name"
argument_list|)
argument_list|,
name|what
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_NOLETTER
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"name must begin with a letter"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_RESERVED
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"name is reserved"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_DISKLIKE
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool name is reserved"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_LEADING_SLASH
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"leading slash in name"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_EMPTY_COMPONENT
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"empty component in name"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_TRAILING_SLASH
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"trailing slash in name"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_MULTIPLE_AT
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"multiple '@' delimiters in name"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zpool_get_all_props
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcmd_alloc_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
while|while
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_POOL_GET_PROPS
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
if|if
condition|(
name|zcmd_expand_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|zcmd_read_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
operator|&
name|zhp
operator|->
name|zpool_props
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Open a handle to the given pool, even if the pool is currently in the FAULTED  * state.  */
end_comment

begin_function
name|zpool_handle_t
modifier|*
name|zpool_open_canfail
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|pool
parameter_list|)
block|{
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|boolean_t
name|missing
decl_stmt|;
comment|/* 	 * Make sure the pool name is valid. 	 */
if|if
condition|(
operator|!
name|zpool_name_valid
argument_list|(
name|hdl
argument_list|,
name|B_TRUE
argument_list|,
name|pool
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot open '%s'"
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|zpool_handle_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|zhp
operator|->
name|zpool_hdl
operator|=
name|hdl
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zhp
operator|->
name|zpool_name
argument_list|,
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|zhp
operator|->
name|zpool_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zpool_refresh_stats
argument_list|(
name|zhp
argument_list|,
operator|&
name|missing
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|missing
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"no such pool"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot open '%s'"
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|zhp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Like the above, but silent on error.  Used when iterating over pools (because  * the configuration cache may be out of date).  */
end_comment

begin_function
name|int
name|zpool_open_silent
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|zpool_handle_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|boolean_t
name|missing
decl_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|zpool_handle_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|zhp
operator|->
name|zpool_hdl
operator|=
name|hdl
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zhp
operator|->
name|zpool_name
argument_list|,
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|zhp
operator|->
name|zpool_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zpool_refresh_stats
argument_list|(
name|zhp
argument_list|,
operator|&
name|missing
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|missing
condition|)
block|{
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
operator|*
name|ret
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|ret
operator|=
name|zhp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Similar to zpool_open_canfail(), but refuses to open pools in the faulted  * state.  */
end_comment

begin_function
name|zpool_handle_t
modifier|*
name|zpool_open
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|pool
parameter_list|)
block|{
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open_canfail
argument_list|(
name|hdl
argument_list|,
name|pool
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|zhp
operator|->
name|zpool_state
operator|==
name|POOL_STATE_UNAVAIL
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_POOLUNAVAIL
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot open '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
expr_stmt|;
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|zhp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close the handle.  Simply frees the memory associated with the handle.  */
end_comment

begin_function
name|void
name|zpool_close
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
if|if
condition|(
name|zhp
operator|->
name|zpool_config
condition|)
name|nvlist_free
argument_list|(
name|zhp
operator|->
name|zpool_config
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zpool_old_config
condition|)
name|nvlist_free
argument_list|(
name|zhp
operator|->
name|zpool_old_config
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zpool_props
condition|)
name|nvlist_free
argument_list|(
name|zhp
operator|->
name|zpool_props
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the name of the pool.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|zpool_get_name
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
return|return
operator|(
name|zhp
operator|->
name|zpool_name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the GUID of the pool.  */
end_comment

begin_function
name|uint64_t
name|zpool_get_guid
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|uint64_t
name|guid
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|zhp
operator|->
name|zpool_config
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|guid
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the version of the pool.  */
end_comment

begin_function
name|uint64_t
name|zpool_get_version
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|uint64_t
name|version
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|zhp
operator|->
name|zpool_config
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|,
operator|&
name|version
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|version
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the amount of space currently consumed by the pool.  */
end_comment

begin_function
name|uint64_t
name|zpool_get_space_used
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|vdev_stat_t
modifier|*
name|vs
decl_stmt|;
name|uint_t
name|vsc
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|zhp
operator|->
name|zpool_config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|vs
argument_list|,
operator|&
name|vsc
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|vs
operator|->
name|vs_alloc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the total space in the pool.  */
end_comment

begin_function
name|uint64_t
name|zpool_get_space_total
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|vdev_stat_t
modifier|*
name|vs
decl_stmt|;
name|uint_t
name|vsc
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|zhp
operator|->
name|zpool_config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|vs
argument_list|,
operator|&
name|vsc
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|vs
operator|->
name|vs_space
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the alternate root for this pool, if any.  */
end_comment

begin_function
name|int
name|zpool_get_root
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_OBJSET_STATS
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
operator|||
name|zc
operator|.
name|zc_value
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the state of the pool (ACTIVE or UNAVAILABLE)  */
end_comment

begin_function
name|int
name|zpool_get_state
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
return|return
operator|(
name|zhp
operator|->
name|zpool_state
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create the named pool, using the provided vdev list.  It is assumed  * that the consumer has already validated the contents of the nvlist, so we  * don't have to worry about error semantics.  */
end_comment

begin_function
name|int
name|zpool_create
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|nvlist_t
modifier|*
name|nvroot
parameter_list|,
specifier|const
name|char
modifier|*
name|altroot
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot create '%s'"
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zpool_name_valid
argument_list|(
name|hdl
argument_list|,
name|B_FALSE
argument_list|,
name|pool
argument_list|)
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|msg
argument_list|)
operator|)
return|;
if|if
condition|(
name|altroot
operator|!=
name|NULL
operator|&&
name|altroot
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
return|return
operator|(
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPATH
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"bad alternate root '%s'"
argument_list|)
argument_list|,
name|altroot
argument_list|)
operator|)
return|;
if|if
condition|(
name|zcmd_write_src_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|nvroot
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|altroot
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|altroot
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_POOL_CREATE
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EBUSY
case|:
comment|/* 			 * This can happen if the user has specified the same 			 * device multiple times.  We can't reliably detect this 			 * until we try to add it and see we already have a 			 * label. 			 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"one or more vdevs refer to the same device"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|msg
argument_list|)
operator|)
return|;
case|case
name|EOVERFLOW
case|:
comment|/* 			 * This occurs when one of the devices is below 			 * SPA_MINDEVSIZE.  Unfortunately, we can't detect which 			 * device was the problem device since there's no 			 * reliable way to determine device size from userland. 			 */
block|{
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|zfs_nicenum
argument_list|(
name|SPA_MINDEVSIZE
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"one or more devices is less than the "
literal|"minimum size (%s)"
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|msg
argument_list|)
operator|)
return|;
case|case
name|ENOSPC
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"one or more devices is out of space"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|msg
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
block|}
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
comment|/* 	 * If this is an alternate root pool, then we automatically set the 	 * mountpoint of the root dataset to be '/'. 	 */
if|if
condition|(
name|altroot
operator|!=
name|NULL
condition|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|verify
argument_list|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|pool
argument_list|,
name|ZFS_TYPE_ANY
argument_list|)
operator|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|zfs_prop_set
argument_list|(
name|zhp
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_MOUNTPOINT
argument_list|)
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy the given pool.  It is up to the caller to ensure that there are no  * datasets left in the pool.  */
end_comment

begin_function
name|int
name|zpool_destroy
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zfp
init|=
name|NULL
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zpool_state
operator|==
name|POOL_STATE_ACTIVE
operator|&&
operator|(
name|zfp
operator|=
name|zfs_open
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|zpool_remove_zvol_links
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_POOL_DESTROY
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot destroy '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|EROFS
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"one or more devices is read only"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zfp
condition|)
name|zfs_close
argument_list|(
name|zfp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zfp
condition|)
block|{
name|remove_mountpoint
argument_list|(
name|zfp
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zfp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add the given vdevs to the pool.  The caller must have already performed the  * necessary verification to ensure that the vdev specification is well-formed.  */
end_comment

begin_function
name|int
name|zpool_add
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
name|nvroot
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|spares
decl_stmt|;
name|uint_t
name|nspares
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot add to '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|zpool_get_version
argument_list|(
name|zhp
argument_list|)
operator|<
name|ZFS_VERSION_SPARES
operator|&&
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool must be "
literal|"upgraded to add hot spares"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|zcmd_write_src_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|nvroot
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_VDEV_ADD
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EBUSY
case|:
comment|/* 			 * This can happen if the user has specified the same 			 * device multiple times.  We can't reliably detect this 			 * until we try to add it and see we already have a 			 * label. 			 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"one or more vdevs refer to the same device"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOVERFLOW
case|:
comment|/* 			 * This occurrs when one of the devices is below 			 * SPA_MINDEVSIZE.  Unfortunately, we can't detect which 			 * device was the problem device since there's no 			 * reliable way to determine device size from userland. 			 */
block|{
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|zfs_nicenum
argument_list|(
name|SPA_MINDEVSIZE
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"device is less than the minimum "
literal|"size (%s)"
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENOTSUP
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool must be upgraded to add raidz2 vdevs"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|EDOM
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"root pool can not have concatenated devices"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_POOL_NOTSUP
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
literal|0
expr_stmt|;
block|}
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Exports the pool from the system.  The caller must ensure that there are no  * mounted datasets in the pool.  */
end_comment

begin_function
name|int
name|zpool_export
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|zpool_remove_zvol_links
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_POOL_EXPORT
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|zpool_standard_error_fmt
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|errno
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot export '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Import the given pool using the known configuration.  The configuration  * should have come from zpool_find_import().  The 'newname' and 'altroot'  * parameters control whether the pool is imported with a different name or with  * an alternate root, respectively.  */
end_comment

begin_function
name|int
name|zpool_import
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|,
specifier|const
name|char
modifier|*
name|newname
parameter_list|,
specifier|const
name|char
modifier|*
name|altroot
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
modifier|*
name|thename
decl_stmt|;
name|char
modifier|*
name|origname
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
operator|&
name|origname
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|newname
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|zpool_name_valid
argument_list|(
name|hdl
argument_list|,
name|B_FALSE
argument_list|,
name|newname
argument_list|)
condition|)
return|return
operator|(
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot import '%s'"
argument_list|)
argument_list|,
name|newname
argument_list|)
operator|)
return|;
name|thename
operator|=
operator|(
name|char
operator|*
operator|)
name|newname
expr_stmt|;
block|}
else|else
block|{
name|thename
operator|=
name|origname
expr_stmt|;
block|}
if|if
condition|(
name|altroot
operator|!=
name|NULL
operator|&&
name|altroot
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
return|return
operator|(
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPATH
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"bad alternate root '%s'"
argument_list|)
argument_list|,
name|altroot
argument_list|)
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|thename
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|altroot
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|altroot
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|zc
operator|.
name|zc_value
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
operator|&
name|zc
operator|.
name|zc_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcmd_write_src_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|config
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_POOL_IMPORT
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
name|desc
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
name|newname
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot import '%s'"
argument_list|)
argument_list|,
name|thename
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot import '%s' as '%s'"
argument_list|)
argument_list|,
name|origname
argument_list|,
name|thename
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOTSUP
case|:
comment|/* 			 * Unsupported version. 			 */
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|EINVAL
case|:
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALCONFIG
argument_list|,
name|desc
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|desc
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
comment|/* 		 * This should never fail, but play it safe anyway. 		 */
if|if
condition|(
name|zpool_open_silent
argument_list|(
name|hdl
argument_list|,
name|thename
argument_list|,
operator|&
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zhp
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|zpool_create_zvol_links
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
block|}
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Scrub the pool.  */
end_comment

begin_function
name|int
name|zpool_scrub
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|pool_scrub_type_t
name|type
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_cookie
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_POOL_SCRUB
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot scrub %s"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|EBUSY
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_RESILVERING
argument_list|,
name|msg
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 'avail_spare' is set to TRUE if the provided guid refers to an AVAIL  * spare; but FALSE if its an INUSE spare.  */
end_comment

begin_function
specifier|static
name|nvlist_t
modifier|*
name|vdev_to_nvlist_iter
parameter_list|(
name|nvlist_t
modifier|*
name|nv
parameter_list|,
specifier|const
name|char
modifier|*
name|search
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|boolean_t
modifier|*
name|avail_spare
parameter_list|)
block|{
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint64_t
name|theguid
decl_stmt|,
name|present
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|uint64_t
name|wholedisk
init|=
literal|0
decl_stmt|;
name|nvlist_t
modifier|*
name|ret
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|theguid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|search
operator|==
name|NULL
operator|&&
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_NOT_PRESENT
argument_list|,
operator|&
name|present
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If the device has never been present since import, the only 		 * reliable way to match the vdev is by GUID. 		 */
if|if
condition|(
name|theguid
operator|==
name|guid
condition|)
return|return
operator|(
name|nv
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|search
operator|!=
name|NULL
operator|&&
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
operator|&
name|path
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_WHOLE_DISK
argument_list|,
operator|&
name|wholedisk
argument_list|)
expr_stmt|;
if|if
condition|(
name|wholedisk
condition|)
block|{
comment|/* 			 * For whole disks, the internal path has 's0', but the 			 * path passed in by the user doesn't. 			 */
if|if
condition|(
name|strlen
argument_list|(
name|search
argument_list|)
operator|==
name|strlen
argument_list|(
name|path
argument_list|)
operator|-
literal|2
operator|&&
name|strncmp
argument_list|(
name|search
argument_list|,
name|path
argument_list|,
name|strlen
argument_list|(
name|search
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|nv
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|search
argument_list|,
name|path
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|nv
operator|)
return|;
block|}
block|}
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|(
name|ret
operator|=
name|vdev_to_nvlist_iter
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|search
argument_list|,
name|guid
argument_list|,
name|avail_spare
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|vdev_to_nvlist_iter
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|search
argument_list|,
name|guid
argument_list|,
name|avail_spare
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|avail_spare
operator|=
name|B_TRUE
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|nvlist_t
modifier|*
name|zpool_find_vdev
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|boolean_t
modifier|*
name|avail_spare
parameter_list|)
block|{
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|search
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|;
name|guid
operator|=
name|strtoull
argument_list|(
name|path
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|guid
operator|!=
literal|0
operator|&&
operator|*
name|end
operator|==
literal|'\0'
condition|)
block|{
name|search
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|_PATH_DEV
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|search
operator|=
name|buf
expr_stmt|;
block|}
else|else
block|{
name|search
operator|=
name|path
expr_stmt|;
block|}
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|zhp
operator|->
name|zpool_config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|*
name|avail_spare
operator|=
name|B_FALSE
expr_stmt|;
return|return
operator|(
name|vdev_to_nvlist_iter
argument_list|(
name|nvroot
argument_list|,
name|search
argument_list|,
name|guid
argument_list|,
name|avail_spare
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns TRUE if the given guid corresponds to a spare (INUSE or not).  */
end_comment

begin_function
specifier|static
name|boolean_t
name|is_spare
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|uint64_t
name|guid
parameter_list|)
block|{
name|uint64_t
name|spare_guid
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|spares
decl_stmt|;
name|uint_t
name|nspares
decl_stmt|;
name|int
name|i
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|zhp
operator|->
name|zpool_config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nspares
condition|;
name|i
operator|++
control|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|spares
index|[
name|i
index|]
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|spare_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|guid
operator|==
name|spare_guid
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Bring the specified vdev online  */
end_comment

begin_function
name|int
name|zpool_vdev_online
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|nvlist_t
modifier|*
name|tgt
decl_stmt|;
name|boolean_t
name|avail_spare
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot online %s"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tgt
operator|=
name|zpool_find_vdev
argument_list|(
name|zhp
argument_list|,
name|path
argument_list|,
operator|&
name|avail_spare
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NODEVICE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|tgt
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|zc
operator|.
name|zc_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|avail_spare
operator|||
name|is_spare
argument_list|(
name|zhp
argument_list|,
name|zc
operator|.
name|zc_guid
argument_list|)
operator|==
name|B_TRUE
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ISSPARE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
if|if
condition|(
name|ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_VDEV_ONLINE
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Take the specified vdev offline  */
end_comment

begin_function
name|int
name|zpool_vdev_offline
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|istmp
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|nvlist_t
modifier|*
name|tgt
decl_stmt|;
name|boolean_t
name|avail_spare
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot offline %s"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tgt
operator|=
name|zpool_find_vdev
argument_list|(
name|zhp
argument_list|,
name|path
argument_list|,
operator|&
name|avail_spare
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NODEVICE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|tgt
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|zc
operator|.
name|zc_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|avail_spare
operator|||
name|is_spare
argument_list|(
name|zhp
argument_list|,
name|zc
operator|.
name|zc_guid
argument_list|)
operator|==
name|B_TRUE
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ISSPARE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
name|zc
operator|.
name|zc_cookie
operator|=
name|istmp
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_VDEV_OFFLINE
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EBUSY
case|:
comment|/* 		 * There are no other replicas of this device. 		 */
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOREPLICAS
argument_list|,
name|msg
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Returns TRUE if the given nvlist is a vdev that was originally swapped in as  * a hot spare.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|is_replacing_spare
parameter_list|(
name|nvlist_t
modifier|*
name|search
parameter_list|,
name|nvlist_t
modifier|*
name|tgt
parameter_list|,
name|int
name|which
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|search
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|search
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
operator|&
name|type
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_SPARE
argument_list|)
operator|==
literal|0
operator|&&
name|children
operator|==
literal|2
operator|&&
name|child
index|[
name|which
index|]
operator|==
name|tgt
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|is_replacing_spare
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|tgt
argument_list|,
name|which
argument_list|)
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach new_disk (fully described by nvroot) to old_disk.  * If 'replacing' is specified, tne new disk will replace the old one.  */
end_comment

begin_function
name|int
name|zpool_vdev_attach
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|old_disk
parameter_list|,
specifier|const
name|char
modifier|*
name|new_disk
parameter_list|,
name|nvlist_t
modifier|*
name|nvroot
parameter_list|,
name|int
name|replacing
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|nvlist_t
modifier|*
name|tgt
decl_stmt|;
name|boolean_t
name|avail_spare
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|children
decl_stmt|;
name|nvlist_t
modifier|*
name|config_root
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
if|if
condition|(
name|replacing
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot replace %s with %s"
argument_list|)
argument_list|,
name|old_disk
argument_list|,
name|new_disk
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot attach %s to %s"
argument_list|)
argument_list|,
name|new_disk
argument_list|,
name|old_disk
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tgt
operator|=
name|zpool_find_vdev
argument_list|(
name|zhp
argument_list|,
name|old_disk
argument_list|,
operator|&
name|avail_spare
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NODEVICE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
if|if
condition|(
name|avail_spare
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ISSPARE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|tgt
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|zc
operator|.
name|zc_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_cookie
operator|=
name|replacing
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|!=
literal|0
operator|||
name|children
operator|!=
literal|1
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"new device must be a single disk"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALCONFIG
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|config_root
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If the target is a hot spare that has been swapped in, we can only 	 * replace it with another hot spare. 	 */
if|if
condition|(
name|replacing
operator|&&
name|nvlist_lookup_uint64
argument_list|(
name|tgt
argument_list|,
name|ZPOOL_CONFIG_IS_SPARE
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
operator|&&
name|nvlist_lookup_string
argument_list|(
name|child
index|[
literal|0
index|]
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
operator|&
name|path
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|zpool_find_vdev
argument_list|(
name|zhp
argument_list|,
name|path
argument_list|,
operator|&
name|avail_spare
argument_list|)
operator|==
name|NULL
operator|||
operator|!
name|avail_spare
operator|)
operator|&&
name|is_replacing_spare
argument_list|(
name|config_root
argument_list|,
name|tgt
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"can only be replaced by another hot spare"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTARGET
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * If we are attempting to replace a spare, it canot be applied to an 	 * already spared device. 	 */
if|if
condition|(
name|replacing
operator|&&
name|nvlist_lookup_string
argument_list|(
name|child
index|[
literal|0
index|]
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
operator|&
name|path
argument_list|)
operator|==
literal|0
operator|&&
name|zpool_find_vdev
argument_list|(
name|zhp
argument_list|,
name|path
argument_list|,
operator|&
name|avail_spare
argument_list|)
operator|!=
name|NULL
operator|&&
name|avail_spare
operator|&&
name|is_replacing_spare
argument_list|(
name|config_root
argument_list|,
name|tgt
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"device has already been replaced with a spare"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTARGET
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|zcmd_write_src_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|nvroot
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ret
operator|=
name|ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_VDEV_ATTACH
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOTSUP
case|:
comment|/* 		 * Can't attach to or replace this type of vdev. 		 */
if|if
condition|(
name|replacing
condition|)
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot replace a replacing device"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"can only attach to mirrors and top-level "
literal|"disks"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTARGET
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|EINVAL
case|:
comment|/* 		 * The new device must be a single disk. 		 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"new device must be a single disk"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALCONFIG
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|EBUSY
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"%s is busy"
argument_list|)
argument_list|,
name|new_disk
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOVERFLOW
case|:
comment|/* 		 * The new device is too small. 		 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"device is too small"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|EDOM
case|:
comment|/* 		 * The new device has a different alignment requirement. 		 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"devices have different sector alignment"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADDEV
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENAMETOOLONG
case|:
comment|/* 		 * The resulting top-level vdev spec won't fit in the label. 		 */
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_DEVOVERFLOW
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detach the specified device.  */
end_comment

begin_function
name|int
name|zpool_vdev_detach
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|nvlist_t
modifier|*
name|tgt
decl_stmt|;
name|boolean_t
name|avail_spare
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot detach %s"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tgt
operator|=
name|zpool_find_vdev
argument_list|(
name|zhp
argument_list|,
name|path
argument_list|,
operator|&
name|avail_spare
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NODEVICE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
if|if
condition|(
name|avail_spare
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ISSPARE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|tgt
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|zc
operator|.
name|zc_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_VDEV_DETACH
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOTSUP
case|:
comment|/* 		 * Can't detach from this type of vdev. 		 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"only "
literal|"applicable to mirror and replacing vdevs"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|EZFS_BADTARGET
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|EBUSY
case|:
comment|/* 		 * There are no other replicas of this device. 		 */
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOREPLICAS
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove the given device.  Currently, this is supported only for hot spares.  */
end_comment

begin_function
name|int
name|zpool_vdev_remove
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|nvlist_t
modifier|*
name|tgt
decl_stmt|;
name|boolean_t
name|avail_spare
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot remove %s"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tgt
operator|=
name|zpool_find_vdev
argument_list|(
name|zhp
argument_list|,
name|path
argument_list|,
operator|&
name|avail_spare
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NODEVICE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|avail_spare
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"only inactive hot spares can be removed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NODEVICE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|tgt
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|zc
operator|.
name|zc_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_VDEV_REMOVE
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clear the errors for the pool, or the particular device if specified.  */
end_comment

begin_function
name|int
name|zpool_clear
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|nvlist_t
modifier|*
name|tgt
decl_stmt|;
name|boolean_t
name|avail_spare
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
if|if
condition|(
name|path
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot clear errors for %s"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot clear errors for %s"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
condition|)
block|{
if|if
condition|(
operator|(
name|tgt
operator|=
name|zpool_find_vdev
argument_list|(
name|zhp
argument_list|,
name|path
argument_list|,
operator|&
name|avail_spare
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NODEVICE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
if|if
condition|(
name|avail_spare
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ISSPARE
argument_list|,
name|msg
argument_list|)
operator|)
return|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|tgt
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|zc
operator|.
name|zc_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_CLEAR
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|zpool_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate over all zvols in a given pool by walking the /dev/zvol/dsk/<pool>  * hierarchy.  */
end_comment

begin_function
name|int
name|zpool_iter_zvol
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|int
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
name|char
argument_list|(
operator|*
name|paths
argument_list|)
index|[
name|MAXPATHLEN
index|]
expr_stmt|;
name|char
name|path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|size_t
name|size
init|=
literal|4
decl_stmt|;
name|int
name|curr
decl_stmt|,
name|fd
decl_stmt|,
name|base
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
operator|(
name|base
operator|=
name|open
argument_list|(
name|ZVOL_FULL_DEV_DIR
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|errno
operator|==
name|ENOENT
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
return|;
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|ZVOL_FULL_DEV_DIR
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|err
init|=
name|errno
decl_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|==
name|ENOENT
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Oddly this wasn't a directory -- ignore that failure since we 	 * know there are no links lower in the (non-existant) hierarchy. 	 */
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|paths
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|paths
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|paths
index|[
literal|0
index|]
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|paths
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|curr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|curr
operator|>=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|ZVOL_FULL_DEV_DIR
argument_list|,
name|paths
index|[
name|curr
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|path
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|err
goto|;
block|}
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
continue|continue;
if|if
condition|(
name|curr
operator|+
literal|1
operator|==
name|size
condition|)
block|{
name|paths
operator|=
name|zfs_realloc
argument_list|(
name|hdl
argument_list|,
name|paths
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|paths
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|size
operator|*
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|paths
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|paths
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|size
operator|*=
literal|2
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|paths
index|[
name|curr
operator|+
literal|1
index|]
argument_list|,
name|paths
index|[
name|curr
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|paths
index|[
name|curr
operator|+
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|paths
index|[
name|curr
index|]
argument_list|,
literal|"/"
argument_list|,
sizeof|sizeof
argument_list|(
name|paths
index|[
name|curr
index|]
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|paths
index|[
name|curr
index|]
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
sizeof|sizeof
argument_list|(
name|paths
index|[
name|curr
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|curr
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|cb
argument_list|(
name|paths
index|[
name|curr
index|]
argument_list|,
name|data
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
name|curr
operator|--
expr_stmt|;
block|}
name|free
argument_list|(
name|paths
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
name|err
label|:
name|free
argument_list|(
name|paths
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|zvol_cb
block|{
name|zpool_handle_t
modifier|*
name|zcb_pool
decl_stmt|;
name|boolean_t
name|zcb_create
decl_stmt|;
block|}
name|zvol_cb_t
typedef|;
end_typedef

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|do_zvol_create
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|ZFS_IS_VOLUME
argument_list|(
name|zhp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|zvol_create_link
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
name|ret
operator|=
name|zfs_iter_children
argument_list|(
name|zhp
argument_list|,
name|do_zvol_create
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate over all zvols in the pool and make any necessary minor nodes.  */
end_comment

begin_function
name|int
name|zpool_create_zvol_links
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zfp
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* 	 * If the pool is unavailable, just return success. 	 */
if|if
condition|(
operator|(
name|zfp
operator|=
name|make_dataset_handle
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ret
operator|=
name|zfs_iter_children
argument_list|(
name|zfp
argument_list|,
name|do_zvol_create
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zfp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_zvol_remove
parameter_list|(
specifier|const
name|char
modifier|*
name|dataset
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|zpool_handle_t
modifier|*
name|zhp
init|=
name|data
decl_stmt|;
return|return
operator|(
name|zvol_remove_link
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|dataset
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate over all zvols in the pool and remove any minor nodes.  We iterate  * by examining the /dev links so that a corrupted pool doesn't impede this  * operation.  */
end_comment

begin_function
name|int
name|zpool_remove_zvol_links
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
return|return
operator|(
name|zpool_iter_zvol
argument_list|(
name|zhp
argument_list|,
name|do_zvol_remove
argument_list|,
name|zhp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert from a devid string to a path.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|devid_to_path
parameter_list|(
name|char
modifier|*
name|devid_str
parameter_list|)
block|{
name|ddi_devid_t
name|devid
decl_stmt|;
name|char
modifier|*
name|minor
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|devid_nmlist_t
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|devid_str_decode
argument_list|(
name|devid_str
argument_list|,
operator|&
name|devid
argument_list|,
operator|&
name|minor
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ret
operator|=
name|devid_deviceid_to_nmlist
argument_list|(
literal|"/dev"
argument_list|,
name|devid
argument_list|,
name|minor
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|devid_str_free
argument_list|(
name|minor
argument_list|)
expr_stmt|;
name|devid_free
argument_list|(
name|devid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|path
operator|=
name|strdup
argument_list|(
name|list
index|[
literal|0
index|]
operator|.
name|devname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|devid_free_nmlist
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
operator|(
name|path
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert from a path to a devid string.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|path_to_devid
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|ddi_devid_t
name|devid
decl_stmt|;
name|char
modifier|*
name|minor
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|minor
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|devid_get
argument_list|(
name|fd
argument_list|,
operator|&
name|devid
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|devid_get_minor_name
argument_list|(
name|fd
argument_list|,
operator|&
name|minor
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
name|devid_str_encode
argument_list|(
name|devid
argument_list|,
name|minor
argument_list|)
expr_stmt|;
if|if
condition|(
name|minor
operator|!=
name|NULL
condition|)
name|devid_str_free
argument_list|(
name|minor
argument_list|)
expr_stmt|;
name|devid_free
argument_list|(
name|devid
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Issue the necessary ioctl() to update the stored path value for the vdev.  We  * ignore any failure here, since a common case is for an unprivileged user to  * type 'zpool status', and we'll display the correct information anyway.  */
end_comment

begin_function
specifier|static
name|void
name|set_path
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|zc
operator|.
name|zc_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_VDEV_SETPATH
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a vdev, return the name to display in iostat.  If the vdev has a path,  * we use that, stripping off any leading "/dev/dsk/"; if not, we use the type.  * We also check if this is a whole disk, in which case we strip off the  * trailing 's0' slice name.  *  * This routine is also responsible for identifying when disks have been  * reconfigured in a new location.  The kernel will have opened the device by  * devid, but the path will still refer to the old location.  To catch this, we  * first do a path -> devid translation (which is fast for the common case).  If  * the devid matches, we're done.  If not, we do a reverse devid -> path  * translation and issue the appropriate ioctl() to update the path of the vdev.  * If 'zhp' is NULL, then this is an exported pool, and we don't need to do any  * of these checks.  */
end_comment

begin_function
name|char
modifier|*
name|zpool_vdev_name
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|)
block|{
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|devid
decl_stmt|;
name|uint64_t
name|value
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_NOT_PRESENT
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%llu"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|value
argument_list|)
expr_stmt|;
name|path
operator|=
name|buf
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
operator|&
name|path
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|zhp
operator|!=
name|NULL
operator|&&
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_DEVID
argument_list|,
operator|&
name|devid
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Determine if the current path is correct. 			 */
name|char
modifier|*
name|newdevid
init|=
name|path_to_devid
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|newdevid
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|devid
argument_list|,
name|newdevid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|newpath
decl_stmt|;
if|if
condition|(
operator|(
name|newpath
operator|=
name|devid_to_path
argument_list|(
name|devid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 					 * Update the path appropriately. 					 */
name|set_path
argument_list|(
name|zhp
argument_list|,
name|nv
argument_list|,
name|newpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
name|newpath
argument_list|)
operator|==
literal|0
condition|)
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
operator|&
name|path
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newpath
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newdevid
condition|)
name|devid_str_free
argument_list|(
name|newdevid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|path
argument_list|,
name|_PATH_DEV
argument_list|,
sizeof|sizeof
argument_list|(
name|_PATH_DEV
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|path
operator|+=
sizeof|sizeof
argument_list|(
name|_PATH_DEV
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_WHOLE_DISK
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
operator|&&
name|value
condition|)
block|{
name|char
modifier|*
name|tmp
init|=
name|zfs_strdup
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|tmp
index|[
name|strlen
argument_list|(
name|path
argument_list|)
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|tmp
operator|)
return|;
block|}
block|}
else|else
block|{
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
operator|&
name|path
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * If it's a raidz device, we need to stick in the parity level. 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|path
argument_list|,
name|VDEV_TYPE_RAIDZ
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_NPARITY
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s%llu"
argument_list|,
name|path
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|value
argument_list|)
expr_stmt|;
name|path
operator|=
name|buf
expr_stmt|;
block|}
block|}
return|return
operator|(
name|zfs_strdup
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zbookmark_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
return|return
operator|(
name|memcmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|zbookmark_t
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve the persistent error log, uniquify the members, and return to the  * caller.  */
end_comment

begin_function
name|int
name|zpool_get_errlog
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nverrlistp
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|uint64_t
name|count
decl_stmt|;
name|zbookmark_t
modifier|*
name|zb
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Retrieve the raw error list from the kernel.  If the number of errors 	 * has increased, allocate more space and continue until we get the 	 * entire list. 	 */
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|zhp
operator|->
name|zpool_config
argument_list|,
name|ZPOOL_CONFIG_ERRCOUNT
argument_list|,
operator|&
name|count
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zc
operator|.
name|zc_nvlist_dst
operator|=
operator|(
name|uintptr_t
operator|)
name|zfs_alloc
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|zbookmark_t
argument_list|)
argument_list|)
operator|)
operator|==
operator|(
name|uintptr_t
operator|)
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|zc
operator|.
name|zc_nvlist_dst_size
operator|=
name|count
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_ERROR_LOG
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|.
name|zc_nvlist_dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|count
operator|=
name|zc
operator|.
name|zc_nvlist_dst_size
expr_stmt|;
if|if
condition|(
operator|(
name|zc
operator|.
name|zc_nvlist_dst
operator|=
operator|(
name|uintptr_t
operator|)
name|zfs_alloc
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|zbookmark_t
argument_list|)
argument_list|)
operator|)
operator|==
operator|(
name|uintptr_t
operator|)
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
comment|/* 	 * Sort the resulting bookmarks.  This is a little confusing due to the 	 * implementation of ZFS_IOC_ERROR_LOG.  The bookmarks are copied last 	 * to first, and 'zc_nvlist_dst_size' indicates the number of boomarks 	 * _not_ copied as part of the process.  So we point the start of our 	 * array appropriate and decrement the total number of elements. 	 */
name|zb
operator|=
operator|(
operator|(
name|zbookmark_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|.
name|zc_nvlist_dst
operator|)
operator|+
name|zc
operator|.
name|zc_nvlist_dst_size
expr_stmt|;
name|count
operator|-=
name|zc
operator|.
name|zc_nvlist_dst_size
expr_stmt|;
name|qsort
argument_list|(
name|zb
argument_list|,
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|zbookmark_t
argument_list|)
argument_list|,
name|zbookmark_compare
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_alloc
argument_list|(
name|nverrlistp
argument_list|,
literal|0
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in the nverrlistp with nvlist's of dataset and object numbers. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|nvlist_t
modifier|*
name|nv
decl_stmt|;
comment|/* ignoring zb_blkid and zb_level for now */
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|zb
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|zb_objset
operator|==
name|zb
index|[
name|i
index|]
operator|.
name|zb_objset
operator|&&
name|zb
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|zb_object
operator|==
name|zb
index|[
name|i
index|]
operator|.
name|zb_object
condition|)
continue|continue;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|nv
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|nomem
goto|;
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_ERR_DATASET
argument_list|,
name|zb
index|[
name|i
index|]
operator|.
name|zb_objset
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
goto|goto
name|nomem
goto|;
block|}
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_ERR_OBJECT
argument_list|,
name|zb
index|[
name|i
index|]
operator|.
name|zb_object
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
goto|goto
name|nomem
goto|;
block|}
if|if
condition|(
name|nvlist_add_nvlist
argument_list|(
operator|*
name|nverrlistp
argument_list|,
literal|"ejk"
argument_list|,
name|nv
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
goto|goto
name|nomem
goto|;
block|}
name|nvlist_free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|.
name|zc_nvlist_dst
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|nomem
label|:
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|.
name|zc_nvlist_dst
argument_list|)
expr_stmt|;
return|return
operator|(
name|no_memory
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Upgrade a ZFS pool to the latest on-disk version.  */
end_comment

begin_function
name|int
name|zpool_upgrade
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_POOL_UPGRADE
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|zpool_standard_error_fmt
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot upgrade '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Log command history.  *  * 'pool' is B_TRUE if we are logging a command for 'zpool'; B_FALSE  * otherwise ('zfs').  'pool_create' is B_TRUE if we are logging the creation  * of the pool; B_FALSE otherwise.  'path' is the pathanme containing the  * poolname.  'argc' and 'argv' are used to construct the command string.  */
end_comment

begin_function
name|void
name|zpool_log_history
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|boolean_t
name|pool
parameter_list|,
name|boolean_t
name|pool_create
parameter_list|)
block|{
name|char
name|cmd_buf
index|[
name|HIS_MAX_RECORD_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|dspath
decl_stmt|;
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* construct the command string */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cmd_buf
argument_list|,
name|pool
condition|?
literal|"zpool"
else|:
literal|"zfs"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|cmd_buf
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|>
name|HIS_MAX_RECORD_LEN
condition|)
break|break;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|cmd_buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|cmd_buf
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* figure out the poolname */
name|dspath
operator|=
name|strpbrk
argument_list|(
name|path
argument_list|,
literal|"/@"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dspath
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|path
argument_list|,
name|dspath
operator|-
name|path
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_name
index|[
name|dspath
operator|-
name|path
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|zc
operator|.
name|zc_history
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|cmd_buf
expr_stmt|;
name|zc
operator|.
name|zc_history_len
operator|=
name|strlen
argument_list|(
name|cmd_buf
argument_list|)
expr_stmt|;
comment|/* overloading zc_history_offset */
name|zc
operator|.
name|zc_history_offset
operator|=
name|pool_create
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_POOL_LOG_HISTORY
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Perform ioctl to get some command history of a pool.  *  * 'buf' is the buffer to fill up to 'len' bytes.  'off' is the  * logical offset of the history buffer to start reading from.  *  * Upon return, 'off' is the next logical offset to read from and  * 'len' is the actual amount of bytes read into 'buf'.  */
end_comment

begin_function
specifier|static
name|int
name|get_history
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|uint64_t
modifier|*
name|off
parameter_list|,
name|uint64_t
modifier|*
name|len
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_history
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|buf
expr_stmt|;
name|zc
operator|.
name|zc_history_len
operator|=
operator|*
name|len
expr_stmt|;
name|zc
operator|.
name|zc_history_offset
operator|=
operator|*
name|off
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_POOL_GET_HISTORY
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EPERM
case|:
return|return
operator|(
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_PERM
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot show history for pool '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
operator|)
return|;
case|case
name|ENOENT
case|:
return|return
operator|(
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOHISTORY
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot get history for pool "
literal|"'%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
operator|)
return|;
case|case
name|ENOTSUP
case|:
return|return
operator|(
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot get history for pool "
literal|"'%s', pool must be upgraded"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|zpool_standard_error_fmt
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot get history for '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
operator|)
return|;
block|}
block|}
operator|*
name|len
operator|=
name|zc
operator|.
name|zc_history_len
expr_stmt|;
operator|*
name|off
operator|=
name|zc
operator|.
name|zc_history_offset
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process the buffer of nvlists, unpacking and storing each nvlist record  * into 'records'.  'leftover' is set to the number of bytes that weren't  * processed as there wasn't a complete record.  */
end_comment

begin_function
specifier|static
name|int
name|zpool_history_unpack
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|uint64_t
name|bytes_read
parameter_list|,
name|uint64_t
modifier|*
name|leftover
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
modifier|*
name|records
parameter_list|,
name|uint_t
modifier|*
name|numrecords
parameter_list|)
block|{
name|uint64_t
name|reclen
decl_stmt|;
name|nvlist_t
modifier|*
name|nv
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
name|bytes_read
operator|>
sizeof|sizeof
argument_list|(
name|reclen
argument_list|)
condition|)
block|{
comment|/* get length of packed record (stored as little endian) */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|reclen
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|reclen
argument_list|)
condition|;
name|i
operator|++
control|)
name|reclen
operator|+=
call|(
name|uint64_t
call|)
argument_list|(
operator|(
operator|(
name|uchar_t
operator|*
operator|)
name|buf
operator|)
index|[
name|i
index|]
argument_list|)
operator|<<
operator|(
literal|8
operator|*
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|<
sizeof|sizeof
argument_list|(
name|reclen
argument_list|)
operator|+
name|reclen
condition|)
break|break;
comment|/* unpack record */
if|if
condition|(
name|nvlist_unpack
argument_list|(
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|reclen
argument_list|)
argument_list|,
name|reclen
argument_list|,
operator|&
name|nv
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bytes_read
operator|-=
sizeof|sizeof
argument_list|(
name|reclen
argument_list|)
operator|+
name|reclen
expr_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|reclen
argument_list|)
operator|+
name|reclen
expr_stmt|;
comment|/* add record to nvlist array */
operator|(
operator|*
name|numrecords
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|ISP2
argument_list|(
operator|*
name|numrecords
operator|+
literal|1
argument_list|)
condition|)
block|{
operator|*
name|records
operator|=
name|realloc
argument_list|(
operator|*
name|records
argument_list|,
operator|*
name|numrecords
operator|*
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|nvlist_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|records
operator|)
index|[
operator|*
name|numrecords
operator|-
literal|1
index|]
operator|=
name|nv
expr_stmt|;
block|}
operator|*
name|leftover
operator|=
name|bytes_read
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|HIS_BUF_LEN
value|(128*1024)
end_define

begin_comment
comment|/*  * Retrieve the command history of a pool.  */
end_comment

begin_function
name|int
name|zpool_get_history
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nvhisp
parameter_list|)
block|{
name|char
name|buf
index|[
name|HIS_BUF_LEN
index|]
decl_stmt|;
name|uint64_t
name|off
init|=
literal|0
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|records
init|=
name|NULL
decl_stmt|;
name|uint_t
name|numrecords
init|=
literal|0
decl_stmt|;
name|int
name|err
decl_stmt|,
name|i
decl_stmt|;
do|do
block|{
name|uint64_t
name|bytes_read
init|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|uint64_t
name|leftover
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|get_history
argument_list|(
name|zhp
argument_list|,
name|buf
argument_list|,
operator|&
name|off
argument_list|,
operator|&
name|bytes_read
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/* if nothing else was read in, we're at EOF, just return */
if|if
condition|(
operator|!
name|bytes_read
condition|)
break|break;
if|if
condition|(
operator|(
name|err
operator|=
name|zpool_history_unpack
argument_list|(
name|buf
argument_list|,
name|bytes_read
argument_list|,
operator|&
name|leftover
argument_list|,
operator|&
name|records
argument_list|,
operator|&
name|numrecords
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|off
operator|-=
name|leftover
expr_stmt|;
comment|/* CONSTCOND */
block|}
do|while
condition|(
literal|1
condition|)
do|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|verify
argument_list|(
name|nvlist_alloc
argument_list|(
name|nvhisp
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
operator|*
name|nvhisp
argument_list|,
name|ZPOOL_HIST_RECORD
argument_list|,
name|records
argument_list|,
name|numrecords
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numrecords
condition|;
name|i
operator|++
control|)
name|nvlist_free
argument_list|(
name|records
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|records
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zpool_obj_to_path
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|uint64_t
name|dsobj
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|char
modifier|*
name|pathname
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|boolean_t
name|mounted
init|=
name|B_FALSE
decl_stmt|;
name|char
modifier|*
name|mntpnt
init|=
name|NULL
decl_stmt|;
name|char
name|dsname
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
if|if
condition|(
name|dsobj
operator|==
literal|0
condition|)
block|{
comment|/* special case for the MOS */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pathname
argument_list|,
name|len
argument_list|,
literal|"<metadata>:<0x%llx>"
argument_list|,
name|obj
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* get the dataset's name */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_obj
operator|=
name|dsobj
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_DSOBJ_TO_DSNAME
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* just write out a path of two object numbers */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pathname
argument_list|,
name|len
argument_list|,
literal|"<0x%llx>:<0x%llx>"
argument_list|,
name|dsobj
argument_list|,
name|obj
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|dsname
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|,
sizeof|sizeof
argument_list|(
name|dsname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* find out if the dataset is mounted */
name|mounted
operator|=
name|is_mounted
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|dsname
argument_list|,
operator|&
name|mntpnt
argument_list|)
expr_stmt|;
comment|/* get the corrupted object's path */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|dsname
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_obj
operator|=
name|obj
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_OBJ_TO_PATH
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mounted
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pathname
argument_list|,
name|len
argument_list|,
literal|"%s%s"
argument_list|,
name|mntpnt
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pathname
argument_list|,
name|len
argument_list|,
literal|"%s:%s"
argument_list|,
name|dsname
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pathname
argument_list|,
name|len
argument_list|,
literal|"%s:<0x%llx>"
argument_list|,
name|dsname
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|mntpnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|zpool_set_prop
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
specifier|const
name|char
modifier|*
name|propval
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|nvlist_t
modifier|*
name|nvl
init|=
name|NULL
decl_stmt|;
name|nvlist_t
modifier|*
name|realprops
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot set property for '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|zpool_get_version
argument_list|(
name|zhp
argument_list|)
operator|<
name|ZFS_VERSION_BOOTFS
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool must be "
literal|"upgraded to support pool properties"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|zhp
operator|->
name|zpool_props
operator|==
name|NULL
operator|&&
name|zpool_get_all_props
argument_list|(
name|zhp
argument_list|)
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|EZFS_POOLPROPS
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|nvl
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_add_string
argument_list|(
name|nvl
argument_list|,
name|propname
argument_list|,
name|propval
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|no_memory
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|realprops
operator|=
name|zfs_validate_properties
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|ZFS_TYPE_POOL
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
name|nvl
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|errbuf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|nvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|nvl
operator|=
name|realprops
expr_stmt|;
comment|/* 	 * Execute the corresponding ioctl() to set this property. 	 */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcmd_write_src_nvlist
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|nvl
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ret
operator|=
name|ioctl
argument_list|(
name|zhp
operator|->
name|zpool_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_POOL_SET_PROPS
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
operator|(
name|void
operator|)
name|zpool_standard_error
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zpool_get_prop
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|zpool_prop_t
name|prop
parameter_list|,
name|char
modifier|*
name|propbuf
parameter_list|,
name|size_t
name|proplen
parameter_list|,
name|zfs_source_t
modifier|*
name|srctype
parameter_list|)
block|{
name|uint64_t
name|value
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|,
modifier|*
name|strvalue
decl_stmt|;
name|nvlist_t
modifier|*
name|nvp
decl_stmt|;
name|zfs_source_t
name|src
init|=
name|ZFS_SRC_NONE
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot get property '%s'"
argument_list|)
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zpool_get_version
argument_list|(
name|zhp
argument_list|)
operator|<
name|ZFS_VERSION_BOOTFS
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool must be "
literal|"upgraded to support pool properties"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|zhp
operator|->
name|zpool_props
operator|==
name|NULL
operator|&&
name|zpool_get_all_props
argument_list|(
name|zhp
argument_list|)
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|EZFS_POOLPROPS
argument_list|,
name|msg
argument_list|)
operator|)
return|;
comment|/* 	 * the "name" property is special cased 	 */
if|if
condition|(
operator|!
name|zfs_prop_valid_for_type
argument_list|(
name|prop
argument_list|,
name|ZFS_TYPE_POOL
argument_list|)
operator|&&
name|prop
operator|!=
name|ZFS_PROP_NAME
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZFS_PROP_NAME
case|:
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
name|zhp
operator|->
name|zpool_name
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_BOOTFS
case|:
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|zhp
operator|->
name|zpool_props
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|,
operator|&
name|nvp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|strvalue
operator|=
operator|(
name|char
operator|*
operator|)
name|zfs_prop_default_string
argument_list|(
name|prop
argument_list|)
expr_stmt|;
if|if
condition|(
name|strvalue
operator|==
name|NULL
condition|)
name|strvalue
operator|=
literal|"-"
expr_stmt|;
name|src
operator|=
name|ZFS_SRC_DEFAULT
expr_stmt|;
block|}
else|else
block|{
name|VERIFY
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nvp
argument_list|,
name|ZFS_PROP_SOURCE
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|src
operator|=
name|value
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|nvp
argument_list|,
name|ZFS_PROP_VALUE
argument_list|,
operator|&
name|strvalue
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|strvalue
argument_list|)
operator|>=
name|proplen
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|propbuf
argument_list|,
name|strvalue
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|srctype
condition|)
operator|*
name|srctype
operator|=
name|src
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zpool_get_proplist
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|char
modifier|*
name|fields
parameter_list|,
name|zpool_proplist_t
modifier|*
modifier|*
name|listp
parameter_list|)
block|{
return|return
operator|(
name|zfs_get_proplist_common
argument_list|(
name|hdl
argument_list|,
name|fields
argument_list|,
name|listp
argument_list|,
name|ZFS_TYPE_POOL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zpool_expand_proplist
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|zpool_proplist_t
modifier|*
modifier|*
name|plp
parameter_list|)
block|{
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
name|zpool_proplist_t
modifier|*
name|entry
decl_stmt|;
name|char
name|buf
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
if|if
condition|(
name|zfs_expand_proplist_common
argument_list|(
name|hdl
argument_list|,
name|plp
argument_list|,
name|ZFS_TYPE_POOL
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|entry
operator|=
operator|*
name|plp
init|;
name|entry
operator|!=
name|NULL
condition|;
name|entry
operator|=
name|entry
operator|->
name|pl_next
control|)
block|{
if|if
condition|(
name|entry
operator|->
name|pl_fixed
condition|)
continue|continue;
if|if
condition|(
name|entry
operator|->
name|pl_prop
operator|!=
name|ZFS_PROP_INVAL
operator|&&
name|zpool_get_prop
argument_list|(
name|zhp
argument_list|,
name|entry
operator|->
name|pl_prop
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|>
name|entry
operator|->
name|pl_width
condition|)
name|entry
operator|->
name|pl_width
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

