begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * divsufsort.c for libdivsufsort  * Copyright (c) 2003-2008 Yuta Mori All Rights Reserved.  *  * Permission is hereby granted, free of charge, to any person  * obtaining a copy of this software and associated documentation  * files (the "Software"), to deal in the Software without  * restriction, including without limitation the rights to use,  * copy, modify, merge, publish, distribute, sublicense, and/or sell  * copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following  * conditions:  *  * The above copyright notice and this permission notice shall be  * included in all copies or substantial portions of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES  * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT  * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,  * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR  * OTHER DEALINGS IN THE SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"divsufsort_private.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_OPENMP
end_ifdef

begin_include
include|#
directive|include
file|<omp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*- Private Functions -*/
end_comment

begin_comment
comment|/* Sorts suffixes of type B*. */
end_comment

begin_function
specifier|static
name|saidx_t
name|sort_typeBstar
parameter_list|(
specifier|const
name|sauchar_t
modifier|*
name|T
parameter_list|,
name|saidx_t
modifier|*
name|SA
parameter_list|,
name|saidx_t
modifier|*
name|bucket_A
parameter_list|,
name|saidx_t
modifier|*
name|bucket_B
parameter_list|,
name|saidx_t
name|n
parameter_list|)
block|{
name|saidx_t
modifier|*
name|PAb
decl_stmt|,
modifier|*
name|ISAb
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
ifdef|#
directive|ifdef
name|_OPENMP
name|saidx_t
modifier|*
name|curbuf
decl_stmt|;
name|saidx_t
name|l
decl_stmt|;
endif|#
directive|endif
name|saidx_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|t
decl_stmt|,
name|m
decl_stmt|,
name|bufsize
decl_stmt|;
name|saint_t
name|c0
decl_stmt|,
name|c1
decl_stmt|;
ifdef|#
directive|ifdef
name|_OPENMP
name|saint_t
name|d0
decl_stmt|,
name|d1
decl_stmt|;
name|int
name|tmp
decl_stmt|;
endif|#
directive|endif
comment|/* Initialize bucket arrays. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BUCKET_A_SIZE
condition|;
operator|++
name|i
control|)
block|{
name|bucket_A
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BUCKET_B_SIZE
condition|;
operator|++
name|i
control|)
block|{
name|bucket_B
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Count the number of occurrences of the first one or two characters of each      type A, B and B* suffix. Moreover, store the beginning position of all      type B* suffixes into the array SA. */
for|for
control|(
name|i
operator|=
name|n
operator|-
literal|1
operator|,
name|m
operator|=
name|n
operator|,
name|c0
operator|=
name|T
index|[
name|n
operator|-
literal|1
index|]
init|;
literal|0
operator|<=
name|i
condition|;
control|)
block|{
comment|/* type A suffix. */
do|do
block|{
operator|++
name|BUCKET_A
argument_list|(
name|c1
operator|=
name|c0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
literal|0
operator|<=
operator|--
name|i
operator|)
operator|&&
operator|(
operator|(
name|c0
operator|=
name|T
index|[
name|i
index|]
operator|)
operator|>=
name|c1
operator|)
condition|)
do|;
if|if
condition|(
literal|0
operator|<=
name|i
condition|)
block|{
comment|/* type B* suffix. */
operator|++
name|BUCKET_BSTAR
argument_list|(
name|c0
argument_list|,
name|c1
argument_list|)
expr_stmt|;
name|SA
index|[
operator|--
name|m
index|]
operator|=
name|i
expr_stmt|;
comment|/* type B suffix. */
for|for
control|(
operator|--
name|i
operator|,
name|c1
operator|=
name|c0
init|;
operator|(
literal|0
operator|<=
name|i
operator|)
operator|&&
operator|(
operator|(
name|c0
operator|=
name|T
index|[
name|i
index|]
operator|)
operator|<=
name|c1
operator|)
condition|;
operator|--
name|i
operator|,
name|c1
operator|=
name|c0
control|)
block|{
operator|++
name|BUCKET_B
argument_list|(
name|c0
argument_list|,
name|c1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|m
operator|=
name|n
operator|-
name|m
expr_stmt|;
comment|/* note:   A type B* suffix is lexicographically smaller than a type B suffix that   begins with the same first two characters. */
comment|/* Calculate the index of start/end point of each bucket. */
for|for
control|(
name|c0
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|c0
operator|<
name|ALPHABET_SIZE
condition|;
operator|++
name|c0
control|)
block|{
name|t
operator|=
name|i
operator|+
name|BUCKET_A
argument_list|(
name|c0
argument_list|)
expr_stmt|;
name|BUCKET_A
argument_list|(
name|c0
argument_list|)
operator|=
name|i
operator|+
name|j
expr_stmt|;
comment|/* start point */
name|i
operator|=
name|t
operator|+
name|BUCKET_B
argument_list|(
name|c0
argument_list|,
name|c0
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|c0
operator|+
literal|1
init|;
name|c1
operator|<
name|ALPHABET_SIZE
condition|;
operator|++
name|c1
control|)
block|{
name|j
operator|+=
name|BUCKET_BSTAR
argument_list|(
name|c0
argument_list|,
name|c1
argument_list|)
expr_stmt|;
name|BUCKET_BSTAR
argument_list|(
name|c0
argument_list|,
name|c1
argument_list|)
operator|=
name|j
expr_stmt|;
comment|/* end point */
name|i
operator|+=
name|BUCKET_B
argument_list|(
name|c0
argument_list|,
name|c1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
literal|0
operator|<
name|m
condition|)
block|{
comment|/* Sort the type B* suffixes by their first two characters. */
name|PAb
operator|=
name|SA
operator|+
name|n
operator|-
name|m
expr_stmt|;
name|ISAb
operator|=
name|SA
operator|+
name|m
expr_stmt|;
for|for
control|(
name|i
operator|=
name|m
operator|-
literal|2
init|;
literal|0
operator|<=
name|i
condition|;
operator|--
name|i
control|)
block|{
name|t
operator|=
name|PAb
index|[
name|i
index|]
operator|,
name|c0
operator|=
name|T
index|[
name|t
index|]
operator|,
name|c1
operator|=
name|T
index|[
name|t
operator|+
literal|1
index|]
expr_stmt|;
name|SA
index|[
operator|--
name|BUCKET_BSTAR
argument_list|(
name|c0
argument_list|,
name|c1
argument_list|)
index|]
operator|=
name|i
expr_stmt|;
block|}
name|t
operator|=
name|PAb
index|[
name|m
operator|-
literal|1
index|]
operator|,
name|c0
operator|=
name|T
index|[
name|t
index|]
operator|,
name|c1
operator|=
name|T
index|[
name|t
operator|+
literal|1
index|]
expr_stmt|;
name|SA
index|[
operator|--
name|BUCKET_BSTAR
argument_list|(
name|c0
argument_list|,
name|c1
argument_list|)
index|]
operator|=
name|m
operator|-
literal|1
expr_stmt|;
comment|/* Sort the type B* substrings using sssort. */
ifdef|#
directive|ifdef
name|_OPENMP
name|tmp
operator|=
name|omp_get_max_threads
argument_list|()
expr_stmt|;
name|buf
operator|=
name|SA
operator|+
name|m
operator|,
name|bufsize
operator|=
operator|(
name|n
operator|-
operator|(
literal|2
operator|*
name|m
operator|)
operator|)
operator|/
name|tmp
expr_stmt|;
name|c0
operator|=
name|ALPHABET_SIZE
operator|-
literal|2
operator|,
name|c1
operator|=
name|ALPHABET_SIZE
operator|-
literal|1
operator|,
name|j
operator|=
name|m
expr_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
name|default
name|(
name|shared
name|)
name|private
name|(
name|curbuf
name|,
name|k
name|,
name|l
name|,
name|d0
name|,
name|d1
name|,
name|tmp
name|)
block|{
name|tmp
operator|=
name|omp_get_thread_num
argument_list|()
expr_stmt|;
name|curbuf
operator|=
name|buf
operator|+
name|tmp
operator|*
name|bufsize
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
pragma|#
directive|pragma
name|omp
name|critical
name|(
name|sssort_lock
name|)
block|{
if|if
condition|(
literal|0
operator|<
operator|(
name|l
operator|=
name|j
operator|)
condition|)
block|{
name|d0
operator|=
name|c0
operator|,
name|d1
operator|=
name|c1
expr_stmt|;
do|do
block|{
name|k
operator|=
name|BUCKET_BSTAR
argument_list|(
name|d0
argument_list|,
name|d1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|d1
operator|<=
name|d0
condition|)
block|{
name|d1
operator|=
name|ALPHABET_SIZE
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|--
name|d0
operator|<
literal|0
condition|)
block|{
break|break;
block|}
block|}
block|}
do|while
condition|(
operator|(
operator|(
name|l
operator|-
name|k
operator|)
operator|<=
literal|1
operator|)
operator|&&
operator|(
literal|0
operator|<
operator|(
name|l
operator|=
name|k
operator|)
operator|)
condition|)
do|;
name|c0
operator|=
name|d0
operator|,
name|c1
operator|=
name|d1
operator|,
name|j
operator|=
name|k
expr_stmt|;
block|}
block|}
if|if
condition|(
name|l
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|sssort
argument_list|(
name|T
argument_list|,
name|PAb
argument_list|,
name|SA
operator|+
name|k
argument_list|,
name|SA
operator|+
name|l
argument_list|,
name|curbuf
argument_list|,
name|bufsize
argument_list|,
literal|2
argument_list|,
name|n
argument_list|,
operator|*
operator|(
name|SA
operator|+
name|k
operator|)
operator|==
operator|(
name|m
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
name|buf
operator|=
name|SA
operator|+
name|m
operator|,
name|bufsize
operator|=
name|n
operator|-
operator|(
literal|2
operator|*
name|m
operator|)
expr_stmt|;
for|for
control|(
name|c0
operator|=
name|ALPHABET_SIZE
operator|-
literal|2
operator|,
name|j
operator|=
name|m
init|;
literal|0
operator|<
name|j
condition|;
operator|--
name|c0
control|)
block|{
for|for
control|(
name|c1
operator|=
name|ALPHABET_SIZE
operator|-
literal|1
init|;
name|c0
operator|<
name|c1
condition|;
name|j
operator|=
name|i
operator|,
operator|--
name|c1
control|)
block|{
name|i
operator|=
name|BUCKET_BSTAR
argument_list|(
name|c0
argument_list|,
name|c1
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|<
operator|(
name|j
operator|-
name|i
operator|)
condition|)
block|{
name|sssort
argument_list|(
name|T
argument_list|,
name|PAb
argument_list|,
name|SA
operator|+
name|i
argument_list|,
name|SA
operator|+
name|j
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|,
literal|2
argument_list|,
name|n
argument_list|,
operator|*
operator|(
name|SA
operator|+
name|i
operator|)
operator|==
operator|(
name|m
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* Compute ranks of type B* substrings. */
for|for
control|(
name|i
operator|=
name|m
operator|-
literal|1
init|;
literal|0
operator|<=
name|i
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
literal|0
operator|<=
name|SA
index|[
name|i
index|]
condition|)
block|{
name|j
operator|=
name|i
expr_stmt|;
do|do
block|{
name|ISAb
index|[
name|SA
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
block|}
do|while
condition|(
operator|(
literal|0
operator|<=
operator|--
name|i
operator|)
operator|&&
operator|(
literal|0
operator|<=
name|SA
index|[
name|i
index|]
operator|)
condition|)
do|;
name|SA
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|i
operator|-
name|j
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
break|break;
block|}
block|}
name|j
operator|=
name|i
expr_stmt|;
do|do
block|{
name|ISAb
index|[
name|SA
index|[
name|i
index|]
operator|=
operator|~
name|SA
index|[
name|i
index|]
index|]
operator|=
name|j
expr_stmt|;
block|}
do|while
condition|(
name|SA
index|[
operator|--
name|i
index|]
operator|<
literal|0
condition|)
do|;
name|ISAb
index|[
name|SA
index|[
name|i
index|]
index|]
operator|=
name|j
expr_stmt|;
block|}
comment|/* Construct the inverse suffix array of type B* suffixes using trsort. */
name|trsort
argument_list|(
name|ISAb
argument_list|,
name|SA
argument_list|,
name|m
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set the sorted order of tyoe B* suffixes. */
for|for
control|(
name|i
operator|=
name|n
operator|-
literal|1
operator|,
name|j
operator|=
name|m
operator|,
name|c0
operator|=
name|T
index|[
name|n
operator|-
literal|1
index|]
init|;
literal|0
operator|<=
name|i
condition|;
control|)
block|{
for|for
control|(
operator|--
name|i
operator|,
name|c1
operator|=
name|c0
init|;
operator|(
literal|0
operator|<=
name|i
operator|)
operator|&&
operator|(
operator|(
name|c0
operator|=
name|T
index|[
name|i
index|]
operator|)
operator|>=
name|c1
operator|)
condition|;
operator|--
name|i
operator|,
name|c1
operator|=
name|c0
control|)
block|{ }
if|if
condition|(
literal|0
operator|<=
name|i
condition|)
block|{
name|t
operator|=
name|i
expr_stmt|;
for|for
control|(
operator|--
name|i
operator|,
name|c1
operator|=
name|c0
init|;
operator|(
literal|0
operator|<=
name|i
operator|)
operator|&&
operator|(
operator|(
name|c0
operator|=
name|T
index|[
name|i
index|]
operator|)
operator|<=
name|c1
operator|)
condition|;
operator|--
name|i
operator|,
name|c1
operator|=
name|c0
control|)
block|{ }
name|SA
index|[
name|ISAb
index|[
operator|--
name|j
index|]
index|]
operator|=
operator|(
operator|(
name|t
operator|==
literal|0
operator|)
operator|||
operator|(
literal|1
operator|<
operator|(
name|t
operator|-
name|i
operator|)
operator|)
operator|)
condition|?
name|t
else|:
operator|~
name|t
expr_stmt|;
block|}
block|}
comment|/* Calculate the index of start/end point of each bucket. */
name|BUCKET_B
argument_list|(
name|ALPHABET_SIZE
operator|-
literal|1
argument_list|,
name|ALPHABET_SIZE
operator|-
literal|1
argument_list|)
operator|=
name|n
expr_stmt|;
comment|/* end point */
for|for
control|(
name|c0
operator|=
name|ALPHABET_SIZE
operator|-
literal|2
operator|,
name|k
operator|=
name|m
operator|-
literal|1
init|;
literal|0
operator|<=
name|c0
condition|;
operator|--
name|c0
control|)
block|{
name|i
operator|=
name|BUCKET_A
argument_list|(
name|c0
operator|+
literal|1
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|ALPHABET_SIZE
operator|-
literal|1
init|;
name|c0
operator|<
name|c1
condition|;
operator|--
name|c1
control|)
block|{
name|t
operator|=
name|i
operator|-
name|BUCKET_B
argument_list|(
name|c0
argument_list|,
name|c1
argument_list|)
expr_stmt|;
name|BUCKET_B
argument_list|(
name|c0
argument_list|,
name|c1
argument_list|)
operator|=
name|i
expr_stmt|;
comment|/* end point */
comment|/* Move all type B* suffixes to the correct position. */
for|for
control|(
name|i
operator|=
name|t
operator|,
name|j
operator|=
name|BUCKET_BSTAR
argument_list|(
name|c0
argument_list|,
name|c1
argument_list|)
init|;
name|j
operator|<=
name|k
condition|;
operator|--
name|i
operator|,
operator|--
name|k
control|)
block|{
name|SA
index|[
name|i
index|]
operator|=
name|SA
index|[
name|k
index|]
expr_stmt|;
block|}
block|}
name|BUCKET_BSTAR
argument_list|(
name|c0
argument_list|,
name|c0
operator|+
literal|1
argument_list|)
operator|=
name|i
operator|-
name|BUCKET_B
argument_list|(
name|c0
argument_list|,
name|c0
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* start point */
name|BUCKET_B
argument_list|(
name|c0
argument_list|,
name|c0
argument_list|)
operator|=
name|i
expr_stmt|;
comment|/* end point */
block|}
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* Constructs the suffix array by using the sorted order of type B* suffixes. */
end_comment

begin_function
specifier|static
name|void
name|construct_SA
parameter_list|(
specifier|const
name|sauchar_t
modifier|*
name|T
parameter_list|,
name|saidx_t
modifier|*
name|SA
parameter_list|,
name|saidx_t
modifier|*
name|bucket_A
parameter_list|,
name|saidx_t
modifier|*
name|bucket_B
parameter_list|,
name|saidx_t
name|n
parameter_list|,
name|saidx_t
name|m
parameter_list|)
block|{
name|saidx_t
modifier|*
name|i
decl_stmt|,
modifier|*
name|j
decl_stmt|,
modifier|*
name|k
decl_stmt|;
name|saidx_t
name|s
decl_stmt|;
name|saint_t
name|c0
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|;
if|if
condition|(
literal|0
operator|<
name|m
condition|)
block|{
comment|/* Construct the sorted order of type B suffixes by using        the sorted order of type B* suffixes. */
for|for
control|(
name|c1
operator|=
name|ALPHABET_SIZE
operator|-
literal|2
init|;
literal|0
operator|<=
name|c1
condition|;
operator|--
name|c1
control|)
block|{
comment|/* Scan the suffix array from right to left. */
for|for
control|(
name|i
operator|=
name|SA
operator|+
name|BUCKET_BSTAR
argument_list|(
name|c1
argument_list|,
name|c1
operator|+
literal|1
argument_list|)
operator|,
name|j
operator|=
name|SA
operator|+
name|BUCKET_A
argument_list|(
name|c1
operator|+
literal|1
argument_list|)
operator|-
literal|1
operator|,
name|k
operator|=
name|NULL
operator|,
name|c2
operator|=
operator|-
literal|1
init|;
name|i
operator|<=
name|j
condition|;
operator|--
name|j
control|)
block|{
if|if
condition|(
literal|0
operator|<
operator|(
name|s
operator|=
operator|*
name|j
operator|)
condition|)
block|{
name|assert
argument_list|(
name|T
index|[
name|s
index|]
operator|==
name|c1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
operator|(
name|s
operator|+
literal|1
operator|)
operator|<
name|n
operator|)
operator|&&
operator|(
name|T
index|[
name|s
index|]
operator|<=
name|T
index|[
name|s
operator|+
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|T
index|[
name|s
operator|-
literal|1
index|]
operator|<=
name|T
index|[
name|s
index|]
argument_list|)
expr_stmt|;
operator|*
name|j
operator|=
operator|~
name|s
expr_stmt|;
name|c0
operator|=
name|T
index|[
operator|--
name|s
index|]
expr_stmt|;
if|if
condition|(
operator|(
literal|0
operator|<
name|s
operator|)
operator|&&
operator|(
name|T
index|[
name|s
operator|-
literal|1
index|]
operator|>
name|c0
operator|)
condition|)
block|{
name|s
operator|=
operator|~
name|s
expr_stmt|;
block|}
if|if
condition|(
name|c0
operator|!=
name|c2
condition|)
block|{
if|if
condition|(
literal|0
operator|<=
name|c2
condition|)
block|{
name|BUCKET_B
argument_list|(
name|c2
argument_list|,
name|c1
argument_list|)
operator|=
name|k
operator|-
name|SA
expr_stmt|;
block|}
name|k
operator|=
name|SA
operator|+
name|BUCKET_B
argument_list|(
name|c2
operator|=
name|c0
argument_list|,
name|c1
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|k
operator|<
name|j
argument_list|)
expr_stmt|;
operator|*
name|k
operator|--
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
operator|(
operator|(
name|s
operator|==
literal|0
operator|)
operator|&&
operator|(
name|T
index|[
name|s
index|]
operator|==
name|c1
operator|)
operator|)
operator|||
operator|(
name|s
operator|<
literal|0
operator|)
argument_list|)
expr_stmt|;
operator|*
name|j
operator|=
operator|~
name|s
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Construct the suffix array by using      the sorted order of type B suffixes. */
name|k
operator|=
name|SA
operator|+
name|BUCKET_A
argument_list|(
name|c2
operator|=
name|T
index|[
name|n
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
operator|*
name|k
operator|++
operator|=
operator|(
name|T
index|[
name|n
operator|-
literal|2
index|]
operator|<
name|c2
operator|)
condition|?
operator|~
operator|(
name|n
operator|-
literal|1
operator|)
else|:
operator|(
name|n
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Scan the suffix array from left to right. */
for|for
control|(
name|i
operator|=
name|SA
operator|,
name|j
operator|=
name|SA
operator|+
name|n
init|;
name|i
operator|<
name|j
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
literal|0
operator|<
operator|(
name|s
operator|=
operator|*
name|i
operator|)
condition|)
block|{
name|assert
argument_list|(
name|T
index|[
name|s
operator|-
literal|1
index|]
operator|>=
name|T
index|[
name|s
index|]
argument_list|)
expr_stmt|;
name|c0
operator|=
name|T
index|[
operator|--
name|s
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|==
literal|0
operator|)
operator|||
operator|(
name|T
index|[
name|s
operator|-
literal|1
index|]
operator|<
name|c0
operator|)
condition|)
block|{
name|s
operator|=
operator|~
name|s
expr_stmt|;
block|}
if|if
condition|(
name|c0
operator|!=
name|c2
condition|)
block|{
name|BUCKET_A
argument_list|(
name|c2
argument_list|)
operator|=
name|k
operator|-
name|SA
expr_stmt|;
name|k
operator|=
name|SA
operator|+
name|BUCKET_A
argument_list|(
name|c2
operator|=
name|c0
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|i
operator|<
name|k
argument_list|)
expr_stmt|;
operator|*
name|k
operator|++
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|s
operator|<
literal|0
argument_list|)
expr_stmt|;
operator|*
name|i
operator|=
operator|~
name|s
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Constructs the burrows-wheeler transformed string directly    by using the sorted order of type B* suffixes. */
end_comment

begin_function
specifier|static
name|saidx_t
name|construct_BWT
parameter_list|(
specifier|const
name|sauchar_t
modifier|*
name|T
parameter_list|,
name|saidx_t
modifier|*
name|SA
parameter_list|,
name|saidx_t
modifier|*
name|bucket_A
parameter_list|,
name|saidx_t
modifier|*
name|bucket_B
parameter_list|,
name|saidx_t
name|n
parameter_list|,
name|saidx_t
name|m
parameter_list|)
block|{
name|saidx_t
modifier|*
name|i
decl_stmt|,
modifier|*
name|j
decl_stmt|,
modifier|*
name|k
decl_stmt|,
modifier|*
name|orig
decl_stmt|;
name|saidx_t
name|s
decl_stmt|;
name|saint_t
name|c0
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|;
if|if
condition|(
literal|0
operator|<
name|m
condition|)
block|{
comment|/* Construct the sorted order of type B suffixes by using        the sorted order of type B* suffixes. */
for|for
control|(
name|c1
operator|=
name|ALPHABET_SIZE
operator|-
literal|2
init|;
literal|0
operator|<=
name|c1
condition|;
operator|--
name|c1
control|)
block|{
comment|/* Scan the suffix array from right to left. */
for|for
control|(
name|i
operator|=
name|SA
operator|+
name|BUCKET_BSTAR
argument_list|(
name|c1
argument_list|,
name|c1
operator|+
literal|1
argument_list|)
operator|,
name|j
operator|=
name|SA
operator|+
name|BUCKET_A
argument_list|(
name|c1
operator|+
literal|1
argument_list|)
operator|-
literal|1
operator|,
name|k
operator|=
name|NULL
operator|,
name|c2
operator|=
operator|-
literal|1
init|;
name|i
operator|<=
name|j
condition|;
operator|--
name|j
control|)
block|{
if|if
condition|(
literal|0
operator|<
operator|(
name|s
operator|=
operator|*
name|j
operator|)
condition|)
block|{
name|assert
argument_list|(
name|T
index|[
name|s
index|]
operator|==
name|c1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
operator|(
name|s
operator|+
literal|1
operator|)
operator|<
name|n
operator|)
operator|&&
operator|(
name|T
index|[
name|s
index|]
operator|<=
name|T
index|[
name|s
operator|+
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|T
index|[
name|s
operator|-
literal|1
index|]
operator|<=
name|T
index|[
name|s
index|]
argument_list|)
expr_stmt|;
name|c0
operator|=
name|T
index|[
operator|--
name|s
index|]
expr_stmt|;
operator|*
name|j
operator|=
operator|~
operator|(
operator|(
name|saidx_t
operator|)
name|c0
operator|)
expr_stmt|;
if|if
condition|(
operator|(
literal|0
operator|<
name|s
operator|)
operator|&&
operator|(
name|T
index|[
name|s
operator|-
literal|1
index|]
operator|>
name|c0
operator|)
condition|)
block|{
name|s
operator|=
operator|~
name|s
expr_stmt|;
block|}
if|if
condition|(
name|c0
operator|!=
name|c2
condition|)
block|{
if|if
condition|(
literal|0
operator|<=
name|c2
condition|)
block|{
name|BUCKET_B
argument_list|(
name|c2
argument_list|,
name|c1
argument_list|)
operator|=
name|k
operator|-
name|SA
expr_stmt|;
block|}
name|k
operator|=
name|SA
operator|+
name|BUCKET_B
argument_list|(
name|c2
operator|=
name|c0
argument_list|,
name|c1
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|k
operator|<
name|j
argument_list|)
expr_stmt|;
operator|*
name|k
operator|--
operator|=
name|s
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|!=
literal|0
condition|)
block|{
operator|*
name|j
operator|=
operator|~
name|s
expr_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
block|}
else|else
block|{
name|assert
argument_list|(
name|T
index|[
name|s
index|]
operator|==
name|c1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
block|}
comment|/* Construct the BWTed string by using      the sorted order of type B suffixes. */
name|k
operator|=
name|SA
operator|+
name|BUCKET_A
argument_list|(
name|c2
operator|=
name|T
index|[
name|n
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
operator|*
name|k
operator|++
operator|=
operator|(
name|T
index|[
name|n
operator|-
literal|2
index|]
operator|<
name|c2
operator|)
condition|?
operator|~
operator|(
operator|(
name|saidx_t
operator|)
name|T
index|[
name|n
operator|-
literal|2
index|]
operator|)
else|:
operator|(
name|n
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Scan the suffix array from left to right. */
for|for
control|(
name|i
operator|=
name|SA
operator|,
name|j
operator|=
name|SA
operator|+
name|n
operator|,
name|orig
operator|=
name|SA
init|;
name|i
operator|<
name|j
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
literal|0
operator|<
operator|(
name|s
operator|=
operator|*
name|i
operator|)
condition|)
block|{
name|assert
argument_list|(
name|T
index|[
name|s
operator|-
literal|1
index|]
operator|>=
name|T
index|[
name|s
index|]
argument_list|)
expr_stmt|;
name|c0
operator|=
name|T
index|[
operator|--
name|s
index|]
expr_stmt|;
operator|*
name|i
operator|=
name|c0
expr_stmt|;
if|if
condition|(
operator|(
literal|0
operator|<
name|s
operator|)
operator|&&
operator|(
name|T
index|[
name|s
operator|-
literal|1
index|]
operator|<
name|c0
operator|)
condition|)
block|{
name|s
operator|=
operator|~
operator|(
operator|(
name|saidx_t
operator|)
name|T
index|[
name|s
operator|-
literal|1
index|]
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|c0
operator|!=
name|c2
condition|)
block|{
name|BUCKET_A
argument_list|(
name|c2
argument_list|)
operator|=
name|k
operator|-
name|SA
expr_stmt|;
name|k
operator|=
name|SA
operator|+
name|BUCKET_A
argument_list|(
name|c2
operator|=
name|c0
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|i
operator|<
name|k
argument_list|)
expr_stmt|;
operator|*
name|k
operator|++
operator|=
name|s
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|!=
literal|0
condition|)
block|{
operator|*
name|i
operator|=
operator|~
name|s
expr_stmt|;
block|}
else|else
block|{
name|orig
operator|=
name|i
expr_stmt|;
block|}
block|}
return|return
name|orig
operator|-
name|SA
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*- Function -*/
end_comment

begin_function
name|saint_t
name|divsufsort
parameter_list|(
specifier|const
name|sauchar_t
modifier|*
name|T
parameter_list|,
name|saidx_t
modifier|*
name|SA
parameter_list|,
name|saidx_t
name|n
parameter_list|)
block|{
name|saidx_t
modifier|*
name|bucket_A
decl_stmt|,
modifier|*
name|bucket_B
decl_stmt|;
name|saidx_t
name|m
decl_stmt|;
name|saint_t
name|err
init|=
literal|0
decl_stmt|;
comment|/* Check arguments. */
if|if
condition|(
operator|(
name|T
operator|==
name|NULL
operator|)
operator|||
operator|(
name|SA
operator|==
name|NULL
operator|)
operator|||
operator|(
name|n
operator|<
literal|0
operator|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|n
operator|==
literal|1
condition|)
block|{
name|SA
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|n
operator|==
literal|2
condition|)
block|{
name|m
operator|=
operator|(
name|T
index|[
literal|0
index|]
operator|<
name|T
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|SA
index|[
name|m
operator|^
literal|1
index|]
operator|=
literal|0
operator|,
name|SA
index|[
name|m
index|]
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bucket_A
operator|=
operator|(
name|saidx_t
operator|*
operator|)
name|malloc
argument_list|(
name|BUCKET_A_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|saidx_t
argument_list|)
argument_list|)
expr_stmt|;
name|bucket_B
operator|=
operator|(
name|saidx_t
operator|*
operator|)
name|malloc
argument_list|(
name|BUCKET_B_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|saidx_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Suffixsort. */
if|if
condition|(
operator|(
name|bucket_A
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|bucket_B
operator|!=
name|NULL
operator|)
condition|)
block|{
name|m
operator|=
name|sort_typeBstar
argument_list|(
name|T
argument_list|,
name|SA
argument_list|,
name|bucket_A
argument_list|,
name|bucket_B
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|construct_SA
argument_list|(
name|T
argument_list|,
name|SA
argument_list|,
name|bucket_A
argument_list|,
name|bucket_B
argument_list|,
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
operator|-
literal|2
expr_stmt|;
block|}
name|free
argument_list|(
name|bucket_B
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bucket_A
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|saidx_t
name|divbwt
parameter_list|(
specifier|const
name|sauchar_t
modifier|*
name|T
parameter_list|,
name|sauchar_t
modifier|*
name|U
parameter_list|,
name|saidx_t
modifier|*
name|A
parameter_list|,
name|saidx_t
name|n
parameter_list|)
block|{
name|saidx_t
modifier|*
name|B
decl_stmt|;
name|saidx_t
modifier|*
name|bucket_A
decl_stmt|,
modifier|*
name|bucket_B
decl_stmt|;
name|saidx_t
name|m
decl_stmt|,
name|pidx
decl_stmt|,
name|i
decl_stmt|;
comment|/* Check arguments. */
if|if
condition|(
operator|(
name|T
operator|==
name|NULL
operator|)
operator|||
operator|(
name|U
operator|==
name|NULL
operator|)
operator|||
operator|(
name|n
operator|<
literal|0
operator|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|n
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|1
condition|)
block|{
name|U
index|[
literal|0
index|]
operator|=
name|T
index|[
literal|0
index|]
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
if|if
condition|(
operator|(
name|B
operator|=
name|A
operator|)
operator|==
name|NULL
condition|)
block|{
name|B
operator|=
operator|(
name|saidx_t
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|size_t
call|)
argument_list|(
name|n
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|saidx_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bucket_A
operator|=
operator|(
name|saidx_t
operator|*
operator|)
name|malloc
argument_list|(
name|BUCKET_A_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|saidx_t
argument_list|)
argument_list|)
expr_stmt|;
name|bucket_B
operator|=
operator|(
name|saidx_t
operator|*
operator|)
name|malloc
argument_list|(
name|BUCKET_B_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|saidx_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Burrows-Wheeler Transform. */
if|if
condition|(
operator|(
name|B
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|bucket_A
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|bucket_B
operator|!=
name|NULL
operator|)
condition|)
block|{
name|m
operator|=
name|sort_typeBstar
argument_list|(
name|T
argument_list|,
name|B
argument_list|,
name|bucket_A
argument_list|,
name|bucket_B
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|pidx
operator|=
name|construct_BWT
argument_list|(
name|T
argument_list|,
name|B
argument_list|,
name|bucket_A
argument_list|,
name|bucket_B
argument_list|,
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Copy to output string. */
name|U
index|[
literal|0
index|]
operator|=
name|T
index|[
name|n
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pidx
condition|;
operator|++
name|i
control|)
block|{
name|U
index|[
name|i
operator|+
literal|1
index|]
operator|=
operator|(
name|sauchar_t
operator|)
name|B
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|+=
literal|1
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|U
index|[
name|i
index|]
operator|=
operator|(
name|sauchar_t
operator|)
name|B
index|[
name|i
index|]
expr_stmt|;
block|}
name|pidx
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|pidx
operator|=
operator|-
literal|2
expr_stmt|;
block|}
name|free
argument_list|(
name|bucket_B
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bucket_A
argument_list|)
expr_stmt|;
if|if
condition|(
name|A
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|B
argument_list|)
expr_stmt|;
block|}
return|return
name|pidx
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|divsufsort_version
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|PROJECT_VERSION_FULL
return|;
block|}
end_function

end_unit

