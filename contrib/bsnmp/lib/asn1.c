begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2001-2003  *	Fraunhofer Institute for Open Communication Systems (FhG Fokus).  *	All rights reserved.  *  * Author: Harti Brandt<harti@freebsd.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Begemot: bsnmp/lib/asn1.c,v 1.31 2005/10/06 07:14:58 brandt_h Exp $  *  * ASN.1 for SNMP.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDINT_H
end_ifdef

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_INTTYPES_H
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"support.h"
end_include

begin_include
include|#
directive|include
file|"asn1.h"
end_include

begin_function_decl
specifier|static
name|void
name|asn_error_func
parameter_list|(
specifier|const
name|struct
name|asn_buf
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|asn_error
function_decl|)
parameter_list|(
specifier|const
name|struct
name|asn_buf
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
init|=
name|asn_error_func
function_decl|;
end_function_decl

begin_comment
comment|/*  * Read the next header. This reads the tag (note, that only single  * byte tags are supported for now) and the length field. The length field  * is restricted to a 32-bit value.  * All errors of this function stop the decoding.  */
end_comment

begin_function
name|enum
name|asn_err
name|asn_get_header
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
name|u_char
modifier|*
name|type
parameter_list|,
name|asn_len_t
modifier|*
name|len
parameter_list|)
block|{
name|u_int
name|length
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|asn_len
operator|==
literal|0
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"no identifier for header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ASN_ERR_EOBUF
operator|)
return|;
block|}
operator|*
name|type
operator|=
operator|*
name|b
operator|->
name|asn_cptr
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|type
operator|&
name|ASN_TYPE_MASK
operator|)
operator|>
literal|0x30
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"types> 0x30 not supported (%u)"
argument_list|,
operator|*
name|type
operator|&
name|ASN_TYPE_MASK
argument_list|)
expr_stmt|;
return|return
operator|(
name|ASN_ERR_FAILED
operator|)
return|;
block|}
name|b
operator|->
name|asn_cptr
operator|++
expr_stmt|;
name|b
operator|->
name|asn_len
operator|--
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|asn_len
operator|==
literal|0
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"no length field"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ASN_ERR_EOBUF
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|b
operator|->
name|asn_cptr
operator|&
literal|0x80
condition|)
block|{
name|length
operator|=
operator|*
name|b
operator|->
name|asn_cptr
operator|++
operator|&
literal|0x7f
expr_stmt|;
name|b
operator|->
name|asn_len
operator|--
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"indefinite length not supported"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ASN_ERR_FAILED
operator|)
return|;
block|}
if|if
condition|(
name|length
operator|>
name|ASN_MAXLENLEN
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"long length too long (%u)"
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
name|ASN_ERR_FAILED
operator|)
return|;
block|}
if|if
condition|(
name|length
operator|>
name|b
operator|->
name|asn_len
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"long length truncated"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ASN_ERR_EOBUF
operator|)
return|;
block|}
operator|*
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
operator|*
name|len
operator|=
operator|(
operator|*
name|len
operator|<<
literal|8
operator|)
operator||
operator|*
name|b
operator|->
name|asn_cptr
operator|++
expr_stmt|;
name|b
operator|->
name|asn_len
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|len
operator|=
operator|*
name|b
operator|->
name|asn_cptr
operator|++
expr_stmt|;
name|b
operator|->
name|asn_len
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|ASN_ERR_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write a length field (restricted to values< 2^32-1) and return the  * number of bytes this field takes. If ptr is NULL, the length is computed  * but nothing is written. If the length would be too large return 0.  */
end_comment

begin_function
specifier|static
name|u_int
name|asn_put_len
parameter_list|(
name|u_char
modifier|*
name|ptr
parameter_list|,
name|asn_len_t
name|len
parameter_list|)
block|{
name|u_int
name|lenlen
decl_stmt|,
name|lenlen1
decl_stmt|;
name|asn_len_t
name|tmp
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|ASN_MAXLEN
condition|)
block|{
name|asn_error
argument_list|(
name|NULL
argument_list|,
literal|"encoding length too long: (%u)"
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|<=
literal|127
condition|)
block|{
if|if
condition|(
name|ptr
condition|)
operator|*
name|ptr
operator|++
operator|=
operator|(
name|u_char
operator|)
name|len
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|lenlen
operator|=
literal|0
expr_stmt|;
comment|/* compute number of bytes for value (is at least 1) */
for|for
control|(
name|tmp
operator|=
name|len
init|;
name|tmp
operator|!=
literal|0
condition|;
name|tmp
operator|>>=
literal|8
control|)
name|lenlen
operator|++
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
operator|(
name|u_char
operator|)
name|lenlen
operator||
literal|0x80
expr_stmt|;
name|lenlen1
operator|=
name|lenlen
expr_stmt|;
while|while
condition|(
name|lenlen1
operator|--
operator|>
literal|0
condition|)
block|{
name|ptr
index|[
name|lenlen1
index|]
operator|=
name|len
operator|&
literal|0xff
expr_stmt|;
name|len
operator|>>=
literal|8
expr_stmt|;
block|}
block|}
return|return
operator|(
name|lenlen
operator|+
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Write a header (tag and length fields).  * Tags are restricted to one byte tags (value<= 0x30) and the  * lenght field to 16-bit. All errors stop the encoding.  */
end_comment

begin_function
name|enum
name|asn_err
name|asn_put_header
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
name|u_char
name|type
parameter_list|,
name|asn_len_t
name|len
parameter_list|)
block|{
name|u_int
name|lenlen
decl_stmt|;
comment|/* tag field */
if|if
condition|(
operator|(
name|type
operator|&
name|ASN_TYPE_MASK
operator|)
operator|>
literal|0x30
condition|)
block|{
name|asn_error
argument_list|(
name|NULL
argument_list|,
literal|"types> 0x30 not supported (%u)"
argument_list|,
name|type
operator|&
name|ASN_TYPE_MASK
argument_list|)
expr_stmt|;
return|return
operator|(
name|ASN_ERR_FAILED
operator|)
return|;
block|}
if|if
condition|(
name|b
operator|->
name|asn_len
operator|==
literal|0
condition|)
return|return
operator|(
name|ASN_ERR_EOBUF
operator|)
return|;
operator|*
name|b
operator|->
name|asn_ptr
operator|++
operator|=
name|type
expr_stmt|;
name|b
operator|->
name|asn_len
operator|--
expr_stmt|;
comment|/* length field */
if|if
condition|(
operator|(
name|lenlen
operator|=
name|asn_put_len
argument_list|(
name|NULL
argument_list|,
name|len
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ASN_ERR_FAILED
operator|)
return|;
if|if
condition|(
name|b
operator|->
name|asn_len
operator|<
name|lenlen
condition|)
return|return
operator|(
name|ASN_ERR_EOBUF
operator|)
return|;
operator|(
name|void
operator|)
name|asn_put_len
argument_list|(
name|b
operator|->
name|asn_ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|b
operator|->
name|asn_ptr
operator|+=
name|lenlen
expr_stmt|;
name|b
operator|->
name|asn_len
operator|-=
name|lenlen
expr_stmt|;
return|return
operator|(
name|ASN_ERR_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This constructs a temporary sequence header with space for the maximum  * length field (three byte). Set the pointer that ptr points to to the  * start of the encoded header. This is used for a later call to  * asn_commit_header which will fix-up the length field and move the  * value if needed. All errors should stop the encoding.  */
end_comment

begin_define
define|#
directive|define
name|TEMP_LEN
value|(1 + ASN_MAXLENLEN + 1)
end_define

begin_function
name|enum
name|asn_err
name|asn_put_temp_header
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
name|u_char
name|type
parameter_list|,
name|u_char
modifier|*
modifier|*
name|ptr
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|asn_len
operator|<
name|TEMP_LEN
condition|)
return|return
operator|(
name|ASN_ERR_EOBUF
operator|)
return|;
operator|*
name|ptr
operator|=
name|b
operator|->
name|asn_ptr
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|asn_put_header
argument_list|(
name|b
argument_list|,
name|type
argument_list|,
name|ASN_MAXLEN
argument_list|)
operator|)
operator|==
name|ASN_ERR_OK
condition|)
name|assert
argument_list|(
name|b
operator|->
name|asn_ptr
operator|==
operator|*
name|ptr
operator|+
name|TEMP_LEN
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|enum
name|asn_err
name|asn_commit_header
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
name|u_char
modifier|*
name|ptr
parameter_list|,
name|size_t
modifier|*
name|moved
parameter_list|)
block|{
name|asn_len_t
name|len
decl_stmt|;
name|u_int
name|lenlen
decl_stmt|,
name|shift
decl_stmt|;
comment|/* compute length of encoded value without header */
name|len
operator|=
name|b
operator|->
name|asn_ptr
operator|-
operator|(
name|ptr
operator|+
name|TEMP_LEN
operator|)
expr_stmt|;
comment|/* insert length. may not fail. */
name|lenlen
operator|=
name|asn_put_len
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|lenlen
operator|>
name|TEMP_LEN
operator|-
literal|1
condition|)
return|return
operator|(
name|ASN_ERR_FAILED
operator|)
return|;
if|if
condition|(
name|lenlen
operator|<
name|TEMP_LEN
operator|-
literal|1
condition|)
block|{
comment|/* shift value down */
name|shift
operator|=
operator|(
name|TEMP_LEN
operator|-
literal|1
operator|)
operator|-
name|lenlen
expr_stmt|;
name|memmove
argument_list|(
name|ptr
operator|+
literal|1
operator|+
name|lenlen
argument_list|,
name|ptr
operator|+
name|TEMP_LEN
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|b
operator|->
name|asn_ptr
operator|-=
name|shift
expr_stmt|;
name|b
operator|->
name|asn_len
operator|+=
name|shift
expr_stmt|;
if|if
condition|(
name|moved
operator|!=
name|NULL
condition|)
operator|*
name|moved
operator|=
name|shift
expr_stmt|;
block|}
return|return
operator|(
name|ASN_ERR_OK
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|TEMP_LEN
end_undef

begin_comment
comment|/*  * BER integer. This may be used to get a signed 64 bit integer at maximum.  * The maximum length should be checked by the caller. This cannot overflow  * if the caller ensures that len is at maximum 8.  *  *<bytes>  */
end_comment

begin_function
specifier|static
name|enum
name|asn_err
name|asn_get_real_integer
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
name|asn_len_t
name|len
parameter_list|,
name|int64_t
modifier|*
name|vp
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
name|int
name|neg
init|=
literal|0
decl_stmt|;
name|enum
name|asn_err
name|err
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|asn_len
operator|<
name|len
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"truncated integer"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ASN_ERR_EOBUF
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"zero-length integer"
argument_list|)
expr_stmt|;
operator|*
name|vp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ASN_ERR_BADLEN
operator|)
return|;
block|}
name|err
operator|=
name|ASN_ERR_OK
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|8
condition|)
name|err
operator|=
name|ASN_ERR_RANGE
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|>
literal|1
operator|&&
operator|(
operator|(
operator|*
name|b
operator|->
name|asn_cptr
operator|==
literal|0x00
operator|&&
operator|(
name|b
operator|->
name|asn_cptr
index|[
literal|1
index|]
operator|&
literal|0x80
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|*
name|b
operator|->
name|asn_cptr
operator|==
literal|0xff
operator|&&
operator|(
name|b
operator|->
name|asn_cptr
index|[
literal|1
index|]
operator|&
literal|0x80
operator|)
operator|==
literal|0x80
operator|)
operator|)
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"non-minimal integer"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ASN_ERR_BADLEN
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|b
operator|->
name|asn_cptr
operator|&
literal|0x80
condition|)
name|neg
operator|=
literal|1
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|val
operator|<<=
literal|8
expr_stmt|;
name|val
operator||=
name|neg
condition|?
operator|(
name|u_char
operator|)
operator|~
operator|*
name|b
operator|->
name|asn_cptr
else|:
operator|*
name|b
operator|->
name|asn_cptr
expr_stmt|;
name|b
operator|->
name|asn_len
operator|--
expr_stmt|;
name|b
operator|->
name|asn_cptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|neg
condition|)
block|{
operator|*
name|vp
operator|=
operator|-
operator|(
name|int64_t
operator|)
name|val
operator|-
literal|1
expr_stmt|;
block|}
else|else
operator|*
name|vp
operator|=
operator|(
name|int64_t
operator|)
name|val
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write a signed integer with the given type. The caller has to ensure  * that the actual value is ok for this type.  */
end_comment

begin_function
specifier|static
name|enum
name|asn_err
name|asn_put_real_integer
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
name|u_char
name|type
parameter_list|,
name|int64_t
name|ival
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|neg
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|OCTETS
value|8
name|u_char
name|buf
index|[
name|OCTETS
index|]
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|enum
name|asn_err
name|ret
decl_stmt|;
if|if
condition|(
name|ival
operator|<
literal|0
condition|)
block|{
comment|/* this may fail if |INT64_MIN|> |INT64_MAX| and 		 * the value is between * INT64_MIN<= ival< -(INT64_MAX+1) */
name|val
operator|=
operator|(
name|uint64_t
operator|)
operator|-
operator|(
name|ival
operator|+
literal|1
operator|)
expr_stmt|;
name|neg
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|val
operator|=
operator|(
name|uint64_t
operator|)
name|ival
expr_stmt|;
comment|/* split the value into octets */
for|for
control|(
name|i
operator|=
name|OCTETS
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|buf
index|[
name|i
index|]
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|neg
condition|)
name|buf
index|[
name|i
index|]
operator|=
operator|~
name|buf
index|[
name|i
index|]
expr_stmt|;
name|val
operator|>>=
literal|8
expr_stmt|;
block|}
comment|/* no leading 9 zeroes or ones */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OCTETS
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
operator|(
name|buf
index|[
name|i
index|]
operator|==
literal|0xff
operator|&&
operator|(
name|buf
index|[
name|i
operator|+
literal|1
index|]
operator|&
literal|0x80
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|buf
index|[
name|i
index|]
operator|==
literal|0x00
operator|&&
operator|(
name|buf
index|[
name|i
operator|+
literal|1
index|]
operator|&
literal|0x80
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|ret
operator|=
name|asn_put_header
argument_list|(
name|b
argument_list|,
name|type
argument_list|,
name|OCTETS
operator|-
name|i
argument_list|)
operator|)
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|OCTETS
operator|-
operator|(
name|u_int
operator|)
name|i
operator|>
name|b
operator|->
name|asn_len
condition|)
return|return
operator|(
name|ASN_ERR_EOBUF
operator|)
return|;
while|while
condition|(
name|i
operator|<
name|OCTETS
condition|)
block|{
operator|*
name|b
operator|->
name|asn_ptr
operator|++
operator|=
name|buf
index|[
name|i
operator|++
index|]
expr_stmt|;
name|b
operator|->
name|asn_len
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|ASN_ERR_OK
operator|)
return|;
undef|#
directive|undef
name|OCTETS
block|}
end_function

begin_comment
comment|/*  * The same for unsigned 64-bitters. Here we have the problem, that overflow  * can happen, because the value maybe 9 bytes long. In this case the  * first byte must be 0.  */
end_comment

begin_function
specifier|static
name|enum
name|asn_err
name|asn_get_real_unsigned
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
name|asn_len_t
name|len
parameter_list|,
name|uint64_t
modifier|*
name|vp
parameter_list|)
block|{
name|enum
name|asn_err
name|err
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|asn_len
operator|<
name|len
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"truncated integer"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ASN_ERR_EOBUF
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"zero-length integer"
argument_list|)
expr_stmt|;
operator|*
name|vp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ASN_ERR_BADLEN
operator|)
return|;
block|}
name|err
operator|=
name|ASN_ERR_OK
expr_stmt|;
operator|*
name|vp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|b
operator|->
name|asn_cptr
operator|&
literal|0x80
operator|)
operator|||
operator|(
name|len
operator|==
literal|9
operator|&&
operator|*
name|b
operator|->
name|asn_cptr
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* negative integer or too larger */
operator|*
name|vp
operator|=
literal|0xffffffffffffffffULL
expr_stmt|;
name|err
operator|=
name|ASN_ERR_RANGE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|>
literal|1
operator|&&
operator|*
name|b
operator|->
name|asn_cptr
operator|==
literal|0x00
operator|&&
operator|(
name|b
operator|->
name|asn_cptr
index|[
literal|1
index|]
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"non-minimal unsigned"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ASN_ERR_BADLEN
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|--
condition|)
block|{
operator|*
name|vp
operator|=
operator|(
operator|*
name|vp
operator|<<
literal|8
operator|)
operator||
operator|*
name|b
operator|->
name|asn_cptr
operator|++
expr_stmt|;
name|b
operator|->
name|asn_len
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Values with the msb on need 9 octets.  */
end_comment

begin_function
specifier|static
name|int
name|asn_put_real_unsigned
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
name|u_char
name|type
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
define|#
directive|define
name|OCTETS
value|9
name|u_char
name|buf
index|[
name|OCTETS
index|]
decl_stmt|;
name|enum
name|asn_err
name|ret
decl_stmt|;
comment|/* split the value into octets */
for|for
control|(
name|i
operator|=
name|OCTETS
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|buf
index|[
name|i
index|]
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
name|val
operator|>>=
literal|8
expr_stmt|;
block|}
comment|/* no leading 9 zeroes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OCTETS
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|buf
index|[
name|i
index|]
operator|==
literal|0x00
operator|&&
operator|(
name|buf
index|[
name|i
operator|+
literal|1
index|]
operator|&
literal|0x80
operator|)
operator|==
literal|0
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|ret
operator|=
name|asn_put_header
argument_list|(
name|b
argument_list|,
name|type
argument_list|,
name|OCTETS
operator|-
name|i
argument_list|)
operator|)
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|OCTETS
operator|-
operator|(
name|u_int
operator|)
name|i
operator|>
name|b
operator|->
name|asn_len
condition|)
return|return
operator|(
name|ASN_ERR_EOBUF
operator|)
return|;
while|while
condition|(
name|i
operator|<
name|OCTETS
condition|)
block|{
operator|*
name|b
operator|->
name|asn_ptr
operator|++
operator|=
name|buf
index|[
name|i
operator|++
index|]
expr_stmt|;
name|b
operator|->
name|asn_len
operator|--
expr_stmt|;
block|}
undef|#
directive|undef
name|OCTETS
return|return
operator|(
name|ASN_ERR_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The ASN.1 INTEGER type is restricted to 32-bit signed by the SMI.  */
end_comment

begin_function
name|enum
name|asn_err
name|asn_get_integer_raw
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
name|asn_len_t
name|len
parameter_list|,
name|int32_t
modifier|*
name|vp
parameter_list|)
block|{
name|int64_t
name|val
decl_stmt|;
name|enum
name|asn_err
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|asn_get_real_integer
argument_list|(
name|b
argument_list|,
name|len
argument_list|,
operator|&
name|val
argument_list|)
operator|)
operator|==
name|ASN_ERR_OK
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|4
condition|)
name|ret
operator|=
name|ASN_ERR_BADLEN
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|>
name|INT32_MAX
operator|||
name|val
operator|<
name|INT32_MIN
condition|)
comment|/* may not happen */
name|ret
operator|=
name|ASN_ERR_RANGE
expr_stmt|;
operator|*
name|vp
operator|=
operator|(
name|int32_t
operator|)
name|val
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|enum
name|asn_err
name|asn_get_integer
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
name|int32_t
modifier|*
name|vp
parameter_list|)
block|{
name|asn_len_t
name|len
decl_stmt|;
name|u_char
name|type
decl_stmt|;
name|enum
name|asn_err
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|asn_get_header
argument_list|(
name|b
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|!=
name|ASN_ERR_OK
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|type
operator|!=
name|ASN_TYPE_INTEGER
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"bad type for integer (%u)"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|ASN_ERR_TAG
operator|)
return|;
block|}
return|return
operator|(
name|asn_get_integer_raw
argument_list|(
name|b
argument_list|,
name|len
argument_list|,
name|vp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|enum
name|asn_err
name|asn_put_integer
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
name|int32_t
name|val
parameter_list|)
block|{
return|return
operator|(
name|asn_put_real_integer
argument_list|(
name|b
argument_list|,
name|ASN_TYPE_INTEGER
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * OCTETSTRING  *  *<0x04><len><data ...>  *  * Get an octetstring. noctets must point to the buffer size and on  * return will contain the size of the octetstring, regardless of the  * buffer size.  */
end_comment

begin_function
name|enum
name|asn_err
name|asn_get_octetstring_raw
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
name|asn_len_t
name|len
parameter_list|,
name|u_char
modifier|*
name|octets
parameter_list|,
name|u_int
modifier|*
name|noctets
parameter_list|)
block|{
name|enum
name|asn_err
name|err
init|=
name|ASN_ERR_OK
decl_stmt|;
if|if
condition|(
operator|*
name|noctets
operator|<
name|len
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"octetstring truncated"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ASN_ERR_RANGE
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|asn_len
operator|<
name|len
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"truncatet octetstring"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ASN_ERR_EOBUF
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|noctets
operator|<
name|len
condition|)
name|memcpy
argument_list|(
name|octets
argument_list|,
name|b
operator|->
name|asn_cptr
argument_list|,
operator|*
name|noctets
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|octets
argument_list|,
name|b
operator|->
name|asn_cptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
name|noctets
operator|=
name|len
expr_stmt|;
name|b
operator|->
name|asn_cptr
operator|+=
name|len
expr_stmt|;
name|b
operator|->
name|asn_len
operator|-=
name|len
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|enum
name|asn_err
name|asn_get_octetstring
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
name|u_char
modifier|*
name|octets
parameter_list|,
name|u_int
modifier|*
name|noctets
parameter_list|)
block|{
name|enum
name|asn_err
name|err
decl_stmt|;
name|u_char
name|type
decl_stmt|;
name|asn_len_t
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|asn_get_header
argument_list|(
name|b
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|!=
name|ASN_ERR_OK
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|type
operator|!=
name|ASN_TYPE_OCTETSTRING
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"bad type for octetstring (%u)"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|ASN_ERR_TAG
operator|)
return|;
block|}
return|return
operator|(
name|asn_get_octetstring_raw
argument_list|(
name|b
argument_list|,
name|len
argument_list|,
name|octets
argument_list|,
name|noctets
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|enum
name|asn_err
name|asn_put_octetstring
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
specifier|const
name|u_char
modifier|*
name|octets
parameter_list|,
name|u_int
name|noctets
parameter_list|)
block|{
name|enum
name|asn_err
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|asn_put_header
argument_list|(
name|b
argument_list|,
name|ASN_TYPE_OCTETSTRING
argument_list|,
name|noctets
argument_list|)
operator|)
operator|!=
name|ASN_ERR_OK
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|b
operator|->
name|asn_len
operator|<
name|noctets
condition|)
return|return
operator|(
name|ASN_ERR_EOBUF
operator|)
return|;
name|memcpy
argument_list|(
name|b
operator|->
name|asn_ptr
argument_list|,
name|octets
argument_list|,
name|noctets
argument_list|)
expr_stmt|;
name|b
operator|->
name|asn_ptr
operator|+=
name|noctets
expr_stmt|;
name|b
operator|->
name|asn_len
operator|-=
name|noctets
expr_stmt|;
return|return
operator|(
name|ASN_ERR_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * NULL  *  *<0x05><0x00>  */
end_comment

begin_function
name|enum
name|asn_err
name|asn_get_null_raw
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
name|asn_len_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|asn_len
operator|<
name|len
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"truncated NULL"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ASN_ERR_EOBUF
operator|)
return|;
block|}
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"bad length for NULL (%u)"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|b
operator|->
name|asn_len
operator|-=
name|len
expr_stmt|;
name|b
operator|->
name|asn_ptr
operator|+=
name|len
expr_stmt|;
return|return
operator|(
name|ASN_ERR_BADLEN
operator|)
return|;
block|}
return|return
operator|(
name|ASN_ERR_OK
operator|)
return|;
block|}
end_function

begin_function
name|enum
name|asn_err
name|asn_get_null
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|)
block|{
name|u_char
name|type
decl_stmt|;
name|asn_len_t
name|len
decl_stmt|;
name|enum
name|asn_err
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|asn_get_header
argument_list|(
name|b
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|!=
name|ASN_ERR_OK
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|type
operator|!=
name|ASN_TYPE_NULL
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"bad type for NULL (%u)"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|ASN_ERR_TAG
operator|)
return|;
block|}
return|return
operator|(
name|asn_get_null_raw
argument_list|(
name|b
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|enum
name|asn_err
name|asn_put_null
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|)
block|{
return|return
operator|(
name|asn_put_header
argument_list|(
name|b
argument_list|,
name|ASN_TYPE_NULL
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|enum
name|asn_err
name|asn_put_exception
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
name|u_int
name|except
parameter_list|)
block|{
return|return
operator|(
name|asn_put_header
argument_list|(
name|b
argument_list|,
name|ASN_CLASS_CONTEXT
operator||
name|except
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * OBJID  *  *<0x06><len><subid...>  */
end_comment

begin_function
name|enum
name|asn_err
name|asn_get_objid_raw
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
name|asn_len_t
name|len
parameter_list|,
name|struct
name|asn_oid
modifier|*
name|oid
parameter_list|)
block|{
name|asn_subid_t
name|subid
decl_stmt|;
name|enum
name|asn_err
name|err
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|asn_len
operator|<
name|len
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"truncated OBJID"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ASN_ERR_EOBUF
operator|)
return|;
block|}
name|oid
operator|->
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"short OBJID"
argument_list|)
expr_stmt|;
name|oid
operator|->
name|subs
index|[
name|oid
operator|->
name|len
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|oid
operator|->
name|subs
index|[
name|oid
operator|->
name|len
operator|++
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ASN_ERR_BADLEN
operator|)
return|;
block|}
name|err
operator|=
name|ASN_ERR_OK
expr_stmt|;
while|while
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|oid
operator|->
name|len
operator|==
name|ASN_MAXOIDLEN
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"OID too long (%u)"
argument_list|,
name|oid
operator|->
name|len
argument_list|)
expr_stmt|;
name|b
operator|->
name|asn_cptr
operator|+=
name|len
expr_stmt|;
name|b
operator|->
name|asn_len
operator|-=
name|len
expr_stmt|;
return|return
operator|(
name|ASN_ERR_BADLEN
operator|)
return|;
block|}
name|subid
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"unterminated subid"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ASN_ERR_EOBUF
operator|)
return|;
block|}
if|if
condition|(
name|subid
operator|>
operator|(
name|ASN_MAXID
operator|>>
literal|7
operator|)
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"OBID subid too larger"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ASN_ERR_RANGE
expr_stmt|;
block|}
name|subid
operator|=
operator|(
name|subid
operator|<<
literal|7
operator|)
operator||
operator|(
operator|*
name|b
operator|->
name|asn_cptr
operator|&
literal|0x7f
operator|)
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|b
operator|->
name|asn_len
operator|--
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|b
operator|->
name|asn_cptr
operator|++
operator|&
literal|0x80
condition|)
do|;
if|if
condition|(
name|oid
operator|->
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|subid
operator|<
literal|80
condition|)
block|{
name|oid
operator|->
name|subs
index|[
name|oid
operator|->
name|len
operator|++
index|]
operator|=
name|subid
operator|/
literal|40
expr_stmt|;
name|oid
operator|->
name|subs
index|[
name|oid
operator|->
name|len
operator|++
index|]
operator|=
name|subid
operator|%
literal|40
expr_stmt|;
block|}
else|else
block|{
name|oid
operator|->
name|subs
index|[
name|oid
operator|->
name|len
operator|++
index|]
operator|=
literal|2
expr_stmt|;
name|oid
operator|->
name|subs
index|[
name|oid
operator|->
name|len
operator|++
index|]
operator|=
name|subid
operator|-
literal|80
expr_stmt|;
block|}
block|}
else|else
block|{
name|oid
operator|->
name|subs
index|[
name|oid
operator|->
name|len
operator|++
index|]
operator|=
name|subid
expr_stmt|;
block|}
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|enum
name|asn_err
name|asn_get_objid
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
name|struct
name|asn_oid
modifier|*
name|oid
parameter_list|)
block|{
name|u_char
name|type
decl_stmt|;
name|asn_len_t
name|len
decl_stmt|;
name|enum
name|asn_err
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|asn_get_header
argument_list|(
name|b
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|!=
name|ASN_ERR_OK
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|type
operator|!=
name|ASN_TYPE_OBJID
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"bad type for OBJID (%u)"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|ASN_ERR_TAG
operator|)
return|;
block|}
return|return
operator|(
name|asn_get_objid_raw
argument_list|(
name|b
argument_list|,
name|len
argument_list|,
name|oid
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|enum
name|asn_err
name|asn_put_objid
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
specifier|const
name|struct
name|asn_oid
modifier|*
name|oid
parameter_list|)
block|{
name|asn_subid_t
name|first
decl_stmt|,
name|sub
decl_stmt|;
name|enum
name|asn_err
name|err
decl_stmt|,
name|err1
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|oidlen
decl_stmt|;
name|asn_len_t
name|len
decl_stmt|;
name|err
operator|=
name|ASN_ERR_OK
expr_stmt|;
if|if
condition|(
name|oid
operator|->
name|len
operator|==
literal|0
condition|)
block|{
comment|/* illegal */
name|asn_error
argument_list|(
name|NULL
argument_list|,
literal|"short oid"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ASN_ERR_RANGE
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
name|oidlen
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oid
operator|->
name|len
operator|==
literal|1
condition|)
block|{
comment|/* illegal */
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"short oid"
argument_list|)
expr_stmt|;
if|if
condition|(
name|oid
operator|->
name|subs
index|[
literal|0
index|]
operator|>
literal|2
condition|)
name|asn_error
argument_list|(
name|NULL
argument_list|,
literal|"oid[0] too large (%u)"
argument_list|,
name|oid
operator|->
name|subs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|err
operator|=
name|ASN_ERR_RANGE
expr_stmt|;
name|first
operator|=
name|oid
operator|->
name|subs
index|[
literal|0
index|]
operator|*
literal|40
expr_stmt|;
name|oidlen
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|oid
operator|->
name|len
operator|>
name|ASN_MAXOIDLEN
condition|)
block|{
name|asn_error
argument_list|(
name|NULL
argument_list|,
literal|"oid too long %u"
argument_list|,
name|oid
operator|->
name|len
argument_list|)
expr_stmt|;
name|err
operator|=
name|ASN_ERR_RANGE
expr_stmt|;
block|}
if|if
condition|(
name|oid
operator|->
name|subs
index|[
literal|0
index|]
operator|>
literal|2
operator|||
operator|(
name|oid
operator|->
name|subs
index|[
literal|0
index|]
operator|<
literal|2
operator|&&
name|oid
operator|->
name|subs
index|[
literal|1
index|]
operator|>=
literal|40
operator|)
condition|)
block|{
name|asn_error
argument_list|(
name|NULL
argument_list|,
literal|"oid out of range (%u,%u)"
argument_list|,
name|oid
operator|->
name|subs
index|[
literal|0
index|]
argument_list|,
name|oid
operator|->
name|subs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|err
operator|=
name|ASN_ERR_RANGE
expr_stmt|;
block|}
name|first
operator|=
literal|40
operator|*
name|oid
operator|->
name|subs
index|[
literal|0
index|]
operator|+
name|oid
operator|->
name|subs
index|[
literal|1
index|]
expr_stmt|;
name|oidlen
operator|=
name|oid
operator|->
name|len
expr_stmt|;
block|}
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|oidlen
condition|;
name|i
operator|++
control|)
block|{
name|sub
operator|=
operator|(
name|i
operator|==
literal|1
operator|)
condition|?
name|first
else|:
name|oid
operator|->
name|subs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sub
operator|>
name|ASN_MAXID
condition|)
block|{
name|asn_error
argument_list|(
name|NULL
argument_list|,
literal|"oid subid too large"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ASN_ERR_RANGE
expr_stmt|;
block|}
name|len
operator|+=
operator|(
name|sub
operator|<=
literal|0x7f
operator|)
condition|?
literal|1
else|:
operator|(
name|sub
operator|<=
literal|0x3fff
operator|)
condition|?
literal|2
else|:
operator|(
name|sub
operator|<=
literal|0x1fffff
operator|)
condition|?
literal|3
else|:
operator|(
name|sub
operator|<=
literal|0xfffffff
operator|)
condition|?
literal|4
else|:
literal|5
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|err1
operator|=
name|asn_put_header
argument_list|(
name|b
argument_list|,
name|ASN_TYPE_OBJID
argument_list|,
name|len
argument_list|)
operator|)
operator|!=
name|ASN_ERR_OK
condition|)
return|return
operator|(
name|err1
operator|)
return|;
if|if
condition|(
name|b
operator|->
name|asn_len
operator|<
name|len
condition|)
return|return
operator|(
name|ASN_ERR_EOBUF
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|oidlen
condition|;
name|i
operator|++
control|)
block|{
name|sub
operator|=
operator|(
name|i
operator|==
literal|1
operator|)
condition|?
name|first
else|:
name|oid
operator|->
name|subs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sub
operator|<=
literal|0x7f
condition|)
block|{
operator|*
name|b
operator|->
name|asn_ptr
operator|++
operator|=
name|sub
expr_stmt|;
name|b
operator|->
name|asn_len
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sub
operator|<=
literal|0x3fff
condition|)
block|{
operator|*
name|b
operator|->
name|asn_ptr
operator|++
operator|=
operator|(
name|sub
operator|>>
literal|7
operator|)
operator||
literal|0x80
expr_stmt|;
operator|*
name|b
operator|->
name|asn_ptr
operator|++
operator|=
name|sub
operator|&
literal|0x7f
expr_stmt|;
name|b
operator|->
name|asn_len
operator|-=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sub
operator|<=
literal|0x1fffff
condition|)
block|{
operator|*
name|b
operator|->
name|asn_ptr
operator|++
operator|=
operator|(
name|sub
operator|>>
literal|14
operator|)
operator||
literal|0x80
expr_stmt|;
operator|*
name|b
operator|->
name|asn_ptr
operator|++
operator|=
operator|(
operator|(
name|sub
operator|>>
literal|7
operator|)
operator|&
literal|0x7f
operator|)
operator||
literal|0x80
expr_stmt|;
operator|*
name|b
operator|->
name|asn_ptr
operator|++
operator|=
name|sub
operator|&
literal|0x7f
expr_stmt|;
name|b
operator|->
name|asn_len
operator|-=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sub
operator|<=
literal|0xfffffff
condition|)
block|{
operator|*
name|b
operator|->
name|asn_ptr
operator|++
operator|=
operator|(
name|sub
operator|>>
literal|21
operator|)
operator||
literal|0x80
expr_stmt|;
operator|*
name|b
operator|->
name|asn_ptr
operator|++
operator|=
operator|(
operator|(
name|sub
operator|>>
literal|14
operator|)
operator|&
literal|0x7f
operator|)
operator||
literal|0x80
expr_stmt|;
operator|*
name|b
operator|->
name|asn_ptr
operator|++
operator|=
operator|(
operator|(
name|sub
operator|>>
literal|7
operator|)
operator|&
literal|0x7f
operator|)
operator||
literal|0x80
expr_stmt|;
operator|*
name|b
operator|->
name|asn_ptr
operator|++
operator|=
name|sub
operator|&
literal|0x7f
expr_stmt|;
name|b
operator|->
name|asn_len
operator|-=
literal|4
expr_stmt|;
block|}
else|else
block|{
operator|*
name|b
operator|->
name|asn_ptr
operator|++
operator|=
operator|(
name|sub
operator|>>
literal|28
operator|)
operator||
literal|0x80
expr_stmt|;
operator|*
name|b
operator|->
name|asn_ptr
operator|++
operator|=
operator|(
operator|(
name|sub
operator|>>
literal|21
operator|)
operator|&
literal|0x7f
operator|)
operator||
literal|0x80
expr_stmt|;
operator|*
name|b
operator|->
name|asn_ptr
operator|++
operator|=
operator|(
operator|(
name|sub
operator|>>
literal|14
operator|)
operator|&
literal|0x7f
operator|)
operator||
literal|0x80
expr_stmt|;
operator|*
name|b
operator|->
name|asn_ptr
operator|++
operator|=
operator|(
operator|(
name|sub
operator|>>
literal|7
operator|)
operator|&
literal|0x7f
operator|)
operator||
literal|0x80
expr_stmt|;
operator|*
name|b
operator|->
name|asn_ptr
operator|++
operator|=
name|sub
operator|&
literal|0x7f
expr_stmt|;
name|b
operator|->
name|asn_len
operator|-=
literal|5
expr_stmt|;
block|}
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SEQUENCE header  *  *<0x10|0x20><len><data...>  */
end_comment

begin_function
name|enum
name|asn_err
name|asn_get_sequence
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
name|asn_len_t
modifier|*
name|len
parameter_list|)
block|{
name|u_char
name|type
decl_stmt|;
name|enum
name|asn_err
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|asn_get_header
argument_list|(
name|b
argument_list|,
operator|&
name|type
argument_list|,
name|len
argument_list|)
operator|)
operator|!=
name|ASN_ERR_OK
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|type
operator|!=
operator|(
name|ASN_TYPE_SEQUENCE
operator||
name|ASN_TYPE_CONSTRUCTED
operator|)
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"bad sequence type %u"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|ASN_ERR_TAG
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|len
operator|>
name|b
operator|->
name|asn_len
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"truncated sequence"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ASN_ERR_EOBUF
operator|)
return|;
block|}
return|return
operator|(
name|ASN_ERR_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Application types  *  * 0x40 4 MSB 2MSB 2LSB LSB  */
end_comment

begin_function
name|enum
name|asn_err
name|asn_get_ipaddress_raw
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
name|asn_len_t
name|len
parameter_list|,
name|u_char
modifier|*
name|addr
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|asn_len
operator|<
name|len
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"truncated ip-address"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ASN_ERR_EOBUF
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|<
literal|4
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"short length for ip-Address %u"
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
operator|*
name|addr
operator|++
operator|=
operator|*
name|b
operator|->
name|asn_cptr
operator|++
expr_stmt|;
while|while
condition|(
name|i
operator|++
operator|<
name|len
condition|)
operator|*
name|addr
operator|++
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|asn_len
operator|-=
name|len
expr_stmt|;
return|return
operator|(
name|ASN_ERR_BADLEN
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|addr
operator|++
operator|=
operator|*
name|b
operator|->
name|asn_cptr
operator|++
expr_stmt|;
name|b
operator|->
name|asn_cptr
operator|+=
name|len
operator|-
literal|4
expr_stmt|;
name|b
operator|->
name|asn_len
operator|-=
name|len
expr_stmt|;
return|return
operator|(
name|ASN_ERR_OK
operator|)
return|;
block|}
end_function

begin_function
name|enum
name|asn_err
name|asn_get_ipaddress
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
name|u_char
modifier|*
name|addr
parameter_list|)
block|{
name|u_char
name|type
decl_stmt|;
name|asn_len_t
name|len
decl_stmt|;
name|enum
name|asn_err
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|asn_get_header
argument_list|(
name|b
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|!=
name|ASN_ERR_OK
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|type
operator|!=
operator|(
name|ASN_CLASS_APPLICATION
operator||
name|ASN_APP_IPADDRESS
operator|)
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"bad type for ip-address %u"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|ASN_ERR_TAG
operator|)
return|;
block|}
return|return
operator|(
name|asn_get_ipaddress_raw
argument_list|(
name|b
argument_list|,
name|len
argument_list|,
name|addr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|enum
name|asn_err
name|asn_put_ipaddress
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
specifier|const
name|u_char
modifier|*
name|addr
parameter_list|)
block|{
name|enum
name|asn_err
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|asn_put_header
argument_list|(
name|b
argument_list|,
name|ASN_CLASS_APPLICATION
operator||
name|ASN_APP_IPADDRESS
argument_list|,
literal|4
argument_list|)
operator|)
operator|!=
name|ASN_ERR_OK
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|b
operator|->
name|asn_len
operator|<
literal|4
condition|)
return|return
operator|(
name|ASN_ERR_EOBUF
operator|)
return|;
name|memcpy
argument_list|(
name|b
operator|->
name|asn_ptr
argument_list|,
name|addr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|b
operator|->
name|asn_ptr
operator|+=
literal|4
expr_stmt|;
name|b
operator|->
name|asn_len
operator|-=
literal|4
expr_stmt|;
return|return
operator|(
name|ASN_ERR_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * UNSIGNED32  *  * 0x42|0x41<len> ...  */
end_comment

begin_function
name|enum
name|asn_err
name|asn_get_uint32_raw
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
name|asn_len_t
name|len
parameter_list|,
name|uint32_t
modifier|*
name|vp
parameter_list|)
block|{
name|uint64_t
name|v
decl_stmt|;
name|enum
name|asn_err
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|asn_get_real_unsigned
argument_list|(
name|b
argument_list|,
name|len
argument_list|,
operator|&
name|v
argument_list|)
operator|)
operator|==
name|ASN_ERR_OK
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|5
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"uint32 too long %u"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|err
operator|=
name|ASN_ERR_BADLEN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|>
name|UINT32_MAX
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"uint32 too large %llu"
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|err
operator|=
name|ASN_ERR_RANGE
expr_stmt|;
block|}
operator|*
name|vp
operator|=
operator|(
name|uint32_t
operator|)
name|v
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|enum
name|asn_err
name|asn_put_uint32
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
name|u_char
name|type
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|uint64_t
name|v
init|=
name|val
decl_stmt|;
return|return
operator|(
name|asn_put_real_unsigned
argument_list|(
name|b
argument_list|,
name|ASN_CLASS_APPLICATION
operator||
name|type
argument_list|,
name|v
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * COUNTER64  * 0x46<len> ...  */
end_comment

begin_function
name|enum
name|asn_err
name|asn_get_counter64_raw
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
name|asn_len_t
name|len
parameter_list|,
name|uint64_t
modifier|*
name|vp
parameter_list|)
block|{
return|return
operator|(
name|asn_get_real_unsigned
argument_list|(
name|b
argument_list|,
name|len
argument_list|,
name|vp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|enum
name|asn_err
name|asn_put_counter64
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
return|return
operator|(
name|asn_put_real_unsigned
argument_list|(
name|b
argument_list|,
name|ASN_CLASS_APPLICATION
operator||
name|ASN_APP_COUNTER64
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * TimeTicks  * 0x43<len> ...  */
end_comment

begin_function
name|enum
name|asn_err
name|asn_get_timeticks
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
name|uint32_t
modifier|*
name|vp
parameter_list|)
block|{
name|asn_len_t
name|len
decl_stmt|;
name|u_char
name|type
decl_stmt|;
name|enum
name|asn_err
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|asn_get_header
argument_list|(
name|b
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|!=
name|ASN_ERR_OK
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|type
operator|!=
operator|(
name|ASN_CLASS_APPLICATION
operator||
name|ASN_APP_TIMETICKS
operator|)
condition|)
block|{
name|asn_error
argument_list|(
name|b
argument_list|,
literal|"bad type for timeticks %u"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|ASN_ERR_TAG
operator|)
return|;
block|}
return|return
operator|(
name|asn_get_uint32_raw
argument_list|(
name|b
argument_list|,
name|len
argument_list|,
name|vp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|enum
name|asn_err
name|asn_put_timeticks
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|uint64_t
name|v
init|=
name|val
decl_stmt|;
return|return
operator|(
name|asn_put_real_unsigned
argument_list|(
name|b
argument_list|,
name|ASN_CLASS_APPLICATION
operator||
name|ASN_APP_TIMETICKS
argument_list|,
name|v
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Construct a new OID by taking a range of sub ids of the original oid.  */
end_comment

begin_function
name|void
name|asn_slice_oid
parameter_list|(
name|struct
name|asn_oid
modifier|*
name|dest
parameter_list|,
specifier|const
name|struct
name|asn_oid
modifier|*
name|src
parameter_list|,
name|u_int
name|from
parameter_list|,
name|u_int
name|to
parameter_list|)
block|{
if|if
condition|(
name|from
operator|>=
name|to
condition|)
block|{
name|dest
operator|->
name|len
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|dest
operator|->
name|len
operator|=
name|to
operator|-
name|from
expr_stmt|;
name|memcpy
argument_list|(
name|dest
operator|->
name|subs
argument_list|,
operator|&
name|src
operator|->
name|subs
index|[
name|from
index|]
argument_list|,
name|dest
operator|->
name|len
operator|*
sizeof|sizeof
argument_list|(
name|dest
operator|->
name|subs
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Append from to to  */
end_comment

begin_function
name|void
name|asn_append_oid
parameter_list|(
name|struct
name|asn_oid
modifier|*
name|to
parameter_list|,
specifier|const
name|struct
name|asn_oid
modifier|*
name|from
parameter_list|)
block|{
name|memcpy
argument_list|(
operator|&
name|to
operator|->
name|subs
index|[
name|to
operator|->
name|len
index|]
argument_list|,
operator|&
name|from
operator|->
name|subs
index|[
literal|0
index|]
argument_list|,
name|from
operator|->
name|len
operator|*
sizeof|sizeof
argument_list|(
name|from
operator|->
name|subs
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|->
name|len
operator|+=
name|from
operator|->
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Skip a value  */
end_comment

begin_function
name|enum
name|asn_err
name|asn_skip
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
name|asn_len_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|b
operator|->
name|asn_len
operator|<
name|len
condition|)
return|return
operator|(
name|ASN_ERR_EOBUF
operator|)
return|;
name|b
operator|->
name|asn_cptr
operator|+=
name|len
expr_stmt|;
name|b
operator|->
name|asn_len
operator|-=
name|len
expr_stmt|;
return|return
operator|(
name|ASN_ERR_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a padding  */
end_comment

begin_function
name|enum
name|asn_err
name|asn_pad
parameter_list|(
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
name|asn_len_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|b
operator|->
name|asn_len
operator|<
name|len
condition|)
return|return
operator|(
name|ASN_ERR_EOBUF
operator|)
return|;
name|b
operator|->
name|asn_ptr
operator|+=
name|len
expr_stmt|;
name|b
operator|->
name|asn_len
operator|-=
name|len
expr_stmt|;
return|return
operator|(
name|ASN_ERR_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compare two OIDs.  *  * o1< o2 : -1  * o1> o2 : +1  * o1 = o2 :  0  */
end_comment

begin_function
name|int
name|asn_compare_oid
parameter_list|(
specifier|const
name|struct
name|asn_oid
modifier|*
name|o1
parameter_list|,
specifier|const
name|struct
name|asn_oid
modifier|*
name|o2
parameter_list|)
block|{
name|u_long
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|o1
operator|->
name|len
operator|&&
name|i
operator|<
name|o2
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|o1
operator|->
name|subs
index|[
name|i
index|]
operator|<
name|o2
operator|->
name|subs
index|[
name|i
index|]
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|o1
operator|->
name|subs
index|[
name|i
index|]
operator|>
name|o2
operator|->
name|subs
index|[
name|i
index|]
condition|)
return|return
operator|(
operator|+
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|o1
operator|->
name|len
operator|<
name|o2
operator|->
name|len
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|o1
operator|->
name|len
operator|>
name|o2
operator|->
name|len
condition|)
return|return
operator|(
operator|+
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check whether an OID is a sub-string of another OID.  */
end_comment

begin_function
name|int
name|asn_is_suboid
parameter_list|(
specifier|const
name|struct
name|asn_oid
modifier|*
name|o1
parameter_list|,
specifier|const
name|struct
name|asn_oid
modifier|*
name|o2
parameter_list|)
block|{
name|u_long
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|o1
operator|->
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|>=
name|o2
operator|->
name|len
operator|||
name|o1
operator|->
name|subs
index|[
name|i
index|]
operator|!=
name|o2
operator|->
name|subs
index|[
name|i
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Put a string representation of an oid into a user buffer. This buffer  * is assumed to be at least ASN_OIDSTRLEN characters long.  *  * sprintf is assumed not to fail here.  */
end_comment

begin_function
name|char
modifier|*
name|asn_oid2str_r
parameter_list|(
specifier|const
name|struct
name|asn_oid
modifier|*
name|oid
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|u_int
name|len
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|oid
operator|->
name|len
operator|)
operator|>
name|ASN_MAXOIDLEN
condition|)
name|len
operator|=
name|ASN_MAXOIDLEN
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ptr
operator|=
name|buf
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
operator|*
name|ptr
operator|++
operator|=
literal|'.'
expr_stmt|;
name|ptr
operator|+=
name|sprintf
argument_list|(
name|ptr
argument_list|,
literal|"%u"
argument_list|,
name|oid
operator|->
name|subs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make a string from an OID in a private buffer.  */
end_comment

begin_function
name|char
modifier|*
name|asn_oid2str
parameter_list|(
specifier|const
name|struct
name|asn_oid
modifier|*
name|oid
parameter_list|)
block|{
specifier|static
name|char
name|str
index|[
name|ASN_OIDSTRLEN
index|]
decl_stmt|;
return|return
operator|(
name|asn_oid2str_r
argument_list|(
name|oid
argument_list|,
name|str
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|asn_error_func
parameter_list|(
specifier|const
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|err
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|u_long
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ASN.1: "
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|err
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" at"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|b
operator|->
name|asn_len
operator|>
name|i
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %02x"
argument_list|,
name|b
operator|->
name|asn_cptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

