begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2001-2003  *	Fraunhofer Institute for Open Communication Systems (FhG Fokus).  *	All rights reserved.  *  * Author: Harti Brandt<harti@freebsd.org>  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *   * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Begemot: bsnmp/snmpd/config.c,v 1.25 2006/02/14 09:04:20 brandt_h Exp $  *  * Parse configuration file.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|"snmpmod.h"
end_include

begin_include
include|#
directive|include
file|"snmpd.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_comment
comment|/* #define DEBUGGING */
end_comment

begin_comment
comment|/*  * config_file: EMPTY | config_file line  *  * line: oid '=' value  *     | '%' STRING  *     | STRING := REST_OF_LINE  *     | STRING ?= REST_OF_LINE  *     | . INCLUDE STRING  *  * oid: STRING suboid  *  * suboid: EMPTY | suboid '.' subid  *  * subid: NUM | STRING | '[' STRING ']'  *  * value: EMPTY | STRING | NUM  */
end_comment

begin_comment
comment|/*  * Input context for macros and includes  */
end_comment

begin_enum
enum|enum
name|input_type
block|{
name|INPUT_FILE
init|=
literal|1
block|,
name|INPUT_STRING
block|}
enum|;
end_enum

begin_struct
struct|struct
name|input
block|{
name|enum
name|input_type
name|type
decl_stmt|;
union|union
block|{
struct|struct
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|u_int
name|lno
decl_stmt|;
block|}
name|file
struct|;
struct|struct
block|{
name|char
modifier|*
name|macro
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|size_t
name|left
decl_stmt|;
block|}
name|str
struct|;
block|}
name|u
union|;
name|LIST_ENTRY
argument_list|(
argument|input
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|input
argument_list|)
name|inputs
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|input_fp
value|u.file.fp
end_define

begin_define
define|#
directive|define
name|input_filename
value|u.file.filename
end_define

begin_define
define|#
directive|define
name|input_lno
value|u.file.lno
end_define

begin_define
define|#
directive|define
name|input_macro
value|u.str.macro
end_define

begin_define
define|#
directive|define
name|input_str
value|u.str.str
end_define

begin_define
define|#
directive|define
name|input_ptr
value|u.str.ptr
end_define

begin_define
define|#
directive|define
name|input_left
value|u.str.left
end_define

begin_decl_stmt
specifier|static
name|int
name|input_push
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|input_buf
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Configuration data. The configuration file is handled as one single  * SNMP transaction. So we need to keep the assignment data for the  * commit or rollback pass. Note, that dependencies and finish functions  * are NOT allowed here.  */
end_comment

begin_struct
struct|struct
name|assign
block|{
name|struct
name|snmp_value
name|value
decl_stmt|;
name|struct
name|snmp_scratch
name|scratch
decl_stmt|;
specifier|const
name|char
modifier|*
name|node_name
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|assign
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument|assigns
argument_list|,
argument|assign
argument_list|)
name|assigns
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|assigns
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|snmp_context
modifier|*
name|snmp_ctx
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|macro
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|size_t
name|length
decl_stmt|;
name|LIST_ENTRY
argument_list|(
argument|macro
argument_list|)
name|link
expr_stmt|;
name|int
name|perm
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|macro
argument_list|)
name|macros
operator|=
name|LIST_HEAD_INITIALIZER
argument_list|(
operator|&
name|macros
argument_list|)
expr_stmt|;
end_expr_stmt

begin_enum
enum|enum
block|{
name|TOK_EOF
init|=
literal|0200
block|,
name|TOK_EOL
block|,
name|TOK_NUM
block|,
name|TOK_STR
block|,
name|TOK_HOST
block|,
name|TOK_ASSIGN
block|,
name|TOK_QASSIGN
block|, }
enum|;
end_enum

begin_comment
comment|/* lexer values and last token */
end_comment

begin_decl_stmt
specifier|static
name|uint64_t
name|numval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|strval
index|[
name|_POSIX2_LINE_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|strvallen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|token
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* error return */
end_comment

begin_decl_stmt
specifier|static
name|jmp_buf
name|errjmp
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|errstk
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ERRPUSH
parameter_list|()
value|(setjmp(errjmp[errstk++]))
end_define

begin_define
define|#
directive|define
name|ERRPOP
parameter_list|()
value|((void)(errstk--))
end_define

begin_define
define|#
directive|define
name|ERRNEXT
parameter_list|()
value|(longjmp(errjmp[--errstk], 1))
end_define

begin_define
define|#
directive|define
name|ERR
parameter_list|()
value|(longjmp(errjmp[--errstk], 1))
end_define

begin_comment
comment|/* section context */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ignore
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Report an error and jump to the error label  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|report
argument_list|(
specifier|const
name|char
operator|*
name|fmt
argument_list|,
operator|...
argument_list|)
name|__dead2
name|__printflike
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|report
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
specifier|const
name|struct
name|input
modifier|*
name|input
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsyslog
argument_list|(
name|LOG_ERR
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|input
argument_list|,
argument|&inputs
argument_list|,
argument|link
argument_list|)
block|{
switch|switch
condition|(
name|input
operator|->
name|type
condition|)
block|{
case|case
name|INPUT_FILE
case|:
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"  in file %s line %u"
argument_list|,
name|input
operator|->
name|input_filename
argument_list|,
name|input
operator|->
name|input_lno
argument_list|)
expr_stmt|;
break|break;
case|case
name|INPUT_STRING
case|:
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"  in macro %s pos %td"
argument_list|,
name|input
operator|->
name|input_macro
argument_list|,
name|input
operator|->
name|input_ptr
operator|-
name|input
operator|->
name|input_str
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|ERR
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Open a file for input  */
end_comment

begin_function
specifier|static
name|int
name|input_open_file
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|int
name|sysdir
parameter_list|)
block|{
name|struct
name|input
modifier|*
name|input
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|path
index|[
name|PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|col
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|sysdir
condition|)
block|{
name|ptr
operator|=
name|syspath
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
name|col
operator|=
name|strchr
argument_list|(
name|ptr
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|ptr
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|col
operator|=
name|ptr
operator|+
name|strlen
argument_list|(
name|ptr
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|col
operator|==
name|ptr
condition|)
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"./%s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"%.*s/%s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|col
operator|-
name|ptr
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|path
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
break|break;
name|ptr
operator|=
name|col
operator|+
literal|1
expr_stmt|;
block|}
block|}
else|else
name|fp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|report
argument_list|(
literal|"%s: %m"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|input
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|input
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|input
operator|->
name|input_filename
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|fname
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|input
operator|->
name|input_filename
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|input
operator|->
name|input_fp
operator|=
name|fp
expr_stmt|;
name|input
operator|->
name|input_lno
operator|=
literal|1
expr_stmt|;
name|input
operator|->
name|type
operator|=
name|INPUT_FILE
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|inputs
argument_list|,
name|input
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make a macro the next input  */
end_comment

begin_function
specifier|static
name|void
name|input_open_macro
parameter_list|(
name|struct
name|macro
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|input
modifier|*
name|input
decl_stmt|;
if|if
condition|(
operator|(
name|input
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|input
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|report
argument_list|(
literal|"%m"
argument_list|)
expr_stmt|;
name|input
operator|->
name|type
operator|=
name|INPUT_STRING
expr_stmt|;
name|input
operator|->
name|input_macro
operator|=
name|m
operator|->
name|name
expr_stmt|;
if|if
condition|(
operator|(
name|input
operator|->
name|input_str
operator|=
name|malloc
argument_list|(
name|m
operator|->
name|length
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|report
argument_list|(
literal|"%m"
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|input
operator|->
name|input_str
argument_list|,
name|m
operator|->
name|value
argument_list|,
name|m
operator|->
name|length
argument_list|)
expr_stmt|;
name|input
operator|->
name|input_ptr
operator|=
name|input
operator|->
name|input_str
expr_stmt|;
name|input
operator|->
name|input_left
operator|=
name|m
operator|->
name|length
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|inputs
argument_list|,
name|input
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Close top input source  */
end_comment

begin_function
specifier|static
name|void
name|input_close
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|input
modifier|*
name|input
decl_stmt|;
if|if
condition|(
operator|(
name|input
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inputs
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|input
operator|->
name|type
condition|)
block|{
case|case
name|INPUT_FILE
case|:
name|fclose
argument_list|(
name|input
operator|->
name|input_fp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input
operator|->
name|input_filename
argument_list|)
expr_stmt|;
break|break;
case|case
name|INPUT_STRING
case|:
name|free
argument_list|(
name|input
operator|->
name|input_str
argument_list|)
expr_stmt|;
break|break;
block|}
name|LIST_REMOVE
argument_list|(
name|input
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Close all inputs  */
end_comment

begin_function
specifier|static
name|void
name|input_close_all
parameter_list|(
name|void
parameter_list|)
block|{
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|inputs
argument_list|)
condition|)
name|input_close
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Push back one character  */
end_comment

begin_function
specifier|static
name|void
name|input_ungetc
parameter_list|(
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|report
argument_list|(
literal|"pushing EOF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_push
operator|==
literal|2
condition|)
name|report
argument_list|(
literal|"pushing third char"
argument_list|)
expr_stmt|;
name|input_buf
index|[
name|input_push
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return next character from the input without preprocessing.  */
end_comment

begin_function
specifier|static
name|int
name|input_getc_raw
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|struct
name|input
modifier|*
name|input
decl_stmt|;
if|if
condition|(
name|input_push
operator|!=
literal|0
condition|)
block|{
name|c
operator|=
name|input_buf
index|[
operator|--
name|input_push
index|]
expr_stmt|;
goto|goto
name|ok
goto|;
block|}
while|while
condition|(
operator|(
name|input
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inputs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|input
operator|->
name|type
condition|)
block|{
case|case
name|INPUT_FILE
case|:
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|input
operator|->
name|input_fp
argument_list|)
operator|)
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|input
operator|->
name|input_fp
argument_list|)
condition|)
name|report
argument_list|(
literal|"read error: %m"
argument_list|)
expr_stmt|;
name|input_close
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|input
operator|->
name|input_lno
operator|++
expr_stmt|;
goto|goto
name|ok
goto|;
case|case
name|INPUT_STRING
case|:
if|if
condition|(
name|input
operator|->
name|input_left
operator|--
operator|==
literal|0
condition|)
block|{
name|input_close
argument_list|()
expr_stmt|;
break|break;
block|}
name|c
operator|=
operator|*
name|input
operator|->
name|input_ptr
operator|++
expr_stmt|;
goto|goto
name|ok
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUGGING
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"EOF"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EOF
operator|)
return|;
name|ok
label|:
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
operator|!
name|isascii
argument_list|(
name|c
argument_list|)
operator|||
operator|!
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"'%#2x'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"'%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get character with and \\n -> processing.  */
end_comment

begin_function
specifier|static
name|int
name|input_getc_plain
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|again
label|:
if|if
condition|(
operator|(
name|c
operator|=
name|input_getc_raw
argument_list|()
operator|)
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|input_getc_raw
argument_list|()
operator|)
operator|==
literal|'\n'
condition|)
goto|goto
name|again
goto|;
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
name|input_ungetc
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
literal|'\\'
operator|)
return|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get next character with substitution of macros  */
end_comment

begin_function
specifier|static
name|int
name|input_getc
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|struct
name|macro
modifier|*
name|m
decl_stmt|;
name|char
name|name
index|[
name|_POSIX2_LINE_MAX
index|]
decl_stmt|;
name|size_t
name|namelen
decl_stmt|;
name|again
label|:
if|if
condition|(
operator|(
name|c
operator|=
name|input_getc_plain
argument_list|()
operator|)
operator|!=
literal|'$'
condition|)
return|return
operator|(
name|c
operator|)
return|;
if|if
condition|(
operator|(
name|c
operator|=
name|input_getc
argument_list|()
operator|)
operator|==
name|EOF
condition|)
name|report
argument_list|(
literal|"unexpected EOF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'('
condition|)
name|report
argument_list|(
literal|"expecting '(' after '$'"
argument_list|)
expr_stmt|;
name|namelen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|input_getc
argument_list|()
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|')'
condition|)
block|{
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
operator|(
name|namelen
operator|!=
literal|0
operator|&&
name|isdigit
argument_list|(
name|c
argument_list|)
operator|)
condition|)
name|name
index|[
name|namelen
operator|++
index|]
operator|=
name|c
expr_stmt|;
else|else
goto|goto
name|badchar
goto|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|report
argument_list|(
literal|"unexpected EOF"
argument_list|)
expr_stmt|;
name|name
index|[
name|namelen
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|m
argument_list|,
argument|&macros
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|m
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|report
argument_list|(
literal|"undefined macro '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|input_open_macro
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
name|badchar
label|:
if|if
condition|(
operator|!
name|isascii
argument_list|(
name|c
argument_list|)
operator|||
operator|!
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
name|report
argument_list|(
literal|"unexpected character %#2x"
argument_list|,
operator|(
name|u_int
operator|)
name|c
argument_list|)
expr_stmt|;
else|else
name|report
argument_list|(
literal|"bad character '%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|input_getnum
parameter_list|(
name|u_int
name|base
parameter_list|,
name|u_int
name|flen
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|u_int
name|cnt
decl_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
name|numval
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|flen
operator|==
literal|0
operator|||
name|cnt
operator|<
name|flen
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|input_getc
argument_list|()
operator|)
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
name|report
argument_list|(
literal|"bad number"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|base
operator|==
literal|8
operator|&&
operator|(
name|c
operator|==
literal|'8'
operator|||
name|c
operator|==
literal|'9'
operator|)
condition|)
block|{
name|input_ungetc
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
name|report
argument_list|(
literal|"bad number"
argument_list|)
expr_stmt|;
return|return;
block|}
name|numval
operator|=
name|numval
operator|*
name|base
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|base
operator|==
literal|16
operator|&&
name|isxdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|islower
argument_list|(
name|c
argument_list|)
condition|)
name|numval
operator|=
name|numval
operator|*
name|base
operator|+
operator|(
name|c
operator|-
literal|'a'
operator|+
literal|10
operator|)
expr_stmt|;
else|else
name|numval
operator|=
name|numval
operator|*
name|base
operator|+
operator|(
name|c
operator|-
literal|'A'
operator|+
literal|10
operator|)
expr_stmt|;
block|}
else|else
block|{
name|input_ungetc
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
name|report
argument_list|(
literal|"bad number"
argument_list|)
expr_stmt|;
return|return;
block|}
name|cnt
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|DEBUGGING
name|_gettoken
parameter_list|(
name|void
parameter_list|)
else|#
directive|else
function|gettoken
parameter_list|(
name|void
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
specifier|static
specifier|const
name|char
name|esc
index|[]
init|=
literal|"abfnrtv"
decl_stmt|;
specifier|static
specifier|const
name|char
name|chr
index|[]
init|=
literal|"\a\b\f\n\r\t\v"
decl_stmt|;
comment|/* 	 * Skip any whitespace before the next token 	 */
while|while
condition|(
operator|(
name|c
operator|=
name|input_getc
argument_list|()
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'\n'
condition|)
break|break;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
operator|(
name|token
operator|=
name|TOK_EOF
operator|)
return|;
if|if
condition|(
operator|!
name|isascii
argument_list|(
name|c
argument_list|)
condition|)
goto|goto
name|badchar
goto|;
comment|/* 	 * Skip comments 	 */
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|input_getc_plain
argument_list|()
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
operator|(
name|token
operator|=
name|TOK_EOL
operator|)
return|;
block|}
goto|goto
name|badeof
goto|;
block|}
comment|/* 	 * Single character tokens 	 */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
operator|(
name|token
operator|=
name|TOK_EOL
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'%'
operator|||
name|c
operator|==
literal|'='
operator|||
name|c
operator|==
literal|'<'
operator|||
name|c
operator|==
literal|'>'
condition|)
return|return
operator|(
name|token
operator|=
name|c
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|input_getc
argument_list|()
operator|)
operator|==
literal|'='
condition|)
return|return
operator|(
name|token
operator|=
name|TOK_ASSIGN
operator|)
return|;
name|input_ungetc
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|token
operator|=
literal|':'
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'?'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|input_getc
argument_list|()
operator|)
operator|==
literal|'='
condition|)
return|return
operator|(
name|token
operator|=
name|TOK_QASSIGN
operator|)
return|;
name|input_ungetc
argument_list|(
name|c
argument_list|)
expr_stmt|;
goto|goto
name|badchar
goto|;
block|}
comment|/* 	 * Sort out numbers 	 */
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|input_getc
argument_list|()
operator|)
operator|==
literal|'x'
operator|||
name|c
operator|==
literal|'X'
condition|)
block|{
name|input_getnum
argument_list|(
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|input_ungetc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|input_getnum
argument_list|(
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
name|input_ungetc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|numval
operator|=
literal|0
expr_stmt|;
name|c
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|input_ungetc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|input_getnum
argument_list|(
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|token
operator|=
name|TOK_NUM
operator|)
return|;
block|}
comment|/* 	 * Must be a string then 	 */
name|strvallen
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|GETC
parameter_list|(
name|C
parameter_list|)
value|do {							\ 	if ((c = input_getc()) == EOF)					\ 		goto badeof;						\ 	if (!isascii(c) || (!isprint(c)&& c != '\t')) 			\ 		goto badchar;						\ } while(0)
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|GETC
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|strval
index|[
name|strvallen
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|!=
literal|'\\'
condition|)
block|{
name|strval
index|[
name|strvallen
operator|++
index|]
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
name|GETC
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|end
operator|=
name|strchr
argument_list|(
name|esc
argument_list|,
name|c
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strval
index|[
name|strvallen
operator|++
index|]
operator|=
name|chr
index|[
name|end
operator|-
name|esc
index|]
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'x'
condition|)
block|{
name|input_getnum
argument_list|(
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|c
operator|=
name|numval
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'7'
condition|)
block|{
name|input_ungetc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|input_getnum
argument_list|(
literal|8
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|c
operator|=
name|numval
expr_stmt|;
block|}
name|strval
index|[
name|strvallen
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
undef|#
directive|undef
name|GETC
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'['
condition|)
block|{
comment|/* 		 * Skip leading space 		 */
while|while
condition|(
operator|(
name|c
operator|=
name|input_getc
argument_list|()
operator|)
operator|!=
name|EOF
operator|&&
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
goto|goto
name|badeof
goto|;
while|while
condition|(
name|c
operator|!=
literal|']'
operator|&&
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'.'
operator|&&
name|c
operator|!=
literal|'-'
condition|)
goto|goto
name|badchar
goto|;
name|strval
index|[
name|strvallen
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|input_getc
argument_list|()
operator|)
operator|==
name|EOF
condition|)
goto|goto
name|badeof
goto|;
block|}
while|while
condition|(
name|c
operator|!=
literal|']'
operator|&&
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|input_getc
argument_list|()
operator|)
operator|==
name|EOF
condition|)
goto|goto
name|badeof
goto|;
block|}
if|if
condition|(
name|c
operator|!=
literal|']'
condition|)
goto|goto
name|badchar
goto|;
name|strval
index|[
name|strvallen
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|token
operator|=
name|TOK_HOST
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isalpha
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'_'
condition|)
block|{
goto|goto
name|badchar
goto|;
block|}
else|else
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|strval
index|[
name|strvallen
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|input_getc
argument_list|()
operator|)
operator|==
name|EOF
condition|)
goto|goto
name|badeof
goto|;
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'_'
operator|&&
name|c
operator|!=
literal|'-'
condition|)
block|{
name|input_ungetc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|strval
index|[
name|strvallen
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
operator|(
name|token
operator|=
name|TOK_STR
operator|)
return|;
name|badeof
label|:
name|report
argument_list|(
literal|"unexpected EOF"
argument_list|)
expr_stmt|;
name|badchar
label|:
if|if
condition|(
operator|!
name|isascii
argument_list|(
name|c
argument_list|)
operator|||
operator|!
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
name|report
argument_list|(
literal|"unexpected character %#2x"
argument_list|,
operator|(
name|u_int
operator|)
name|c
argument_list|)
expr_stmt|;
else|else
name|report
argument_list|(
literal|"bad character '%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGGING
end_ifdef

begin_function
specifier|static
name|int
name|gettoken
parameter_list|()
block|{
name|_gettoken
argument_list|()
expr_stmt|;
if|if
condition|(
name|isascii
argument_list|(
name|token
argument_list|)
operator|&&
name|isprint
argument_list|(
name|token
argument_list|)
condition|)
name|printf
argument_list|(
literal|"(%c)"
argument_list|,
name|token
argument_list|)
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|TOK_EOF
case|:
name|printf
argument_list|(
literal|"(EOF)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_EOL
case|:
name|printf
argument_list|(
literal|"(EOL)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_NUM
case|:
name|printf
argument_list|(
literal|"(NUM %llu)"
argument_list|,
name|numval
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_STR
case|:
name|printf
argument_list|(
literal|"(STR %.*s)"
argument_list|,
operator|(
name|int
operator|)
name|strvallen
argument_list|,
name|strval
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_HOST
case|:
name|printf
argument_list|(
literal|"(HOST %s)"
argument_list|,
name|strval
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"(%#2x)"
argument_list|,
name|token
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|token
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Try to execute the assignment.  */
end_comment

begin_function
specifier|static
name|void
name|handle_assignment
parameter_list|(
specifier|const
name|struct
name|snmp_node
modifier|*
name|node
parameter_list|,
name|struct
name|asn_oid
modifier|*
name|vindex
parameter_list|,
specifier|const
name|struct
name|snmp_value
modifier|*
name|value
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|assign
modifier|*
name|tp
decl_stmt|;
name|char
name|nodename
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|type
operator|==
name|SNMP_NODE_LEAF
condition|)
block|{
comment|/* index must be one single zero or no index at all */
if|if
condition|(
name|vindex
operator|->
name|len
operator|>
literal|1
operator|||
operator|(
name|vindex
operator|->
name|len
operator|==
literal|1
operator|&&
name|vindex
operator|->
name|subs
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
condition|)
name|report
argument_list|(
literal|"bad index on leaf node"
argument_list|)
expr_stmt|;
name|vindex
operator|->
name|len
operator|=
literal|1
expr_stmt|;
name|vindex
operator|->
name|subs
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* resulting oid must not be too long */
if|if
condition|(
name|node
operator|->
name|oid
operator|.
name|len
operator|+
name|vindex
operator|->
name|len
operator|>
name|ASN_MAXOIDLEN
condition|)
name|report
argument_list|(
literal|"resulting OID too long"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Get the next assignment entry for the transaction. 	 */
if|if
condition|(
operator|(
name|tp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|report
argument_list|(
literal|"%m"
argument_list|)
expr_stmt|;
name|tp
operator|->
name|value
operator|=
operator|*
name|value
expr_stmt|;
name|tp
operator|->
name|node_name
operator|=
name|node
operator|->
name|name
expr_stmt|;
comment|/* 	 * Build the OID 	 */
name|tp
operator|->
name|value
operator|.
name|var
operator|=
name|node
operator|->
name|oid
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vindex
operator|->
name|len
condition|;
name|i
operator|++
control|)
name|tp
operator|->
name|value
operator|.
name|var
operator|.
name|subs
index|[
name|tp
operator|->
name|value
operator|.
name|var
operator|.
name|len
operator|++
index|]
operator|=
name|vindex
operator|->
name|subs
index|[
name|i
index|]
expr_stmt|;
comment|/* 	 * Puzzle together the variables for the call and call the 	 * set routine. The set routine may make our node pointer 	 * invalid (if we happend to call the module loader) so 	 * get a copy of the node name beforehands. 	 */
name|snprintf
argument_list|(
name|nodename
argument_list|,
sizeof|sizeof
argument_list|(
name|nodename
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
name|snmp_ctx
operator|->
name|scratch
operator|=
operator|&
name|tp
operator|->
name|scratch
expr_stmt|;
name|snmp_ctx
operator|->
name|var_index
operator|=
literal|0
expr_stmt|;
name|err
operator|=
call|(
modifier|*
name|node
operator|->
name|op
call|)
argument_list|(
name|snmp_ctx
argument_list|,
operator|&
name|tp
operator|->
name|value
argument_list|,
name|node
operator|->
name|oid
operator|.
name|len
argument_list|,
name|node
operator|->
name|index
argument_list|,
name|SNMP_OP_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|report
argument_list|(
literal|"assignment to %s.%s returns %d"
argument_list|,
name|nodename
argument_list|,
name|asn_oid2str
argument_list|(
name|vindex
argument_list|)
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|assigns
argument_list|,
name|tp
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse the section statement  */
end_comment

begin_function
specifier|static
name|void
name|parse_section
parameter_list|(
specifier|const
name|struct
name|lmodule
modifier|*
name|mod
parameter_list|)
block|{
if|if
condition|(
name|token
operator|!=
name|TOK_STR
condition|)
name|report
argument_list|(
literal|"expecting section name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|strval
argument_list|,
literal|"snmpd"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mod
operator|!=
name|NULL
condition|)
comment|/* loading a module - ignore common stuff */
name|ignore
operator|=
literal|1
expr_stmt|;
else|else
comment|/* global configuration - don't ignore */
name|ignore
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mod
operator|==
name|NULL
condition|)
block|{
comment|/* global configuration - ignore module stuff */
name|ignore
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* loading module - check if it's our section */
name|ignore
operator|=
operator|(
name|strcmp
argument_list|(
name|strval
argument_list|,
name|mod
operator|->
name|section
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
block|}
name|gettoken
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Convert a hostname to four u_chars  */
end_comment

begin_function
specifier|static
name|void
name|gethost
parameter_list|(
specifier|const
name|char
modifier|*
name|host
parameter_list|,
name|u_char
modifier|*
name|ip
parameter_list|)
block|{
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|res
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sain
decl_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|AF_INET
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_DGRAM
expr_stmt|;
name|hints
operator|.
name|ai_protocol
operator|=
name|IPPROTO_UDP
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|AI_PASSIVE
expr_stmt|;
name|error
operator|=
name|getaddrinfo
argument_list|(
name|host
argument_list|,
name|NULL
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|report
argument_list|(
literal|"%s: %s"
argument_list|,
name|host
argument_list|,
name|gai_strerror
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
name|report
argument_list|(
literal|"%s: unknown hostname"
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|sain
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|res
operator|->
name|ai_addr
expr_stmt|;
name|sain
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|ntohl
argument_list|(
name|sain
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|ip
index|[
literal|0
index|]
operator|=
name|sain
operator|->
name|sin_addr
operator|.
name|s_addr
operator|>>
literal|24
expr_stmt|;
name|ip
index|[
literal|1
index|]
operator|=
name|sain
operator|->
name|sin_addr
operator|.
name|s_addr
operator|>>
literal|16
expr_stmt|;
name|ip
index|[
literal|2
index|]
operator|=
name|sain
operator|->
name|sin_addr
operator|.
name|s_addr
operator|>>
literal|8
expr_stmt|;
name|ip
index|[
literal|3
index|]
operator|=
name|sain
operator|->
name|sin_addr
operator|.
name|s_addr
operator|>>
literal|0
expr_stmt|;
name|freeaddrinfo
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse the left hand side of a config line.  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|snmp_node
modifier|*
name|parse_oid
parameter_list|(
specifier|const
name|char
modifier|*
name|varname
parameter_list|,
name|struct
name|asn_oid
modifier|*
name|oid
parameter_list|)
block|{
name|struct
name|snmp_node
modifier|*
name|node
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|u_char
name|ip
index|[
literal|4
index|]
decl_stmt|;
for|for
control|(
name|node
operator|=
name|tree
init|;
name|node
operator|<
operator|&
name|tree
index|[
name|tree_size
index|]
condition|;
name|node
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|varname
argument_list|,
name|node
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|node
operator|==
operator|&
name|tree
index|[
name|tree_size
index|]
condition|)
name|node
operator|=
name|NULL
expr_stmt|;
name|oid
operator|->
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|token
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|gettoken
argument_list|()
operator|==
name|TOK_NUM
condition|)
block|{
if|if
condition|(
name|numval
operator|>
name|ASN_MAXID
condition|)
name|report
argument_list|(
literal|"subid too large %#"
name|QUADXFMT
argument_list|,
name|numval
argument_list|)
expr_stmt|;
if|if
condition|(
name|oid
operator|->
name|len
operator|==
name|ASN_MAXOIDLEN
condition|)
name|report
argument_list|(
literal|"index too long"
argument_list|)
expr_stmt|;
name|oid
operator|->
name|subs
index|[
name|oid
operator|->
name|len
operator|++
index|]
operator|=
name|numval
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|TOK_STR
condition|)
block|{
if|if
condition|(
name|strvallen
operator|+
name|oid
operator|->
name|len
operator|+
literal|1
operator|>
name|ASN_MAXOIDLEN
condition|)
name|report
argument_list|(
literal|"oid too long"
argument_list|)
expr_stmt|;
name|oid
operator|->
name|subs
index|[
name|oid
operator|->
name|len
operator|++
index|]
operator|=
name|strvallen
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strvallen
condition|;
name|i
operator|++
control|)
name|oid
operator|->
name|subs
index|[
name|oid
operator|->
name|len
operator|++
index|]
operator|=
name|strval
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|TOK_HOST
condition|)
block|{
name|gethost
argument_list|(
name|strval
argument_list|,
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|oid
operator|->
name|len
operator|+
literal|4
operator|>
name|ASN_MAXOIDLEN
condition|)
name|report
argument_list|(
literal|"index too long"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|oid
operator|->
name|subs
index|[
name|oid
operator|->
name|len
operator|++
index|]
operator|=
name|ip
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
name|report
argument_list|(
literal|"bad token in index"
argument_list|)
expr_stmt|;
name|gettoken
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|node
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse the value for an assignment.  */
end_comment

begin_function
specifier|static
name|void
name|parse_syntax_null
parameter_list|(
name|struct
name|snmp_value
modifier|*
name|value
name|__unused
parameter_list|)
block|{
if|if
condition|(
name|token
operator|!=
name|TOK_EOL
condition|)
name|report
argument_list|(
literal|"bad NULL syntax"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_syntax_integer
parameter_list|(
name|struct
name|snmp_value
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
name|token
operator|!=
name|TOK_NUM
condition|)
name|report
argument_list|(
literal|"bad INTEGER syntax"
argument_list|)
expr_stmt|;
if|if
condition|(
name|numval
operator|>
literal|0x7fffffff
condition|)
name|report
argument_list|(
literal|"INTEGER too large %"
name|QUADFMT
argument_list|,
name|numval
argument_list|)
expr_stmt|;
name|value
operator|->
name|v
operator|.
name|integer
operator|=
name|numval
expr_stmt|;
name|gettoken
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_syntax_counter64
parameter_list|(
name|struct
name|snmp_value
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
name|token
operator|!=
name|TOK_NUM
condition|)
name|report
argument_list|(
literal|"bad COUNTER64 syntax"
argument_list|)
expr_stmt|;
name|value
operator|->
name|v
operator|.
name|counter64
operator|=
name|numval
expr_stmt|;
name|gettoken
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_syntax_octetstring
parameter_list|(
name|struct
name|snmp_value
modifier|*
name|value
parameter_list|)
block|{
name|u_long
name|alloc
decl_stmt|;
name|u_char
modifier|*
name|noct
decl_stmt|;
if|if
condition|(
name|token
operator|==
name|TOK_STR
condition|)
block|{
name|value
operator|->
name|v
operator|.
name|octetstring
operator|.
name|len
operator|=
name|strvallen
expr_stmt|;
name|value
operator|->
name|v
operator|.
name|octetstring
operator|.
name|octets
operator|=
name|malloc
argument_list|(
name|strvallen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|value
operator|->
name|v
operator|.
name|octetstring
operator|.
name|octets
argument_list|,
name|strval
argument_list|,
name|strvallen
argument_list|)
expr_stmt|;
name|gettoken
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* XX:XX:XX syntax */
name|value
operator|->
name|v
operator|.
name|octetstring
operator|.
name|octets
operator|=
name|NULL
expr_stmt|;
name|value
operator|->
name|v
operator|.
name|octetstring
operator|.
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|TOK_NUM
condition|)
comment|/* empty string is allowed */
return|return;
if|if
condition|(
name|ERRPUSH
argument_list|()
condition|)
block|{
name|free
argument_list|(
name|value
operator|->
name|v
operator|.
name|octetstring
operator|.
name|octets
argument_list|)
expr_stmt|;
name|ERRNEXT
argument_list|()
expr_stmt|;
block|}
name|alloc
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|token
operator|!=
name|TOK_NUM
condition|)
name|report
argument_list|(
literal|"bad OCTETSTRING syntax"
argument_list|)
expr_stmt|;
if|if
condition|(
name|numval
operator|>
literal|0xff
condition|)
name|report
argument_list|(
literal|"byte value too large"
argument_list|)
expr_stmt|;
if|if
condition|(
name|alloc
operator|==
name|value
operator|->
name|v
operator|.
name|octetstring
operator|.
name|len
condition|)
block|{
name|alloc
operator|+=
literal|100
expr_stmt|;
name|noct
operator|=
name|realloc
argument_list|(
name|value
operator|->
name|v
operator|.
name|octetstring
operator|.
name|octets
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|noct
operator|==
name|NULL
condition|)
name|report
argument_list|(
literal|"%m"
argument_list|)
expr_stmt|;
name|value
operator|->
name|v
operator|.
name|octetstring
operator|.
name|octets
operator|=
name|noct
expr_stmt|;
block|}
name|value
operator|->
name|v
operator|.
name|octetstring
operator|.
name|octets
index|[
name|value
operator|->
name|v
operator|.
name|octetstring
operator|.
name|len
operator|++
index|]
operator|=
name|numval
expr_stmt|;
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
literal|':'
condition|)
break|break;
name|gettoken
argument_list|()
expr_stmt|;
block|}
name|ERRPOP
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_syntax_oid
parameter_list|(
name|struct
name|snmp_value
modifier|*
name|value
parameter_list|)
block|{
name|value
operator|->
name|v
operator|.
name|oid
operator|.
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|TOK_NUM
condition|)
return|return;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|token
operator|!=
name|TOK_NUM
condition|)
name|report
argument_list|(
literal|"bad OID syntax"
argument_list|)
expr_stmt|;
if|if
condition|(
name|numval
operator|>
name|ASN_MAXID
condition|)
name|report
argument_list|(
literal|"subid too large"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|->
name|v
operator|.
name|oid
operator|.
name|len
operator|==
name|ASN_MAXOIDLEN
condition|)
name|report
argument_list|(
literal|"OID too long"
argument_list|)
expr_stmt|;
name|value
operator|->
name|v
operator|.
name|oid
operator|.
name|subs
index|[
name|value
operator|->
name|v
operator|.
name|oid
operator|.
name|len
operator|++
index|]
operator|=
name|numval
expr_stmt|;
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
literal|'.'
condition|)
break|break;
name|gettoken
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|parse_syntax_ipaddress
parameter_list|(
name|struct
name|snmp_value
modifier|*
name|value
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_char
name|ip
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|token
operator|==
name|TOK_NUM
condition|)
block|{
comment|/* numerical address */
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|numval
operator|>=
literal|256
condition|)
name|report
argument_list|(
literal|"ip address part too large"
argument_list|)
expr_stmt|;
name|value
operator|->
name|v
operator|.
name|ipaddress
index|[
name|i
operator|++
index|]
operator|=
name|numval
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|4
condition|)
break|break;
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
literal|'.'
condition|)
name|report
argument_list|(
literal|"expecting '.' in ip address"
argument_list|)
expr_stmt|;
block|}
name|gettoken
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|TOK_HOST
condition|)
block|{
comment|/* host name */
name|gethost
argument_list|(
name|strval
argument_list|,
name|ip
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|value
operator|->
name|v
operator|.
name|ipaddress
index|[
name|i
index|]
operator|=
name|ip
index|[
name|i
index|]
expr_stmt|;
name|gettoken
argument_list|()
expr_stmt|;
block|}
else|else
name|report
argument_list|(
literal|"bad ip address syntax"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_syntax_uint32
parameter_list|(
name|struct
name|snmp_value
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
name|token
operator|!=
name|TOK_NUM
condition|)
name|report
argument_list|(
literal|"bad number syntax"
argument_list|)
expr_stmt|;
if|if
condition|(
name|numval
operator|>
literal|0xffffffff
condition|)
name|report
argument_list|(
literal|"number too large"
argument_list|)
expr_stmt|;
name|value
operator|->
name|v
operator|.
name|uint32
operator|=
name|numval
expr_stmt|;
name|gettoken
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse an assignement line  */
end_comment

begin_function
specifier|static
name|void
name|parse_assign
parameter_list|(
specifier|const
name|char
modifier|*
name|varname
parameter_list|)
block|{
name|struct
name|snmp_value
name|value
decl_stmt|;
name|struct
name|asn_oid
name|vindex
decl_stmt|;
specifier|const
name|struct
name|snmp_node
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|parse_oid
argument_list|(
name|varname
argument_list|,
operator|&
name|vindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
literal|'='
condition|)
name|report
argument_list|(
literal|"'=' expected"
argument_list|)
expr_stmt|;
name|gettoken
argument_list|()
expr_stmt|;
if|if
condition|(
name|ignore
condition|)
block|{
comment|/* skip rest of line */
while|while
condition|(
name|token
operator|!=
name|TOK_EOL
operator|&&
name|token
operator|!=
name|TOK_EOF
condition|)
name|gettoken
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
name|report
argument_list|(
literal|"unknown variable"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|value
operator|.
name|syntax
operator|=
name|node
operator|->
name|syntax
condition|)
block|{
case|case
name|SNMP_SYNTAX_NULL
case|:
name|parse_syntax_null
argument_list|(
operator|&
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNMP_SYNTAX_INTEGER
case|:
name|parse_syntax_integer
argument_list|(
operator|&
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNMP_SYNTAX_COUNTER64
case|:
name|parse_syntax_counter64
argument_list|(
operator|&
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNMP_SYNTAX_OCTETSTRING
case|:
name|parse_syntax_octetstring
argument_list|(
operator|&
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNMP_SYNTAX_OID
case|:
name|parse_syntax_oid
argument_list|(
operator|&
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNMP_SYNTAX_IPADDRESS
case|:
name|parse_syntax_ipaddress
argument_list|(
operator|&
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNMP_SYNTAX_COUNTER
case|:
case|case
name|SNMP_SYNTAX_GAUGE
case|:
case|case
name|SNMP_SYNTAX_TIMETICKS
case|:
name|parse_syntax_uint32
argument_list|(
operator|&
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNMP_SYNTAX_NOSUCHOBJECT
case|:
case|case
name|SNMP_SYNTAX_NOSUCHINSTANCE
case|:
case|case
name|SNMP_SYNTAX_ENDOFMIBVIEW
case|:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ERRPUSH
argument_list|()
condition|)
block|{
name|snmp_value_free
argument_list|(
operator|&
name|value
argument_list|)
expr_stmt|;
name|ERRNEXT
argument_list|()
expr_stmt|;
block|}
name|handle_assignment
argument_list|(
name|node
argument_list|,
operator|&
name|vindex
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|ERRPOP
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle macro definition line  * We have already seen the := and the input now stands at the character  * after the =. Skip whitespace and then call the input routine directly to  * eat up characters.  */
end_comment

begin_function
specifier|static
name|void
name|parse_define
parameter_list|(
specifier|const
name|char
modifier|*
name|varname
parameter_list|)
block|{
name|char
modifier|*
specifier|volatile
name|string
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
specifier|volatile
name|size_t
name|alloc
decl_stmt|,
name|length
decl_stmt|;
name|int
name|c
decl_stmt|;
name|struct
name|macro
modifier|*
name|m
decl_stmt|;
name|int
name|t
init|=
name|token
decl_stmt|;
name|alloc
operator|=
literal|100
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|string
operator|=
name|malloc
argument_list|(
name|alloc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|report
argument_list|(
literal|"%m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ERRPUSH
argument_list|()
condition|)
block|{
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|ERRNEXT
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|input_getc_plain
argument_list|()
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
while|while
condition|(
name|c
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'#'
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|alloc
operator|==
name|length
condition|)
block|{
name|alloc
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
name|realloc
argument_list|(
name|string
argument_list|,
name|alloc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|report
argument_list|(
literal|"%m"
argument_list|)
expr_stmt|;
name|string
operator|=
name|new
expr_stmt|;
block|}
name|string
index|[
name|length
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|input_getc_plain
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|input_getc_plain
argument_list|()
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|report
argument_list|(
literal|"EOF in macro definition"
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|m
argument_list|,
argument|&macros
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|m
operator|->
name|name
argument_list|,
name|varname
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|m
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|report
argument_list|(
literal|"%m"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|name
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|varname
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|report
argument_list|(
literal|"%m"
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|m
operator|->
name|name
argument_list|,
name|varname
argument_list|)
expr_stmt|;
name|m
operator|->
name|perm
operator|=
literal|0
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|macros
argument_list|,
name|m
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|m
operator|->
name|value
operator|=
name|string
expr_stmt|;
name|m
operator|->
name|length
operator|=
name|length
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|t
operator|==
name|TOK_ASSIGN
condition|)
block|{
name|free
argument_list|(
name|m
operator|->
name|value
argument_list|)
expr_stmt|;
name|m
operator|->
name|value
operator|=
name|string
expr_stmt|;
name|m
operator|->
name|length
operator|=
name|length
expr_stmt|;
block|}
block|}
name|token
operator|=
name|TOK_EOL
expr_stmt|;
name|ERRPOP
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free all macros  */
end_comment

begin_function
specifier|static
name|void
name|macro_free_all
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|struct
name|macro
modifier|*
name|m
decl_stmt|,
modifier|*
name|m1
decl_stmt|;
name|m
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|macros
argument_list|)
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|m1
operator|=
name|LIST_NEXT
argument_list|(
name|m
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|->
name|perm
condition|)
block|{
name|free
argument_list|(
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|m
operator|->
name|value
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|m
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|m1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Parse an include directive and switch to the new file  */
end_comment

begin_function
specifier|static
name|void
name|parse_include
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|sysdir
init|=
literal|0
decl_stmt|;
name|char
name|fname
index|[
name|_POSIX2_LINE_MAX
index|]
decl_stmt|;
if|if
condition|(
name|gettoken
argument_list|()
operator|==
literal|'<'
condition|)
block|{
name|sysdir
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|TOK_STR
condition|)
name|report
argument_list|(
literal|"expecting filename after in .include"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|!=
name|TOK_STR
condition|)
name|report
argument_list|(
literal|"expecting filename after in .include"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|fname
argument_list|,
name|strval
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysdir
operator|&&
name|gettoken
argument_list|()
operator|!=
literal|'>'
condition|)
name|report
argument_list|(
literal|"expecting '>'"
argument_list|)
expr_stmt|;
name|gettoken
argument_list|()
expr_stmt|;
if|if
condition|(
name|input_open_file
argument_list|(
name|fname
argument_list|,
name|sysdir
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|report
argument_list|(
literal|"%s: %m"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse the configuration file  */
end_comment

begin_function
specifier|static
name|void
name|parse_file
parameter_list|(
specifier|const
name|struct
name|lmodule
modifier|*
name|mod
parameter_list|)
block|{
name|char
name|varname
index|[
name|_POSIX2_LINE_MAX
index|]
decl_stmt|;
while|while
condition|(
name|gettoken
argument_list|()
operator|!=
name|TOK_EOF
condition|)
block|{
if|if
condition|(
name|token
operator|==
name|TOK_EOL
condition|)
comment|/* empty line */
continue|continue;
if|if
condition|(
name|token
operator|==
literal|'%'
condition|)
block|{
name|gettoken
argument_list|()
expr_stmt|;
name|parse_section
argument_list|(
name|mod
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|TOK_STR
condition|)
name|report
argument_list|(
literal|"keyword expected after '.'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|strval
argument_list|,
literal|"include"
argument_list|)
operator|==
literal|0
condition|)
name|parse_include
argument_list|()
expr_stmt|;
else|else
name|report
argument_list|(
literal|"unknown keyword '%s'"
argument_list|,
name|strval
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|TOK_STR
condition|)
block|{
name|strcpy
argument_list|(
name|varname
argument_list|,
name|strval
argument_list|)
expr_stmt|;
if|if
condition|(
name|gettoken
argument_list|()
operator|==
name|TOK_ASSIGN
operator|||
name|token
operator|==
name|TOK_QASSIGN
condition|)
name|parse_define
argument_list|(
name|varname
argument_list|)
expr_stmt|;
else|else
name|parse_assign
argument_list|(
name|varname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|token
operator|!=
name|TOK_EOL
condition|)
name|report
argument_list|(
literal|"eol expected"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Do rollback on errors  */
end_comment

begin_function
specifier|static
name|void
name|do_rollback
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|assign
modifier|*
name|tp
decl_stmt|;
name|struct
name|snmp_node
modifier|*
name|node
decl_stmt|;
while|while
condition|(
operator|(
name|tp
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|assigns
argument_list|,
name|assigns
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|assigns
argument_list|,
name|tp
argument_list|,
name|link
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|tree
init|;
name|node
operator|<
operator|&
name|tree
index|[
name|tree_size
index|]
condition|;
name|node
operator|++
control|)
if|if
condition|(
name|node
operator|->
name|name
operator|==
name|tp
operator|->
name|node_name
condition|)
block|{
name|snmp_ctx
operator|->
name|scratch
operator|=
operator|&
name|tp
operator|->
name|scratch
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|node
operator|->
name|op
argument_list|)
argument_list|(
name|snmp_ctx
argument_list|,
operator|&
name|tp
operator|->
name|value
argument_list|,
name|node
operator|->
name|oid
operator|.
name|len
argument_list|,
name|node
operator|->
name|index
argument_list|,
name|SNMP_OP_ROLLBACK
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|node
operator|==
operator|&
name|tree
index|[
name|tree_size
index|]
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"failed to find node for "
literal|"rollback"
argument_list|)
expr_stmt|;
name|snmp_value_free
argument_list|(
operator|&
name|tp
operator|->
name|value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Do commit  */
end_comment

begin_function
specifier|static
name|void
name|do_commit
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|assign
modifier|*
name|tp
decl_stmt|;
name|struct
name|snmp_node
modifier|*
name|node
decl_stmt|;
while|while
condition|(
operator|(
name|tp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|assigns
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|assigns
argument_list|,
name|tp
argument_list|,
name|link
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|tree
init|;
name|node
operator|<
operator|&
name|tree
index|[
name|tree_size
index|]
condition|;
name|node
operator|++
control|)
if|if
condition|(
name|node
operator|->
name|name
operator|==
name|tp
operator|->
name|node_name
condition|)
block|{
name|snmp_ctx
operator|->
name|scratch
operator|=
operator|&
name|tp
operator|->
name|scratch
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|node
operator|->
name|op
argument_list|)
argument_list|(
name|snmp_ctx
argument_list|,
operator|&
name|tp
operator|->
name|value
argument_list|,
name|node
operator|->
name|oid
operator|.
name|len
argument_list|,
name|node
operator|->
name|index
argument_list|,
name|SNMP_OP_COMMIT
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|node
operator|==
operator|&
name|tree
index|[
name|tree_size
index|]
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"failed to find node for commit"
argument_list|)
expr_stmt|;
name|snmp_value_free
argument_list|(
operator|&
name|tp
operator|->
name|value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Read the configuration file. Handle the entire file as one transaction.  *  * If lodmod is NULL, the sections for 'snmpd' and all loaded modules are  * executed. If it is not NULL, only the sections for that module are handled.  */
end_comment

begin_function
name|int
name|read_config
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|struct
name|lmodule
modifier|*
name|lodmod
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|char
name|objbuf
index|[
name|ASN_OIDSTRLEN
index|]
decl_stmt|;
name|char
name|idxbuf
index|[
name|ASN_OIDSTRLEN
index|]
decl_stmt|;
name|ignore
operator|=
literal|0
expr_stmt|;
name|input_push
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ERRPUSH
argument_list|()
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|input_open_file
argument_list|(
name|fname
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: %m"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ERRPOP
argument_list|()
expr_stmt|;
name|community
operator|=
name|COMM_INITIALIZE
expr_stmt|;
if|if
condition|(
operator|(
name|snmp_ctx
operator|=
name|snmp_init_context
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|input_close_all
argument_list|()
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%m"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ERRPUSH
argument_list|()
condition|)
block|{
name|do_rollback
argument_list|()
expr_stmt|;
name|input_close_all
argument_list|()
expr_stmt|;
name|macro_free_all
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|snmp_ctx
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|parse_file
argument_list|(
name|lodmod
argument_list|)
expr_stmt|;
name|ERRPOP
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|snmp_dep_commit
argument_list|(
name|snmp_ctx
argument_list|)
operator|)
operator|!=
name|SNMP_ERR_NOERROR
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"init dep failed: %u %s %s"
argument_list|,
name|err
argument_list|,
name|asn_oid2str_r
argument_list|(
operator|&
name|snmp_ctx
operator|->
name|dep
operator|->
name|obj
argument_list|,
name|objbuf
argument_list|)
argument_list|,
name|asn_oid2str_r
argument_list|(
operator|&
name|snmp_ctx
operator|->
name|dep
operator|->
name|idx
argument_list|,
name|idxbuf
argument_list|)
argument_list|)
expr_stmt|;
name|snmp_dep_rollback
argument_list|(
name|snmp_ctx
argument_list|)
expr_stmt|;
name|do_rollback
argument_list|()
expr_stmt|;
name|input_close_all
argument_list|()
expr_stmt|;
name|macro_free_all
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|snmp_ctx
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|do_commit
argument_list|()
expr_stmt|;
name|snmp_dep_finish
argument_list|(
name|snmp_ctx
argument_list|)
expr_stmt|;
name|macro_free_all
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|snmp_ctx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Define a permanent macro  */
end_comment

begin_function
name|int
name|define_macro
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|macro
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|m
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|m
operator|->
name|name
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|m
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|value
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|m
operator|->
name|value
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|m
operator|->
name|length
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|m
operator|->
name|perm
operator|=
literal|1
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|macros
argument_list|,
name|m
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

