begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2001-2003  *	Fraunhofer Institute for Open Communication Systems (FhG Fokus).  *	All rights reserved.  *  * Author: Harti Brandt<harti@freebsd.org>  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *   * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Begemot: bsnmp/snmpd/main.c,v 1.97 2005/10/04 14:32:45 brandt_h Exp $  *  * SNMPd main stuff.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<sys/ucred.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_TCPWRAPPERS
end_ifdef

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<tcpd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"snmpmod.h"
end_include

begin_include
include|#
directive|include
file|"snmpd.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"oid.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|INT32_MAX
argument_list|)
end_if

begin_define
define|#
directive|define
name|INT32_MAX
value|(0x7fffffff)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PATH_PID
value|"/var/run/%s.pid"
end_define

begin_define
define|#
directive|define
name|PATH_CONFIG
value|"/etc/%s.config"
end_define

begin_decl_stmt
name|uint64_t
name|this_tick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start of processing of current packet (absolute) */
end_comment

begin_decl_stmt
name|uint64_t
name|start_tick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start of processing */
end_comment

begin_decl_stmt
name|struct
name|systemg
name|systemg
init|=
block|{
name|NULL
block|,
block|{
literal|8
block|,
block|{
literal|1
block|,
literal|3
block|,
literal|6
block|,
literal|1
block|,
literal|4
block|,
literal|1
block|,
literal|1115
block|,
literal|7352
block|}
block|}
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|64
operator|+
literal|8
operator|+
literal|4
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|debug
name|debug
init|=
block|{
literal|0
block|,
comment|/* dump_pdus */
name|LOG_DEBUG
block|,
comment|/* log_pri */
literal|0
block|,
comment|/* evdebug */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|snmpd
name|snmpd
init|=
block|{
literal|2048
block|,
comment|/* txbuf */
literal|2048
block|,
comment|/* rxbuf */
literal|0
block|,
comment|/* comm_dis */
literal|0
block|,
comment|/* auth_traps */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* trap1addr */
name|VERS_ENABLE_ALL
block|,
comment|/* version_enable */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|snmpd_stats
name|snmpd_stats
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* snmpSerialNo */
end_comment

begin_decl_stmt
name|int32_t
name|snmp_serial_no
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* search path for config files */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|syspath
init|=
name|PATH_SYSCONFIG
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of all loaded modules */
end_comment

begin_decl_stmt
name|struct
name|lmodules
name|lmodules
init|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|lmodules
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of loaded modules during start-up in the order they were loaded */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|lmodules
name|modules_start
init|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|modules_start
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of all known communities */
end_comment

begin_decl_stmt
name|struct
name|community_list
name|community_list
init|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|community_list
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of all installed object resources */
end_comment

begin_decl_stmt
name|struct
name|objres_list
name|objres_list
init|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|objres_list
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* community value generator */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|next_community_index
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of all known ranges */
end_comment

begin_decl_stmt
name|struct
name|idrange_list
name|idrange_list
init|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|idrange_list
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* identifier generator */
end_comment

begin_decl_stmt
name|u_int
name|next_idrange
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of all current timers */
end_comment

begin_decl_stmt
name|struct
name|timer_list
name|timer_list
init|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|timer_list
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of file descriptors */
end_comment

begin_decl_stmt
name|struct
name|fdesc_list
name|fdesc_list
init|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|fdesc_list
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* program arguments */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|progargs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nprogargs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current community */
end_comment

begin_decl_stmt
name|u_int
name|community
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|community
modifier|*
name|comm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file names */
end_comment

begin_decl_stmt
specifier|static
name|char
name|config_file
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|pid_file
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|USE_LIBBEGEMOT
end_ifndef

begin_comment
comment|/* event context */
end_comment

begin_decl_stmt
specifier|static
name|evContext
name|evctx
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* signal mask */
end_comment

begin_decl_stmt
specifier|static
name|sigset_t
name|blocked_sigs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* signal handling */
end_comment

begin_decl_stmt
specifier|static
name|int
name|work
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|WORK_DOINFO
value|0x0001
end_define

begin_define
define|#
directive|define
name|WORK_RECONFIG
value|0x0002
end_define

begin_comment
comment|/* oids */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|asn_oid
name|oid_snmpMIB
init|=
name|OIDX_snmpMIB
decl_stmt|,
name|oid_begemotSnmpd
init|=
name|OIDX_begemotSnmpd
decl_stmt|,
name|oid_coldStart
init|=
name|OIDX_coldStart
decl_stmt|,
name|oid_authenticationFailure
init|=
name|OIDX_authenticationFailure
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|asn_oid
name|oid_zeroDotZero
init|=
block|{
literal|2
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* request id generator for traps */
end_comment

begin_decl_stmt
name|u_int
name|trap_reqid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* help text */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|usgtxt
index|[]
init|=
literal|"\ Begemot simple SNMP daemon. Copyright (c) 2001-2002 Fraunhofer Institute for\n\ Open Communication Systems (FhG Fokus). All rights reserved.\n\ usage: snmpd [-dh] [-c file] [-D options] [-I path] [-l prefix]\n\              [-m variable=value] [-p file]\n\ options:\n\   -d		don't daemonize\n\   -h		print this info\n\   -c file	specify configuration file\n\   -D options	debugging options\n\   -I path	system include path\n\   -l prefix	default basename for pid and config file\n\   -m var=val	define variable\n\   -p file	specify pid file\n\ "
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hosts_access(3) request */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_TCPWRAPPERS
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|request_info
name|req
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* transports */
end_comment

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|transport_def
name|udp_trans
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|transport_def
name|lsock_trans
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|transport_list
name|transport_list
init|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|transport_list
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* forward declarations */
end_comment

begin_function_decl
specifier|static
name|void
name|snmp_printf_func
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|snmp_error_func
parameter_list|(
specifier|const
name|char
modifier|*
name|err
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|snmp_debug_func
parameter_list|(
specifier|const
name|char
modifier|*
name|err
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|asn_error_func
parameter_list|(
specifier|const
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|err
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Allocate rx/tx buffer. We allocate one byte more for rx.  */
end_comment

begin_function
name|void
modifier|*
name|buf_alloc
parameter_list|(
name|int
name|tx
parameter_list|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|tx
condition|?
name|snmpd
operator|.
name|txbuf
else|:
name|snmpd
operator|.
name|rxbuf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"cannot allocate buffer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx
condition|)
name|snmpd_stats
operator|.
name|noTxbuf
operator|++
expr_stmt|;
else|else
name|snmpd_stats
operator|.
name|noRxbuf
operator|++
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the buffer size.  */
end_comment

begin_function
name|size_t
name|buf_size
parameter_list|(
name|int
name|tx
parameter_list|)
block|{
return|return
operator|(
name|tx
condition|?
name|snmpd
operator|.
name|txbuf
else|:
name|snmpd
operator|.
name|rxbuf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Prepare a PDU for output  */
end_comment

begin_function
name|void
name|snmp_output
parameter_list|(
name|struct
name|snmp_pdu
modifier|*
name|pdu
parameter_list|,
name|u_char
modifier|*
name|sndbuf
parameter_list|,
name|size_t
modifier|*
name|sndlen
parameter_list|,
specifier|const
name|char
modifier|*
name|dest
parameter_list|)
block|{
name|struct
name|asn_buf
name|resp_b
decl_stmt|;
name|resp_b
operator|.
name|asn_ptr
operator|=
name|sndbuf
expr_stmt|;
name|resp_b
operator|.
name|asn_len
operator|=
name|snmpd
operator|.
name|txbuf
expr_stmt|;
if|if
condition|(
name|snmp_pdu_encode
argument_list|(
name|pdu
argument_list|,
operator|&
name|resp_b
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot encode message"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|debug
operator|.
name|dump_pdus
condition|)
block|{
name|snmp_printf
argument_list|(
literal|"%s<- "
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|snmp_pdu_dump
argument_list|(
name|pdu
argument_list|)
expr_stmt|;
block|}
operator|*
name|sndlen
operator|=
call|(
name|size_t
call|)
argument_list|(
name|resp_b
operator|.
name|asn_ptr
operator|-
name|sndbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SNMP input. Start: decode the PDU, find the community.  */
end_comment

begin_function
name|enum
name|snmpd_input_err
name|snmp_input_start
parameter_list|(
specifier|const
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|source
parameter_list|,
name|struct
name|snmp_pdu
modifier|*
name|pdu
parameter_list|,
name|int32_t
modifier|*
name|ip
parameter_list|,
name|size_t
modifier|*
name|pdulen
parameter_list|)
block|{
name|struct
name|asn_buf
name|b
decl_stmt|;
name|enum
name|snmp_code
name|code
decl_stmt|;
name|enum
name|snmpd_input_err
name|ret
decl_stmt|;
name|int
name|sret
decl_stmt|;
name|b
operator|.
name|asn_cptr
operator|=
name|buf
expr_stmt|;
name|b
operator|.
name|asn_len
operator|=
name|len
expr_stmt|;
comment|/* look whether we have enough bytes for the entire PDU. */
switch|switch
condition|(
name|sret
operator|=
name|snmp_pdu_snoop
argument_list|(
operator|&
name|b
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
return|return
operator|(
name|SNMPD_INPUT_TRUNC
operator|)
return|;
case|case
operator|-
literal|1
case|:
name|snmpd_stats
operator|.
name|inASNParseErrs
operator|++
expr_stmt|;
return|return
operator|(
name|SNMPD_INPUT_FAILED
operator|)
return|;
block|}
name|b
operator|.
name|asn_len
operator|=
operator|*
name|pdulen
operator|=
operator|(
name|size_t
operator|)
name|sret
expr_stmt|;
name|code
operator|=
name|snmp_pdu_decode
argument_list|(
operator|&
name|b
argument_list|,
name|pdu
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|snmpd_stats
operator|.
name|inPkts
operator|++
expr_stmt|;
name|ret
operator|=
name|SNMPD_INPUT_OK
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SNMP_CODE_FAILED
case|:
name|snmpd_stats
operator|.
name|inASNParseErrs
operator|++
expr_stmt|;
return|return
operator|(
name|SNMPD_INPUT_FAILED
operator|)
return|;
case|case
name|SNMP_CODE_BADVERS
case|:
name|bad_vers
label|:
name|snmpd_stats
operator|.
name|inBadVersions
operator|++
expr_stmt|;
return|return
operator|(
name|SNMPD_INPUT_FAILED
operator|)
return|;
case|case
name|SNMP_CODE_BADLEN
case|:
if|if
condition|(
name|pdu
operator|->
name|type
operator|==
name|SNMP_OP_SET
condition|)
name|ret
operator|=
name|SNMPD_INPUT_VALBADLEN
expr_stmt|;
break|break;
case|case
name|SNMP_CODE_OORANGE
case|:
if|if
condition|(
name|pdu
operator|->
name|type
operator|==
name|SNMP_OP_SET
condition|)
name|ret
operator|=
name|SNMPD_INPUT_VALRANGE
expr_stmt|;
break|break;
case|case
name|SNMP_CODE_BADENC
case|:
if|if
condition|(
name|pdu
operator|->
name|type
operator|==
name|SNMP_OP_SET
condition|)
name|ret
operator|=
name|SNMPD_INPUT_VALBADENC
expr_stmt|;
break|break;
case|case
name|SNMP_CODE_OK
case|:
switch|switch
condition|(
name|pdu
operator|->
name|version
condition|)
block|{
case|case
name|SNMP_V1
case|:
if|if
condition|(
operator|!
operator|(
name|snmpd
operator|.
name|version_enable
operator|&
name|VERS_ENABLE_V1
operator|)
condition|)
goto|goto
name|bad_vers
goto|;
break|break;
case|case
name|SNMP_V2c
case|:
if|if
condition|(
operator|!
operator|(
name|snmpd
operator|.
name|version_enable
operator|&
name|VERS_ENABLE_V2C
operator|)
condition|)
goto|goto
name|bad_vers
goto|;
break|break;
case|case
name|SNMP_Verr
case|:
goto|goto
name|bad_vers
goto|;
block|}
break|break;
block|}
if|if
condition|(
name|debug
operator|.
name|dump_pdus
condition|)
block|{
name|snmp_printf
argument_list|(
literal|"%s -> "
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|snmp_pdu_dump
argument_list|(
name|pdu
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Look, whether we know the community 	 */
name|TAILQ_FOREACH
argument_list|(
argument|comm
argument_list|,
argument|&community_list
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|comm
operator|->
name|string
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|comm
operator|->
name|string
argument_list|,
name|pdu
operator|->
name|community
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|comm
operator|==
name|NULL
condition|)
block|{
name|snmpd_stats
operator|.
name|inBadCommunityNames
operator|++
expr_stmt|;
name|snmp_pdu_free
argument_list|(
name|pdu
argument_list|)
expr_stmt|;
if|if
condition|(
name|snmpd
operator|.
name|auth_traps
condition|)
name|snmp_send_trap
argument_list|(
operator|&
name|oid_authenticationFailure
argument_list|,
operator|(
expr|struct
name|snmp_value
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ret
operator|=
name|SNMPD_INPUT_BAD_COMM
expr_stmt|;
block|}
else|else
name|community
operator|=
name|comm
operator|->
name|value
expr_stmt|;
comment|/* update uptime */
name|this_tick
operator|=
name|get_ticks
argument_list|()
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Will return only _OK or _FAILED  */
end_comment

begin_function
name|enum
name|snmpd_input_err
name|snmp_input_finish
parameter_list|(
name|struct
name|snmp_pdu
modifier|*
name|pdu
parameter_list|,
specifier|const
name|u_char
modifier|*
name|rcvbuf
parameter_list|,
name|size_t
name|rcvlen
parameter_list|,
name|u_char
modifier|*
name|sndbuf
parameter_list|,
name|size_t
modifier|*
name|sndlen
parameter_list|,
specifier|const
name|char
modifier|*
name|source
parameter_list|,
name|enum
name|snmpd_input_err
name|ierr
parameter_list|,
name|int32_t
name|ivar
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|snmp_pdu
name|resp
decl_stmt|;
name|struct
name|asn_buf
name|resp_b
decl_stmt|,
name|pdu_b
decl_stmt|;
name|enum
name|snmp_ret
name|ret
decl_stmt|;
name|resp_b
operator|.
name|asn_ptr
operator|=
name|sndbuf
expr_stmt|;
name|resp_b
operator|.
name|asn_len
operator|=
name|snmpd
operator|.
name|txbuf
expr_stmt|;
name|pdu_b
operator|.
name|asn_cptr
operator|=
name|rcvbuf
expr_stmt|;
name|pdu_b
operator|.
name|asn_len
operator|=
name|rcvlen
expr_stmt|;
if|if
condition|(
name|ierr
operator|!=
name|SNMPD_INPUT_OK
condition|)
block|{
comment|/* error decoding the input of a SET */
if|if
condition|(
name|pdu
operator|->
name|version
operator|==
name|SNMP_V1
condition|)
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_BADVALUE
expr_stmt|;
elseif|else
if|if
condition|(
name|ierr
operator|==
name|SNMPD_INPUT_VALBADLEN
condition|)
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_WRONG_LENGTH
expr_stmt|;
elseif|else
if|if
condition|(
name|ierr
operator|==
name|SNMPD_INPUT_VALRANGE
condition|)
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_WRONG_VALUE
expr_stmt|;
else|else
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_WRONG_ENCODING
expr_stmt|;
name|pdu
operator|->
name|error_index
operator|=
name|ivar
expr_stmt|;
if|if
condition|(
name|snmp_make_errresp
argument_list|(
name|pdu
argument_list|,
operator|&
name|pdu_b
argument_list|,
operator|&
name|resp_b
argument_list|)
operator|==
name|SNMP_RET_IGN
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"could not encode error response"
argument_list|)
expr_stmt|;
name|snmpd_stats
operator|.
name|silentDrops
operator|++
expr_stmt|;
return|return
operator|(
name|SNMPD_INPUT_FAILED
operator|)
return|;
block|}
if|if
condition|(
name|debug
operator|.
name|dump_pdus
condition|)
block|{
name|snmp_printf
argument_list|(
literal|"%s<- "
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|snmp_pdu_dump
argument_list|(
name|pdu
argument_list|)
expr_stmt|;
block|}
operator|*
name|sndlen
operator|=
call|(
name|size_t
call|)
argument_list|(
name|resp_b
operator|.
name|asn_ptr
operator|-
name|sndbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMPD_INPUT_OK
operator|)
return|;
block|}
switch|switch
condition|(
name|pdu
operator|->
name|type
condition|)
block|{
case|case
name|SNMP_PDU_GET
case|:
name|ret
operator|=
name|snmp_get
argument_list|(
name|pdu
argument_list|,
operator|&
name|resp_b
argument_list|,
operator|&
name|resp
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNMP_PDU_GETNEXT
case|:
name|ret
operator|=
name|snmp_getnext
argument_list|(
name|pdu
argument_list|,
operator|&
name|resp_b
argument_list|,
operator|&
name|resp
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNMP_PDU_SET
case|:
name|ret
operator|=
name|snmp_set
argument_list|(
name|pdu
argument_list|,
operator|&
name|resp_b
argument_list|,
operator|&
name|resp
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNMP_PDU_GETBULK
case|:
name|ret
operator|=
name|snmp_getbulk
argument_list|(
name|pdu
argument_list|,
operator|&
name|resp_b
argument_list|,
operator|&
name|resp
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|SNMP_RET_IGN
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|SNMP_RET_OK
case|:
comment|/* normal return - send a response */
if|if
condition|(
name|debug
operator|.
name|dump_pdus
condition|)
block|{
name|snmp_printf
argument_list|(
literal|"%s<- "
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|snmp_pdu_dump
argument_list|(
operator|&
name|resp
argument_list|)
expr_stmt|;
block|}
operator|*
name|sndlen
operator|=
call|(
name|size_t
call|)
argument_list|(
name|resp_b
operator|.
name|asn_ptr
operator|-
name|sndbuf
argument_list|)
expr_stmt|;
name|snmp_pdu_free
argument_list|(
operator|&
name|resp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMPD_INPUT_OK
operator|)
return|;
case|case
name|SNMP_RET_IGN
case|:
comment|/* error - send nothing */
name|snmpd_stats
operator|.
name|silentDrops
operator|++
expr_stmt|;
return|return
operator|(
name|SNMPD_INPUT_FAILED
operator|)
return|;
case|case
name|SNMP_RET_ERR
case|:
comment|/* error - send error response. The snmp routine has 		 * changed the error fields in the original message. */
name|resp_b
operator|.
name|asn_ptr
operator|=
name|sndbuf
expr_stmt|;
name|resp_b
operator|.
name|asn_len
operator|=
name|snmpd
operator|.
name|txbuf
expr_stmt|;
if|if
condition|(
name|snmp_make_errresp
argument_list|(
name|pdu
argument_list|,
operator|&
name|pdu_b
argument_list|,
operator|&
name|resp_b
argument_list|)
operator|==
name|SNMP_RET_IGN
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"could not encode error response"
argument_list|)
expr_stmt|;
name|snmpd_stats
operator|.
name|silentDrops
operator|++
expr_stmt|;
return|return
operator|(
name|SNMPD_INPUT_FAILED
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|debug
operator|.
name|dump_pdus
condition|)
block|{
name|snmp_printf
argument_list|(
literal|"%s<- "
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|snmp_pdu_dump
argument_list|(
name|pdu
argument_list|)
expr_stmt|;
block|}
operator|*
name|sndlen
operator|=
call|(
name|size_t
call|)
argument_list|(
name|resp_b
operator|.
name|asn_ptr
operator|-
name|sndbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMPD_INPUT_OK
operator|)
return|;
block|}
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Insert a port into the right place in the transport's table of ports  */
end_comment

begin_function
name|void
name|trans_insert_port
parameter_list|(
name|struct
name|transport
modifier|*
name|t
parameter_list|,
name|struct
name|tport
modifier|*
name|port
parameter_list|)
block|{
name|struct
name|tport
modifier|*
name|p
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&t->table
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|asn_compare_oid
argument_list|(
operator|&
name|p
operator|->
name|index
argument_list|,
operator|&
name|port
operator|->
name|index
argument_list|)
operator|>
literal|0
condition|)
block|{
name|TAILQ_INSERT_BEFORE
argument_list|(
name|p
argument_list|,
name|port
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|port
operator|->
name|transport
operator|=
name|t
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|t
operator|->
name|table
argument_list|,
name|port
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove a port from a transport's list  */
end_comment

begin_function
name|void
name|trans_remove_port
parameter_list|(
name|struct
name|tport
modifier|*
name|port
parameter_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|port
operator|->
name|transport
operator|->
name|table
argument_list|,
name|port
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find a port on a transport's list  */
end_comment

begin_function
name|struct
name|tport
modifier|*
name|trans_find_port
parameter_list|(
name|struct
name|transport
modifier|*
name|t
parameter_list|,
specifier|const
name|struct
name|asn_oid
modifier|*
name|idx
parameter_list|,
name|u_int
name|sub
parameter_list|)
block|{
return|return
operator|(
name|FIND_OBJECT_OID
argument_list|(
operator|&
name|t
operator|->
name|table
argument_list|,
name|idx
argument_list|,
name|sub
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find next port on a transport's list  */
end_comment

begin_function
name|struct
name|tport
modifier|*
name|trans_next_port
parameter_list|(
name|struct
name|transport
modifier|*
name|t
parameter_list|,
specifier|const
name|struct
name|asn_oid
modifier|*
name|idx
parameter_list|,
name|u_int
name|sub
parameter_list|)
block|{
return|return
operator|(
name|NEXT_OBJECT_OID
argument_list|(
operator|&
name|t
operator|->
name|table
argument_list|,
name|idx
argument_list|,
name|sub
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return first port  */
end_comment

begin_function
name|struct
name|tport
modifier|*
name|trans_first_port
parameter_list|(
name|struct
name|transport
modifier|*
name|t
parameter_list|)
block|{
return|return
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|t
operator|->
name|table
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate through all ports until a function returns a 0.  */
end_comment

begin_function
name|struct
name|tport
modifier|*
name|trans_iter_port
parameter_list|(
name|struct
name|transport
modifier|*
name|t
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|tport
modifier|*
parameter_list|,
name|intptr_t
parameter_list|)
parameter_list|,
name|intptr_t
name|arg
parameter_list|)
block|{
name|struct
name|tport
modifier|*
name|p
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&t->table
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|func
argument_list|(
name|p
argument_list|,
name|arg
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|p
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Register a transport  */
end_comment

begin_function
name|int
name|trans_register
parameter_list|(
specifier|const
name|struct
name|transport_def
modifier|*
name|def
parameter_list|,
name|struct
name|transport
modifier|*
modifier|*
name|pp
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|char
name|or_descr
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|pp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|pp
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|SNMP_ERR_GENERR
operator|)
return|;
comment|/* construct index */
operator|(
operator|*
name|pp
operator|)
operator|->
name|index
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|def
operator|->
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|->
name|index
operator|.
name|subs
index|[
literal|0
index|]
operator|=
name|strlen
argument_list|(
name|def
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
operator|*
name|pp
operator|)
operator|->
name|index
operator|.
name|subs
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
operator|(
operator|*
name|pp
operator|)
operator|->
name|index
operator|.
name|subs
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|def
operator|->
name|name
index|[
name|i
index|]
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|->
name|vtab
operator|=
name|def
expr_stmt|;
if|if
condition|(
name|FIND_OBJECT_OID
argument_list|(
operator|&
name|transport_list
argument_list|,
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|index
argument_list|,
literal|0
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_ERR_INCONS_VALUE
operator|)
return|;
block|}
comment|/* register module */
name|snprintf
argument_list|(
name|or_descr
argument_list|,
sizeof|sizeof
argument_list|(
name|or_descr
argument_list|)
argument_list|,
literal|"%s transport mapping"
argument_list|,
name|def
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|or_index
operator|=
name|or_register
argument_list|(
operator|&
name|def
operator|->
name|id
argument_list|,
name|or_descr
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_ERR_GENERR
operator|)
return|;
block|}
name|INSERT_OBJECT_OID
argument_list|(
operator|(
operator|*
name|pp
operator|)
argument_list|,
operator|&
name|transport_list
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|table
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_ERR_NOERROR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unregister transport  */
end_comment

begin_function
name|int
name|trans_unregister
parameter_list|(
name|struct
name|transport
modifier|*
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|t
operator|->
name|table
argument_list|)
condition|)
return|return
operator|(
name|SNMP_ERR_INCONS_VALUE
operator|)
return|;
name|or_unregister
argument_list|(
name|t
operator|->
name|or_index
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|transport_list
argument_list|,
name|t
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_ERR_NOERROR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * File descriptor support  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LIBBEGEMOT
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|input
argument_list|(
name|int
name|fd
argument_list|,
name|int
name|mask
name|__unused
argument_list|,
name|void
operator|*
name|uap
argument_list|)
else|#
directive|else
decl|static
name|void
name|input
argument_list|(
name|evContext
name|ctx
name|__unused
argument_list|,
name|void
operator|*
name|uap
argument_list|,
name|int
name|fd
argument_list|,
name|int
name|mask
name|__unused
argument_list|)
endif|#
directive|endif
block|{
name|struct
name|fdesc
modifier|*
name|f
init|=
name|uap
decl_stmt|;
call|(
modifier|*
name|f
operator|->
name|func
call|)
argument_list|(
name|fd
argument_list|,
name|f
operator|->
name|udata
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|void
name|fd_suspend
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|fdesc
modifier|*
name|f
init|=
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_LIBBEGEMOT
if|if
condition|(
name|f
operator|->
name|id
operator|>=
literal|0
condition|)
block|{
name|poll_unregister
argument_list|(
name|f
operator|->
name|id
argument_list|)
expr_stmt|;
name|f
operator|->
name|id
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|evTestID
argument_list|(
name|f
operator|->
name|id
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|evDeselectFD
argument_list|(
name|evctx
argument_list|,
name|f
operator|->
name|id
argument_list|)
expr_stmt|;
name|evInitID
argument_list|(
operator|&
name|f
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|fd_resume
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|fdesc
modifier|*
name|f
init|=
name|p
decl_stmt|;
name|int
name|err
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_LIBBEGEMOT
if|if
condition|(
name|f
operator|->
name|id
operator|>=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|f
operator|->
name|id
operator|=
name|poll_register
argument_list|(
name|f
operator|->
name|fd
argument_list|,
name|input
argument_list|,
name|f
argument_list|,
name|POLL_IN
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|err
operator|=
name|errno
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"select fd %d: %m"
argument_list|,
name|f
operator|->
name|fd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|err
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|#
directive|else
if|if
condition|(
name|evTestID
argument_list|(
name|f
operator|->
name|id
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|evSelectFD
argument_list|(
name|evctx
argument_list|,
name|f
operator|->
name|fd
argument_list|,
name|EV_READ
argument_list|,
name|input
argument_list|,
name|f
argument_list|,
operator|&
name|f
operator|->
name|id
argument_list|)
condition|)
block|{
name|err
operator|=
name|errno
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"select fd %d: %m"
argument_list|,
name|f
operator|->
name|fd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|err
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|fd_select
parameter_list|(
name|int
name|fd
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|,
name|struct
name|lmodule
modifier|*
name|mod
parameter_list|)
block|{
name|struct
name|fdesc
modifier|*
name|f
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fdesc
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|errno
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fd_select: %m"
argument_list|)
expr_stmt|;
name|errno
operator|=
name|err
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|f
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|f
operator|->
name|func
operator|=
name|func
expr_stmt|;
name|f
operator|->
name|udata
operator|=
name|udata
expr_stmt|;
name|f
operator|->
name|owner
operator|=
name|mod
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_LIBBEGEMOT
name|f
operator|->
name|id
operator|=
operator|-
literal|1
expr_stmt|;
else|#
directive|else
name|evInitID
argument_list|(
operator|&
name|f
operator|->
name|id
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fd_resume
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|err
operator|=
name|errno
expr_stmt|;
name|free
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|errno
operator|=
name|err
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|fdesc_list
argument_list|,
name|f
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_function
name|void
name|fd_deselect
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|fdesc
modifier|*
name|f
init|=
name|p
decl_stmt|;
name|LIST_REMOVE
argument_list|(
name|f
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|fd_suspend
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fd_flush
parameter_list|(
name|struct
name|lmodule
modifier|*
name|mod
parameter_list|)
block|{
name|struct
name|fdesc
modifier|*
name|t
decl_stmt|,
modifier|*
name|t1
decl_stmt|;
name|t
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|fdesc_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|t
operator|!=
name|NULL
condition|)
block|{
name|t1
operator|=
name|LIST_NEXT
argument_list|(
name|t
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|owner
operator|==
name|mod
condition|)
name|fd_deselect
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|t1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Consume a message from the input buffer  */
end_comment

begin_function
specifier|static
name|void
name|snmp_input_consume
parameter_list|(
name|struct
name|port_input
modifier|*
name|pi
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pi
operator|->
name|stream
condition|)
block|{
comment|/* always consume everything */
name|pi
operator|->
name|length
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pi
operator|->
name|consumed
operator|>=
name|pi
operator|->
name|length
condition|)
block|{
comment|/* all bytes consumed */
name|pi
operator|->
name|length
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|memmove
argument_list|(
name|pi
operator|->
name|buf
argument_list|,
name|pi
operator|->
name|buf
operator|+
name|pi
operator|->
name|consumed
argument_list|,
name|pi
operator|->
name|length
operator|-
name|pi
operator|->
name|consumed
argument_list|)
expr_stmt|;
name|pi
operator|->
name|length
operator|-=
name|pi
operator|->
name|consumed
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|credmsg
block|{
name|struct
name|cmsghdr
name|hdr
decl_stmt|;
name|struct
name|cmsgcred
name|cred
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|check_priv
parameter_list|(
name|struct
name|port_input
modifier|*
name|pi
parameter_list|,
name|struct
name|msghdr
modifier|*
name|msg
parameter_list|)
block|{
name|struct
name|credmsg
modifier|*
name|cmsg
decl_stmt|;
name|struct
name|xucred
name|ucred
decl_stmt|;
name|socklen_t
name|ucredlen
decl_stmt|;
name|pi
operator|->
name|priv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|msg_controllen
operator|==
sizeof|sizeof
argument_list|(
operator|*
name|cmsg
argument_list|)
condition|)
block|{
comment|/* process explicitly sends credentials */
name|cmsg
operator|=
operator|(
expr|struct
name|credmsg
operator|*
operator|)
name|msg
operator|->
name|msg_control
expr_stmt|;
name|pi
operator|->
name|priv
operator|=
operator|(
name|cmsg
operator|->
name|cred
operator|.
name|cmcred_euid
operator|==
literal|0
operator|)
expr_stmt|;
return|return;
block|}
comment|/* ok, obtain the accept time credentials */
name|ucredlen
operator|=
sizeof|sizeof
argument_list|(
name|ucred
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockopt
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
literal|0
argument_list|,
name|LOCAL_PEERCRED
argument_list|,
operator|&
name|ucred
argument_list|,
operator|&
name|ucredlen
argument_list|)
operator|==
literal|0
operator|&&
name|ucredlen
operator|>=
sizeof|sizeof
argument_list|(
name|ucred
argument_list|)
operator|&&
name|ucred
operator|.
name|cr_version
operator|==
name|XUCRED_VERSION
condition|)
name|pi
operator|->
name|priv
operator|=
operator|(
name|ucred
operator|.
name|cr_uid
operator|==
literal|0
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Input from a stream socket.  */
end_comment

begin_function
specifier|static
name|int
name|recv_stream
parameter_list|(
name|struct
name|port_input
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|msghdr
name|msg
decl_stmt|;
name|struct
name|iovec
name|iov
index|[
literal|1
index|]
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
name|struct
name|credmsg
name|cmsg
decl_stmt|;
if|if
condition|(
name|pi
operator|->
name|buf
operator|==
name|NULL
condition|)
block|{
comment|/* no buffer yet - allocate one */
if|if
condition|(
operator|(
name|pi
operator|->
name|buf
operator|=
name|buf_alloc
argument_list|(
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* ups - could not get buffer. Return an error 			 * the caller must close the transport. */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pi
operator|->
name|buflen
operator|=
name|buf_size
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pi
operator|->
name|consumed
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|length
operator|=
literal|0
expr_stmt|;
block|}
comment|/* try to get a message */
name|msg
operator|.
name|msg_name
operator|=
name|pi
operator|->
name|peer
expr_stmt|;
name|msg
operator|.
name|msg_namelen
operator|=
name|pi
operator|->
name|peerlen
expr_stmt|;
name|msg
operator|.
name|msg_iov
operator|=
name|iov
expr_stmt|;
name|msg
operator|.
name|msg_iovlen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|cred
condition|)
block|{
name|msg
operator|.
name|msg_control
operator|=
operator|&
name|cmsg
expr_stmt|;
name|msg
operator|.
name|msg_controllen
operator|=
sizeof|sizeof
argument_list|(
name|cmsg
argument_list|)
expr_stmt|;
name|cmsg
operator|.
name|hdr
operator|.
name|cmsg_len
operator|=
sizeof|sizeof
argument_list|(
name|cmsg
argument_list|)
expr_stmt|;
name|cmsg
operator|.
name|hdr
operator|.
name|cmsg_level
operator|=
name|SOL_SOCKET
expr_stmt|;
name|cmsg
operator|.
name|hdr
operator|.
name|cmsg_type
operator|=
name|SCM_CREDS
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|.
name|msg_control
operator|=
name|NULL
expr_stmt|;
name|msg
operator|.
name|msg_controllen
operator|=
literal|0
expr_stmt|;
block|}
name|msg
operator|.
name|msg_flags
operator|=
literal|0
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
name|pi
operator|->
name|buf
operator|+
name|pi
operator|->
name|length
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|pi
operator|->
name|buflen
operator|-
name|pi
operator|->
name|length
expr_stmt|;
name|len
operator|=
name|recvmsg
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
operator|&
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
operator|||
name|len
operator|==
literal|0
condition|)
comment|/* receive error */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|pi
operator|->
name|length
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|cred
condition|)
name|check_priv
argument_list|(
name|pi
argument_list|,
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Input from a datagram socket.  * Each receive should return one datagram.  */
end_comment

begin_function
specifier|static
name|int
name|recv_dgram
parameter_list|(
name|struct
name|port_input
modifier|*
name|pi
parameter_list|)
block|{
name|u_char
name|embuf
index|[
literal|1000
index|]
decl_stmt|;
name|struct
name|msghdr
name|msg
decl_stmt|;
name|struct
name|iovec
name|iov
index|[
literal|1
index|]
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
name|struct
name|credmsg
name|cmsg
decl_stmt|;
if|if
condition|(
name|pi
operator|->
name|buf
operator|==
name|NULL
condition|)
block|{
comment|/* no buffer yet - allocate one */
if|if
condition|(
operator|(
name|pi
operator|->
name|buf
operator|=
name|buf_alloc
argument_list|(
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* ups - could not get buffer. Read away input 			 * and drop it */
operator|(
name|void
operator|)
name|recvfrom
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|embuf
argument_list|,
sizeof|sizeof
argument_list|(
name|embuf
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* return error */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pi
operator|->
name|buflen
operator|=
name|buf_size
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* try to get a message */
name|msg
operator|.
name|msg_name
operator|=
name|pi
operator|->
name|peer
expr_stmt|;
name|msg
operator|.
name|msg_namelen
operator|=
name|pi
operator|->
name|peerlen
expr_stmt|;
name|msg
operator|.
name|msg_iov
operator|=
name|iov
expr_stmt|;
name|msg
operator|.
name|msg_iovlen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|cred
condition|)
block|{
name|msg
operator|.
name|msg_control
operator|=
operator|&
name|cmsg
expr_stmt|;
name|msg
operator|.
name|msg_controllen
operator|=
sizeof|sizeof
argument_list|(
name|cmsg
argument_list|)
expr_stmt|;
name|cmsg
operator|.
name|hdr
operator|.
name|cmsg_len
operator|=
sizeof|sizeof
argument_list|(
name|cmsg
argument_list|)
expr_stmt|;
name|cmsg
operator|.
name|hdr
operator|.
name|cmsg_level
operator|=
name|SOL_SOCKET
expr_stmt|;
name|cmsg
operator|.
name|hdr
operator|.
name|cmsg_type
operator|=
name|SCM_CREDS
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|.
name|msg_control
operator|=
name|NULL
expr_stmt|;
name|msg
operator|.
name|msg_controllen
operator|=
literal|0
expr_stmt|;
block|}
name|msg
operator|.
name|msg_flags
operator|=
literal|0
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
name|pi
operator|->
name|buf
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|pi
operator|->
name|buflen
expr_stmt|;
name|len
operator|=
name|recvmsg
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
operator|&
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
operator|||
name|len
operator|==
literal|0
condition|)
comment|/* receive error */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|msg
operator|.
name|msg_flags
operator|&
name|MSG_TRUNC
condition|)
block|{
comment|/* truncated - drop */
name|snmpd_stats
operator|.
name|silentDrops
operator|++
expr_stmt|;
name|snmpd_stats
operator|.
name|inTooLong
operator|++
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pi
operator|->
name|length
operator|=
operator|(
name|size_t
operator|)
name|len
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|cred
condition|)
name|check_priv
argument_list|(
name|pi
argument_list|,
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Input from a socket  */
end_comment

begin_function
name|int
name|snmpd_input
parameter_list|(
name|struct
name|port_input
modifier|*
name|pi
parameter_list|,
name|struct
name|tport
modifier|*
name|tport
parameter_list|)
block|{
name|u_char
modifier|*
name|sndbuf
decl_stmt|;
name|size_t
name|sndlen
decl_stmt|;
name|struct
name|snmp_pdu
name|pdu
decl_stmt|;
name|enum
name|snmpd_input_err
name|ierr
decl_stmt|,
name|ferr
decl_stmt|;
name|enum
name|snmpd_proxy_err
name|perr
decl_stmt|;
name|int32_t
name|vi
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ssize_t
name|slen
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_TCPWRAPPERS
name|char
name|client
index|[
literal|16
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* get input depending on the transport */
if|if
condition|(
name|pi
operator|->
name|stream
condition|)
block|{
name|ret
operator|=
name|recv_stream
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|recv_dgram
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|USE_TCPWRAPPERS
comment|/* 	 * In case of AF_INET{6} peer, do hosts_access(5) check. 	 */
if|if
condition|(
name|inet_ntop
argument_list|(
name|pi
operator|->
name|peer
operator|->
name|sa_family
argument_list|,
operator|&
operator|(
operator|(
specifier|const
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
specifier|const
name|void
operator|*
operator|)
name|pi
operator|->
name|peer
operator|)
operator|->
name|sin_addr
argument_list|,
name|client
argument_list|,
sizeof|sizeof
argument_list|(
name|client
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|request_set
argument_list|(
operator|&
name|req
argument_list|,
name|RQ_CLIENT_ADDR
argument_list|,
name|client
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hosts_access
argument_list|(
operator|&
name|req
argument_list|)
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"refused connection from %.500s"
argument_list|,
name|eval_client
argument_list|(
operator|&
name|req
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"inet_ntop(): %m"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Handle input 	 */
name|ierr
operator|=
name|snmp_input_start
argument_list|(
name|pi
operator|->
name|buf
argument_list|,
name|pi
operator|->
name|length
argument_list|,
literal|"SNMP"
argument_list|,
operator|&
name|pdu
argument_list|,
operator|&
name|vi
argument_list|,
operator|&
name|pi
operator|->
name|consumed
argument_list|)
expr_stmt|;
if|if
condition|(
name|ierr
operator|==
name|SNMPD_INPUT_TRUNC
condition|)
block|{
comment|/* need more bytes. This is ok only for streaming transports. 		 * but only if we have not reached bufsiz yet. */
if|if
condition|(
name|pi
operator|->
name|stream
condition|)
block|{
if|if
condition|(
name|pi
operator|->
name|length
operator|==
name|buf_size
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|snmpd_stats
operator|.
name|silentDrops
operator|++
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|snmpd_stats
operator|.
name|silentDrops
operator|++
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* can't check for bad SET pdus here, because a proxy may have to 	 * check the access first. We don't want to return an error response 	 * to a proxy PDU with a wrong community */
if|if
condition|(
name|ierr
operator|==
name|SNMPD_INPUT_FAILED
condition|)
block|{
comment|/* for streaming transports this is fatal */
if|if
condition|(
name|pi
operator|->
name|stream
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|snmp_input_consume
argument_list|(
name|pi
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ierr
operator|==
name|SNMPD_INPUT_BAD_COMM
condition|)
block|{
name|snmp_input_consume
argument_list|(
name|pi
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If that is a module community and the module has a proxy function, 	 * the hand it over to the module. 	 */
if|if
condition|(
name|comm
operator|->
name|owner
operator|!=
name|NULL
operator|&&
name|comm
operator|->
name|owner
operator|->
name|config
operator|->
name|proxy
operator|!=
name|NULL
condition|)
block|{
name|perr
operator|=
call|(
modifier|*
name|comm
operator|->
name|owner
operator|->
name|config
operator|->
name|proxy
call|)
argument_list|(
operator|&
name|pdu
argument_list|,
name|tport
operator|->
name|transport
argument_list|,
operator|&
name|tport
operator|->
name|index
argument_list|,
name|pi
operator|->
name|peer
argument_list|,
name|pi
operator|->
name|peerlen
argument_list|,
name|ierr
argument_list|,
name|vi
argument_list|,
operator|!
name|pi
operator|->
name|cred
operator|||
name|pi
operator|->
name|priv
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|perr
condition|)
block|{
case|case
name|SNMPD_PROXY_OK
case|:
name|snmp_input_consume
argument_list|(
name|pi
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|SNMPD_PROXY_REJ
case|:
break|break;
case|case
name|SNMPD_PROXY_DROP
case|:
name|snmp_input_consume
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|snmp_pdu_free
argument_list|(
operator|&
name|pdu
argument_list|)
expr_stmt|;
name|snmpd_stats
operator|.
name|proxyDrops
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|SNMPD_PROXY_BADCOMM
case|:
name|snmp_input_consume
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|snmp_pdu_free
argument_list|(
operator|&
name|pdu
argument_list|)
expr_stmt|;
name|snmpd_stats
operator|.
name|inBadCommunityNames
operator|++
expr_stmt|;
if|if
condition|(
name|snmpd
operator|.
name|auth_traps
condition|)
name|snmp_send_trap
argument_list|(
operator|&
name|oid_authenticationFailure
argument_list|,
operator|(
expr|struct
name|snmp_value
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|SNMPD_PROXY_BADCOMMUSE
case|:
name|snmp_input_consume
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|snmp_pdu_free
argument_list|(
operator|&
name|pdu
argument_list|)
expr_stmt|;
name|snmpd_stats
operator|.
name|inBadCommunityUses
operator|++
expr_stmt|;
if|if
condition|(
name|snmpd
operator|.
name|auth_traps
condition|)
name|snmp_send_trap
argument_list|(
operator|&
name|oid_authenticationFailure
argument_list|,
operator|(
expr|struct
name|snmp_value
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * Check type 	 */
if|if
condition|(
name|pdu
operator|.
name|type
operator|==
name|SNMP_PDU_RESPONSE
operator|||
name|pdu
operator|.
name|type
operator|==
name|SNMP_PDU_TRAP
operator|||
name|pdu
operator|.
name|type
operator|==
name|SNMP_PDU_TRAP2
condition|)
block|{
name|snmpd_stats
operator|.
name|silentDrops
operator|++
expr_stmt|;
name|snmpd_stats
operator|.
name|inBadPduTypes
operator|++
expr_stmt|;
name|snmp_pdu_free
argument_list|(
operator|&
name|pdu
argument_list|)
expr_stmt|;
name|snmp_input_consume
argument_list|(
name|pi
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Check community 	 */
if|if
condition|(
operator|(
name|pi
operator|->
name|cred
operator|&&
operator|!
name|pi
operator|->
name|priv
operator|&&
name|pdu
operator|.
name|type
operator|==
name|SNMP_PDU_SET
operator|)
operator|||
operator|(
name|community
operator|!=
name|COMM_WRITE
operator|&&
operator|(
name|pdu
operator|.
name|type
operator|==
name|SNMP_PDU_SET
operator|||
name|community
operator|!=
name|COMM_READ
operator|)
operator|)
condition|)
block|{
name|snmpd_stats
operator|.
name|inBadCommunityUses
operator|++
expr_stmt|;
name|snmp_pdu_free
argument_list|(
operator|&
name|pdu
argument_list|)
expr_stmt|;
name|snmp_input_consume
argument_list|(
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|snmpd
operator|.
name|auth_traps
condition|)
name|snmp_send_trap
argument_list|(
operator|&
name|oid_authenticationFailure
argument_list|,
operator|(
expr|struct
name|snmp_value
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Execute it. 	 */
if|if
condition|(
operator|(
name|sndbuf
operator|=
name|buf_alloc
argument_list|(
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|snmpd_stats
operator|.
name|silentDrops
operator|++
expr_stmt|;
name|snmp_pdu_free
argument_list|(
operator|&
name|pdu
argument_list|)
expr_stmt|;
name|snmp_input_consume
argument_list|(
name|pi
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ferr
operator|=
name|snmp_input_finish
argument_list|(
operator|&
name|pdu
argument_list|,
name|pi
operator|->
name|buf
argument_list|,
name|pi
operator|->
name|length
argument_list|,
name|sndbuf
argument_list|,
operator|&
name|sndlen
argument_list|,
literal|"SNMP"
argument_list|,
name|ierr
argument_list|,
name|vi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferr
operator|==
name|SNMPD_INPUT_OK
condition|)
block|{
name|slen
operator|=
name|sendto
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|sndbuf
argument_list|,
name|sndlen
argument_list|,
literal|0
argument_list|,
name|pi
operator|->
name|peer
argument_list|,
name|pi
operator|->
name|peerlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|slen
operator|==
operator|-
literal|1
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sendto: %m"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|size_t
operator|)
name|slen
operator|!=
name|sndlen
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sendto: short write %zu/%zu"
argument_list|,
name|sndlen
argument_list|,
operator|(
name|size_t
operator|)
name|slen
argument_list|)
expr_stmt|;
block|}
name|snmp_pdu_free
argument_list|(
operator|&
name|pdu
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sndbuf
argument_list|)
expr_stmt|;
name|snmp_input_consume
argument_list|(
name|pi
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a PDU to a given port  */
end_comment

begin_function
name|void
name|snmp_send_port
parameter_list|(
name|void
modifier|*
name|targ
parameter_list|,
specifier|const
name|struct
name|asn_oid
modifier|*
name|port
parameter_list|,
name|struct
name|snmp_pdu
modifier|*
name|pdu
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|)
block|{
name|struct
name|transport
modifier|*
name|trans
init|=
name|targ
decl_stmt|;
name|struct
name|tport
modifier|*
name|tp
decl_stmt|;
name|u_char
modifier|*
name|sndbuf
decl_stmt|;
name|size_t
name|sndlen
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tp
argument_list|,
argument|&trans->table
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|asn_compare_oid
argument_list|(
name|port
argument_list|,
operator|&
name|tp
operator|->
name|index
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|tp
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|sndbuf
operator|=
name|buf_alloc
argument_list|(
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|snmp_output
argument_list|(
name|pdu
argument_list|,
name|sndbuf
argument_list|,
operator|&
name|sndlen
argument_list|,
literal|"SNMP PROXY"
argument_list|)
expr_stmt|;
name|len
operator|=
name|trans
operator|->
name|vtab
operator|->
name|send
argument_list|(
name|tp
argument_list|,
name|sndbuf
argument_list|,
name|sndlen
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sendto: %m"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|size_t
operator|)
name|len
operator|!=
name|sndlen
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sendto: short write %zu/%zu"
argument_list|,
name|sndlen
argument_list|,
operator|(
name|size_t
operator|)
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sndbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Close an input source  */
end_comment

begin_function
name|void
name|snmpd_input_close
parameter_list|(
name|struct
name|port_input
modifier|*
name|pi
parameter_list|)
block|{
if|if
condition|(
name|pi
operator|->
name|id
operator|!=
name|NULL
condition|)
name|fd_deselect
argument_list|(
name|pi
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|fd
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|pi
operator|->
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|pi
operator|->
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dump internal state.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LIBBEGEMOT
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|info_func
argument_list|(
name|void
argument_list|)
else|#
directive|else
decl|static
name|void
name|info_func
argument_list|(
name|evContext
name|ctx
name|__unused
argument_list|,
name|void
operator|*
name|uap
name|__unused
argument_list|,
specifier|const
name|void
operator|*
name|tag
name|__unused
argument_list|)
endif|#
directive|endif
block|{
name|struct
name|lmodule
modifier|*
name|m
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|10000
index|]
decl_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Dump of SNMPd %lu\n"
argument_list|,
operator|(
name|u_long
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tree_size
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|tree
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|SNMP_NODE_LEAF
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"LEAF: %s %s"
argument_list|,
name|tree
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|asn_oid2str
argument_list|(
operator|&
name|tree
index|[
name|i
index|]
operator|.
name|oid
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNMP_NODE_COLUMN
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"COL: %s %s"
argument_list|,
name|tree
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|asn_oid2str
argument_list|(
operator|&
name|tree
index|[
name|i
index|]
operator|.
name|oid
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|m
argument_list|,
argument|&lmodules
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|m
operator|->
name|config
operator|->
name|dump
condition|)
call|(
modifier|*
name|m
operator|->
name|config
operator|->
name|dump
call|)
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Re-read configuration  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LIBBEGEMOT
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|config_func
argument_list|(
name|void
argument_list|)
else|#
directive|else
decl|static
name|void
name|config_func
argument_list|(
name|evContext
name|ctx
name|__unused
argument_list|,
name|void
operator|*
name|uap
name|__unused
argument_list|,
specifier|const
name|void
operator|*
name|tag
name|__unused
argument_list|)
endif|#
directive|endif
block|{
name|struct
name|lmodule
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|read_config
argument_list|(
name|config_file
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"error reading config file '%s'"
argument_list|,
name|config_file
argument_list|)
expr_stmt|;
return|return;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|m
argument_list|,
argument|&lmodules
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|m
operator|->
name|config
operator|->
name|config
condition|)
call|(
modifier|*
name|m
operator|->
name|config
operator|->
name|config
call|)
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * On USR1 dump actual configuration.  */
end_comment

begin_function
specifier|static
name|void
name|onusr1
parameter_list|(
name|int
name|s
name|__unused
parameter_list|)
block|{
name|work
operator||=
name|WORK_DOINFO
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|onhup
parameter_list|(
name|int
name|s
name|__unused
parameter_list|)
block|{
name|work
operator||=
name|WORK_RECONFIG
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|onterm
parameter_list|(
name|int
name|s
name|__unused
parameter_list|)
block|{
comment|/* allow clean-up */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_sigs
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sigaction
name|sa
decl_stmt|;
name|sa
operator|.
name|sa_handler
operator|=
name|onusr1
expr_stmt|;
name|sa
operator|.
name|sa_flags
operator|=
name|SA_RESTART
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sa
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|SIGUSR1
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sigaction: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|sa
operator|.
name|sa_handler
operator|=
name|onhup
expr_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|SIGHUP
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sigaction: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|sa
operator|.
name|sa_handler
operator|=
name|onterm
expr_stmt|;
name|sa
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sa
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|SIGTERM
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sigaction: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sigaction: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|block_sigs
parameter_list|(
name|void
parameter_list|)
block|{
name|sigset_t
name|set
decl_stmt|;
name|sigfillset
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|set
argument_list|,
operator|&
name|blocked_sigs
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"SIG_BLOCK: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|unblock_sigs
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|blocked_sigs
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"SIG_SETMASK: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Shut down  */
end_comment

begin_function
specifier|static
name|void
name|term
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|pid_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|trans_stop
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|transport
modifier|*
name|t
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|t
argument_list|,
argument|&transport_list
argument_list|,
argument|link
argument_list|)
operator|(
name|void
operator|)
name|t
operator|->
name|vtab
operator|->
name|stop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Define a macro from the command line  */
end_comment

begin_function
specifier|static
name|void
name|do_macro
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|char
modifier|*
name|eq
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|eq
operator|=
name|strchr
argument_list|(
name|arg
argument_list|,
literal|'='
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
operator|=
name|define_macro
argument_list|(
name|arg
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|eq
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|err
operator|=
name|define_macro
argument_list|(
name|arg
argument_list|,
name|eq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot save macro: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Re-implement getsubopt from scratch, because the second argument is broken  * and will not compile with WARNS=5.  */
end_comment

begin_function
specifier|static
name|int
name|getsubopt1
parameter_list|(
name|char
modifier|*
modifier|*
name|arg
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|options
parameter_list|,
name|char
modifier|*
modifier|*
name|valp
parameter_list|,
name|char
modifier|*
modifier|*
name|optp
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|delim
init|=
literal|",\t "
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
operator|*
name|optp
operator|=
name|NULL
expr_stmt|;
comment|/* skip leading junk */
for|for
control|(
name|ptr
operator|=
operator|*
name|arg
init|;
operator|*
name|ptr
operator|!=
literal|'\0'
condition|;
name|ptr
operator|++
control|)
if|if
condition|(
name|strchr
argument_list|(
name|delim
argument_list|,
operator|*
name|ptr
argument_list|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|arg
operator|=
name|ptr
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|optp
operator|=
name|ptr
expr_stmt|;
comment|/* find the end of the option */
while|while
condition|(
operator|*
operator|++
name|ptr
operator|!=
literal|'\0'
condition|)
if|if
condition|(
name|strchr
argument_list|(
name|delim
argument_list|,
operator|*
name|ptr
argument_list|)
operator|!=
name|NULL
operator|||
operator|*
name|ptr
operator|==
literal|'='
condition|)
break|break;
if|if
condition|(
operator|*
name|ptr
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'='
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|valp
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|!=
literal|'\0'
operator|&&
name|strchr
argument_list|(
name|delim
argument_list|,
operator|*
name|ptr
argument_list|)
operator|==
name|NULL
condition|)
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|!=
literal|'\0'
condition|)
operator|*
name|ptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
operator|*
name|ptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|*
name|arg
operator|=
name|ptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|options
operator|!=
name|NULL
condition|;
name|options
operator|++
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|optp
argument_list|,
operator|*
name|options
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|i
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|opt
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|background
init|=
literal|1
decl_stmt|;
name|struct
name|tport
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
init|=
literal|"snmpd"
decl_stmt|;
name|struct
name|lmodule
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|,
modifier|*
name|option
decl_stmt|;
name|struct
name|transport
modifier|*
name|t
decl_stmt|;
define|#
directive|define
name|DBG_DUMP
value|0
define|#
directive|define
name|DBG_EVENTS
value|1
define|#
directive|define
name|DBG_TRACE
value|2
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|debug_opts
index|[]
init|=
block|{
literal|"dump"
block|,
literal|"events"
block|,
literal|"trace"
block|,
name|NULL
block|}
decl_stmt|;
name|snmp_printf
operator|=
name|snmp_printf_func
expr_stmt|;
name|snmp_error
operator|=
name|snmp_error_func
expr_stmt|;
name|snmp_debug
operator|=
name|snmp_debug_func
expr_stmt|;
name|asn_error
operator|=
name|asn_error_func
expr_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"c:dD:hI:l:m:p:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'c'
case|:
name|strlcpy
argument_list|(
name|config_file
argument_list|,
name|optarg
argument_list|,
sizeof|sizeof
argument_list|(
name|config_file
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|background
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
while|while
condition|(
operator|*
name|optarg
condition|)
block|{
switch|switch
condition|(
name|getsubopt1
argument_list|(
operator|&
name|optarg
argument_list|,
name|debug_opts
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|option
argument_list|)
condition|)
block|{
case|case
name|DBG_DUMP
case|:
name|debug
operator|.
name|dump_pdus
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DBG_EVENTS
case|:
name|debug
operator|.
name|evdebug
operator|++
expr_stmt|;
break|break;
case|case
name|DBG_TRACE
case|:
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no value for 'trace'"
argument_list|)
expr_stmt|;
else|else
name|snmp_trace
operator|=
name|strtoul
argument_list|(
name|value
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
if|if
condition|(
name|suboptarg
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unknown debug flag '%s'"
argument_list|,
name|option
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"missing debug flag"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
literal|'h'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|usgtxt
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'I'
case|:
name|syspath
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|prefix
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|do_macro
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|strlcpy
argument_list|(
name|pid_file
argument_list|,
name|optarg
argument_list|,
sizeof|sizeof
argument_list|(
name|pid_file
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|openlog
argument_list|(
name|prefix
argument_list|,
name|LOG_PID
operator||
operator|(
name|background
condition|?
literal|0
else|:
name|LOG_PERROR
operator|)
argument_list|,
name|LOG_USER
argument_list|)
expr_stmt|;
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|debug
operator|.
name|logpri
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|background
operator|&&
name|daemon
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"daemon: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
name|progargs
operator|=
name|argv
expr_stmt|;
name|nprogargs
operator|=
name|argc
expr_stmt|;
name|srandomdev
argument_list|()
expr_stmt|;
name|snmp_serial_no
operator|=
name|random
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_TCPWRAPPERS
comment|/* 	 * Initialize hosts_access(3) handler. 	 */
name|request_init
argument_list|(
operator|&
name|req
argument_list|,
name|RQ_DAEMON
argument_list|,
literal|"snmpd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sock_methods
argument_list|(
operator|&
name|req
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Initialize the tree. 	 */
if|if
condition|(
operator|(
name|tree
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|snmp_node
argument_list|)
operator|*
name|CTREE_SIZE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|tree
argument_list|,
name|ctree
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|snmp_node
argument_list|)
operator|*
name|CTREE_SIZE
argument_list|)
expr_stmt|;
name|tree_size
operator|=
name|CTREE_SIZE
expr_stmt|;
comment|/* 	 * Get standard communities 	 */
operator|(
name|void
operator|)
name|comm_define
argument_list|(
literal|1
argument_list|,
literal|"SNMP read"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|comm_define
argument_list|(
literal|2
argument_list|,
literal|"SNMP write"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|community
operator|=
name|COMM_INITIALIZE
expr_stmt|;
name|trap_reqid
operator|=
name|reqid_allocate
argument_list|(
literal|512
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_file
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|snprintf
argument_list|(
name|config_file
argument_list|,
sizeof|sizeof
argument_list|(
name|config_file
argument_list|)
argument_list|,
name|PATH_CONFIG
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|init_actvals
argument_list|()
expr_stmt|;
name|this_tick
operator|=
name|get_ticks
argument_list|()
expr_stmt|;
name|start_tick
operator|=
name|this_tick
expr_stmt|;
comment|/* start transports */
if|if
condition|(
name|atexit
argument_list|(
name|trans_stop
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"atexit failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|udp_trans
operator|.
name|start
argument_list|()
operator|!=
name|SNMP_ERR_NOERROR
condition|)
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"cannot start UDP transport"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsock_trans
operator|.
name|start
argument_list|()
operator|!=
name|SNMP_ERR_NOERROR
condition|)
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"cannot start LSOCK transport"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_LIBBEGEMOT
if|if
condition|(
name|debug
operator|.
name|evdebug
operator|>
literal|0
condition|)
name|rpoll_trace
operator|=
literal|1
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|evCreate
argument_list|(
operator|&
name|evctx
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"evCreate: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
operator|.
name|evdebug
operator|>
literal|0
condition|)
name|evSetDebug
argument_list|(
name|evctx
argument_list|,
literal|10
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|read_config
argument_list|(
name|config_file
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"error in config file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|t
argument_list|,
argument|&transport_list
argument_list|,
argument|link
argument_list|)
name|TAILQ_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&t->table
argument_list|,
argument|link
argument_list|)
name|t
operator|->
name|vtab
operator|->
name|init_port
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|init_sigs
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid_file
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|snprintf
argument_list|(
name|pid_file
argument_list|,
sizeof|sizeof
argument_list|(
name|pid_file
argument_list|)
argument_list|,
name|PATH_PID
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|pid_file
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%u"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|atexit
argument_list|(
name|term
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"atexit failed: %m"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|pid_file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|or_register
argument_list|(
operator|&
name|oid_snmpMIB
argument_list|,
literal|"The MIB module for SNMPv2 entities."
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot register SNMPv2 MIB"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|or_register
argument_list|(
operator|&
name|oid_begemotSnmpd
argument_list|,
literal|"The MIB module for the Begemot SNMPd."
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot register begemotSnmpd MIB"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|snmp_send_trap
argument_list|(
operator|&
name|oid_coldStart
argument_list|,
operator|(
expr|struct
name|snmp_value
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|modules_start
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|m
operator|->
name|flags
operator|&=
operator|~
name|LM_ONSTARTLIST
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|modules_start
argument_list|,
name|m
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|lm_start
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
ifndef|#
directive|ifndef
name|USE_LIBBEGEMOT
name|evEvent
name|event
decl_stmt|;
endif|#
directive|endif
name|struct
name|lmodule
modifier|*
name|mod
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|mod
argument_list|,
argument|&lmodules
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|mod
operator|->
name|config
operator|->
name|idle
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|mod
operator|->
name|config
operator|->
name|idle
call|)
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_LIBBEGEMOT
if|if
condition|(
name|evGetNext
argument_list|(
name|evctx
argument_list|,
operator|&
name|event
argument_list|,
name|EV_WAIT
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|evDispatch
argument_list|(
name|evctx
argument_list|,
name|event
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"evDispatch: %m"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"evGetNext: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|poll_dispatch
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|work
operator|!=
literal|0
condition|)
block|{
name|block_sigs
argument_list|()
expr_stmt|;
if|if
condition|(
name|work
operator|&
name|WORK_DOINFO
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_LIBBEGEMOT
name|info_func
argument_list|()
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|evWaitFor
argument_list|(
name|evctx
argument_list|,
operator|&
name|work
argument_list|,
name|info_func
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"evWaitFor: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|work
operator|&
name|WORK_RECONFIG
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_LIBBEGEMOT
name|config_func
argument_list|()
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|evWaitFor
argument_list|(
name|evctx
argument_list|,
operator|&
name|work
argument_list|,
name|config_func
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"evWaitFor: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|work
operator|=
literal|0
expr_stmt|;
name|unblock_sigs
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_LIBBEGEMOT
if|if
condition|(
name|evDo
argument_list|(
name|evctx
argument_list|,
operator|&
name|work
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"evDo: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|get_ticks
parameter_list|()
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|uint64_t
name|ret
decl_stmt|;
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ret
operator|=
name|tv
operator|.
name|tv_sec
operator|*
literal|100ULL
operator|+
name|tv
operator|.
name|tv_usec
operator|/
literal|10000ULL
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Timer support  */
end_comment

begin_comment
comment|/*  * Trampoline for the non-repeatable timers.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LIBBEGEMOT
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|tfunc
argument_list|(
name|int
name|tid
name|__unused
argument_list|,
name|void
operator|*
name|uap
argument_list|)
else|#
directive|else
decl|static
name|void
name|tfunc
argument_list|(
name|evContext
name|ctx
name|__unused
argument_list|,
name|void
operator|*
name|uap
argument_list|,
expr|struct
name|timespec
name|due
name|__unused
argument_list|,
expr|struct
name|timespec
name|inter
name|__unused
argument_list|)
endif|#
directive|endif
block|{
name|struct
name|timer
modifier|*
name|tp
init|=
name|uap
decl_stmt|;
name|LIST_REMOVE
argument_list|(
name|tp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|tp
operator|->
name|func
argument_list|(
name|tp
operator|->
name|udata
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Trampoline for the repeatable timers.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LIBBEGEMOT
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|trfunc
argument_list|(
name|int
name|tid
name|__unused
argument_list|,
name|void
operator|*
name|uap
argument_list|)
else|#
directive|else
decl|static
name|void
name|trfunc
argument_list|(
name|evContext
name|ctx
name|__unused
argument_list|,
name|void
operator|*
name|uap
argument_list|,
expr|struct
name|timespec
name|due
name|__unused
argument_list|,
expr|struct
name|timespec
name|inter
name|__unused
argument_list|)
endif|#
directive|endif
block|{
name|struct
name|timer
modifier|*
name|tp
init|=
name|uap
decl_stmt|;
name|tp
operator|->
name|func
argument_list|(
name|tp
operator|->
name|udata
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Start a one-shot timer  */
end_comment

begin_function
name|void
modifier|*
name|timer_start
parameter_list|(
name|u_int
name|ticks
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|,
name|struct
name|lmodule
modifier|*
name|mod
parameter_list|)
block|{
name|struct
name|timer
modifier|*
name|tp
decl_stmt|;
ifndef|#
directive|ifndef
name|USE_LIBBEGEMOT
name|struct
name|timespec
name|due
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|tp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|timer
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"out of memory for timer"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|USE_LIBBEGEMOT
name|due
operator|=
name|evAddTime
argument_list|(
name|evNowTime
argument_list|()
argument_list|,
name|evConsTime
argument_list|(
name|ticks
operator|/
literal|100
argument_list|,
operator|(
name|ticks
operator|%
literal|100
operator|)
operator|*
literal|10000
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tp
operator|->
name|udata
operator|=
name|udata
expr_stmt|;
name|tp
operator|->
name|owner
operator|=
name|mod
expr_stmt|;
name|tp
operator|->
name|func
operator|=
name|func
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|timer_list
argument_list|,
name|tp
argument_list|,
name|link
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_LIBBEGEMOT
if|if
condition|(
operator|(
name|tp
operator|->
name|id
operator|=
name|poll_start_timer
argument_list|(
name|ticks
operator|*
literal|10
argument_list|,
literal|0
argument_list|,
name|tfunc
argument_list|,
name|tp
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot set timer: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|evSetTimer
argument_list|(
name|evctx
argument_list|,
name|tfunc
argument_list|,
name|tp
argument_list|,
name|due
argument_list|,
name|evConsTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|tp
operator|->
name|id
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot set timer: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|tp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start a repeatable timer. When used with USE_LIBBEGEMOT the first argument  * is currently ignored and the initial number of ticks is set to the  * repeat number of ticks.  */
end_comment

begin_function
name|void
modifier|*
name|timer_start_repeat
parameter_list|(
name|u_int
name|ticks
name|__unused
parameter_list|,
name|u_int
name|repeat_ticks
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|,
name|struct
name|lmodule
modifier|*
name|mod
parameter_list|)
block|{
name|struct
name|timer
modifier|*
name|tp
decl_stmt|;
ifndef|#
directive|ifndef
name|USE_LIBBEGEMOT
name|struct
name|timespec
name|due
decl_stmt|;
name|struct
name|timespec
name|inter
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|tp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|timer
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"out of memory for timer"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|USE_LIBBEGEMOT
name|due
operator|=
name|evAddTime
argument_list|(
name|evNowTime
argument_list|()
argument_list|,
name|evConsTime
argument_list|(
name|ticks
operator|/
literal|100
argument_list|,
operator|(
name|ticks
operator|%
literal|100
operator|)
operator|*
literal|10000
argument_list|)
argument_list|)
expr_stmt|;
name|inter
operator|=
name|evConsTime
argument_list|(
name|repeat_ticks
operator|/
literal|100
argument_list|,
operator|(
name|repeat_ticks
operator|%
literal|100
operator|)
operator|*
literal|10000
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tp
operator|->
name|udata
operator|=
name|udata
expr_stmt|;
name|tp
operator|->
name|owner
operator|=
name|mod
expr_stmt|;
name|tp
operator|->
name|func
operator|=
name|func
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|timer_list
argument_list|,
name|tp
argument_list|,
name|link
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_LIBBEGEMOT
if|if
condition|(
operator|(
name|tp
operator|->
name|id
operator|=
name|poll_start_timer
argument_list|(
name|repeat_ticks
operator|*
literal|10
argument_list|,
literal|1
argument_list|,
name|trfunc
argument_list|,
name|tp
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot set timer: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|evSetTimer
argument_list|(
name|evctx
argument_list|,
name|trfunc
argument_list|,
name|tp
argument_list|,
name|due
argument_list|,
name|inter
argument_list|,
operator|&
name|tp
operator|->
name|id
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot set timer: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|tp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Stop a timer.  */
end_comment

begin_function
name|void
name|timer_stop
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|timer
modifier|*
name|tp
init|=
name|p
decl_stmt|;
name|LIST_REMOVE
argument_list|(
name|tp
argument_list|,
name|link
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_LIBBEGEMOT
name|poll_stop_timer
argument_list|(
name|tp
operator|->
name|id
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|evClearTimer
argument_list|(
name|evctx
argument_list|,
name|tp
operator|->
name|id
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot stop timer: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|timer_flush
parameter_list|(
name|struct
name|lmodule
modifier|*
name|mod
parameter_list|)
block|{
name|struct
name|timer
modifier|*
name|t
decl_stmt|,
modifier|*
name|t1
decl_stmt|;
name|t
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|timer_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|t
operator|!=
name|NULL
condition|)
block|{
name|t1
operator|=
name|LIST_NEXT
argument_list|(
name|t
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|owner
operator|==
name|mod
condition|)
name|timer_stop
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|t1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|snmp_printf_func
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
specifier|static
name|char
modifier|*
name|pend
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vasprintf
argument_list|(
operator|&
name|ret
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|pend
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|new
operator|=
name|realloc
argument_list|(
name|pend
argument_list|,
name|strlen
argument_list|(
name|pend
argument_list|)
operator|+
name|strlen
argument_list|(
name|ret
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return;
block|}
name|pend
operator|=
name|new
expr_stmt|;
name|strcat
argument_list|(
name|pend
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
else|else
name|pend
operator|=
name|ret
expr_stmt|;
while|while
condition|(
operator|(
name|ret
operator|=
name|strchr
argument_list|(
name|pend
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|ret
operator|=
literal|'\0'
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s"
argument_list|,
name|pend
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|ret
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|pend
argument_list|)
expr_stmt|;
name|pend
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|strcpy
argument_list|(
name|pend
argument_list|,
name|ret
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|snmp_error_func
parameter_list|(
specifier|const
name|char
modifier|*
name|err
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|errbuf
index|[
literal|1000
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|snmp_trace
operator|&
name|LOG_SNMP_ERRORS
operator|)
condition|)
return|return;
name|va_start
argument_list|(
name|ap
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
literal|"SNMP: "
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|errbuf
operator|+
name|strlen
argument_list|(
name|errbuf
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
operator|-
name|strlen
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|err
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s"
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|snmp_debug_func
parameter_list|(
specifier|const
name|char
modifier|*
name|err
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|errbuf
index|[
literal|1000
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
literal|"SNMP: "
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|errbuf
operator|+
name|strlen
argument_list|(
name|errbuf
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
operator|-
name|strlen
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|err
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s"
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|asn_error_func
parameter_list|(
specifier|const
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|err
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|errbuf
index|[
literal|1000
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|u_int
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|snmp_trace
operator|&
name|LOG_ASN1_ERRORS
operator|)
condition|)
return|return;
name|va_start
argument_list|(
name|ap
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
literal|"ASN.1: "
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|errbuf
operator|+
name|strlen
argument_list|(
name|errbuf
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
operator|-
name|strlen
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|err
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|errbuf
operator|+
name|strlen
argument_list|(
name|errbuf
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
operator|-
name|strlen
argument_list|(
name|errbuf
argument_list|)
argument_list|,
literal|" at"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|b
operator|->
name|asn_len
operator|>
name|i
condition|;
name|i
operator|++
control|)
name|snprintf
argument_list|(
name|errbuf
operator|+
name|strlen
argument_list|(
name|errbuf
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
operator|-
name|strlen
argument_list|(
name|errbuf
argument_list|)
argument_list|,
literal|" %02x"
argument_list|,
name|b
operator|->
name|asn_cptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s"
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a new community  */
end_comment

begin_function
name|u_int
name|comm_define
parameter_list|(
name|u_int
name|priv
parameter_list|,
specifier|const
name|char
modifier|*
name|descr
parameter_list|,
name|struct
name|lmodule
modifier|*
name|owner
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|struct
name|community
modifier|*
name|c
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|u_int
name|ncomm
decl_stmt|;
comment|/* generate an identifier */
do|do
block|{
if|if
condition|(
operator|(
name|ncomm
operator|=
name|next_community_index
operator|++
operator|)
operator|==
name|UINT_MAX
condition|)
name|next_community_index
operator|=
literal|1
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|c
argument_list|,
argument|&community_list
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|c
operator|->
name|value
operator|==
name|ncomm
condition|)
break|break;
block|}
do|while
condition|(
name|c
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
operator|(
name|c
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|community
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"comm_define: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|c
operator|->
name|owner
operator|=
name|owner
expr_stmt|;
name|c
operator|->
name|value
operator|=
name|ncomm
expr_stmt|;
name|c
operator|->
name|descr
operator|=
name|descr
expr_stmt|;
name|c
operator|->
name|string
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|private
operator|=
name|priv
expr_stmt|;
if|if
condition|(
name|str
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|->
name|string
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|c
operator|->
name|string
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
comment|/* make index */
if|if
condition|(
name|c
operator|->
name|owner
operator|==
name|NULL
condition|)
block|{
name|c
operator|->
name|index
operator|.
name|len
operator|=
literal|1
expr_stmt|;
name|c
operator|->
name|index
operator|.
name|subs
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|c
operator|->
name|index
operator|=
name|c
operator|->
name|owner
operator|->
name|index
expr_stmt|;
block|}
name|c
operator|->
name|index
operator|.
name|subs
index|[
name|c
operator|->
name|index
operator|.
name|len
operator|++
index|]
operator|=
name|c
operator|->
name|private
expr_stmt|;
comment|/* 	 * Insert ordered 	 */
name|TAILQ_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&community_list
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|asn_compare_oid
argument_list|(
operator|&
name|p
operator|->
name|index
argument_list|,
operator|&
name|c
operator|->
name|index
argument_list|)
operator|>
literal|0
condition|)
block|{
name|TAILQ_INSERT_BEFORE
argument_list|(
name|p
argument_list|,
name|c
argument_list|,
name|link
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|community_list
argument_list|,
name|c
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|->
name|value
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|comm_string
parameter_list|(
name|u_int
name|ncomm
parameter_list|)
block|{
name|struct
name|community
modifier|*
name|p
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&community_list
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|p
operator|->
name|value
operator|==
name|ncomm
condition|)
return|return
operator|(
name|p
operator|->
name|string
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete all communities allocated by a module  */
end_comment

begin_function
specifier|static
name|void
name|comm_flush
parameter_list|(
name|struct
name|lmodule
modifier|*
name|mod
parameter_list|)
block|{
name|struct
name|community
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|p
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|community_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|p1
operator|=
name|TAILQ_NEXT
argument_list|(
name|p
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|owner
operator|==
name|mod
condition|)
block|{
name|free
argument_list|(
name|p
operator|->
name|string
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|community_list
argument_list|,
name|p
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|p1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Request ID handling.  *  * Allocate a new range of request ids. Use a first fit algorithm.  */
end_comment

begin_function
name|u_int
name|reqid_allocate
parameter_list|(
name|int
name|size
parameter_list|,
name|struct
name|lmodule
modifier|*
name|mod
parameter_list|)
block|{
name|u_int
name|type
decl_stmt|;
name|struct
name|idrange
modifier|*
name|r
decl_stmt|,
modifier|*
name|r1
decl_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
operator|||
name|size
operator|>
name|INT32_MAX
condition|)
block|{
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"%s: size out of range: %d"
argument_list|,
name|__func__
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* allocate a type id */
do|do
block|{
if|if
condition|(
operator|(
name|type
operator|=
name|next_idrange
operator|++
operator|)
operator|==
name|UINT_MAX
condition|)
name|next_idrange
operator|=
literal|1
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|r
argument_list|,
argument|&idrange_list
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|r
operator|->
name|type
operator|==
name|type
condition|)
break|break;
block|}
do|while
condition|(
name|r
operator|!=
name|NULL
condition|)
do|;
comment|/* find a range */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|idrange_list
argument_list|)
condition|)
name|r
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|r
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|idrange_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|base
operator|<
name|size
condition|)
block|{
while|while
condition|(
operator|(
name|r1
operator|=
name|TAILQ_NEXT
argument_list|(
name|r
argument_list|,
name|link
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|r1
operator|->
name|base
operator|-
operator|(
name|r
operator|->
name|base
operator|+
name|r
operator|->
name|size
operator|)
operator|>=
name|size
condition|)
break|break;
name|r
operator|=
name|r1
expr_stmt|;
block|}
name|r
operator|=
name|r1
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
name|r1
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|idrange_list
argument_list|,
name|idrange_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|INT32_MAX
operator|-
name|size
operator|+
literal|1
operator|<
name|r1
operator|->
name|base
operator|+
name|r1
operator|->
name|size
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"out of id ranges (%u)"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
comment|/* allocate structure */
if|if
condition|(
operator|(
name|r1
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|idrange
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: %m"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|r1
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|r1
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|r1
operator|->
name|owner
operator|=
name|mod
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|idrange_list
argument_list|)
operator|||
name|r
operator|==
name|TAILQ_FIRST
argument_list|(
operator|&
name|idrange_list
argument_list|)
condition|)
block|{
name|r1
operator|->
name|base
operator|=
literal|0
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|idrange_list
argument_list|,
name|r1
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|idrange_list
argument_list|,
name|idrange_list
argument_list|)
expr_stmt|;
name|r1
operator|->
name|base
operator|=
name|r
operator|->
name|base
operator|+
name|r
operator|->
name|size
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|idrange_list
argument_list|,
name|r1
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|TAILQ_PREV
argument_list|(
name|r
argument_list|,
name|idrange_list
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|r1
operator|->
name|base
operator|=
name|r
operator|->
name|base
operator|+
name|r
operator|->
name|size
expr_stmt|;
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|idrange_list
argument_list|,
name|r
argument_list|,
name|r1
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|r1
operator|->
name|next
operator|=
name|r1
operator|->
name|base
expr_stmt|;
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_function
name|int32_t
name|reqid_next
parameter_list|(
name|u_int
name|type
parameter_list|)
block|{
name|struct
name|idrange
modifier|*
name|r
decl_stmt|;
name|int32_t
name|id
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|r
argument_list|,
argument|&idrange_list
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|r
operator|->
name|type
operator|==
name|type
condition|)
break|break;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"wrong idrange type"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|id
operator|=
name|r
operator|->
name|next
operator|++
operator|)
operator|==
name|r
operator|->
name|base
operator|+
operator|(
name|r
operator|->
name|size
operator|-
literal|1
operator|)
condition|)
name|r
operator|->
name|next
operator|=
name|r
operator|->
name|base
expr_stmt|;
return|return
operator|(
name|id
operator|)
return|;
block|}
end_function

begin_function
name|int32_t
name|reqid_base
parameter_list|(
name|u_int
name|type
parameter_list|)
block|{
name|struct
name|idrange
modifier|*
name|r
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|r
argument_list|,
argument|&idrange_list
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|r
operator|->
name|type
operator|==
name|type
condition|)
return|return
operator|(
name|r
operator|->
name|base
operator|)
return|;
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"wrong idrange type"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|u_int
name|reqid_type
parameter_list|(
name|int32_t
name|reqid
parameter_list|)
block|{
name|struct
name|idrange
modifier|*
name|r
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|r
argument_list|,
argument|&idrange_list
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|reqid
operator|>=
name|r
operator|->
name|base
operator|&&
name|reqid
operator|<=
name|r
operator|->
name|base
operator|+
operator|(
name|r
operator|->
name|size
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
name|r
operator|->
name|type
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|reqid_istype
parameter_list|(
name|int32_t
name|reqid
parameter_list|,
name|u_int
name|type
parameter_list|)
block|{
return|return
operator|(
name|reqid_type
argument_list|(
name|reqid
argument_list|)
operator|==
name|type
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete all communities allocated by a module  */
end_comment

begin_function
specifier|static
name|void
name|reqid_flush
parameter_list|(
name|struct
name|lmodule
modifier|*
name|mod
parameter_list|)
block|{
name|struct
name|idrange
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|p
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|idrange_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|p1
operator|=
name|TAILQ_NEXT
argument_list|(
name|p
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|owner
operator|==
name|mod
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|idrange_list
argument_list|,
name|p
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|p1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Merge the given tree for the given module into the main tree.  */
end_comment

begin_function
specifier|static
name|int
name|compare_node
parameter_list|(
specifier|const
name|void
modifier|*
name|v1
parameter_list|,
specifier|const
name|void
modifier|*
name|v2
parameter_list|)
block|{
specifier|const
name|struct
name|snmp_node
modifier|*
name|n1
init|=
name|v1
decl_stmt|;
specifier|const
name|struct
name|snmp_node
modifier|*
name|n2
init|=
name|v2
decl_stmt|;
return|return
operator|(
name|asn_compare_oid
argument_list|(
operator|&
name|n1
operator|->
name|oid
argument_list|,
operator|&
name|n2
operator|->
name|oid
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tree_merge
parameter_list|(
specifier|const
name|struct
name|snmp_node
modifier|*
name|ntree
parameter_list|,
name|u_int
name|nsize
parameter_list|,
name|struct
name|lmodule
modifier|*
name|mod
parameter_list|)
block|{
name|struct
name|snmp_node
modifier|*
name|xtree
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|xtree
operator|=
name|realloc
argument_list|(
name|tree
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tree
argument_list|)
operator|*
operator|(
name|tree_size
operator|+
name|nsize
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xtree
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"tree_merge: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|tree
operator|=
name|xtree
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|tree
index|[
name|tree_size
index|]
argument_list|,
name|ntree
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tree
argument_list|)
operator|*
name|nsize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsize
condition|;
name|i
operator|++
control|)
name|tree
index|[
name|tree_size
operator|+
name|i
index|]
operator|.
name|tree_data
operator|=
name|mod
expr_stmt|;
name|tree_size
operator|+=
name|nsize
expr_stmt|;
name|qsort
argument_list|(
name|tree
argument_list|,
name|tree_size
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|compare_node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove all nodes belonging to the loadable module  */
end_comment

begin_function
specifier|static
name|void
name|tree_unmerge
parameter_list|(
name|struct
name|lmodule
modifier|*
name|mod
parameter_list|)
block|{
name|u_int
name|s
decl_stmt|,
name|d
decl_stmt|;
for|for
control|(
name|s
operator|=
name|d
operator|=
literal|0
init|;
name|s
operator|<
name|tree_size
condition|;
name|s
operator|++
control|)
if|if
condition|(
name|tree
index|[
name|s
index|]
operator|.
name|tree_data
operator|!=
name|mod
condition|)
block|{
if|if
condition|(
name|s
operator|!=
name|d
condition|)
name|tree
index|[
name|d
index|]
operator|=
name|tree
index|[
name|s
index|]
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
name|tree_size
operator|=
name|d
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Loadable modules  */
end_comment

begin_function
name|struct
name|lmodule
modifier|*
name|lm_load
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|)
block|{
name|struct
name|lmodule
modifier|*
name|m
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|av
index|[
name|MAX_MOD_ARGS
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|ac
decl_stmt|;
name|u_int
name|u
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|m
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lm_load: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|m
operator|->
name|handle
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|m
operator|->
name|section
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|path
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lm_load: %m"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|strcpy
argument_list|(
name|m
operator|->
name|path
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* 	 * Make index 	 */
name|m
operator|->
name|index
operator|.
name|subs
index|[
literal|0
index|]
operator|=
name|strlen
argument_list|(
name|section
argument_list|)
expr_stmt|;
name|m
operator|->
name|index
operator|.
name|len
operator|=
name|m
operator|->
name|index
operator|.
name|subs
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|m
operator|->
name|index
operator|.
name|subs
index|[
literal|0
index|]
condition|;
name|u
operator|++
control|)
name|m
operator|->
name|index
operator|.
name|subs
index|[
name|u
operator|+
literal|1
index|]
operator|=
name|section
index|[
name|u
index|]
expr_stmt|;
comment|/* 	 * Load the object file and locate the config structure 	 */
if|if
condition|(
operator|(
name|m
operator|->
name|handle
operator|=
name|dlopen
argument_list|(
name|m
operator|->
name|path
argument_list|,
name|RTLD_NOW
operator||
name|RTLD_GLOBAL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lm_load: open %s"
argument_list|,
name|dlerror
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|(
name|m
operator|->
name|config
operator|=
name|dlsym
argument_list|(
name|m
operator|->
name|handle
argument_list|,
literal|"config"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lm_load: no 'config' symbol %s"
argument_list|,
name|dlerror
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* 	 * Insert it into the right place 	 */
name|INSERT_OBJECT_OID
argument_list|(
name|m
argument_list|,
operator|&
name|lmodules
argument_list|)
expr_stmt|;
comment|/* preserve order */
if|if
condition|(
name|community
operator|==
name|COMM_INITIALIZE
condition|)
block|{
name|m
operator|->
name|flags
operator||=
name|LM_ONSTARTLIST
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|modules_start
argument_list|,
name|m
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * make the argument vector. 	 */
name|ac
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nprogargs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|progargs
index|[
name|i
index|]
argument_list|)
operator|>=
name|strlen
argument_list|(
name|section
argument_list|)
operator|+
literal|1
operator|&&
name|strncmp
argument_list|(
name|progargs
index|[
name|i
index|]
argument_list|,
name|section
argument_list|,
name|strlen
argument_list|(
name|section
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|progargs
index|[
name|i
index|]
index|[
name|strlen
argument_list|(
name|section
argument_list|)
index|]
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|ac
operator|==
name|MAX_MOD_ARGS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"too many arguments for "
literal|"module '%s"
argument_list|,
name|section
argument_list|)
expr_stmt|;
break|break;
block|}
name|av
index|[
name|ac
operator|++
index|]
operator|=
operator|&
name|progargs
index|[
name|i
index|]
index|[
name|strlen
argument_list|(
name|section
argument_list|)
operator|+
literal|1
index|]
expr_stmt|;
block|}
block|}
name|av
index|[
name|ac
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Run the initialization function 	 */
if|if
condition|(
operator|(
name|err
operator|=
call|(
modifier|*
name|m
operator|->
name|config
operator|->
name|init
call|)
argument_list|(
name|m
argument_list|,
name|ac
argument_list|,
name|av
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lm_load: init failed: %d"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lmodules
argument_list|,
name|m
argument_list|,
name|link
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
return|return
operator|(
name|m
operator|)
return|;
name|err
label|:
if|if
condition|(
name|m
operator|->
name|handle
condition|)
name|dlclose
argument_list|(
name|m
operator|->
name|handle
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|m
operator|->
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start a module  */
end_comment

begin_function
name|void
name|lm_start
parameter_list|(
name|struct
name|lmodule
modifier|*
name|mod
parameter_list|)
block|{
specifier|const
name|struct
name|lmodule
modifier|*
name|m
decl_stmt|;
comment|/* 	 * Merge tree. If this fails, unload the module. 	 */
if|if
condition|(
name|tree_merge
argument_list|(
name|mod
operator|->
name|config
operator|->
name|tree
argument_list|,
name|mod
operator|->
name|config
operator|->
name|tree_size
argument_list|,
name|mod
argument_list|)
condition|)
block|{
name|lm_unload
argument_list|(
name|mod
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Read configuration 	 */
if|if
condition|(
name|read_config
argument_list|(
name|config_file
argument_list|,
name|mod
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"error in config file"
argument_list|)
expr_stmt|;
name|lm_unload
argument_list|(
name|mod
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mod
operator|->
name|config
operator|->
name|start
condition|)
call|(
modifier|*
name|mod
operator|->
name|config
operator|->
name|start
call|)
argument_list|()
expr_stmt|;
name|mod
operator|->
name|flags
operator||=
name|LM_STARTED
expr_stmt|;
comment|/* 	 * Inform other modules 	 */
name|TAILQ_FOREACH
argument_list|(
argument|m
argument_list|,
argument|&lmodules
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|m
operator|->
name|config
operator|->
name|loading
condition|)
call|(
modifier|*
name|m
operator|->
name|config
operator|->
name|loading
call|)
argument_list|(
name|mod
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unload a module.  */
end_comment

begin_function
name|void
name|lm_unload
parameter_list|(
name|struct
name|lmodule
modifier|*
name|m
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
specifier|const
name|struct
name|lmodule
modifier|*
name|mod
decl_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lmodules
argument_list|,
name|m
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|LM_ONSTARTLIST
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|modules_start
argument_list|,
name|m
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|tree_unmerge
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|LM_STARTED
operator|)
operator|&&
name|m
operator|->
name|config
operator|->
name|fini
operator|&&
operator|(
name|err
operator|=
call|(
modifier|*
name|m
operator|->
name|config
operator|->
name|fini
call|)
argument_list|()
operator|)
operator|!=
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"lm_unload(%s): fini %d"
argument_list|,
name|m
operator|->
name|section
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|comm_flush
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|reqid_flush
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|timer_flush
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|fd_flush
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|dlclose
argument_list|(
name|m
operator|->
name|handle
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|m
operator|->
name|path
argument_list|)
expr_stmt|;
comment|/* 	 * Inform other modules 	 */
name|TAILQ_FOREACH
argument_list|(
argument|mod
argument_list|,
argument|&lmodules
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|mod
operator|->
name|config
operator|->
name|loading
condition|)
call|(
modifier|*
name|mod
operator|->
name|config
operator|->
name|loading
call|)
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Register an object resource and return the index (or 0 on failures)  */
end_comment

begin_function
name|u_int
name|or_register
parameter_list|(
specifier|const
name|struct
name|asn_oid
modifier|*
name|or
parameter_list|,
specifier|const
name|char
modifier|*
name|descr
parameter_list|,
name|struct
name|lmodule
modifier|*
name|mod
parameter_list|)
block|{
name|struct
name|objres
modifier|*
name|objres
decl_stmt|,
modifier|*
name|or1
decl_stmt|;
name|u_int
name|idx
decl_stmt|;
comment|/* find a free index */
name|idx
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|objres
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|objres_list
argument_list|)
init|;
name|objres
operator|!=
name|NULL
condition|;
name|objres
operator|=
name|TAILQ_NEXT
argument_list|(
name|objres
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|or1
operator|=
name|TAILQ_NEXT
argument_list|(
name|objres
argument_list|,
name|link
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|or1
operator|->
name|index
operator|>
name|objres
operator|->
name|index
operator|+
literal|1
condition|)
block|{
name|idx
operator|=
name|objres
operator|->
name|index
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|objres
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|objres
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|objres
operator|->
name|index
operator|=
name|idx
expr_stmt|;
name|objres
operator|->
name|oid
operator|=
operator|*
name|or
expr_stmt|;
name|strlcpy
argument_list|(
name|objres
operator|->
name|descr
argument_list|,
name|descr
argument_list|,
sizeof|sizeof
argument_list|(
name|objres
operator|->
name|descr
argument_list|)
argument_list|)
expr_stmt|;
name|objres
operator|->
name|uptime
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|get_ticks
argument_list|()
operator|-
name|start_tick
argument_list|)
expr_stmt|;
name|objres
operator|->
name|module
operator|=
name|mod
expr_stmt|;
name|INSERT_OBJECT_INT
argument_list|(
name|objres
argument_list|,
operator|&
name|objres_list
argument_list|)
expr_stmt|;
name|systemg
operator|.
name|or_last_change
operator|=
name|objres
operator|->
name|uptime
expr_stmt|;
return|return
operator|(
name|idx
operator|)
return|;
block|}
end_function

begin_function
name|void
name|or_unregister
parameter_list|(
name|u_int
name|idx
parameter_list|)
block|{
name|struct
name|objres
modifier|*
name|objres
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|objres
argument_list|,
argument|&objres_list
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|objres
operator|->
name|index
operator|==
name|idx
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|objres_list
argument_list|,
name|objres
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|objres
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

end_unit

