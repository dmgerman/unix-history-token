begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2001-2003  *	Fraunhofer Institute for Open Communication Systems (FhG Fokus).  *	All rights reserved.  *  * Author: Harti Brandt<harti@freebsd.org>  *  * Redistribution of this software and documentation and use in source and  * binary forms, with or without modification, are permitted provided that  * the following conditions are met:  *  * 1. Redistributions of source code or documentation must retain the above  *    copyright notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the Institute nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE AND DOCUMENTATION IS PROVIDED BY FRAUNHOFER FOKUS  * AND ITS CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL  * FRAUNHOFER FOKUS OR ITS CONTRIBUTORS  BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,  * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $Begemot: bsnmp/snmpd/main.c,v 1.76 2003/01/28 13:44:35 hbb Exp $  *  * SNMPd main stuff.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|"snmpmod.h"
end_include

begin_include
include|#
directive|include
file|"snmpd.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"oid.h"
end_include

begin_define
define|#
directive|define
name|PATH_PID
value|"/var/run/%s.pid"
end_define

begin_define
define|#
directive|define
name|PATH_CONFIG
value|"/etc/%s.config"
end_define

begin_decl_stmt
name|u_int32_t
name|this_tick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start of processing of current packet */
end_comment

begin_decl_stmt
name|u_int32_t
name|start_tick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start of processing */
end_comment

begin_decl_stmt
name|struct
name|systemg
name|systemg
init|=
block|{
name|NULL
block|,
block|{
literal|8
block|,
block|{
literal|1
block|,
literal|3
block|,
literal|6
block|,
literal|1
block|,
literal|4
block|,
literal|1
block|,
literal|1115
block|,
literal|7352
block|}
block|}
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|64
operator|+
literal|8
operator|+
literal|4
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|debug
name|debug
init|=
block|{
literal|0
block|,
comment|/* dump_pdus */
name|LOG_DEBUG
block|,
comment|/* log_pri */
literal|0
block|,
comment|/* evdebug */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|snmpd
name|snmpd
init|=
block|{
literal|2048
block|,
comment|/* txbuf */
literal|2048
block|,
comment|/* rxbuf */
literal|0
block|,
comment|/* comm_dis */
literal|0
block|,
comment|/* auth_traps */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* trap1addr */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|snmpd_stats
name|snmpd_stats
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* snmpSerialNo */
end_comment

begin_decl_stmt
name|int32_t
name|snmp_serial_no
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* search path for config files */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|syspath
init|=
name|PATH_SYSCONFIG
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of all loaded modules */
end_comment

begin_decl_stmt
name|struct
name|lmodules
name|lmodules
init|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|lmodules
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of loaded modules during start-up in the order they were loaded */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|lmodules
name|modules_start
init|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|modules_start
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of all known communities */
end_comment

begin_decl_stmt
name|struct
name|community_list
name|community_list
init|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|community_list
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of all installed object resources */
end_comment

begin_decl_stmt
name|struct
name|objres_list
name|objres_list
init|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|objres_list
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* community value generator */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|next_community_index
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of all known ranges */
end_comment

begin_decl_stmt
name|struct
name|idrange_list
name|idrange_list
init|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|idrange_list
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* identifier generator */
end_comment

begin_decl_stmt
name|u_int
name|next_idrange
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of all current timers */
end_comment

begin_decl_stmt
name|struct
name|timer_list
name|timer_list
init|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|timer_list
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of file descriptors */
end_comment

begin_decl_stmt
name|struct
name|fdesc_list
name|fdesc_list
init|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|fdesc_list
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* program arguments */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|progargs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nprogargs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current community */
end_comment

begin_decl_stmt
name|u_int
name|community
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|community
modifier|*
name|comm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of all IP ports we are listening on */
end_comment

begin_decl_stmt
name|struct
name|snmp_port_list
name|snmp_port_list
init|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|snmp_port_list
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of all local ports we are listening on */
end_comment

begin_decl_stmt
name|struct
name|local_port_list
name|local_port_list
init|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|local_port_list
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file names */
end_comment

begin_decl_stmt
specifier|static
name|char
name|config_file
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|pid_file
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* event context */
end_comment

begin_decl_stmt
specifier|static
name|evContext
name|evctx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* signal mask */
end_comment

begin_decl_stmt
specifier|static
name|sigset_t
name|blocked_sigs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* signal handling */
end_comment

begin_decl_stmt
specifier|static
name|int
name|work
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|WORK_DOINFO
value|0x0001
end_define

begin_define
define|#
directive|define
name|WORK_RECONFIG
value|0x0002
end_define

begin_comment
comment|/* oids */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|asn_oid
name|oid_snmpMIB
init|=
name|OIDX_snmpMIB
decl_stmt|,
name|oid_begemotSnmpd
init|=
name|OIDX_begemotSnmpd
decl_stmt|,
name|oid_coldStart
init|=
name|OIDX_coldStart
decl_stmt|,
name|oid_authenticationFailure
init|=
name|OIDX_authenticationFailure
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|asn_oid
name|oid_zeroDotZero
init|=
block|{
literal|2
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* request id generator for traps */
end_comment

begin_decl_stmt
name|u_int
name|trap_reqid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* help text */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|usgtxt
index|[]
init|=
literal|"\ Begemot simple SNMP daemon. Copyright (c) 2001-2002 Fraunhofer Institute for\n\ Open Communication Systems (FhG Fokus). All rights reserved.\n\ usage: snmpd [-dh] [-c file] [-D options] [-I path] [-l prefix]\n\              [-m variable=value] [-p file]\n\ options:\n\   -d		don't daemonize\n\   -h		print this info\n\   -c file	specify configuration file\n\   -D options	debugging options\n\   -I path	system include path\n\   -l prefix	default basename for pid and config file\n\   -m var=val	define variable\n\   -p file	specify pid file\n\ "
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* forward declarations */
end_comment

begin_function_decl
specifier|static
name|void
name|snmp_printf_func
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|snmp_error_func
parameter_list|(
specifier|const
name|char
modifier|*
name|err
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|snmp_debug_func
parameter_list|(
specifier|const
name|char
modifier|*
name|err
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|asn_error_func
parameter_list|(
specifier|const
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|err
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Allocate rx/tx buffer. We allocate one byte more for rx.  */
end_comment

begin_function
name|void
modifier|*
name|buf_alloc
parameter_list|(
name|int
name|tx
parameter_list|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|tx
condition|?
name|snmpd
operator|.
name|txbuf
else|:
operator|(
name|snmpd
operator|.
name|rxbuf
operator|+
literal|1
operator|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"cannot allocate buffer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx
condition|)
name|snmpd_stats
operator|.
name|noTxbuf
operator|++
expr_stmt|;
else|else
name|snmpd_stats
operator|.
name|noRxbuf
operator|++
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the buffer size. (one more for RX).  */
end_comment

begin_function
name|size_t
name|buf_size
parameter_list|(
name|int
name|tx
parameter_list|)
block|{
return|return
operator|(
name|tx
condition|?
name|snmpd
operator|.
name|txbuf
else|:
operator|(
name|snmpd
operator|.
name|rxbuf
operator|+
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Prepare a PDU for output  */
end_comment

begin_function
name|void
name|snmp_output
parameter_list|(
name|struct
name|snmp_v1_pdu
modifier|*
name|pdu
parameter_list|,
name|u_char
modifier|*
name|sndbuf
parameter_list|,
name|size_t
modifier|*
name|sndlen
parameter_list|,
specifier|const
name|char
modifier|*
name|dest
parameter_list|)
block|{
name|struct
name|asn_buf
name|resp_b
decl_stmt|;
name|resp_b
operator|.
name|asn_ptr
operator|=
name|sndbuf
expr_stmt|;
name|resp_b
operator|.
name|asn_len
operator|=
name|snmpd
operator|.
name|txbuf
expr_stmt|;
if|if
condition|(
name|snmp_pdu_encode
argument_list|(
name|pdu
argument_list|,
operator|&
name|resp_b
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot encode message"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|debug
operator|.
name|dump_pdus
condition|)
block|{
name|snmp_printf
argument_list|(
literal|"%s<- "
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|snmp_pdu_dump
argument_list|(
name|pdu
argument_list|)
expr_stmt|;
block|}
operator|*
name|sndlen
operator|=
call|(
name|size_t
call|)
argument_list|(
name|resp_b
operator|.
name|asn_ptr
operator|-
name|sndbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a PDU to a given port  */
end_comment

begin_function
name|void
name|snmp_send_port
parameter_list|(
specifier|const
name|struct
name|asn_oid
modifier|*
name|port
parameter_list|,
name|struct
name|snmp_v1_pdu
modifier|*
name|pdu
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|)
block|{
name|struct
name|snmp_port
modifier|*
name|p
decl_stmt|;
name|u_char
modifier|*
name|sndbuf
decl_stmt|;
name|size_t
name|sndlen
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&snmp_port_list
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|asn_compare_oid
argument_list|(
name|port
argument_list|,
operator|&
name|p
operator|->
name|index
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|sndbuf
operator|=
name|buf_alloc
argument_list|(
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|snmp_output
argument_list|(
name|pdu
argument_list|,
name|sndbuf
argument_list|,
operator|&
name|sndlen
argument_list|,
literal|"SNMP PROXY"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|sendto
argument_list|(
name|p
operator|->
name|sock
argument_list|,
name|sndbuf
argument_list|,
name|sndlen
argument_list|,
literal|0
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sendto: %m"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|size_t
operator|)
name|len
operator|!=
name|sndlen
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sendto: short write %zu/%zu"
argument_list|,
name|sndlen
argument_list|,
operator|(
name|size_t
operator|)
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sndbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SNMP input. Start: decode the PDU, find the community.  */
end_comment

begin_function
name|enum
name|snmpd_input_err
name|snmp_input_start
parameter_list|(
specifier|const
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|source
parameter_list|,
name|struct
name|snmp_v1_pdu
modifier|*
name|pdu
parameter_list|,
name|int32_t
modifier|*
name|ip
parameter_list|)
block|{
name|struct
name|asn_buf
name|b
decl_stmt|;
name|enum
name|snmp_code
name|code
decl_stmt|;
name|enum
name|snmpd_input_err
name|ret
decl_stmt|;
name|snmpd_stats
operator|.
name|inPkts
operator|++
expr_stmt|;
name|b
operator|.
name|asn_cptr
operator|=
name|buf
expr_stmt|;
name|b
operator|.
name|asn_len
operator|=
name|len
expr_stmt|;
name|code
operator|=
name|snmp_pdu_decode
argument_list|(
operator|&
name|b
argument_list|,
name|pdu
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|ret
operator|=
name|SNMPD_INPUT_OK
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SNMP_CODE_FAILED
case|:
name|snmpd_stats
operator|.
name|inASNParseErrs
operator|++
expr_stmt|;
return|return
operator|(
name|SNMPD_INPUT_FAILED
operator|)
return|;
case|case
name|SNMP_CODE_BADVERS
case|:
name|snmpd_stats
operator|.
name|inBadVersions
operator|++
expr_stmt|;
return|return
operator|(
name|SNMPD_INPUT_FAILED
operator|)
return|;
case|case
name|SNMP_CODE_BADLEN
case|:
if|if
condition|(
name|pdu
operator|->
name|type
operator|==
name|SNMP_OP_SET
condition|)
name|ret
operator|=
name|SNMPD_INPUT_VALBADLEN
expr_stmt|;
break|break;
case|case
name|SNMP_CODE_OORANGE
case|:
if|if
condition|(
name|pdu
operator|->
name|type
operator|==
name|SNMP_OP_SET
condition|)
name|ret
operator|=
name|SNMPD_INPUT_VALRANGE
expr_stmt|;
break|break;
case|case
name|SNMP_CODE_BADENC
case|:
if|if
condition|(
name|pdu
operator|->
name|type
operator|==
name|SNMP_OP_SET
condition|)
name|ret
operator|=
name|SNMPD_INPUT_VALBADENC
expr_stmt|;
break|break;
case|case
name|SNMP_CODE_OK
case|:
break|break;
block|}
if|if
condition|(
name|debug
operator|.
name|dump_pdus
condition|)
block|{
name|snmp_printf
argument_list|(
literal|"%s -> "
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|snmp_pdu_dump
argument_list|(
name|pdu
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Look, whether we know the community 	 */
name|TAILQ_FOREACH
argument_list|(
argument|comm
argument_list|,
argument|&community_list
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|comm
operator|->
name|string
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|comm
operator|->
name|string
argument_list|,
name|pdu
operator|->
name|community
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|comm
operator|==
name|NULL
condition|)
block|{
name|snmpd_stats
operator|.
name|inBadCommunityNames
operator|++
expr_stmt|;
name|snmp_pdu_free
argument_list|(
name|pdu
argument_list|)
expr_stmt|;
if|if
condition|(
name|snmpd
operator|.
name|auth_traps
condition|)
name|snmp_send_trap
argument_list|(
operator|&
name|oid_authenticationFailure
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMPD_INPUT_FAILED
operator|)
return|;
block|}
name|community
operator|=
name|comm
operator|->
name|value
expr_stmt|;
comment|/* update uptime */
name|this_tick
operator|=
name|get_ticks
argument_list|()
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Will return only _OK or _FAILED  */
end_comment

begin_function
name|enum
name|snmpd_input_err
name|snmp_input_finish
parameter_list|(
name|struct
name|snmp_pdu
modifier|*
name|pdu
parameter_list|,
specifier|const
name|u_char
modifier|*
name|rcvbuf
parameter_list|,
name|size_t
name|rcvlen
parameter_list|,
name|u_char
modifier|*
name|sndbuf
parameter_list|,
name|size_t
modifier|*
name|sndlen
parameter_list|,
specifier|const
name|char
modifier|*
name|source
parameter_list|,
name|enum
name|snmpd_input_err
name|ierr
parameter_list|,
name|int32_t
name|ivar
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|snmp_pdu
name|resp
decl_stmt|;
name|struct
name|asn_buf
name|resp_b
decl_stmt|,
name|pdu_b
decl_stmt|;
name|enum
name|snmp_ret
name|ret
decl_stmt|;
name|resp_b
operator|.
name|asn_ptr
operator|=
name|sndbuf
expr_stmt|;
name|resp_b
operator|.
name|asn_len
operator|=
name|snmpd
operator|.
name|txbuf
expr_stmt|;
name|pdu_b
operator|.
name|asn_cptr
operator|=
name|rcvbuf
expr_stmt|;
name|pdu_b
operator|.
name|asn_len
operator|=
name|rcvlen
expr_stmt|;
if|if
condition|(
name|ierr
operator|!=
name|SNMPD_INPUT_OK
condition|)
block|{
comment|/* error decoding the input of a SET */
if|if
condition|(
name|pdu
operator|->
name|version
operator|==
name|SNMP_V1
condition|)
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_BADVALUE
expr_stmt|;
elseif|else
if|if
condition|(
name|ierr
operator|==
name|SNMPD_INPUT_VALBADLEN
condition|)
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_WRONG_LENGTH
expr_stmt|;
elseif|else
if|if
condition|(
name|ierr
operator|==
name|SNMPD_INPUT_VALRANGE
condition|)
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_WRONG_VALUE
expr_stmt|;
else|else
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_WRONG_ENCODING
expr_stmt|;
name|pdu
operator|->
name|error_index
operator|=
name|ivar
expr_stmt|;
if|if
condition|(
name|snmp_make_errresp
argument_list|(
name|pdu
argument_list|,
operator|&
name|pdu_b
argument_list|,
operator|&
name|resp_b
argument_list|)
operator|==
name|SNMP_RET_IGN
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"could not encode error response"
argument_list|)
expr_stmt|;
name|snmpd_stats
operator|.
name|silentDrops
operator|++
expr_stmt|;
return|return
operator|(
name|SNMPD_INPUT_FAILED
operator|)
return|;
block|}
if|if
condition|(
name|debug
operator|.
name|dump_pdus
condition|)
block|{
name|snmp_printf
argument_list|(
literal|"%s<- "
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|snmp_pdu_dump
argument_list|(
name|pdu
argument_list|)
expr_stmt|;
block|}
operator|*
name|sndlen
operator|=
call|(
name|size_t
call|)
argument_list|(
name|resp_b
operator|.
name|asn_ptr
operator|-
name|sndbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMPD_INPUT_OK
operator|)
return|;
block|}
switch|switch
condition|(
name|pdu
operator|->
name|type
condition|)
block|{
case|case
name|SNMP_PDU_GET
case|:
name|ret
operator|=
name|snmp_get
argument_list|(
name|pdu
argument_list|,
operator|&
name|resp_b
argument_list|,
operator|&
name|resp
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNMP_PDU_GETNEXT
case|:
name|ret
operator|=
name|snmp_getnext
argument_list|(
name|pdu
argument_list|,
operator|&
name|resp_b
argument_list|,
operator|&
name|resp
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNMP_PDU_SET
case|:
name|ret
operator|=
name|snmp_set
argument_list|(
name|pdu
argument_list|,
operator|&
name|resp_b
argument_list|,
operator|&
name|resp
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNMP_PDU_GETBULK
case|:
name|ret
operator|=
name|snmp_getbulk
argument_list|(
name|pdu
argument_list|,
operator|&
name|resp_b
argument_list|,
operator|&
name|resp
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|SNMP_RET_IGN
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|SNMP_RET_OK
case|:
comment|/* normal return - send a response */
if|if
condition|(
name|debug
operator|.
name|dump_pdus
condition|)
block|{
name|snmp_printf
argument_list|(
literal|"%s<- "
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|snmp_pdu_dump
argument_list|(
operator|&
name|resp
argument_list|)
expr_stmt|;
block|}
operator|*
name|sndlen
operator|=
call|(
name|size_t
call|)
argument_list|(
name|resp_b
operator|.
name|asn_ptr
operator|-
name|sndbuf
argument_list|)
expr_stmt|;
name|snmp_pdu_free
argument_list|(
operator|&
name|resp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMPD_INPUT_OK
operator|)
return|;
case|case
name|SNMP_RET_IGN
case|:
comment|/* error - send nothing */
name|snmpd_stats
operator|.
name|silentDrops
operator|++
expr_stmt|;
return|return
operator|(
name|SNMPD_INPUT_FAILED
operator|)
return|;
case|case
name|SNMP_RET_ERR
case|:
comment|/* error - send error response. The snmp routine has 		 * changed the error fields in the original message. */
name|resp_b
operator|.
name|asn_ptr
operator|=
name|sndbuf
expr_stmt|;
name|resp_b
operator|.
name|asn_len
operator|=
name|snmpd
operator|.
name|txbuf
expr_stmt|;
if|if
condition|(
name|snmp_make_errresp
argument_list|(
name|pdu
argument_list|,
operator|&
name|pdu_b
argument_list|,
operator|&
name|resp_b
argument_list|)
operator|==
name|SNMP_RET_IGN
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"could not encode error response"
argument_list|)
expr_stmt|;
name|snmpd_stats
operator|.
name|silentDrops
operator|++
expr_stmt|;
return|return
operator|(
name|SNMPD_INPUT_FAILED
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|debug
operator|.
name|dump_pdus
condition|)
block|{
name|snmp_printf
argument_list|(
literal|"%s<- "
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|snmp_pdu_dump
argument_list|(
name|pdu
argument_list|)
expr_stmt|;
block|}
operator|*
name|sndlen
operator|=
call|(
name|size_t
call|)
argument_list|(
name|resp_b
operator|.
name|asn_ptr
operator|-
name|sndbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMPD_INPUT_OK
operator|)
return|;
block|}
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * File descriptor support  */
end_comment

begin_function
specifier|static
name|void
name|input
parameter_list|(
name|evContext
name|ctx
name|__unused
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|mask
name|__unused
parameter_list|)
block|{
name|struct
name|fdesc
modifier|*
name|f
init|=
name|uap
decl_stmt|;
call|(
modifier|*
name|f
operator|->
name|func
call|)
argument_list|(
name|fd
argument_list|,
name|f
operator|->
name|udata
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fd_suspend
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|fdesc
modifier|*
name|f
init|=
name|p
decl_stmt|;
if|if
condition|(
name|evTestID
argument_list|(
name|f
operator|->
name|id
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|evDeselectFD
argument_list|(
name|evctx
argument_list|,
name|f
operator|->
name|id
argument_list|)
expr_stmt|;
name|evInitID
argument_list|(
operator|&
name|f
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|fd_resume
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|fdesc
modifier|*
name|f
init|=
name|p
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|evTestID
argument_list|(
name|f
operator|->
name|id
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|evSelectFD
argument_list|(
name|evctx
argument_list|,
name|f
operator|->
name|fd
argument_list|,
name|EV_READ
argument_list|,
name|input
argument_list|,
name|f
argument_list|,
operator|&
name|f
operator|->
name|id
argument_list|)
condition|)
block|{
name|err
operator|=
name|errno
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"select fd %d: %m"
argument_list|,
name|f
operator|->
name|fd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|err
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|fd_select
parameter_list|(
name|int
name|fd
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|,
name|struct
name|lmodule
modifier|*
name|mod
parameter_list|)
block|{
name|struct
name|fdesc
modifier|*
name|f
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fdesc
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|errno
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fd_select: %m"
argument_list|)
expr_stmt|;
name|errno
operator|=
name|err
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|f
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|f
operator|->
name|func
operator|=
name|func
expr_stmt|;
name|f
operator|->
name|udata
operator|=
name|udata
expr_stmt|;
name|f
operator|->
name|owner
operator|=
name|mod
expr_stmt|;
name|evInitID
argument_list|(
operator|&
name|f
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd_resume
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|err
operator|=
name|errno
expr_stmt|;
name|free
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|errno
operator|=
name|err
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|fdesc_list
argument_list|,
name|f
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_function
name|void
name|fd_deselect
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|fdesc
modifier|*
name|f
init|=
name|p
decl_stmt|;
name|LIST_REMOVE
argument_list|(
name|f
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|fd_suspend
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fd_flush
parameter_list|(
name|struct
name|lmodule
modifier|*
name|mod
parameter_list|)
block|{
name|struct
name|fdesc
modifier|*
name|t
decl_stmt|,
modifier|*
name|t1
decl_stmt|;
name|t
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|fdesc_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|t
operator|!=
name|NULL
condition|)
block|{
name|t1
operator|=
name|LIST_NEXT
argument_list|(
name|t
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|owner
operator|==
name|mod
condition|)
name|fd_deselect
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|t1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Input from UDP socket  */
end_comment

begin_function
specifier|static
name|void
name|do_input
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|struct
name|asn_oid
modifier|*
name|port_index
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|ret
parameter_list|,
name|socklen_t
modifier|*
name|retlen
parameter_list|)
block|{
name|u_char
modifier|*
name|resbuf
decl_stmt|,
name|embuf
index|[
literal|100
index|]
decl_stmt|;
name|u_char
modifier|*
name|sndbuf
decl_stmt|;
name|size_t
name|sndlen
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
name|struct
name|snmp_v1_pdu
name|pdu
decl_stmt|;
name|enum
name|snmpd_input_err
name|ierr
decl_stmt|,
name|ferr
decl_stmt|;
name|enum
name|snmpd_proxy_err
name|perr
decl_stmt|;
name|int32_t
name|vi
decl_stmt|;
if|if
condition|(
operator|(
name|resbuf
operator|=
name|buf_alloc
argument_list|(
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|recvfrom
argument_list|(
name|fd
argument_list|,
name|embuf
argument_list|,
sizeof|sizeof
argument_list|(
name|embuf
argument_list|)
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
name|retlen
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|len
operator|=
name|recvfrom
argument_list|(
name|fd
argument_list|,
name|resbuf
argument_list|,
name|buf_size
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
name|retlen
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|resbuf
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|resbuf
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|size_t
operator|)
name|len
operator|==
name|buf_size
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|resbuf
argument_list|)
expr_stmt|;
name|snmpd_stats
operator|.
name|silentDrops
operator|++
expr_stmt|;
name|snmpd_stats
operator|.
name|inTooLong
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 	 * Handle input 	 */
name|ierr
operator|=
name|snmp_input_start
argument_list|(
name|resbuf
argument_list|,
operator|(
name|size_t
operator|)
name|len
argument_list|,
literal|"SNMP"
argument_list|,
operator|&
name|pdu
argument_list|,
operator|&
name|vi
argument_list|)
expr_stmt|;
comment|/* can't check for bad SET pdus here, because a proxy may have to 	 * check the access first. We don't want to return an error response 	 * to a proxy PDU with a wrong community */
if|if
condition|(
name|ierr
operator|==
name|SNMPD_INPUT_FAILED
condition|)
block|{
name|free
argument_list|(
name|resbuf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If that is a module community and the module has a proxy function, 	 * the hand it over to the module. 	 */
if|if
condition|(
name|comm
operator|->
name|owner
operator|!=
name|NULL
operator|&&
name|comm
operator|->
name|owner
operator|->
name|config
operator|->
name|proxy
operator|!=
name|NULL
condition|)
block|{
name|perr
operator|=
call|(
modifier|*
name|comm
operator|->
name|owner
operator|->
name|config
operator|->
name|proxy
call|)
argument_list|(
operator|&
name|pdu
argument_list|,
name|port_index
argument_list|,
name|ret
argument_list|,
operator|*
name|retlen
argument_list|,
name|ierr
argument_list|,
name|vi
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|perr
condition|)
block|{
case|case
name|SNMPD_PROXY_OK
case|:
name|free
argument_list|(
name|resbuf
argument_list|)
expr_stmt|;
return|return;
case|case
name|SNMPD_PROXY_REJ
case|:
break|break;
case|case
name|SNMPD_PROXY_DROP
case|:
name|free
argument_list|(
name|resbuf
argument_list|)
expr_stmt|;
name|snmp_pdu_free
argument_list|(
operator|&
name|pdu
argument_list|)
expr_stmt|;
name|snmpd_stats
operator|.
name|proxyDrops
operator|++
expr_stmt|;
return|return;
case|case
name|SNMPD_PROXY_BADCOMM
case|:
name|free
argument_list|(
name|resbuf
argument_list|)
expr_stmt|;
name|snmp_pdu_free
argument_list|(
operator|&
name|pdu
argument_list|)
expr_stmt|;
name|snmpd_stats
operator|.
name|inBadCommunityNames
operator|++
expr_stmt|;
if|if
condition|(
name|snmpd
operator|.
name|auth_traps
condition|)
name|snmp_send_trap
argument_list|(
operator|&
name|oid_authenticationFailure
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
case|case
name|SNMPD_PROXY_BADCOMMUSE
case|:
name|free
argument_list|(
name|resbuf
argument_list|)
expr_stmt|;
name|snmp_pdu_free
argument_list|(
operator|&
name|pdu
argument_list|)
expr_stmt|;
name|snmpd_stats
operator|.
name|inBadCommunityUses
operator|++
expr_stmt|;
if|if
condition|(
name|snmpd
operator|.
name|auth_traps
condition|)
name|snmp_send_trap
argument_list|(
operator|&
name|oid_authenticationFailure
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Check type 	 */
if|if
condition|(
name|pdu
operator|.
name|type
operator|==
name|SNMP_PDU_RESPONSE
operator|||
name|pdu
operator|.
name|type
operator|==
name|SNMP_PDU_TRAP
operator|||
name|pdu
operator|.
name|type
operator|==
name|SNMP_PDU_TRAP2
condition|)
block|{
name|snmpd_stats
operator|.
name|silentDrops
operator|++
expr_stmt|;
name|snmpd_stats
operator|.
name|inBadPduTypes
operator|++
expr_stmt|;
name|snmp_pdu_free
argument_list|(
operator|&
name|pdu
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|resbuf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Check community 	 */
if|if
condition|(
name|community
operator|!=
name|COMM_WRITE
operator|&&
operator|(
name|pdu
operator|.
name|type
operator|==
name|SNMP_PDU_SET
operator|||
name|community
operator|!=
name|COMM_READ
operator|)
condition|)
block|{
name|snmpd_stats
operator|.
name|inBadCommunityUses
operator|++
expr_stmt|;
name|snmp_pdu_free
argument_list|(
operator|&
name|pdu
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|resbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|snmpd
operator|.
name|auth_traps
condition|)
name|snmp_send_trap
argument_list|(
operator|&
name|oid_authenticationFailure
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Execute it. 	 */
if|if
condition|(
operator|(
name|sndbuf
operator|=
name|buf_alloc
argument_list|(
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|snmpd_stats
operator|.
name|silentDrops
operator|++
expr_stmt|;
name|snmp_pdu_free
argument_list|(
operator|&
name|pdu
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|resbuf
argument_list|)
expr_stmt|;
return|return;
block|}
name|ferr
operator|=
name|snmp_input_finish
argument_list|(
operator|&
name|pdu
argument_list|,
name|resbuf
argument_list|,
name|len
argument_list|,
name|sndbuf
argument_list|,
operator|&
name|sndlen
argument_list|,
literal|"SNMP"
argument_list|,
name|ierr
argument_list|,
name|vi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferr
operator|==
name|SNMPD_INPUT_OK
condition|)
block|{
if|if
condition|(
operator|(
name|len
operator|=
name|sendto
argument_list|(
name|fd
argument_list|,
name|sndbuf
argument_list|,
name|sndlen
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
operator|*
name|retlen
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sendto: %m"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|size_t
operator|)
name|len
operator|!=
name|sndlen
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sendto: short write %zu/%zu"
argument_list|,
name|sndlen
argument_list|,
operator|(
name|size_t
operator|)
name|len
argument_list|)
expr_stmt|;
block|}
name|snmp_pdu_free
argument_list|(
operator|&
name|pdu
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sndbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|resbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ssock_input
parameter_list|(
name|int
name|fd
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|)
block|{
name|struct
name|snmp_port
modifier|*
name|p
init|=
name|udata
decl_stmt|;
name|p
operator|->
name|retlen
operator|=
sizeof|sizeof
argument_list|(
name|p
operator|->
name|ret
argument_list|)
expr_stmt|;
name|do_input
argument_list|(
name|fd
argument_list|,
operator|&
name|p
operator|->
name|index
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|p
operator|->
name|ret
argument_list|,
operator|&
name|p
operator|->
name|retlen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lsock_input
parameter_list|(
name|int
name|fd
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|)
block|{
name|struct
name|local_port
modifier|*
name|p
init|=
name|udata
decl_stmt|;
name|p
operator|->
name|retlen
operator|=
sizeof|sizeof
argument_list|(
name|p
operator|->
name|ret
argument_list|)
expr_stmt|;
name|do_input
argument_list|(
name|fd
argument_list|,
operator|&
name|p
operator|->
name|index
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|p
operator|->
name|ret
argument_list|,
operator|&
name|p
operator|->
name|retlen
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a UDP socket and bind it to the given port  */
end_comment

begin_function
specifier|static
name|int
name|init_snmp
parameter_list|(
name|struct
name|snmp_port
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|sockaddr_in
name|addr
decl_stmt|;
name|u_int32_t
name|ip
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|sock
operator|=
name|socket
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"creating UDP socket: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_ERR_RES_UNAVAIL
operator|)
return|;
block|}
name|ip
operator|=
operator|(
name|p
operator|->
name|addr
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|p
operator|->
name|addr
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|p
operator|->
name|addr
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|p
operator|->
name|addr
index|[
literal|3
index|]
expr_stmt|;
name|memset
argument_list|(
operator|&
name|addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|p
operator|->
name|port
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|addr
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|p
operator|->
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EADDRNOTAVAIL
condition|)
block|{
name|close
argument_list|(
name|p
operator|->
name|sock
argument_list|)
expr_stmt|;
name|p
operator|->
name|sock
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|SNMP_ERR_INCONS_NAME
operator|)
return|;
block|}
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bind: %s:%u %m"
argument_list|,
name|inet_ntoa
argument_list|(
name|addr
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|p
operator|->
name|port
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|p
operator|->
name|sock
argument_list|)
expr_stmt|;
name|p
operator|->
name|sock
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|SNMP_ERR_GENERR
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|p
operator|->
name|id
operator|=
name|fd_select
argument_list|(
name|p
operator|->
name|sock
argument_list|,
name|ssock_input
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|close
argument_list|(
name|p
operator|->
name|sock
argument_list|)
expr_stmt|;
name|p
operator|->
name|sock
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|SNMP_ERR_GENERR
operator|)
return|;
block|}
return|return
operator|(
name|SNMP_ERR_NOERROR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a new SNMP Port object and start it, if we are not  * in initialisation mode. The arguments are in host byte order.  */
end_comment

begin_function
name|int
name|open_snmp_port
parameter_list|(
name|u_int8_t
modifier|*
name|addr
parameter_list|,
name|u_int32_t
name|port
parameter_list|,
name|struct
name|snmp_port
modifier|*
modifier|*
name|pp
parameter_list|)
block|{
name|struct
name|snmp_port
modifier|*
name|snmp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|port
operator|>
literal|0xffff
condition|)
return|return
operator|(
name|SNMP_ERR_NO_CREATION
operator|)
return|;
if|if
condition|(
operator|(
name|snmp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|snmp
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|SNMP_ERR_GENERR
operator|)
return|;
name|snmp
operator|->
name|addr
index|[
literal|0
index|]
operator|=
name|addr
index|[
literal|0
index|]
expr_stmt|;
name|snmp
operator|->
name|addr
index|[
literal|1
index|]
operator|=
name|addr
index|[
literal|1
index|]
expr_stmt|;
name|snmp
operator|->
name|addr
index|[
literal|2
index|]
operator|=
name|addr
index|[
literal|2
index|]
expr_stmt|;
name|snmp
operator|->
name|addr
index|[
literal|3
index|]
operator|=
name|addr
index|[
literal|3
index|]
expr_stmt|;
name|snmp
operator|->
name|port
operator|=
name|port
expr_stmt|;
name|snmp
operator|->
name|sock
operator|=
operator|-
literal|1
expr_stmt|;
name|snmp
operator|->
name|id
operator|=
name|NULL
expr_stmt|;
name|snmp
operator|->
name|index
operator|.
name|len
operator|=
literal|5
expr_stmt|;
name|snmp
operator|->
name|index
operator|.
name|subs
index|[
literal|0
index|]
operator|=
name|addr
index|[
literal|0
index|]
expr_stmt|;
name|snmp
operator|->
name|index
operator|.
name|subs
index|[
literal|1
index|]
operator|=
name|addr
index|[
literal|1
index|]
expr_stmt|;
name|snmp
operator|->
name|index
operator|.
name|subs
index|[
literal|2
index|]
operator|=
name|addr
index|[
literal|2
index|]
expr_stmt|;
name|snmp
operator|->
name|index
operator|.
name|subs
index|[
literal|3
index|]
operator|=
name|addr
index|[
literal|3
index|]
expr_stmt|;
name|snmp
operator|->
name|index
operator|.
name|subs
index|[
literal|4
index|]
operator|=
name|port
expr_stmt|;
comment|/* 	 * Insert it into the right place 	 */
name|TAILQ_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&snmp_port_list
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|asn_compare_oid
argument_list|(
operator|&
name|p
operator|->
name|index
argument_list|,
operator|&
name|snmp
operator|->
name|index
argument_list|)
operator|>
literal|0
condition|)
block|{
name|TAILQ_INSERT_BEFORE
argument_list|(
name|p
argument_list|,
name|snmp
argument_list|,
name|link
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|snmp_port_list
argument_list|,
name|snmp
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|community
operator|!=
name|COMM_INITIALIZE
operator|&&
operator|(
name|err
operator|=
name|init_snmp
argument_list|(
name|snmp
argument_list|)
operator|)
operator|!=
name|SNMP_ERR_NOERROR
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|snmp_port_list
argument_list|,
name|snmp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|snmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
operator|*
name|pp
operator|=
name|snmp
expr_stmt|;
return|return
operator|(
name|SNMP_ERR_NOERROR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close an SNMP port  */
end_comment

begin_function
name|void
name|close_snmp_port
parameter_list|(
name|struct
name|snmp_port
modifier|*
name|snmp
parameter_list|)
block|{
if|if
condition|(
name|snmp
operator|->
name|id
operator|!=
name|NULL
condition|)
name|fd_deselect
argument_list|(
name|snmp
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|snmp
operator|->
name|sock
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|snmp
operator|->
name|sock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|snmp_port_list
argument_list|,
name|snmp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|snmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a local socket  */
end_comment

begin_function
specifier|static
name|int
name|init_local
parameter_list|(
name|struct
name|local_port
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|sockaddr_un
name|sa
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|sock
operator|=
name|socket
argument_list|(
name|PF_LOCAL
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"creating local socket: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_ERR_RES_UNAVAIL
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|sa
operator|.
name|sun_path
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sun_family
operator|=
name|AF_LOCAL
expr_stmt|;
name|sa
operator|.
name|sun_len
operator|=
name|strlen
argument_list|(
name|p
operator|->
name|name
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|,
name|sun_path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|p
operator|->
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sa
argument_list|,
sizeof|sizeof
argument_list|(
name|sa
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EADDRNOTAVAIL
condition|)
block|{
name|close
argument_list|(
name|p
operator|->
name|sock
argument_list|)
expr_stmt|;
name|p
operator|->
name|sock
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|SNMP_ERR_INCONS_NAME
operator|)
return|;
block|}
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bind: %s %m"
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|p
operator|->
name|sock
argument_list|)
expr_stmt|;
name|p
operator|->
name|sock
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|SNMP_ERR_GENERR
operator|)
return|;
block|}
if|if
condition|(
name|chmod
argument_list|(
name|p
operator|->
name|name
argument_list|,
literal|0666
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"chmod(%s,0666): %m"
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|id
operator|=
name|fd_select
argument_list|(
name|p
operator|->
name|sock
argument_list|,
name|lsock_input
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|remove
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|p
operator|->
name|sock
argument_list|)
expr_stmt|;
name|p
operator|->
name|sock
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|SNMP_ERR_GENERR
operator|)
return|;
block|}
return|return
operator|(
name|SNMP_ERR_NOERROR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Open a local port  */
end_comment

begin_function
name|int
name|open_local_port
parameter_list|(
name|u_char
modifier|*
name|name
parameter_list|,
name|size_t
name|namelen
parameter_list|,
name|struct
name|local_port
modifier|*
modifier|*
name|pp
parameter_list|)
block|{
name|struct
name|local_port
modifier|*
name|port
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|size_t
name|u
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|sockaddr_un
name|sa
decl_stmt|;
if|if
condition|(
name|namelen
operator|==
literal|0
operator|||
name|namelen
operator|+
literal|1
operator|>
sizeof|sizeof
argument_list|(
name|sa
operator|.
name|sun_path
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_ERR_BADVALUE
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|port
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|port
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_ERR_GENERR
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|port
operator|->
name|name
operator|=
name|malloc
argument_list|(
name|namelen
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_ERR_GENERR
operator|)
return|;
block|}
name|strncpy
argument_list|(
name|port
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|port
operator|->
name|name
index|[
name|namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|port
operator|->
name|sock
operator|=
operator|-
literal|1
expr_stmt|;
name|port
operator|->
name|id
operator|=
name|NULL
expr_stmt|;
name|port
operator|->
name|index
operator|.
name|len
operator|=
name|namelen
operator|+
literal|1
expr_stmt|;
name|port
operator|->
name|index
operator|.
name|subs
index|[
literal|0
index|]
operator|=
name|namelen
expr_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|namelen
condition|;
name|u
operator|++
control|)
name|port
operator|->
name|index
operator|.
name|subs
index|[
name|u
operator|+
literal|1
index|]
operator|=
name|name
index|[
name|u
index|]
expr_stmt|;
comment|/* 	 * Insert it into the right place 	 */
name|TAILQ_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&local_port_list
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|asn_compare_oid
argument_list|(
operator|&
name|p
operator|->
name|index
argument_list|,
operator|&
name|port
operator|->
name|index
argument_list|)
operator|>
literal|0
condition|)
block|{
name|TAILQ_INSERT_BEFORE
argument_list|(
name|p
argument_list|,
name|port
argument_list|,
name|link
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|local_port_list
argument_list|,
name|port
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|community
operator|!=
name|COMM_INITIALIZE
operator|&&
operator|(
name|err
operator|=
name|init_local
argument_list|(
name|port
argument_list|)
operator|)
operator|!=
name|SNMP_ERR_NOERROR
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|local_port_list
argument_list|,
name|port
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|port
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
operator|*
name|pp
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|SNMP_ERR_NOERROR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close a local port  */
end_comment

begin_function
name|void
name|close_local_port
parameter_list|(
name|struct
name|local_port
modifier|*
name|port
parameter_list|)
block|{
if|if
condition|(
name|port
operator|->
name|id
operator|!=
name|NULL
condition|)
name|fd_deselect
argument_list|(
name|port
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|sock
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|port
operator|->
name|sock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|port
operator|->
name|name
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|local_port_list
argument_list|,
name|port
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|port
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dump internal state.  */
end_comment

begin_function
specifier|static
name|void
name|info_func
parameter_list|(
name|evContext
name|ctx
name|__unused
parameter_list|,
name|void
modifier|*
name|uap
name|__unused
parameter_list|,
specifier|const
name|void
modifier|*
name|tag
name|__unused
parameter_list|)
block|{
name|struct
name|lmodule
modifier|*
name|m
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|10000
index|]
decl_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Dump of SNMPd %lu\n"
argument_list|,
operator|(
name|u_long
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tree_size
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|tree
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|SNMP_NODE_LEAF
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"LEAF: %s %s"
argument_list|,
name|tree
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|asn_oid2str
argument_list|(
operator|&
name|tree
index|[
name|i
index|]
operator|.
name|oid
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNMP_NODE_COLUMN
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"COL: %s %s"
argument_list|,
name|tree
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|asn_oid2str
argument_list|(
operator|&
name|tree
index|[
name|i
index|]
operator|.
name|oid
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|m
argument_list|,
argument|&lmodules
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|m
operator|->
name|config
operator|->
name|dump
condition|)
call|(
modifier|*
name|m
operator|->
name|config
operator|->
name|dump
call|)
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Re-read configuration  */
end_comment

begin_function
specifier|static
name|void
name|config_func
parameter_list|(
name|evContext
name|ctx
name|__unused
parameter_list|,
name|void
modifier|*
name|uap
name|__unused
parameter_list|,
specifier|const
name|void
modifier|*
name|tag
name|__unused
parameter_list|)
block|{
name|struct
name|lmodule
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|read_config
argument_list|(
name|config_file
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"error reading config file '%s'"
argument_list|,
name|config_file
argument_list|)
expr_stmt|;
return|return;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|m
argument_list|,
argument|&lmodules
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|m
operator|->
name|config
operator|->
name|config
condition|)
call|(
modifier|*
name|m
operator|->
name|config
operator|->
name|config
call|)
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * On USR1 dump actual configuration.  */
end_comment

begin_function
specifier|static
name|void
name|onusr1
parameter_list|(
name|int
name|s
name|__unused
parameter_list|)
block|{
name|work
operator||=
name|WORK_DOINFO
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|onhup
parameter_list|(
name|int
name|s
name|__unused
parameter_list|)
block|{
name|work
operator||=
name|WORK_RECONFIG
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|onterm
parameter_list|(
name|int
name|s
name|__unused
parameter_list|)
block|{
name|struct
name|local_port
modifier|*
name|p
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&local_port_list
argument_list|,
argument|link
argument_list|)
operator|(
name|void
operator|)
name|remove
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_sigs
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sigaction
name|sa
decl_stmt|;
name|sa
operator|.
name|sa_handler
operator|=
name|onusr1
expr_stmt|;
name|sa
operator|.
name|sa_flags
operator|=
name|SA_RESTART
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sa
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|SIGUSR1
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sigaction: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|sa
operator|.
name|sa_handler
operator|=
name|onhup
expr_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|SIGHUP
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sigaction: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|sa
operator|.
name|sa_handler
operator|=
name|onterm
expr_stmt|;
name|sa
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sa
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|SIGTERM
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sigaction: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sigaction: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|block_sigs
parameter_list|(
name|void
parameter_list|)
block|{
name|sigset_t
name|set
decl_stmt|;
name|sigfillset
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|set
argument_list|,
operator|&
name|blocked_sigs
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"SIG_BLOCK: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|unblock_sigs
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|blocked_sigs
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"SIG_SETMASK: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Shut down  */
end_comment

begin_function
specifier|static
name|void
name|term
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|pid_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Define a macro from the command line  */
end_comment

begin_function
specifier|static
name|void
name|do_macro
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|char
modifier|*
name|eq
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|eq
operator|=
name|strchr
argument_list|(
name|arg
argument_list|,
literal|'='
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
operator|=
name|define_macro
argument_list|(
name|arg
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|eq
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|err
operator|=
name|define_macro
argument_list|(
name|arg
argument_list|,
name|eq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot save macro: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Re-implement getsubopt from scratch, because the second argument is broken  * and will not compile with WARNS=5.  */
end_comment

begin_function
specifier|static
name|int
name|getsubopt1
parameter_list|(
name|char
modifier|*
modifier|*
name|arg
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|options
parameter_list|,
name|char
modifier|*
modifier|*
name|valp
parameter_list|,
name|char
modifier|*
modifier|*
name|optp
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|delim
init|=
literal|",\t "
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
operator|*
name|optp
operator|=
name|NULL
expr_stmt|;
comment|/* skip leading junk */
for|for
control|(
name|ptr
operator|=
operator|*
name|arg
init|;
operator|*
name|ptr
operator|!=
literal|'\0'
condition|;
name|ptr
operator|++
control|)
if|if
condition|(
name|strchr
argument_list|(
name|delim
argument_list|,
operator|*
name|ptr
argument_list|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|arg
operator|=
name|ptr
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|optp
operator|=
name|ptr
expr_stmt|;
comment|/* find the end of the option */
while|while
condition|(
operator|*
operator|++
name|ptr
operator|!=
literal|'\0'
condition|)
if|if
condition|(
name|strchr
argument_list|(
name|delim
argument_list|,
operator|*
name|ptr
argument_list|)
operator|!=
name|NULL
operator|||
operator|*
name|ptr
operator|==
literal|'='
condition|)
break|break;
if|if
condition|(
operator|*
name|ptr
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'='
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|valp
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|!=
literal|'\0'
operator|&&
name|strchr
argument_list|(
name|delim
argument_list|,
operator|*
name|ptr
argument_list|)
operator|==
name|NULL
condition|)
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|!=
literal|'\0'
condition|)
operator|*
name|ptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
operator|*
name|ptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|*
name|arg
operator|=
name|ptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|options
operator|!=
name|NULL
condition|;
name|options
operator|++
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|suboptarg
argument_list|,
operator|*
name|options
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|i
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|opt
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|background
init|=
literal|1
decl_stmt|;
name|struct
name|snmp_port
modifier|*
name|p
decl_stmt|;
name|struct
name|local_port
modifier|*
name|pl
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
init|=
literal|"snmpd"
decl_stmt|;
name|struct
name|lmodule
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|,
modifier|*
name|option
decl_stmt|;
define|#
directive|define
name|DBG_DUMP
value|0
define|#
directive|define
name|DBG_EVENTS
value|1
define|#
directive|define
name|DBG_TRACE
value|2
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|debug_opts
index|[]
init|=
block|{
literal|"dump"
block|,
literal|"events"
block|,
literal|"trace"
block|,
name|NULL
block|}
decl_stmt|;
name|snmp_printf
operator|=
name|snmp_printf_func
expr_stmt|;
name|snmp_error
operator|=
name|snmp_error_func
expr_stmt|;
name|snmp_debug
operator|=
name|snmp_debug_func
expr_stmt|;
name|asn_error
operator|=
name|asn_error_func
expr_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"c:dD:hI:l:m:p:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'c'
case|:
name|strlcpy
argument_list|(
name|config_file
argument_list|,
name|optarg
argument_list|,
sizeof|sizeof
argument_list|(
name|config_file
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|background
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
while|while
condition|(
operator|*
name|optarg
condition|)
block|{
switch|switch
condition|(
name|getsubopt1
argument_list|(
operator|&
name|optarg
argument_list|,
name|debug_opts
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|option
argument_list|)
condition|)
block|{
case|case
name|DBG_DUMP
case|:
name|debug
operator|.
name|dump_pdus
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DBG_EVENTS
case|:
name|debug
operator|.
name|evdebug
operator|++
expr_stmt|;
break|break;
case|case
name|DBG_TRACE
case|:
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no value for 'trace'"
argument_list|)
expr_stmt|;
name|snmp_trace
operator|=
name|strtoul
argument_list|(
name|value
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
if|if
condition|(
name|suboptarg
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unknown debug flag '%s'"
argument_list|,
name|option
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"missing debug flag"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
literal|'h'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|usgtxt
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'I'
case|:
name|syspath
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|prefix
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|do_macro
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|strlcpy
argument_list|(
name|pid_file
argument_list|,
name|optarg
argument_list|,
sizeof|sizeof
argument_list|(
name|pid_file
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|openlog
argument_list|(
name|prefix
argument_list|,
name|LOG_PID
operator||
operator|(
name|background
condition|?
literal|0
else|:
name|LOG_PERROR
operator|)
argument_list|,
name|LOG_USER
argument_list|)
expr_stmt|;
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|debug
operator|.
name|logpri
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|background
operator|&&
name|daemon
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"daemon: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
name|progargs
operator|=
name|argv
expr_stmt|;
name|nprogargs
operator|=
name|argc
expr_stmt|;
name|srandomdev
argument_list|()
expr_stmt|;
name|snmp_serial_no
operator|=
name|random
argument_list|()
expr_stmt|;
comment|/* 	 * Initialize the tree. 	 */
if|if
condition|(
operator|(
name|tree
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|snmp_node
argument_list|)
operator|*
name|CTREE_SIZE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|tree
argument_list|,
name|ctree
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|snmp_node
argument_list|)
operator|*
name|CTREE_SIZE
argument_list|)
expr_stmt|;
name|tree_size
operator|=
name|CTREE_SIZE
expr_stmt|;
comment|/* 	 * Get standard communities 	 */
operator|(
name|void
operator|)
name|comm_define
argument_list|(
literal|1
argument_list|,
literal|"SNMP read"
argument_list|,
name|NULL
argument_list|,
literal|"public"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|comm_define
argument_list|(
literal|2
argument_list|,
literal|"SNMP write"
argument_list|,
name|NULL
argument_list|,
literal|"public"
argument_list|)
expr_stmt|;
name|community
operator|=
name|COMM_INITIALIZE
expr_stmt|;
name|trap_reqid
operator|=
name|reqid_allocate
argument_list|(
literal|512
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_file
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|snprintf
argument_list|(
name|config_file
argument_list|,
sizeof|sizeof
argument_list|(
name|config_file
argument_list|)
argument_list|,
name|PATH_CONFIG
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|init_actvals
argument_list|()
expr_stmt|;
if|if
condition|(
name|read_config
argument_list|(
name|config_file
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"error in config file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|evCreate
argument_list|(
operator|&
name|evctx
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"evCreate: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
operator|.
name|evdebug
operator|>
literal|0
condition|)
name|evSetDebug
argument_list|(
name|evctx
argument_list|,
literal|10
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&snmp_port_list
argument_list|,
argument|link
argument_list|)
operator|(
name|void
operator|)
name|init_snmp
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pl
argument_list|,
argument|&local_port_list
argument_list|,
argument|link
argument_list|)
operator|(
name|void
operator|)
name|init_local
argument_list|(
name|pl
argument_list|)
expr_stmt|;
name|init_sigs
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid_file
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|snprintf
argument_list|(
name|pid_file
argument_list|,
sizeof|sizeof
argument_list|(
name|pid_file
argument_list|)
argument_list|,
name|PATH_PID
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|pid_file
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%u"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|atexit
argument_list|(
name|term
argument_list|)
expr_stmt|;
block|}
name|start_tick
operator|=
name|get_ticks
argument_list|()
expr_stmt|;
name|this_tick
operator|=
name|get_ticks
argument_list|()
expr_stmt|;
if|if
condition|(
name|or_register
argument_list|(
operator|&
name|oid_snmpMIB
argument_list|,
literal|"The MIB module for SNMPv2 entities."
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot register SNMPv2 MIB"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|or_register
argument_list|(
operator|&
name|oid_begemotSnmpd
argument_list|,
literal|"The MIB module for the Begemot SNMPd."
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot register begemotSnmpd MIB"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|snmp_send_trap
argument_list|(
operator|&
name|oid_coldStart
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|modules_start
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|m
operator|->
name|flags
operator|&=
operator|~
name|LM_ONSTARTLIST
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|modules_start
argument_list|,
name|m
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|lm_start
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|evEvent
name|event
decl_stmt|;
name|struct
name|lmodule
modifier|*
name|mod
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|mod
argument_list|,
argument|&lmodules
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|mod
operator|->
name|config
operator|->
name|idle
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|mod
operator|->
name|config
operator|->
name|idle
call|)
argument_list|()
expr_stmt|;
if|if
condition|(
name|evGetNext
argument_list|(
name|evctx
argument_list|,
operator|&
name|event
argument_list|,
name|EV_WAIT
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|evDispatch
argument_list|(
name|evctx
argument_list|,
name|event
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"evDispatch: %m"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"evGetNext: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|work
operator|!=
literal|0
condition|)
block|{
name|block_sigs
argument_list|()
expr_stmt|;
if|if
condition|(
name|work
operator|&
name|WORK_DOINFO
condition|)
block|{
if|if
condition|(
name|evWaitFor
argument_list|(
name|evctx
argument_list|,
operator|&
name|work
argument_list|,
name|info_func
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"evWaitFor: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|work
operator|&
name|WORK_RECONFIG
condition|)
block|{
if|if
condition|(
name|evWaitFor
argument_list|(
name|evctx
argument_list|,
operator|&
name|work
argument_list|,
name|config_func
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"evWaitFor: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|work
operator|=
literal|0
expr_stmt|;
name|unblock_sigs
argument_list|()
expr_stmt|;
if|if
condition|(
name|evDo
argument_list|(
name|evctx
argument_list|,
operator|&
name|work
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"evDo: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|u_int32_t
name|get_ticks
parameter_list|()
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|u_int32_t
name|ret
decl_stmt|;
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ret
operator|=
name|tv
operator|.
name|tv_sec
operator|*
literal|100
operator|+
name|tv
operator|.
name|tv_usec
operator|/
literal|10000
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Timer support  */
end_comment

begin_function
specifier|static
name|void
name|tfunc
parameter_list|(
name|evContext
name|ctx
name|__unused
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|struct
name|timespec
name|due
name|__unused
parameter_list|,
name|struct
name|timespec
name|inter
name|__unused
parameter_list|)
block|{
name|struct
name|timer
modifier|*
name|tp
init|=
name|uap
decl_stmt|;
name|LIST_REMOVE
argument_list|(
name|tp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|tp
operator|->
name|func
argument_list|(
name|tp
operator|->
name|udata
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start a timer  */
end_comment

begin_function
name|void
modifier|*
name|timer_start
parameter_list|(
name|u_int
name|ticks
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|,
name|struct
name|lmodule
modifier|*
name|mod
parameter_list|)
block|{
name|struct
name|timer
modifier|*
name|tp
decl_stmt|;
name|struct
name|timespec
name|due
decl_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|timer
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"out of memory for timer"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|due
operator|=
name|evAddTime
argument_list|(
name|evNowTime
argument_list|()
argument_list|,
name|evConsTime
argument_list|(
name|ticks
operator|/
literal|100
argument_list|,
operator|(
name|ticks
operator|%
literal|100
operator|)
operator|*
literal|10000
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|->
name|udata
operator|=
name|udata
expr_stmt|;
name|tp
operator|->
name|owner
operator|=
name|mod
expr_stmt|;
name|tp
operator|->
name|func
operator|=
name|func
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|timer_list
argument_list|,
name|tp
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|evSetTimer
argument_list|(
name|evctx
argument_list|,
name|tfunc
argument_list|,
name|tp
argument_list|,
name|due
argument_list|,
name|evConsTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|tp
operator|->
name|id
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot set timer: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|tp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|timer_stop
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|timer
modifier|*
name|tp
init|=
name|p
decl_stmt|;
name|LIST_REMOVE
argument_list|(
name|tp
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|evClearTimer
argument_list|(
name|evctx
argument_list|,
name|tp
operator|->
name|id
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot stop timer: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|timer_flush
parameter_list|(
name|struct
name|lmodule
modifier|*
name|mod
parameter_list|)
block|{
name|struct
name|timer
modifier|*
name|t
decl_stmt|,
modifier|*
name|t1
decl_stmt|;
name|t
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|timer_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|t
operator|!=
name|NULL
condition|)
block|{
name|t1
operator|=
name|LIST_NEXT
argument_list|(
name|t
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|owner
operator|==
name|mod
condition|)
name|timer_stop
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|t1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|snmp_printf_func
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
specifier|static
name|char
modifier|*
name|pend
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vasprintf
argument_list|(
operator|&
name|ret
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|pend
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|new
operator|=
name|realloc
argument_list|(
name|pend
argument_list|,
name|strlen
argument_list|(
name|pend
argument_list|)
operator|+
name|strlen
argument_list|(
name|ret
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return;
block|}
name|pend
operator|=
name|new
expr_stmt|;
name|strcat
argument_list|(
name|pend
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
else|else
name|pend
operator|=
name|ret
expr_stmt|;
while|while
condition|(
operator|(
name|ret
operator|=
name|strchr
argument_list|(
name|pend
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|ret
operator|=
literal|'\0'
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s"
argument_list|,
name|pend
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|ret
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|pend
argument_list|)
expr_stmt|;
name|pend
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|strcpy
argument_list|(
name|pend
argument_list|,
name|ret
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|snmp_error_func
parameter_list|(
specifier|const
name|char
modifier|*
name|err
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|errbuf
index|[
literal|1000
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
literal|"SNMP: "
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|errbuf
operator|+
name|strlen
argument_list|(
name|errbuf
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
operator|-
name|strlen
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|err
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s"
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|snmp_debug_func
parameter_list|(
specifier|const
name|char
modifier|*
name|err
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|errbuf
index|[
literal|1000
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
literal|"SNMP: "
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|errbuf
operator|+
name|strlen
argument_list|(
name|errbuf
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
operator|-
name|strlen
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|err
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s"
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|asn_error_func
parameter_list|(
specifier|const
name|struct
name|asn_buf
modifier|*
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|err
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|errbuf
index|[
literal|1000
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
literal|"ASN.1: "
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|errbuf
operator|+
name|strlen
argument_list|(
name|errbuf
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
operator|-
name|strlen
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|err
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|errbuf
operator|+
name|strlen
argument_list|(
name|errbuf
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
operator|-
name|strlen
argument_list|(
name|errbuf
argument_list|)
argument_list|,
literal|" at"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|b
operator|->
name|asn_len
operator|>
name|i
condition|;
name|i
operator|++
control|)
name|snprintf
argument_list|(
name|errbuf
operator|+
name|strlen
argument_list|(
name|errbuf
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
operator|-
name|strlen
argument_list|(
name|errbuf
argument_list|)
argument_list|,
literal|" %02x"
argument_list|,
name|b
operator|->
name|asn_cptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s"
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a new community  */
end_comment

begin_function
name|u_int
name|comm_define
parameter_list|(
name|u_int
name|priv
parameter_list|,
specifier|const
name|char
modifier|*
name|descr
parameter_list|,
name|struct
name|lmodule
modifier|*
name|owner
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|struct
name|community
modifier|*
name|c
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|u_int
name|ncomm
decl_stmt|;
comment|/* generate an identifier */
do|do
block|{
if|if
condition|(
operator|(
name|ncomm
operator|=
name|next_community_index
operator|++
operator|)
operator|==
name|UINT_MAX
condition|)
name|next_community_index
operator|=
literal|1
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|c
argument_list|,
argument|&community_list
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|c
operator|->
name|value
operator|==
name|ncomm
condition|)
break|break;
block|}
do|while
condition|(
name|c
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
operator|(
name|c
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|community
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"comm_define: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|c
operator|->
name|owner
operator|=
name|owner
expr_stmt|;
name|c
operator|->
name|value
operator|=
name|ncomm
expr_stmt|;
name|c
operator|->
name|descr
operator|=
name|descr
expr_stmt|;
name|c
operator|->
name|string
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|private
operator|=
name|priv
expr_stmt|;
if|if
condition|(
name|str
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|->
name|string
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|c
operator|->
name|string
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
comment|/* make index */
if|if
condition|(
name|c
operator|->
name|owner
operator|==
name|NULL
condition|)
block|{
name|c
operator|->
name|index
operator|.
name|len
operator|=
literal|1
expr_stmt|;
name|c
operator|->
name|index
operator|.
name|subs
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|c
operator|->
name|index
operator|=
name|c
operator|->
name|owner
operator|->
name|index
expr_stmt|;
block|}
name|c
operator|->
name|index
operator|.
name|subs
index|[
name|c
operator|->
name|index
operator|.
name|len
operator|++
index|]
operator|=
name|c
operator|->
name|private
expr_stmt|;
comment|/* 	 * Insert ordered 	 */
name|TAILQ_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&community_list
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|asn_compare_oid
argument_list|(
operator|&
name|p
operator|->
name|index
argument_list|,
operator|&
name|c
operator|->
name|index
argument_list|)
operator|>
literal|0
condition|)
block|{
name|TAILQ_INSERT_BEFORE
argument_list|(
name|p
argument_list|,
name|c
argument_list|,
name|link
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|community_list
argument_list|,
name|c
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|->
name|value
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|comm_string
parameter_list|(
name|u_int
name|ncomm
parameter_list|)
block|{
name|struct
name|community
modifier|*
name|p
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&community_list
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|p
operator|->
name|value
operator|==
name|ncomm
condition|)
return|return
operator|(
name|p
operator|->
name|string
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete all communities allocated by a module  */
end_comment

begin_function
specifier|static
name|void
name|comm_flush
parameter_list|(
name|struct
name|lmodule
modifier|*
name|mod
parameter_list|)
block|{
name|struct
name|community
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|p
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|community_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|p1
operator|=
name|TAILQ_NEXT
argument_list|(
name|p
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|owner
operator|==
name|mod
condition|)
block|{
name|free
argument_list|(
name|p
operator|->
name|string
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|community_list
argument_list|,
name|p
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|p1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Request ID handling.  *  * Allocate a new range of request ids. Use a first fit algorithm.  */
end_comment

begin_function
name|u_int
name|reqid_allocate
parameter_list|(
name|int
name|size
parameter_list|,
name|struct
name|lmodule
modifier|*
name|mod
parameter_list|)
block|{
name|u_int
name|type
decl_stmt|;
name|struct
name|idrange
modifier|*
name|r
decl_stmt|,
modifier|*
name|r1
decl_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
operator|||
name|size
operator|>
name|INT32_MAX
condition|)
block|{
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"%s: size out of range: %d"
argument_list|,
name|__func__
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* allocate a type id */
do|do
block|{
if|if
condition|(
operator|(
name|type
operator|=
name|next_idrange
operator|++
operator|)
operator|==
name|UINT_MAX
condition|)
name|next_idrange
operator|=
literal|1
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|r
argument_list|,
argument|&idrange_list
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|r
operator|->
name|type
operator|==
name|type
condition|)
break|break;
block|}
do|while
condition|(
name|r
operator|!=
name|NULL
condition|)
do|;
comment|/* find a range */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|idrange_list
argument_list|)
condition|)
name|r
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|r
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|idrange_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|base
operator|<
name|size
condition|)
block|{
while|while
condition|(
operator|(
name|r1
operator|=
name|TAILQ_NEXT
argument_list|(
name|r
argument_list|,
name|link
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|r1
operator|->
name|base
operator|-
operator|(
name|r
operator|->
name|base
operator|+
name|r
operator|->
name|size
operator|)
operator|>=
name|size
condition|)
break|break;
name|r
operator|=
name|r1
expr_stmt|;
block|}
name|r
operator|=
name|r1
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
name|r1
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|idrange_list
argument_list|,
name|idrange_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|INT32_MAX
operator|-
name|size
operator|+
literal|1
operator|<
name|r1
operator|->
name|base
operator|+
name|r1
operator|->
name|size
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"out of id ranges (%u)"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
comment|/* allocate structure */
if|if
condition|(
operator|(
name|r1
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|idrange
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: %m"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|r1
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|r1
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|r1
operator|->
name|owner
operator|=
name|mod
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|idrange_list
argument_list|)
operator|||
name|r
operator|==
name|TAILQ_FIRST
argument_list|(
operator|&
name|idrange_list
argument_list|)
condition|)
block|{
name|r1
operator|->
name|base
operator|=
literal|0
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|idrange_list
argument_list|,
name|r1
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|idrange_list
argument_list|,
name|idrange_list
argument_list|)
expr_stmt|;
name|r1
operator|->
name|base
operator|=
name|r
operator|->
name|base
operator|+
name|r
operator|->
name|size
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|idrange_list
argument_list|,
name|r1
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|TAILQ_PREV
argument_list|(
name|r
argument_list|,
name|idrange_list
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|r1
operator|->
name|base
operator|=
name|r
operator|->
name|base
operator|+
name|r
operator|->
name|size
expr_stmt|;
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|idrange_list
argument_list|,
name|r
argument_list|,
name|r1
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|r1
operator|->
name|next
operator|=
name|r1
operator|->
name|base
expr_stmt|;
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_function
name|int32_t
name|reqid_next
parameter_list|(
name|u_int
name|type
parameter_list|)
block|{
name|struct
name|idrange
modifier|*
name|r
decl_stmt|;
name|int32_t
name|id
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|r
argument_list|,
argument|&idrange_list
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|r
operator|->
name|type
operator|==
name|type
condition|)
break|break;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"wrong idrange type"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|id
operator|=
name|r
operator|->
name|next
operator|++
operator|)
operator|==
name|r
operator|->
name|base
operator|+
operator|(
name|r
operator|->
name|size
operator|-
literal|1
operator|)
condition|)
name|r
operator|->
name|next
operator|=
name|r
operator|->
name|base
expr_stmt|;
return|return
operator|(
name|id
operator|)
return|;
block|}
end_function

begin_function
name|int32_t
name|reqid_base
parameter_list|(
name|u_int
name|type
parameter_list|)
block|{
name|struct
name|idrange
modifier|*
name|r
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|r
argument_list|,
argument|&idrange_list
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|r
operator|->
name|type
operator|==
name|type
condition|)
return|return
operator|(
name|r
operator|->
name|base
operator|)
return|;
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"wrong idrange type"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|u_int
name|reqid_type
parameter_list|(
name|int32_t
name|reqid
parameter_list|)
block|{
name|struct
name|idrange
modifier|*
name|r
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|r
argument_list|,
argument|&idrange_list
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|reqid
operator|>=
name|r
operator|->
name|base
operator|&&
name|reqid
operator|<=
name|r
operator|->
name|base
operator|+
operator|(
name|r
operator|->
name|size
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
name|r
operator|->
name|type
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|reqid_istype
parameter_list|(
name|int32_t
name|reqid
parameter_list|,
name|u_int
name|type
parameter_list|)
block|{
return|return
operator|(
name|reqid_type
argument_list|(
name|reqid
argument_list|)
operator|==
name|type
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete all communities allocated by a module  */
end_comment

begin_function
specifier|static
name|void
name|reqid_flush
parameter_list|(
name|struct
name|lmodule
modifier|*
name|mod
parameter_list|)
block|{
name|struct
name|idrange
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|p
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|idrange_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|p1
operator|=
name|TAILQ_NEXT
argument_list|(
name|p
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|owner
operator|==
name|mod
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|idrange_list
argument_list|,
name|p
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|p1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Merge the given tree for the given module into the main tree.  */
end_comment

begin_function
specifier|static
name|int
name|compare_node
parameter_list|(
specifier|const
name|void
modifier|*
name|v1
parameter_list|,
specifier|const
name|void
modifier|*
name|v2
parameter_list|)
block|{
specifier|const
name|struct
name|snmp_node
modifier|*
name|n1
init|=
name|v1
decl_stmt|;
specifier|const
name|struct
name|snmp_node
modifier|*
name|n2
init|=
name|v2
decl_stmt|;
return|return
operator|(
name|asn_compare_oid
argument_list|(
operator|&
name|n1
operator|->
name|oid
argument_list|,
operator|&
name|n2
operator|->
name|oid
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tree_merge
parameter_list|(
specifier|const
name|struct
name|snmp_node
modifier|*
name|ntree
parameter_list|,
name|u_int
name|nsize
parameter_list|,
name|struct
name|lmodule
modifier|*
name|mod
parameter_list|)
block|{
name|struct
name|snmp_node
modifier|*
name|xtree
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|xtree
operator|=
name|realloc
argument_list|(
name|tree
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tree
argument_list|)
operator|*
operator|(
name|tree_size
operator|+
name|nsize
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xtree
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lm_load: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|tree
operator|=
name|xtree
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|tree
index|[
name|tree_size
index|]
argument_list|,
name|ntree
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tree
argument_list|)
operator|*
name|nsize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsize
condition|;
name|i
operator|++
control|)
name|tree
index|[
name|tree_size
operator|+
name|i
index|]
operator|.
name|data
operator|=
name|mod
expr_stmt|;
name|tree_size
operator|+=
name|nsize
expr_stmt|;
name|qsort
argument_list|(
name|tree
argument_list|,
name|tree_size
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|compare_node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove all nodes belonging to the loadable module  */
end_comment

begin_function
specifier|static
name|void
name|tree_unmerge
parameter_list|(
name|struct
name|lmodule
modifier|*
name|mod
parameter_list|)
block|{
name|u_int
name|s
decl_stmt|,
name|d
decl_stmt|;
for|for
control|(
name|s
operator|=
name|d
operator|=
literal|0
init|;
name|s
operator|<
name|tree_size
condition|;
name|s
operator|++
control|)
if|if
condition|(
name|tree
index|[
name|s
index|]
operator|.
name|data
operator|!=
name|mod
condition|)
block|{
if|if
condition|(
name|s
operator|!=
name|d
condition|)
name|tree
index|[
name|d
index|]
operator|=
name|tree
index|[
name|s
index|]
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
name|tree_size
operator|=
name|d
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Loadable modules  */
end_comment

begin_function
name|struct
name|lmodule
modifier|*
name|lm_load
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|)
block|{
name|struct
name|lmodule
modifier|*
name|m
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|av
index|[
name|MAX_MOD_ARGS
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|ac
decl_stmt|;
name|u_int
name|u
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|m
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lm_load: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|m
operator|->
name|handle
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|m
operator|->
name|section
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|path
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lm_load: %m"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|strcpy
argument_list|(
name|m
operator|->
name|path
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* 	 * Make index 	 */
name|m
operator|->
name|index
operator|.
name|subs
index|[
literal|0
index|]
operator|=
name|strlen
argument_list|(
name|section
argument_list|)
expr_stmt|;
name|m
operator|->
name|index
operator|.
name|len
operator|=
name|m
operator|->
name|index
operator|.
name|subs
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|m
operator|->
name|index
operator|.
name|subs
index|[
literal|0
index|]
condition|;
name|u
operator|++
control|)
name|m
operator|->
name|index
operator|.
name|subs
index|[
name|u
operator|+
literal|1
index|]
operator|=
name|section
index|[
name|u
index|]
expr_stmt|;
comment|/* 	 * Load the object file and locate the config structure 	 */
if|if
condition|(
operator|(
name|m
operator|->
name|handle
operator|=
name|dlopen
argument_list|(
name|m
operator|->
name|path
argument_list|,
name|RTLD_NOW
operator||
name|RTLD_GLOBAL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lm_load: open %s"
argument_list|,
name|dlerror
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|(
name|m
operator|->
name|config
operator|=
name|dlsym
argument_list|(
name|m
operator|->
name|handle
argument_list|,
literal|"config"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lm_load: no 'config' symbol %s"
argument_list|,
name|dlerror
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* 	 * Insert it into the right place 	 */
name|INSERT_OBJECT_OID
argument_list|(
name|m
argument_list|,
operator|&
name|lmodules
argument_list|)
expr_stmt|;
comment|/* preserve order */
if|if
condition|(
name|community
operator|==
name|COMM_INITIALIZE
condition|)
block|{
name|m
operator|->
name|flags
operator||=
name|LM_ONSTARTLIST
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|modules_start
argument_list|,
name|m
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * make the argument vector. 	 */
name|ac
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nprogargs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|progargs
index|[
name|i
index|]
argument_list|)
operator|>=
name|strlen
argument_list|(
name|section
argument_list|)
operator|+
literal|1
operator|&&
name|strncmp
argument_list|(
name|progargs
index|[
name|i
index|]
argument_list|,
name|section
argument_list|,
name|strlen
argument_list|(
name|section
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|progargs
index|[
name|i
index|]
index|[
name|strlen
argument_list|(
name|section
argument_list|)
index|]
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|ac
operator|==
name|MAX_MOD_ARGS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"too many arguments for "
literal|"module '%s"
argument_list|,
name|section
argument_list|)
expr_stmt|;
break|break;
block|}
name|av
index|[
name|ac
operator|++
index|]
operator|=
operator|&
name|progargs
index|[
name|i
index|]
index|[
name|strlen
argument_list|(
name|section
argument_list|)
operator|+
literal|1
index|]
expr_stmt|;
block|}
block|}
name|av
index|[
name|ac
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Run the initialisation function 	 */
if|if
condition|(
operator|(
name|err
operator|=
call|(
modifier|*
name|m
operator|->
name|config
operator|->
name|init
call|)
argument_list|(
name|m
argument_list|,
name|ac
argument_list|,
name|av
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"lm_load: init failed: %d"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lmodules
argument_list|,
name|m
argument_list|,
name|link
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
return|return
operator|(
name|m
operator|)
return|;
name|err
label|:
if|if
condition|(
name|m
operator|->
name|handle
condition|)
name|dlclose
argument_list|(
name|m
operator|->
name|handle
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|m
operator|->
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start a module  */
end_comment

begin_function
name|void
name|lm_start
parameter_list|(
name|struct
name|lmodule
modifier|*
name|mod
parameter_list|)
block|{
specifier|const
name|struct
name|lmodule
modifier|*
name|m
decl_stmt|;
comment|/* 	 * Merge tree. If this fails, unload the module. 	 */
if|if
condition|(
name|tree_merge
argument_list|(
name|mod
operator|->
name|config
operator|->
name|tree
argument_list|,
name|mod
operator|->
name|config
operator|->
name|tree_size
argument_list|,
name|mod
argument_list|)
condition|)
block|{
name|lm_unload
argument_list|(
name|mod
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Read configuration 	 */
if|if
condition|(
name|read_config
argument_list|(
name|config_file
argument_list|,
name|mod
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"error in config file"
argument_list|)
expr_stmt|;
name|lm_unload
argument_list|(
name|mod
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mod
operator|->
name|config
operator|->
name|start
condition|)
call|(
modifier|*
name|mod
operator|->
name|config
operator|->
name|start
call|)
argument_list|()
expr_stmt|;
name|mod
operator|->
name|flags
operator||=
name|LM_STARTED
expr_stmt|;
comment|/* 	 * Inform other modules 	 */
name|TAILQ_FOREACH
argument_list|(
argument|m
argument_list|,
argument|&lmodules
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|m
operator|->
name|config
operator|->
name|loading
condition|)
call|(
modifier|*
name|m
operator|->
name|config
operator|->
name|loading
call|)
argument_list|(
name|mod
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unload a module.  */
end_comment

begin_function
name|void
name|lm_unload
parameter_list|(
name|struct
name|lmodule
modifier|*
name|m
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
specifier|const
name|struct
name|lmodule
modifier|*
name|mod
decl_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lmodules
argument_list|,
name|m
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|LM_ONSTARTLIST
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|modules_start
argument_list|,
name|m
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|tree_unmerge
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|LM_STARTED
operator|)
operator|&&
name|m
operator|->
name|config
operator|->
name|fini
operator|&&
operator|(
name|err
operator|=
call|(
modifier|*
name|m
operator|->
name|config
operator|->
name|fini
call|)
argument_list|()
operator|)
operator|!=
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"lm_unload(%s): fini %d"
argument_list|,
name|m
operator|->
name|section
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|comm_flush
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|reqid_flush
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|timer_flush
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|fd_flush
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|dlclose
argument_list|(
name|m
operator|->
name|handle
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|m
operator|->
name|path
argument_list|)
expr_stmt|;
comment|/* 	 * Inform other modules 	 */
name|TAILQ_FOREACH
argument_list|(
argument|mod
argument_list|,
argument|&lmodules
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|mod
operator|->
name|config
operator|->
name|loading
condition|)
call|(
modifier|*
name|mod
operator|->
name|config
operator|->
name|loading
call|)
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Register an object resource and return the index (or 0 on failures)  */
end_comment

begin_function
name|u_int
name|or_register
parameter_list|(
specifier|const
name|struct
name|asn_oid
modifier|*
name|or
parameter_list|,
specifier|const
name|char
modifier|*
name|descr
parameter_list|,
name|struct
name|lmodule
modifier|*
name|mod
parameter_list|)
block|{
name|struct
name|objres
modifier|*
name|objres
decl_stmt|,
modifier|*
name|or1
decl_stmt|;
name|u_int
name|idx
decl_stmt|;
comment|/* find a free index */
name|idx
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|objres
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|objres_list
argument_list|)
init|;
name|objres
operator|!=
name|NULL
condition|;
name|objres
operator|=
name|TAILQ_NEXT
argument_list|(
name|objres
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|or1
operator|=
name|TAILQ_NEXT
argument_list|(
name|objres
argument_list|,
name|link
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|or1
operator|->
name|index
operator|>
name|objres
operator|->
name|index
operator|+
literal|1
condition|)
block|{
name|idx
operator|=
name|objres
operator|->
name|index
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|objres
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|objres
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|objres
operator|->
name|index
operator|=
name|idx
expr_stmt|;
name|objres
operator|->
name|oid
operator|=
operator|*
name|or
expr_stmt|;
name|strlcpy
argument_list|(
name|objres
operator|->
name|descr
argument_list|,
name|descr
argument_list|,
sizeof|sizeof
argument_list|(
name|objres
operator|->
name|descr
argument_list|)
argument_list|)
expr_stmt|;
name|objres
operator|->
name|uptime
operator|=
name|get_ticks
argument_list|()
operator|-
name|start_tick
expr_stmt|;
name|objres
operator|->
name|module
operator|=
name|mod
expr_stmt|;
name|INSERT_OBJECT_INT
argument_list|(
name|objres
argument_list|,
operator|&
name|objres_list
argument_list|)
expr_stmt|;
name|systemg
operator|.
name|or_last_change
operator|=
name|objres
operator|->
name|uptime
expr_stmt|;
return|return
operator|(
name|idx
operator|)
return|;
block|}
end_function

begin_function
name|void
name|or_unregister
parameter_list|(
name|u_int
name|idx
parameter_list|)
block|{
name|struct
name|objres
modifier|*
name|objres
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|objres
argument_list|,
argument|&objres_list
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|objres
operator|->
name|index
operator|==
name|idx
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|objres_list
argument_list|,
name|objres
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|objres
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

end_unit

