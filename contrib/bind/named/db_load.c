begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)db_load.c	4.38 (Berkeley) 3/2/91"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: db_load.c,v 8.32 1997/06/01 20:34:34 vixie Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * ++Copyright++ 1986, 1988, 1990  * -  * Copyright (c) 1986, 1988, 1990  *    The Regents of the University of California.  All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * 	This product includes software developed by the University of  * 	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  * -  * Portions Copyright (c) 1993 by Digital Equipment Corporation.  *   * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Digital Equipment Corporation not be used in advertising or  * publicity pertaining to distribution of the document or software without  * specific, written prior permission.  *   * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT  * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  * -  * Portions Copyright (c) 1995 by International Business Machines, Inc.  *  * International Business Machines, Inc. (hereinafter called IBM) grants  * permission under its copyrights to use, copy, modify, and distribute this  * Software with or without fee, provided that the above copyright notice and  * all paragraphs of this notice appear in all copies, and that the name of IBM  * not be used in connection with the marketing of any product incorporating  * the Software or modifications thereof, without specific, written prior  * permission.  *  * To the extent it has a right to do so, IBM grants an immunity from suit  * under its patents, if any, for the use, sale or manufacture of products to  * the extent that such products are used for performing Domain Name System  * dynamic updates in TCP/IP networks by means of the Software.  No immunity is  * granted for any product per se or for any other function of any product.  *  * THE SOFTWARE IS PROVIDED "AS IS", AND IBM DISCLAIMS ALL WARRANTIES,  * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  * PARTICULAR PURPOSE.  IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL,  * DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER ARISING  * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE, EVEN  * IF IBM IS APPRISED OF THE POSSIBILITY OF SUCH DAMAGES.  * --Copyright--  */
end_comment

begin_comment
comment|/*  * Load data base from ascii backupfile.  Format similar to RFC 883.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|"named.h"
end_include

begin_define
define|#
directive|define
name|ALLOW_LONG_TXT_RDATA
end_define

begin_decl_stmt
specifier|static
name|int
name|gettoken
name|__P
argument_list|(
operator|(
specifier|register
name|FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|,
name|getnonblank
name|__P
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|,
name|getprotocol
name|__P
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|,
name|getservices
name|__P
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|,
name|getcharstring
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|makename
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|makename_ok
name|__P
argument_list|(
operator|(
name|char
operator|*
name|name
operator|,
specifier|const
name|char
operator|*
name|origin
operator|,
name|int
name|class
operator|,
expr|enum
name|transport
name|transport
operator|,
expr|enum
name|context
name|context
operator|,
specifier|const
name|char
operator|*
name|owner
operator|,
specifier|const
name|char
operator|*
name|filename
operator|,
name|int
name|lineno
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getmlword
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getallwords
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|wordtouint32
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|datetosecs
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wordtouint32_error
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|empty_token
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getmlword_nesting
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|getnum_error
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Parser token values  */
end_comment

begin_define
define|#
directive|define
name|CURRENT
value|1
end_define

begin_define
define|#
directive|define
name|DOT
value|2
end_define

begin_define
define|#
directive|define
name|AT
value|3
end_define

begin_define
define|#
directive|define
name|DNAME
value|4
end_define

begin_define
define|#
directive|define
name|INCLUDE
value|5
end_define

begin_define
define|#
directive|define
name|ORIGIN
value|6
end_define

begin_define
define|#
directive|define
name|ERROR
value|7
end_define

begin_decl_stmt
specifier|static
name|int
name|clev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a zone deeper in a hierachy has more credability */
end_comment

begin_define
define|#
directive|define
name|MAKENAME_OK
parameter_list|(
name|N
parameter_list|)
value|if (!makename_ok(N, origin, class, \ 					 transport, context, \ 					 domain, filename, lineno)) { \ 				errs++; \ 				sprintf(buf, "bad name \"%s\"", N); \ 				goto err; \ 			}
end_define

begin_comment
comment|/* int  * db_load(filename, in_origin, zp, def_domain)  *	load a database from `filename' into zone `zp'.  append `in_origin'  *	to all nonterminal domain names in the file.  `def_domain' is the  *	default domain for include files or NULL for zone base files.  * returns:  *	-1 = can't open file  *	0 = success  *>0 = number of errors encountered  */
end_comment

begin_function
name|int
name|db_load
parameter_list|(
name|filename
parameter_list|,
name|in_origin
parameter_list|,
name|zp
parameter_list|,
name|def_domain
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|,
decl|*
name|in_origin
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|def_domain
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|int
name|read_soa
decl_stmt|,
name|read_ns
decl_stmt|,
name|rrcount
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|domain
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|char
name|origin
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|char
name|tmporigin
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|char
name|buf
index|[
name|MAXDATA
index|]
decl_stmt|;
name|char
name|data
index|[
name|MAXDATA
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|op
decl_stmt|;
name|int
name|c
decl_stmt|,
name|someclass
decl_stmt|,
name|class
decl_stmt|,
name|type
decl_stmt|,
name|dbflags
decl_stmt|,
name|dataflags
decl_stmt|,
name|multiline
decl_stmt|;
name|u_int32_t
name|ttl
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|slineno
decl_stmt|,
name|i
decl_stmt|,
name|errs
decl_stmt|,
name|didinclude
decl_stmt|;
specifier|register
name|u_int32_t
name|n
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|struct
name|in_addr
name|ina
decl_stmt|;
name|int
name|escape
decl_stmt|;
name|enum
name|transport
name|transport
decl_stmt|;
name|enum
name|context
name|context
decl_stmt|;
name|u_int32_t
name|sig_type
decl_stmt|;
name|u_int32_t
name|keyflags
decl_stmt|;
name|int
name|success
decl_stmt|;
name|int
name|dateerror
decl_stmt|;
ifdef|#
directive|ifdef
name|DO_WARN_SERIAL
name|u_int32_t
name|serial
decl_stmt|;
endif|#
directive|endif
comment|/* Simple macro for setting error messages about RR's being parsed,    before jumping to err label.  If no SETERR is done, the last word    scanned into "buf" by getword will be printed.  */
define|#
directive|define
name|SETERR
parameter_list|(
name|x
parameter_list|)
value|strcpy (buf, x);
switch|switch
condition|(
name|zp
operator|->
name|z_type
condition|)
block|{
case|case
name|Z_PRIMARY
case|:
case|case
name|Z_CACHE
case|:
name|transport
operator|=
name|primary_trans
expr_stmt|;
break|break;
case|case
name|Z_SECONDARY
case|:
case|case
name|Z_STUB
case|:
name|transport
operator|=
name|secondary_trans
expr_stmt|;
break|break;
default|default:
name|transport
operator|=
name|response_trans
expr_stmt|;
comment|/*guessing*/
break|break;
block|}
name|errs
operator|=
literal|0
expr_stmt|;
name|didinclude
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|def_domain
condition|)
block|{
comment|/* This is not the result of a $INCLUDE. */
name|rrcount
operator|=
literal|0
expr_stmt|;
name|read_soa
operator|=
literal|0
expr_stmt|;
name|read_ns
operator|=
literal|0
expr_stmt|;
name|clev
operator|=
name|db_getclev
argument_list|(
name|in_origin
argument_list|)
expr_stmt|;
block|}
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"db_load(%s, %s, %d, %s)\n"
operator|,
name|filename
operator|,
name|in_origin
operator|,
name|zp
operator|-
name|zones
operator|,
name|def_domain
condition|?
name|def_domain
else|:
literal|"Nil"
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|origin
argument_list|,
name|in_origin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s: %m"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"db_load: error opening file %s\n"
operator|,
name|filename
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_CACHE
condition|)
block|{
name|dbflags
operator|=
name|DB_NODATA
operator||
name|DB_NOHINTS
expr_stmt|;
name|dataflags
operator|=
name|DB_F_HINT
expr_stmt|;
ifdef|#
directive|ifdef
name|STUBS
block|}
elseif|else
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_STUB
operator|&&
name|clev
operator|==
literal|0
condition|)
block|{
name|dbflags
operator|=
name|DB_NODATA
operator||
name|DB_NOHINTS
expr_stmt|;
name|dataflags
operator|=
name|DB_F_HINT
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|dbflags
operator|=
name|DB_NODATA
expr_stmt|;
name|dataflags
operator|=
literal|0
expr_stmt|;
block|}
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s: %m"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|sb
operator|.
name|st_mtime
operator|=
operator|(
name|int
operator|)
name|tt
operator|.
name|tv_sec
expr_stmt|;
block|}
name|slineno
operator|=
name|lineno
expr_stmt|;
name|lineno
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|def_domain
condition|)
name|strcpy
argument_list|(
name|domain
argument_list|,
name|def_domain
argument_list|)
expr_stmt|;
else|else
name|domain
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|class
operator|=
name|zp
operator|->
name|z_class
expr_stmt|;
name|zp
operator|->
name|z_flags
operator|&=
operator|~
operator|(
name|Z_INCLUDE
operator||
name|Z_DB_BAD
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|gettoken
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|INCLUDE
case|:
if|if
condition|(
operator|!
name|getword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
comment|/* file name*/
break|break;
if|if
condition|(
operator|!
name|getword
argument_list|(
name|tmporigin
argument_list|,
sizeof|sizeof
argument_list|(
name|tmporigin
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
condition|)
name|strcpy
argument_list|(
name|tmporigin
argument_list|,
name|origin
argument_list|)
expr_stmt|;
else|else
block|{
name|makename
argument_list|(
name|tmporigin
argument_list|,
name|origin
argument_list|)
expr_stmt|;
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|didinclude
operator|=
literal|1
expr_stmt|;
name|errs
operator|+=
name|db_load
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|tmporigin
argument_list|,
name|zp
argument_list|,
name|domain
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|ORIGIN
case|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getword
argument_list|(
name|origin
argument_list|,
sizeof|sizeof
argument_list|(
name|origin
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"db_load: origin %s, buf %s\n"
operator|,
name|origin
operator|,
name|buf
operator|)
argument_list|)
expr_stmt|;
name|makename
argument_list|(
name|origin
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"db_load: origin now %s\n"
operator|,
name|origin
operator|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DNAME
case|:
if|if
condition|(
operator|!
name|getword
argument_list|(
name|domain
argument_list|,
sizeof|sizeof
argument_list|(
name|domain
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
name|n
operator|=
name|strlen
argument_list|(
name|domain
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|domain
index|[
name|n
index|]
operator|==
literal|'.'
condition|)
name|domain
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|origin
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|domain
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|domain
argument_list|,
name|origin
argument_list|)
expr_stmt|;
block|}
goto|goto
name|gotdomain
goto|;
case|case
name|AT
case|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|domain
argument_list|,
name|origin
argument_list|)
expr_stmt|;
goto|goto
name|gotdomain
goto|;
case|case
name|DOT
case|:
name|domain
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|CURRENT
case|:
name|gotdomain
label|:
if|if
condition|(
operator|!
name|getword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|CURRENT
condition|)
continue|continue;
break|break;
block|}
name|cp
operator|=
name|buf
expr_stmt|;
name|ttl
operator|=
name|USE_MINIMUM
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|n
operator|>
operator|(
name|INT_MAX
operator|-
operator|(
operator|*
name|cp
operator|-
literal|'0'
operator|)
operator|)
operator|/
literal|10
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: line %d: number> %lu\n"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
operator|(
name|u_long
operator|)
name|INT_MAX
argument_list|)
expr_stmt|;
name|n
operator|=
name|INT_MAX
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
else|else
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
do|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
name|errs
operator|++
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: Line %d: bad TTL: %s.\n"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_CACHE
condition|)
block|{
comment|/* this allows the cache entry to age */
comment|/* while sitting on disk (powered off) */
if|if
condition|(
name|n
operator|>
name|max_cache_ttl
condition|)
name|n
operator|=
name|max_cache_ttl
expr_stmt|;
name|n
operator|+=
name|sb
operator|.
name|st_mtime
expr_stmt|;
block|}
name|ttl
operator|=
name|n
expr_stmt|;
if|if
condition|(
operator|!
name|getword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
block|}
comment|/* Parse class (IN, etc) */
name|someclass
operator|=
name|sym_ston
argument_list|(
name|__p_class_syms
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
operator|&
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
operator|&&
name|someclass
operator|!=
name|C_ANY
condition|)
block|{
name|class
operator|=
name|someclass
expr_stmt|;
operator|(
name|void
operator|)
name|getword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Parse RR type (A, MX, etc) */
name|type
operator|=
name|sym_ston
argument_list|(
name|__p_type_syms
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
operator|&
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|success
operator|)
operator|||
name|type
operator|==
name|T_ANY
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"%s: Line %d: Unknown type: %s.\n"
operator|,
name|filename
operator|,
name|lineno
operator|,
name|buf
operator|)
argument_list|)
expr_stmt|;
name|errs
operator|++
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: Line %d: Unknown type: %s.\n"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
block|}
name|context
operator|=
name|ns_ownercontext
argument_list|(
name|type
argument_list|,
name|transport
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
name|domain
argument_list|,
name|class
argument_list|,
name|transport
argument_list|,
name|context
argument_list|,
name|domain
argument_list|,
name|inaddr_any
argument_list|)
condition|)
block|{
name|errs
operator|++
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%s:%d: owner name error\n"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
break|break;
block|}
name|context
operator|=
name|domain_ctx
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|ALLOW_T_UNSPEC
case|case
name|T_UNSPEC
case|:
endif|#
directive|endif
case|case
name|T_KEY
case|:
case|case
name|T_SIG
case|:
comment|/* Don't do anything here for these types -- 				   they read their own input separately later */
goto|goto
name|dont_get_word
goto|;
case|case
name|T_SOA
case|:
case|case
name|T_MINFO
case|:
case|case
name|T_RP
case|:
case|case
name|T_NS
case|:
case|case
name|T_CNAME
case|:
case|case
name|T_MB
case|:
case|case
name|T_MG
case|:
case|case
name|T_MR
case|:
case|case
name|T_PTR
case|:
name|escape
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|escape
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|getword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|,
name|escape
argument_list|)
condition|)
break|break;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"d='%s', c=%d, t=%d, ttl=%d, data='%s'\n"
operator|,
name|domain
operator|,
name|class
operator|,
name|type
operator|,
name|ttl
operator|,
name|buf
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Convert the ascii data 'buf' to the proper format 			 * based on the type and pack into 'data'. 			 */
name|dont_get_word
label|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
if|if
condition|(
operator|!
name|inet_aton
argument_list|(
name|buf
argument_list|,
operator|&
name|ina
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|n
operator|=
name|ntohl
argument_list|(
name|ina
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|cp
operator|=
name|data
expr_stmt|;
name|PUTLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|n
operator|=
name|INT32SZ
expr_stmt|;
break|break;
case|case
name|T_SOA
case|:
name|context
operator|=
name|hostname_ctx
expr_stmt|;
goto|goto
name|soa_rp_minfo
goto|;
case|case
name|T_RP
case|:
case|case
name|T_MINFO
case|:
name|context
operator|=
name|mailname_ctx
expr_stmt|;
comment|/* FALLTHROUGH */
name|soa_rp_minfo
label|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
name|MAKENAME_OK
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|cp
operator|=
name|data
operator|+
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|getword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
operator|(
sizeof|sizeof
name|data
operator|)
operator|-
operator|(
name|cp
operator|-
operator|(
name|char
operator|*
operator|)
name|data
operator|)
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|type
operator|==
name|T_RP
condition|)
name|context
operator|=
name|domain_ctx
expr_stmt|;
else|else
name|context
operator|=
name|mailname_ctx
expr_stmt|;
name|MAKENAME_OK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|T_SOA
condition|)
block|{
name|n
operator|=
name|cp
operator|-
operator|(
name|char
operator|*
operator|)
name|data
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|class
operator|!=
name|zp
operator|->
name|z_class
condition|)
block|{
name|errs
operator|++
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s:%d: %s"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
literal|"SOA class not same as zone's"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcasecmp
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|domain
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|errs
operator|++
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: line %d: SOA for \"%s\" not at zone top \"%s\""
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|domain
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|getnonblank
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
block|{
name|multiline
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|multiline
operator|=
literal|0
expr_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DO_WARN_SERIAL
name|serial
operator|=
name|zp
operator|->
name|z_serial
expr_stmt|;
endif|#
directive|endif
name|zp
operator|->
name|z_serial
operator|=
name|getnum
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|,
name|GETNUM_SERIAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|getnum_error
condition|)
name|errs
operator|++
expr_stmt|;
name|n
operator|=
operator|(
name|u_int32_t
operator|)
name|zp
operator|->
name|z_serial
expr_stmt|;
name|PUTLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DO_WARN_SERIAL
if|if
condition|(
name|serial
operator|&&
name|SEQ_GT
argument_list|(
name|serial
argument_list|,
name|zp
operator|->
name|z_serial
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%s:%d: WARNING: new serial number< old (%lu< %lu)"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|zp
operator|->
name|z_serial
argument_list|,
name|serial
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|zp
operator|->
name|z_refresh
operator|=
name|getnum
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|,
name|GETNUM_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|getnum_error
condition|)
block|{
name|errs
operator|++
expr_stmt|;
name|zp
operator|->
name|z_refresh
operator|=
name|INIT_REFRESH
expr_stmt|;
block|}
name|n
operator|=
operator|(
name|u_int32_t
operator|)
name|zp
operator|->
name|z_refresh
expr_stmt|;
name|PUTLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_SECONDARY
if|#
directive|if
name|defined
argument_list|(
name|STUBS
argument_list|)
operator|||
name|zp
operator|->
name|z_type
operator|==
name|Z_STUB
endif|#
directive|endif
condition|)
block|{
name|ns_refreshtime
argument_list|(
name|zp
argument_list|,
name|MIN
argument_list|(
name|sb
operator|.
name|st_mtime
argument_list|,
name|tt
operator|.
name|tv_sec
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|zp
operator|->
name|z_retry
operator|=
name|getnum
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|,
name|GETNUM_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|getnum_error
condition|)
block|{
name|errs
operator|++
expr_stmt|;
name|zp
operator|->
name|z_retry
operator|=
name|INIT_REFRESH
expr_stmt|;
block|}
name|n
operator|=
operator|(
name|u_int32_t
operator|)
name|zp
operator|->
name|z_retry
expr_stmt|;
name|PUTLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_expire
operator|=
name|getnum
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|,
name|GETNUM_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|getnum_error
condition|)
block|{
name|errs
operator|++
expr_stmt|;
name|zp
operator|->
name|z_expire
operator|=
name|INIT_REFRESH
expr_stmt|;
block|}
name|n
operator|=
operator|(
name|u_int32_t
operator|)
name|zp
operator|->
name|z_expire
expr_stmt|;
name|PUTLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_minimum
operator|=
name|getnum
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|,
name|GETNUM_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|getnum_error
condition|)
block|{
name|errs
operator|++
expr_stmt|;
name|zp
operator|->
name|z_minimum
operator|=
literal|120
expr_stmt|;
block|}
name|n
operator|=
operator|(
name|u_int32_t
operator|)
name|zp
operator|->
name|z_minimum
expr_stmt|;
name|PUTLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|n
operator|=
name|cp
operator|-
operator|(
name|char
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|multiline
condition|)
block|{
if|if
condition|(
name|getnonblank
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|)
operator|!=
literal|')'
condition|)
goto|goto
name|err
goto|;
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|read_soa
operator|++
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_type
operator|!=
name|Z_PRIMARY
condition|)
break|break;
comment|/* sanity checks PRIMARY ONLY */
comment|/* 				 * sanity: give enough time for the 				 * zone to transfer (retry) 				 */
if|if
condition|(
name|zp
operator|->
name|z_expire
operator|<
operator|(
name|zp
operator|->
name|z_refresh
operator|+
name|zp
operator|->
name|z_retry
operator|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%s: WARNING SOA expire value is less then SOA refresh + retry (%lu< %lu + %lu)"
argument_list|,
name|filename
argument_list|,
name|zp
operator|->
name|z_expire
argument_list|,
name|zp
operator|->
name|z_refresh
argument_list|,
name|zp
operator|->
name|z_retry
argument_list|)
expr_stmt|;
block|}
comment|/* BIND specific */
if|if
condition|(
name|zp
operator|->
name|z_expire
operator|<
name|maint_interval
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%s: WARNING SOA expire value is less then maintainance interval (%lu< %lu)"
argument_list|,
name|filename
argument_list|,
name|zp
operator|->
name|z_expire
argument_list|,
name|maint_interval
argument_list|)
expr_stmt|;
block|}
comment|/* BIND Specific */
if|if
condition|(
name|zp
operator|->
name|z_refresh
operator|<
name|maint_interval
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s: WARNING SOA refresh value is less then maintainance interval (%lu< %lu)"
argument_list|,
name|filename
argument_list|,
name|zp
operator|->
name|z_refresh
argument_list|,
name|maint_interval
argument_list|)
expr_stmt|;
block|}
comment|/* BIND specific */
if|if
condition|(
name|zp
operator|->
name|z_retry
operator|<
name|maint_interval
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s: WARNING SOA retry value is less then maintainance interval (%lu< %lu)"
argument_list|,
name|filename
argument_list|,
name|zp
operator|->
name|z_retry
argument_list|,
name|maint_interval
argument_list|)
expr_stmt|;
block|}
comment|/* sanity */
if|if
condition|(
name|zp
operator|->
name|z_expire
operator|<
operator|(
name|zp
operator|->
name|z_refresh
operator|+
literal|10
operator|*
name|zp
operator|->
name|z_retry
operator|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s: WARNING SOA expire value is less then refresh + 10 * retry (%lu< (%lu + 10 * %lu))"
argument_list|,
name|filename
argument_list|,
name|zp
operator|->
name|z_expire
argument_list|,
name|zp
operator|->
name|z_refresh
argument_list|,
name|zp
operator|->
name|z_retry
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * sanity: most harware/telco faults are 				 * detected and fixed within a week, 				 * secondaries should continue to 				 * operate for this time. 				 * (minimum of 4 days for long weekends) 				 */
if|if
condition|(
name|zp
operator|->
name|z_expire
operator|<
operator|(
literal|7
operator|*
literal|24
operator|*
literal|3600
operator|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s: WARNING SOA expire value is less then 7 days (%lu)"
argument_list|,
name|filename
argument_list|,
name|zp
operator|->
name|z_expire
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * sanity: maximum down time 				 * if we havn't talked for six months  				 * war must have broken out 				 */
if|if
condition|(
name|zp
operator|->
name|z_expire
operator|>
operator|(
literal|183
operator|*
literal|24
operator|*
literal|3600
operator|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s: WARNING SOA expire value is greater then 6 months (%lu)"
argument_list|,
name|filename
argument_list|,
name|zp
operator|->
name|z_expire
argument_list|)
expr_stmt|;
block|}
comment|/* sanity */
if|if
condition|(
name|zp
operator|->
name|z_refresh
operator|<
operator|(
name|zp
operator|->
name|z_retry
operator|*
literal|2
operator|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s: WARNING SOA refresh value is less than 2 * retry (%lu< %lu * 2)"
argument_list|,
name|filename
argument_list|,
name|zp
operator|->
name|z_refresh
argument_list|,
name|zp
operator|->
name|z_retry
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|T_UID
case|:
case|case
name|T_GID
case|:
name|n
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|buf
condition|)
goto|goto
name|err
goto|;
name|cp
operator|=
name|data
expr_stmt|;
name|PUTLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|n
operator|=
name|INT32SZ
expr_stmt|;
break|break;
case|case
name|T_WKS
case|:
comment|/* Address */
if|if
condition|(
operator|!
name|inet_aton
argument_list|(
name|buf
argument_list|,
operator|&
name|ina
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|n
operator|=
name|ntohl
argument_list|(
name|ina
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|cp
operator|=
name|data
expr_stmt|;
name|PUTLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
operator|(
name|char
operator|)
name|getprotocol
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* Protocol */
name|n
operator|=
name|INT32SZ
operator|+
sizeof|sizeof
argument_list|(
name|char
argument_list|)
expr_stmt|;
comment|/* Services */
name|n
operator|=
name|getservices
argument_list|(
operator|(
name|int
operator|)
name|n
argument_list|,
name|data
argument_list|,
name|fp
argument_list|,
name|filename
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_NS
case|:
if|if
condition|(
name|strcasecmp
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|domain
argument_list|)
operator|==
literal|0
condition|)
name|read_ns
operator|++
expr_stmt|;
name|context
operator|=
name|hostname_ctx
expr_stmt|;
goto|goto
name|cname_etc
goto|;
case|case
name|T_CNAME
case|:
case|case
name|T_MB
case|:
case|case
name|T_MG
case|:
case|case
name|T_MR
case|:
name|context
operator|=
name|domain_ctx
expr_stmt|;
goto|goto
name|cname_etc
goto|;
case|case
name|T_PTR
case|:
name|context
operator|=
name|ns_ptrcontext
argument_list|(
name|domain
argument_list|)
expr_stmt|;
name|cname_etc
label|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
name|MAKENAME_OK
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|T_UINFO
case|:
name|cp
operator|=
name|strchr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|'&'
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|cp
operator|-
name|buf
argument_list|)
expr_stmt|;
name|op
operator|=
name|strchr
argument_list|(
name|domain
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|strncat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|domain
argument_list|,
name|op
operator|-
name|domain
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strcat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|domain
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|++
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|T_NAPTR
case|:
comment|/* Order Preference Flags Service Replacement Regexp */
name|n
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
comment|/* Order */
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
comment|/* catch bad values */
if|if
condition|(
operator|(
name|cp
operator|==
name|buf
operator|)
operator|||
operator|(
name|n
operator|>
literal|65535
operator|)
condition|)
goto|goto
name|err
goto|;
name|cp
operator|=
name|data
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* Preference */
name|n
operator|=
name|getnum
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|,
name|GETNUM_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|getnum_error
operator|||
name|n
operator|>
literal|65536
condition|)
goto|goto
name|err
goto|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* Flags */
if|if
condition|(
operator|!
name|getword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|n
expr_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* Service Classes */
if|if
condition|(
operator|!
name|getword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|n
expr_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* Pattern */
if|if
condition|(
operator|!
name|getword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|n
expr_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* Replacement */
if|if
condition|(
operator|!
name|getword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|err
goto|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
name|context
operator|=
name|domain_ctx
expr_stmt|;
name|MAKENAME_OK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* advance pointer to end of data */
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* now save length */
name|n
operator|=
operator|(
name|cp
operator|-
operator|(
name|char
operator|*
operator|)
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|T_MX
case|:
case|case
name|T_AFSDB
case|:
case|case
name|T_RT
case|:
case|case
name|T_SRV
case|:
name|n
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
comment|/* catch bad values */
if|if
condition|(
operator|(
name|cp
operator|==
name|buf
operator|)
operator|||
operator|(
name|n
operator|>
literal|65535
operator|)
condition|)
goto|goto
name|err
goto|;
name|cp
operator|=
name|data
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SRV
condition|)
block|{
name|n
operator|=
name|getnum
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|,
name|GETNUM_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|getnum_error
operator|||
name|n
operator|>
literal|65536
condition|)
goto|goto
name|err
goto|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|n
operator|=
name|getnum
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|,
name|GETNUM_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|getnum_error
operator|||
name|n
operator|>
literal|65536
condition|)
goto|goto
name|err
goto|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|getword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|err
goto|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
name|context
operator|=
name|hostname_ctx
expr_stmt|;
name|MAKENAME_OK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* advance pointer to end of data */
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* now save length */
name|n
operator|=
operator|(
name|cp
operator|-
operator|(
name|char
operator|*
operator|)
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|T_PX
case|:
name|context
operator|=
name|domain_ctx
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
comment|/* catch bad values */
if|if
condition|(
operator|(
name|cp
operator|==
name|buf
operator|)
operator|||
operator|(
name|n
operator|>
literal|65535
operator|)
condition|)
goto|goto
name|err
goto|;
name|cp
operator|=
name|data
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|err
goto|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
name|MAKENAME_OK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* advance pointer to next field */
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|getword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|err
goto|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
name|MAKENAME_OK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* advance pointer to end of data */
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* now save length */
name|n
operator|=
operator|(
name|cp
operator|-
operator|(
name|char
operator|*
operator|)
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|T_HINFO
case|:
name|n
operator|=
name|getcharstring
argument_list|(
name|buf
argument_list|,
name|data
argument_list|,
name|type
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
name|fp
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
goto|goto
name|err
goto|;
break|break;
case|case
name|T_ISDN
case|:
name|n
operator|=
name|getcharstring
argument_list|(
name|buf
argument_list|,
name|data
argument_list|,
name|type
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|fp
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
goto|goto
name|err
goto|;
break|break;
case|case
name|T_TXT
case|:
name|n
operator|=
name|getcharstring
argument_list|(
name|buf
argument_list|,
name|data
argument_list|,
name|type
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|fp
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
goto|goto
name|err
goto|;
break|break;
case|case
name|T_X25
case|:
name|n
operator|=
name|getcharstring
argument_list|(
name|buf
argument_list|,
name|data
argument_list|,
name|type
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
goto|goto
name|err
goto|;
break|break;
case|case
name|T_NSAP
case|:
name|n
operator|=
name|inet_nsap_addr
argument_list|(
name|buf
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
goto|goto
name|err
goto|;
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_AAAA
case|:
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|buf
argument_list|,
name|data
argument_list|)
operator|<=
literal|0
condition|)
goto|goto
name|err
goto|;
name|n
operator|=
name|IN6ADDRSZ
expr_stmt|;
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_KEY
case|:
block|{
comment|/* The KEY record looks like this in the db file: 	 *	Name  Cl KEY Flags  Proto  Algid  PublicKeyData 	 * where: 	 *	Name,Cl per usual 	 *	KEY	RR type 	 *	Flags	4 digit hex value (unsigned_16) 	 *	Proto	8 bit u_int 	 *	Algid	8 bit u_int 	 *	PublicKeyData 	 *		a string of base64 digits, 	 *		skipping any embedded whitespace. 	 */
name|u_int32_t
name|al
decl_stmt|,
name|pr
decl_stmt|;
name|int
name|nk
decl_stmt|,
name|klen
decl_stmt|;
name|char
modifier|*
name|expstart
decl_stmt|;
name|u_int
name|expbytes
decl_stmt|,
name|modbytes
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|data
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
name|data
expr_stmt|;
name|getmlword_nesting
operator|=
literal|0
expr_stmt|;
comment|/* KLUDGE err recov. */
comment|/*>>> Flags (unsigned_16)  */
if|if
condition|(
operator|!
name|getmlword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|SETERR
argument_list|(
literal|"No flags field"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|keyflags
operator|=
name|wordtouint32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|wordtouint32_error
operator|||
literal|0xFFFF
operator|<
name|keyflags
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|keyflags
operator|&
name|KEYFLAG_RESERVED_BITMASK
condition|)
block|{
name|SETERR
argument_list|(
literal|"Reserved flag bits are set"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|PUTSHORT
argument_list|(
name|keyflags
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/*>>> Protocol (8-bit decimal) */
if|if
condition|(
operator|!
name|getmlword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|SETERR
argument_list|(
literal|"No protocol field"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|pr
operator|=
name|wordtouint32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|wordtouint32_error
operator|||
literal|255
operator|<
name|pr
condition|)
goto|goto
name|err
goto|;
operator|*
name|cp
operator|++
operator|=
operator|(
name|u_char
operator|)
name|pr
expr_stmt|;
comment|/*>>> Algorithm id (8-bit decimal) */
if|if
condition|(
operator|!
name|getmlword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|SETERR
argument_list|(
literal|"No algorithm ID"
argument_list|)
goto|goto
name|err
goto|;
block|}
name|al
operator|=
name|wordtouint32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|wordtouint32_error
operator|||
literal|0
operator|==
name|al
operator|||
literal|255
operator|==
name|al
operator|||
literal|255
operator|<
name|al
condition|)
goto|goto
name|err
goto|;
operator|*
name|cp
operator|++
operator|=
operator|(
name|u_char
operator|)
name|al
expr_stmt|;
comment|/*>>> Public Key data is in BASE64. 			 *	We don't care what algorithm it uses or what 			 *	the internal structure of the BASE64 data is. 			 */
if|if
condition|(
operator|!
name|getallwords
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|MAXDATA
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|klen
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Convert from BASE64 to binary. */
name|klen
operator|=
name|b64_pton
argument_list|(
name|buf
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|,
sizeof|sizeof
name|data
operator|-
operator|(
name|cp
operator|-
operator|(
name|char
operator|*
operator|)
name|data
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|klen
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
block|}
comment|/* set total length */
name|n
operator|=
name|cp
operator|+
name|klen
operator|-
operator|(
name|char
operator|*
operator|)
name|data
expr_stmt|;
comment|/* 			 * Now check for valid key flags& algs& etc, 			 * from the RFC. 			 */
if|if
condition|(
name|keyflags
operator|&
operator|(
name|KEYFLAG_ZONEKEY
operator||
name|KEYFLAG_IPSEC
operator||
name|KEYFLAG_EMAIL
operator|)
condition|)
name|pr
operator||=
literal|1
expr_stmt|;
comment|/* A nonzero proto. */
if|if
condition|(
name|KEYFLAG_TYPE_NO_KEY
operator|==
operator|(
name|keyflags
operator|&
name|KEYFLAG_TYPEMASK
operator|)
condition|)
name|nk
operator|=
literal|1
expr_stmt|;
comment|/* No-key */
else|else
name|nk
operator|=
literal|0
expr_stmt|;
comment|/* have a key */
if|if
condition|(
operator|(
name|keyflags
operator|&
name|KEYFLAG_ZONEKEY
operator|)
operator|&&
operator|(
name|KEYFLAG_TYPE_CONF_ONLY
operator|==
operator|(
name|keyflags
operator|&
name|KEYFLAG_TYPEMASK
operator|)
operator|)
condition|)
block|{
comment|/* Zone key must have Authentication bit                                        set  ogud@tis.com */
name|SETERR
argument_list|(
literal|"Zonekey needs authentication bit"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|al
operator|==
literal|0
operator|&&
name|nk
operator|==
literal|0
condition|)
block|{
name|SETERR
argument_list|(
literal|"Key specified, but no alg"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|al
operator|!=
literal|0
operator|&&
name|pr
operator|==
literal|0
condition|)
block|{
name|SETERR
argument_list|(
literal|"Alg specified, but no protos"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|nk
operator|==
literal|1
operator|&&
name|klen
operator|!=
literal|0
condition|)
block|{
name|SETERR
argument_list|(
literal|"No-key flags set but key fnd"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|nk
operator|==
literal|0
operator|&&
name|klen
operator|==
literal|0
condition|)
block|{
name|SETERR
argument_list|(
literal|"Key type spec'd, but no key"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Check algorithm-ID and key structure, for 				   the algorithm-ID's that we know about. */
switch|switch
condition|(
name|al
condition|)
block|{
case|case
name|ALGORITHM_MD5RSA
case|:
if|if
condition|(
name|klen
operator|==
literal|0
condition|)
break|break;
name|expstart
operator|=
name|cp
expr_stmt|;
name|expbytes
operator|=
operator|*
name|expstart
operator|++
expr_stmt|;
if|if
condition|(
name|expbytes
operator|==
literal|0
condition|)
name|GETSHORT
argument_list|(
name|expbytes
argument_list|,
name|expstart
argument_list|)
expr_stmt|;
if|if
condition|(
name|expbytes
operator|<
literal|1
condition|)
block|{
name|SETERR
argument_list|(
literal|"Exponent too short"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|expbytes
operator|>
operator|(
name|MAX_MD5RSA_KEY_PART_BITS
operator|+
literal|7
operator|)
operator|/
literal|8
condition|)
block|{
name|SETERR
argument_list|(
literal|"Exponent too long"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|*
name|expstart
operator|==
literal|0
condition|)
block|{
name|SETERR
argument_list|(
literal|"Exponent starts w/ 0"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|modbytes
operator|=
name|klen
operator|-
operator|(
name|expbytes
operator|+
operator|(
name|expstart
operator|-
name|cp
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|modbytes
operator|<
operator|(
name|MIN_MD5RSA_KEY_PART_BITS
operator|+
literal|7
operator|)
operator|/
literal|8
condition|)
block|{
name|SETERR
argument_list|(
literal|"Modulus too short"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|modbytes
operator|>
operator|(
name|MAX_MD5RSA_KEY_PART_BITS
operator|+
literal|7
operator|)
operator|/
literal|8
condition|)
block|{
name|SETERR
argument_list|(
literal|"Modulus too long"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|*
operator|(
name|expstart
operator|+
name|expbytes
operator|)
operator|==
literal|0
condition|)
block|{
name|SETERR
argument_list|(
literal|"Modulus starts w/ 0"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
break|break;
case|case
name|ALGORITHM_EXPIRE_ONLY
case|:
if|if
condition|(
name|klen
operator|!=
literal|0
condition|)
block|{
name|SETERR
argument_list|(
literal|"Key provided for expire-only algorithm"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
break|break;
case|case
name|ALGORITHM_PRIVATE_OID
case|:
if|if
condition|(
name|klen
operator|==
literal|0
condition|)
block|{
name|SETERR
argument_list|(
literal|"No ObjectID in key"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
break|break;
block|}
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* flush the rest of the line */
break|break;
block|}
comment|/*T_KEY*/
case|case
name|T_SIG
case|:
block|{
comment|/* The SIG record looks like this in the db file: 		   Name Cl SIG RRtype Algid [OTTL] Texp Tsig Kfoot Signer Sig 		      		   where:  Name and Cl are as usual 			   SIG     is a keyword 			   RRtype  is a char string  			   ALGid   is  8 bit u_int 			   OTTL    is 32 bit u_int (optionally present) 			   Texp    is YYYYMMDDHHMMSS 			   Tsig    is YYYYMMDDHHMMSS 			   Kfoot   is 16-bit unsigned decimal integer 			   Signer  is a char string 			   Sig     is 64 to 319 base-64 digits 		   A missing OTTL is detected by the magnitude of the Texp value 		   that follows it, which is larger than any u_int. 		   The Labels field in the binary RR does not appear in the 		   text RR.  		   It's too crazy to run these pages of SIG code at the right 		   margin.  I'm exdenting them for readability. 		 */
name|int
name|siglen
decl_stmt|;
name|u_int32_t
name|al
decl_stmt|;
name|u_int32_t
name|signtime
decl_stmt|,
name|exptime
decl_stmt|,
name|timetilexp
decl_stmt|;
name|u_int32_t
name|origTTL
decl_stmt|;
name|time_t
name|now
decl_stmt|;
comment|/* The TTL gets checked against the Original TTL, 		   and bounded by the signature expiration time, which  		   are both under the signature.  We can't let TTL drift 		   based on the SOA record.  If defaulted, fix it now.  		   (It's not clear to me why USE_MINIMUM isn't eliminated 		   before putting ALL RR's into the database.  -gnu@toad.com) */
if|if
condition|(
name|ttl
operator|==
name|USE_MINIMUM
condition|)
name|ttl
operator|=
name|zp
operator|->
name|z_minimum
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|data
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|getmlword_nesting
operator|=
literal|0
expr_stmt|;
comment|/* KLUDGE err recovery */
comment|/* RRtype (char *) */
if|if
condition|(
operator|!
name|getmlword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|SETERR
argument_list|(
literal|"SIG record doesn't specify type"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|sig_type
operator|=
name|sym_ston
argument_list|(
name|__p_type_syms
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
operator|&
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
operator|||
name|sig_type
operator|==
name|T_ANY
condition|)
block|{
comment|/* 			 * We'll also accept a numeric RR type, 			 * for signing RR types that this version 			 * of named doesn't yet understand. 			 * In the T_ANY case, we rely on wordtouint32 			 * to fail when scanning the string "ANY". 			 */
name|sig_type
operator|=
name|wordtouint32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|wordtouint32_error
operator|||
name|sig_type
operator|>
literal|0xFFFF
condition|)
block|{
name|SETERR
argument_list|(
literal|"Unknown RR type in SIG record"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
name|cp
operator|=
operator|&
name|data
index|[
name|i
index|]
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|sig_type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
comment|/* Algorithm id (8-bit decimal) */
if|if
condition|(
operator|!
name|getmlword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|SETERR
argument_list|(
literal|"Missing algorithm ID"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|al
operator|=
name|wordtouint32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|al
operator|||
name|wordtouint32_error
operator|||
literal|255
operator|<=
name|al
condition|)
goto|goto
name|err
goto|;
name|data
index|[
name|i
index|]
operator|=
operator|(
name|u_char
operator|)
name|al
expr_stmt|;
name|i
operator|++
expr_stmt|;
comment|/* 		 * Labels (8-bit decimal) 		 *	Not given in the file.  Must compute. 		 */
name|n
operator|=
name|dn_count_labels
argument_list|(
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|>=
name|n
operator|||
literal|255
operator|<
name|n
condition|)
block|{
name|SETERR
argument_list|(
literal|"SIG label count invalid"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|data
index|[
name|i
index|]
operator|=
operator|(
name|u_char
operator|)
name|n
expr_stmt|;
name|i
operator|++
expr_stmt|;
comment|/* 		 * OTTL (optional u_int32_t) and 		 * Texp (u_int32_t date) 		 */
if|if
condition|(
operator|!
name|getmlword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|SETERR
argument_list|(
literal|"OTTL and expiration time missing"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* 		 * See if OTTL is missing and this is a date. 		 * This relies on good, silent error checking 		 * in datetosecs. 		 */
name|exptime
operator|=
name|datetosecs
argument_list|(
name|buf
argument_list|,
operator|&
name|dateerror
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dateerror
condition|)
block|{
comment|/* Output TTL as OTTL */
name|origTTL
operator|=
name|ttl
expr_stmt|;
name|cp
operator|=
operator|&
name|data
index|[
name|i
index|]
expr_stmt|;
name|PUTLONG
argument_list|(
name|origTTL
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* Parse and output OTTL; scan TEXP */
name|origTTL
operator|=
name|wordtouint32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|>=
name|origTTL
operator|||
name|wordtouint32_error
operator|||
operator|(
name|origTTL
operator|>
literal|0x7fffffff
operator|)
condition|)
goto|goto
name|err
goto|;
name|cp
operator|=
operator|&
name|data
index|[
name|i
index|]
expr_stmt|;
name|PUTLONG
argument_list|(
name|origTTL
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|getmlword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|SETERR
argument_list|(
literal|"Expiration time missing"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|exptime
operator|=
name|datetosecs
argument_list|(
name|buf
argument_list|,
operator|&
name|dateerror
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dateerror
operator|||
name|exptime
operator|>
literal|0x7fffffff
operator|||
name|exptime
operator|<=
literal|0
condition|)
block|{
name|SETERR
argument_list|(
literal|"Invalid expiration time"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|cp
operator|=
operator|&
name|data
index|[
name|i
index|]
expr_stmt|;
name|PUTLONG
argument_list|(
name|exptime
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
comment|/* Tsig (u_int32_t) */
if|if
condition|(
operator|!
name|getmlword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|SETERR
argument_list|(
literal|"Missing signature time"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|signtime
operator|=
name|datetosecs
argument_list|(
name|buf
argument_list|,
operator|&
name|dateerror
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|signtime
operator|||
name|dateerror
condition|)
block|{
name|SETERR
argument_list|(
literal|"Invalid signature time"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|cp
operator|=
operator|&
name|data
index|[
name|i
index|]
expr_stmt|;
name|PUTLONG
argument_list|(
name|signtime
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
comment|/* Kfootprint (unsigned_16) */
if|if
condition|(
operator|!
name|getmlword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|SETERR
argument_list|(
literal|"Missing key footprint"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|n
operator|=
name|wordtouint32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|wordtouint32_error
operator|||
name|n
operator|>=
literal|0x0ffff
condition|)
block|{
name|SETERR
argument_list|(
literal|"Invalid key footprint"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|cp
operator|=
operator|&
name|data
index|[
name|i
index|]
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
comment|/* Signer's Name */
if|if
condition|(
operator|!
name|getmlword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|SETERR
argument_list|(
literal|"Missing signer's name"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|cp
operator|=
operator|&
name|data
index|[
name|i
index|]
expr_stmt|;
name|strcpy
argument_list|(
name|cp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|context
operator|=
name|domain_ctx
expr_stmt|;
name|MAKENAME_OK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|i
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* 		 * Signature (base64 of any length) 		 * We don't care what algorithm it uses or what 		 * the internal structure of the BASE64 data is. 		 */
if|if
condition|(
operator|!
name|getallwords
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|siglen
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
operator|&
name|data
index|[
name|i
index|]
expr_stmt|;
name|siglen
operator|=
name|b64_pton
argument_list|(
name|buf
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|,
sizeof|sizeof
name|data
operator|-
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|siglen
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
block|}
comment|/* set total length and we're done! */
name|n
operator|=
name|i
operator|+
name|siglen
expr_stmt|;
comment|/* 		 * Check signature time, expiration, and adjust TTL.  Note 		 * that all time values are in GMT (UTC), *not* local time. 		 */
name|now
operator|=
name|time
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't let bogus name servers increase the signed TTL */
if|if
condition|(
name|ttl
operator|>
name|origTTL
condition|)
block|{
name|SETERR
argument_list|(
literal|"TTL is greater than signed original TTL"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Don't let bogus signers "sign" in the future.  */
if|if
condition|(
name|signtime
operator|>
name|now
condition|)
block|{
name|SETERR
argument_list|(
literal|"signature time is in the future"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Ignore received SIG RR's that are already expired.  */
if|if
condition|(
name|exptime
operator|<=
name|now
condition|)
block|{
name|SETERR
argument_list|(
literal|"expiration time is in the past"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Lop off the TTL at the expiration time.  */
name|timetilexp
operator|=
name|exptime
operator|-
name|now
expr_stmt|;
if|if
condition|(
name|timetilexp
operator|<
name|ttl
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"shrinking expiring %s SIG TTL from %d to %d\n"
operator|,
name|p_secstodate
argument_list|(
name|exptime
argument_list|)
operator|,
name|ttl
operator|,
name|timetilexp
operator|)
argument_list|)
expr_stmt|;
name|ttl
operator|=
name|timetilexp
expr_stmt|;
block|}
comment|/* 		 * Check algorithm-ID and key structure, for 		 * the algorithm-ID's that we know about. 		 */
switch|switch
condition|(
name|al
condition|)
block|{
case|case
name|ALGORITHM_MD5RSA
case|:
if|if
condition|(
name|siglen
operator|==
literal|0
condition|)
block|{
name|SETERR
argument_list|(
literal|"No key for RSA algorithm"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|siglen
operator|<
literal|1
condition|)
block|{
name|SETERR
argument_list|(
literal|"Signature too short"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|siglen
operator|>
operator|(
name|MAX_MD5RSA_KEY_PART_BITS
operator|+
literal|7
operator|)
operator|/
literal|8
condition|)
block|{
name|SETERR
argument_list|(
literal|"Signature too long"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* We rely on  cp  from parse */
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
block|{
name|SETERR
argument_list|(
literal|"Signature starts with zeroes"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
break|break;
case|case
name|ALGORITHM_EXPIRE_ONLY
case|:
if|if
condition|(
name|siglen
operator|!=
literal|0
condition|)
block|{
name|SETERR
argument_list|(
literal|"Signature supplied to expire-only algorithm"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
break|break;
case|case
name|ALGORITHM_PRIVATE_OID
case|:
if|if
condition|(
name|siglen
operator|==
literal|0
condition|)
block|{
name|SETERR
argument_list|(
literal|"No ObjectID in key"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
break|break;
block|}
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* flush the rest of the line */
break|break;
comment|/* Accept this RR. */
block|}
ifdef|#
directive|ifdef
name|LOC_RR
case|case
name|T_LOC
case|:
name|cp
operator|=
name|buf
operator|+
operator|(
name|n
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|' '
expr_stmt|;
name|cp
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|,
operator|*
name|cp
operator|=
name|i
operator|,
name|i
operator|!=
name|EOF
operator|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\n'
operator|&&
operator|(
name|n
operator|<
name|MAXDATA
operator|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
comment|/* leave \n for getword */
name|ungetc
argument_list|(
operator|*
name|cp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* now process the whole line */
name|n
operator|=
name|loc_aton
argument_list|(
name|buf
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
goto|goto
name|err
goto|;
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* LOC_RR */
ifdef|#
directive|ifdef
name|ALLOW_T_UNSPEC
case|case
name|T_UNSPEC
case|:
block|{
name|int
name|rcode
decl_stmt|;
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"loading T_UNSPEC\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcode
operator|=
name|atob
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
argument_list|,
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|,
operator|&
name|n
argument_list|)
condition|)
block|{
if|if
condition|(
name|rcode
operator|==
name|CONV_OVERFLOW
condition|)
block|{
name|errs
operator|++
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Load T_UNSPEC: input buffer overflow"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errs
operator|++
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Load T_UNSPEC: Data in bad atob format"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
endif|#
directive|endif
comment|/* ALLOW_T_UNSPEC */
default|default:
goto|goto
name|err
goto|;
block|}
ifndef|#
directive|ifndef
name|PURGE_ZONE
ifdef|#
directive|ifdef
name|STUBS
if|if
condition|(
name|type
operator|==
name|T_SOA
operator|&&
name|zp
operator|->
name|z_type
operator|==
name|Z_STUB
condition|)
continue|continue;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NO_GLUE
comment|/* 			 * Ignore data outside the zone. 			 */
if|if
condition|(
name|zp
operator|->
name|z_type
operator|!=
name|Z_CACHE
operator|&&
operator|!
name|samedomain
argument_list|(
name|domain
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s:%d: data \"%s\" outside zone \"%s\" (ignored)"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|domain
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/*NO_GLUE*/
name|dp
operator|=
name|savedata
argument_list|(
name|class
argument_list|,
name|type
argument_list|,
operator|(
name|u_int32_t
operator|)
name|ttl
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|data
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_zone
operator|=
name|zp
operator|-
name|zones
expr_stmt|;
name|dp
operator|->
name|d_flags
operator|=
name|dataflags
expr_stmt|;
name|dp
operator|->
name|d_cred
operator|=
name|DB_C_ZONE
expr_stmt|;
name|dp
operator|->
name|d_clev
operator|=
name|clev
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|db_update
argument_list|(
name|domain
argument_list|,
name|dp
argument_list|,
name|dp
argument_list|,
name|dbflags
argument_list|,
operator|(
name|dataflags
operator|&
name|DB_F_HINT
operator|)
condition|?
name|fcachetab
else|:
name|hashtab
argument_list|)
operator|)
operator|!=
name|OK
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&&
operator|(
name|c
operator|!=
name|DATAEXISTS
operator|)
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"update failed %s %d\n"
argument_list|,
name|domain
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|db_free
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rrcount
operator|++
expr_stmt|;
block|}
continue|continue;
case|case
name|ERROR
case|:
break|break;
block|}
name|err
label|:
name|errs
operator|++
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%s: line %d: database format error (%s)"
argument_list|,
name|filename
argument_list|,
name|empty_token
condition|?
operator|(
name|lineno
operator|-
literal|1
operator|)
else|:
name|lineno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|empty_token
condition|)
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|my_fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|slineno
expr_stmt|;
if|if
condition|(
operator|!
name|def_domain
condition|)
block|{
if|if
condition|(
name|didinclude
condition|)
block|{
name|zp
operator|->
name|z_flags
operator||=
name|Z_INCLUDE
expr_stmt|;
name|zp
operator|->
name|z_ftime
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|zp
operator|->
name|z_ftime
operator|=
name|sb
operator|.
name|st_mtime
expr_stmt|;
name|zp
operator|->
name|z_lastupdate
operator|=
name|sb
operator|.
name|st_mtime
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_type
operator|!=
name|Z_CACHE
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|read_soa
operator|==
literal|0
condition|)
name|msg
operator|=
literal|"no SOA RR found"
expr_stmt|;
elseif|else
if|if
condition|(
name|read_soa
operator|!=
literal|1
condition|)
name|msg
operator|=
literal|"multiple SOA RRs found"
expr_stmt|;
elseif|else
if|if
condition|(
name|read_ns
operator|==
literal|0
condition|)
name|msg
operator|=
literal|"no NS RRs found at zone top"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|rrcount
condition|)
name|msg
operator|=
literal|"no relevant RRs found"
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
block|{
name|errs
operator|++
expr_stmt|;
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Zone \"%s\" (file %s): %s"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|filename
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|SECURE_ZONES
name|build_secure_netlist
argument_list|(
name|zp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|def_domain
condition|)
name|syslog
argument_list|(
name|errs
condition|?
name|LOG_WARNING
else|:
name|LOG_INFO
argument_list|,
literal|"%s zone \"%s\" %s (serial %lu)"
argument_list|,
name|zoneTypeString
argument_list|(
name|zp
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|errs
condition|?
literal|"rejected due to errors"
else|:
literal|"loaded"
argument_list|,
operator|(
name|u_long
operator|)
name|zp
operator|->
name|z_serial
argument_list|)
expr_stmt|;
if|if
condition|(
name|errs
condition|)
block|{
name|zp
operator|->
name|z_flags
operator||=
name|Z_DB_BAD
expr_stmt|;
name|zp
operator|->
name|z_ftime
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BIND_NOTIFY
comment|/* XXX: this needs to be delayed, both according to the spec, and 	 *	because the metadata needed by sysnotify() (and its sysquery()) 	 *	could be in other zones that we (at startup) havn't loaded yet. 	 */
if|if
condition|(
operator|!
name|errs
operator|&&
operator|!
name|def_domain
operator|&&
operator|(
name|zp
operator|->
name|z_type
operator|==
name|Z_PRIMARY
operator|||
name|zp
operator|->
name|z_type
operator|==
name|Z_SECONDARY
operator|)
condition|)
name|sysnotify
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|zp
operator|->
name|z_class
argument_list|,
name|T_SOA
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|errs
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|gettoken
parameter_list|(
name|fp
parameter_list|,
name|src
parameter_list|)
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|src
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|char
name|op
index|[
literal|32
index|]
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|top
label|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|EOF
case|:
return|return
operator|(
name|EOF
operator|)
return|;
case|case
literal|'$'
case|:
if|if
condition|(
name|getword
argument_list|(
name|op
argument_list|,
sizeof|sizeof
argument_list|(
name|op
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
literal|"include"
argument_list|,
name|op
argument_list|)
condition|)
return|return
operator|(
name|INCLUDE
operator|)
return|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
literal|"origin"
argument_list|,
name|op
argument_list|)
condition|)
return|return
operator|(
name|ORIGIN
operator|)
return|;
block|}
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%s: line %d: Unknown $ option: $%s\n"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
case|case
literal|';'
case|:
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
goto|goto
name|top
goto|;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
return|return
operator|(
name|CURRENT
operator|)
return|;
case|case
literal|'.'
case|:
return|return
operator|(
name|DOT
operator|)
return|;
case|case
literal|'@'
case|:
return|return
operator|(
name|AT
operator|)
return|;
case|case
literal|'\n'
case|:
name|lineno
operator|++
expr_stmt|;
continue|continue;
default|default:
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNAME
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* int  * getword(buf, size, fp, preserve)  *	get next word, skipping blanks& comments.  *	'\' '\n' outside of "quotes" is considered a blank.  * parameters:  *	buf - destination  *	size - of destination  *	fp - file to read from  *	preserve - should we preserve \ before \\ and \.?  * return value:  *	0 = no word; perhaps EOL or EOF; lineno was incremented.  *	1 = word was read  */
end_comment

begin_function
name|int
name|getword
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|,
name|fp
parameter_list|,
name|preserve
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|size
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|preserve
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|buf
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|spaceok
decl_stmt|;
name|empty_token
operator|=
literal|0
expr_stmt|;
comment|/* XXX global side effect. */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
block|{
comment|/* Comment.  Skip to end of line. */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
name|NULL
expr_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|/* 			 * Unescaped newline.  It's a terminator unless we're 			 * already midway into a token. 			 */
if|if
condition|(
name|cp
operator|!=
name|buf
condition|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
name|lineno
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
comment|/* "Quoted string."  Gather the whole string here. */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'"'
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
name|EOF
condition|)
name|c
operator|=
literal|'\\'
expr_stmt|;
if|if
condition|(
name|preserve
operator|&&
operator|(
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
literal|'.'
operator|)
condition|)
block|{
if|if
condition|(
name|cp
operator|>=
name|buf
operator|+
name|size
operator|-
literal|1
condition|)
break|break;
operator|*
name|cp
operator|++
operator|=
literal|'\\'
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|>=
name|buf
operator|+
name|size
operator|-
literal|1
condition|)
break|break;
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
block|}
comment|/* 			 * Newline string terminators are 			 * not token terminators. 			 */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
break|break;
block|}
comment|/* Sample following character, check for terminator. */
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
operator|||
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
continue|continue;
block|}
name|spaceok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
comment|/* Do escape processing. */
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
name|EOF
condition|)
name|c
operator|=
literal|'\\'
expr_stmt|;
if|if
condition|(
name|preserve
operator|&&
operator|(
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
literal|'.'
operator|)
condition|)
block|{
if|if
condition|(
name|cp
operator|>=
name|buf
operator|+
name|size
operator|-
literal|1
condition|)
break|break;
operator|*
name|cp
operator|++
operator|=
literal|'\\'
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|spaceok
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|spaceok
condition|)
block|{
comment|/* Blank of some kind.  Skip run. */
while|while
condition|(
name|isspace
argument_list|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
name|NULL
expr_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* Blank means terminator if the token is nonempty. */
if|if
condition|(
name|cp
operator|!=
name|buf
condition|)
comment|/* Trailing whitespace */
break|break;
continue|continue;
comment|/* Leading whitespace */
block|}
if|if
condition|(
name|cp
operator|>=
name|buf
operator|+
name|size
operator|-
literal|1
condition|)
break|break;
operator|*
name|cp
operator|++
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|buf
condition|)
name|empty_token
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|cp
operator|!=
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get multiline words.  Same parameters as getword.  Handles any    number of leading ('s or )'s in the words it sees.    FIXME:  We kludge recognition of ( and ) for multiline input.    Each paren must appear at the start of a (blank-separated) word,    which is particularly counter-intuitive for ).  Good enough for now,    until Paul rewrites the parser. */
end_comment

begin_function
specifier|static
name|int
name|getmlword
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|,
name|fp
parameter_list|,
name|preserve
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|size
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|preserve
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
do|do
block|{
while|while
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|fp
argument_list|,
name|preserve
argument_list|)
condition|)
block|{
comment|/* No more words on this line.  See if doing the 			   multiline thing. */
if|if
condition|(
operator|!
name|getmlword_nesting
condition|)
block|{
comment|/* Nope... */
name|ungetc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* Push back newline */
name|lineno
operator|--
expr_stmt|;
comment|/* Unbump the lineno */
name|empty_token
operator|=
literal|0
expr_stmt|;
comment|/* Undo this botch */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
operator|||
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Error, no terminating ')' */
comment|/* Continue reading til we get a word... */
block|}
while|while
condition|(
literal|'('
operator|==
operator|*
name|buf
condition|)
block|{
comment|/* Word starts with paren.  Multiline mode. 			   Move the rest of the word down over the paren.  */
name|getmlword_nesting
operator|++
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
while|while
condition|(
literal|0
operator|!=
operator|(
name|p
index|[
literal|0
index|]
operator|=
name|p
index|[
literal|1
index|]
operator|)
condition|)
name|p
operator|++
expr_stmt|;
block|}
while|while
condition|(
literal|')'
operator|==
operator|*
name|buf
condition|)
block|{
name|getmlword_nesting
operator|--
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
while|while
condition|(
literal|0
operator|!=
operator|(
name|p
index|[
literal|0
index|]
operator|=
name|p
index|[
literal|1
index|]
operator|)
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|0
condition|)
do|;
comment|/* loop til we get a non-( non-) word */
return|return
literal|1
return|;
comment|/* Got a word... */
block|}
end_function

begin_comment
comment|/* Get all the remaining words on a line, concatenated into one big    long (not too long!) string, with the whitespace squeezed out.    This routine, like getword(), does not swallow the newline if words seen.    This routine, unlike getword(), never swallows the newline if no words.    Parameters are the same as getword().  Result is: 	 0	got no words at all 	 1 	got one or more words 	-1	got too many words, they don't all fit; or missing close paren */
end_comment

begin_function
specifier|static
name|int
name|getallwords
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|,
name|fp
parameter_list|,
name|preserve
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|size
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|preserve
decl_stmt|;
block|{
name|char
modifier|*
name|runningbuf
init|=
name|buf
decl_stmt|;
name|int
name|runningsize
init|=
name|size
decl_stmt|;
name|int
name|len
decl_stmt|;
while|while
condition|(
name|runningsize
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|getmlword
argument_list|(
name|runningbuf
argument_list|,
name|runningsize
argument_list|,
name|fp
argument_list|,
name|preserve
argument_list|)
condition|)
block|{
return|return
name|runningbuf
operator|!=
name|buf
return|;
comment|/* 1 or 0 */
block|}
name|len
operator|=
name|strlen
argument_list|(
name|runningbuf
argument_list|)
expr_stmt|;
name|runningbuf
operator|+=
name|len
expr_stmt|;
name|runningsize
operator|-=
name|len
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
comment|/* Error, String too long */
block|}
end_function

begin_comment
comment|/* From: kagotani@cs.titech.ac.jp Message-Id:<9007040716.AA26646@saeko.cs.titech.ac.jp> Subject: named bug report and fix Date: Wed, 04 Jul 90 16:16:52 JST  I found a bug in the BIND source code. Named with this bug parses the serial_no field of SOA records incorrectly. For example:         expression      internal         in files        expression      I expect         1.              1000            10000         1.2             10002           10002         1.23            100023          10023         2.3             20003           20003 Especially I can not accept that "2.3" is treated as if it is smaller than "1.23" in their internal expressions.  [ if you define SENSIBLE_DOTS in ../conf/options.h, you get   m. kagotani's expected behaviour.  this is NOT compatible   with pre-4.9 versions of BIND.  --vix ] */
end_comment

begin_function
name|int
name|getnum
parameter_list|(
name|fp
parameter_list|,
name|src
parameter_list|,
name|opt
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|src
decl_stmt|;
name|int
name|opt
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|n
decl_stmt|;
name|int
name|seendigit
init|=
literal|0
decl_stmt|;
name|int
name|seendecimal
init|=
literal|0
decl_stmt|;
name|int
name|m
init|=
literal|0
decl_stmt|;
name|int
name|allow_dots
init|=
literal|0
decl_stmt|;
name|getnum_error
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DOTTED_SERIAL
if|if
condition|(
name|opt
operator|&
name|GETNUM_SERIAL
condition|)
name|allow_dots
operator|++
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|n
operator|=
literal|0
init|;
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|;
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|seendigit
condition|)
break|break;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|seendigit
condition|)
break|break;
continue|continue;
block|}
if|if
condition|(
name|getnum_error
condition|)
continue|continue;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|')'
operator|&&
name|seendigit
condition|)
block|{
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|seendigit
operator|&&
operator|(
name|opt
operator|&
name|GETNUM_SCALED
operator|)
operator|&&
name|strchr
argument_list|(
literal|"KkMmGg"
argument_list|,
name|c
argument_list|)
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'K'
case|:
case|case
literal|'k'
case|:
name|n
operator|*=
literal|1024
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
case|case
literal|'m'
case|:
name|n
operator|*=
operator|(
literal|1024
operator|*
literal|1024
operator|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
case|case
literal|'g'
case|:
name|n
operator|*=
operator|(
literal|1024
operator|*
literal|1024
operator|*
literal|1024
operator|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|seendecimal
operator|||
name|c
operator|!=
literal|'.'
operator|||
operator|!
name|allow_dots
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%s:%d: expected a number"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|getnum_error
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|seendigit
condition|)
name|n
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SENSIBLE_DOTS
name|n
operator|*=
literal|10000
expr_stmt|;
else|#
directive|else
name|n
operator|*=
literal|1000
expr_stmt|;
endif|#
directive|endif
name|seendigit
operator|=
literal|1
expr_stmt|;
name|seendecimal
operator|=
literal|1
expr_stmt|;
block|}
continue|continue;
block|}
ifdef|#
directive|ifdef
name|SENSIBLE_DOTS
if|if
condition|(
name|seendecimal
condition|)
name|m
operator|=
name|m
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
else|else
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
else|#
directive|else
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
endif|#
directive|endif
name|seendigit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|getnum_error
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|m
operator|>
literal|9999
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s:%d: number after the decimal point exceeds 9999"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|getnum_error
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|seendecimal
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s:%d: decimal serial number interpreted as %d"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|,
name|n
operator|+
name|m
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|+
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getnonblank
parameter_list|(
name|fp
parameter_list|,
name|src
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|src
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
continue|continue;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: line %d: unexpected EOF"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOF
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Take name and fix it according to following rules:  * "." means root.  * "@" means current origin.  * "name." means no changes.  * "name" means append origin.  */
end_comment

begin_function
specifier|static
name|void
name|makename
parameter_list|(
name|name
parameter_list|,
name|origin
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|origin
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|origin
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
name|origin
operator|++
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
name|origin
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|name
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|name
index|[
name|n
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
elseif|else
if|if
condition|(
name|origin
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|name
index|[
name|n
index|]
operator|=
literal|'.'
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
operator|+
name|n
operator|+
literal|1
argument_list|,
name|origin
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|makename_ok
parameter_list|(
name|name
parameter_list|,
name|origin
parameter_list|,
name|class
parameter_list|,
name|transport
parameter_list|,
name|context
parameter_list|,
name|owner
parameter_list|,
name|filename
parameter_list|,
name|lineno
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|origin
decl_stmt|;
name|int
name|class
decl_stmt|;
name|enum
name|transport
name|transport
decl_stmt|;
name|enum
name|context
name|context
decl_stmt|;
specifier|const
name|char
modifier|*
name|owner
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|lineno
decl_stmt|;
block|{
name|int
name|ret
init|=
literal|1
decl_stmt|;
name|makename
argument_list|(
name|name
argument_list|,
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|transport
argument_list|,
name|context
argument_list|,
name|owner
argument_list|,
name|inaddr_any
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s:%d: database naming error\n"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|endline
parameter_list|(
name|fp
parameter_list|)
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
break|break;
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|MAXPORT
value|1024
end_define

begin_define
define|#
directive|define
name|MAXLEN
value|24
end_define

begin_function
specifier|static
name|int
name|getprotocol
parameter_list|(
name|fp
parameter_list|,
name|src
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|src
decl_stmt|;
block|{
name|int
name|k
decl_stmt|;
name|char
name|b
index|[
name|MAXLEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|getword
argument_list|(
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|b
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|k
operator|=
name|protocolnumber
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
operator|-
literal|1
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: line %d: unknown protocol: %s."
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|,
name|b
argument_list|)
expr_stmt|;
return|return
operator|(
name|k
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getservices
parameter_list|(
name|n
parameter_list|,
name|data
parameter_list|,
name|fp
parameter_list|,
name|src
parameter_list|)
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|src
decl_stmt|;
block|{
name|int
name|j
decl_stmt|,
name|ch
decl_stmt|;
name|int
name|k
decl_stmt|;
name|int
name|maxl
decl_stmt|;
name|int
name|bracket
decl_stmt|;
name|char
name|b
index|[
name|MAXLEN
index|]
decl_stmt|;
name|char
name|bm
index|[
name|MAXPORT
operator|/
literal|8
index|]
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXPORT
operator|/
literal|8
condition|;
name|j
operator|++
control|)
name|bm
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|maxl
operator|=
literal|0
expr_stmt|;
name|bracket
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|getword
argument_list|(
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|b
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
operator|||
name|bracket
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
operator|||
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
break|break;
if|if
condition|(
name|strlen
argument_list|(
name|b
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|b
index|[
literal|0
index|]
operator|==
literal|'('
condition|)
block|{
name|bracket
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|b
index|[
literal|0
index|]
operator|==
literal|')'
condition|)
block|{
name|bracket
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|ch
operator|!=
literal|'\n'
condition|)
empty_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
break|break;
block|}
name|k
operator|=
name|servicenumber
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: line %d: Unknown service '%s'"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|,
name|b
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|k
operator|<
name|MAXPORT
operator|)
operator|&&
operator|(
name|k
operator|)
condition|)
block|{
name|bm
index|[
name|k
operator|/
literal|8
index|]
operator||=
operator|(
literal|0x80
operator|>>
operator|(
name|k
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|maxl
condition|)
name|maxl
operator|=
name|k
expr_stmt|;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: line %d: port no. (%d) too big"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"%s: line %d: port no. (%d) too big\n"
operator|,
name|src
operator|,
name|lineno
operator|,
name|k
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bracket
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: line %d: missing close paren"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|maxl
operator|=
name|maxl
operator|/
literal|8
operator|+
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|bm
argument_list|,
name|data
operator|+
name|n
argument_list|,
name|maxl
argument_list|)
expr_stmt|;
return|return
operator|(
name|maxl
operator|+
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/* get_netlist(fp, netlistp, allow)  *	get list of nets from 'fp', put on *netlistp, 'allow' controls  *	whether hosts, nets, or both shall be accepted without warnings.  *	(note that they are always accepted; 'allow' just controls the  *	warnings.)  */
end_comment

begin_function
name|void
name|get_netlist
parameter_list|(
name|fp
parameter_list|,
name|netlistp
parameter_list|,
name|allow
parameter_list|,
name|print_tag
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|netinfo
modifier|*
modifier|*
name|netlistp
decl_stmt|;
name|int
name|allow
decl_stmt|;
name|char
modifier|*
name|print_tag
decl_stmt|;
block|{
name|struct
name|netinfo
modifier|*
name|ntp
decl_stmt|,
modifier|*
modifier|*
name|end
decl_stmt|;
name|char
name|buf
index|[
name|MAXDNAME
index|]
decl_stmt|,
modifier|*
name|maskp
decl_stmt|;
name|struct
name|in_addr
name|ina
decl_stmt|;
for|for
control|(
name|end
operator|=
name|netlistp
init|;
operator|*
name|end
condition|;
name|end
operator|=
operator|&
operator|(
operator|*
operator|*
name|end
operator|)
operator|.
name|next
control|)
empty_stmt|;
name|ntp
operator|=
name|NULL
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"get_netlist(%s)"
operator|,
name|print_tag
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|maskp
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'&'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|maskp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|" %s"
operator|,
name|buf
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ntp
condition|)
block|{
name|ntp
operator|=
operator|(
expr|struct
name|netinfo
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|netinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ntp
condition|)
name|panic
argument_list|(
name|errno
argument_list|,
literal|"malloc(netinfo)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|inet_aton
argument_list|(
name|buf
argument_list|,
operator|&
name|ntp
operator|->
name|my_addr
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s contains bogus element (%s)"
argument_list|,
name|print_tag
argument_list|,
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|maskp
condition|)
block|{
if|if
condition|(
operator|!
name|inet_aton
argument_list|(
name|maskp
argument_list|,
operator|&
name|ina
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s element %s has bad mask (%s)"
argument_list|,
name|print_tag
argument_list|,
name|buf
argument_list|,
name|maskp
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
if|if
condition|(
name|allow
operator|&
name|ALLOW_HOSTS
condition|)
name|ina
operator|.
name|s_addr
operator|=
literal|0xffffffff
expr_stmt|;
comment|/* "exact" */
else|else
name|ina
operator|.
name|s_addr
operator|=
name|net_mask
argument_list|(
name|ntp
operator|->
name|my_addr
argument_list|)
expr_stmt|;
block|}
name|ntp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|ntp
operator|->
name|mask
operator|=
name|ina
operator|.
name|s_addr
expr_stmt|;
name|ntp
operator|->
name|addr
operator|=
name|ntp
operator|->
name|my_addr
operator|.
name|s_addr
operator|&
name|ntp
operator|->
name|mask
expr_stmt|;
comment|/* Check for duplicates */
if|if
condition|(
name|addr_on_netlist
argument_list|(
name|ntp
operator|->
name|my_addr
argument_list|,
operator|*
name|netlistp
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|ntp
operator|->
name|addr
operator|!=
name|ntp
operator|->
name|my_addr
operator|.
name|s_addr
condition|)
block|{
name|ina
operator|.
name|s_addr
operator|=
name|ntp
operator|->
name|addr
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s element (%s) mask problem (%s)"
argument_list|,
name|print_tag
argument_list|,
name|buf
argument_list|,
name|inet_ntoa
argument_list|(
name|ina
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|end
operator|=
name|ntp
expr_stmt|;
name|end
operator|=
operator|&
name|ntp
operator|->
name|next
expr_stmt|;
name|ntp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ntp
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ntp
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
for|for
control|(
name|ntp
operator|=
operator|*
name|netlistp
init|;
name|ntp
operator|!=
name|NULL
condition|;
name|ntp
operator|=
name|ntp
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"ntp x%lx addr x%lx mask x%lx"
argument_list|,
operator|(
name|u_long
operator|)
name|ntp
argument_list|,
operator|(
name|u_long
operator|)
name|ntp
operator|->
name|addr
argument_list|,
operator|(
name|u_long
operator|)
name|ntp
operator|->
name|mask
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|" my_addr x%lx"
argument_list|,
operator|(
name|u_long
operator|)
name|ntp
operator|->
name|my_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|" %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|ntp
operator|->
name|my_addr
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|" next x%lx\n"
argument_list|,
operator|(
name|u_long
operator|)
name|ntp
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|struct
name|netinfo
modifier|*
name|addr_on_netlist
parameter_list|(
name|addr
parameter_list|,
name|netlist
parameter_list|)
name|struct
name|in_addr
name|addr
decl_stmt|;
name|struct
name|netinfo
modifier|*
name|netlist
decl_stmt|;
block|{
name|u_int32_t
name|a
init|=
name|addr
operator|.
name|s_addr
decl_stmt|;
name|struct
name|netinfo
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|netlist
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
if|if
condition|(
name|t
operator|->
name|addr
operator|==
operator|(
name|a
operator|&
name|t
operator|->
name|mask
operator|)
condition|)
return|return
name|t
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|position_on_netlist
parameter_list|(
name|addr
parameter_list|,
name|netlist
parameter_list|)
name|struct
name|in_addr
name|addr
decl_stmt|;
name|struct
name|netinfo
modifier|*
name|netlist
decl_stmt|;
block|{
name|u_int32_t
name|a
init|=
name|addr
operator|.
name|s_addr
decl_stmt|;
name|struct
name|netinfo
modifier|*
name|t
decl_stmt|;
name|int
name|position
init|=
literal|0
decl_stmt|;
for|for
control|(
name|t
operator|=
name|netlist
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
if|if
condition|(
name|t
operator|->
name|addr
operator|==
operator|(
name|a
operator|&
name|t
operator|->
name|mask
operator|)
condition|)
break|break;
else|else
name|position
operator|++
expr_stmt|;
return|return
name|position
return|;
block|}
end_function

begin_function
name|void
name|free_netlist
parameter_list|(
name|netlistp
parameter_list|)
name|struct
name|netinfo
modifier|*
modifier|*
name|netlistp
decl_stmt|;
block|{
specifier|register
name|struct
name|netinfo
modifier|*
name|ntp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|ntp
operator|=
operator|*
name|netlistp
init|;
name|ntp
operator|!=
name|NULL
condition|;
name|ntp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|ntp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ntp
argument_list|)
expr_stmt|;
block|}
operator|*
name|netlistp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Converts a word to a u_int32_t.  Error if any non-numeric  * characters in the word, except leading or trailing white space.  */
end_comment

begin_function
specifier|static
name|u_int32_t
name|wordtouint32
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|u_long
name|result
decl_stmt|;
name|u_int32_t
name|res2
decl_stmt|;
name|char
modifier|*
name|bufend
decl_stmt|;
name|wordtouint32_error
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|strtoul
argument_list|(
name|buf
argument_list|,
operator|&
name|bufend
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufend
operator|==
name|buf
condition|)
name|wordtouint32_error
operator|=
literal|1
expr_stmt|;
else|else
while|while
condition|(
literal|'\0'
operator|!=
operator|*
name|bufend
condition|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|bufend
argument_list|)
condition|)
name|bufend
operator|++
expr_stmt|;
else|else
block|{
name|wordtouint32_error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Check for truncation between u_long and u_int32_t */
name|res2
operator|=
name|result
expr_stmt|;
if|if
condition|(
name|res2
operator|!=
name|result
condition|)
name|wordtouint32_error
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|res2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse part of a date.  Set error flag if any error.  * Don't reset the flag if there is no error.  */
end_comment

begin_function
specifier|static
name|int
name|datepart
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|,
name|errp
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|size
decl_stmt|,
name|min
decl_stmt|,
name|max
decl_stmt|,
decl|*
name|errp
decl_stmt|;
end_function

begin_block
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
condition|)
operator|*
name|errp
operator|=
literal|1
expr_stmt|;
name|result
operator|=
operator|(
name|result
operator|*
literal|10
operator|)
operator|+
name|buf
index|[
name|i
index|]
operator|-
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|<
name|min
condition|)
operator|*
name|errp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|result
operator|>
name|max
condition|)
operator|*
name|errp
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Convert a date in ASCII into the number of seconds since    1 January 1970 (GMT assumed).  Format is yyyymmddhhmmss, all    digits required, no spaces allowed.  */
end_comment

begin_function
specifier|static
name|u_int32_t
name|datetosecs
parameter_list|(
name|cp
parameter_list|,
name|errp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
name|int
modifier|*
name|errp
decl_stmt|;
block|{
name|struct
name|tm
name|time
decl_stmt|;
name|u_int32_t
name|result
decl_stmt|;
name|int
name|mdays
decl_stmt|,
name|i
decl_stmt|;
specifier|static
specifier|const
name|int
name|days_per_month
index|[
literal|12
index|]
init|=
block|{
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|!=
literal|14
condition|)
block|{
operator|*
name|errp
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|errp
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|time
argument_list|,
sizeof|sizeof
name|time
argument_list|)
expr_stmt|;
name|time
operator|.
name|tm_year
operator|=
name|datepart
argument_list|(
name|cp
operator|+
literal|0
argument_list|,
literal|4
argument_list|,
literal|1990
argument_list|,
literal|9999
argument_list|,
name|errp
argument_list|)
operator|-
literal|1900
expr_stmt|;
name|time
operator|.
name|tm_mon
operator|=
name|datepart
argument_list|(
name|cp
operator|+
literal|4
argument_list|,
literal|2
argument_list|,
literal|01
argument_list|,
literal|12
argument_list|,
name|errp
argument_list|)
operator|-
literal|1
expr_stmt|;
name|time
operator|.
name|tm_mday
operator|=
name|datepart
argument_list|(
name|cp
operator|+
literal|6
argument_list|,
literal|2
argument_list|,
literal|01
argument_list|,
literal|31
argument_list|,
name|errp
argument_list|)
expr_stmt|;
name|time
operator|.
name|tm_hour
operator|=
name|datepart
argument_list|(
name|cp
operator|+
literal|8
argument_list|,
literal|2
argument_list|,
literal|00
argument_list|,
literal|23
argument_list|,
name|errp
argument_list|)
expr_stmt|;
name|time
operator|.
name|tm_min
operator|=
name|datepart
argument_list|(
name|cp
operator|+
literal|10
argument_list|,
literal|2
argument_list|,
literal|00
argument_list|,
literal|59
argument_list|,
name|errp
argument_list|)
expr_stmt|;
name|time
operator|.
name|tm_sec
operator|=
name|datepart
argument_list|(
name|cp
operator|+
literal|12
argument_list|,
literal|2
argument_list|,
literal|00
argument_list|,
literal|59
argument_list|,
name|errp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|errp
condition|)
comment|/* Any parse errors? */
return|return
operator|(
literal|0
operator|)
return|;
comment|/*  	 * OK, now because timegm() is not available in all environments, 	 * we will do it by hand.  Roll up sleeves, curse the gods, begin! 	 */
define|#
directive|define
name|SECS_PER_DAY
value|((u_int32_t)24*60*60)
define|#
directive|define
name|isleap
parameter_list|(
name|y
parameter_list|)
value|((((y) % 4) == 0&& ((y) % 100) != 0) || ((y) % 400) == 0)
name|result
operator|=
name|time
operator|.
name|tm_sec
expr_stmt|;
comment|/* Seconds */
name|result
operator|+=
name|time
operator|.
name|tm_min
operator|*
literal|60
expr_stmt|;
comment|/* Minutes */
name|result
operator|+=
name|time
operator|.
name|tm_hour
operator|*
operator|(
literal|60
operator|*
literal|60
operator|)
expr_stmt|;
comment|/* Hours */
name|result
operator|+=
operator|(
name|time
operator|.
name|tm_mday
operator|-
literal|1
operator|)
operator|*
name|SECS_PER_DAY
expr_stmt|;
comment|/* Days */
comment|/* Months are trickier.  Look without leaping, then leap */
name|mdays
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|time
operator|.
name|tm_mon
condition|;
name|i
operator|++
control|)
name|mdays
operator|+=
name|days_per_month
index|[
name|i
index|]
expr_stmt|;
name|result
operator|+=
name|mdays
operator|*
name|SECS_PER_DAY
expr_stmt|;
comment|/* Months */
if|if
condition|(
name|time
operator|.
name|tm_mon
operator|>
literal|1
operator|&&
name|isleap
argument_list|(
literal|1900
operator|+
name|time
operator|.
name|tm_year
argument_list|)
condition|)
name|result
operator|+=
name|SECS_PER_DAY
expr_stmt|;
comment|/* Add leapday for this year */
comment|/* First figure years without leapdays, then add them in.  */
comment|/* The loop is slow, FIXME, but simple and accurate.  */
name|result
operator|+=
operator|(
name|time
operator|.
name|tm_year
operator|-
literal|70
operator|)
operator|*
operator|(
name|SECS_PER_DAY
operator|*
literal|365
operator|)
expr_stmt|;
comment|/* Years */
for|for
control|(
name|i
operator|=
literal|70
init|;
name|i
operator|<
name|time
operator|.
name|tm_year
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|isleap
argument_list|(
literal|1900
operator|+
name|i
argument_list|)
condition|)
name|result
operator|+=
name|SECS_PER_DAY
expr_stmt|;
comment|/* Add leapday for prev year */
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAXCHARSTRING
value|255
end_define

begin_function
specifier|static
name|int
name|getcharstring
parameter_list|(
name|buf
parameter_list|,
name|data
parameter_list|,
name|type
parameter_list|,
name|minfields
parameter_list|,
name|maxfields
parameter_list|,
name|fp
parameter_list|,
name|src
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|minfields
decl_stmt|;
name|int
name|maxfields
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|src
decl_stmt|;
block|{
name|int
name|nfield
init|=
literal|0
decl_stmt|,
name|done
init|=
literal|0
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|b
init|=
name|buf
decl_stmt|;
do|do
block|{
name|nfield
operator|++
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ALLOW_LONG_TXT_RDATA
name|b
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_TXT
operator|||
name|type
operator|==
name|T_X25
condition|)
block|{
while|while
condition|(
name|i
operator|>
name|MAXCHARSTRING
operator|&&
name|n
operator|+
name|MAXCHARSTRING
operator|+
literal|1
operator|<
name|MAXDATA
condition|)
block|{
name|data
index|[
name|n
index|]
operator|=
name|MAXCHARSTRING
expr_stmt|;
name|bcopy
argument_list|(
name|b
argument_list|,
name|data
operator|+
name|n
operator|+
literal|1
argument_list|,
name|MAXCHARSTRING
argument_list|)
expr_stmt|;
name|n
operator|+=
name|MAXCHARSTRING
operator|+
literal|1
expr_stmt|;
name|b
operator|+=
name|MAXCHARSTRING
expr_stmt|;
name|i
operator|-=
name|MAXCHARSTRING
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* ALLOW_LONG_TXT_RDATA */
if|if
condition|(
name|i
operator|>
name|MAXCHARSTRING
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: line %d: RDATA field %d too long"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|,
name|nfield
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|+
name|i
operator|+
literal|1
operator|>
name|MAXDATA
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: line %d: total RDATA too long"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|data
index|[
name|n
index|]
operator|=
name|i
expr_stmt|;
name|bcopy
argument_list|(
name|b
argument_list|,
name|data
operator|+
name|n
operator|+
literal|1
argument_list|,
operator|(
name|int
operator|)
name|i
argument_list|)
expr_stmt|;
name|n
operator|+=
name|i
operator|+
literal|1
expr_stmt|;
name|done
operator|=
operator|(
name|maxfields
operator|&&
name|nfield
operator|>=
name|maxfields
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|done
operator|&&
name|getword
argument_list|(
name|buf
argument_list|,
name|MAXDATA
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
do|;
if|if
condition|(
name|nfield
operator|<
name|minfields
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: line %d: expected %d RDATA fields, only saw %d"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|,
name|minfields
argument_list|,
name|nfield
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|done
condition|)
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

end_unit

