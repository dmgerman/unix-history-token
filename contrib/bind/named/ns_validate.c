begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  * ns_validate.c (was security.c in original ISI contribution)  * author: anant kumar  * contributed: March 17, 1993  *  * implements validation procedure for RR's received from a server as a  * response to a query.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|"named.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|VALIDATE
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|isvalid
name|__P
argument_list|(
operator|(
expr|struct
name|namebuf
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|,
name|check_addr_ns
name|__P
argument_list|(
operator|(
expr|struct
name|databuf
operator|*
operator|*
operator|,
expr|struct
name|sockaddr_in
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|,
name|check_in_tables
name|__P
argument_list|(
operator|(
expr|struct
name|databuf
operator|*
operator|*
operator|,
expr|struct
name|sockaddr_in
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void		stick_in_queue __P((char *, int, int, char *));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|NAMEADDR
name|nameaddrlist
index|[
name|MAXNAMECACHE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|firstNA
init|=
literal|0
decl_stmt|,
name|lastNA
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|TO_Validate
modifier|*
name|validateQ
decl_stmt|,
modifier|*
name|currentVQ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|VQcount
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*****************************************************************  * validate() is called from dovalidate(). it takes as parameters,   * the domain name sought, the class, type etc. of record, the server  * that gave us the answer and the data it gave us  *  * it returns VALID if it is able to validate the record, INVALID if it cannot.  * furtehr VALID is split into VALID_CACHE if we need to cache this record  * since the domainname is not something we are authoritative for and  * VALID_NO_CACHE if the name is something we are authoritative for.  *  * pseudocode for function validate is as follows:  * validate(domain, qdomain, server, type, class, data, dlen, rcode) {  *  *       if (dname or a higher level name not found in cache)  *          return INVALID;  *       if (NS records for "domain" found in cache){  *  *           if (we are authoritative)  /findns() returned NXDOMAIN;/  *              if (we did not have an exact match on names)  *                 =>the name does not exist in our database  *                 => data is bad: return INVALID  *              if (data agrees with what we have)  *                return VALID_NO_CACHE;  *              else return INVALID;  *      *          if (we are not authoritative) /findns() returned OK;/         *	    if (domain lives below the qdomain)  *		return VALID_CACHE;  *          if (address records for NS's found in cache){  *                       if ("server" = one of the addresses){  *                               return VALID_CACHE;  *                       }else{  *                          stick in queue of "to_validate" data;  *                          return (INVALID);  *                       }  *          else return INVALID;  *  * This performs the validation procedure described above. Checks  * for the longest component of the dname that has a NS record  * associated with it. At any stage, if no data is found, it implies  * that the name is bad (has an unknown domain identifier) thus, we  * return INVALID.  * If address of one of these servers matches the address of the server  * that returned us this data, we are happy!  *  * since findns will set needs_prime_cache if np = NULL is passed, we always  * reset it. will let ns_req do it when we are searching for ns records to  * query someone. hence in all the three cases of switch(findns())  *                                 we have needs_prime_cache = 0;  *****************************************************************************/
end_comment

begin_function
name|int
name|validate
parameter_list|(
name|dname
parameter_list|,
name|qdomain
parameter_list|,
name|server
parameter_list|,
name|type
parameter_list|,
name|class
parameter_list|,
name|data
parameter_list|,
name|dlen
ifdef|#
directive|ifdef
name|NCACHE
parameter_list|,
name|rcode
endif|#
directive|endif
parameter_list|)
name|char
modifier|*
name|dname
decl_stmt|,
decl|*
name|qdomain
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|sockaddr_in
modifier|*
name|server
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|,
name|class
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dlen
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NCACHE
end_ifdef

begin_decl_stmt
name|int
name|rcode
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|,
modifier|*
name|dnamep
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|struct
name|databuf
modifier|*
name|nsp
index|[
name|NSMAX
index|]
decl_stmt|;
name|int
name|count
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|exactmatch
init|=
literal|0
decl_stmt|;
name|struct
name|fwdinfo
modifier|*
name|fwd
decl_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|nsp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"validate(), d:%s, s:[%s], t:%d, c:%d\n"
operator|,
name|dname
operator|,
name|inet_ntoa
argument_list|(
name|server
operator|->
name|sin_addr
argument_list|)
operator|,
name|type
operator|,
name|class
operator|)
argument_list|)
expr_stmt|;
comment|/* everything from forwarders is the GOSPEL */
for|for
control|(
name|fwd
operator|=
name|fwdtab
init|;
name|fwd
operator|!=
name|NULL
condition|;
name|fwd
operator|=
name|fwd
operator|->
name|next
control|)
block|{
if|if
condition|(
name|server
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|fwd
operator|->
name|fwdaddr
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
return|return
operator|(
name|VALID_CACHE
operator|)
return|;
block|}
name|htp
operator|=
name|hashtab
expr_stmt|;
if|if
condition|(
name|priming
operator|&&
operator|(
name|dname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|)
name|np
operator|=
name|NULL
expr_stmt|;
else|else
name|np
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* we were able to locate namebufs for this domain, or a parent domain, 	 * or ??? */
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
name|fname
operator|=
literal|""
expr_stmt|;
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"validate:namebuf found np:%#lx, d:\"%s\", f:\"%s\"\n"
operator|,
operator|(
name|u_long
operator|)
name|np
operator|,
name|dname
operator|,
name|fname
operator|)
argument_list|)
expr_stmt|;
comment|/* save the namebuf if we were able to locate the exact dname */
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|dname
argument_list|,
name|fname
argument_list|)
condition|)
block|{
name|dnamep
operator|=
name|np
expr_stmt|;
name|exactmatch
operator|=
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|findns
argument_list|(
operator|&
name|np
argument_list|,
name|class
argument_list|,
name|nsp
argument_list|,
operator|&
name|count
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
name|NXDOMAIN
case|:
comment|/** we are authoritative for this domain, lookup name  		 * in our zone data, if it matches, return valid. 		 * in either case, do not cache 		 **/
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"validate: auth data found\n"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|needs_prime_cache
condition|)
name|needs_prime_cache
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|NCACHE
if|if
condition|(
name|rcode
operator|==
name|NXDOMAIN
condition|)
block|{
comment|/* If we had an exactmatch on the name, we found the 			 * name in our authority database, so this couldn't  			 * have been a bad name. INVALID data, say so 			 */
if|if
condition|(
name|exactmatch
condition|)
return|return
operator|(
name|INVALID
operator|)
return|;
else|else
comment|/* we did not have an exactmatch, the data is 				 * good, we do not NCACHE stuff we are 				 * authoritative for, though. 				 */
return|return
operator|(
name|VALID_NO_CACHE
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|dname
argument_list|,
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
argument_list|)
condition|)
block|{
comment|/* if the name we seek is the same as that we have ns 			 * records for, compare the data we have to see if it 			 * matches. if it does, return valid_no_cache, if it 			 * doesn't, invalid. 			 */
if|if
condition|(
name|isvalid
argument_list|(
name|np
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
name|data
argument_list|,
name|dlen
argument_list|)
condition|)
return|return
operator|(
name|VALID_NO_CACHE
operator|)
return|;
else|else
return|return
operator|(
name|INVALID
operator|)
return|;
block|}
comment|/* we found ns records in a higher level, if we were unable to 		 * locate the exact name earlier, it means we are 		 * authoritative for this domain but do not have records for 		 * this name. this name is obviously invalid 		 */
if|if
condition|(
operator|!
name|exactmatch
condition|)
return|return
operator|(
name|INVALID
operator|)
return|;
comment|/* we found the exact name earlier and we are obviously 		 * authoritative so check for data records and see if any 		 * match. 		 */
if|if
condition|(
name|isvalid
argument_list|(
name|dnamep
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
name|data
argument_list|,
name|dlen
argument_list|)
condition|)
return|return
operator|(
name|VALID_NO_CACHE
operator|)
return|;
else|else
return|return
operator|(
name|INVALID
operator|)
return|;
case|case
name|SERVFAIL
case|:
comment|/* could not find name server records*/
comment|/* stick_in_queue(dname, type, class, data); */
if|if
condition|(
name|needs_prime_cache
condition|)
name|needs_prime_cache
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|INVALID
operator|)
return|;
case|case
name|OK
case|:
comment|/*proceed */
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"validate:found ns records\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_prime_cache
condition|)
name|needs_prime_cache
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|samedomain
argument_list|(
name|dname
argument_list|,
name|qdomain
argument_list|)
operator|||
name|check_addr_ns
argument_list|(
name|nsp
argument_list|,
name|server
argument_list|,
name|dname
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|VALID_CACHE
operator|)
return|;
block|}
comment|/* server is not one of those we know of */
comment|/* stick_in_queue(dname, type, class, data); */
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|INVALID
operator|)
return|;
default|default:
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|INVALID
operator|)
return|;
block|}
comment|/*switch*/
block|}
end_block

begin_comment
comment|/*validate*/
end_comment

begin_escape
end_escape

begin_comment
comment|/***********************************************************************  * validate rr returned by somebody against your own database, if you are   * authoritative for the information. if you have a record that matches,  * return 1, else return 0. validate() above will use this and determine  * if the record should be returned/discarded.  ***********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|isvalid
parameter_list|(
name|np
parameter_list|,
name|type
parameter_list|,
name|class
parameter_list|,
name|data
parameter_list|,
name|dlen
parameter_list|)
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|int
name|type
decl_stmt|,
name|class
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|dlen
decl_stmt|;
block|{
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|!
name|wanted
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|type
operator|==
name|T_CNAME
operator|)
operator|&&
operator|(
name|class
operator|==
name|dp
operator|->
name|d_class
operator|)
condition|)
block|{
comment|/* if a cname exists, any other will not */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* we come here only for zone info, 				 * so -ve $ed info can't be 				 */
block|}
continue|continue;
block|}
comment|/* type and class match, if i get here  		 * let's now compare the data section, per RR type 		 */
comment|/* unless, of course, the data was negative, in which case 		 * we should return FAILURE since we should not have found 		 * data here. 		 */
if|if
condition|(
operator|(
name|data
operator|==
name|NULL
operator|)
operator|||
operator|(
name|dlen
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX:	why aren't we just calling db_cmp()? */
switch|switch
condition|(
name|type
condition|)
block|{
name|char
modifier|*
name|td
decl_stmt|;
name|u_char
modifier|*
name|tdp
decl_stmt|;
name|int
name|x
decl_stmt|;
case|case
name|T_A
case|:
case|case
name|T_WKS
case|:
case|case
name|T_HINFO
case|:
case|case
name|T_UINFO
case|:
case|case
name|T_UID
case|:
case|case
name|T_GID
case|:
case|case
name|T_TXT
case|:
case|case
name|T_X25
case|:
case|case
name|T_ISDN
case|:
case|case
name|T_LOC
case|:
ifdef|#
directive|ifdef
name|ALLOW_T_UNSPEC
case|case
name|T_UNSPEC
case|:
endif|#
directive|endif
name|x
operator|=
name|memcmp
argument_list|(
name|dp
operator|->
name|d_data
argument_list|,
name|data
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"type = %d, GOOD = %d\n"
operator|,
name|type
operator|,
name|x
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
break|break;
case|case
name|T_CNAME
case|:
case|case
name|T_MB
case|:
case|case
name|T_MG
case|:
case|case
name|T_MR
case|:
case|case
name|T_NS
case|:
case|case
name|T_PTR
case|:
name|x
operator|=
name|strncasecmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|,
name|data
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"type = %d, GOOD = %d\n"
operator|,
name|type
operator|,
name|x
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
break|break;
case|case
name|T_MINFO
case|:
case|case
name|T_SOA
case|:
case|case
name|T_RP
case|:
comment|/* compare first string */
name|x
operator|=
name|strncasecmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|,
name|data
argument_list|,
name|strlen
argument_list|(
name|data
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
break|break;
comment|/* move to second string */
name|td
operator|=
name|data
operator|+
operator|(
name|strlen
argument_list|(
name|data
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
name|tdp
operator|=
name|dp
operator|->
name|d_data
operator|+
operator|(
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* compare second string */
name|x
operator|=
name|strncasecmp
argument_list|(
name|td
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tdp
argument_list|,
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|td
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
break|break;
comment|/* move beyond second string, to 				 * set of words in SOA. 				 * RP and MINFO stuff really 				 * ends here 				 */
name|td
operator|=
name|td
operator|+
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|td
argument_list|)
operator|+
literal|1
expr_stmt|;
name|tdp
operator|=
name|tdp
operator|+
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tdp
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
block|{
name|x
operator|=
name|memcmp
argument_list|(
name|td
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tdp
argument_list|,
literal|5
operator|*
name|INT32SZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* everything was equal, wow! 				 * so return a success 				 */
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|T_MX
case|:
case|case
name|T_AFSDB
case|:
case|case
name|T_RT
case|:
name|x
operator|=
name|memcmp
argument_list|(
name|dp
operator|->
name|d_data
argument_list|,
name|data
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
break|break;
name|td
operator|=
name|data
operator|+
name|INT16SZ
expr_stmt|;
name|tdp
operator|=
name|dp
operator|->
name|d_data
operator|+
name|INT16SZ
expr_stmt|;
name|x
operator|=
name|strncasecmp
argument_list|(
name|td
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tdp
argument_list|,
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|td
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
break|break;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|T_PX
case|:
name|x
operator|=
name|memcmp
argument_list|(
name|dp
operator|->
name|d_data
argument_list|,
name|data
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
break|break;
name|td
operator|=
name|data
operator|+
name|INT16SZ
expr_stmt|;
name|tdp
operator|=
name|dp
operator|->
name|d_data
operator|+
name|INT16SZ
expr_stmt|;
comment|/* compare first string */
name|x
operator|=
name|strncasecmp
argument_list|(
name|td
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tdp
argument_list|,
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|td
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
break|break;
name|td
operator|+=
operator|(
name|strlen
argument_list|(
name|td
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
name|tdp
operator|+=
operator|(
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tdp
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* compare second string */
name|x
operator|=
name|strncasecmp
argument_list|(
name|td
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tdp
argument_list|,
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|td
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
break|break;
return|return
operator|(
literal|1
operator|)
return|;
default|default:
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"unknown type %d\n"
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* continue in loop if record did not match */
block|}
comment|/* saw no record of interest in whole chain 	 * If the data we were trying to validate was negative, we succeeded! 	 * else we failed 	 */
if|if
condition|(
operator|(
name|data
operator|==
name|NULL
operator|)
operator|||
operator|(
name|dlen
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* negative data, report success */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* positive data, no such RR, validation failed */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/******************************************************************   * get a list of databufs that have ns addresses for the closest domain   * you know about, get their addresses and confirm that server indeed   * is one of them. if yes return 1 else 0.    * first checks the cache that we build in nslookup() earlier    * when we ns_forw(). if unableto find it there, it checks the entire   * hash table to do address translations.   *******************************************************************/
end_comment

begin_function
specifier|static
name|int
name|check_addr_ns
parameter_list|(
name|nsp
parameter_list|,
name|server
parameter_list|,
name|dname
parameter_list|)
name|struct
name|databuf
modifier|*
modifier|*
name|nsp
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|server
decl_stmt|;
name|char
modifier|*
name|dname
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|;
name|char
name|sname
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|struct
name|in_addr
modifier|*
name|saddr
init|=
operator|&
operator|(
name|server
operator|->
name|sin_addr
operator|)
decl_stmt|;
name|struct
name|databuf
modifier|*
modifier|*
name|nsdp
decl_stmt|;
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"check_addr_ns: s:[%s], db:0x%lx, d:\"%s\"\n"
operator|,
name|inet_ntoa
argument_list|(
operator|*
name|saddr
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|nsp
operator|,
name|dname
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|lastNA
init|;
name|i
operator|!=
name|firstNA
condition|;
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|MAXNAMECACHE
control|)
block|{
if|if
condition|(
operator|!
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|saddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|nameaddrlist
index|[
name|i
index|]
operator|.
name|ns_addr
operator|)
argument_list|,
name|INADDRSZ
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|sname
argument_list|,
name|nameaddrlist
index|[
name|i
index|]
operator|.
name|nsname
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"check_addr_ns: found address:[%s]\n"
operator|,
name|inet_ntoa
argument_list|(
operator|*
name|saddr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|nsdp
operator|=
name|nsp
init|;
operator|*
name|nsdp
operator|!=
name|NULL
condition|;
name|nsdp
operator|++
control|)
block|{
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"check_addr_ns:names are:%s, %s\n"
operator|,
name|sname
operator|,
operator|(
operator|*
name|nsdp
operator|)
operator|->
name|d_data
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|sname
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|*
name|nsdp
operator|)
operator|->
name|d_data
operator|)
argument_list|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
comment|/* could not find name in my cache of servers, must go through the 	 * whole grind 	 */
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"check_addr_ns:calling check_in_tables()\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|check_in_tables
argument_list|(
name|nsp
argument_list|,
name|server
argument_list|,
name|dname
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*************************************************************************  * checks in hash tables for the address of servers whose name is in the   * data section of nsp records. borrows code from nslookup()/ns_forw.c  * largely.  *************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|check_in_tables
parameter_list|(
name|nsp
parameter_list|,
name|server
parameter_list|,
name|syslogdname
parameter_list|)
name|struct
name|databuf
modifier|*
name|nsp
index|[]
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|server
decl_stmt|;
name|char
modifier|*
name|syslogdname
decl_stmt|;
block|{
specifier|register
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|nsdp
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|tmphtp
decl_stmt|;
specifier|const
name|char
modifier|*
name|dname
decl_stmt|,
modifier|*
name|fname
decl_stmt|;
name|int
name|class
decl_stmt|;
name|int
name|qcomp
parameter_list|()
function_decl|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"check_in_tables(nsp=x%lx, qp=x%x, '%s')\n"
operator|,
operator|(
name|u_long
operator|)
name|nsp
operator|,
name|server
operator|,
name|syslogdname
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|nsdp
operator|=
operator|*
name|nsp
operator|++
operator|)
operator|!=
name|NULL
condition|)
block|{
name|class
operator|=
name|nsdp
operator|->
name|d_class
expr_stmt|;
name|dname
operator|=
operator|(
name|char
operator|*
operator|)
name|nsdp
operator|->
name|d_data
expr_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"check_in_tables: NS %s c%d t%d (x%x)\n"
operator|,
name|dname
operator|,
name|class
operator|,
name|nsdp
operator|->
name|d_type
operator|,
name|nsdp
operator|->
name|d_flags
operator|)
argument_list|)
expr_stmt|;
name|tmphtp
operator|=
operator|(
operator|(
name|nsdp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
operator|)
condition|?
name|fcachetab
else|:
name|hashtab
operator|)
expr_stmt|;
name|np
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|tmphtp
argument_list|,
operator|&
name|fname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
operator|||
name|fname
operator|!=
name|dname
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"%s: not found %s %x\n"
operator|,
name|dname
operator|,
name|fname
operator|,
name|np
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* look for name server addresses */
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
name|stale
argument_list|(
name|dp
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_type
operator|!=
name|T_A
operator|||
name|dp
operator|->
name|d_class
operator|!=
name|class
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|NCACHE
if|if
condition|(
name|dp
operator|->
name|d_rcode
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
operator|!
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|server
operator|->
name|sin_addr
operator|)
argument_list|,
name|INADDRSZ
argument_list|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* haven't been able to locate the right address */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/************************************************************************  * is called in nslookup() and stores the name vs address of a name server  *           --& check_in_tables above--  * we contact, in a list of a maximum MAXNAMECACHE entries. we later refer  *             -- NAMEADDR nameaddrlist[MAXNAMECACHE]; --  * to this list when we are trying to resolve the name in check_addr_ns().  *************************************************************************/
end_comment

begin_function
name|void
name|store_name_addr
parameter_list|(
name|servername
parameter_list|,
name|serveraddr
parameter_list|,
name|syslogdname
parameter_list|,
name|sysloginfo
parameter_list|)
specifier|const
name|char
modifier|*
name|servername
decl_stmt|;
name|struct
name|in_addr
name|serveraddr
decl_stmt|;
specifier|const
name|char
modifier|*
name|syslogdname
decl_stmt|;
specifier|const
name|char
modifier|*
name|sysloginfo
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"store_name_addr:s:%s, a:[%s]\n"
operator|,
name|servername
operator|,
name|inet_ntoa
argument_list|(
name|serveraddr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* if we already have the name address pair in cache, return */
for|for
control|(
name|i
operator|=
name|lastNA
init|;
name|i
operator|!=
name|firstNA
condition|;
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|MAXNAMECACHE
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|servername
argument_list|,
name|nameaddrlist
index|[
name|i
index|]
operator|.
name|nsname
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|serveraddr
operator|.
name|s_addr
operator|==
name|nameaddrlist
index|[
name|i
index|]
operator|.
name|ns_addr
operator|.
name|s_addr
condition|)
block|{
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"store_name_addr:found n and a [%s] [%s] in our $\n"
operator|,
name|inet_ntoa
argument_list|(
name|nameaddrlist
index|[
name|i
index|]
operator|.
name|ns_addr
argument_list|)
operator|,
name|inet_ntoa
argument_list|(
name|serveraddr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* if */
block|}
elseif|else
if|if
condition|(
name|serveraddr
operator|.
name|s_addr
operator|==
name|nameaddrlist
index|[
name|i
index|]
operator|.
name|ns_addr
operator|.
name|s_addr
condition|)
block|{
ifdef|#
directive|ifdef
name|BAD_IDEA
comment|/* 			 * log this as it needs to be fixed. 			 * replace old name by new, next query likely to have 			 * NS record matching new 			 */
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nhash
argument_list|(
name|nameaddrlist
index|[
name|i
index|]
operator|.
name|nsname
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nhash
argument_list|(
name|servername
argument_list|)
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: server name mismatch for [%s]: (%s != %s) (server for %s)"
argument_list|,
name|sysloginfo
argument_list|,
name|inet_ntoa
argument_list|(
name|serveraddr
argument_list|)
argument_list|,
name|nameaddrlist
index|[
name|i
index|]
operator|.
name|nsname
argument_list|,
name|servername
argument_list|,
name|syslogdname
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|nameaddrlist
index|[
name|i
index|]
operator|.
name|nsname
argument_list|)
expr_stmt|;
name|nameaddrlist
index|[
name|i
index|]
operator|.
name|nsname
operator|=
name|savestr
argument_list|(
name|servername
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* we have to add this one to our cache */
name|nameaddrlist
index|[
name|firstNA
index|]
operator|.
name|nsname
operator|=
name|savestr
argument_list|(
name|servername
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|serveraddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|nameaddrlist
index|[
name|firstNA
index|]
operator|.
name|ns_addr
operator|)
argument_list|,
name|INADDRSZ
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"store_name_addr:added entry #:%d n:%s a:[%s]\n"
operator|,
name|firstNA
operator|,
name|nameaddrlist
index|[
name|firstNA
index|]
operator|.
name|nsname
operator|,
name|inet_ntoa
argument_list|(
name|nameaddrlist
index|[
name|firstNA
index|]
operator|.
name|ns_addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|firstNA
operator|=
operator|(
name|firstNA
operator|+
literal|1
operator|)
operator|%
name|MAXNAMECACHE
expr_stmt|;
if|if
condition|(
name|firstNA
operator|==
name|lastNA
condition|)
block|{
name|free
argument_list|(
name|nameaddrlist
index|[
name|firstNA
index|]
operator|.
name|nsname
argument_list|)
expr_stmt|;
name|nameaddrlist
index|[
name|firstNA
index|]
operator|.
name|nsname
operator|=
literal|0
expr_stmt|;
name|lastNA
operator|=
operator|(
name|lastNA
operator|+
literal|1
operator|)
operator|%
name|MAXNAMECACHE
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Decode the resource record 'rrp' and validate the RR.  * Borrows code almost entirely from doupdate(). is a rather  * non-invasive routine since it just goes thru the same motions  * as doupdate but just marks the array validatelist entry as   * the return code from validate(). This is later used in doupdate  * to cache/not cache the entry. also used in update_msg() to   * delete/keep the record from the outgoing message.  */
end_comment

begin_function
name|int
name|dovalidate
parameter_list|(
name|msg
parameter_list|,
name|msglen
parameter_list|,
name|rrp
parameter_list|,
name|zone
parameter_list|,
name|flags
parameter_list|,
name|qdomain
parameter_list|,
name|server
parameter_list|,
name|VCode
parameter_list|)
name|u_char
modifier|*
name|msg
decl_stmt|,
decl|*
name|rrp
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|msglen
decl_stmt|,
name|zone
decl_stmt|,
name|flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|qdomain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in
modifier|*
name|server
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|VCode
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|int
name|class
decl_stmt|,
name|type
decl_stmt|,
name|dlen
decl_stmt|,
name|n1
decl_stmt|;
name|u_int32_t
name|ttl
decl_stmt|;
name|char
name|dname
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|u_char
modifier|*
name|cp1
decl_stmt|;
name|u_char
name|data
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|hp
init|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
decl_stmt|;
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"dovalidate(zone %d, flags %x)\n"
operator|,
name|zone
operator|,
name|flags
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|10
condition|)
name|fp_nquery
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cp
operator|=
name|rrp
expr_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
name|dname
argument_list|,
sizeof|sizeof
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|ttl
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|dlen
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"dovalidate: dname %s type %d class %d ttl %d\n"
operator|,
name|dname
operator|,
name|type
operator|,
name|class
operator|,
name|ttl
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Convert the resource record data into the internal 	 * database format. 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
case|case
name|T_WKS
case|:
case|case
name|T_HINFO
case|:
case|case
name|T_UINFO
case|:
case|case
name|T_UID
case|:
case|case
name|T_GID
case|:
case|case
name|T_TXT
case|:
case|case
name|T_X25
case|:
case|case
name|T_ISDN
case|:
case|case
name|T_LOC
case|:
ifdef|#
directive|ifdef
name|ALLOW_T_UNSPEC
case|case
name|T_UNSPEC
case|:
endif|#
directive|endif
name|cp1
operator|=
name|cp
expr_stmt|;
name|n
operator|=
name|dlen
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
break|break;
case|case
name|T_CNAME
case|:
case|case
name|T_MB
case|:
case|case
name|T_MG
case|:
case|case
name|T_MR
case|:
case|case
name|T_NS
case|:
case|case
name|T_PTR
case|:
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|=
name|data
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|T_MINFO
case|:
case|case
name|T_SOA
case|:
case|case
name|T_RP
case|:
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|=
name|data
operator|+
operator|(
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
name|n1
operator|=
sizeof|sizeof
argument_list|(
name|data
argument_list|)
operator|-
name|n
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
name|n1
operator|-=
literal|5
operator|*
name|INT32SZ
expr_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|n1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|n
operator|=
literal|5
operator|*
name|INT32SZ
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
block|}
name|n
operator|=
name|cp1
operator|-
name|data
expr_stmt|;
name|cp1
operator|=
name|data
expr_stmt|;
break|break;
case|case
name|T_MX
case|:
case|case
name|T_AFSDB
case|:
case|case
name|T_RT
case|:
comment|/* grab preference */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|data
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|cp1
operator|=
name|data
operator|+
name|INT16SZ
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
comment|/* get name */
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* compute end of data */
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* compute size of data */
name|n
operator|=
name|cp1
operator|-
name|data
expr_stmt|;
name|cp1
operator|=
name|data
expr_stmt|;
break|break;
case|case
name|T_PX
case|:
comment|/* grab preference */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|data
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|cp1
operator|=
name|data
operator|+
name|INT16SZ
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
comment|/* get first name */
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
operator|(
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
name|n1
operator|=
sizeof|sizeof
argument_list|(
name|data
argument_list|)
operator|-
name|n
expr_stmt|;
comment|/* get second name */
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|n1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|n
operator|=
name|cp1
operator|-
name|data
expr_stmt|;
name|cp1
operator|=
name|data
expr_stmt|;
break|break;
default|default:
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"unknown type %d\n"
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|cp
operator|-
name|rrp
operator|)
operator|+
name|dlen
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|>
name|MAXDATA
condition|)
block|{
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"update type %d: %d bytes is too much data\n"
operator|,
name|type
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|VCode
operator|=
name|validate
argument_list|(
name|dname
argument_list|,
name|qdomain
argument_list|,
name|server
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|n
ifdef|#
directive|ifdef
name|NCACHE
argument_list|,
name|NOERROR
endif|#
directive|endif
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|VCode
operator|==
name|INVALID
condition|)
block|{
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"validation failed d:%s, t:%d, c:%d\n"
operator|,
name|dname
operator|,
name|type
operator|,
name|class
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"validation succeeded d:%s, t:%d, c:%d\n"
operator|,
name|dname
operator|,
name|type
operator|,
name|class
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|cp
operator|-
name|rrp
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/******************************************************************   * This manages a data structure that stores all RRs that we were   * unable to validate. Am not sure exactly what purpose this might   * serve but until such time as we are sure it will not help, let   * me do it anyway.   *****************************************************************/
end_comment

begin_comment
unit|static void stick_in_queue(dname, type, class, data) 	char *dname; 	int type; 	int class; 	char *data; { 	struct timeval tp; 	struct _TIMEZONE tzp; 	TO_Validate *tempVQ; 	u_long leasttime;  	if (validateQ == NULL) { 		validateQ = (TO_Validate *)malloc(sizeof(TO_Validate)); 		if (!validateQ) 			panic(errno, "malloc(validateQ)"); 		validateQ->type = type; 		validateQ->class = class; 		validateQ->dname = savestr(dname); 		validateQ->data = savestr(data);
comment|/* XXX no \0 */
end_comment

begin_comment
unit|gettimeofday(&tp,&tzp); 		validateQ->time = tp.tv_sec; 		VQcount = 1; 		validateQ->next = validateQ->prev = NULL; 		currentVQ = validateQ; 		return; 	} 	if (VQcount< MAXVQ) { 		tempVQ =(TO_Validate *)malloc(sizeof(TO_Validate)); 		if (!tempVQ) 			panic(errno, "malloc(tempVQ)"); 		tempVQ->type = type; 		tempVQ->class = class; 		tempVQ->dname = savestr(dname); 		tempVQ->data = savestr(data);
comment|/* XXX no \0 */
end_comment

begin_endif
unit|gettimeofday(&tp,&tzp); 		tempVQ->time = tp.tv_sec; 		tempVQ->next = currentVQ->next; 		tempVQ->prev = currentVQ; 		if (currentVQ->next != NULL) 			currentVQ->next->prev = tempVQ; 		currentVQ->next = tempVQ; 		currentVQ = tempVQ; 		VQcount++; 		return; 	} 	gettimeofday(&tp,&tzp); 	leasttime = validateQ->time; 	currentVQ = validateQ; 	for (tempVQ = validateQ;  tempVQ != NULL;  tempVQ = tempVQ->next) { 		if (tp.tv_sec>= tempVQ->time +VQEXPIRY) { 			tempVQ->type = type; 			tempVQ->class = class; 			strcpy(tempVQ->dname, dname); 			strcpy(tempVQ->data, data); 			tempVQ->time = tp.tv_sec; 			currentVQ = tempVQ; 			return; 		} 		if (tempVQ->time< leasttime) { 			leasttime = tempVQ->time; 			currentVQ = tempVQ; 		} 	} 	currentVQ->type = type; 	currentVQ->class = class; 	strcpy(currentVQ->dname, dname); 	strcpy(currentVQ->data, data); 	currentVQ->time = tp.tv_sec; 	return; }
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BAD_IDEA
end_ifdef

begin_comment
comment|/* removes any INVALID RR's from the msg being returned, updates msglen to  * reflect the new message length.  */
end_comment

begin_function
name|int
name|update_msg
parameter_list|(
name|msg
parameter_list|,
name|msglen
parameter_list|,
name|Vlist
parameter_list|,
name|c
parameter_list|)
name|u_char
modifier|*
name|msg
decl_stmt|;
name|int
modifier|*
name|msglen
decl_stmt|;
name|int
name|Vlist
index|[]
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|u_char
modifier|*
name|tempcp
decl_stmt|,
modifier|*
name|newcp
decl_stmt|;
name|int
modifier|*
name|RRlen
decl_stmt|;
name|int
name|qlen
decl_stmt|;
comment|/* the length of the query section*/
name|u_int16_t
name|rdlength
decl_stmt|;
name|u_int16_t
name|ancount
decl_stmt|,
name|nscount
decl_stmt|;
name|u_int16_t
name|new_ancount
decl_stmt|,
name|new_nscount
decl_stmt|,
name|new_arcount
decl_stmt|;
name|char
name|dname
index|[
name|MAXDNAME
index|]
decl_stmt|,
name|qname
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|u_char
name|data
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|u_char
modifier|*
modifier|*
name|dpp
decl_stmt|;
name|u_char
modifier|*
name|dnptrs
index|[
literal|40
index|]
decl_stmt|;
name|u_char
modifier|*
modifier|*
name|edp
init|=
name|dnptrs
operator|+
sizeof|sizeof
argument_list|(
name|dnptrs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|dnptrs
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|u_char
modifier|*
name|eom
init|=
name|msg
operator|+
operator|*
name|msglen
decl_stmt|;
name|int
name|n_new
decl_stmt|;
name|int
name|rembuflen
decl_stmt|,
name|newlen
decl_stmt|;
name|u_char
modifier|*
name|newmsg
decl_stmt|;
name|u_int16_t
name|type
decl_stmt|,
name|class
decl_stmt|,
name|dlen
decl_stmt|;
name|u_int32_t
name|ttl
decl_stmt|;
name|int
name|inv
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"update_msg: msglen:%d, c:%d\n"
argument_list|,
operator|*
name|msglen
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>=
literal|10
condition|)
name|fp_nquery
argument_list|(
name|msg
argument_list|,
operator|*
name|msglen
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* just making sure we do not do all the work for nothing */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Vlist
index|[
name|i
index|]
operator|==
name|INVALID
condition|)
block|{
name|inv
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|inv
operator|!=
literal|1
condition|)
block|{
comment|/* no invalid records, go about your job */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"update_msg: NEEDS updating:\n"
operator|)
argument_list|)
expr_stmt|;
name|RRlen
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|c
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|RRlen
condition|)
name|panic
argument_list|(
name|errno
argument_list|,
literal|"malloc(RRlen)"
argument_list|)
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
expr_stmt|;
name|new_ancount
operator|=
name|ancount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|new_nscount
operator|=
name|nscount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|nscount
argument_list|)
expr_stmt|;
name|new_arcount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|arcount
argument_list|)
expr_stmt|;
name|cp
operator|=
name|msg
operator|+
name|HFIXEDSZ
expr_stmt|;
name|newlen
operator|=
name|HFIXEDSZ
expr_stmt|;
comment|/* skip the query section */
name|qlen
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|qname
argument_list|,
sizeof|sizeof
name|qname
argument_list|)
expr_stmt|;
if|if
condition|(
name|qlen
operator|<=
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"dn_expand() failed, bad record\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|badend
goto|;
block|}
name|cp
operator|+=
name|qlen
expr_stmt|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|qlen
operator|+=
literal|2
operator|*
name|INT16SZ
expr_stmt|;
name|newlen
operator|+=
name|qlen
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Vlist
index|[
name|i
index|]
operator|==
name|INVALID
condition|)
block|{
if|if
condition|(
name|i
operator|<
name|ancount
condition|)
name|new_ancount
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
name|ancount
operator|+
name|nscount
condition|)
name|new_nscount
operator|--
expr_stmt|;
else|else
name|new_arcount
operator|--
expr_stmt|;
block|}
name|RRlen
index|[
name|i
index|]
operator|=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|msg
operator|+
operator|*
name|msglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|RRlen
index|[
name|i
index|]
operator|<=
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"dn_skipname() failed, bad record\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|badend
goto|;
block|}
name|RRlen
index|[
name|i
index|]
operator|+=
literal|2
operator|*
name|INT16SZ
operator|+
name|INT32SZ
expr_stmt|;
comment|/*type+class+TTL*/
name|cp
operator|+=
name|RRlen
index|[
name|i
index|]
expr_stmt|;
name|GETSHORT
argument_list|(
name|rdlength
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|RRlen
index|[
name|i
index|]
operator|+=
name|INT16SZ
expr_stmt|;
comment|/*rdlength*/
name|RRlen
index|[
name|i
index|]
operator|+=
name|rdlength
expr_stmt|;
comment|/*rdata field*/
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"RRlen[%d]=%d\n"
operator|,
name|i
operator|,
name|RRlen
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Vlist
index|[
name|i
index|]
operator|!=
name|INVALID
condition|)
name|newlen
operator|+=
name|RRlen
index|[
name|i
index|]
expr_stmt|;
name|cp
operator|+=
name|rdlength
expr_stmt|;
comment|/*increment pointer to next RR*/
block|}
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
name|new_ancount
argument_list|)
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
name|new_nscount
argument_list|)
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
name|htons
argument_list|(
name|new_arcount
argument_list|)
expr_stmt|;
comment|/* get new buffer */
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"newlen:%d, if no RR is INVALID == msglen\n"
operator|,
name|newlen
operator|)
argument_list|)
expr_stmt|;
name|newmsg
operator|=
operator|(
name|u_char
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
name|newlen
operator|+
name|MAXDNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|newmsg
operator|==
name|NULL
condition|)
goto|goto
name|badend
goto|;
name|dpp
operator|=
name|dnptrs
expr_stmt|;
operator|*
name|dpp
operator|++
operator|=
name|newmsg
expr_stmt|;
operator|*
name|dpp
operator|=
name|NULL
expr_stmt|;
comment|/* bcopy the header, with all the length fields correctly put in */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|msg
argument_list|,
operator|(
name|char
operator|*
operator|)
name|newmsg
argument_list|,
name|HFIXEDSZ
argument_list|)
expr_stmt|;
comment|/*header copied */
name|newcp
operator|=
name|newmsg
operator|+
name|HFIXEDSZ
expr_stmt|;
comment|/*need a pointer in the new buffer */
name|rembuflen
operator|=
name|newlen
operator|+
name|MAXDNAME
operator|-
name|HFIXEDSZ
expr_stmt|;
comment|/*buflen we can workin*/
name|newlen
operator|=
name|HFIXEDSZ
expr_stmt|;
comment|/* this will now contain the length of msg */
name|n_new
operator|=
name|dn_comp
argument_list|(
name|qname
argument_list|,
name|newcp
argument_list|,
name|rembuflen
argument_list|,
name|dnptrs
argument_list|,
name|edp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_new
operator|<
literal|0
condition|)
goto|goto
name|badend
goto|;
name|newcp
operator|+=
name|n_new
expr_stmt|;
name|PUTSHORT
argument_list|(
name|type
argument_list|,
name|newcp
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
name|class
argument_list|,
name|newcp
argument_list|)
expr_stmt|;
comment|/*query section complete*/
name|newlen
operator|+=
operator|(
name|n_new
operator|+
literal|2
operator|*
name|INT16SZ
operator|)
expr_stmt|;
name|rembuflen
operator|-=
operator|(
name|n_new
operator|+
literal|2
operator|*
name|INT16SZ
operator|)
expr_stmt|;
comment|/* have to decode and copy every Valid RR from here */
name|cp
operator|=
name|msg
operator|+
name|HFIXEDSZ
operator|+
name|qlen
expr_stmt|;
comment|/*skip header and query section*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Vlist
index|[
name|i
index|]
operator|==
name|INVALID
condition|)
block|{
comment|/* go to next RR if this one is not INVALID */
name|cp
operator|+=
name|RRlen
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
comment|/* we have a valid record, must put it in the newmsg */
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|dname
argument_list|,
sizeof|sizeof
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
goto|goto
name|badend
goto|;
block|}
name|n_new
operator|=
name|dn_comp
argument_list|(
name|dname
argument_list|,
name|newcp
argument_list|,
name|rembuflen
argument_list|,
name|dnptrs
argument_list|,
name|edp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_new
operator|<
literal|0
condition|)
goto|goto
name|badend
goto|;
name|cp
operator|+=
name|n
expr_stmt|;
name|newcp
operator|+=
name|n_new
expr_stmt|;
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"cp:0x%x newcp:0x%x after getting name\n"
operator|,
name|cp
operator|,
name|newcp
operator|)
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
name|type
argument_list|,
name|newcp
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"cp:0x%x newcp:0x%x after getting type\n"
operator|,
name|cp
operator|,
name|newcp
operator|)
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
name|class
argument_list|,
name|newcp
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"cp:0x%x newcp:0x%x after getting class\n"
operator|,
name|cp
operator|,
name|newcp
operator|)
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|ttl
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|PUTLONG
argument_list|(
name|ttl
argument_list|,
name|newcp
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"cp:0x%x newcp:0x%x after getting ttl\n"
operator|,
name|cp
operator|,
name|newcp
operator|)
argument_list|)
expr_stmt|;
comment|/* this will probably be modified for newmsg, 		 * will put this in later, after compression 		 */
name|GETSHORT
argument_list|(
name|dlen
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|newlen
operator|+=
operator|(
name|n_new
operator|+
literal|3
operator|*
name|INT16SZ
operator|+
name|INT32SZ
operator|)
expr_stmt|;
name|rembuflen
operator|-=
operator|(
name|n_new
operator|+
literal|3
operator|*
name|INT16SZ
operator|+
name|INT32SZ
operator|)
expr_stmt|;
name|tempcp
operator|=
name|newcp
expr_stmt|;
name|newcp
operator|+=
name|INT16SZ
expr_stmt|;
comment|/*advance to rdata field*/
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"tempcp:0x%x newcp:0x%x\n"
operator|,
name|tempcp
operator|,
name|newcp
operator|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"update_msg: dname %s type %d class %d ttl %d\n"
operator|,
name|dname
operator|,
name|type
operator|,
name|class
operator|,
name|ttl
operator|)
argument_list|)
expr_stmt|;
comment|/* read off the data section */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
case|case
name|T_WKS
case|:
case|case
name|T_HINFO
case|:
case|case
name|T_UINFO
case|:
case|case
name|T_UID
case|:
case|case
name|T_GID
case|:
case|case
name|T_TXT
case|:
case|case
name|T_X25
case|:
case|case
name|T_ISDN
case|:
case|case
name|T_LOC
case|:
ifdef|#
directive|ifdef
name|ALLOW_T_UNSPEC
case|case
name|T_UNSPEC
case|:
endif|#
directive|endif
name|n
operator|=
name|dlen
expr_stmt|;
name|PUTSHORT
argument_list|(
name|n
argument_list|,
name|tempcp
argument_list|)
expr_stmt|;
comment|/*time to put in the dlen*/
name|bcopy
argument_list|(
name|cp
argument_list|,
name|newcp
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/*done here*/
name|cp
operator|+=
name|n
expr_stmt|;
name|newcp
operator|+=
name|n
expr_stmt|;
name|newlen
operator|+=
name|n
expr_stmt|;
name|rembuflen
operator|-=
name|n
expr_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"\tcp:0x%x newcp:0x%x dlen:%d\n"
operator|,
name|cp
operator|,
name|newcp
operator|,
name|dlen
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_CNAME
case|:
case|case
name|T_MB
case|:
case|case
name|T_MG
case|:
case|case
name|T_MR
case|:
case|case
name|T_NS
case|:
case|case
name|T_PTR
case|:
comment|/*read off name from data section */
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
goto|goto
name|badend
goto|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
comment|/*advance pointer*/
comment|/* fill in new packet */
name|n_new
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|newcp
argument_list|,
name|rembuflen
argument_list|,
name|dnptrs
argument_list|,
name|edp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_new
operator|<
literal|0
condition|)
goto|goto
name|badend
goto|;
name|PUTSHORT
argument_list|(
name|n_new
argument_list|,
name|tempcp
argument_list|)
expr_stmt|;
comment|/*put in dlen field*/
name|newcp
operator|+=
name|n_new
expr_stmt|;
comment|/*advance new pointer*/
name|newlen
operator|+=
name|n_new
expr_stmt|;
name|rembuflen
operator|-=
name|n_new
expr_stmt|;
break|break;
case|case
name|T_MINFO
case|:
case|case
name|T_SOA
case|:
case|case
name|T_RP
case|:
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
goto|goto
name|badend
goto|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|n_new
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|newcp
argument_list|,
name|rembuflen
argument_list|,
name|dnptrs
argument_list|,
name|edp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_new
operator|<
literal|0
condition|)
goto|goto
name|badend
goto|;
name|newcp
operator|+=
name|n_new
expr_stmt|;
name|newlen
operator|+=
name|n_new
expr_stmt|;
name|rembuflen
operator|-=
name|n_new
expr_stmt|;
name|dlen
operator|=
name|n_new
expr_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
goto|goto
name|badend
goto|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|n_new
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|newcp
argument_list|,
name|rembuflen
argument_list|,
name|dnptrs
argument_list|,
name|edp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_new
operator|<
literal|0
condition|)
goto|goto
name|badend
goto|;
name|newcp
operator|+=
name|n_new
expr_stmt|;
name|newlen
operator|+=
name|n_new
expr_stmt|;
name|rembuflen
operator|-=
name|n_new
expr_stmt|;
name|dlen
operator|+=
name|n_new
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
block|{
name|bcopy
argument_list|(
name|cp
argument_list|,
name|newcp
argument_list|,
name|n
operator|=
literal|5
operator|*
name|INT32SZ
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|newcp
operator|+=
name|n
expr_stmt|;
name|newlen
operator|+=
name|n
expr_stmt|;
name|rembuflen
operator|-=
name|n
expr_stmt|;
name|dlen
operator|+=
name|n
expr_stmt|;
block|}
name|PUTSHORT
argument_list|(
name|dlen
argument_list|,
name|tempcp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MX
case|:
case|case
name|T_AFSDB
case|:
case|case
name|T_RT
case|:
comment|/* grab preference */
name|bcopy
argument_list|(
name|cp
argument_list|,
name|newcp
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
name|newcp
operator|+=
name|INT16SZ
expr_stmt|;
comment|/* get name */
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
goto|goto
name|badend
goto|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|n_new
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|newcp
argument_list|,
name|rembuflen
argument_list|,
name|dnptrs
argument_list|,
name|edp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_new
operator|<
literal|0
condition|)
goto|goto
name|badend
goto|;
name|PUTSHORT
argument_list|(
name|n_new
operator|+
name|INT16SZ
argument_list|,
name|tempcp
argument_list|)
expr_stmt|;
name|newcp
operator|+=
name|n_new
expr_stmt|;
name|newlen
operator|+=
name|n_new
operator|+
name|INT16SZ
expr_stmt|;
name|rembuflen
operator|-=
name|n_new
operator|+
name|INT16SZ
expr_stmt|;
break|break;
case|case
name|T_PX
case|:
comment|/* grab preference */
name|bcopy
argument_list|(
name|cp
argument_list|,
name|newcp
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
name|newcp
operator|+=
name|INT16SZ
expr_stmt|;
comment|/* get first name */
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
goto|goto
name|badend
goto|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|n_new
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|newcp
argument_list|,
name|rembuflen
argument_list|,
name|dnptrs
argument_list|,
name|edp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_new
operator|<
literal|0
condition|)
goto|goto
name|badend
goto|;
name|newcp
operator|+=
name|n_new
expr_stmt|;
name|newlen
operator|+=
name|n_new
operator|+
name|INT16SZ
expr_stmt|;
name|rembuflen
operator|-=
name|n_new
operator|+
name|INT16SZ
expr_stmt|;
name|dlen
operator|=
name|n_new
operator|+
name|INT16SZ
expr_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
goto|goto
name|badend
goto|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|n_new
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|newcp
argument_list|,
name|rembuflen
argument_list|,
name|dnptrs
argument_list|,
name|edp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_new
operator|<
literal|0
condition|)
goto|goto
name|badend
goto|;
name|newcp
operator|+=
name|n_new
expr_stmt|;
name|newlen
operator|+=
name|n_new
expr_stmt|;
name|rembuflen
operator|-=
name|n_new
expr_stmt|;
name|dlen
operator|+=
name|n_new
expr_stmt|;
name|PUTSHORT
argument_list|(
name|dlen
argument_list|,
name|tempcp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"unknown type %d\n"
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|badend
goto|;
block|}
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"newlen:%d, i:%d newcp:0x%x cp:0x%x\n\n"
operator|,
name|newlen
operator|,
name|i
operator|,
name|newcp
operator|,
name|cp
operator|)
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|newmsg
argument_list|,
name|msg
argument_list|,
name|newlen
argument_list|)
expr_stmt|;
name|n
operator|=
operator|*
name|msglen
operator|-
name|newlen
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"update_msg():newmsg longer than old: n:%d o:%d ???\n"
operator|,
name|newlen
operator|,
operator|*
name|msglen
operator|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|msglen
operator|=
name|newlen
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newmsg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|10
condition|)
name|fp_nquery
argument_list|(
name|msg
argument_list|,
operator|*
name|msglen
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|RRlen
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
name|badend
label|:
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"encountered problems: UPDATE_MSG\n"
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|RRlen
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*BAD_IDEA*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*VALIDATE*/
end_comment

end_unit

