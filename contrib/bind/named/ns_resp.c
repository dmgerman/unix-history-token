begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ns_resp.c	4.65 (Berkeley) 3/3/91"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: ns_resp.c,v 8.41 1998/04/07 04:59:45 vixie Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * ++Copyright++ 1986, 1988, 1990  * -  * Copyright (c) 1986, 1988, 1990  *    The Regents of the University of California.  All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * 	This product includes software developed by the University of  * 	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  * -  * Portions Copyright (c) 1993 by Digital Equipment Corporation.  *   * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Digital Equipment Corporation not be used in advertising or  * publicity pertaining to distribution of the document or software without  * specific, written prior permission.  *   * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT  * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  * -  * Portions Copyright (c) 1995 by International Business Machines, Inc.  *  * International Business Machines, Inc. (hereinafter called IBM) grants  * permission under its copyrights to use, copy, modify, and distribute this  * Software with or without fee, provided that the above copyright notice and  * all paragraphs of this notice appear in all copies, and that the name of IBM  * not be used in connection with the marketing of any product incorporating  * the Software or modifications thereof, without specific, written prior  * permission.  *  * To the extent it has a right to do so, IBM grants an immunity from suit  * under its patents, if any, for the use, sale or manufacture of products to  * the extent that such products are used for performing Domain Name System  * dynamic updates in TCP/IP networks by means of the Software.  No immunity is  * granted for any product per se or for any other function of any product.  *  * THE SOFTWARE IS PROVIDED "AS IS", AND IBM DISCLAIMS ALL WARRANTIES,  * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  * PARTICULAR PURPOSE.  IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL,  * DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER ARISING  * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE, EVEN  * IF IBM IS APPRISED OF THE POSSIBILITY OF SUCH DAMAGES.  * --Copyright--  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|"named.h"
end_include

begin_decl_stmt
specifier|static
name|u_int8_t
name|norootlogged
index|[
name|MAXCLASS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX- should be a bitmap */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|skipnameFailedAnswer
index|[]
init|=
literal|"skipname failed in answer"
decl_stmt|,
name|skipnameFailedAuth
index|[]
init|=
literal|"skipname failed in authority"
decl_stmt|,
name|skipnameFailedQuery
index|[]
init|=
literal|"skipname failed in query"
decl_stmt|,
name|outofDataQuery
index|[]
init|=
literal|"ran out of data in query"
decl_stmt|,
name|outofDataAnswer
index|[]
init|=
literal|"ran out of data in answer"
decl_stmt|,
name|notSingleQuery
index|[]
init|=
literal|"not exactly one query"
decl_stmt|,
name|expandFailedQuery
index|[]
init|=
literal|"dn_expand failed in query"
decl_stmt|,
name|expandFailedAnswer
index|[]
init|=
literal|"dn_expand failed in answer"
decl_stmt|,
name|expandFailedAuth
index|[]
init|=
literal|"dn_expand failed in authority"
decl_stmt|,
name|outofDataAuth
index|[]
init|=
literal|"ran out of data in authority"
decl_stmt|,
name|dlenOverrunAnswer
index|[]
init|=
literal|"dlen overrun in answer"
decl_stmt|,
name|dlenOverrunAuth
index|[]
init|=
literal|"dlen overrun in authority"
decl_stmt|,
name|dlenUnderrunAnswer
index|[]
init|=
literal|"dlen underrun in answer"
decl_stmt|,
name|outofDataFinal
index|[]
init|=
literal|"out of data in final pass"
decl_stmt|,
name|outofDataAFinal
index|[]
init|=
literal|"out of data after final pass"
decl_stmt|,
name|badNameFound
index|[]
init|=
literal|"found an invalid domain name"
decl_stmt|,
name|wrongQuestion
index|[]
init|=
literal|"answer to wrong question"
decl_stmt|,
name|danglingCname
index|[]
init|=
literal|"dangling CNAME pointer"
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|db_list
block|{
name|struct
name|db_list
modifier|*
name|db_next
decl_stmt|;
name|struct
name|databuf
modifier|*
name|db_dp
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|flush_set
block|{
name|char
modifier|*
name|fs_name
decl_stmt|;
name|int
name|fs_type
decl_stmt|;
name|int
name|fs_class
decl_stmt|;
name|u_int
name|fs_cred
decl_stmt|;
name|struct
name|db_list
modifier|*
name|fs_list
decl_stmt|;
name|struct
name|db_list
modifier|*
name|fs_last
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|rrsetadd
name|__P
argument_list|(
operator|(
expr|struct
name|flush_set
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|databuf
operator|*
operator|)
argument_list|)
decl_stmt|,
name|rrsetupdate
name|__P
argument_list|(
operator|(
expr|struct
name|flush_set
operator|*
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|,
name|flushrrset
name|__P
argument_list|(
operator|(
expr|struct
name|flush_set
operator|*
operator|)
argument_list|)
decl_stmt|,
name|free_flushset
name|__P
argument_list|(
operator|(
expr|struct
name|flush_set
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rrsetcmp
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|db_list
operator|*
operator|)
argument_list|)
decl_stmt|,
name|check_root
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|,
name|check_ns
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|,
name|rrextract
name|__P
argument_list|(
operator|(
name|u_char
operator|*
operator|,
name|int
operator|,
name|u_char
operator|*
operator|,
expr|struct
name|databuf
operator|*
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_related_additional
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_related_additional
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|related_additional
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|maybe_free
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAX_RELATED
value|100
end_define

begin_decl_stmt
specifier|static
name|int
name|num_related
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|related
index|[
name|MAX_RELATED
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LAME_LOGGING
end_ifdef

begin_function
specifier|static
name|char
modifier|*
name|learntFrom
parameter_list|(
name|qp
parameter_list|,
name|server
parameter_list|)
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|server
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|ns
decl_stmt|,
modifier|*
name|na
decl_stmt|;
name|struct
name|databuf
modifier|*
name|db
decl_stmt|;
ifdef|#
directive|ifdef
name|STATS
name|char
name|nsbuf
index|[
literal|20
index|]
decl_stmt|;
name|char
name|abuf
index|[
literal|20
index|]
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|;
if|if
condition|(
name|buf
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
name|a
operator|=
name|ns
operator|=
name|na
operator|=
literal|"<Not Available>"
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|qp
operator|->
name|q_naddr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns_addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|server
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
name|db
operator|=
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns
expr_stmt|;
if|if
condition|(
name|db
condition|)
block|{
ifdef|#
directive|ifdef
name|STATS
if|if
condition|(
name|db
operator|->
name|d_ns
condition|)
block|{
name|strcpy
argument_list|(
name|nsbuf
argument_list|,
name|inet_ntoa
argument_list|(
name|db
operator|->
name|d_ns
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|ns
operator|=
name|nsbuf
expr_stmt|;
block|}
else|else
block|{
name|ns
operator|=
name|zones
index|[
name|db
operator|->
name|d_zone
index|]
operator|.
name|z_origin
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NCACHE
if|if
condition|(
operator|!
name|db
operator|->
name|d_rcode
condition|)
endif|#
directive|endif
name|na
operator|=
operator|(
name|char
operator|*
operator|)
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns
operator|->
name|d_data
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STATS
name|db
operator|=
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|nsdata
expr_stmt|;
if|if
condition|(
name|db
condition|)
block|{
if|if
condition|(
name|db
operator|->
name|d_ns
condition|)
block|{
name|strcpy
argument_list|(
name|abuf
argument_list|,
name|inet_ntoa
argument_list|(
name|db
operator|->
name|d_ns
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|=
name|abuf
expr_stmt|;
block|}
else|else
block|{
name|a
operator|=
name|zones
index|[
name|db
operator|->
name|d_zone
index|]
operator|.
name|z_origin
expr_stmt|;
block|}
block|}
endif|#
directive|endif
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|a
operator|==
name|ns
operator|)
operator|&&
operator|(
name|ns
operator|==
name|na
operator|)
condition|)
comment|/* all "UNKNOWN" */
return|return
operator|(
literal|""
operator|)
return|;
ifdef|#
directive|ifdef
name|STATS
define|#
directive|define
name|LEARNTFROM
value|" '%s': learnt (A=%s,NS=%s)"
else|#
directive|else
define|#
directive|define
name|LEARNTFROM
value|" '%s'"
endif|#
directive|endif
name|buf
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|a
operator|=
operator|(
operator|*
name|a
condition|?
name|a
else|:
literal|"\".\""
operator|)
argument_list|)
operator|+
name|strlen
argument_list|(
name|ns
operator|=
operator|(
operator|*
name|ns
condition|?
name|ns
else|:
literal|"\".\""
operator|)
argument_list|)
operator|+
name|strlen
argument_list|(
name|na
operator|=
operator|(
operator|*
name|na
condition|?
name|na
else|:
literal|"\".\""
operator|)
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|LEARNTFROM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return
operator|(
literal|""
operator|)
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|LEARNTFROM
argument_list|,
name|na
argument_list|,
name|a
argument_list|,
name|ns
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*LAME_LOGGING*/
end_comment

begin_function
name|void
name|ns_resp
parameter_list|(
name|msg
parameter_list|,
name|msglen
parameter_list|)
name|u_char
modifier|*
name|msg
decl_stmt|;
name|int
name|msglen
decl_stmt|;
block|{
specifier|register
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
specifier|register
name|struct
name|qserv
modifier|*
name|qs
decl_stmt|;
specifier|register
name|struct
name|databuf
modifier|*
name|ns
decl_stmt|,
modifier|*
name|ns2
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
name|u_char
modifier|*
name|eom
init|=
name|msg
operator|+
name|msglen
decl_stmt|;
name|struct
name|flush_set
modifier|*
name|flushset
init|=
name|NULL
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|nsa
decl_stmt|;
name|struct
name|databuf
modifier|*
name|nsp
index|[
name|NSMAX
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|n
decl_stmt|,
name|qdcount
decl_stmt|,
name|ancount
decl_stmt|,
name|aucount
decl_stmt|,
name|nscount
decl_stmt|,
name|arcount
decl_stmt|,
name|arfirst
decl_stmt|;
name|int
name|qtype
decl_stmt|,
name|qclass
decl_stmt|,
name|dbflags
decl_stmt|;
name|int
name|restart
decl_stmt|;
comment|/* flag for processing cname response */
name|int
name|validanswer
decl_stmt|;
name|int
name|cname
decl_stmt|,
name|lastwascname
decl_stmt|,
name|externalcname
decl_stmt|;
name|int
name|count
decl_stmt|,
name|founddata
decl_stmt|,
name|foundname
decl_stmt|;
name|int
name|buflen
decl_stmt|;
name|int
name|newmsglen
decl_stmt|;
name|char
name|name
index|[
name|MAXDNAME
index|]
decl_stmt|,
name|qname
index|[
name|MAXDNAME
index|]
decl_stmt|,
name|aname
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|char
name|msgbuf
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|char
modifier|*
name|dname
decl_stmt|,
name|tmpdomain
index|[
name|MAXDNAME
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
specifier|const
name|char
modifier|*
name|formerrmsg
init|=
literal|"brain damage"
decl_stmt|;
name|u_char
name|newmsg
index|[
name|PACKETSZ
index|]
decl_stmt|;
name|u_char
modifier|*
modifier|*
name|dpp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|time_t
name|rtrip
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|netinfo
modifier|*
name|lp
decl_stmt|;
name|struct
name|fwdinfo
modifier|*
name|fwd
decl_stmt|;
name|char
modifier|*
name|tname
init|=
name|NULL
decl_stmt|;
name|nameserIncr
argument_list|(
name|from_addr
operator|.
name|sin_addr
argument_list|,
name|nssRcvdR
argument_list|)
expr_stmt|;
name|nsp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
expr_stmt|;
if|if
condition|(
operator|(
name|qp
operator|=
name|qfindid
argument_list|(
name|hp
operator|->
name|id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"DUP? dropped (id %d)\n"
operator|,
name|ntohs
argument_list|(
name|hp
operator|->
name|id
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|from_addr
operator|.
name|sin_addr
argument_list|,
name|nssRcvdDupR
argument_list|)
expr_stmt|;
return|return;
block|}
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"Response (%s %s %s) nsid=%d id=%d\n"
operator|,
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_SYSTEM
operator|)
condition|?
literal|"SYSTEM"
else|:
literal|"USER"
operator|,
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_PRIMING
operator|)
condition|?
literal|"PRIMING"
else|:
literal|"NORMAL"
operator|,
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_ZSERIAL
operator|)
condition|?
literal|"ZSERIAL"
else|:
literal|"-"
operator|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_nsid
argument_list|)
operator|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_id
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Here we handle high level formatting problems by parsing the header. 	 */
name|qdcount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
expr_stmt|;
name|ancount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|aucount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|nscount
argument_list|)
expr_stmt|;
comment|/* !!! */
name|arcount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|arcount
argument_list|)
expr_stmt|;
name|free_addinfo
argument_list|()
expr_stmt|;
comment|/* sets addcount to zero */
name|cp
operator|=
name|msg
operator|+
name|HFIXEDSZ
expr_stmt|;
name|dpp
operator|=
name|dnptrs
expr_stmt|;
operator|*
name|dpp
operator|++
operator|=
name|msg
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cp
operator|&
name|INDIR_MASK
operator|)
operator|==
literal|0
condition|)
operator|*
name|dpp
operator|++
operator|=
name|cp
expr_stmt|;
operator|*
name|dpp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|qdcount
operator|==
literal|1
condition|)
block|{
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|qname
argument_list|,
sizeof|sizeof
argument_list|(
name|qname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
name|formerrmsg
operator|=
name|expandFailedQuery
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|cp
operator|+
literal|2
operator|*
name|INT16SZ
operator|>
name|eom
condition|)
block|{
name|formerrmsg
operator|=
name|outofDataQuery
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|GETSHORT
argument_list|(
name|qtype
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|qclass
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
name|qname
argument_list|,
name|qclass
argument_list|,
name|response_trans
argument_list|,
name|ns_ownercontext
argument_list|(
name|qtype
argument_list|,
name|response_trans
argument_list|)
argument_list|,
name|qname
argument_list|,
name|from_addr
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|formerrmsg
operator|=
name|badNameFound
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
if|if
condition|(
name|cp
operator|>
name|eom
condition|)
block|{
name|formerrmsg
operator|=
name|outofDataQuery
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
if|if
condition|(
name|qp
operator|->
name|q_msg
operator|&&
name|qp
operator|->
name|q_msglen
operator|&&
operator|!
name|res_nameinquery
argument_list|(
name|qname
argument_list|,
name|qtype
argument_list|,
name|qclass
argument_list|,
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msg
operator|+
name|qp
operator|->
name|q_msglen
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"query section mismatch (%s %s %s)"
argument_list|,
name|qname
argument_list|,
name|p_class
argument_list|(
name|qclass
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|qtype
argument_list|)
argument_list|)
expr_stmt|;
name|formerrmsg
operator|=
name|msgbuf
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
if|if
condition|(
name|strcasecmp
argument_list|(
name|qp
operator|->
name|q_name
argument_list|,
name|qname
argument_list|)
operator|!=
literal|0
operator|||
name|qp
operator|->
name|q_class
operator|!=
name|qclass
operator|||
name|qp
operator|->
name|q_type
operator|!=
name|qtype
condition|)
block|{
name|formerrmsg
operator|=
name|wrongQuestion
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
block|}
else|else
block|{
name|strcpy
argument_list|(
name|qname
argument_list|,
name|qp
operator|->
name|q_name
argument_list|)
expr_stmt|;
name|qclass
operator|=
name|qp
operator|->
name|q_class
expr_stmt|;
name|qtype
operator|=
name|qp
operator|->
name|q_type
expr_stmt|;
block|}
comment|/* cp now points after the query section. */
comment|/* 	 *  Here we handle bad responses from servers. 	 *  Several possibilities come to mind: 	 *	The server is sick and returns SERVFAIL 	 *	The server returns some garbage opcode (it's sick) 	 *	The server can't understand our query and return FORMERR 	 *  In all these cases, we drop the packet, disable retries on 	 *  this server and immediately force a retry. 	 */
if|if
condition|(
operator|(
name|hp
operator|->
name|rcode
operator|!=
name|NOERROR
operator|&&
name|hp
operator|->
name|rcode
operator|!=
name|NXDOMAIN
operator|)
operator|||
operator|(
name|hp
operator|->
name|opcode
operator|!=
name|QUERY
ifdef|#
directive|ifdef
name|BIND_NOTIFY
operator|&&
name|hp
operator|->
name|opcode
operator|!=
name|NS_NOTIFY_OP
endif|#
directive|endif
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: error (ret %d, op %d), dropped\n"
operator|,
name|hp
operator|->
name|rcode
operator|,
name|hp
operator|->
name|opcode
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hp
operator|->
name|rcode
condition|)
block|{
case|case
name|SERVFAIL
case|:
name|nameserIncr
argument_list|(
name|from_addr
operator|.
name|sin_addr
argument_list|,
name|nssRcvdFail
argument_list|)
expr_stmt|;
break|break;
case|case
name|FORMERR
case|:
name|nameserIncr
argument_list|(
name|from_addr
operator|.
name|sin_addr
argument_list|,
name|nssRcvdFErr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|nameserIncr
argument_list|(
name|from_addr
operator|.
name|sin_addr
argument_list|,
name|nssRcvdErr
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* mark server as bad */
if|if
condition|(
operator|!
name|qp
operator|->
name|q_fwd
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|qp
operator|->
name|q_naddr
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns_addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|from_addr
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|nretry
operator|=
name|MAXRETRY
expr_stmt|;
comment|/* 		 * XXX:	doesn't handle responses sent from the wrong 		 *	interface on a multihomed server. 		 */
if|if
condition|(
name|qp
operator|->
name|q_fwd
operator|||
name|qp
operator|->
name|q_addr
index|[
name|qp
operator|->
name|q_curaddr
index|]
operator|.
name|ns_addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|from_addr
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
name|retry
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|qdcount
operator|!=
literal|1
condition|)
block|{
comment|/* We don't generate or forward these (yet). */
name|formerrmsg
operator|=
name|notSingleQuery
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
comment|/* 	 * Determine if the response came from a forwarder.  Packets from 	 * anyplace not listed as a forwarder or as a server to whom we 	 * might have forwarded the query will be dropped. 	 */
for|for
control|(
name|fwd
operator|=
name|fwdtab
init|;
name|fwd
operator|!=
operator|(
expr|struct
name|fwdinfo
operator|*
operator|)
name|NULL
condition|;
name|fwd
operator|=
name|fwd
operator|->
name|next
control|)
block|{
if|if
condition|(
name|fwd
operator|->
name|fwdaddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|from_addr
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
comment|/* XXX - should put this in STATS somewhere. */
break|break;
block|}
block|}
comment|/* 	 * XXX:	note bad ambiguity here.  if one of our forwarders is also 	 *	a delegated server for some domain, then we will not update 	 *	the RTT information on any replies we get from those servers. 	 *	Workaround: disable recursion on authoritative servers so that 	 *	the ambiguity does not arise. 	 */
comment|/* 	 * If we weren't using a forwarder, find the qinfo pointer and update 	 * the rtt and fact that we have called on this server before. 	 */
if|if
condition|(
name|fwd
operator|==
operator|(
expr|struct
name|fwdinfo
operator|*
operator|)
name|NULL
condition|)
block|{
name|struct
name|timeval
modifier|*
name|stp
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|qs
operator|=
name|qp
operator|->
name|q_addr
init|;
operator|(
name|u_int
operator|)
name|n
operator|<
name|qp
operator|->
name|q_naddr
condition|;
name|n
operator|++
operator|,
name|qs
operator|++
control|)
if|if
condition|(
name|qs
operator|->
name|ns_addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|from_addr
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
break|break;
if|if
condition|(
operator|(
name|u_int
operator|)
name|n
operator|>=
name|qp
operator|->
name|q_naddr
condition|)
block|{
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
operator|(
name|char
operator|*
operator|)
name|from_addr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
literal|"unexpected source"
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Response from unexpected source (%s)"
argument_list|,
name|sin_ntoa
argument_list|(
operator|&
name|from_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*  			 * We don't know who this response came from so it 			 * gets dropped on the floor. 			 */
return|return;
block|}
name|stp
operator|=
operator|&
name|qs
operator|->
name|stime
expr_stmt|;
comment|/* Handle response from different (untried) interface */
if|if
condition|(
operator|(
name|qs
operator|->
name|ns
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|stp
operator|->
name|tv_sec
operator|==
literal|0
operator|)
condition|)
block|{
name|ns
operator|=
name|qs
operator|->
name|ns
expr_stmt|;
while|while
condition|(
name|qs
operator|>
name|qp
operator|->
name|q_addr
operator|&&
operator|(
name|qs
operator|->
name|stime
operator|.
name|tv_sec
operator|==
literal|0
operator|||
name|qs
operator|->
name|ns
operator|!=
name|ns
operator|)
condition|)
name|qs
operator|--
expr_stmt|;
operator|*
name|stp
operator|=
name|qs
operator|->
name|stime
expr_stmt|;
comment|/* XXX - sometimes stp still ends up pointing to 			 * a zero timeval, in spite of the above attempt. 			 * Why?  What should we do about it? 			 */
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"Response from unused address %s, assuming %s\n"
operator|,
name|sin_ntoa
argument_list|(
operator|&
name|from_addr
argument_list|)
operator|,
name|sin_ntoa
argument_list|(
operator|&
name|qs
operator|->
name|ns_addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX - catch aliases here */
block|}
comment|/* compute query round trip time */
comment|/* XXX - avoid integer overflow, which is quite likely if stp 		 * points to a zero timeval (see above). 		 * rtrip is of type time_t, which we assume is at least 		 * as big as an int. 		 */
if|if
condition|(
operator|(
name|tt
operator|.
name|tv_sec
operator|-
name|stp
operator|->
name|tv_sec
operator|)
operator|>
operator|(
name|INT_MAX
operator|-
literal|999
operator|)
operator|/
literal|1000
condition|)
block|{
name|rtrip
operator|=
name|INT_MAX
expr_stmt|;
block|}
else|else
block|{
name|rtrip
operator|=
operator|(
operator|(
name|tt
operator|.
name|tv_sec
operator|-
name|stp
operator|->
name|tv_sec
operator|)
operator|*
literal|1000
operator|+
operator|(
name|tt
operator|.
name|tv_usec
operator|-
name|stp
operator|->
name|tv_usec
operator|)
operator|/
literal|1000
operator|)
expr_stmt|;
block|}
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"stime %lu/%lu  now %lu/%lu rtt %ld\n"
operator|,
operator|(
name|u_long
operator|)
name|stp
operator|->
name|tv_sec
operator|,
operator|(
name|u_long
operator|)
name|stp
operator|->
name|tv_usec
operator|,
operator|(
name|u_long
operator|)
name|tt
operator|.
name|tv_sec
operator|,
operator|(
name|u_long
operator|)
name|tt
operator|.
name|tv_usec
operator|,
operator|(
name|long
operator|)
name|rtrip
operator|)
argument_list|)
expr_stmt|;
comment|/* prevent floating point overflow, limit to 1000 sec */
if|if
condition|(
name|rtrip
operator|>
literal|1000000
condition|)
block|{
name|rtrip
operator|=
literal|1000000
expr_stmt|;
block|}
name|ns
operator|=
name|qs
operator|->
name|nsdata
expr_stmt|;
comment|/* 		 * Don't update nstime if this doesn't look 		 * like an address databuf now.			XXX 		 */
if|if
condition|(
name|ns
operator|&&
name|ns
operator|->
name|d_type
operator|==
name|T_A
operator|&&
name|ns
operator|->
name|d_class
operator|==
name|qs
operator|->
name|ns
operator|->
name|d_class
condition|)
block|{
name|u_long
name|t
decl_stmt|;
if|if
condition|(
name|ns
operator|->
name|d_nstime
operator|==
literal|0
condition|)
name|t
operator|=
name|rtrip
expr_stmt|;
else|else
name|t
operator|=
name|ns
operator|->
name|d_nstime
operator|*
name|ALPHA
operator|+
operator|(
literal|1
operator|-
name|ALPHA
operator|)
operator|*
name|rtrip
expr_stmt|;
if|if
condition|(
name|t
operator|>
literal|65535
condition|)
name|t
operator|=
literal|65535
expr_stmt|;
name|ns
operator|->
name|d_nstime
operator|=
operator|(
name|u_int16_t
operator|)
name|t
expr_stmt|;
block|}
comment|/* 		 * Record the source so that we do not use this NS again. 		 */
if|if
condition|(
name|ns
operator|&&
name|qs
operator|->
name|ns
operator|&&
operator|(
name|qp
operator|->
name|q_nusedns
operator|<
name|NSMAX
operator|)
condition|)
block|{
name|qp
operator|->
name|q_usedns
index|[
name|qp
operator|->
name|q_nusedns
operator|++
index|]
operator|=
name|qs
operator|->
name|ns
expr_stmt|;
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"NS #%d addr %s used, rtt %d\n"
operator|,
name|n
operator|,
name|sin_ntoa
argument_list|(
operator|&
name|qs
operator|->
name|ns_addr
argument_list|)
operator|,
name|ns
operator|->
name|d_nstime
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Penalize those who had earlier chances but failed 		 * by multiplying round-trip times by BETA (>1). 		 * Improve nstime for unused addresses by applying GAMMA. 		 * The GAMMA factor makes unused entries slowly 		 * improve, so they eventually get tried again. 		 * GAMMA should be slightly less than 1. 		 * Watch out for records that may have timed out 		 * and are no longer the correct type.			XXX 		 */
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|qs
operator|=
name|qp
operator|->
name|q_addr
init|;
operator|(
name|u_int
operator|)
name|n
operator|<
name|qp
operator|->
name|q_naddr
condition|;
name|n
operator|++
operator|,
name|qs
operator|++
control|)
block|{
name|u_long
name|t
decl_stmt|;
name|ns2
operator|=
name|qs
operator|->
name|nsdata
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|ns2
operator|)
operator|||
operator|(
name|ns2
operator|==
name|ns
operator|)
condition|)
continue|continue;
if|if
condition|(
name|ns2
operator|->
name|d_type
operator|!=
name|T_A
operator|||
name|ns2
operator|->
name|d_class
operator|!=
name|qs
operator|->
name|ns
operator|->
name|d_class
condition|)
comment|/* XXX */
continue|continue;
if|if
condition|(
name|qs
operator|->
name|stime
operator|.
name|tv_sec
condition|)
block|{
if|if
condition|(
name|ns2
operator|->
name|d_nstime
operator|==
literal|0
condition|)
name|t
operator|=
operator|(
name|rtrip
operator|*
name|BETA
operator|)
expr_stmt|;
else|else
name|t
operator|=
name|ns2
operator|->
name|d_nstime
operator|*
name|BETA
operator|+
operator|(
literal|1
operator|-
name|ALPHA
operator|)
operator|*
name|rtrip
expr_stmt|;
block|}
else|else
name|t
operator|=
name|ns2
operator|->
name|d_nstime
operator|*
name|GAMMA
expr_stmt|;
if|if
condition|(
name|t
operator|>
literal|65535
condition|)
name|t
operator|=
literal|65535
expr_stmt|;
name|ns2
operator|->
name|d_nstime
operator|=
operator|(
name|u_int16_t
operator|)
name|t
expr_stmt|;
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"NS #%d %s rtt now %d\n"
operator|,
name|n
operator|,
name|sin_ntoa
argument_list|(
operator|&
name|qs
operator|->
name|ns_addr
argument_list|)
operator|,
name|ns2
operator|->
name|d_nstime
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|BIND_NOTIFY
comment|/* for now, NOTIFY isn't defined for ANCOUNT!=0, AUCOUNT!=0, 	 * or ADCOUNT!=0.  therefore the only real work to be done for 	 * a NOTIFY-QR is to remove it from the query queue. 	 */
if|if
condition|(
name|hp
operator|->
name|opcode
operator|==
name|NS_NOTIFY_OP
condition|)
block|{
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LAME_DELEGATION
comment|/* 	 *  Non-authoritative, no answer, no error, with referral. 	 */
if|if
condition|(
name|hp
operator|->
name|rcode
operator|==
name|NOERROR
operator|&&
operator|!
name|hp
operator|->
name|aa
operator|&&
name|ancount
operator|==
literal|0
operator|&&
name|aucount
operator|>
literal|0
ifdef|#
directive|ifdef
name|BIND_NOTIFY
operator|&&
name|hp
operator|->
name|opcode
operator|!=
name|NS_NOTIFY_OP
endif|#
directive|endif
condition|)
block|{
name|u_char
modifier|*
name|tp
decl_stmt|;
name|int
name|type
decl_stmt|,
name|class
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|0
condition|)
name|fp_nquery
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Since there is no answer section (ancount == 0), 		 * we must be pointing at the authority section (aucount> 0). 		 */
name|tp
operator|=
name|cp
expr_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|tp
argument_list|,
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|formerrmsg
operator|=
name|expandFailedAuth
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|tp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|tp
operator|+
literal|2
operator|*
name|INT16SZ
operator|>
name|eom
condition|)
block|{
name|formerrmsg
operator|=
name|outofDataAuth
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|response_trans
argument_list|,
name|ns_ownercontext
argument_list|(
name|type
argument_list|,
name|response_trans
argument_list|)
argument_list|,
name|name
argument_list|,
name|from_addr
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|formerrmsg
operator|=
name|badNameFound
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
comment|/* 		 * If the answer delegates us either to the same level in 		 * the hierarchy or closer to the root, we consider this 		 * server lame.  Note that for now we only log the message 		 * if the T_NS was C_IN, which is technically wrong (NS is 		 * visible in all classes) but necessary anyway (non-IN 		 * classes tend to not have good strong delegation graphs). 		 */
if|if
condition|(
name|type
operator|==
name|T_NS
operator|&&
name|samedomain
argument_list|(
name|qp
operator|->
name|q_domain
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|nameserIncr
argument_list|(
name|from_addr
operator|.
name|sin_addr
argument_list|,
name|nssRcvdLDel
argument_list|)
expr_stmt|;
comment|/* mark server as bad */
if|if
condition|(
operator|!
name|qp
operator|->
name|q_fwd
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|qp
operator|->
name|q_naddr
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns_addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|from_addr
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|nretry
operator|=
name|MAXRETRY
expr_stmt|;
ifdef|#
directive|ifdef
name|LAME_LOGGING
if|if
condition|(
name|class
operator|==
name|C_IN
operator|&&
operator|!
name|haveComplained
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nhash
argument_list|(
name|sin_ntoa
argument_list|(
operator|&
name|from_addr
argument_list|)
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nhash
argument_list|(
name|qp
operator|->
name|q_domain
argument_list|)
argument_list|)
condition|)
name|syslog
argument_list|(
name|LAME_LOGGING
argument_list|,
literal|"Lame server on '%s' (in '%s'?): %s%s\n"
argument_list|,
name|qname
argument_list|,
name|qp
operator|->
name|q_domain
argument_list|,
name|sin_ntoa
argument_list|(
operator|&
name|from_addr
argument_list|)
argument_list|,
name|learntFrom
argument_list|(
name|qp
argument_list|,
operator|&
name|from_addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LAME_LOGGING */
comment|/* XXX - doesn't handle responses sent from the wrong 			 * interface on a multihomed server 			 */
if|if
condition|(
name|qp
operator|->
name|q_fwd
operator|||
name|qp
operator|->
name|q_addr
index|[
name|qp
operator|->
name|q_curaddr
index|]
operator|.
name|ns_addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|from_addr
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
name|retry
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* LAME_DELEGATION */
if|if
condition|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_ZSERIAL
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|aa
operator|&&
name|ancount
operator|>
literal|0
operator|&&
name|hp
operator|->
name|rcode
operator|==
name|NOERROR
operator|&&
name|qtype
operator|==
name|T_SOA
operator|&&
operator|(
operator|(
name|qclass
operator|==
name|C_IN
operator|)
operator|||
operator|(
name|qclass
operator|==
name|C_HS
operator|)
operator|)
condition|)
block|{
name|int
name|n
decl_stmt|;
name|u_int16_t
name|type
decl_stmt|,
name|class
decl_stmt|,
name|dlen
decl_stmt|;
name|u_int32_t
name|serial
decl_stmt|;
name|u_char
modifier|*
name|tp
init|=
name|cp
decl_stmt|;
name|u_char
modifier|*
name|rdatap
decl_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|tp
argument_list|,
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|formerrmsg
operator|=
name|expandFailedAnswer
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|tp
operator|+=
name|n
expr_stmt|;
comment|/* name */
if|if
condition|(
name|tp
operator|+
literal|3
operator|*
name|INT16SZ
operator|+
name|INT32SZ
operator|>
name|eom
condition|)
block|{
name|formerrmsg
operator|=
name|outofDataAnswer
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|tp
argument_list|)
expr_stmt|;
comment|/* type */
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|tp
argument_list|)
expr_stmt|;
comment|/* class */
name|tp
operator|+=
name|INT32SZ
expr_stmt|;
comment|/* ttl */
name|GETSHORT
argument_list|(
name|dlen
argument_list|,
name|tp
argument_list|)
expr_stmt|;
comment|/* dlen */
name|rdatap
operator|=
name|tp
expr_stmt|;
comment|/* start of rdata */
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|response_trans
argument_list|,
name|ns_ownercontext
argument_list|(
name|type
argument_list|,
name|response_trans
argument_list|)
argument_list|,
name|name
argument_list|,
name|from_addr
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|formerrmsg
operator|=
name|badNameFound
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
if|if
condition|(
name|strcasecmp
argument_list|(
name|qname
argument_list|,
name|name
argument_list|)
operator|||
name|qtype
operator|!=
name|type
operator|||
name|qclass
operator|!=
name|class
condition|)
block|{
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"qserial answer mismatch (%s %s %s)"
argument_list|,
name|name
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|formerrmsg
operator|=
name|msgbuf
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
if|if
condition|(
literal|0
operator|>=
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
name|tp
argument_list|,
name|eom
argument_list|)
operator|)
condition|)
block|{
name|formerrmsg
operator|=
name|skipnameFailedAnswer
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|tp
operator|+=
name|n
expr_stmt|;
comment|/* mname */
if|if
condition|(
literal|0
operator|>=
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
name|tp
argument_list|,
name|eom
argument_list|)
operator|)
condition|)
block|{
name|formerrmsg
operator|=
name|skipnameFailedAnswer
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|tp
operator|+=
name|n
expr_stmt|;
comment|/* rname */
if|if
condition|(
name|tp
operator|+
literal|5
operator|*
name|INT32SZ
operator|>
name|eom
condition|)
block|{
name|formerrmsg
operator|=
name|dlenUnderrunAnswer
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|GETLONG
argument_list|(
name|serial
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|+=
literal|4
operator|*
name|INT32SZ
expr_stmt|;
comment|/* Skip rest of SOA. */
if|if
condition|(
call|(
name|u_int
call|)
argument_list|(
name|tp
operator|-
name|rdatap
argument_list|)
operator|!=
name|dlen
condition|)
block|{
name|formerrmsg
operator|=
name|dlenOverrunAnswer
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|qserial_answer
argument_list|(
name|qp
argument_list|,
name|serial
argument_list|)
expr_stmt|;
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retry
argument_list|(
name|qp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* 	 * Add the info received in the response to the data base. 	 */
name|arfirst
operator|=
name|ancount
operator|+
name|aucount
expr_stmt|;
name|c
operator|=
name|arfirst
operator|+
name|arcount
expr_stmt|;
comment|/* -ve $ing non-existence of record, must handle non-authoritative 	 * NOERRORs with c == 0. 	 */
if|if
condition|(
operator|!
name|hp
operator|->
name|aa
operator|&&
name|hp
operator|->
name|rcode
operator|==
name|NOERROR
operator|&&
name|c
operator|==
literal|0
condition|)
goto|goto
name|return_msg
goto|;
ifdef|#
directive|ifdef
name|notdef
comment|/* 	 * If the request was for a CNAME that doesn't exist, 	 * but the name is valid, fetch any other data for the name. 	 * DON'T do this now, as it will requery if data are already 	 * in the cache (maybe later with negative caching). 	 */
if|if
condition|(
name|type
operator|==
name|T_CNAME
operator|&&
name|c
operator|==
literal|0
operator|&&
name|hp
operator|->
name|rcode
operator|==
name|NOERROR
operator|&&
operator|!
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_SYSTEM
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|4
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: leaving, no CNAME\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Cause us to put it in the cache later */
name|prime
argument_list|(
name|class
argument_list|,
name|T_ANY
argument_list|,
name|qp
argument_list|)
expr_stmt|;
comment|/* Nothing to store, just give user the answer */
goto|goto
name|return_msg
goto|;
block|}
endif|#
directive|endif
comment|/* notdef */
if|if
condition|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_SYSTEM
condition|)
name|dbflags
operator|=
name|DB_NOTAUTH
operator||
name|DB_NODATA
expr_stmt|;
else|else
name|dbflags
operator|=
name|DB_NOTAUTH
operator||
name|DB_NODATA
operator||
name|DB_NOHINTS
expr_stmt|;
name|count
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_PRIMING
condition|)
name|dbflags
operator||=
name|DB_PRIMING
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|tc
condition|)
block|{
name|count
operator|-=
name|arcount
expr_stmt|;
comment|/* truncation had to affect this */
if|if
condition|(
operator|!
name|arcount
condition|)
block|{
name|count
operator|-=
name|aucount
expr_stmt|;
comment|/* guess it got this too */
block|}
if|if
condition|(
operator|!
operator|(
name|arcount
operator|||
name|aucount
operator|)
condition|)
block|{
name|count
operator|-=
name|ancount
expr_stmt|;
comment|/* things are pretty grim */
block|}
comment|/* XXX - should retry this query with TCP */
comment|/* 		 * XXX - if this response is forwarded to the client 		 * the truncated section is included.  We will not 		 * validate it, and if it somehow corrupt, we won't 		 * notice. 		 * 		 * XXX - if the answer section is truncated and we got 		 * this response after being redirected by a CNAME, we 		 * will not include any part of the final answer in our 		 * response to the client.  This will make the client 		 * think that there are no RRs of the appropriate type. 		 */
block|}
name|tp
operator|=
name|cp
expr_stmt|;
name|restart
operator|=
literal|0
expr_stmt|;
name|validanswer
operator|=
literal|0
expr_stmt|;
name|nscount
operator|=
literal|0
expr_stmt|;
name|cname
operator|=
literal|0
expr_stmt|;
name|lastwascname
operator|=
literal|0
expr_stmt|;
name|externalcname
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|aname
argument_list|,
name|qname
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
condition|)
block|{
comment|/* allocate 1 extra record for end of set detection */
name|flushset
operator|=
operator|(
expr|struct
name|flush_set
operator|*
operator|)
name|calloc
argument_list|(
name|count
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|flush_set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flushset
condition|)
name|panic
argument_list|(
operator|-
literal|1
argument_list|,
literal|"flushset: out of memory"
argument_list|)
expr_stmt|;
block|}
else|else
name|flushset
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|int
name|type
decl_stmt|;
name|maybe_free
argument_list|(
operator|&
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|>=
name|eom
condition|)
block|{
name|free_related_additional
argument_list|()
expr_stmt|;
if|if
condition|(
name|flushset
operator|!=
name|NULL
condition|)
name|free_flushset
argument_list|(
name|flushset
argument_list|)
expr_stmt|;
name|formerrmsg
operator|=
name|outofDataFinal
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|n
operator|=
name|rrextract
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|,
name|cp
argument_list|,
operator|&
name|dp
argument_list|,
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|free_related_additional
argument_list|()
expr_stmt|;
name|maybe_free
argument_list|(
operator|&
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|flushset
operator|!=
name|NULL
condition|)
name|free_flushset
argument_list|(
name|flushset
argument_list|)
expr_stmt|;
name|formerrmsg
operator|=
name|outofDataFinal
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
operator|!
name|dp
condition|)
continue|continue;
name|type
operator|=
name|dp
operator|->
name|d_type
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|ancount
condition|)
block|{
comment|/* Answer section. */
if|if
condition|(
name|externalcname
operator|||
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|aname
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|externalcname
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"wrong ans. name (%s != %s)"
argument_list|,
name|name
argument_list|,
name|aname
argument_list|)
expr_stmt|;
else|else
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"ignoring answer '%s' after external cname\n"
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|db_free
argument_list|(
name|dp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|type
operator|==
name|T_CNAME
operator|&&
name|qtype
operator|!=
name|T_CNAME
operator|&&
name|qtype
operator|!=
name|T_ANY
condition|)
block|{
name|strcpy
argument_list|(
name|aname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|samedomain
argument_list|(
name|aname
argument_list|,
name|qp
operator|->
name|q_domain
argument_list|)
condition|)
name|externalcname
operator|=
literal|1
expr_stmt|;
name|cname
operator|=
literal|1
expr_stmt|;
name|lastwascname
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|validanswer
operator|=
literal|1
expr_stmt|;
name|lastwascname
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tname
operator|!=
name|NULL
condition|)
block|{
name|add_related_additional
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|tname
operator|=
name|NULL
expr_stmt|;
block|}
name|dp
operator|->
name|d_cred
operator|=
operator|(
name|hp
operator|->
name|aa
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|qname
argument_list|)
operator|)
condition|?
name|DB_C_AUTH
else|:
name|DB_C_ANSWER
expr_stmt|;
block|}
else|else
block|{
comment|/* After answer section. */
if|if
condition|(
name|lastwascname
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"last was cname, ignoring auth. and add.\n"
operator|)
argument_list|)
expr_stmt|;
name|db_free
argument_list|(
name|dp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|arfirst
condition|)
block|{
comment|/* Authority section. */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_NS
case|:
case|case
name|T_SOA
case|:
if|if
condition|(
operator|!
name|samedomain
argument_list|(
name|aname
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"bad referral (%s !< %s)"
argument_list|,
name|aname
index|[
literal|0
index|]
condition|?
name|aname
else|:
literal|"."
argument_list|,
name|name
index|[
literal|0
index|]
condition|?
name|name
else|:
literal|"."
argument_list|)
expr_stmt|;
name|db_free
argument_list|(
name|dp
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|samedomain
argument_list|(
name|name
argument_list|,
name|qp
operator|->
name|q_domain
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|externalcname
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"bad referral (%s !< %s)"
argument_list|,
name|name
index|[
literal|0
index|]
condition|?
name|name
else|:
literal|"."
argument_list|,
name|qp
operator|->
name|q_domain
index|[
literal|0
index|]
condition|?
name|qp
operator|->
name|q_domain
else|:
literal|"."
argument_list|)
expr_stmt|;
name|db_free
argument_list|(
name|dp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|type
operator|==
name|T_NS
condition|)
block|{
name|nscount
operator|++
expr_stmt|;
name|add_related_additional
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|tname
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|T_NXT
case|:
case|case
name|T_SIG
case|:
break|break;
default|default:
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"invalid RR type '%s' in authority section (name = '%s') from %s"
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|name
argument_list|,
name|sin_ntoa
argument_list|(
operator|&
name|from_addr
argument_list|)
argument_list|)
expr_stmt|;
name|db_free
argument_list|(
name|dp
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
comment|/* Additional section. */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
case|case
name|T_AAAA
case|:
if|if
condition|(
name|externalcname
operator|||
operator|!
name|samedomain
argument_list|(
name|name
argument_list|,
name|qp
operator|->
name|q_domain
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"ignoring additional info '%s' type %s\n"
operator|,
name|name
operator|,
name|p_type
argument_list|(
name|type
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|db_free
argument_list|(
name|dp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|related_additional
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"unrelated additional info '%s' type %s from %s"
argument_list|,
name|name
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|sin_ntoa
argument_list|(
operator|&
name|from_addr
argument_list|)
argument_list|)
expr_stmt|;
name|db_free
argument_list|(
name|dp
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|T_KEY
case|:
case|case
name|T_SIG
case|:
break|break;
default|default:
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"invalid RR type '%s' in additional section (name = '%s') from %s"
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|name
argument_list|,
name|sin_ntoa
argument_list|(
operator|&
name|from_addr
argument_list|)
argument_list|)
expr_stmt|;
name|db_free
argument_list|(
name|dp
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|dp
operator|->
name|d_cred
operator|=
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_PRIMING
operator|)
condition|?
name|DB_C_ANSWER
else|:
name|DB_C_ADDITIONAL
expr_stmt|;
block|}
name|rrsetadd
argument_list|(
name|flushset
argument_list|,
name|name
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
name|free_related_additional
argument_list|()
expr_stmt|;
name|maybe_free
argument_list|(
operator|&
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|flushset
condition|)
block|{
name|rrsetupdate
argument_list|(
name|flushset
argument_list|,
name|dbflags
argument_list|)
expr_stmt|;
name|free_flushset
argument_list|(
name|flushset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lastwascname
operator|&&
operator|!
name|externalcname
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s (%s)"
argument_list|,
name|danglingCname
argument_list|,
name|aname
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|>
name|eom
condition|)
block|{
name|formerrmsg
operator|=
name|outofDataAFinal
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
if|if
condition|(
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_SYSTEM
operator|)
operator|&&
name|ancount
condition|)
block|{
if|if
condition|(
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_PRIMING
operator|)
operator|&&
operator|!
name|check_root
argument_list|()
condition|)
block|{
comment|/* mark server as bad */
if|if
condition|(
operator|!
name|qp
operator|->
name|q_fwd
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|qp
operator|->
name|q_naddr
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns_addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|from_addr
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|nretry
operator|=
name|MAXRETRY
expr_stmt|;
comment|/* XXX - doesn't handle responses sent from 			* the wronginterface on a multihomed server 		 	*/
if|if
condition|(
name|qp
operator|->
name|q_fwd
operator|||
name|qp
operator|->
name|q_addr
index|[
name|qp
operator|->
name|q_curaddr
index|]
operator|.
name|ns_addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|from_addr
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
name|retry
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return;
block|}
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: leaving, SYSQUERY ancount %d\n"
operator|,
name|ancount
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND_NOTIFY
if|if
condition|(
name|qp
operator|->
name|q_notifyzone
operator|!=
name|DB_Z_CACHE
condition|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
init|=
operator|&
name|zones
index|[
name|qp
operator|->
name|q_notifyzone
index|]
decl_stmt|;
comment|/* 			 * Clear this first since sysnotify() might set it. 			 */
name|qp
operator|->
name|q_notifyzone
operator|=
name|DB_Z_CACHE
expr_stmt|;
name|sysnotify
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|zp
operator|->
name|z_class
argument_list|,
name|T_SOA
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ancount
operator|&&
name|count
operator|&&
operator|!
name|validanswer
condition|)
comment|/* 		 * Everything passed validation but we didn't get the 		 * final answer.  The response must have contained 		 * a dangling CNAME.  Force a restart of the query. 		 * 		 * Don't set restart if count==0, since this means 		 * the response was truncated in the answer section, 	         * causing us to set count to 0 which will cause 		 * validanswer to be 0 as well even though the answer 		 * section probably contained valid RRs (just not 		 * a complete set). 		 * XXX - this works right if we can just forward this 		 * response to the client, but not if we found a CNAME 		 * in a prior response and restarted the query. 		 */
name|restart
operator|=
literal|1
expr_stmt|;
comment|/* 	 *  If there are addresses and this is a local query, 	 *  sort them appropriately for the local context. 	 */
ifdef|#
directive|ifdef
name|SORT_RESPONSE
if|if
condition|(
operator|!
name|restart
operator|&&
name|ancount
operator|>
literal|1
operator|&&
operator|(
name|lp
operator|=
name|local
argument_list|(
operator|&
name|qp
operator|->
name|q_from
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|sort_response
argument_list|(
name|tp
argument_list|,
name|ancount
argument_list|,
name|lp
argument_list|,
name|eom
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * An answer to a T_ANY query or a successful answer to a 	 * regular query with no indirection, then just return answer. 	 */
if|if
condition|(
operator|!
name|restart
operator|&&
name|ancount
operator|&&
operator|(
name|qtype
operator|==
name|T_ANY
operator|||
operator|!
name|qp
operator|->
name|q_cmsglen
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: got as much answer as there is\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|return_msg
goto|;
block|}
comment|/* 	 * We might want to cache this negative answer. 	 */
if|if
condition|(
operator|!
name|ancount
operator|&&
operator|(
operator|!
name|nscount
operator|||
name|hp
operator|->
name|rcode
operator|==
name|NXDOMAIN
operator|)
operator|&&
operator|(
name|hp
operator|->
name|aa
operator|||
name|fwd
operator|||
name|qclass
operator|==
name|C_ANY
operator|)
condition|)
block|{
comment|/* we have an authoritative NO */
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: leaving auth NO\n"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NCACHE
comment|/* answer was NO */
if|if
condition|(
name|hp
operator|->
name|aa
operator|&&
operator|(
operator|(
name|hp
operator|->
name|rcode
operator|==
name|NXDOMAIN
operator|)
operator|||
operator|(
name|hp
operator|->
name|rcode
operator|==
name|NOERROR
operator|)
operator|)
condition|)
block|{
name|cache_n_resp
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*NCACHE*/
if|if
condition|(
name|qp
operator|->
name|q_cmsglen
condition|)
block|{
comment|/* XXX - what about additional CNAMEs in the chain? */
name|msg
operator|=
name|qp
operator|->
name|q_cmsg
expr_stmt|;
name|msglen
operator|=
name|qp
operator|->
name|q_cmsglen
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
expr_stmt|;
block|}
goto|goto
name|return_msg
goto|;
block|}
comment|/* 	 * All messages in here need further processing.  i.e. they 	 * are either CNAMEs or we got referred again. 	 */
name|count
operator|=
literal|0
expr_stmt|;
name|founddata
operator|=
literal|0
expr_stmt|;
name|foundname
operator|=
literal|0
expr_stmt|;
name|dname
operator|=
name|name
expr_stmt|;
comment|/* 	 * Even with VALIDATE, if restart==0 and ancount> 0, we should 	 * have some valid data because because the data in the answer 	 * section is owned by the query name and that passes the 	 * validation test by definition 	 * 	 * XXX - the restart stuff doesn't work if any of the answer RRs 	 * is not cacheable (TTL==0 or unknown RR type), since all of the 	 * answer must pass through the cache and be re-assembled. 	 */
if|if
condition|(
operator|(
operator|!
name|restart
operator|||
operator|!
name|cname
operator|)
operator|&&
name|qp
operator|->
name|q_cmsglen
operator|&&
name|ancount
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"Cname second pass\n"
operator|)
argument_list|)
expr_stmt|;
name|newmsglen
operator|=
name|MIN
argument_list|(
name|PACKETSZ
argument_list|,
name|qp
operator|->
name|q_cmsglen
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|qp
operator|->
name|q_cmsg
argument_list|,
name|newmsg
argument_list|,
name|newmsglen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newmsglen
operator|=
name|MIN
argument_list|(
name|PACKETSZ
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|msg
argument_list|,
name|newmsg
argument_list|,
name|newmsglen
argument_list|)
expr_stmt|;
block|}
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|newmsg
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NOERROR
expr_stmt|;
name|dnptrs
index|[
literal|0
index|]
operator|=
name|newmsg
expr_stmt|;
name|dnptrs
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
name|newmsg
operator|+
name|HFIXEDSZ
expr_stmt|;
comment|/* 	 * Keep in mind that none of this code works when QDCOUNT>1. 	 * cp ends up pointed just past the query section in both cases. 	 */
comment|/* 	 * Arrange for dname to contain the query name. The query 	 * name can be either the original query name if restart==0 	 * or the target of the last CNAME if we are following a 	 * CNAME chain and were referred. 	 */
name|n
operator|=
name|dn_expand
argument_list|(
name|newmsg
argument_list|,
name|newmsg
operator|+
name|newmsglen
argument_list|,
name|cp
argument_list|,
name|dname
argument_list|,
sizeof|sizeof
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"dn_expand failed\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|servfail
goto|;
block|}
if|if
condition|(
operator|!
name|res_dnok
argument_list|(
name|dname
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"bad name (%s)\n"
operator|,
name|dname
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|servfail
goto|;
block|}
name|cp
operator|+=
name|n
operator|+
name|QFIXEDSZ
expr_stmt|;
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|newmsg
argument_list|)
operator|-
operator|(
name|cp
operator|-
name|newmsg
operator|)
expr_stmt|;
name|cname
operator|=
literal|0
expr_stmt|;
name|try_again
label|:
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: nlookup(%s) qtype=%d\n"
operator|,
name|dname
operator|,
name|qtype
operator|)
argument_list|)
expr_stmt|;
name|fname
operator|=
literal|""
expr_stmt|;
name|htp
operator|=
name|hashtab
expr_stmt|;
comment|/* lookup relative to root */
name|np
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: %s '%s' as '%s' (cname=%d)\n"
operator|,
name|np
operator|==
name|NULL
condition|?
literal|"missed"
else|:
literal|"found"
operator|,
name|dname
operator|,
name|fname
operator|,
name|cname
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
operator|||
name|fname
operator|!=
name|dname
condition|)
goto|goto
name|fetch_ns
goto|;
name|foundname
operator|++
expr_stmt|;
name|count
operator|=
name|cp
operator|-
name|newmsg
expr_stmt|;
name|n
operator|=
name|finddata
argument_list|(
name|np
argument_list|,
name|qclass
argument_list|,
name|qtype
argument_list|,
name|hp
argument_list|,
operator|&
name|dname
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
goto|goto
name|fetch_ns
goto|;
comment|/* NO data available */
ifdef|#
directive|ifdef
name|NCACHE
if|if
condition|(
name|hp
operator|->
name|rcode
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|rcode
operator|==
name|NOERROR_NODATA
condition|)
name|hp
operator|->
name|rcode
operator|=
name|NOERROR
expr_stmt|;
ifdef|#
directive|ifdef
name|RETURNSOA
if|if
condition|(
name|count
condition|)
block|{
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|count
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
goto|goto
name|return_newmsg
goto|;
block|}
endif|#
directive|endif
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
operator|+
operator|(
name|u_int16_t
operator|)
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|!=
name|dname
operator|&&
name|qtype
operator|!=
name|T_CNAME
operator|&&
name|qtype
operator|!=
name|T_ANY
condition|)
block|{
name|cname
operator|++
expr_stmt|;
goto|goto
name|try_again
goto|;
block|}
name|founddata
operator|=
literal|1
expr_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: foundname=%d, count=%d, founddata=%d, cname=%d\n"
operator|,
name|foundname
operator|,
name|count
operator|,
name|founddata
operator|,
name|cname
operator|)
argument_list|)
expr_stmt|;
name|fetch_ns
label|:
if|if
condition|(
name|hp
operator|->
name|tc
condition|)
goto|goto
name|return_newmsg
goto|;
comment|/*  	 * Look for name servers to refer to and fill in the authority  	 * section or record the address for forwarding the query  	 * (recursion desired).  	 */
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|findns
argument_list|(
operator|&
name|np
argument_list|,
name|qclass
argument_list|,
name|nsp
argument_list|,
operator|&
name|count
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
name|NXDOMAIN
case|:
comment|/* shouldn't happen */
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"req: leaving (%s, rcode %d)\n"
operator|,
name|dname
operator|,
name|hp
operator|->
name|rcode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|foundname
condition|)
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
if|if
condition|(
name|qclass
operator|!=
name|C_ANY
condition|)
block|{
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|np
operator|&&
operator|(
operator|!
name|foundname
operator|||
operator|!
name|founddata
operator|)
condition|)
block|{
name|n
operator|=
name|doaddauth
argument_list|(
name|hp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
name|np
argument_list|,
name|nsp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
block|}
block|}
goto|goto
name|return_newmsg
goto|;
case|case
name|SERVFAIL
case|:
goto|goto
name|servfail
goto|;
block|}
if|if
condition|(
name|founddata
condition|)
block|{
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|newmsg
expr_stmt|;
name|n
operator|=
name|add_data
argument_list|(
name|np
argument_list|,
name|nsp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
name|n
operator|=
operator|(
operator|-
name|n
operator|)
expr_stmt|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|count
argument_list|)
expr_stmt|;
goto|goto
name|return_newmsg
goto|;
block|}
comment|/* 	 *  If we get here, we don't have the answer yet and are about 	 *  to iterate to try and get it.  First, infinite loop avoidance. 	 */
if|if
condition|(
name|qp
operator|->
name|q_nqueries
operator|++
operator|>
name|MAXQUERIES
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: MAXQUERIES exceeded (%s %s %s)\n"
operator|,
name|dname
operator|,
name|p_class
argument_list|(
name|qclass
argument_list|)
operator|,
name|p_type
argument_list|(
name|qtype
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"MAXQUERIES exceeded, possible data loop in resolving (%s)"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
goto|goto
name|servfail
goto|;
block|}
comment|/* Reset the query control structure */
name|nsfree
argument_list|(
name|qp
argument_list|,
literal|"ns_resp"
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_naddr
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|q_curaddr
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|q_fwd
operator|=
name|fwdtab
expr_stmt|;
name|getname
argument_list|(
name|np
argument_list|,
name|tmpdomain
argument_list|,
sizeof|sizeof
name|tmpdomain
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_domain
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|qp
operator|->
name|q_domain
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_domain
operator|=
name|strdup
argument_list|(
name|tmpdomain
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_domain
operator|==
name|NULL
condition|)
name|panic
argument_list|(
name|ENOMEM
argument_list|,
literal|"ns_resp: strdup failed"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|nslookup
argument_list|(
name|nsp
argument_list|,
name|qp
argument_list|,
name|dname
argument_list|,
literal|"ns_resp"
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: nslookup reports danger\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cname
condition|)
comment|/* a remote CNAME that does not have data */
goto|goto
name|return_newmsg
goto|;
goto|goto
name|servfail
goto|;
block|}
else|else
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: no addrs found for NS's\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Timeout while sysquery looks up the NS addresses. 			 * 			 * Hopefully we'll have them when the client asks 			 * again. 			 * 			 * too bad we can't just wait for the sysquery 			 * response to restart this query (it's too hard). 			 * 			 * We could try to crawl back up the tree looking 			 * for reachable servers, but we may have just 			 * gotten delegated down here by a response with 			 * no A RRs for the servers.  If we blindly tried 			 * this strategy, we bang on the same server forever. 			 */
goto|goto
name|timeout
goto|;
block|}
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
operator|(
name|u_int
operator|)
name|n
operator|<
name|qp
operator|->
name|q_naddr
condition|;
name|n
operator|++
control|)
name|qp
operator|->
name|q_addr
index|[
name|n
index|]
operator|.
name|stime
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|qp
operator|->
name|q_fwd
condition|)
name|qp
operator|->
name|q_addr
index|[
literal|0
index|]
operator|.
name|stime
operator|=
name|tt
expr_stmt|;
if|if
condition|(
name|cname
condition|)
block|{
if|if
condition|(
name|qp
operator|->
name|q_cname
operator|++
operator|==
name|MAXCNAMES
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: leaving, MAXCNAMES exceeded\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|servfail
goto|;
block|}
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"q_cname = %d\n"
operator|,
name|qp
operator|->
name|q_cname
operator|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: building recursive query; nslookup\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qp
operator|->
name|q_cmsg
condition|)
block|{
name|qp
operator|->
name|q_cmsg
operator|=
name|qp
operator|->
name|q_msg
expr_stmt|;
name|qp
operator|->
name|q_cmsglen
operator|=
name|qp
operator|->
name|q_msglen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qp
operator|->
name|q_msg
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
name|qp
operator|->
name|q_msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|qp
operator|->
name|q_msg
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|PACKETSZ
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"resp: malloc error\n"
argument_list|)
expr_stmt|;
goto|goto
name|servfail
goto|;
block|}
name|n
operator|=
name|res_mkquery
argument_list|(
name|QUERY
argument_list|,
name|dname
argument_list|,
name|qclass
argument_list|,
name|qtype
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|qp
operator|->
name|q_msg
argument_list|,
name|PACKETSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"resp: res_mkquery(%s) failed"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
goto|goto
name|servfail
goto|;
block|}
if|if
condition|(
name|qp
operator|->
name|q_name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|qp
operator|->
name|q_name
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_name
operator|=
name|savestr
argument_list|(
name|dname
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_msglen
operator|=
name|n
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|qp
operator|->
name|q_msg
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|qp
operator|->
name|q_msg
expr_stmt|;
name|hp
operator|->
name|id
operator|=
name|qp
operator|->
name|q_nsid
operator|=
name|htons
argument_list|(
name|nsid_next
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_fwd
condition|)
name|hp
operator|->
name|rd
operator|=
literal|1
expr_stmt|;
name|unsched
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|schedretry
argument_list|(
name|qp
argument_list|,
name|retrytime
argument_list|(
name|qp
argument_list|)
argument_list|)
expr_stmt|;
name|nsa
operator|=
name|Q_NEXTADDR
argument_list|(
name|qp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: forw -> %s ds=%d nsid=%d id=%d %dms\n"
operator|,
name|sin_ntoa
argument_list|(
name|nsa
argument_list|)
operator|,
name|ds
operator|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_nsid
argument_list|)
operator|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_id
argument_list|)
operator|,
operator|(
name|qp
operator|->
name|q_addr
index|[
literal|0
index|]
operator|.
name|nsdata
operator|!=
name|NULL
operator|)
condition|?
name|qp
operator|->
name|q_addr
index|[
literal|0
index|]
operator|.
name|nsdata
operator|->
name|d_nstime
else|:
operator|(
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|10
condition|)
name|fp_nquery
argument_list|(
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sendto
argument_list|(
name|ds
argument_list|,
operator|(
name|char
operator|*
operator|)
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|nsa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nsa
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|sendtoStr
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"ns_resp: sendto(%s): %m"
argument_list|,
name|sin_ntoa
argument_list|(
name|nsa
argument_list|)
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|,
name|nssSendtoErr
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|rd
operator|=
literal|0
expr_stmt|;
comment|/* leave set to 0 for dup detection */
ifdef|#
directive|ifdef
name|XSTATS
name|nameserIncr
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|,
name|nssSentFwdR
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nameserIncr
argument_list|(
name|qp
operator|->
name|q_from
operator|.
name|sin_addr
argument_list|,
name|nssRcvdFwdR
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: Query sent.\n"
operator|)
argument_list|)
expr_stmt|;
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
return|return;
name|formerr
label|:
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
operator|(
name|char
operator|*
operator|)
name|from_addr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nhash
argument_list|(
name|formerrmsg
argument_list|)
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Malformed response from %s (%s)\n"
argument_list|,
name|sin_ntoa
argument_list|(
operator|&
name|from_addr
argument_list|)
argument_list|,
name|formerrmsg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XSTATS
name|nameserIncr
argument_list|(
name|from_addr
operator|.
name|sin_addr
argument_list|,
name|nssSentFErr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
return|return;
name|return_msg
label|:
name|nameserIncr
argument_list|(
name|from_addr
operator|.
name|sin_addr
argument_list|,
name|nssRcvdFwdR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XSTATS
name|nameserIncr
argument_list|(
name|qp
operator|->
name|q_from
operator|.
name|sin_addr
argument_list|,
name|nssSentFwdR
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* The "standard" return code */
name|hp
operator|->
name|qr
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|id
operator|=
name|qp
operator|->
name|q_id
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|ra
operator|=
operator|(
name|NoRecurse
operator|==
literal|0
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|send_msg
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
return|return;
name|return_newmsg
label|:
name|nameserIncr
argument_list|(
name|qp
operator|->
name|q_from
operator|.
name|sin_addr
argument_list|,
name|nssSentAns
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XSTATS
if|if
condition|(
operator|!
name|hp
operator|->
name|aa
condition|)
name|nameserIncr
argument_list|(
name|qp
operator|->
name|q_from
operator|.
name|sin_addr
argument_list|,
name|nssSentNaAns
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|rcode
operator|==
name|NXDOMAIN
condition|)
name|nameserIncr
argument_list|(
name|qp
operator|->
name|q_from
operator|.
name|sin_addr
argument_list|,
name|nssSentNXD
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|n
operator|=
name|doaddinfo
argument_list|(
name|hp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|hp
operator|->
name|qr
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|id
operator|=
name|qp
operator|->
name|q_id
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|ra
operator|=
operator|(
name|NoRecurse
operator|==
literal|0
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|send_msg
argument_list|(
name|newmsg
argument_list|,
name|cp
operator|-
name|newmsg
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
return|return;
name|servfail
label|:
ifdef|#
directive|ifdef
name|XSTATS
name|nameserIncr
argument_list|(
name|qp
operator|->
name|q_from
operator|.
name|sin_addr
argument_list|,
name|nssSentFail
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
operator|(
name|qp
operator|->
name|q_cmsglen
condition|?
name|qp
operator|->
name|q_cmsg
else|:
name|qp
operator|->
name|q_msg
operator|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
name|hp
operator|->
name|qr
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|id
operator|=
name|qp
operator|->
name|q_id
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|ra
operator|=
operator|(
name|NoRecurse
operator|==
literal|0
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|send_msg
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|hp
argument_list|,
operator|(
name|qp
operator|->
name|q_cmsglen
condition|?
name|qp
operator|->
name|q_cmsglen
else|:
name|qp
operator|->
name|q_msglen
operator|)
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|timeout
label|:
if|if
condition|(
name|qp
operator|->
name|q_stream
operator|!=
name|QSTREAM_NULL
condition|)
name|sqrm
argument_list|(
name|qp
operator|->
name|q_stream
argument_list|)
expr_stmt|;
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_define
define|#
directive|define
name|BOUNDS_CHECK
parameter_list|(
name|ptr
parameter_list|,
name|count
parameter_list|)
define|\
value|do { \ 		if ((ptr) + (count)> eom) { \ 			hp->rcode = FORMERR; \ 			return (-1); \ 		} \ 	} while (0)
end_define

begin_function
specifier|static
name|int
name|rrextract
parameter_list|(
name|msg
parameter_list|,
name|msglen
parameter_list|,
name|rrp
parameter_list|,
name|dpp
parameter_list|,
name|dname
parameter_list|,
name|namelen
parameter_list|,
name|tnamep
parameter_list|)
name|u_char
modifier|*
name|msg
decl_stmt|;
name|int
name|msglen
decl_stmt|;
name|u_char
modifier|*
name|rrp
decl_stmt|;
name|struct
name|databuf
modifier|*
modifier|*
name|dpp
decl_stmt|;
name|char
modifier|*
name|dname
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|char
modifier|*
modifier|*
name|tnamep
decl_stmt|;
block|{
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|eom
decl_stmt|,
modifier|*
name|rdatap
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|int
name|class
decl_stmt|,
name|type
decl_stmt|,
name|dlen
decl_stmt|,
name|n1
decl_stmt|;
name|u_int32_t
name|ttl
decl_stmt|;
name|u_char
modifier|*
name|cp1
decl_stmt|;
name|u_char
name|data
index|[
name|MAXDNAME
operator|*
literal|2
operator|+
name|INT32SZ
operator|*
literal|5
index|]
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|hp
init|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
decl_stmt|;
name|enum
name|context
name|context
decl_stmt|;
if|if
condition|(
name|tnamep
operator|!=
name|NULL
condition|)
operator|*
name|tnamep
operator|=
name|NULL
expr_stmt|;
operator|*
name|dpp
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
name|rrp
expr_stmt|;
name|eom
operator|=
name|msg
operator|+
name|msglen
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|dname
argument_list|,
name|namelen
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
literal|2
operator|*
name|INT16SZ
operator|+
name|INT32SZ
operator|+
name|INT16SZ
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|ttl
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|dlen
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
name|rdatap
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
name|dname
argument_list|,
name|class
argument_list|,
name|response_trans
argument_list|,
name|ns_ownercontext
argument_list|(
name|type
argument_list|,
name|response_trans
argument_list|)
argument_list|,
name|dname
argument_list|,
name|from_addr
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"rrextract: dname %s type %d class %d ttl %d\n"
operator|,
name|dname
operator|,
name|type
operator|,
name|class
operator|,
name|ttl
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Convert the resource record data into the internal 	 * database format. 	 * 	 * On entry to the switch: 	 *   CP points to the RDATA section of the wire-format RR. 	 *   DLEN is its length. 	 *   The memory area at DATA is available for processing. 	 *  	 * On exit from the switch: 	 *   CP has been incremented past the RR. 	 *   CP1 points to the RDATA section of the database-format RR. 	 *   N contains the length of the RDATA section of the dbase-format RR. 	 * 	 * The new data at CP1 for length N will be copied into the database, 	 * so it need not be in any particular storage location. 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
if|if
condition|(
name|dlen
operator|!=
name|INT32SZ
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*FALLTHROUGH*/
case|case
name|T_WKS
case|:
case|case
name|T_HINFO
case|:
case|case
name|T_UINFO
case|:
case|case
name|T_UID
case|:
case|case
name|T_GID
case|:
case|case
name|T_TXT
case|:
case|case
name|T_X25
case|:
case|case
name|T_ISDN
case|:
case|case
name|T_NSAP
case|:
case|case
name|T_AAAA
case|:
case|case
name|T_LOC
case|:
case|case
name|T_KEY
case|:
ifdef|#
directive|ifdef
name|ALLOW_T_UNSPEC
case|case
name|T_UNSPEC
case|:
endif|#
directive|endif
name|cp1
operator|=
name|cp
expr_stmt|;
name|n
operator|=
name|dlen
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
break|break;
case|case
name|T_CNAME
case|:
case|case
name|T_MB
case|:
case|case
name|T_MG
case|:
case|case
name|T_MR
case|:
case|case
name|T_NS
case|:
case|case
name|T_PTR
case|:
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|class
argument_list|,
name|response_trans
argument_list|,
name|type
operator|==
name|T_PTR
condition|?
name|ns_ptrcontext
argument_list|(
name|dname
argument_list|)
else|:
name|domain_ctx
argument_list|,
name|dname
argument_list|,
name|from_addr
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|=
name|data
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|tnamep
operator|!=
name|NULL
operator|&&
operator|(
name|type
operator|==
name|T_NS
operator|||
name|type
operator|==
name|T_MB
operator|)
condition|)
operator|*
name|tnamep
operator|=
name|strdup
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_SOA
case|:
name|context
operator|=
name|hostname_ctx
expr_stmt|;
goto|goto
name|soa_rp_minfo
goto|;
case|case
name|T_RP
case|:
case|case
name|T_MINFO
case|:
name|context
operator|=
name|mailname_ctx
expr_stmt|;
comment|/* FALLTHROUGH */
name|soa_rp_minfo
label|:
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|class
argument_list|,
name|response_trans
argument_list|,
name|context
argument_list|,
name|dname
argument_list|,
name|from_addr
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* 		 * The next use of 'cp' is dn_expand(), so we don't have 		 * to BOUNDS_CHECK() here. 		 */
name|cp1
operator|=
name|data
operator|+
operator|(
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
name|n1
operator|=
sizeof|sizeof
argument_list|(
name|data
argument_list|)
operator|-
name|n
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
name|n1
operator|-=
literal|5
operator|*
name|INT32SZ
expr_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|n1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|type
operator|==
name|T_RP
condition|)
name|context
operator|=
name|domain_ctx
expr_stmt|;
else|else
name|context
operator|=
name|mailname_ctx
expr_stmt|;
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|class
argument_list|,
name|response_trans
argument_list|,
name|context
argument_list|,
name|dname
argument_list|,
name|from_addr
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
block|{
name|n
operator|=
literal|5
operator|*
name|INT32SZ
expr_stmt|;
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
block|}
name|n
operator|=
name|cp1
operator|-
name|data
expr_stmt|;
name|cp1
operator|=
name|data
expr_stmt|;
break|break;
case|case
name|T_NAPTR
case|:
comment|/* Grab weight and port. */
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
name|INT16SZ
operator|*
literal|2
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|data
argument_list|,
name|INT16SZ
operator|*
literal|2
argument_list|)
expr_stmt|;
name|cp1
operator|=
name|data
operator|+
name|INT16SZ
operator|*
literal|2
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
operator|*
literal|2
expr_stmt|;
comment|/* Flags */
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|*
name|cp1
operator|++
operator|=
name|n
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
comment|/* Service */
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|*
name|cp1
operator|++
operator|=
name|n
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
comment|/* Regexp */
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|*
name|cp1
operator|++
operator|=
name|n
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
comment|/* Replacement */
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
sizeof|sizeof
name|data
operator|-
operator|(
name|cp1
operator|-
name|data
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|class
argument_list|,
name|response_trans
argument_list|,
name|hostname_ctx
argument_list|,
name|dname
argument_list|,
name|from_addr
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* compute end of data */
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* compute size of data */
name|n
operator|=
name|cp1
operator|-
name|data
expr_stmt|;
name|cp1
operator|=
name|data
expr_stmt|;
break|break;
case|case
name|T_MX
case|:
case|case
name|T_AFSDB
case|:
case|case
name|T_RT
case|:
case|case
name|T_SRV
case|:
comment|/* grab preference */
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|data
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|cp1
operator|=
name|data
operator|+
name|INT16SZ
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SRV
condition|)
block|{
comment|/* Grab weight and port. */
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
name|INT16SZ
operator|*
literal|2
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|INT16SZ
operator|*
literal|2
argument_list|)
expr_stmt|;
name|cp1
operator|+=
name|INT16SZ
operator|*
literal|2
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
operator|*
literal|2
expr_stmt|;
block|}
comment|/* get name */
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
sizeof|sizeof
name|data
operator|-
operator|(
name|cp1
operator|-
name|data
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|class
argument_list|,
name|response_trans
argument_list|,
name|hostname_ctx
argument_list|,
name|dname
argument_list|,
name|from_addr
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|tnamep
operator|!=
name|NULL
condition|)
operator|*
name|tnamep
operator|=
name|strdup
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
expr_stmt|;
comment|/* compute end of data */
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* compute size of data */
name|n
operator|=
name|cp1
operator|-
name|data
expr_stmt|;
name|cp1
operator|=
name|data
expr_stmt|;
break|break;
case|case
name|T_PX
case|:
comment|/* grab preference */
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|data
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|cp1
operator|=
name|data
operator|+
name|INT16SZ
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
comment|/* get MAP822 name */
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
sizeof|sizeof
name|data
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|class
argument_list|,
name|response_trans
argument_list|,
name|domain_ctx
argument_list|,
name|dname
argument_list|,
name|from_addr
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* 		 * The next use of 'cp' is dn_expand(), so we don't have 		 * to BOUNDS_CHECK() here. 		 */
name|cp1
operator|+=
operator|(
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
name|n1
operator|=
sizeof|sizeof
argument_list|(
name|data
argument_list|)
operator|-
name|n
expr_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|n1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|class
argument_list|,
name|response_trans
argument_list|,
name|domain_ctx
argument_list|,
name|dname
argument_list|,
name|from_addr
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|n
operator|=
name|cp1
operator|-
name|data
expr_stmt|;
name|cp1
operator|=
name|data
expr_stmt|;
break|break;
case|case
name|T_SIG
case|:
block|{
name|u_long
name|origTTL
decl_stmt|,
name|exptime
decl_stmt|,
name|signtime
decl_stmt|,
name|timetilexp
decl_stmt|,
name|now
decl_stmt|;
comment|/* Check signature time, expiration, and adjust TTL.  */
comment|/* This code is similar to that in db_load.c.  */
comment|/* Skip coveredType, alg, labels */
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
name|INT16SZ
operator|+
literal|1
operator|+
literal|1
operator|+
literal|3
operator|*
name|INT32SZ
argument_list|)
expr_stmt|;
name|cp1
operator|=
name|cp
operator|+
name|INT16SZ
operator|+
literal|1
operator|+
literal|1
expr_stmt|;
name|GETLONG
argument_list|(
name|origTTL
argument_list|,
name|cp1
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|exptime
argument_list|,
name|cp1
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|signtime
argument_list|,
name|cp1
argument_list|)
expr_stmt|;
name|now
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Get current time in GMT/UTC */
comment|/* Don't let bogus name servers increase the signed TTL */
if|if
condition|(
name|ttl
operator|>
name|origTTL
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"shrinking SIG TTL from %d to origTTL %d\n"
operator|,
name|ttl
operator|,
name|origTTL
operator|)
argument_list|)
expr_stmt|;
name|ttl
operator|=
name|origTTL
expr_stmt|;
block|}
comment|/* Don't let bogus signers "sign" in the future.  */
if|if
condition|(
name|signtime
operator|>
name|now
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"ignoring SIG: signature date %s is in the future\n"
operator|,
name|p_secstodate
argument_list|(
name|signtime
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|cp
operator|-
name|rrp
operator|)
operator|+
name|dlen
operator|)
return|;
block|}
comment|/* Ignore received SIG RR's that are already expired.  */
if|if
condition|(
name|exptime
operator|<=
name|now
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"ignoring SIG: expiration %s is in the past\n"
operator|,
name|p_secstodate
argument_list|(
name|exptime
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|cp
operator|-
name|rrp
operator|)
operator|+
name|dlen
operator|)
return|;
block|}
comment|/* Lop off the TTL at the expiration time.  */
name|timetilexp
operator|=
name|exptime
operator|-
name|now
expr_stmt|;
if|if
condition|(
name|timetilexp
operator|<
name|ttl
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"shrinking expiring %s SIG TTL from %d to %d\n"
operator|,
name|p_secstodate
argument_list|(
name|exptime
argument_list|)
operator|,
name|ttl
operator|,
name|timetilexp
operator|)
argument_list|)
expr_stmt|;
name|ttl
operator|=
name|timetilexp
expr_stmt|;
block|}
comment|/* The following code is copied from named-xfer.c.  */
name|cp1
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
comment|/* first just copy over the type_covered, algorithm, */
comment|/* labels, orig ttl, two timestamps, and the footprint */
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|18
expr_stmt|;
name|cp1
operator|+=
literal|18
expr_stmt|;
comment|/* then the signer's name */
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
operator|(
sizeof|sizeof
name|data
operator|)
operator|-
literal|18
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* finally, we copy over the variable-length signature. 		   Its size is the total data length, minus what we copied. */
if|if
condition|(
literal|18
operator|+
operator|(
name|u_int
operator|)
name|n
operator|>
name|dlen
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|n
operator|=
name|dlen
operator|-
operator|(
literal|18
operator|+
name|n
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
operator|(
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
name|data
argument_list|)
operator|-
call|(
name|int
call|)
argument_list|(
name|cp1
operator|-
operator|(
name|u_char
operator|*
operator|)
name|data
argument_list|)
operator|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* out of room! */
block|}
name|bcopy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
comment|/* compute size of data */
name|n
operator|=
name|cp1
operator|-
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
name|cp1
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
break|break;
block|}
default|default:
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"unknown type %d\n"
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|cp
operator|-
name|rrp
operator|)
operator|+
name|dlen
operator|)
return|;
block|}
if|if
condition|(
name|cp
operator|>
name|eom
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
call|(
name|u_int
call|)
argument_list|(
name|cp
operator|-
name|rdatap
argument_list|)
operator|!=
name|dlen
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"encoded rdata length is %u, but actual length was %u"
operator|,
name|dlen
operator|,
call|(
name|u_int
call|)
argument_list|(
name|cp
operator|-
name|rdatap
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|>
name|MAXDATA
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"update type %d: %d bytes is too much data\n"
operator|,
name|type
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ttl
operator|+=
name|tt
operator|.
name|tv_sec
expr_stmt|;
operator|*
name|dpp
operator|=
name|savedata
argument_list|(
name|class
argument_list|,
name|type
argument_list|,
name|ttl
argument_list|,
name|cp1
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|-
name|rrp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Decode the resource record 'rrp' and update the database.  * If savens is non-nil, record pointer for forwarding queries a second time.  */
end_comment

begin_function
name|int
name|doupdate
parameter_list|(
name|msg
parameter_list|,
name|msglen
parameter_list|,
name|rrp
parameter_list|,
name|zone
parameter_list|,
name|savens
parameter_list|,
name|flags
parameter_list|,
name|cred
parameter_list|)
name|u_char
modifier|*
name|msg
decl_stmt|;
name|int
name|msglen
decl_stmt|;
name|u_char
modifier|*
name|rrp
decl_stmt|;
name|int
name|zone
decl_stmt|;
name|struct
name|databuf
modifier|*
modifier|*
name|savens
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|u_int
name|cred
decl_stmt|;
block|{
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|int
name|class
decl_stmt|,
name|type
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|char
name|dname
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"doupdate(zone %d, savens %#lx, flags %#lx)\n"
operator|,
name|zone
operator|,
operator|(
name|u_long
operator|)
name|savens
operator|,
operator|(
name|u_long
operator|)
name|flags
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|rrextract
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|,
name|rrp
argument_list|,
operator|&
name|dp
argument_list|,
name|dname
argument_list|,
sizeof|sizeof
argument_list|(
name|dname
argument_list|)
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|dp
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|type
operator|=
name|dp
operator|->
name|d_type
expr_stmt|;
name|class
operator|=
name|dp
operator|->
name|d_class
expr_stmt|;
name|cp
operator|=
name|rrp
operator|+
name|n
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TRACEROOT
argument_list|)
operator|||
name|defined
argument_list|(
name|BOGUSNS
argument_list|)
if|if
condition|(
operator|(
name|type
operator|==
name|T_NS
operator|)
operator|&&
operator|(
name|savens
operator|!=
name|NULL
operator|)
condition|)
block|{
name|char
modifier|*
name|temp
decl_stmt|,
name|qname
index|[
name|MAXDNAME
index|]
decl_stmt|;
specifier|register
name|int
name|bogus
init|=
literal|0
decl_stmt|;
name|int
name|bogusns
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|BOGUSNS
if|if
condition|(
name|addr_on_netlist
argument_list|(
name|from_addr
operator|.
name|sin_addr
argument_list|,
name|boglist
argument_list|)
condition|)
block|{
name|bogusns
operator|++
expr_stmt|;
name|bogus
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|bogus
operator|&&
operator|(
operator|(
name|temp
operator|=
name|strrchr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|temp
argument_list|,
literal|".arpa"
argument_list|)
condition|)
name|bogus
operator|++
expr_stmt|;
name|qname
index|[
literal|0
index|]
operator|=
name|qname
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|msg
operator|+
name|HFIXEDSZ
argument_list|,
name|qname
argument_list|,
sizeof|sizeof
argument_list|(
name|qname
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|qname
index|[
literal|0
index|]
operator|=
literal|'?'
expr_stmt|;
elseif|else
if|if
condition|(
name|qname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|qname
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
if|if
condition|(
name|bogus
operator|&&
operator|(
operator|(
name|dname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
operator|&&
operator|(
name|zone
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
operator|(
name|char
operator|*
operator|)
name|from_addr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
literal|"bogus root NS"
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"bogus root NS %s rcvd from %s on query for \"%s\""
argument_list|,
name|dp
operator|->
name|d_data
argument_list|,
name|sin_ntoa
argument_list|(
operator|&
name|from_addr
argument_list|)
argument_list|,
name|qname
argument_list|)
expr_stmt|;
name|db_free
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|-
name|rrp
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|BOGUSNS
if|if
condition|(
name|bogusns
condition|)
block|{
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
operator|(
name|char
operator|*
operator|)
name|from_addr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
literal|"bogus nonroot NS"
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"bogus nonroot NS %s rcvd from %s on query for \"%s\""
argument_list|,
name|dp
operator|->
name|d_data
argument_list|,
name|sin_ntoa
argument_list|(
operator|&
name|from_addr
argument_list|)
argument_list|,
name|qname
argument_list|)
expr_stmt|;
name|db_free
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|-
name|rrp
operator|)
return|;
block|}
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/*TRACEROOT || BOGUSNS*/
name|dp
operator|->
name|d_zone
operator|=
name|zone
expr_stmt|;
name|dp
operator|->
name|d_cred
operator|=
name|cred
expr_stmt|;
name|dp
operator|->
name|d_clev
operator|=
literal|0
expr_stmt|;
comment|/* We trust what is on disk more, except root srvrs */
if|if
condition|(
operator|(
name|n
operator|=
name|db_update
argument_list|(
name|dname
argument_list|,
name|dp
argument_list|,
name|dp
argument_list|,
name|flags
argument_list|,
name|hashtab
argument_list|)
operator|)
operator|!=
name|OK
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&&
operator|(
name|n
operator|!=
name|DATAEXISTS
operator|)
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"update failed (%d)\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"update failed (DATAEXISTS)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|db_free
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|T_NS
operator|&&
name|savens
operator|!=
name|NULL
condition|)
operator|*
name|savens
operator|=
name|dp
expr_stmt|;
return|return
operator|(
name|cp
operator|-
name|rrp
operator|)
return|;
block|}
end_function

begin_function
name|int
name|send_msg
parameter_list|(
name|msg
parameter_list|,
name|msglen
parameter_list|,
name|qp
parameter_list|)
name|u_char
modifier|*
name|msg
decl_stmt|;
name|int
name|msglen
decl_stmt|;
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
block|{
if|if
condition|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_SYSTEM
condition|)
return|return
operator|(
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"send_msg -> %s (%s %d) id=%d\n"
argument_list|,
name|sin_ntoa
argument_list|(
operator|&
name|qp
operator|->
name|q_from
argument_list|)
argument_list|,
name|qp
operator|->
name|q_stream
operator|==
name|QSTREAM_NULL
condition|?
literal|"UDP"
else|:
literal|"TCP"
argument_list|,
name|qp
operator|->
name|q_stream
operator|==
name|QSTREAM_NULL
condition|?
name|qp
operator|->
name|q_dfd
else|:
name|qp
operator|->
name|q_stream
operator|->
name|s_rfd
argument_list|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
block|{
name|struct
name|qinfo
modifier|*
name|tqp
decl_stmt|;
for|for
control|(
name|tqp
operator|=
name|nsqhead
init|;
name|tqp
operator|!=
name|QINFO_NULL
condition|;
name|tqp
operator|=
name|tqp
operator|->
name|q_link
control|)
block|{
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"qp %#lx q_id: %d  q_nsid: %d q_msglen: %d "
argument_list|,
operator|(
name|u_long
operator|)
name|tqp
argument_list|,
name|tqp
operator|->
name|q_id
argument_list|,
name|tqp
operator|->
name|q_nsid
argument_list|,
name|tqp
operator|->
name|q_msglen
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"q_naddr: %d q_curaddr: %d\n"
argument_list|,
name|tqp
operator|->
name|q_naddr
argument_list|,
name|tqp
operator|->
name|q_curaddr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"q_next: %#lx q_link: %#lx\n"
argument_list|,
operator|(
name|u_long
operator|)
name|qp
operator|->
name|q_next
argument_list|,
operator|(
name|u_long
operator|)
name|qp
operator|->
name|q_link
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|debug
operator|>
literal|5
condition|)
name|fp_nquery
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|qp
operator|->
name|q_stream
operator|==
name|QSTREAM_NULL
condition|)
block|{
if|if
condition|(
name|sendto
argument_list|(
name|qp
operator|->
name|q_dfd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|msg
argument_list|,
name|msglen
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|qp
operator|->
name|q_from
argument_list|,
sizeof|sizeof
argument_list|(
name|qp
operator|->
name|q_from
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
operator|(
name|char
operator|*
operator|)
name|qp
operator|->
name|q_from
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|sendtoStr
argument_list|)
condition|)
if|#
directive|if
name|defined
argument_list|(
name|SPURIOUS_ECONNREFUSED
argument_list|)
if|if
condition|(
name|errno
operator|!=
name|ECONNREFUSED
condition|)
endif|#
directive|endif
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"send_msg: sendto(%s): %m"
argument_list|,
name|sin_ntoa
argument_list|(
operator|&
name|qp
operator|->
name|q_from
argument_list|)
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|qp
operator|->
name|q_from
operator|.
name|sin_addr
argument_list|,
name|nssSendtoErr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|writemsg
argument_list|(
name|qp
operator|->
name|q_stream
operator|->
name|s_rfd
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|msg
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|sq_done
argument_list|(
name|qp
operator|->
name|q_stream
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_comment
comment|/* i don't quite understand this but the only ref to it is notdef'd --vix */
end_comment

begin_macro
name|prime
argument_list|(
argument|class
argument_list|,
argument|type
argument_list|,
argument|oqp
argument_list|)
end_macro

begin_decl_stmt
name|int
name|class
decl_stmt|,
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|qinfo
modifier|*
name|oqp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|dname
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|oqp
operator|->
name|q_msg
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|dn_expand
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|oqp
operator|->
name|q_msg
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|oqp
operator|->
name|q_msg
operator|+
name|oqp
operator|->
name|q_msglen
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|oqp
operator|->
name|q_msg
operator|+
name|HFIXEDSZ
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|dname
argument_list|,
sizeof|sizeof
argument_list|(
name|dname
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return;
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"prime: %s\n"
operator|,
name|dname
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sysquery
argument_list|(
name|dname
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|QUERY
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|prime_cache
parameter_list|()
block|{
specifier|register
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"prime_cache: priming = %d\n"
operator|,
name|priming
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priming
operator|&&
name|fcachetab
operator|->
name|h_tab
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
operator|!
name|forward_only
condition|)
block|{
name|priming
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|qp
operator|=
name|sysquery
argument_list|(
literal|""
argument_list|,
name|C_IN
argument_list|,
name|T_NS
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|QUERY
argument_list|)
operator|)
condition|)
name|priming
operator|=
literal|0
expr_stmt|;
else|else
name|qp
operator|->
name|q_flags
operator||=
operator|(
name|Q_SYSTEM
operator||
name|Q_PRIMING
operator|)
expr_stmt|;
block|}
name|needs_prime_cache
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BIND_NOTIFY
end_ifdef

begin_function
name|struct
name|notify
modifier|*
name|findNotifyPeer
parameter_list|(
name|zp
parameter_list|,
name|ina
parameter_list|)
specifier|const
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|struct
name|in_addr
name|ina
decl_stmt|;
block|{
specifier|register
name|struct
name|notify
modifier|*
name|ap
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|zp
operator|->
name|z_notifylist
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
if|if
condition|(
name|ap
operator|->
name|addr
operator|.
name|s_addr
operator|==
name|ina
operator|.
name|s_addr
condition|)
break|break;
return|return
operator|(
name|ap
operator|)
return|;
block|}
end_function

begin_comment
comment|/* sysnotify(dname, class, type)  *	cause a NOTIFY request to be sysquery()'d to each secondary server  *	of the zone that "dname" is within.  */
end_comment

begin_function
name|void
name|sysnotify
parameter_list|(
name|dname
parameter_list|,
name|class
parameter_list|,
name|type
parameter_list|)
specifier|const
name|char
modifier|*
name|dname
decl_stmt|;
name|int
name|class
decl_stmt|,
name|type
decl_stmt|;
block|{
name|char
modifier|*
name|soaname
decl_stmt|,
modifier|*
name|zname
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|struct
name|in_addr
name|nss
index|[
name|NSMAX
index|]
decl_stmt|;
name|int
name|nns
decl_stmt|,
name|na
decl_stmt|,
name|zn
decl_stmt|,
name|nsc
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|struct
name|notify
modifier|*
name|ap
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|htp
operator|=
name|hashtab
expr_stmt|;
name|np
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|np
condition|)
name|panic
argument_list|(
operator|-
literal|1
argument_list|,
literal|"sysnotify: can't find name"
argument_list|)
expr_stmt|;
name|zn
operator|=
name|findMyZone
argument_list|(
name|np
argument_list|,
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|zn
operator|==
name|DB_Z_CACHE
condition|)
name|panic
argument_list|(
operator|-
literal|1
argument_list|,
literal|"sysnotify: not auth zone"
argument_list|)
expr_stmt|;
name|zp
operator|=
operator|&
name|zones
index|[
name|zn
index|]
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_type
operator|!=
name|Z_PRIMARY
operator|&&
name|zp
operator|->
name|z_type
operator|!=
name|Z_SECONDARY
condition|)
name|panic
argument_list|(
operator|-
literal|1
argument_list|,
literal|"sysnotify: not pri/sec"
argument_list|)
expr_stmt|;
name|zname
operator|=
name|zp
operator|->
name|z_origin
expr_stmt|;
comment|/* **DBG**	syslog(LOG_INFO, "sysnotify: found \"%s\" in \"%s\" (%s)", **DBG**	       dname, zname, zoneTypeString(zp)); */
name|nns
operator|=
name|na
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Send to recent AXFR peers. 	 */
for|for
control|(
name|ap
operator|=
name|zp
operator|->
name|z_notifylist
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
if|if
condition|(
name|tt
operator|.
name|tv_sec
operator|-
name|ap
operator|->
name|last
operator|>=
name|zp
operator|->
name|z_refresh
condition|)
block|{
comment|/* XXX - probably should do GC here. */
continue|continue;
block|}
name|nss
index|[
literal|0
index|]
operator|=
name|ap
operator|->
name|addr
expr_stmt|;
name|nsc
operator|=
literal|1
expr_stmt|;
name|nns
operator|++
expr_stmt|;
name|na
operator|++
expr_stmt|;
name|sysquery
argument_list|(
name|dname
argument_list|,
name|class
argument_list|,
name|T_SOA
argument_list|,
name|nss
argument_list|,
name|nsc
argument_list|,
name|NS_NOTIFY_OP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zp
operator|->
name|z_type
operator|!=
name|Z_PRIMARY
condition|)
goto|goto
name|done
goto|;
comment|/* 	 * Master. 	 */
name|htp
operator|=
name|hashtab
expr_stmt|;
name|np
operator|=
name|nlookup
argument_list|(
name|zname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|np
condition|)
name|panic
argument_list|(
operator|-
literal|1
argument_list|,
literal|"sysnotify: found name but not zone"
argument_list|)
expr_stmt|;
name|soaname
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|!
name|dp
operator|->
name|d_zone
operator|||
operator|!
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|T_SOA
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|soaname
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"multiple SOA's for zone \"%s\"?"
argument_list|,
name|zname
argument_list|)
expr_stmt|;
return|return;
block|}
name|soaname
operator|=
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|soaname
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"no SOA found for zone \"%s\""
argument_list|,
name|zname
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
specifier|register
name|struct
name|databuf
modifier|*
name|adp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|anp
decl_stmt|;
if|if
condition|(
operator|!
name|dp
operator|->
name|d_zone
operator|||
operator|!
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|T_NS
argument_list|)
condition|)
continue|continue;
comment|/* NS RDATA is server name. */
if|if
condition|(
name|strcasecmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|,
name|soaname
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|htp
operator|=
name|hashtab
expr_stmt|;
name|anp
operator|=
name|nlookup
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|anp
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"sysnotify: can't nlookup(%s)?"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|nsc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|adp
operator|=
name|anp
operator|->
name|n_data
init|;
name|adp
condition|;
name|adp
operator|=
name|adp
operator|->
name|d_next
control|)
block|{
name|struct
name|in_addr
name|ina
decl_stmt|;
if|if
condition|(
operator|!
name|match
argument_list|(
name|adp
argument_list|,
name|class
argument_list|,
name|T_A
argument_list|)
condition|)
continue|continue;
name|ina
operator|=
name|data_inaddr
argument_list|(
name|adp
operator|->
name|d_data
argument_list|)
expr_stmt|;
comment|/* Don't send to things we handled above. */
name|ap
operator|=
name|findNotifyPeer
argument_list|(
name|zp
argument_list|,
name|ina
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|&&
name|tt
operator|.
name|tv_sec
operator|-
name|ap
operator|->
name|last
operator|<
name|zp
operator|->
name|z_refresh
condition|)
goto|goto
name|nextns
goto|;
if|if
condition|(
name|nsc
operator|<
name|NSMAX
condition|)
name|nss
index|[
name|nsc
operator|++
index|]
operator|=
name|ina
expr_stmt|;
block|}
comment|/*next A*/
if|if
condition|(
name|nsc
operator|==
literal|0
condition|)
block|{
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
name|qp
operator|=
name|sysquery
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|,
comment|/*NS name*/
name|class
argument_list|,
comment|/*XXX: C_IN?*/
name|T_A
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|QUERY
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
condition|)
name|qp
operator|->
name|q_notifyzone
operator|=
name|zn
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|sysquery
argument_list|(
name|dname
argument_list|,
name|class
argument_list|,
name|T_SOA
argument_list|,
name|nss
argument_list|,
name|nsc
argument_list|,
name|NS_NOTIFY_OP
argument_list|)
expr_stmt|;
name|nns
operator|++
expr_stmt|;
name|na
operator|+=
name|nsc
expr_stmt|;
name|nextns
label|:
empty_stmt|;
block|}
comment|/*next NS*/
name|done
label|:
if|if
condition|(
name|nns
operator|||
name|na
condition|)
block|{
name|char
name|tmp
index|[
name|MAXDNAME
index|]
decl_stmt|;
comment|/* Many syslog()'s only take 5 args. */
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s %s %s"
argument_list|,
name|dname
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Sent NOTIFY for \"%s\" (%s); %d NS, %d A"
argument_list|,
name|tmp
argument_list|,
name|zname
argument_list|,
name|nns
argument_list|,
name|na
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*BIND_NOTIFY*/
end_comment

begin_function
name|struct
name|qinfo
modifier|*
name|sysquery
parameter_list|(
name|dname
parameter_list|,
name|class
parameter_list|,
name|type
parameter_list|,
name|nss
parameter_list|,
name|nsc
parameter_list|,
name|opcode
parameter_list|)
specifier|const
name|char
modifier|*
name|dname
decl_stmt|;
name|int
name|class
decl_stmt|,
name|type
decl_stmt|;
name|struct
name|in_addr
modifier|*
name|nss
decl_stmt|;
name|int
name|nsc
decl_stmt|,
name|opcode
decl_stmt|;
block|{
specifier|register
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|,
modifier|*
name|oqp
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|char
name|tmpdomain
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|databuf
modifier|*
name|nsp
index|[
name|NSMAX
index|]
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|nsa
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|n
decl_stmt|,
name|count
decl_stmt|;
name|nsp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"sysquery(%s, %d, %d, %#lx, %d)\n"
operator|,
name|dname
operator|,
name|class
operator|,
name|type
operator|,
operator|(
name|u_long
operator|)
name|nss
operator|,
name|nsc
operator|)
argument_list|)
expr_stmt|;
name|qp
operator|=
name|qnew
argument_list|(
name|dname
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|nss
operator|&&
name|nsc
condition|)
block|{
name|np
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|htp
operator|=
name|hashtab
expr_stmt|;
if|if
condition|(
name|priming
operator|&&
name|dname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|np
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|np
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"sysquery: nlookup error on %s?"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|err1
label|:
name|qfree
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|n
operator|=
name|findns
argument_list|(
operator|&
name|np
argument_list|,
name|class
argument_list|,
name|nsp
argument_list|,
operator|&
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|NXDOMAIN
case|:
case|case
name|SERVFAIL
case|:
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"sysquery: findns error (%s) on %s?"
argument_list|,
name|n
operator|==
name|NXDOMAIN
condition|?
literal|"NXDOMAIN"
else|:
literal|"SERVFAIL"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|err2
label|:
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
goto|goto
name|err1
goto|;
block|}
block|}
comment|/* build new qinfo struct */
name|qp
operator|->
name|q_cmsg
operator|=
name|qp
operator|->
name|q_msg
operator|=
name|NULL
expr_stmt|;
name|qp
operator|->
name|q_dfd
operator|=
name|ds
expr_stmt|;
if|if
condition|(
name|nss
operator|&&
name|nsc
condition|)
name|qp
operator|->
name|q_fwd
operator|=
name|NULL
expr_stmt|;
else|else
name|qp
operator|->
name|q_fwd
operator|=
name|fwdtab
expr_stmt|;
name|qp
operator|->
name|q_expire
operator|=
name|tt
operator|.
name|tv_sec
operator|+
name|RETRY_TIMEOUT
operator|*
literal|2
expr_stmt|;
name|qp
operator|->
name|q_flags
operator||=
name|Q_SYSTEM
expr_stmt|;
name|getname
argument_list|(
name|np
argument_list|,
name|tmpdomain
argument_list|,
sizeof|sizeof
name|tmpdomain
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_domain
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|qp
operator|->
name|q_domain
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_domain
operator|=
name|strdup
argument_list|(
name|tmpdomain
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_domain
operator|==
name|NULL
condition|)
name|panic
argument_list|(
name|ENOMEM
argument_list|,
literal|"ns_resp: strdup failed"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|qp
operator|->
name|q_msg
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|PACKETSZ
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"sysquery: malloc failed"
argument_list|)
expr_stmt|;
goto|goto
name|err2
goto|;
block|}
name|n
operator|=
name|res_mkquery
argument_list|(
name|opcode
argument_list|,
name|dname
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|qp
operator|->
name|q_msg
argument_list|,
name|PACKETSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"sysquery: res_mkquery(%s) failed"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
goto|goto
name|err2
goto|;
block|}
name|qp
operator|->
name|q_msglen
operator|=
name|n
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|qp
operator|->
name|q_msg
expr_stmt|;
name|hp
operator|->
name|id
operator|=
name|qp
operator|->
name|q_nsid
operator|=
name|htons
argument_list|(
name|nsid_next
argument_list|()
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
operator|(
name|qp
operator|->
name|q_fwd
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
comment|/* First check for an already pending query for this data */
for|for
control|(
name|oqp
operator|=
name|nsqhead
init|;
name|oqp
operator|!=
name|QINFO_NULL
condition|;
name|oqp
operator|=
name|oqp
operator|->
name|q_link
control|)
block|{
if|if
condition|(
operator|(
name|oqp
operator|!=
name|qp
operator|)
operator|&&
operator|(
name|oqp
operator|->
name|q_msglen
operator|==
name|qp
operator|->
name|q_msglen
operator|)
operator|&&
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|oqp
operator|->
name|q_msg
operator|+
literal|2
argument_list|,
name|qp
operator|->
name|q_msg
operator|+
literal|2
argument_list|,
name|qp
operator|->
name|q_msglen
operator|-
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|BIND_NOTIFY
comment|/* XXX - need fancier test to suppress duplicate 			 *       NOTIFYs to the same server (compare nss?) 			 */
if|if
condition|(
name|opcode
operator|!=
name|NS_NOTIFY_OP
condition|)
endif|#
directive|endif
comment|/*BIND_NOTIFY*/
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"sysquery: duplicate\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|err2
goto|;
block|}
block|}
block|}
if|if
condition|(
name|nss
operator|&&
name|nsc
condition|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|qserv
modifier|*
name|qs
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|qs
operator|=
name|qp
operator|->
name|q_addr
init|;
name|i
operator|<
name|nsc
condition|;
name|i
operator|++
operator|,
name|qs
operator|++
control|)
block|{
name|qs
operator|->
name|ns_addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|qs
operator|->
name|ns_addr
operator|.
name|sin_addr
operator|=
name|nss
index|[
name|i
index|]
expr_stmt|;
name|qs
operator|->
name|ns_addr
operator|.
name|sin_port
operator|=
name|ns_port
expr_stmt|;
name|qs
operator|->
name|ns
operator|=
name|NULL
expr_stmt|;
name|qs
operator|->
name|nsdata
operator|=
name|NULL
expr_stmt|;
name|qs
operator|->
name|stime
operator|=
name|tt
expr_stmt|;
name|qs
operator|->
name|nretry
operator|=
literal|0
expr_stmt|;
block|}
name|qp
operator|->
name|q_naddr
operator|=
name|nsc
expr_stmt|;
block|}
else|else
block|{
name|fetch_a
label|:
name|count
operator|=
name|nslookup
argument_list|(
name|nsp
argument_list|,
name|qp
argument_list|,
name|dname
argument_list|,
literal|"sysquery"
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"sysquery: nslookup reports danger (%s)"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
goto|goto
name|err2
goto|;
block|}
elseif|else
if|if
condition|(
name|np
operator|&&
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"sysquery: no addrs found for root NS (%s)"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|C_IN
operator|&&
operator|!
name|priming
condition|)
name|needs_prime_cache
operator|=
literal|1
expr_stmt|;
goto|goto
name|err2
goto|;
block|}
if|if
condition|(
name|np
condition|)
block|{
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
name|nsp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|np
operator|=
name|np_parent
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|n
operator|=
name|findns
argument_list|(
operator|&
name|np
argument_list|,
name|class
argument_list|,
name|nsp
argument_list|,
operator|&
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|NXDOMAIN
case|:
comment|/*FALLTHROUGH*/
case|case
name|SERVFAIL
case|:
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"sysquery: findns error (%d) on %s?"
argument_list|,
name|n
argument_list|,
name|dname
argument_list|)
expr_stmt|;
goto|goto
name|err2
goto|;
block|}
goto|goto
name|fetch_a
goto|;
block|}
goto|goto
name|err2
goto|;
block|}
block|}
name|schedretry
argument_list|(
name|qp
argument_list|,
name|retrytime
argument_list|(
name|qp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_fwd
operator|==
name|NULL
condition|)
name|qp
operator|->
name|q_addr
index|[
literal|0
index|]
operator|.
name|stime
operator|=
name|tt
expr_stmt|;
comment|/* XXX - why not every? */
name|nsa
operator|=
name|Q_NEXTADDR
argument_list|(
name|qp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"sysquery: send -> %s dfd=%d nsid=%d id=%d retry=%ld\n"
operator|,
name|sin_ntoa
argument_list|(
name|nsa
argument_list|)
operator|,
name|qp
operator|->
name|q_dfd
operator|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_nsid
argument_list|)
operator|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_id
argument_list|)
operator|,
operator|(
name|long
operator|)
name|qp
operator|->
name|q_time
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|10
condition|)
name|fp_nquery
argument_list|(
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sendto
argument_list|(
name|qp
operator|->
name|q_dfd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|nsa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nsa
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|sendtoStr
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"sysquery: sendto(%s): %m"
argument_list|,
name|sin_ntoa
argument_list|(
name|nsa
argument_list|)
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|,
name|nssSendtoErr
argument_list|)
expr_stmt|;
block|}
name|nameserIncr
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|,
name|nssSentSysQ
argument_list|)
expr_stmt|;
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
return|return
operator|(
name|qp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check the list of root servers after receiving a response  * to a query for the root servers.  */
end_comment

begin_function
specifier|static
name|int
name|check_root
parameter_list|()
block|{
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|pdp
decl_stmt|;
specifier|register
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|priming
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|np
operator|=
name|hashtab
operator|->
name|h_tab
index|[
literal|0
index|]
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|n_next
control|)
if|if
condition|(
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"check_root: Can't find root!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_NS
condition|)
name|count
operator|++
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"%d root servers\n"
operator|,
name|count
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|MINROOTS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"check_root: %d root servers after query to root server< min"
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pdp
operator|=
name|NULL
expr_stmt|;
name|dp
operator|=
name|np
operator|->
name|n_data
expr_stmt|;
while|while
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_NS
operator|&&
name|dp
operator|->
name|d_zone
operator|==
literal|0
operator|&&
name|dp
operator|->
name|d_ttl
operator|<
name|tt
operator|.
name|tv_sec
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"deleting old root server '%s'\n"
operator|,
name|dp
operator|->
name|d_data
operator|)
argument_list|)
expr_stmt|;
name|dp
operator|=
name|rm_datum
argument_list|(
name|dp
argument_list|,
name|np
argument_list|,
name|pdp
argument_list|)
expr_stmt|;
comment|/* SHOULD DELETE FROM HINTS ALSO */
continue|continue;
block|}
name|pdp
operator|=
name|dp
expr_stmt|;
name|dp
operator|=
name|dp
operator|->
name|d_next
expr_stmt|;
block|}
if|if
condition|(
name|check_ns
argument_list|()
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
block|{
name|priming
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*   * Check the root to make sure that for each NS record we have a A RR  */
end_comment

begin_function
specifier|static
name|int
name|check_ns
parameter_list|()
block|{
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|tdp
decl_stmt|;
specifier|register
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|,
modifier|*
name|tnp
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|char
modifier|*
name|dname
decl_stmt|;
name|int
name|found_arr
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|time_t
name|curtime
decl_stmt|;
name|int
name|servers
init|=
literal|0
decl_stmt|,
name|rrsets
init|=
literal|0
decl_stmt|;
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"check_ns()\n"
operator|)
argument_list|)
expr_stmt|;
name|curtime
operator|=
operator|(
name|u_int32_t
operator|)
name|tt
operator|.
name|tv_sec
expr_stmt|;
for|for
control|(
name|np
operator|=
name|hashtab
operator|->
name|h_tab
index|[
literal|0
index|]
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|n_next
control|)
block|{
if|if
condition|(
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
continue|continue;
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
name|int
name|cnames
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|NCACHE
if|if
condition|(
name|dp
operator|->
name|d_rcode
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
name|dp
operator|->
name|d_type
operator|!=
name|T_NS
condition|)
continue|continue;
name|servers
operator|++
expr_stmt|;
comment|/* look for A records */
name|dname
operator|=
operator|(
name|caddr_t
operator|)
name|dp
operator|->
name|d_data
expr_stmt|;
name|htp
operator|=
name|hashtab
expr_stmt|;
name|tnp
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tnp
operator|==
name|NULL
operator|||
name|fname
operator|!=
name|dname
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"check_ns: %s: not found %s %#lx\n"
operator|,
name|dname
operator|,
name|fname
operator|,
operator|(
name|u_long
operator|)
name|tnp
operator|)
argument_list|)
expr_stmt|;
name|sysquery
argument_list|(
name|dname
argument_list|,
name|dp
operator|->
name|d_class
argument_list|,
name|T_A
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|QUERY
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* look for name server addresses */
name|found_arr
operator|=
literal|0
expr_stmt|;
name|delete_stale
argument_list|(
name|tnp
argument_list|)
expr_stmt|;
for|for
control|(
name|tdp
operator|=
name|tnp
operator|->
name|n_data
init|;
name|tdp
operator|!=
name|NULL
condition|;
name|tdp
operator|=
name|tdp
operator|->
name|d_next
control|)
block|{
ifdef|#
directive|ifdef
name|NCACHE
if|if
condition|(
name|tdp
operator|->
name|d_rcode
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
name|tdp
operator|->
name|d_type
operator|==
name|T_CNAME
condition|)
name|cnames
operator|++
expr_stmt|;
if|if
condition|(
name|tdp
operator|->
name|d_type
operator|!=
name|T_A
operator|||
name|tdp
operator|->
name|d_class
operator|!=
name|dp
operator|->
name|d_class
condition|)
continue|continue;
if|if
condition|(
operator|(
name|tdp
operator|->
name|d_zone
operator|==
literal|0
operator|)
operator|&&
operator|(
name|tdp
operator|->
name|d_ttl
operator|<
name|curtime
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"check_ns: stale entry '%s'\n"
operator|,
name|NAME
argument_list|(
operator|*
name|tnp
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|found_arr
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|found_arr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|found_arr
condition|)
name|rrsets
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|cnames
operator|>
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Root NS %s -> CNAME %s"
argument_list|,
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
argument_list|,
name|NAME
argument_list|(
operator|*
name|tnp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sysquery
argument_list|(
name|dname
argument_list|,
name|dp
operator|->
name|d_class
argument_list|,
name|T_A
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|QUERY
argument_list|)
expr_stmt|;
block|}
block|}
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"check_ns: %d %d\n"
operator|,
name|servers
operator|,
name|rrsets
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|servers
operator|<=
literal|2
operator|)
condition|?
operator|(
name|rrsets
operator|==
name|servers
operator|)
else|:
operator|(
operator|(
name|rrsets
operator|*
literal|2
operator|)
operator|>=
name|servers
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* int findns(npp, class, nsp, countp, flag)  *	Find NS's or an SOA  * npp, class:  *	dname whose most enclosing NS is wanted  * nsp, countp:  *	result array and count; array will also be NULL terminated  * flag:  *	boolean: we're being called from ADDAUTH, bypass authority checks  * return value:  *	NXDOMAIN: we are authoritative for this {dname,class}  *		  *countp is bogus, but nsp[] has a single SOA returned in it.  *	SERVFAIL: we are auth but zone isn't loaded; or, no root servers found  *		  *countp and nsp[] are bogus.  *	OK: we are not authoritative, and here are the NS records we found.  *		  *countp and nsp[] return NS records of interest.  */
end_comment

begin_function
name|int
name|findns
parameter_list|(
name|npp
parameter_list|,
name|class
parameter_list|,
name|nsp
parameter_list|,
name|countp
parameter_list|,
name|flag
parameter_list|)
specifier|register
name|struct
name|namebuf
modifier|*
modifier|*
name|npp
decl_stmt|;
name|int
name|class
decl_stmt|;
name|struct
name|databuf
modifier|*
modifier|*
name|nsp
decl_stmt|;
name|int
modifier|*
name|countp
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
specifier|register
name|struct
name|namebuf
modifier|*
name|np
init|=
operator|*
name|npp
decl_stmt|;
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|databuf
modifier|*
modifier|*
name|nspp
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|nsp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|priming
operator|&&
operator|(
name|np
operator|==
name|NULL
operator|||
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|)
name|htp
operator|=
name|fcachetab
expr_stmt|;
else|else
name|htp
operator|=
name|hashtab
expr_stmt|;
name|try_again
label|:
if|if
condition|(
name|htp
operator|==
name|fcachetab
operator|&&
name|class
operator|==
name|C_IN
operator|&&
operator|!
name|priming
condition|)
name|needs_prime_cache
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
block|{
comment|/* find the root */
for|for
control|(
name|np
operator|=
name|htp
operator|->
name|h_tab
index|[
literal|0
index|]
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|n_next
control|)
if|if
condition|(
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
break|break;
block|}
while|while
condition|(
name|np
operator|!=
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"findns: np %#lx '%s'\n"
operator|,
operator|(
name|u_long
operator|)
name|np
operator|,
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Look first for SOA records. */
ifdef|#
directive|ifdef
name|ADDAUTH
if|if
condition|(
operator|!
name|flag
condition|)
endif|#
directive|endif
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|!=
literal|0
operator|&&
ifdef|#
directive|ifdef
name|PURGE_ZONE
operator|(
operator|(
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
operator|.
name|z_type
operator|==
name|Z_PRIMARY
operator|)
operator|||
operator|(
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
operator|.
name|z_type
operator|==
name|Z_SECONDARY
operator|)
operator|)
operator|&&
endif|#
directive|endif
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|T_SOA
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"findns: SOA found\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
operator|.
name|z_flags
operator|&
name|Z_AUTH
condition|)
block|{
operator|*
name|npp
operator|=
name|np
expr_stmt|;
name|nsp
index|[
literal|0
index|]
operator|=
name|dp
expr_stmt|;
name|nsp
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|dp
operator|->
name|d_rcnt
operator|++
expr_stmt|;
return|return
operator|(
name|NXDOMAIN
operator|)
return|;
block|}
else|else
block|{
comment|/* XXX:	zone isn't loaded but we're 					 *	primary or secondary for it. 					 *	should we fwd this? 					 */
return|return
operator|(
name|SERVFAIL
operator|)
return|;
block|}
block|}
block|}
comment|/* If no SOA records, look for NS records. */
name|nspp
operator|=
operator|&
name|nsp
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|nspp
operator|=
name|NULL
expr_stmt|;
name|delete_stale
argument_list|(
name|np
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|!
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|T_NS
argument_list|)
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|NCACHE
if|if
condition|(
name|dp
operator|->
name|d_rcode
condition|)
continue|continue;
endif|#
directive|endif
comment|/* 			 * Don't use records that may become invalid to 			 * reference later when we do the rtt computation. 			 * Never delete our safety-belt information! 			 * 			 * XXX:	this is horribly bogus. 			 */
if|if
condition|(
operator|(
name|dp
operator|->
name|d_zone
operator|==
literal|0
operator|)
operator|&&
operator|(
name|dp
operator|->
name|d_ttl
operator|<
name|tt
operator|.
name|tv_sec
operator|)
operator|&&
operator|!
operator|(
name|dp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"findns: stale entry '%s'\n"
operator|,
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 				 * We may have already added NS databufs 				 * and are going to throw them away. Fix 				 * fix reference counts. We don't need 				 * free() them here as we just got them 				 * from the cache. 				 */
while|while
condition|(
name|nspp
operator|>
operator|&
name|nsp
index|[
literal|0
index|]
condition|)
operator|(
operator|*
operator|--
name|nspp
operator|)
operator|->
name|d_rcnt
operator|--
expr_stmt|;
name|nsp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
goto|goto
name|try_parent
goto|;
block|}
if|if
condition|(
name|nspp
operator|<
operator|&
name|nsp
index|[
name|NSMAX
operator|-
literal|1
index|]
condition|)
block|{
operator|*
name|nspp
operator|++
operator|=
name|dp
expr_stmt|;
name|dp
operator|->
name|d_rcnt
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|countp
operator|=
name|nspp
operator|-
name|nsp
expr_stmt|;
if|if
condition|(
operator|*
name|countp
operator|>
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"findns: %d NS's added for '%s'\n"
operator|,
operator|*
name|countp
operator|,
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
operator|)
argument_list|)
expr_stmt|;
operator|*
name|nspp
operator|=
name|NULL
expr_stmt|;
operator|*
name|npp
operator|=
name|np
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
comment|/* Success, got some NS's */
block|}
name|try_parent
label|:
name|np
operator|=
name|np_parent
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|htp
operator|==
name|hashtab
condition|)
block|{
name|htp
operator|=
name|fcachetab
expr_stmt|;
goto|goto
name|try_again
goto|;
block|}
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"findns: No root nameservers for class %s?\n"
operator|,
name|p_class
argument_list|(
name|class
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|class
operator|<
name|MAXCLASS
operator|&&
name|norootlogged
index|[
name|class
index|]
operator|==
literal|0
condition|)
block|{
name|norootlogged
index|[
name|class
index|]
operator|=
literal|1
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"No root nameservers for class %s\n"
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|SERVFAIL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Extract RR's from the given node that match class and type.  * Return number of bytes added to response.  * If no matching data is found, then 0 is returned.  */
end_comment

begin_function
name|int
name|finddata
parameter_list|(
name|np
parameter_list|,
name|class
parameter_list|,
name|type
parameter_list|,
name|hp
parameter_list|,
name|dnamep
parameter_list|,
name|lenp
parameter_list|,
name|countp
parameter_list|)
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|int
name|class
decl_stmt|,
name|type
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
modifier|*
name|dnamep
decl_stmt|;
name|int
modifier|*
name|lenp
decl_stmt|,
decl|*
name|countp
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|buflen
decl_stmt|,
name|n
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|delete_stale
argument_list|(
name|np
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ROUND_ROBIN
if|if
condition|(
name|type
operator|!=
name|T_ANY
operator|&&
name|type
operator|!=
name|T_PTR
condition|)
block|{
comment|/* cycle order of RRs, for a load balancing effect... */
specifier|register
name|struct
name|databuf
modifier|*
modifier|*
name|dpp
decl_stmt|;
for|for
control|(
name|dpp
operator|=
operator|&
name|np
operator|->
name|n_data
init|;
name|dp
operator|=
operator|*
name|dpp
condition|;
name|dpp
operator|=
operator|&
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_next
operator|&&
name|wanted
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
condition|)
block|{
specifier|register
name|struct
name|databuf
modifier|*
name|lp
decl_stmt|;
operator|*
name|dpp
operator|=
name|lp
operator|=
name|dp
operator|->
name|d_next
expr_stmt|;
name|dp
operator|->
name|d_next
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|dpp
operator|=
operator|&
name|lp
operator|->
name|d_next
init|;
operator|*
name|dpp
condition|;
name|dpp
operator|=
operator|&
name|lp
operator|->
name|d_next
control|)
name|lp
operator|=
operator|*
name|dpp
expr_stmt|;
operator|*
name|dpp
operator|=
name|dp
expr_stmt|;
break|break;
block|}
block|}
block|}
endif|#
directive|endif
comment|/*ROUND_ROBIN*/
name|buflen
operator|=
operator|*
name|lenp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|buflen
operator|>
name|PACKETSZ
condition|)
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"finddata(): buflen=%d\n"
operator|,
name|buflen
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cp
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|hp
operator|)
operator|+
operator|*
name|countp
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|!
name|wanted
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|NCACHE
comment|/*if no negative caching then cname => nothing else*/
if|if
condition|(
name|type
operator|==
name|T_CNAME
operator|&&
name|class
operator|==
name|dp
operator|->
name|d_class
condition|)
block|{
comment|/* any data means no CNAME exists */
operator|*
name|countp
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/*NCACHE*/
continue|continue;
block|}
if|if
condition|(
name|dp
operator|->
name|d_cred
operator|==
name|DB_C_ADDITIONAL
condition|)
block|{
ifdef|#
directive|ifdef
name|NOADDITIONAL
continue|continue;
else|#
directive|else
comment|/* we want to expire additional data very 			 * quickly.  current strategy is to cut 5% 			 * off each time it is accessed.  this makes 			 * stale(dp) true earlier when this datum is 			 * used often. 			 */
name|dp
operator|->
name|d_ttl
operator|=
name|tt
operator|.
name|tv_sec
operator|+
literal|0.95
operator|*
call|(
name|int
call|)
argument_list|(
name|dp
operator|->
name|d_ttl
operator|-
name|tt
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|NCACHE
comment|/* -ve $ing stuff, anant@isi.edu 		 * if we have a -ve $ed record, change the rcode on the 		 * header to reflect that 		 */
if|if
condition|(
name|dp
operator|->
name|d_rcode
operator|==
name|NOERROR_NODATA
condition|)
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * This should not happen, yet it does... 				 */
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"NODATA& data for \"%s\" type %d class %d"
argument_list|,
operator|*
name|dnamep
argument_list|,
name|type
argument_list|,
name|class
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|type
operator|==
name|T_ANY
condition|)
continue|continue;
name|hp
operator|->
name|rcode
operator|=
name|NOERROR_NODATA
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_size
operator|==
literal|0
condition|)
block|{
comment|/* !RETURNSOA */
operator|*
name|countp
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
comment|/* XXX - we have to report success */
block|}
block|}
if|if
condition|(
name|dp
operator|->
name|d_rcode
operator|==
name|NXDOMAIN
condition|)
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * This should not happen, yet it might... 				 */
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"NXDOMAIN& data for \"%s\" type %d class %d"
argument_list|,
operator|*
name|dnamep
argument_list|,
name|type
argument_list|,
name|class
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_size
operator|==
literal|0
condition|)
block|{
comment|/* !RETURNSOA */
operator|*
name|countp
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
comment|/* XXX - we have to report success */
block|}
block|}
endif|#
directive|endif
comment|/*NCACHE*/
comment|/* Don't put anything but key or sig RR's in response to 			     requests for key or sig */
if|if
condition|(
operator|(
operator|(
name|type
operator|==
name|T_SIG
operator|)
operator|||
operator|(
name|type
operator|==
name|T_KEY
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
operator|(
name|dp
operator|->
name|d_type
operator|==
name|T_SIG
operator|)
operator|||
operator|(
name|dp
operator|->
name|d_type
operator|==
name|T_KEY
operator|)
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|n
operator|=
name|make_rr
argument_list|(
operator|*
name|dnamep
argument_list|,
name|dp
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|,
name|buflen
argument_list|,
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
operator|*
name|countp
operator|=
name|count
expr_stmt|;
return|return
operator|(
operator|*
name|lenp
operator|-
name|buflen
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|count
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* this isn't right for glue records, aa is set in ns_req */
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|&&
operator|(
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
operator|.
name|z_flags
operator|&
name|Z_AUTH
operator|)
operator|&&
name|class
operator|!=
name|C_ANY
condition|)
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
endif|#
directive|endif
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_CNAME
condition|)
block|{
comment|/* don't alias if querying for key, sig, nxt, or any */
if|if
condition|(
operator|(
name|type
operator|!=
name|T_KEY
operator|)
operator|&&
operator|(
name|type
operator|!=
name|T_SIG
operator|)
operator|&&
operator|(
name|type
operator|!=
name|T_NXT
operator|)
operator|&&
operator|(
name|type
operator|!=
name|T_ANY
operator|)
condition|)
block|{
comment|/* or T_NS? */
operator|*
name|dnamep
operator|=
operator|(
name|caddr_t
operator|)
name|dp
operator|->
name|d_data
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|!=
name|DB_Z_CACHE
operator|&&
operator|(
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
operator|.
name|z_flags
operator|&
name|Z_AUTH
operator|)
operator|&&
name|class
operator|!=
name|C_ANY
condition|)
comment|/* XXX */
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
block|}
break|break;
block|}
block|}
comment|/* 	 * Cache invalidate the other RR's of same type 	 * if some have timed out 	 */
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"finddata: added %d class %d type %d RRs\n"
operator|,
name|count
operator|,
name|class
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
operator|*
name|countp
operator|=
name|count
expr_stmt|;
return|return
operator|(
operator|*
name|lenp
operator|-
name|buflen
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Do we want this data record based on the class and type?  * (We always return found unexpired SIG RR's that cover the wanted rrtype.)  */
end_comment

begin_function
name|int
name|wanted
parameter_list|(
name|dp
parameter_list|,
name|class
parameter_list|,
name|type
parameter_list|)
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|int
name|class
decl_stmt|,
name|type
decl_stmt|;
block|{
name|u_char
modifier|*
name|cp
decl_stmt|;
name|u_int16_t
name|coveredType
decl_stmt|;
name|time_t
name|expiration
decl_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"wanted(%#lx, %d, %d) [%s %s]\n"
operator|,
operator|(
name|u_long
operator|)
name|dp
operator|,
name|class
operator|,
name|type
operator|,
name|p_class
argument_list|(
name|dp
operator|->
name|d_class
argument_list|)
operator|,
name|p_type
argument_list|(
name|dp
operator|->
name|d_type
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_class
operator|!=
name|class
operator|&&
name|class
operator|!=
name|C_ANY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Must check SIG for expiration below, other matches return OK here. */
if|if
condition|(
name|type
operator|==
name|dp
operator|->
name|d_type
operator|&&
operator|(
name|type
operator|!=
name|T_SIG
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|NCACHE
comment|/*-ve $ing stuff, for a T_ANY query, we do not want to return 	 * -ve $ed RRs. 	 */
if|if
condition|(
name|type
operator|==
name|T_ANY
operator|&&
name|dp
operator|->
name|d_rcode
operator|==
name|NOERROR_NODATA
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* First, look at the type of RR.  */
switch|switch
condition|(
name|dp
operator|->
name|d_type
condition|)
block|{
comment|/* Cases to deal with: 			T_ANY search, return all unexpired SIGs. 			T_SIG search, return all unexpired SIGs. 			T_<foo> search, return all unexp SIG<FOO>s. 		 */
case|case
name|T_SIG
case|:
name|cp
operator|=
name|dp
operator|->
name|d_data
expr_stmt|;
name|GETSHORT
argument_list|(
name|coveredType
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
operator|+
name|INT32SZ
expr_stmt|;
comment|/* skip alg, labels,& orig TTL */
name|GETLONG
argument_list|(
name|expiration
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_ANY
operator|||
name|type
operator|==
name|T_SIG
operator|||
name|type
operator|==
name|coveredType
condition|)
block|{
if|if
condition|(
name|expiration
operator|>
name|time
argument_list|(
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Unexpired matching SIG */
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* We don't return this SIG. */
case|case
name|T_ANY
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|T_CNAME
case|:
ifdef|#
directive|ifdef
name|NCACHE
if|if
condition|(
name|dp
operator|->
name|d_rcode
operator|!=
name|NOERROR_NODATA
condition|)
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|NCACHE
else|else
break|break;
endif|#
directive|endif
block|}
comment|/* OK, now look at the type of query.  */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_ANY
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|T_MAILB
case|:
switch|switch
condition|(
name|dp
operator|->
name|d_type
condition|)
block|{
case|case
name|T_MR
case|:
case|case
name|T_MB
case|:
case|case
name|T_MG
case|:
case|case
name|T_MINFO
case|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|T_AXFR
case|:
comment|/* T_AXFR needs an authoritative SOA */
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_SOA
operator|&&
name|dp
operator|->
name|d_zone
operator|!=
literal|0
operator|&&
operator|(
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
operator|.
name|z_flags
operator|&
name|Z_AUTH
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Add RR entries from dpp array to a query/response.  *  Return the number of bytes added or negative the amount  *  added if truncation occured.  Typically you are  *  adding NS records to a response.  */
end_comment

begin_function
name|int
name|add_data
parameter_list|(
name|np
parameter_list|,
name|dpp
parameter_list|,
name|cp
parameter_list|,
name|buflen
parameter_list|,
name|countp
parameter_list|)
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|databuf
modifier|*
modifier|*
name|dpp
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|buflen
decl_stmt|,
decl|*
name|countp
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|char
name|dname
index|[
name|MAXDNAME
index|]
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|,
name|bytes
decl_stmt|;
name|bytes
operator|=
operator|*
name|countp
operator|=
literal|0
expr_stmt|;
name|getname
argument_list|(
name|np
argument_list|,
name|dname
argument_list|,
sizeof|sizeof
argument_list|(
name|dname
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
operator|*
name|dpp
operator|++
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
operator|*
name|dpp
operator|++
control|)
block|{
if|if
condition|(
name|stale
argument_list|(
name|dp
argument_list|)
condition|)
continue|continue;
comment|/* ignore old cache entry */
ifdef|#
directive|ifdef
name|NCACHE
if|if
condition|(
name|dp
operator|->
name|d_rcode
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
operator|(
name|n
operator|=
name|make_rr
argument_list|(
name|dname
argument_list|,
name|dp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
name|bytes
operator|)
return|;
comment|/* Truncation */
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|bytes
operator|+=
name|n
expr_stmt|;
operator|(
operator|*
name|countp
operator|)
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|bytes
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|rrsetadd
parameter_list|(
name|flushset
parameter_list|,
name|name
parameter_list|,
name|dp
parameter_list|)
name|struct
name|flush_set
modifier|*
name|flushset
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
block|{
name|struct
name|flush_set
modifier|*
name|fs
init|=
name|flushset
decl_stmt|;
name|struct
name|db_list
modifier|*
name|dbl
decl_stmt|;
while|while
condition|(
name|fs
operator|->
name|fs_name
operator|&&
operator|(
name|strcasecmp
argument_list|(
name|fs
operator|->
name|fs_name
argument_list|,
name|name
argument_list|)
operator|||
operator|(
name|fs
operator|->
name|fs_class
operator|!=
name|dp
operator|->
name|d_class
operator|)
operator|||
operator|(
name|fs
operator|->
name|fs_type
operator|!=
name|dp
operator|->
name|d_type
operator|)
operator|||
operator|(
name|fs
operator|->
name|fs_cred
operator|!=
name|dp
operator|->
name|d_cred
operator|)
operator|)
condition|)
block|{
name|fs
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fs
operator|->
name|fs_name
condition|)
block|{
name|fs
operator|->
name|fs_name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fs
operator|->
name|fs_name
condition|)
name|panic
argument_list|(
operator|-
literal|1
argument_list|,
literal|"rrsetadd: out of memory"
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_class
operator|=
name|dp
operator|->
name|d_class
expr_stmt|;
name|fs
operator|->
name|fs_type
operator|=
name|dp
operator|->
name|d_type
expr_stmt|;
name|fs
operator|->
name|fs_cred
operator|=
name|dp
operator|->
name|d_cred
expr_stmt|;
name|fs
operator|->
name|fs_list
operator|=
name|NULL
expr_stmt|;
name|fs
operator|->
name|fs_last
operator|=
name|NULL
expr_stmt|;
block|}
name|dbl
operator|=
operator|(
expr|struct
name|db_list
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|db_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dbl
condition|)
name|panic
argument_list|(
operator|-
literal|1
argument_list|,
literal|"rrsetadd: out of memory"
argument_list|)
expr_stmt|;
name|dbl
operator|->
name|db_next
operator|=
name|NULL
expr_stmt|;
name|dbl
operator|->
name|db_dp
operator|=
name|dp
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_last
operator|==
name|NULL
condition|)
name|fs
operator|->
name|fs_list
operator|=
name|dbl
expr_stmt|;
else|else
name|fs
operator|->
name|fs_last
operator|->
name|db_next
operator|=
name|dbl
expr_stmt|;
name|fs
operator|->
name|fs_last
operator|=
name|dbl
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ttlcheck
parameter_list|(
name|name
parameter_list|,
name|dbl
parameter_list|,
name|update
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|db_list
modifier|*
name|dbl
decl_stmt|;
name|int
name|update
decl_stmt|;
block|{
name|int
name|type
init|=
name|dbl
operator|->
name|db_dp
operator|->
name|d_type
decl_stmt|;
name|int
name|class
init|=
name|dbl
operator|->
name|db_dp
operator|->
name|d_class
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
init|=
name|hashtab
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
specifier|register
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|db_list
modifier|*
name|dbp
init|=
name|dbl
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|u_int32_t
name|ttl
decl_stmt|;
name|int
name|first
decl_stmt|;
name|np
operator|=
name|nlookup
argument_list|(
name|name
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
operator|||
name|fname
operator|!=
name|name
operator|||
name|ns_wildcard
argument_list|(
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
argument_list|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* check that all the ttl's we have are the same, if not return 1 */
name|first
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|!
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|first
condition|)
block|{
comment|/* we can't update zone data so return early */
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ttl
operator|=
name|dp
operator|->
name|d_ttl
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ttl
operator|!=
name|dp
operator|->
name|d_ttl
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* there are no records of this type in the cache */
if|if
condition|(
name|first
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * the ttls of all records we have in the cache are the same 	 * if the ttls differ in the new set we don't want it. 	 */
comment|/* check that all the ttl's we have are the same, if not return 0 */
name|first
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|dbp
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|ttl
operator|=
name|dbp
operator|->
name|db_dp
operator|->
name|d_ttl
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ttl
operator|!=
name|dbp
operator|->
name|db_dp
operator|->
name|d_ttl
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dbp
operator|=
name|dbp
operator|->
name|db_next
expr_stmt|;
block|}
comment|/* update ttl if required */
if|if
condition|(
name|update
condition|)
block|{
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|!
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_ttl
operator|>
name|ttl
condition|)
break|break;
name|dp
operator|->
name|d_ttl
operator|=
name|ttl
expr_stmt|;
name|fixttl
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rrsetcmp
parameter_list|(
name|name
parameter_list|,
name|dbl
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|db_list
modifier|*
name|dbl
decl_stmt|;
block|{
name|int
name|type
init|=
name|dbl
operator|->
name|db_dp
operator|->
name|d_type
decl_stmt|;
name|int
name|class
init|=
name|dbl
operator|->
name|db_dp
operator|->
name|d_class
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
init|=
name|hashtab
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
specifier|register
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|db_list
modifier|*
name|dbp
init|=
name|dbl
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|int
name|exists
init|=
literal|0
decl_stmt|;
name|np
operator|=
name|nlookup
argument_list|(
name|name
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
operator|||
name|fname
operator|!=
name|name
operator|||
name|ns_wildcard
argument_list|(
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"rrsetcmp: name not in database\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* check that all entries in dbl are in the cache */
while|while
condition|(
name|dbp
condition|)
block|{
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
condition|)
name|exists
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|db_cmp
argument_list|(
name|dp
argument_list|,
name|dbp
operator|->
name|db_dp
argument_list|)
ifdef|#
directive|ifdef
name|NOADDITIONAL
operator|&&
operator|(
operator|(
name|dp
operator|->
name|d_cred
operator|==
name|dbp
operator|->
name|db_dp
operator|->
name|d_cred
operator|)
operator|||
operator|(
name|dp
operator|->
name|d_cred
operator|!=
name|DB_C_ADDITIONAL
operator|)
operator|)
endif|#
directive|endif
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|dp
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"rrsetcmp: %srecord%s in database\n"
operator|,
name|exists
condition|?
literal|""
else|:
literal|"no "
operator|,
name|exists
condition|?
literal|" not"
else|:
literal|"s"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|exists
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
return|;
block|}
name|dbp
operator|=
name|dbp
operator|->
name|db_next
expr_stmt|;
block|}
comment|/* Check that all cache entries are in the list. */
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|!
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|NCACHE
if|if
condition|(
name|dp
operator|->
name|d_rcode
condition|)
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
name|dbp
operator|=
name|dbl
expr_stmt|;
while|while
condition|(
name|dbp
condition|)
block|{
if|if
condition|(
operator|!
name|db_cmp
argument_list|(
name|dp
argument_list|,
name|dbp
operator|->
name|db_dp
argument_list|)
condition|)
break|break;
name|dbp
operator|=
name|dbp
operator|->
name|db_next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dbp
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"rrsetcmp: record not in rrset\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"rrsetcmp: rrsets matched\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rrsetupdate
parameter_list|(
name|flushset
parameter_list|,
name|flags
parameter_list|)
name|struct
name|flush_set
modifier|*
name|flushset
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|flush_set
modifier|*
name|fs
init|=
name|flushset
decl_stmt|;
name|struct
name|db_list
modifier|*
name|dbp
decl_stmt|,
modifier|*
name|odbp
decl_stmt|;
name|int
name|n
decl_stmt|;
while|while
condition|(
name|fs
operator|->
name|fs_name
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"rrsetupdate: %s\n"
operator|,
name|fs
operator|->
name|fs_name
index|[
literal|0
index|]
condition|?
name|fs
operator|->
name|fs_name
else|:
literal|"."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|rrsetcmp
argument_list|(
name|fs
operator|->
name|fs_name
argument_list|,
name|fs
operator|->
name|fs_list
argument_list|)
operator|)
operator|&&
name|ttlcheck
argument_list|(
name|fs
operator|->
name|fs_name
argument_list|,
name|fs
operator|->
name|fs_list
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|flushrrset
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|dbp
operator|=
name|fs
operator|->
name|fs_list
expr_stmt|;
while|while
condition|(
name|dbp
condition|)
block|{
name|n
operator|=
name|db_update
argument_list|(
name|fs
operator|->
name|fs_name
argument_list|,
name|dbp
operator|->
name|db_dp
argument_list|,
name|dbp
operator|->
name|db_dp
argument_list|,
name|flags
argument_list|,
name|hashtab
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"rrsetupdate: %s %d\n"
operator|,
name|fs
operator|->
name|fs_name
index|[
literal|0
index|]
condition|?
name|fs
operator|->
name|fs_name
else|:
literal|"."
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|OK
condition|)
name|db_free
argument_list|(
name|dbp
operator|->
name|db_dp
argument_list|)
expr_stmt|;
name|odbp
operator|=
name|dbp
expr_stmt|;
name|dbp
operator|=
name|dbp
operator|->
name|db_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|odbp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|ttlcheck
argument_list|(
name|fs
operator|->
name|fs_name
argument_list|,
name|fs
operator|->
name|fs_list
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dbp
operator|=
name|fs
operator|->
name|fs_list
expr_stmt|;
while|while
condition|(
name|dbp
condition|)
block|{
name|db_free
argument_list|(
name|dbp
operator|->
name|db_dp
argument_list|)
expr_stmt|;
name|odbp
operator|=
name|dbp
expr_stmt|;
name|dbp
operator|=
name|dbp
operator|->
name|db_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|odbp
argument_list|)
expr_stmt|;
block|}
block|}
name|fs
operator|->
name|fs_list
operator|=
name|NULL
expr_stmt|;
name|fs
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|flushrrset
parameter_list|(
name|fs
parameter_list|)
name|struct
name|flush_set
modifier|*
name|fs
decl_stmt|;
block|{
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"flushrrset(%s, %s, %s, %d)\n"
operator|,
name|fs
operator|->
name|fs_name
index|[
literal|0
index|]
condition|?
name|fs
operator|->
name|fs_name
else|:
literal|"."
operator|,
name|p_type
argument_list|(
name|fs
operator|->
name|fs_type
argument_list|)
operator|,
name|p_class
argument_list|(
name|fs
operator|->
name|fs_class
argument_list|)
operator|,
name|fs
operator|->
name|fs_cred
operator|)
argument_list|)
expr_stmt|;
name|dp
operator|=
name|savedata
argument_list|(
name|fs
operator|->
name|fs_class
argument_list|,
name|fs
operator|->
name|fs_type
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_zone
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|d_cred
operator|=
name|fs
operator|->
name|fs_cred
expr_stmt|;
name|dp
operator|->
name|d_clev
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|n
operator|=
name|db_update
argument_list|(
name|fs
operator|->
name|fs_name
argument_list|,
name|dp
argument_list|,
name|NULL
argument_list|,
name|DB_DELETE
argument_list|,
name|hashtab
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"flushrrset: %d\n"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|==
name|OK
condition|)
do|;
name|db_free
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_flushset
parameter_list|(
name|flushset
parameter_list|)
name|struct
name|flush_set
modifier|*
name|flushset
decl_stmt|;
block|{
name|struct
name|flush_set
modifier|*
name|fs
decl_stmt|;
for|for
control|(
name|fs
operator|=
name|flushset
init|;
name|fs
operator|->
name|fs_name
operator|!=
name|NULL
condition|;
name|fs
operator|++
control|)
name|free
argument_list|(
name|fs
operator|->
name|fs_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|flushset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  This is best thought of as a "cache invalidate" function.  *  It is called whenever a piece of data is determined to have  *  become invalid either through a timeout or a validation  *  failure.  It is better to have no information, than to  *  have partial information you pass off as complete.  */
end_comment

begin_function
name|void
name|delete_all
parameter_list|(
name|np
parameter_list|,
name|class
parameter_list|,
name|type
parameter_list|)
specifier|register
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|int
name|class
decl_stmt|,
name|type
decl_stmt|;
block|{
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|pdp
decl_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"delete_all(%#lx:\"%s\" %s %s)\n"
operator|,
operator|(
name|u_long
operator|)
name|np
operator|,
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
operator|,
name|p_class
argument_list|(
name|class
argument_list|)
operator|,
name|p_type
argument_list|(
name|type
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|pdp
operator|=
name|NULL
expr_stmt|;
name|dp
operator|=
name|np
operator|->
name|n_data
expr_stmt|;
while|while
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|dp
operator|->
name|d_zone
operator|==
literal|0
operator|)
operator|&&
operator|!
operator|(
name|dp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
operator|)
operator|&&
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|dp
operator|=
name|rm_datum
argument_list|(
name|dp
argument_list|,
name|np
argument_list|,
name|pdp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|pdp
operator|=
name|dp
expr_stmt|;
name|dp
operator|=
name|dp
operator|->
name|d_next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* delete_stale(np)  *	for all RRs associated with this name, check for staleness (& delete)  * arguments:  *	np = pointer to namebuf to be cleaned.  * returns:  *	void.  * side effects:  *	delete_all() can be called, freeing memory and relinking chains.  */
end_comment

begin_function
name|void
name|delete_stale
parameter_list|(
name|np
parameter_list|)
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
block|{
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|again
label|:
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|(
name|dp
operator|->
name|d_zone
operator|==
literal|0
operator|)
operator|&&
name|stale
argument_list|(
name|dp
argument_list|)
condition|)
block|{
name|delete_all
argument_list|(
name|np
argument_list|,
name|dp
operator|->
name|d_class
argument_list|,
name|dp
operator|->
name|d_type
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|add_related_additional
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|num_related
operator|>=
name|MAX_RELATED
operator|-
literal|1
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_related
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|related
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|related
index|[
name|num_related
operator|++
index|]
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_related_additional
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_related
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|related
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|num_related
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|related_additional
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_related
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|related
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|maybe_free
parameter_list|(
name|tname
parameter_list|)
name|char
modifier|*
modifier|*
name|tname
decl_stmt|;
block|{
if|if
condition|(
name|tname
operator|==
name|NULL
operator|||
operator|*
name|tname
operator|==
name|NULL
condition|)
return|return;
name|free
argument_list|(
operator|*
name|tname
argument_list|)
expr_stmt|;
operator|*
name|tname
operator|=
name|NULL
expr_stmt|;
block|}
end_function

end_unit

