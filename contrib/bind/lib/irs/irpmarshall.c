begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright(c) 1989, 1993, 1995  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1996 by Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: irpmarshall.c,v 8.5 1999/10/13 17:11:19 vixie Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|Check values are in approrpriate endian order.  Double check memory allocations on unmarhsalling
endif|#
directive|endif
end_endif

begin_comment
comment|/* Extern */
end_comment

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<irs.h>
end_include

begin_include
include|#
directive|include
file|<isc/memcluster.h>
end_include

begin_include
include|#
directive|include
file|<isc/irpmarshall.h>
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_function_decl
specifier|static
name|char
modifier|*
name|strndup
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
modifier|*
name|splitarray
parameter_list|(
specifier|const
name|char
modifier|*
name|buffer
parameter_list|,
specifier|const
name|char
modifier|*
name|buffend
parameter_list|,
name|char
name|delim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|joinarray
parameter_list|(
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|char
name|delim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|getfield
parameter_list|(
name|char
modifier|*
modifier|*
name|res
parameter_list|,
name|size_t
name|reslen
parameter_list|,
name|char
modifier|*
modifier|*
name|buffer
parameter_list|,
name|char
name|delim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|joinlength
parameter_list|(
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_array
parameter_list|(
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|size_t
name|entries
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ADDR_T_STR
parameter_list|(
name|x
parameter_list|)
value|(x == AF_INET ? "AF_INET" :\ 		       (x == AF_INET6 ? "AF_INET6" : "UNKNOWN"))
end_define

begin_define
define|#
directive|define
name|MAXPADDRSIZE
value|(sizeof "255.255.255.255" + 1)
end_define

begin_decl_stmt
specifier|static
name|char
name|COMMA
init|=
literal|','
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|COMMASTR
init|=
literal|","
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|COLONSTR
init|=
literal|":"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* See big comment at bottom of irpmarshall.h for description. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|WANT_IRS_PW
end_ifdef

begin_comment
comment|/* +++++++++++++++++++++++++ struct passwd +++++++++++++++++++++++++ */
end_comment

begin_comment
comment|/*  * int irp_marshall_pw(const struct passwd *pw, char **buffer, size_t *len)  *  * notes:  *  *	See above  *  * return:  *  *	0 on sucess, -1 on failure.  *  */
end_comment

begin_function
name|int
name|irp_marshall_pw
parameter_list|(
specifier|const
name|struct
name|passwd
modifier|*
name|pw
parameter_list|,
name|char
modifier|*
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|size_t
name|need
init|=
literal|1
decl_stmt|;
comment|/* for null byte */
name|char
name|pwUid
index|[
literal|24
index|]
decl_stmt|;
name|char
name|pwGid
index|[
literal|24
index|]
decl_stmt|;
name|char
name|pwChange
index|[
literal|24
index|]
decl_stmt|;
name|char
name|pwExpire
index|[
literal|24
index|]
decl_stmt|;
name|char
modifier|*
name|pwClass
decl_stmt|;
specifier|const
name|char
modifier|*
name|fieldsep
init|=
name|COLONSTR
decl_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
operator|||
name|len
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|sprintf
argument_list|(
name|pwUid
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|pw
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pwGid
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|pw
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PW_CHANGE
name|sprintf
argument_list|(
name|pwChange
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|pw
operator|->
name|pw_change
argument_list|)
expr_stmt|;
else|#
directive|else
name|pwChange
index|[
literal|0
index|]
operator|=
literal|'0'
expr_stmt|;
name|pwChange
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_PW_EXPIRE
name|sprintf
argument_list|(
name|pwExpire
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|pw
operator|->
name|pw_expire
argument_list|)
expr_stmt|;
else|#
directive|else
name|pwExpire
index|[
literal|0
index|]
operator|=
literal|'0'
expr_stmt|;
name|pwExpire
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_PW_CLASS
name|pwClass
operator|=
name|pw
operator|->
name|pw_class
expr_stmt|;
else|#
directive|else
name|pwClass
operator|=
literal|""
expr_stmt|;
endif|#
directive|endif
name|need
operator|+=
name|strlen
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* one for fieldsep */
name|need
operator|+=
name|strlen
argument_list|(
name|pw
operator|->
name|pw_passwd
argument_list|)
operator|+
literal|1
expr_stmt|;
name|need
operator|+=
name|strlen
argument_list|(
name|pwUid
argument_list|)
operator|+
literal|1
expr_stmt|;
name|need
operator|+=
name|strlen
argument_list|(
name|pwGid
argument_list|)
operator|+
literal|1
expr_stmt|;
name|need
operator|+=
name|strlen
argument_list|(
name|pwClass
argument_list|)
operator|+
literal|1
expr_stmt|;
name|need
operator|+=
name|strlen
argument_list|(
name|pwChange
argument_list|)
operator|+
literal|1
expr_stmt|;
name|need
operator|+=
name|strlen
argument_list|(
name|pwExpire
argument_list|)
operator|+
literal|1
expr_stmt|;
name|need
operator|+=
name|strlen
argument_list|(
name|pw
operator|->
name|pw_gecos
argument_list|)
operator|+
literal|1
expr_stmt|;
name|need
operator|+=
name|strlen
argument_list|(
name|pw
operator|->
name|pw_dir
argument_list|)
operator|+
literal|1
expr_stmt|;
name|need
operator|+=
name|strlen
argument_list|(
name|pw
operator|->
name|pw_shell
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
operator|*
name|len
operator|=
name|need
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|buffer
operator|!=
name|NULL
operator|&&
name|need
operator|>
operator|*
name|len
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|buffer
operator|==
name|NULL
condition|)
block|{
name|need
operator|+=
literal|2
expr_stmt|;
comment|/* for CRLF */
operator|*
name|buffer
operator|=
name|memget
argument_list|(
name|need
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buffer
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|len
operator|=
name|need
expr_stmt|;
block|}
name|strcpy
argument_list|(
operator|*
name|buffer
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|pw
operator|->
name|pw_passwd
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|pwUid
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|pwGid
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|pwClass
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|pwChange
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|pwExpire
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|pw
operator|->
name|pw_gecos
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|pw
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|pw
operator|->
name|pw_shell
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * int irp_unmarshall_pw(struct passwd *pw, char *buffer)  *  * notes:  *  *	see above  *  * return:  *  *	0 on success, -1 on failure  *  */
end_comment

begin_function
name|int
name|irp_unmarshall_pw
parameter_list|(
name|struct
name|passwd
modifier|*
name|pw
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|pass
decl_stmt|,
modifier|*
name|class
decl_stmt|,
modifier|*
name|gecos
decl_stmt|,
modifier|*
name|dir
decl_stmt|,
modifier|*
name|shell
decl_stmt|;
name|uid_t
name|pwuid
decl_stmt|;
name|gid_t
name|pwgid
decl_stmt|;
name|time_t
name|pwchange
decl_stmt|;
name|time_t
name|pwexpire
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|long
name|t
decl_stmt|;
name|char
name|tmpbuf
index|[
literal|24
index|]
decl_stmt|;
name|char
modifier|*
name|tb
init|=
operator|&
name|tmpbuf
index|[
literal|0
index|]
decl_stmt|;
name|char
name|fieldsep
init|=
literal|':'
decl_stmt|;
name|int
name|myerrno
init|=
name|EINVAL
decl_stmt|;
name|name
operator|=
name|pass
operator|=
name|class
operator|=
name|gecos
operator|=
name|dir
operator|=
name|shell
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
name|buffer
expr_stmt|;
comment|/* pw_name field */
name|name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|getfield
argument_list|(
operator|&
name|name
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|,
name|fieldsep
argument_list|)
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/* pw_passwd field */
name|pass
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|getfield
argument_list|(
operator|&
name|pass
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|,
name|fieldsep
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* field can be empty */
goto|goto
name|error
goto|;
block|}
comment|/* pw_uid field */
name|tb
operator|=
name|tmpbuf
expr_stmt|;
if|if
condition|(
name|getfield
argument_list|(
operator|&
name|tb
argument_list|,
sizeof|sizeof
name|tmpbuf
argument_list|,
operator|&
name|p
argument_list|,
name|fieldsep
argument_list|)
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|tb
argument_list|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|t
operator|=
name|strtol
argument_list|(
name|tmpbuf
argument_list|,
operator|&
name|tb
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tb
condition|)
block|{
goto|goto
name|error
goto|;
comment|/* junk in value */
block|}
name|pwuid
operator|=
operator|(
name|uid_t
operator|)
name|t
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|pwuid
operator|!=
name|t
condition|)
block|{
comment|/* value must have been too big. */
goto|goto
name|error
goto|;
block|}
comment|/* pw_gid field */
name|tb
operator|=
name|tmpbuf
expr_stmt|;
if|if
condition|(
name|getfield
argument_list|(
operator|&
name|tb
argument_list|,
sizeof|sizeof
name|tmpbuf
argument_list|,
operator|&
name|p
argument_list|,
name|fieldsep
argument_list|)
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|tb
argument_list|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|t
operator|=
name|strtol
argument_list|(
name|tmpbuf
argument_list|,
operator|&
name|tb
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tb
condition|)
block|{
goto|goto
name|error
goto|;
comment|/* junk in value */
block|}
name|pwgid
operator|=
operator|(
name|gid_t
operator|)
name|t
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|pwgid
operator|!=
name|t
condition|)
block|{
comment|/* value must have been too big. */
goto|goto
name|error
goto|;
block|}
comment|/* pw_class field */
name|class
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|getfield
argument_list|(
operator|&
name|class
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|,
name|fieldsep
argument_list|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/* pw_change field */
name|tb
operator|=
name|tmpbuf
expr_stmt|;
if|if
condition|(
name|getfield
argument_list|(
operator|&
name|tb
argument_list|,
sizeof|sizeof
name|tmpbuf
argument_list|,
operator|&
name|p
argument_list|,
name|fieldsep
argument_list|)
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|tb
argument_list|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|t
operator|=
name|strtol
argument_list|(
name|tmpbuf
argument_list|,
operator|&
name|tb
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tb
condition|)
block|{
goto|goto
name|error
goto|;
comment|/* junk in value */
block|}
name|pwchange
operator|=
operator|(
name|time_t
operator|)
name|t
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|pwchange
operator|!=
name|t
condition|)
block|{
comment|/* value must have been too big. */
goto|goto
name|error
goto|;
block|}
comment|/* pw_expire field */
name|tb
operator|=
name|tmpbuf
expr_stmt|;
if|if
condition|(
name|getfield
argument_list|(
operator|&
name|tb
argument_list|,
sizeof|sizeof
name|tmpbuf
argument_list|,
operator|&
name|p
argument_list|,
name|fieldsep
argument_list|)
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|tb
argument_list|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|t
operator|=
name|strtol
argument_list|(
name|tmpbuf
argument_list|,
operator|&
name|tb
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tb
condition|)
block|{
goto|goto
name|error
goto|;
comment|/* junk in value */
block|}
name|pwexpire
operator|=
operator|(
name|time_t
operator|)
name|t
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|pwexpire
operator|!=
name|t
condition|)
block|{
comment|/* value must have been too big. */
goto|goto
name|error
goto|;
block|}
comment|/* pw_gecos field */
name|gecos
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|getfield
argument_list|(
operator|&
name|gecos
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|,
name|fieldsep
argument_list|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/* pw_dir field */
name|dir
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|getfield
argument_list|(
operator|&
name|dir
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|,
name|fieldsep
argument_list|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/* pw_shell field */
name|shell
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|getfield
argument_list|(
operator|&
name|shell
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|,
name|fieldsep
argument_list|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|pw
operator|->
name|pw_name
operator|=
name|name
expr_stmt|;
name|pw
operator|->
name|pw_passwd
operator|=
name|pass
expr_stmt|;
name|pw
operator|->
name|pw_uid
operator|=
name|pwuid
expr_stmt|;
name|pw
operator|->
name|pw_gid
operator|=
name|pwgid
expr_stmt|;
name|pw
operator|->
name|pw_gecos
operator|=
name|gecos
expr_stmt|;
name|pw
operator|->
name|pw_dir
operator|=
name|dir
expr_stmt|;
name|pw
operator|->
name|pw_shell
operator|=
name|shell
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PW_CHANGE
name|pw
operator|->
name|pw_change
operator|=
name|pwchange
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_PW_CLASS
name|pw
operator|->
name|pw_class
operator|=
name|class
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_PW_EXPIRE
name|pw
operator|->
name|pw_expire
operator|=
name|pwexpire
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|errno
operator|=
name|myerrno
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pass
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|pass
argument_list|)
expr_stmt|;
if|if
condition|(
name|gecos
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|gecos
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|shell
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|shell
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------- struct passwd ------------------------- */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WANT_IRS_PW */
end_comment

begin_comment
comment|/* +++++++++++++++++++++++++ struct group +++++++++++++++++++++++++ */
end_comment

begin_comment
comment|/*  * int irp_marshall_gr(const struct group *gr, char **buffer, size_t *len)  *  * notes:  *  *	see above.  *  * return:  *  *	0 on success, -1 on failure  */
end_comment

begin_function
name|int
name|irp_marshall_gr
parameter_list|(
specifier|const
name|struct
name|group
modifier|*
name|gr
parameter_list|,
name|char
modifier|*
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|size_t
name|need
init|=
literal|1
decl_stmt|;
comment|/* for null byte */
name|char
name|grGid
index|[
literal|24
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|fieldsep
init|=
name|COLONSTR
decl_stmt|;
if|if
condition|(
name|gr
operator|==
name|NULL
operator|||
name|len
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|sprintf
argument_list|(
name|grGid
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|gr
operator|->
name|gr_gid
argument_list|)
expr_stmt|;
name|need
operator|+=
name|strlen
argument_list|(
name|gr
operator|->
name|gr_name
argument_list|)
operator|+
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|MISSING_GR_PASSWD
name|need
operator|+=
name|strlen
argument_list|(
name|gr
operator|->
name|gr_passwd
argument_list|)
operator|+
literal|1
expr_stmt|;
else|#
directive|else
name|need
operator|++
expr_stmt|;
endif|#
directive|endif
name|need
operator|+=
name|strlen
argument_list|(
name|grGid
argument_list|)
operator|+
literal|1
expr_stmt|;
name|need
operator|+=
name|joinlength
argument_list|(
name|gr
operator|->
name|gr_mem
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
operator|*
name|len
operator|=
name|need
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|buffer
operator|!=
name|NULL
operator|&&
name|need
operator|>
operator|*
name|len
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|buffer
operator|==
name|NULL
condition|)
block|{
name|need
operator|+=
literal|2
expr_stmt|;
comment|/* for CRLF */
operator|*
name|buffer
operator|=
name|memget
argument_list|(
name|need
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buffer
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|len
operator|=
name|need
expr_stmt|;
block|}
name|strcpy
argument_list|(
operator|*
name|buffer
argument_list|,
name|gr
operator|->
name|gr_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MISSING_GR_PASSWD
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|gr
operator|->
name|gr_passwd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|grGid
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
name|joinarray
argument_list|(
name|gr
operator|->
name|gr_mem
argument_list|,
operator|*
name|buffer
argument_list|,
name|COMMA
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * int irp_unmarshall_gr(struct group *gr, char *buffer)  *  * notes:  *  *	see above  *  * return:  *  *	0 on success and -1 on failure.  *  */
end_comment

begin_function
name|int
name|irp_unmarshall_gr
parameter_list|(
name|struct
name|group
modifier|*
name|gr
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|gid_t
name|grgid
decl_stmt|;
name|long
name|t
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|pass
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
modifier|*
name|members
init|=
name|NULL
decl_stmt|;
name|char
name|tmpbuf
index|[
literal|24
index|]
decl_stmt|;
name|char
modifier|*
name|tb
decl_stmt|;
name|char
name|fieldsep
init|=
literal|':'
decl_stmt|;
name|int
name|myerrno
init|=
name|EINVAL
decl_stmt|;
if|if
condition|(
name|gr
operator|==
name|NULL
operator|||
name|buffer
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|p
operator|=
name|buffer
expr_stmt|;
comment|/* gr_name field */
name|name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|getfield
argument_list|(
operator|&
name|name
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|,
name|fieldsep
argument_list|)
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/* gr_passwd field */
name|pass
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|getfield
argument_list|(
operator|&
name|pass
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|,
name|fieldsep
argument_list|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/* gr_gid field */
name|tb
operator|=
name|tmpbuf
expr_stmt|;
if|if
condition|(
name|getfield
argument_list|(
operator|&
name|tb
argument_list|,
sizeof|sizeof
name|tmpbuf
argument_list|,
operator|&
name|p
argument_list|,
name|fieldsep
argument_list|)
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|tb
argument_list|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|t
operator|=
name|strtol
argument_list|(
name|tmpbuf
argument_list|,
operator|&
name|tb
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tb
condition|)
block|{
goto|goto
name|error
goto|;
comment|/* junk in value */
block|}
name|grgid
operator|=
operator|(
name|gid_t
operator|)
name|t
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|grgid
operator|!=
name|t
condition|)
block|{
comment|/* value must have been too big. */
goto|goto
name|error
goto|;
block|}
comment|/* gr_mem field. Member names are separated by commas */
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|members
operator|=
name|splitarray
argument_list|(
name|p
argument_list|,
name|q
argument_list|,
name|COMMA
argument_list|)
expr_stmt|;
if|if
condition|(
name|members
operator|==
name|NULL
condition|)
block|{
name|myerrno
operator|=
name|errno
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|p
operator|=
name|q
operator|+
literal|1
expr_stmt|;
name|gr
operator|->
name|gr_name
operator|=
name|name
expr_stmt|;
ifndef|#
directive|ifndef
name|MISSING_GR_PASSWD
name|gr
operator|->
name|gr_passwd
operator|=
name|pass
expr_stmt|;
endif|#
directive|endif
name|gr
operator|->
name|gr_gid
operator|=
name|grgid
expr_stmt|;
name|gr
operator|->
name|gr_mem
operator|=
name|members
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|errno
operator|=
name|myerrno
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pass
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|pass
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------- struct group ------------------------- */
end_comment

begin_comment
comment|/* +++++++++++++++++++++++++ struct servent +++++++++++++++++++++++++ */
end_comment

begin_comment
comment|/*  * int irp_marshall_sv(const struct servent *sv, char **buffer, size_t *len)  *  * notes:  *  *	see above  *  * return:  *  *	0 on success, -1 on failure.  *  */
end_comment

begin_function
name|int
name|irp_marshall_sv
parameter_list|(
specifier|const
name|struct
name|servent
modifier|*
name|sv
parameter_list|,
name|char
modifier|*
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|size_t
name|need
init|=
literal|1
decl_stmt|;
comment|/* for null byte */
name|char
name|svPort
index|[
literal|24
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|fieldsep
init|=
name|COLONSTR
decl_stmt|;
name|short
name|realport
decl_stmt|;
if|if
condition|(
name|sv
operator|==
name|NULL
operator|||
name|len
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* the int s_port field is actually a short in network order. We 	   want host order to make the marshalled data look correct */
name|realport
operator|=
name|ntohs
argument_list|(
operator|(
name|short
operator|)
name|sv
operator|->
name|s_port
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|svPort
argument_list|,
literal|"%d"
argument_list|,
name|realport
argument_list|)
expr_stmt|;
name|need
operator|+=
name|strlen
argument_list|(
name|sv
operator|->
name|s_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|need
operator|+=
name|joinlength
argument_list|(
name|sv
operator|->
name|s_aliases
argument_list|)
operator|+
literal|1
expr_stmt|;
name|need
operator|+=
name|strlen
argument_list|(
name|svPort
argument_list|)
operator|+
literal|1
expr_stmt|;
name|need
operator|+=
name|strlen
argument_list|(
name|sv
operator|->
name|s_proto
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
operator|*
name|len
operator|=
name|need
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|buffer
operator|!=
name|NULL
operator|&&
name|need
operator|>
operator|*
name|len
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|buffer
operator|==
name|NULL
condition|)
block|{
name|need
operator|+=
literal|2
expr_stmt|;
comment|/* for CRLF */
operator|*
name|buffer
operator|=
name|memget
argument_list|(
name|need
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buffer
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|len
operator|=
name|need
expr_stmt|;
block|}
name|strcpy
argument_list|(
operator|*
name|buffer
argument_list|,
name|sv
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
name|joinarray
argument_list|(
name|sv
operator|->
name|s_aliases
argument_list|,
operator|*
name|buffer
argument_list|,
name|COMMA
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|svPort
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|sv
operator|->
name|s_proto
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * int irp_unmarshall_sv(struct servent *sv, char *buffer)  *  * notes:  *  *	see above  *  * return:  *  *	0 on success, -1 on failure.  *  */
end_comment

begin_function
name|int
name|irp_unmarshall_sv
parameter_list|(
name|struct
name|servent
modifier|*
name|sv
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|short
name|svport
decl_stmt|;
name|long
name|t
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|proto
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
modifier|*
name|aliases
init|=
name|NULL
decl_stmt|;
name|char
name|tmpbuf
index|[
literal|24
index|]
decl_stmt|;
name|char
modifier|*
name|tb
decl_stmt|;
name|char
name|fieldsep
init|=
literal|':'
decl_stmt|;
name|int
name|myerrno
init|=
name|EINVAL
decl_stmt|;
if|if
condition|(
name|sv
operator|==
name|NULL
operator|||
name|buffer
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|p
operator|=
name|buffer
expr_stmt|;
comment|/* s_name field */
name|name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|getfield
argument_list|(
operator|&
name|name
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|,
name|fieldsep
argument_list|)
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/* s_aliases field */
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|aliases
operator|=
name|splitarray
argument_list|(
name|p
argument_list|,
name|q
argument_list|,
name|COMMA
argument_list|)
expr_stmt|;
if|if
condition|(
name|aliases
operator|==
name|NULL
condition|)
block|{
name|myerrno
operator|=
name|errno
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|p
operator|=
name|q
operator|+
literal|1
expr_stmt|;
comment|/* s_port field */
name|tb
operator|=
name|tmpbuf
expr_stmt|;
if|if
condition|(
name|getfield
argument_list|(
operator|&
name|tb
argument_list|,
sizeof|sizeof
name|tmpbuf
argument_list|,
operator|&
name|p
argument_list|,
name|fieldsep
argument_list|)
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|tb
argument_list|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|t
operator|=
name|strtol
argument_list|(
name|tmpbuf
argument_list|,
operator|&
name|tb
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tb
condition|)
block|{
goto|goto
name|error
goto|;
comment|/* junk in value */
block|}
name|svport
operator|=
operator|(
name|short
operator|)
name|t
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|svport
operator|!=
name|t
condition|)
block|{
comment|/* value must have been too big. */
goto|goto
name|error
goto|;
block|}
name|svport
operator|=
name|htons
argument_list|(
name|svport
argument_list|)
expr_stmt|;
comment|/* s_proto field */
name|proto
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|getfield
argument_list|(
operator|&
name|proto
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|,
name|fieldsep
argument_list|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|sv
operator|->
name|s_name
operator|=
name|name
expr_stmt|;
name|sv
operator|->
name|s_aliases
operator|=
name|aliases
expr_stmt|;
name|sv
operator|->
name|s_port
operator|=
name|svport
expr_stmt|;
name|sv
operator|->
name|s_proto
operator|=
name|proto
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|errno
operator|=
name|myerrno
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|proto
argument_list|)
expr_stmt|;
name|free_array
argument_list|(
name|aliases
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------- struct servent ------------------------- */
end_comment

begin_comment
comment|/* +++++++++++++++++++++++++ struct protoent +++++++++++++++++++++++++ */
end_comment

begin_comment
comment|/*  * int irp_marshall_pr(struct protoent *pr, char **buffer, size_t *len)  *  * notes:  *  *	see above  *  * return:  *  *	0 on success and -1 on failure.  *  */
end_comment

begin_function
name|int
name|irp_marshall_pr
parameter_list|(
name|struct
name|protoent
modifier|*
name|pr
parameter_list|,
name|char
modifier|*
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|size_t
name|need
init|=
literal|1
decl_stmt|;
comment|/* for null byte */
name|char
name|prProto
index|[
literal|24
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|fieldsep
init|=
name|COLONSTR
decl_stmt|;
if|if
condition|(
name|pr
operator|==
name|NULL
operator|||
name|len
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|sprintf
argument_list|(
name|prProto
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|pr
operator|->
name|p_proto
argument_list|)
expr_stmt|;
name|need
operator|+=
name|strlen
argument_list|(
name|pr
operator|->
name|p_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|need
operator|+=
name|joinlength
argument_list|(
name|pr
operator|->
name|p_aliases
argument_list|)
operator|+
literal|1
expr_stmt|;
name|need
operator|+=
name|strlen
argument_list|(
name|prProto
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
operator|*
name|len
operator|=
name|need
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|buffer
operator|!=
name|NULL
operator|&&
name|need
operator|>
operator|*
name|len
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|buffer
operator|==
name|NULL
condition|)
block|{
name|need
operator|+=
literal|2
expr_stmt|;
comment|/* for CRLF */
operator|*
name|buffer
operator|=
name|memget
argument_list|(
name|need
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buffer
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|len
operator|=
name|need
expr_stmt|;
block|}
name|strcpy
argument_list|(
operator|*
name|buffer
argument_list|,
name|pr
operator|->
name|p_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
name|joinarray
argument_list|(
name|pr
operator|->
name|p_aliases
argument_list|,
operator|*
name|buffer
argument_list|,
name|COMMA
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|prProto
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * int irp_unmarshall_pr(struct protoent *pr, char *buffer)  *  * notes:  *  *	See above  *  * return:  *  *	0 on success, -1 on failure  *  */
end_comment

begin_function
name|int
name|irp_unmarshall_pr
parameter_list|(
name|struct
name|protoent
modifier|*
name|pr
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|prproto
decl_stmt|;
name|long
name|t
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
modifier|*
name|aliases
init|=
name|NULL
decl_stmt|;
name|char
name|tmpbuf
index|[
literal|24
index|]
decl_stmt|;
name|char
modifier|*
name|tb
decl_stmt|;
name|char
name|fieldsep
init|=
literal|':'
decl_stmt|;
name|int
name|myerrno
init|=
name|EINVAL
decl_stmt|;
if|if
condition|(
name|pr
operator|==
name|NULL
operator|||
name|buffer
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|p
operator|=
name|buffer
expr_stmt|;
comment|/* p_name field */
name|name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|getfield
argument_list|(
operator|&
name|name
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|,
name|fieldsep
argument_list|)
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/* p_aliases field */
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|aliases
operator|=
name|splitarray
argument_list|(
name|p
argument_list|,
name|q
argument_list|,
name|COMMA
argument_list|)
expr_stmt|;
if|if
condition|(
name|aliases
operator|==
name|NULL
condition|)
block|{
name|myerrno
operator|=
name|errno
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|p
operator|=
name|q
operator|+
literal|1
expr_stmt|;
comment|/* p_proto field */
name|tb
operator|=
name|tmpbuf
expr_stmt|;
if|if
condition|(
name|getfield
argument_list|(
operator|&
name|tb
argument_list|,
sizeof|sizeof
name|tmpbuf
argument_list|,
operator|&
name|p
argument_list|,
name|fieldsep
argument_list|)
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|tb
argument_list|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|t
operator|=
name|strtol
argument_list|(
name|tmpbuf
argument_list|,
operator|&
name|tb
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tb
condition|)
block|{
goto|goto
name|error
goto|;
comment|/* junk in value */
block|}
name|prproto
operator|=
operator|(
name|int
operator|)
name|t
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|prproto
operator|!=
name|t
condition|)
block|{
comment|/* value must have been too big. */
goto|goto
name|error
goto|;
block|}
name|pr
operator|->
name|p_name
operator|=
name|name
expr_stmt|;
name|pr
operator|->
name|p_aliases
operator|=
name|aliases
expr_stmt|;
name|pr
operator|->
name|p_proto
operator|=
name|prproto
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|errno
operator|=
name|myerrno
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free_array
argument_list|(
name|aliases
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------- struct protoent ------------------------- */
end_comment

begin_comment
comment|/* +++++++++++++++++++++++++ struct hostent +++++++++++++++++++++++++ */
end_comment

begin_comment
comment|/*  * int irp_marshall_ho(struct hostent *ho, char **buffer, size_t *len)  *  * notes:  *  *	see above.  *  * return:  *  *	0 on success, -1 on failure.  *  */
end_comment

begin_function
name|int
name|irp_marshall_ho
parameter_list|(
name|struct
name|hostent
modifier|*
name|ho
parameter_list|,
name|char
modifier|*
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|size_t
name|need
init|=
literal|1
decl_stmt|;
comment|/* for null byte */
name|char
name|hoaddrtype
index|[
literal|24
index|]
decl_stmt|;
name|char
name|holength
index|[
literal|24
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|addrlen
decl_stmt|;
name|int
name|malloced
init|=
literal|0
decl_stmt|;
name|size_t
name|remlen
decl_stmt|;
specifier|const
name|char
modifier|*
name|fieldsep
init|=
literal|"@"
decl_stmt|;
if|if
condition|(
name|ho
operator|==
name|NULL
operator|||
name|len
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
switch|switch
condition|(
name|ho
operator|->
name|h_addrtype
condition|)
block|{
case|case
name|AF_INET
case|:
name|strcpy
argument_list|(
name|hoaddrtype
argument_list|,
literal|"AF_INET"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|strcpy
argument_list|(
name|hoaddrtype
argument_list|,
literal|"AF_INET6"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|sprintf
argument_list|(
name|holength
argument_list|,
literal|"%d"
argument_list|,
name|ho
operator|->
name|h_length
argument_list|)
expr_stmt|;
name|need
operator|+=
name|strlen
argument_list|(
name|ho
operator|->
name|h_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|need
operator|+=
name|joinlength
argument_list|(
name|ho
operator|->
name|h_aliases
argument_list|)
operator|+
literal|1
expr_stmt|;
name|need
operator|+=
name|strlen
argument_list|(
name|hoaddrtype
argument_list|)
operator|+
literal|1
expr_stmt|;
name|need
operator|+=
name|strlen
argument_list|(
name|holength
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* we determine an upper bound on the string length needed, not an 	   exact length. */
name|addrlen
operator|=
operator|(
name|ho
operator|->
name|h_addrtype
operator|==
name|AF_INET
condition|?
literal|16
else|:
literal|46
operator|)
expr_stmt|;
comment|/* XX other AF's?? */
for|for
control|(
name|av
operator|=
name|ho
operator|->
name|h_addr_list
init|;
name|av
operator|!=
name|NULL
operator|&&
operator|*
name|av
operator|!=
name|NULL
condition|;
name|av
operator|++
control|)
name|need
operator|+=
name|addrlen
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
operator|*
name|len
operator|=
name|need
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|buffer
operator|!=
name|NULL
operator|&&
name|need
operator|>
operator|*
name|len
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|buffer
operator|==
name|NULL
condition|)
block|{
name|need
operator|+=
literal|2
expr_stmt|;
comment|/* for CRLF */
operator|*
name|buffer
operator|=
name|memget
argument_list|(
name|need
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buffer
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|len
operator|=
name|need
expr_stmt|;
name|malloced
operator|=
literal|1
expr_stmt|;
block|}
name|strcpy
argument_list|(
operator|*
name|buffer
argument_list|,
name|ho
operator|->
name|h_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
name|joinarray
argument_list|(
name|ho
operator|->
name|h_aliases
argument_list|,
operator|*
name|buffer
argument_list|,
name|COMMA
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|hoaddrtype
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|holength
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
name|p
operator|=
operator|*
name|buffer
operator|+
name|strlen
argument_list|(
operator|*
name|buffer
argument_list|)
expr_stmt|;
name|remlen
operator|=
name|need
operator|-
name|strlen
argument_list|(
operator|*
name|buffer
argument_list|)
expr_stmt|;
for|for
control|(
name|av
operator|=
name|ho
operator|->
name|h_addr_list
init|;
name|av
operator|!=
name|NULL
operator|&&
operator|*
name|av
operator|!=
name|NULL
condition|;
name|av
operator|++
control|)
block|{
if|if
condition|(
name|inet_ntop
argument_list|(
name|ho
operator|->
name|h_addrtype
argument_list|,
operator|*
name|av
argument_list|,
name|p
argument_list|,
name|remlen
argument_list|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|*
operator|(
name|av
operator|+
literal|1
operator|)
operator|!=
name|NULL
condition|)
name|strcat
argument_list|(
name|p
argument_list|,
name|COMMASTR
argument_list|)
expr_stmt|;
name|remlen
operator|-=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
if|if
condition|(
name|malloced
condition|)
block|{
name|memput
argument_list|(
operator|*
name|buffer
argument_list|,
name|need
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * int irp_unmarshall_ho(struct hostent *ho, char *buffer)  *  * notes:  *  *	See above.  *  * return:  *  *	0 on success, -1 on failure.  *  */
end_comment

begin_function
name|int
name|irp_unmarshall_ho
parameter_list|(
name|struct
name|hostent
modifier|*
name|ho
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|int
name|hoaddrtype
decl_stmt|;
name|int
name|holength
decl_stmt|;
name|long
name|t
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
modifier|*
name|aliases
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
modifier|*
name|hohaddrlist
init|=
name|NULL
decl_stmt|;
name|size_t
name|hoaddrsize
decl_stmt|;
name|char
name|tmpbuf
index|[
literal|24
index|]
decl_stmt|;
name|char
modifier|*
name|tb
decl_stmt|;
name|char
modifier|*
modifier|*
name|alist
decl_stmt|;
name|int
name|addrcount
decl_stmt|;
name|char
name|fieldsep
init|=
literal|'@'
decl_stmt|;
name|int
name|myerrno
init|=
name|EINVAL
decl_stmt|;
if|if
condition|(
name|ho
operator|==
name|NULL
operator|||
name|buffer
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|p
operator|=
name|buffer
expr_stmt|;
comment|/* h_name field */
name|name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|getfield
argument_list|(
operator|&
name|name
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|,
name|fieldsep
argument_list|)
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/* h_aliases field */
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|aliases
operator|=
name|splitarray
argument_list|(
name|p
argument_list|,
name|q
argument_list|,
name|COMMA
argument_list|)
expr_stmt|;
if|if
condition|(
name|aliases
operator|==
name|NULL
condition|)
block|{
name|myerrno
operator|=
name|errno
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|p
operator|=
name|q
operator|+
literal|1
expr_stmt|;
comment|/* h_addrtype field */
name|tb
operator|=
name|tmpbuf
expr_stmt|;
if|if
condition|(
name|getfield
argument_list|(
operator|&
name|tb
argument_list|,
sizeof|sizeof
name|tmpbuf
argument_list|,
operator|&
name|p
argument_list|,
name|fieldsep
argument_list|)
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|tb
argument_list|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|tmpbuf
argument_list|,
literal|"AF_INET"
argument_list|)
operator|==
literal|0
condition|)
name|hoaddrtype
operator|=
name|AF_INET
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|tmpbuf
argument_list|,
literal|"AF_INET6"
argument_list|)
operator|==
literal|0
condition|)
name|hoaddrtype
operator|=
name|AF_INET6
expr_stmt|;
else|else
goto|goto
name|error
goto|;
comment|/* h_length field */
name|tb
operator|=
name|tmpbuf
expr_stmt|;
if|if
condition|(
name|getfield
argument_list|(
operator|&
name|tb
argument_list|,
sizeof|sizeof
name|tmpbuf
argument_list|,
operator|&
name|p
argument_list|,
name|fieldsep
argument_list|)
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|tb
argument_list|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|t
operator|=
name|strtol
argument_list|(
name|tmpbuf
argument_list|,
operator|&
name|tb
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tb
condition|)
block|{
goto|goto
name|error
goto|;
comment|/* junk in value */
block|}
name|holength
operator|=
operator|(
name|int
operator|)
name|t
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|holength
operator|!=
name|t
condition|)
block|{
comment|/* value must have been too big. */
goto|goto
name|error
goto|;
block|}
comment|/* h_addr_list field */
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
comment|/* count how many addresss are in there */
if|if
condition|(
name|q
operator|>
name|p
operator|+
literal|1
condition|)
block|{
for|for
control|(
name|addrcount
operator|=
literal|1
operator|,
name|r
operator|=
name|p
init|;
name|r
operator|!=
name|q
condition|;
name|r
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|r
operator|==
name|COMMA
condition|)
name|addrcount
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|addrcount
operator|=
literal|0
expr_stmt|;
block|}
name|hoaddrsize
operator|=
operator|(
name|addrcount
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
name|hohaddrlist
operator|=
name|malloc
argument_list|(
name|hoaddrsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|hohaddrlist
operator|==
name|NULL
condition|)
block|{
name|myerrno
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|memset
argument_list|(
name|hohaddrlist
argument_list|,
literal|0x0
argument_list|,
name|hoaddrsize
argument_list|)
expr_stmt|;
name|alist
operator|=
name|hohaddrlist
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
operator|,
name|r
operator|=
name|p
init|;
name|r
operator|!=
name|q
condition|;
name|p
operator|=
name|r
operator|+
literal|1
operator|,
name|t
operator|++
control|)
block|{
name|char
name|saved
decl_stmt|;
while|while
condition|(
name|r
operator|!=
name|q
operator|&&
operator|*
name|r
operator|!=
name|COMMA
condition|)
name|r
operator|++
expr_stmt|;
name|saved
operator|=
operator|*
name|r
expr_stmt|;
operator|*
name|r
operator|=
literal|0x0
expr_stmt|;
name|alist
index|[
name|t
index|]
operator|=
name|malloc
argument_list|(
name|hoaddrtype
operator|==
name|AF_INET
condition|?
literal|4
else|:
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|alist
index|[
name|t
index|]
operator|==
name|NULL
condition|)
block|{
name|myerrno
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|inet_pton
argument_list|(
name|hoaddrtype
argument_list|,
name|p
argument_list|,
name|alist
index|[
name|t
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
operator|*
name|r
operator|=
name|saved
expr_stmt|;
block|}
name|alist
index|[
name|t
index|]
operator|=
name|NULL
expr_stmt|;
name|ho
operator|->
name|h_name
operator|=
name|name
expr_stmt|;
name|ho
operator|->
name|h_aliases
operator|=
name|aliases
expr_stmt|;
name|ho
operator|->
name|h_addrtype
operator|=
name|hoaddrtype
expr_stmt|;
name|ho
operator|->
name|h_length
operator|=
name|holength
expr_stmt|;
name|ho
operator|->
name|h_addr_list
operator|=
name|hohaddrlist
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|errno
operator|=
name|myerrno
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free_array
argument_list|(
name|aliases
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------- struct hostent------------------------- */
end_comment

begin_comment
comment|/* +++++++++++++++++++++++++ struct netgrp +++++++++++++++++++++++++ */
end_comment

begin_comment
comment|/*  * int irp_marshall_ng(const char *host, const char *user,  *		       const char *domain, char *buffer, size_t *len)  *  * notes:  *  *	See note for irp_marshall_ng_start  *  * return:  *  *	0 on success, 0 on failure.  *  */
end_comment

begin_function
name|int
name|irp_marshall_ng
parameter_list|(
specifier|const
name|char
modifier|*
name|host
parameter_list|,
specifier|const
name|char
modifier|*
name|user
parameter_list|,
specifier|const
name|char
modifier|*
name|domain
parameter_list|,
name|char
modifier|*
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|size_t
name|need
init|=
literal|1
decl_stmt|;
comment|/* for nul byte */
specifier|const
name|char
modifier|*
name|fieldsep
init|=
literal|","
decl_stmt|;
if|if
condition|(
name|len
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|need
operator|+=
literal|4
expr_stmt|;
comment|/* two parens and two commas */
name|need
operator|+=
operator|(
name|host
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|host
argument_list|)
operator|)
expr_stmt|;
name|need
operator|+=
operator|(
name|user
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|user
argument_list|)
operator|)
expr_stmt|;
name|need
operator|+=
operator|(
name|domain
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|domain
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
operator|*
name|len
operator|=
name|need
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|buffer
operator|!=
name|NULL
operator|&&
name|need
operator|>
operator|*
name|len
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|buffer
operator|==
name|NULL
condition|)
block|{
name|need
operator|+=
literal|2
expr_stmt|;
comment|/* for CRLF */
operator|*
name|buffer
operator|=
name|memget
argument_list|(
name|need
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buffer
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|len
operator|=
name|need
expr_stmt|;
block|}
operator|(
operator|*
name|buffer
operator|)
index|[
literal|0
index|]
operator|=
literal|'('
expr_stmt|;
operator|(
operator|*
name|buffer
operator|)
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|host
operator|!=
name|NULL
condition|)
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
if|if
condition|(
name|user
operator|!=
name|NULL
condition|)
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
if|if
condition|(
name|domain
operator|!=
name|NULL
condition|)
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|domain
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ---------- */
end_comment

begin_comment
comment|/*  * int irp_unmarshall_ng(char **host, char **user, char **domain,  *			 char *buffer)  *  * notes:  *  *	Unpacks the BUFFER into 3 character arrays it allocates and assigns  *	to *HOST, *USER and *DOMAIN. If any field of the value is empty,  *	then the corresponding paramater value will be set to NULL.  *  * return:  *  *	0 on success and -1 on failure.  */
end_comment

begin_function
name|int
name|irp_unmarshall_ng
parameter_list|(
name|char
modifier|*
modifier|*
name|host
parameter_list|,
name|char
modifier|*
modifier|*
name|user
parameter_list|,
name|char
modifier|*
modifier|*
name|domain
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
name|fieldsep
init|=
literal|','
decl_stmt|;
name|int
name|myerrno
init|=
name|EINVAL
decl_stmt|;
if|if
condition|(
name|user
operator|==
name|NULL
operator|||
name|host
operator|==
name|NULL
operator|||
name|domain
operator|==
name|NULL
operator|||
name|buffer
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|host
operator|=
operator|*
name|user
operator|=
operator|*
name|domain
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
name|buffer
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|!=
literal|'('
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|q
operator|=
name|p
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|&&
operator|*
name|q
operator|!=
name|fieldsep
condition|)
name|q
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|q
condition|)
block|{
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
name|q
operator|>
name|p
operator|+
literal|1
condition|)
block|{
operator|*
name|host
operator|=
name|strndup
argument_list|(
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|q
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
block|{
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|!=
name|fieldsep
condition|)
block|{
name|q
operator|=
name|p
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|&&
operator|*
name|q
operator|!=
name|fieldsep
condition|)
name|q
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|q
condition|)
block|{
goto|goto
name|error
goto|;
block|}
operator|*
name|user
operator|=
name|strndup
argument_list|(
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|p
condition|)
block|{
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|!=
literal|')'
condition|)
block|{
name|q
operator|=
name|p
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|&&
operator|*
name|q
operator|!=
literal|')'
condition|)
name|q
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|q
condition|)
block|{
goto|goto
name|error
goto|;
block|}
operator|*
name|domain
operator|=
name|strndup
argument_list|(
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|errno
operator|=
name|myerrno
expr_stmt|;
if|if
condition|(
operator|*
name|host
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|*
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|user
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|*
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|domain
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|*
name|domain
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------- struct netgrp ------------------------- */
end_comment

begin_comment
comment|/* +++++++++++++++++++++++++ struct nwent +++++++++++++++++++++++++ */
end_comment

begin_comment
comment|/*  * int irp_marshall_nw(struct nwent *ne, char **buffer, size_t *len)  *  * notes:  *  *	See at top.  *  * return:  *  *	0 on success and -1 on failure.  *  */
end_comment

begin_function
name|int
name|irp_marshall_nw
parameter_list|(
name|struct
name|nwent
modifier|*
name|ne
parameter_list|,
name|char
modifier|*
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|size_t
name|need
init|=
literal|1
decl_stmt|;
comment|/* for null byte */
name|char
name|nAddrType
index|[
literal|24
index|]
decl_stmt|;
name|char
name|nNet
index|[
name|MAXPADDRSIZE
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|fieldsep
init|=
name|COLONSTR
decl_stmt|;
if|if
condition|(
name|ne
operator|==
name|NULL
operator|||
name|len
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|nAddrType
argument_list|,
name|ADDR_T_STR
argument_list|(
name|ne
operator|->
name|n_addrtype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inet_net_ntop
argument_list|(
name|ne
operator|->
name|n_addrtype
argument_list|,
name|ne
operator|->
name|n_addr
argument_list|,
name|ne
operator|->
name|n_length
argument_list|,
name|nNet
argument_list|,
sizeof|sizeof
name|nNet
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|need
operator|+=
name|strlen
argument_list|(
name|ne
operator|->
name|n_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|need
operator|+=
name|joinlength
argument_list|(
name|ne
operator|->
name|n_aliases
argument_list|)
operator|+
literal|1
expr_stmt|;
name|need
operator|+=
name|strlen
argument_list|(
name|nAddrType
argument_list|)
operator|+
literal|1
expr_stmt|;
name|need
operator|+=
name|strlen
argument_list|(
name|nNet
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
operator|*
name|len
operator|=
name|need
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|buffer
operator|!=
name|NULL
operator|&&
name|need
operator|>
operator|*
name|len
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|buffer
operator|==
name|NULL
condition|)
block|{
name|need
operator|+=
literal|2
expr_stmt|;
comment|/* for CRLF */
operator|*
name|buffer
operator|=
name|memget
argument_list|(
name|need
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buffer
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|len
operator|=
name|need
expr_stmt|;
block|}
name|strcpy
argument_list|(
operator|*
name|buffer
argument_list|,
name|ne
operator|->
name|n_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
name|joinarray
argument_list|(
name|ne
operator|->
name|n_aliases
argument_list|,
operator|*
name|buffer
argument_list|,
name|COMMA
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|nAddrType
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|nNet
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * int irp_unmarshall_nw(struct nwent *ne, char *buffer)  *  * notes:  *  *	See note up top.  *  * return:  *  *	0 on success and -1 on failure.  *  */
end_comment

begin_function
name|int
name|irp_unmarshall_nw
parameter_list|(
name|struct
name|nwent
modifier|*
name|ne
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|naddrtype
decl_stmt|;
name|long
name|nnet
decl_stmt|;
name|int
name|bits
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
modifier|*
name|aliases
init|=
name|NULL
decl_stmt|;
name|char
name|tmpbuf
index|[
literal|24
index|]
decl_stmt|;
name|char
modifier|*
name|tb
decl_stmt|;
name|char
name|fieldsep
init|=
literal|':'
decl_stmt|;
name|int
name|myerrno
init|=
name|EINVAL
decl_stmt|;
if|if
condition|(
name|ne
operator|==
name|NULL
operator|||
name|buffer
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|p
operator|=
name|buffer
expr_stmt|;
comment|/* n_name field */
name|name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|getfield
argument_list|(
operator|&
name|name
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|,
name|fieldsep
argument_list|)
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/* n_aliases field. Aliases are separated by commas */
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|aliases
operator|=
name|splitarray
argument_list|(
name|p
argument_list|,
name|q
argument_list|,
name|COMMA
argument_list|)
expr_stmt|;
if|if
condition|(
name|aliases
operator|==
name|NULL
condition|)
block|{
name|myerrno
operator|=
name|errno
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|p
operator|=
name|q
operator|+
literal|1
expr_stmt|;
comment|/* h_addrtype field */
name|tb
operator|=
name|tmpbuf
expr_stmt|;
if|if
condition|(
name|getfield
argument_list|(
operator|&
name|tb
argument_list|,
sizeof|sizeof
name|tmpbuf
argument_list|,
operator|&
name|p
argument_list|,
name|fieldsep
argument_list|)
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|tb
argument_list|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|tmpbuf
argument_list|,
literal|"AF_INET"
argument_list|)
operator|==
literal|0
condition|)
name|naddrtype
operator|=
name|AF_INET
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|tmpbuf
argument_list|,
literal|"AF_INET6"
argument_list|)
operator|==
literal|0
condition|)
name|naddrtype
operator|=
name|AF_INET6
expr_stmt|;
else|else
goto|goto
name|error
goto|;
comment|/* n_net field */
name|tb
operator|=
name|tmpbuf
expr_stmt|;
if|if
condition|(
name|getfield
argument_list|(
operator|&
name|tb
argument_list|,
sizeof|sizeof
name|tmpbuf
argument_list|,
operator|&
name|p
argument_list|,
name|fieldsep
argument_list|)
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|tb
argument_list|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|nnet
operator|=
literal|0
expr_stmt|;
name|bits
operator|=
name|inet_net_pton
argument_list|(
name|naddrtype
argument_list|,
name|tmpbuf
argument_list|,
operator|&
name|nnet
argument_list|,
sizeof|sizeof
name|nnet
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
operator|<
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/* nnet = ntohl(nnet); */
comment|/* keep in network order for nwent */
name|ne
operator|->
name|n_name
operator|=
name|name
expr_stmt|;
name|ne
operator|->
name|n_aliases
operator|=
name|aliases
expr_stmt|;
name|ne
operator|->
name|n_addrtype
operator|=
name|naddrtype
expr_stmt|;
name|ne
operator|->
name|n_length
operator|=
name|bits
expr_stmt|;
name|ne
operator|->
name|n_addr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
name|nnet
argument_list|)
expr_stmt|;
if|if
condition|(
name|ne
operator|->
name|n_addr
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|memcpy
argument_list|(
name|ne
operator|->
name|n_addr
argument_list|,
operator|&
name|nnet
argument_list|,
sizeof|sizeof
name|nnet
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|errno
operator|=
name|myerrno
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free_array
argument_list|(
name|aliases
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------- struct nwent ------------------------- */
end_comment

begin_comment
comment|/* +++++++++++++++++++++++++ struct netent +++++++++++++++++++++++++ */
end_comment

begin_comment
comment|/*  * int irp_marshall_ne(struct netent *ne, char **buffer, size_t *len)  *  * notes:  *  *	See at top.  *  * return:  *  *	0 on success and -1 on failure.  *  */
end_comment

begin_function
name|int
name|irp_marshall_ne
parameter_list|(
name|struct
name|netent
modifier|*
name|ne
parameter_list|,
name|char
modifier|*
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|size_t
name|need
init|=
literal|1
decl_stmt|;
comment|/* for null byte */
name|char
name|nAddrType
index|[
literal|24
index|]
decl_stmt|;
name|char
name|nNet
index|[
name|MAXPADDRSIZE
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|fieldsep
init|=
name|COLONSTR
decl_stmt|;
name|long
name|nval
decl_stmt|;
if|if
condition|(
name|ne
operator|==
name|NULL
operator|||
name|len
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|nAddrType
argument_list|,
name|ADDR_T_STR
argument_list|(
name|ne
operator|->
name|n_addrtype
argument_list|)
argument_list|)
expr_stmt|;
name|nval
operator|=
name|htonl
argument_list|(
name|ne
operator|->
name|n_net
argument_list|)
expr_stmt|;
if|if
condition|(
name|inet_ntop
argument_list|(
name|ne
operator|->
name|n_addrtype
argument_list|,
operator|&
name|nval
argument_list|,
name|nNet
argument_list|,
sizeof|sizeof
name|nNet
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|need
operator|+=
name|strlen
argument_list|(
name|ne
operator|->
name|n_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|need
operator|+=
name|joinlength
argument_list|(
name|ne
operator|->
name|n_aliases
argument_list|)
operator|+
literal|1
expr_stmt|;
name|need
operator|+=
name|strlen
argument_list|(
name|nAddrType
argument_list|)
operator|+
literal|1
expr_stmt|;
name|need
operator|+=
name|strlen
argument_list|(
name|nNet
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
operator|*
name|len
operator|=
name|need
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|buffer
operator|!=
name|NULL
operator|&&
name|need
operator|>
operator|*
name|len
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|buffer
operator|==
name|NULL
condition|)
block|{
name|need
operator|+=
literal|2
expr_stmt|;
comment|/* for CRLF */
operator|*
name|buffer
operator|=
name|memget
argument_list|(
name|need
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buffer
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|len
operator|=
name|need
expr_stmt|;
block|}
name|strcpy
argument_list|(
operator|*
name|buffer
argument_list|,
name|ne
operator|->
name|n_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
name|joinarray
argument_list|(
name|ne
operator|->
name|n_aliases
argument_list|,
operator|*
name|buffer
argument_list|,
name|COMMA
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|nAddrType
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|nNet
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|buffer
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * int irp_unmarshall_ne(struct netent *ne, char *buffer)  *  * notes:  *  *	See note up top.  *  * return:  *  *	0 on success and -1 on failure.  *  */
end_comment

begin_function
name|int
name|irp_unmarshall_ne
parameter_list|(
name|struct
name|netent
modifier|*
name|ne
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|naddrtype
decl_stmt|;
name|long
name|nnet
decl_stmt|;
name|int
name|bits
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
modifier|*
name|aliases
init|=
name|NULL
decl_stmt|;
name|char
name|tmpbuf
index|[
literal|24
index|]
decl_stmt|;
name|char
modifier|*
name|tb
decl_stmt|;
name|char
name|fieldsep
init|=
literal|':'
decl_stmt|;
name|int
name|myerrno
init|=
name|EINVAL
decl_stmt|;
if|if
condition|(
name|ne
operator|==
name|NULL
operator|||
name|buffer
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|p
operator|=
name|buffer
expr_stmt|;
comment|/* n_name field */
name|name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|getfield
argument_list|(
operator|&
name|name
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|,
name|fieldsep
argument_list|)
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/* n_aliases field. Aliases are separated by commas */
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
name|fieldsep
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|aliases
operator|=
name|splitarray
argument_list|(
name|p
argument_list|,
name|q
argument_list|,
name|COMMA
argument_list|)
expr_stmt|;
if|if
condition|(
name|aliases
operator|==
name|NULL
condition|)
block|{
name|myerrno
operator|=
name|errno
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|p
operator|=
name|q
operator|+
literal|1
expr_stmt|;
comment|/* h_addrtype field */
name|tb
operator|=
name|tmpbuf
expr_stmt|;
if|if
condition|(
name|getfield
argument_list|(
operator|&
name|tb
argument_list|,
sizeof|sizeof
name|tmpbuf
argument_list|,
operator|&
name|p
argument_list|,
name|fieldsep
argument_list|)
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|tb
argument_list|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|tmpbuf
argument_list|,
literal|"AF_INET"
argument_list|)
operator|==
literal|0
condition|)
name|naddrtype
operator|=
name|AF_INET
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|tmpbuf
argument_list|,
literal|"AF_INET6"
argument_list|)
operator|==
literal|0
condition|)
name|naddrtype
operator|=
name|AF_INET6
expr_stmt|;
else|else
goto|goto
name|error
goto|;
comment|/* n_net field */
name|tb
operator|=
name|tmpbuf
expr_stmt|;
if|if
condition|(
name|getfield
argument_list|(
operator|&
name|tb
argument_list|,
sizeof|sizeof
name|tmpbuf
argument_list|,
operator|&
name|p
argument_list|,
name|fieldsep
argument_list|)
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|tb
argument_list|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|bits
operator|=
name|inet_net_pton
argument_list|(
name|naddrtype
argument_list|,
name|tmpbuf
argument_list|,
operator|&
name|nnet
argument_list|,
sizeof|sizeof
name|nnet
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
operator|<
literal|0
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|nnet
operator|=
name|ntohl
argument_list|(
name|nnet
argument_list|)
expr_stmt|;
name|ne
operator|->
name|n_name
operator|=
name|name
expr_stmt|;
name|ne
operator|->
name|n_aliases
operator|=
name|aliases
expr_stmt|;
name|ne
operator|->
name|n_addrtype
operator|=
name|naddrtype
expr_stmt|;
name|ne
operator|->
name|n_net
operator|=
name|nnet
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|errno
operator|=
name|myerrno
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free_array
argument_list|(
name|aliases
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------- struct netent ------------------------- */
end_comment

begin_comment
comment|/* =========================================================================== */
end_comment

begin_comment
comment|/*  * static char ** splitarray(const char *buffer, const char *buffend, char delim)  *  * notes:  *  *	Split a delim separated astring. Not allowed  *	to have two delims next to each other. BUFFER points to begining of  *	string, BUFFEND points to one past the end of the string  *	(i.e. points at where the null byte would be if null  *	terminated).  *  * return:  *  *	Returns a malloced array of pointers, each pointer pointing to a  *	malloced string. If BUFEER is an empty string, then return values is  *	array of 1 pointer that is NULL. Returns NULL on failure.  *  */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|splitarray
parameter_list|(
specifier|const
name|char
modifier|*
name|buffer
parameter_list|,
specifier|const
name|char
modifier|*
name|buffend
parameter_list|,
name|char
name|delim
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|arr
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
modifier|*
name|aptr
decl_stmt|;
if|if
condition|(
name|buffend
operator|<
name|buffer
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
elseif|else
if|if
condition|(
name|buffend
operator|>
name|buffer
operator|&&
operator|*
name|buffer
operator|==
name|delim
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
elseif|else
if|if
condition|(
name|buffend
operator|>
name|buffer
operator|&&
operator|*
operator|(
name|buffend
operator|-
literal|1
operator|)
operator|==
name|delim
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* count the number of field and make sure none are empty */
if|if
condition|(
name|buffend
operator|>
name|buffer
operator|+
literal|1
condition|)
block|{
for|for
control|(
name|count
operator|=
literal|1
operator|,
name|q
operator|=
name|buffer
init|;
name|q
operator|!=
name|buffend
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
name|delim
condition|)
block|{
if|if
condition|(
name|q
operator|>
name|buffer
operator|&&
operator|(
operator|*
operator|(
name|q
operator|-
literal|1
operator|)
operator|==
name|delim
operator|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|count
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|count
operator|++
expr_stmt|;
comment|/* for NULL at end */
name|aptr
operator|=
name|arr
operator|=
name|malloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|aptr
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|memset
argument_list|(
name|arr
argument_list|,
literal|0x0
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buffer
init|;
name|p
operator|<
name|buffend
condition|;
name|p
operator|++
control|)
block|{
for|for
control|(
name|q
operator|=
name|p
init|;
operator|*
name|q
operator|!=
name|delim
operator|&&
name|q
operator|!=
name|buffend
condition|;
name|q
operator|++
control|)
comment|/* nothing */
empty_stmt|;
operator|*
name|aptr
operator|=
name|strndup
argument_list|(
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
name|aptr
operator|++
expr_stmt|;
block|}
operator|*
name|aptr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|arr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arr
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|arr
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|arr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * static size_t joinlength(char * const *argv)  *  * return:  *  *	the number of bytes in all the arrays pointed at  *	by argv, including their null bytes(which will usually be turned  *	into commas).  *  *  */
end_comment

begin_function
specifier|static
name|size_t
name|joinlength
parameter_list|(
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|argv
operator|&&
operator|*
name|argv
condition|)
block|{
name|len
operator|+=
operator|(
name|strlen
argument_list|(
operator|*
name|argv
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * int joinarray(char * const *argv, char *buffer, char delim)  *  * notes:  *  *	Copy all the ARGV strings into the end of BUFFER  *	separating them with DELIM.  BUFFER is assumed to have  *	enough space to hold everything and to be already null-terminated.  *  * return:  *  *	0 unless argv or buffer is NULL.  *  *  */
end_comment

begin_function
specifier|static
name|int
name|joinarray
parameter_list|(
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|char
name|delim
parameter_list|)
block|{
name|char
modifier|*
specifier|const
modifier|*
name|p
decl_stmt|;
name|char
name|sep
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|argv
operator|==
name|NULL
operator|||
name|buffer
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|sep
index|[
literal|0
index|]
operator|=
name|delim
expr_stmt|;
name|sep
index|[
literal|1
index|]
operator|=
literal|0x0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|argv
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
block|{
name|strcat
argument_list|(
name|buffer
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|buffer
argument_list|,
name|sep
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * static char * getfield(char **res, size_t reslen, char **ptr, char delim)  *  * notes:  *  *	Stores in *RES, which is a buffer of length RESLEN, a  *	copy of the bytes from *PTR up to and including the first  *	instance of DELIM. If *RES is NULL, then it will be  *	assigned a malloced buffer to hold the copy. *PTR is  *	modified to point at the found delimiter.  *  * return:  *  *	If there was no delimiter, then NULL is returned,  *	otherewise *RES is returned.  *  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|getfield
parameter_list|(
name|char
modifier|*
modifier|*
name|res
parameter_list|,
name|size_t
name|reslen
parameter_list|,
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|char
name|delim
parameter_list|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
operator|||
name|ptr
operator|==
name|NULL
operator|||
operator|*
name|ptr
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|q
operator|=
name|strchr
argument_list|(
operator|*
name|ptr
argument_list|,
name|delim
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|res
operator|==
name|NULL
condition|)
block|{
operator|*
name|res
operator|=
name|strndup
argument_list|(
operator|*
name|ptr
argument_list|,
name|q
operator|-
operator|*
name|ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|q
operator|-
operator|*
name|ptr
operator|+
literal|1
operator|>
name|reslen
condition|)
block|{
comment|/* to big for res */
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
name|strncpy
argument_list|(
operator|*
name|res
argument_list|,
operator|*
name|ptr
argument_list|,
name|q
operator|-
operator|*
name|ptr
argument_list|)
expr_stmt|;
operator|(
operator|*
name|res
operator|)
index|[
name|q
operator|-
operator|*
name|ptr
index|]
operator|=
literal|0x0
expr_stmt|;
block|}
block|}
operator|*
name|ptr
operator|=
name|q
operator|+
literal|1
expr_stmt|;
block|}
return|return
operator|(
operator|*
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * static char * strndup(const char *str, size_t len)  *  * notes:  *  *	like strdup, except do len bytes instead of the whole string. Always  *	null-terminates.  *  * return:  *  *	The newly malloced string.  *  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|strndup
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|strncpy
argument_list|(
name|p
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
index|[
name|len
index|]
operator|=
literal|0x0
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|WANT_MAIN
end_if

begin_comment
comment|/*  * static int strcmp_nws(const char *a, const char *b)  *  * notes:  *  *	do a strcmp, except uneven lengths of whitespace compare the same  *  * return:  *  */
end_comment

begin_function
specifier|static
name|int
name|strcmp_nws
parameter_list|(
specifier|const
name|char
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|b
parameter_list|)
block|{
while|while
condition|(
operator|*
name|a
operator|&&
operator|*
name|b
condition|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|a
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|b
argument_list|)
condition|)
block|{
do|do
block|{
name|a
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|isspace
argument_list|(
operator|*
name|a
argument_list|)
condition|)
do|;
do|do
block|{
name|b
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|isspace
argument_list|(
operator|*
name|b
argument_list|)
condition|)
do|;
block|}
if|if
condition|(
operator|*
name|a
operator|<
operator|*
name|b
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
operator|*
name|a
operator|>
operator|*
name|b
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|a
operator|++
expr_stmt|;
name|b
operator|++
expr_stmt|;
empty_stmt|;
block|}
if|if
condition|(
operator|*
name|a
operator|==
operator|*
name|b
condition|)
return|return
operator|(
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
operator|*
name|a
operator|>
operator|*
name|b
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * static void free_array(char **argv, size_t entries)  *  * notes:  *  *	Free argv and each of the pointers inside it. The end of  *	the array is when a NULL pointer is found inside. If  *	entries is> 0, then NULL pointers inside the array do  *	not indicate the end of the array.  *  */
end_comment

begin_function
specifier|static
name|void
name|free_array
parameter_list|(
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|size_t
name|entries
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|p
init|=
name|argv
decl_stmt|;
name|int
name|useEntries
init|=
operator|(
name|entries
operator|>
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|argv
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
operator|(
name|useEntries
operator|&&
name|entries
operator|>
literal|0
operator|)
operator|||
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
condition|)
name|free
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|useEntries
condition|)
name|entries
operator|--
expr_stmt|;
block|}
name|free
argument_list|(
name|argv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ************************************************** */
end_comment

begin_if
if|#
directive|if
name|WANT_MAIN
end_if

begin_comment
comment|/* takes an option to indicate what sort of marshalling(read the code) and    an argument. If the argument looks like a marshalled buffer(has a ':'    embedded) then it's unmarshalled and the remarshalled and the new string    is compared to the old one. */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|b
init|=
operator|&
name|buffer
index|[
literal|0
index|]
decl_stmt|;
name|size_t
name|len
init|=
sizeof|sizeof
name|buffer
decl_stmt|;
name|char
name|option
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
operator|||
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|option
operator|=
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
if|#
directive|if
literal|0
block|{ 		char buff[10]; 		char *p = argv[1], *q =&buff[0];  		while (getfield(&q, sizeof buff,&p, ':') != NULL) { 			printf("field: \"%s\"\n", q); 			p++; 		} 		printf("p is now \"%s\"\n", p); 	}
endif|#
directive|endif
if|#
directive|if
literal|0
block|{ 		char **x = splitarray(argv[1], argv[1] + strlen(argv[1]), 				      argv[2][0]); 		char **p;  		if (x == NULL) 			printf("split failed\n");  		for (p = x ; p != NULL&& *p != NULL ; p++) { 			printf("\"%s\"\n", *p); 		} 	}
endif|#
directive|endif
if|#
directive|if
literal|1
switch|switch
condition|(
name|option
condition|)
block|{
case|case
literal|'n'
case|:
block|{
name|struct
name|nwent
name|ne
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|':'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|irp_unmarshall_nw
argument_list|(
operator|&
name|ne
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Unmarhsalling failed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Name: \"%s\"\n"
argument_list|,
name|ne
operator|.
name|n_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Aliases:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ne
operator|.
name|n_aliases
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"\n\t\"%s\""
argument_list|,
name|ne
operator|.
name|n_aliases
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nAddrtype: %s\n"
argument_list|,
name|ADDR_T_STR
argument_list|(
name|ne
operator|.
name|n_addrtype
argument_list|)
argument_list|)
expr_stmt|;
name|inet_net_ntop
argument_list|(
name|ne
operator|.
name|n_addrtype
argument_list|,
name|ne
operator|.
name|n_addr
argument_list|,
name|ne
operator|.
name|n_length
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Net: \"%s\"\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
name|ne
operator|.
name|n_addr
operator|)
operator|=
name|htonl
argument_list|(
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
name|ne
operator|.
name|n_addr
operator|)
argument_list|)
expr_stmt|;
name|inet_net_ntop
argument_list|(
name|ne
operator|.
name|n_addrtype
argument_list|,
name|ne
operator|.
name|n_addr
argument_list|,
name|ne
operator|.
name|n_length
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Corrected Net: \"%s\"\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|netent
modifier|*
name|np1
init|=
name|getnetbyname
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|ne
operator|.
name|n_name
operator|=
name|np1
operator|->
name|n_name
expr_stmt|;
name|ne
operator|.
name|n_aliases
operator|=
name|np1
operator|->
name|n_aliases
expr_stmt|;
name|ne
operator|.
name|n_addrtype
operator|=
name|np1
operator|->
name|n_addrtype
expr_stmt|;
name|ne
operator|.
name|n_addr
operator|=
operator|&
name|np1
operator|->
name|n_net
expr_stmt|;
name|ne
operator|.
name|n_length
operator|=
operator|(
name|IN_CLASSA
argument_list|(
name|np1
operator|->
name|n_net
argument_list|)
condition|?
literal|8
else|:
operator|(
name|IN_CLASSB
argument_list|(
name|np1
operator|->
name|n_net
argument_list|)
condition|?
literal|16
else|:
operator|(
name|IN_CLASSC
argument_list|(
name|np1
operator|->
name|n_net
argument_list|)
condition|?
literal|24
else|:
operator|-
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
name|np1
operator|->
name|n_net
operator|=
name|htonl
argument_list|(
name|np1
operator|->
name|n_net
argument_list|)
expr_stmt|;
if|if
condition|(
name|irp_marshall_nw
argument_list|(
operator|&
name|ne
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Marshalling failed\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'r'
case|:
block|{
name|char
modifier|*
modifier|*
name|hosts
decl_stmt|,
modifier|*
modifier|*
name|users
decl_stmt|,
modifier|*
modifier|*
name|domains
decl_stmt|;
name|size_t
name|entries
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|buff
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|char
modifier|*
name|ngname
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|'('
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|irp_unmarshall_ng
argument_list|(
operator|&
name|ngname
argument_list|,
operator|&
name|entries
argument_list|,
operator|&
name|hosts
argument_list|,
operator|&
name|users
argument_list|,
operator|&
name|domains
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"unmarshall failed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
define|#
directive|define
name|STRVAL
parameter_list|(
name|x
parameter_list|)
value|(x == NULL ? "*" : x)
name|printf
argument_list|(
literal|"%s {\n"
argument_list|,
name|ngname
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"\t\"%s\" : \"%s\" : \"%s\"\n"
argument_list|,
name|STRVAL
argument_list|(
name|hosts
index|[
name|i
index|]
argument_list|)
argument_list|,
name|STRVAL
argument_list|(
name|users
index|[
name|i
index|]
argument_list|)
argument_list|,
name|STRVAL
argument_list|(
name|domains
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"}\n\n\n"
argument_list|)
expr_stmt|;
name|irp_marshall_ng_start
argument_list|(
name|ngname
argument_list|,
name|NULL
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
condition|;
name|i
operator|++
control|)
name|irp_marshall_ng_next
argument_list|(
name|hosts
index|[
name|i
index|]
argument_list|,
name|users
index|[
name|i
index|]
argument_list|,
name|domains
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|irp_marshall_ng_end
argument_list|(
name|NULL
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|buff
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|irp_marshall_ng_start
argument_list|(
name|ngname
argument_list|,
name|buff
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|irp_marshall_ng_next
argument_list|(
name|hosts
index|[
name|i
index|]
argument_list|,
name|users
index|[
name|i
index|]
argument_list|,
name|domains
index|[
name|i
index|]
argument_list|,
name|buff
argument_list|,
operator|&
name|size
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"next marshalling failed.\n"
argument_list|)
expr_stmt|;
block|}
name|irp_marshall_ng_end
argument_list|(
name|buff
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp_nws
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|buff
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"compare failed:\n\t%s\n\t%s\n"
argument_list|,
name|buffer
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"compare ok\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|h
decl_stmt|,
modifier|*
name|u
decl_stmt|,
modifier|*
name|d
decl_stmt|,
modifier|*
name|buff
decl_stmt|;
name|size_t
name|size
decl_stmt|;
comment|/* run through two times. First to figure out how 			   much of a buffer we need. Second to do the 			   actual marshalling */
name|setnetgrent
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|irp_marshall_ng_start
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
while|while
condition|(
name|getnetgrent
argument_list|(
operator|&
name|h
argument_list|,
operator|&
name|u
argument_list|,
operator|&
name|d
argument_list|)
operator|==
literal|1
condition|)
name|irp_marshall_ng_next
argument_list|(
name|h
argument_list|,
name|u
argument_list|,
name|d
argument_list|,
name|NULL
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|irp_marshall_ng_end
argument_list|(
name|NULL
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|endnetgrent
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|buff
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|setnetgrent
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|irp_marshall_ng_start
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|buff
argument_list|,
operator|&
name|size
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Marshalling start failed\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|getnetgrent
argument_list|(
operator|&
name|h
argument_list|,
operator|&
name|u
argument_list|,
operator|&
name|d
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|irp_marshall_ng_next
argument_list|(
name|h
argument_list|,
name|u
argument_list|,
name|d
argument_list|,
name|buff
argument_list|,
operator|&
name|size
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Marshalling failed\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|irp_marshall_ng_end
argument_list|(
name|buff
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|endnetgrent
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"success: %s\n"
argument_list|,
name|buff
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'h'
case|:
block|{
name|struct
name|hostent
name|he
decl_stmt|,
modifier|*
name|hp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|'@'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|irp_unmarshall_ho
argument_list|(
operator|&
name|he
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"unmarshall failed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Host: \"%s\"\nAliases:"
argument_list|,
name|he
operator|.
name|h_name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|he
operator|.
name|h_aliases
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"\n\t\t\"%s\""
argument_list|,
name|he
operator|.
name|h_aliases
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nAddr Type: \"%s\"\n"
argument_list|,
name|ADDR_T_STR
argument_list|(
name|he
operator|.
name|h_addrtype
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Length: %d\nAddresses:"
argument_list|,
name|he
operator|.
name|h_length
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|he
operator|.
name|h_addr_list
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|inet_ntop
argument_list|(
name|he
operator|.
name|h_addrtype
argument_list|,
name|he
operator|.
name|h_addr_list
index|[
name|i
index|]
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\t\"%s\"\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
name|irp_marshall_ho
argument_list|(
operator|&
name|he
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|buffer
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"compare failed:\n\t\"%s\"\n\t\"%s\"\n"
argument_list|,
name|buffer
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"compare ok\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"gethostbyname"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\"%s\"\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|irp_marshall_ho
argument_list|(
name|hp
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"irp_marshall_ho failed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"success: \"%s\"\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'s'
case|:
block|{
name|struct
name|servent
modifier|*
name|sv
decl_stmt|;
name|struct
name|servent
name|sv1
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|':'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|sv
operator|=
operator|&
name|sv1
expr_stmt|;
name|memset
argument_list|(
name|sv
argument_list|,
literal|0xef
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|servent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|irp_unmarshall_sv
argument_list|(
name|sv
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"unmarshall failed\n"
argument_list|)
expr_stmt|;
block|}
name|irp_marshall_sv
argument_list|(
name|sv
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|buffer
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"compare failed:\n\t\"%s\"\n\t\"%s\"\n"
argument_list|,
name|buffer
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"compare ok\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sv
operator|=
name|getservbyname
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"getservent"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|irp_marshall_sv
argument_list|(
name|sv
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"irp_marshall_sv failed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"success: \"%s\"\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'g'
case|:
block|{
name|struct
name|group
modifier|*
name|gr
decl_stmt|;
name|struct
name|group
name|gr1
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|':'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|gr
operator|=
operator|&
name|gr1
expr_stmt|;
name|memset
argument_list|(
name|gr
argument_list|,
literal|0xef
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|irp_unmarshall_gr
argument_list|(
name|gr
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"unmarshall failed\n"
argument_list|)
expr_stmt|;
block|}
name|irp_marshall_gr
argument_list|(
name|gr
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|buffer
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"compare failed:\n\t\"%s\"\n\t\"%s\"\n"
argument_list|,
name|buffer
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"compare ok\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|gr
operator|=
name|getgrnam
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"getgrnam"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|irp_marshall_gr
argument_list|(
name|gr
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"irp_marshall_gr failed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"success: \"%s\"\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'p'
case|:
block|{
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|struct
name|passwd
name|pw1
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|':'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|pw
operator|=
operator|&
name|pw1
expr_stmt|;
name|memset
argument_list|(
name|pw
argument_list|,
literal|0xef
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|irp_unmarshall_pw
argument_list|(
name|pw
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"unmarshall failed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"User: \"%s\"\nPasswd: \"%s\"\nUid: %ld\nGid: %ld\n"
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
name|pw
operator|->
name|pw_passwd
argument_list|,
operator|(
name|long
operator|)
name|pw
operator|->
name|pw_uid
argument_list|,
operator|(
name|long
operator|)
name|pw
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Class: \"%s\"\nChange: %ld\nGecos: \"%s\"\n"
argument_list|,
name|pw
operator|->
name|pw_class
argument_list|,
operator|(
name|long
operator|)
name|pw
operator|->
name|pw_change
argument_list|,
name|pw
operator|->
name|pw_gecos
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Shell: \"%s\"\nDirectory: \"%s\"\n"
argument_list|,
name|pw
operator|->
name|pw_shell
argument_list|,
name|pw
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|pw
operator|=
name|getpwnam
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|irp_marshall_pw
argument_list|(
name|pw
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|buffer
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"compare failed:\n\t\"%s\"\n\t\"%s\"\n"
argument_list|,
name|buffer
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"compare ok\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"getpwnam"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|irp_marshall_pw
argument_list|(
name|pw
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"irp_marshall_pw failed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"success: \"%s\"\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|printf
argument_list|(
literal|"Wrong option: %c\n"
argument_list|,
name|option
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

