begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|LINT
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: tree.c,v 8.10 2001/11/01 05:33:46 marka Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * tree - balanced binary tree library  *  * vix 05apr94 [removed vixie.h dependencies; cleaned up formatting, names]  * vix 22jan93 [revisited; uses RCS, ANSI, POSIX; has bug fixes]  * vix 23jun86 [added delete uar to add for replaced nodes]  * vix 20jun86 [added tree_delete per wirth a+ds (mod2 v.) p. 224]  * vix 06feb86 [added tree_mung()]  * vix 02feb86 [added tree balancing from wirth "a+ds=p" p. 220-221]  * vix 14dec85 [written]  */
end_comment

begin_comment
comment|/*  * This program text was created by Paul Vixie using examples from the book:  * "Algorithms& Data Structures," Niklaus Wirth, Prentice-Hall, 1986, ISBN  * 0-13-022005-1.  Any errors in the conversion from Modula-2 to C are Paul  * Vixie's.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1996-1999 by Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/*#define		DEBUG	"tree"*/
end_comment

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_include
include|#
directive|include
file|<isc/memcluster.h>
end_include

begin_include
include|#
directive|include
file|<isc/tree.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|debugDepth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|debugFuncs
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ENTER
parameter_list|(
name|proc
parameter_list|)
value|{ \ 			debugFuncs[debugDepth] = proc; \ 			fprintf(stderr, "ENTER(%d:%s.%s)\n", \ 				debugDepth, DEBUG, \ 				debugFuncs[debugDepth]); \ 			debugDepth++; \ 		}
end_define

begin_define
define|#
directive|define
name|RET
parameter_list|(
name|value
parameter_list|)
value|{ \ 			debugDepth--; \ 			fprintf(stderr, "RET(%d:%s.%s)\n", \ 				debugDepth, DEBUG, \ 				debugFuncs[debugDepth]); \ 			return (value); \ 		}
end_define

begin_define
define|#
directive|define
name|RETV
value|{ \ 			debugDepth--; \ 			fprintf(stderr, "RETV(%d:%s.%s)\n", \ 				debugDepth, DEBUG, \ 				debugFuncs[debugDepth]); \ 			return; \ 		}
end_define

begin_define
define|#
directive|define
name|MSG
parameter_list|(
name|msg
parameter_list|)
value|fprintf(stderr, "MSG(%s)\n", msg);
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ENTER
parameter_list|(
name|proc
parameter_list|)
value|;
end_define

begin_define
define|#
directive|define
name|RET
parameter_list|(
name|value
parameter_list|)
value|return (value);
end_define

begin_define
define|#
directive|define
name|RETV
value|return;
end_define

begin_define
define|#
directive|define
name|MSG
parameter_list|(
name|msg
parameter_list|)
value|;
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|tree
modifier|*
name|sprout
parameter_list|(
name|tree
modifier|*
modifier|*
parameter_list|,
name|tree_t
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
function_decl|(
modifier|*
function_decl|)
parameter_list|()
parameter_list|,
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|()
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|delete
parameter_list|(
name|tree
modifier|*
modifier|*
parameter_list|,
name|int
function_decl|(
modifier|*
function_decl|)
parameter_list|()
parameter_list|,
name|tree_t
parameter_list|,
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|()
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|del
parameter_list|(
name|tree
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|tree
modifier|*
modifier|*
parameter_list|,
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|()
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bal_L
parameter_list|(
name|tree
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bal_R
parameter_list|(
name|tree
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|tree_init
parameter_list|(
name|tree
modifier|*
modifier|*
name|ppr_tree
parameter_list|)
block|{
name|ENTER
argument_list|(
literal|"tree_init"
argument_list|)
operator|*
name|ppr_tree
operator|=
name|NULL
expr_stmt|;
name|RETV
block|}
end_function

begin_function
name|tree_t
name|tree_srch
parameter_list|(
name|tree
modifier|*
modifier|*
name|ppr_tree
parameter_list|,
name|int
function_decl|(
modifier|*
name|pfi_compare
function_decl|)
parameter_list|(
name|tree_t
parameter_list|,
name|tree_t
parameter_list|)
parameter_list|,
name|tree_t
name|p_user
parameter_list|)
block|{
name|ENTER
argument_list|(
literal|"tree_srch"
argument_list|)
if|if
condition|(
operator|*
name|ppr_tree
condition|)
block|{
name|int
name|i_comp
init|=
call|(
modifier|*
name|pfi_compare
call|)
argument_list|(
name|p_user
argument_list|,
operator|(
operator|*
operator|*
name|ppr_tree
operator|)
operator|.
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|i_comp
operator|>
literal|0
condition|)
name|RET
argument_list|(
argument|tree_srch(&(**ppr_tree).right, 				      pfi_compare, 				      p_user)
argument_list|)
if|if
condition|(
name|i_comp
operator|<
literal|0
condition|)
name|RET
argument_list|(
argument|tree_srch(&(**ppr_tree).left, 				      pfi_compare, 				      p_user)
argument_list|)
comment|/* not higher, not lower... this must be the one. 		 */
name|RET
argument_list|(
argument|(**ppr_tree).data
argument_list|)
block|}
comment|/* grounded. NOT found. 	 */
name|RET
argument_list|(
argument|NULL
argument_list|)
block|}
end_function

begin_function
name|tree_t
name|tree_add
parameter_list|(
name|tree
modifier|*
modifier|*
name|ppr_tree
parameter_list|,
name|int
function_decl|(
modifier|*
name|pfi_compare
function_decl|)
parameter_list|(
name|tree_t
parameter_list|,
name|tree_t
parameter_list|)
parameter_list|,
name|tree_t
name|p_user
parameter_list|,
name|void
function_decl|(
modifier|*
name|pfv_uar
function_decl|)
parameter_list|()
parameter_list|)
block|{
name|int
name|i_balance
init|=
name|FALSE
decl_stmt|;
name|ENTER
argument_list|(
literal|"tree_add"
argument_list|)
if|if
condition|(
operator|!
name|sprout
argument_list|(
name|ppr_tree
argument_list|,
name|p_user
argument_list|,
operator|&
name|i_balance
argument_list|,
name|pfi_compare
argument_list|,
name|pfv_uar
argument_list|)
condition|)
name|RET
argument_list|(
argument|NULL
argument_list|)
name|RET
argument_list|(
argument|p_user
argument_list|)
block|}
end_function

begin_function
name|int
name|tree_delete
parameter_list|(
name|tree
modifier|*
modifier|*
name|ppr_p
parameter_list|,
name|int
function_decl|(
modifier|*
name|pfi_compare
function_decl|)
parameter_list|(
name|tree_t
parameter_list|,
name|tree_t
parameter_list|)
parameter_list|,
name|tree_t
name|p_user
parameter_list|,
name|void
function_decl|(
modifier|*
name|pfv_uar
function_decl|)
parameter_list|()
parameter_list|)
block|{
name|int
name|i_balance
init|=
name|FALSE
decl_stmt|,
name|i_uar_called
init|=
name|FALSE
decl_stmt|;
name|ENTER
argument_list|(
literal|"tree_delete"
argument_list|)
expr_stmt|;
name|RET
argument_list|(
argument|delete(ppr_p, pfi_compare, p_user, pfv_uar,&i_balance,&i_uar_called)
argument_list|)
block|}
end_function

begin_function
name|int
name|tree_trav
parameter_list|(
name|tree
modifier|*
modifier|*
name|ppr_tree
parameter_list|,
name|int
function_decl|(
modifier|*
name|pfi_uar
function_decl|)
parameter_list|(
name|tree_t
parameter_list|)
parameter_list|)
block|{
name|ENTER
argument_list|(
literal|"tree_trav"
argument_list|)
if|if
condition|(
operator|!
operator|*
name|ppr_tree
condition|)
name|RET
argument_list|(
argument|TRUE
argument_list|)
if|if
condition|(
operator|!
name|tree_trav
argument_list|(
operator|&
operator|(
operator|*
operator|*
name|ppr_tree
operator|)
operator|.
name|left
argument_list|,
name|pfi_uar
argument_list|)
condition|)
name|RET
argument_list|(
argument|FALSE
argument_list|)
if|if
condition|(
operator|!
call|(
modifier|*
name|pfi_uar
call|)
argument_list|(
operator|(
operator|*
operator|*
name|ppr_tree
operator|)
operator|.
name|data
argument_list|)
condition|)
name|RET
argument_list|(
argument|FALSE
argument_list|)
if|if
condition|(
operator|!
name|tree_trav
argument_list|(
operator|&
operator|(
operator|*
operator|*
name|ppr_tree
operator|)
operator|.
name|right
argument_list|,
name|pfi_uar
argument_list|)
condition|)
name|RET
argument_list|(
argument|FALSE
argument_list|)
name|RET
argument_list|(
argument|TRUE
argument_list|)
block|}
end_function

begin_function
name|void
name|tree_mung
parameter_list|(
name|tree
modifier|*
modifier|*
name|ppr_tree
parameter_list|,
name|void
function_decl|(
modifier|*
name|pfv_uar
function_decl|)
parameter_list|(
name|tree_t
parameter_list|)
parameter_list|)
block|{
name|ENTER
argument_list|(
literal|"tree_mung"
argument_list|)
if|if
condition|(
operator|*
name|ppr_tree
condition|)
block|{
name|tree_mung
argument_list|(
operator|&
operator|(
operator|*
operator|*
name|ppr_tree
operator|)
operator|.
name|left
argument_list|,
name|pfv_uar
argument_list|)
expr_stmt|;
name|tree_mung
argument_list|(
operator|&
operator|(
operator|*
operator|*
name|ppr_tree
operator|)
operator|.
name|right
argument_list|,
name|pfv_uar
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfv_uar
condition|)
call|(
modifier|*
name|pfv_uar
call|)
argument_list|(
operator|(
operator|*
operator|*
name|ppr_tree
operator|)
operator|.
name|data
argument_list|)
expr_stmt|;
name|memput
argument_list|(
operator|*
name|ppr_tree
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ppr_tree
operator|=
name|NULL
expr_stmt|;
block|}
name|RETV
block|}
end_function

begin_function
specifier|static
name|tree
modifier|*
name|sprout
parameter_list|(
name|tree
modifier|*
modifier|*
name|ppr
parameter_list|,
name|tree_t
name|p_data
parameter_list|,
name|int
modifier|*
name|pi_balance
parameter_list|,
name|int
function_decl|(
modifier|*
name|pfi_compare
function_decl|)
parameter_list|(
name|tree_t
parameter_list|,
name|tree_t
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|pfv_delete
function_decl|)
parameter_list|(
name|tree_t
parameter_list|)
parameter_list|)
block|{
name|tree
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|sub
decl_stmt|;
name|int
name|cmp
decl_stmt|;
name|ENTER
argument_list|(
literal|"sprout"
argument_list|)
comment|/* are we grounded?  if so, add the node "here" and set the rebalance 	 * flag, then exit. 	 */
if|if
condition|(
operator|!
operator|*
name|ppr
condition|)
block|{
name|MSG
argument_list|(
literal|"grounded. adding new node, setting h=true"
argument_list|)
operator|*
name|ppr
operator|=
operator|(
name|tree
operator|*
operator|)
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ppr
condition|)
block|{
operator|(
operator|*
name|ppr
operator|)
operator|->
name|left
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|ppr
operator|)
operator|->
name|right
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|ppr
operator|)
operator|->
name|bal
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|ppr
operator|)
operator|->
name|data
operator|=
name|p_data
expr_stmt|;
operator|*
name|pi_balance
operator|=
name|TRUE
expr_stmt|;
block|}
name|RET
argument_list|(
operator|*
name|ppr
argument_list|)
expr_stmt|;
block|}
comment|/* compare the data using routine passed by caller. 	 */
name|cmp
operator|=
call|(
modifier|*
name|pfi_compare
call|)
argument_list|(
name|p_data
argument_list|,
operator|(
operator|*
name|ppr
operator|)
operator|->
name|data
argument_list|)
expr_stmt|;
comment|/* if LESS, prepare to move to the left. 	 */
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
name|MSG
argument_list|(
literal|"LESS. sprouting left."
argument_list|)
name|sub
operator|=
name|sprout
argument_list|(
operator|&
operator|(
operator|*
name|ppr
operator|)
operator|->
name|left
argument_list|,
name|p_data
argument_list|,
name|pi_balance
argument_list|,
name|pfi_compare
argument_list|,
name|pfv_delete
argument_list|)
expr_stmt|;
if|if
condition|(
name|sub
operator|&&
operator|*
name|pi_balance
condition|)
block|{
comment|/* left branch has grown */
name|MSG
argument_list|(
literal|"LESS: left branch has grown"
argument_list|)
switch|switch
condition|(
operator|(
operator|*
name|ppr
operator|)
operator|->
name|bal
condition|)
block|{
case|case
literal|1
case|:
comment|/* right branch WAS longer; bal is ok now */
name|MSG
argument_list|(
literal|"LESS: case 1.. bal restored implicitly"
argument_list|)
argument_list|(
operator|*
name|ppr
argument_list|)
operator|->
name|bal
operator|=
literal|0
expr_stmt|;
operator|*
name|pi_balance
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* balance WAS okay; now left branch longer */
name|MSG
argument_list|(
literal|"LESS: case 0.. balnce bad but still ok"
argument_list|)
argument_list|(
operator|*
name|ppr
argument_list|)
operator|->
name|bal
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
comment|/* left branch was already too long. rebal */
name|MSG
argument_list|(
literal|"LESS: case -1: rebalancing"
argument_list|)
name|p1
operator|=
operator|(
operator|*
name|ppr
operator|)
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|bal
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* LL */
name|MSG
argument_list|(
literal|"LESS: single LL"
argument_list|)
argument_list|(
operator|*
name|ppr
argument_list|)
operator|->
name|left
operator|=
name|p1
operator|->
name|right
expr_stmt|;
name|p1
operator|->
name|right
operator|=
operator|*
name|ppr
expr_stmt|;
operator|(
operator|*
name|ppr
operator|)
operator|->
name|bal
operator|=
literal|0
expr_stmt|;
operator|*
name|ppr
operator|=
name|p1
expr_stmt|;
block|}
else|else
block|{
comment|/* double LR */
name|MSG
argument_list|(
literal|"LESS: double LR"
argument_list|)
name|p2
operator|=
name|p1
operator|->
name|right
expr_stmt|;
name|p1
operator|->
name|right
operator|=
name|p2
operator|->
name|left
expr_stmt|;
name|p2
operator|->
name|left
operator|=
name|p1
expr_stmt|;
operator|(
operator|*
name|ppr
operator|)
operator|->
name|left
operator|=
name|p2
operator|->
name|right
expr_stmt|;
name|p2
operator|->
name|right
operator|=
operator|*
name|ppr
expr_stmt|;
if|if
condition|(
name|p2
operator|->
name|bal
operator|==
operator|-
literal|1
condition|)
operator|(
operator|*
name|ppr
operator|)
operator|->
name|bal
operator|=
literal|1
expr_stmt|;
else|else
operator|(
operator|*
name|ppr
operator|)
operator|->
name|bal
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p2
operator|->
name|bal
operator|==
literal|1
condition|)
name|p1
operator|->
name|bal
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|p1
operator|->
name|bal
operator|=
literal|0
expr_stmt|;
operator|*
name|ppr
operator|=
name|p2
expr_stmt|;
block|}
comment|/*else*/
operator|(
operator|*
name|ppr
operator|)
operator|->
name|bal
operator|=
literal|0
expr_stmt|;
operator|*
name|pi_balance
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/*switch*/
block|}
comment|/*if*/
name|RET
argument_list|(
argument|sub
argument_list|)
block|}
comment|/*if*/
comment|/* if MORE, prepare to move to the right. 	 */
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
name|MSG
argument_list|(
literal|"MORE: sprouting to the right"
argument_list|)
name|sub
operator|=
name|sprout
argument_list|(
operator|&
operator|(
operator|*
name|ppr
operator|)
operator|->
name|right
argument_list|,
name|p_data
argument_list|,
name|pi_balance
argument_list|,
name|pfi_compare
argument_list|,
name|pfv_delete
argument_list|)
expr_stmt|;
if|if
condition|(
name|sub
operator|&&
operator|*
name|pi_balance
condition|)
block|{
name|MSG
argument_list|(
literal|"MORE: right branch has grown"
argument_list|)
switch|switch
condition|(
operator|(
operator|*
name|ppr
operator|)
operator|->
name|bal
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|MSG
argument_list|(
literal|"MORE: balance was off, fixed implicitly"
argument_list|)
argument_list|(
operator|*
name|ppr
argument_list|)
operator|->
name|bal
operator|=
literal|0
expr_stmt|;
operator|*
name|pi_balance
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|MSG
argument_list|(
literal|"MORE: balance was okay, now off but ok"
argument_list|)
argument_list|(
operator|*
name|ppr
argument_list|)
operator|->
name|bal
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|MSG
argument_list|(
literal|"MORE: balance was off, need to rebalance"
argument_list|)
name|p1
operator|=
operator|(
operator|*
name|ppr
operator|)
operator|->
name|right
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|bal
operator|==
literal|1
condition|)
block|{
comment|/* RR */
name|MSG
argument_list|(
literal|"MORE: single RR"
argument_list|)
argument_list|(
operator|*
name|ppr
argument_list|)
operator|->
name|right
operator|=
name|p1
operator|->
name|left
expr_stmt|;
name|p1
operator|->
name|left
operator|=
operator|*
name|ppr
expr_stmt|;
operator|(
operator|*
name|ppr
operator|)
operator|->
name|bal
operator|=
literal|0
expr_stmt|;
operator|*
name|ppr
operator|=
name|p1
expr_stmt|;
block|}
else|else
block|{
comment|/* double RL */
name|MSG
argument_list|(
literal|"MORE: double RL"
argument_list|)
name|p2
operator|=
name|p1
operator|->
name|left
expr_stmt|;
name|p1
operator|->
name|left
operator|=
name|p2
operator|->
name|right
expr_stmt|;
name|p2
operator|->
name|right
operator|=
name|p1
expr_stmt|;
operator|(
operator|*
name|ppr
operator|)
operator|->
name|right
operator|=
name|p2
operator|->
name|left
expr_stmt|;
name|p2
operator|->
name|left
operator|=
operator|*
name|ppr
expr_stmt|;
if|if
condition|(
name|p2
operator|->
name|bal
operator|==
literal|1
condition|)
operator|(
operator|*
name|ppr
operator|)
operator|->
name|bal
operator|=
operator|-
literal|1
expr_stmt|;
else|else
operator|(
operator|*
name|ppr
operator|)
operator|->
name|bal
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p2
operator|->
name|bal
operator|==
operator|-
literal|1
condition|)
name|p1
operator|->
name|bal
operator|=
literal|1
expr_stmt|;
else|else
name|p1
operator|->
name|bal
operator|=
literal|0
expr_stmt|;
operator|*
name|ppr
operator|=
name|p2
expr_stmt|;
block|}
comment|/*else*/
operator|(
operator|*
name|ppr
operator|)
operator|->
name|bal
operator|=
literal|0
expr_stmt|;
operator|*
name|pi_balance
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/*switch*/
block|}
comment|/*if*/
name|RET
argument_list|(
argument|sub
argument_list|)
block|}
comment|/*if*/
comment|/* not less, not more: this is the same key!  replace... 	 */
name|MSG
argument_list|(
literal|"FOUND: Replacing data value"
argument_list|)
operator|*
name|pi_balance
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|pfv_delete
condition|)
call|(
modifier|*
name|pfv_delete
call|)
argument_list|(
operator|(
operator|*
name|ppr
operator|)
operator|->
name|data
argument_list|)
expr_stmt|;
operator|(
operator|*
name|ppr
operator|)
operator|->
name|data
operator|=
name|p_data
expr_stmt|;
name|RET
argument_list|(
argument|*ppr
argument_list|)
block|}
end_function

begin_function
specifier|static
name|int
name|delete
parameter_list|(
name|tree
modifier|*
modifier|*
name|ppr_p
parameter_list|,
name|int
function_decl|(
modifier|*
name|pfi_compare
function_decl|)
parameter_list|(
name|tree_t
parameter_list|,
name|tree_t
parameter_list|)
parameter_list|,
name|tree_t
name|p_user
parameter_list|,
name|void
function_decl|(
modifier|*
name|pfv_uar
function_decl|)
parameter_list|(
name|tree_t
parameter_list|)
parameter_list|,
name|int
modifier|*
name|pi_balance
parameter_list|,
name|int
modifier|*
name|pi_uar_called
parameter_list|)
block|{
name|tree
modifier|*
name|pr_q
decl_stmt|;
name|int
name|i_comp
decl_stmt|,
name|i_ret
decl_stmt|;
name|ENTER
argument_list|(
literal|"delete"
argument_list|)
if|if
condition|(
operator|*
name|ppr_p
operator|==
name|NULL
condition|)
block|{
name|MSG
argument_list|(
literal|"key not in tree"
argument_list|)
name|RET
argument_list|(
argument|FALSE
argument_list|)
block|}
name|i_comp
operator|=
call|(
modifier|*
name|pfi_compare
call|)
argument_list|(
operator|(
operator|*
name|ppr_p
operator|)
operator|->
name|data
argument_list|,
name|p_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_comp
operator|>
literal|0
condition|)
block|{
name|MSG
argument_list|(
literal|"too high - scan left"
argument_list|)
name|i_ret
operator|=
name|delete
argument_list|(
operator|&
operator|(
operator|*
name|ppr_p
operator|)
operator|->
name|left
argument_list|,
name|pfi_compare
argument_list|,
name|p_user
argument_list|,
name|pfv_uar
argument_list|,
name|pi_balance
argument_list|,
name|pi_uar_called
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pi_balance
condition|)
name|bal_L
argument_list|(
name|ppr_p
argument_list|,
name|pi_balance
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i_comp
operator|<
literal|0
condition|)
block|{
name|MSG
argument_list|(
literal|"too low - scan right"
argument_list|)
name|i_ret
operator|=
name|delete
argument_list|(
operator|&
operator|(
operator|*
name|ppr_p
operator|)
operator|->
name|right
argument_list|,
name|pfi_compare
argument_list|,
name|p_user
argument_list|,
name|pfv_uar
argument_list|,
name|pi_balance
argument_list|,
name|pi_uar_called
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pi_balance
condition|)
name|bal_R
argument_list|(
name|ppr_p
argument_list|,
name|pi_balance
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MSG
argument_list|(
literal|"equal"
argument_list|)
name|pr_q
operator|=
operator|*
name|ppr_p
expr_stmt|;
if|if
condition|(
name|pr_q
operator|->
name|right
operator|==
name|NULL
condition|)
block|{
name|MSG
argument_list|(
literal|"right subtree null"
argument_list|)
operator|*
name|ppr_p
operator|=
name|pr_q
operator|->
name|left
expr_stmt|;
operator|*
name|pi_balance
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pr_q
operator|->
name|left
operator|==
name|NULL
condition|)
block|{
name|MSG
argument_list|(
literal|"right subtree non-null, left subtree null"
argument_list|)
operator|*
name|ppr_p
operator|=
name|pr_q
operator|->
name|right
expr_stmt|;
operator|*
name|pi_balance
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|MSG
argument_list|(
literal|"neither subtree null"
argument_list|)
name|del
argument_list|(
operator|&
name|pr_q
operator|->
name|left
argument_list|,
name|pi_balance
argument_list|,
operator|&
name|pr_q
argument_list|,
name|pfv_uar
argument_list|,
name|pi_uar_called
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pi_balance
condition|)
name|bal_L
argument_list|(
name|ppr_p
argument_list|,
name|pi_balance
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|pi_uar_called
operator|&&
name|pfv_uar
condition|)
call|(
modifier|*
name|pfv_uar
call|)
argument_list|(
name|pr_q
operator|->
name|data
argument_list|)
expr_stmt|;
comment|/* Thanks to wuth@castrov.cuc.ab.ca for the following stmt. */
name|memput
argument_list|(
name|pr_q
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|i_ret
operator|=
name|TRUE
expr_stmt|;
block|}
name|RET
argument_list|(
argument|i_ret
argument_list|)
block|}
end_function

begin_function
specifier|static
name|void
name|del
parameter_list|(
name|tree
modifier|*
modifier|*
name|ppr_r
parameter_list|,
name|int
modifier|*
name|pi_balance
parameter_list|,
name|tree
modifier|*
modifier|*
name|ppr_q
parameter_list|,
name|void
function_decl|(
modifier|*
name|pfv_uar
function_decl|)
parameter_list|(
name|tree_t
parameter_list|)
parameter_list|,
name|int
modifier|*
name|pi_uar_called
parameter_list|)
block|{
name|ENTER
argument_list|(
literal|"del"
argument_list|)
if|if
condition|(
operator|(
operator|*
name|ppr_r
operator|)
operator|->
name|right
operator|!=
name|NULL
condition|)
block|{
name|del
argument_list|(
operator|&
operator|(
operator|*
name|ppr_r
operator|)
operator|->
name|right
argument_list|,
name|pi_balance
argument_list|,
name|ppr_q
argument_list|,
name|pfv_uar
argument_list|,
name|pi_uar_called
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pi_balance
condition|)
name|bal_R
argument_list|(
name|ppr_r
argument_list|,
name|pi_balance
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pfv_uar
condition|)
call|(
modifier|*
name|pfv_uar
call|)
argument_list|(
operator|(
operator|*
name|ppr_q
operator|)
operator|->
name|data
argument_list|)
expr_stmt|;
operator|*
name|pi_uar_called
operator|=
name|TRUE
expr_stmt|;
operator|(
operator|*
name|ppr_q
operator|)
operator|->
name|data
operator|=
operator|(
operator|*
name|ppr_r
operator|)
operator|->
name|data
expr_stmt|;
operator|*
name|ppr_q
operator|=
operator|*
name|ppr_r
expr_stmt|;
operator|*
name|ppr_r
operator|=
operator|(
operator|*
name|ppr_r
operator|)
operator|->
name|left
expr_stmt|;
operator|*
name|pi_balance
operator|=
name|TRUE
expr_stmt|;
block|}
name|RETV
block|}
end_function

begin_function
specifier|static
name|void
name|bal_L
parameter_list|(
name|tree
modifier|*
modifier|*
name|ppr_p
parameter_list|,
name|int
modifier|*
name|pi_balance
parameter_list|)
block|{
name|tree
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|int
name|b1
decl_stmt|,
name|b2
decl_stmt|;
name|ENTER
argument_list|(
literal|"bal_L"
argument_list|)
name|MSG
argument_list|(
literal|"left branch has shrunk"
argument_list|)
switch|switch
condition|(
operator|(
operator|*
name|ppr_p
operator|)
operator|->
name|bal
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|MSG
argument_list|(
literal|"was imbalanced, fixed implicitly"
argument_list|)
argument_list|(
operator|*
name|ppr_p
argument_list|)
operator|->
name|bal
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|MSG
argument_list|(
literal|"was okay, is now one off"
argument_list|)
argument_list|(
operator|*
name|ppr_p
argument_list|)
operator|->
name|bal
operator|=
literal|1
expr_stmt|;
operator|*
name|pi_balance
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|MSG
argument_list|(
literal|"was already off, this is too much"
argument_list|)
name|p1
operator|=
operator|(
operator|*
name|ppr_p
operator|)
operator|->
name|right
expr_stmt|;
name|b1
operator|=
name|p1
operator|->
name|bal
expr_stmt|;
if|if
condition|(
name|b1
operator|>=
literal|0
condition|)
block|{
name|MSG
argument_list|(
literal|"single RR"
argument_list|)
argument_list|(
operator|*
name|ppr_p
argument_list|)
operator|->
name|right
operator|=
name|p1
operator|->
name|left
expr_stmt|;
name|p1
operator|->
name|left
operator|=
operator|*
name|ppr_p
expr_stmt|;
if|if
condition|(
name|b1
operator|==
literal|0
condition|)
block|{
name|MSG
argument_list|(
literal|"b1 == 0"
argument_list|)
argument_list|(
operator|*
name|ppr_p
argument_list|)
operator|->
name|bal
operator|=
literal|1
expr_stmt|;
name|p1
operator|->
name|bal
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|pi_balance
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|MSG
argument_list|(
literal|"b1 != 0"
argument_list|)
argument_list|(
operator|*
name|ppr_p
argument_list|)
operator|->
name|bal
operator|=
literal|0
expr_stmt|;
name|p1
operator|->
name|bal
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|ppr_p
operator|=
name|p1
expr_stmt|;
block|}
else|else
block|{
name|MSG
argument_list|(
literal|"double RL"
argument_list|)
name|p2
operator|=
name|p1
operator|->
name|left
expr_stmt|;
name|b2
operator|=
name|p2
operator|->
name|bal
expr_stmt|;
name|p1
operator|->
name|left
operator|=
name|p2
operator|->
name|right
expr_stmt|;
name|p2
operator|->
name|right
operator|=
name|p1
expr_stmt|;
operator|(
operator|*
name|ppr_p
operator|)
operator|->
name|right
operator|=
name|p2
operator|->
name|left
expr_stmt|;
name|p2
operator|->
name|left
operator|=
operator|*
name|ppr_p
expr_stmt|;
if|if
condition|(
name|b2
operator|==
literal|1
condition|)
operator|(
operator|*
name|ppr_p
operator|)
operator|->
name|bal
operator|=
operator|-
literal|1
expr_stmt|;
else|else
operator|(
operator|*
name|ppr_p
operator|)
operator|->
name|bal
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|b2
operator|==
operator|-
literal|1
condition|)
name|p1
operator|->
name|bal
operator|=
literal|1
expr_stmt|;
else|else
name|p1
operator|->
name|bal
operator|=
literal|0
expr_stmt|;
operator|*
name|ppr_p
operator|=
name|p2
expr_stmt|;
name|p2
operator|->
name|bal
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|RETV
block|}
end_function

begin_function
specifier|static
name|void
name|bal_R
parameter_list|(
name|tree
modifier|*
modifier|*
name|ppr_p
parameter_list|,
name|int
modifier|*
name|pi_balance
parameter_list|)
block|{
name|tree
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|int
name|b1
decl_stmt|,
name|b2
decl_stmt|;
name|ENTER
argument_list|(
literal|"bal_R"
argument_list|)
name|MSG
argument_list|(
literal|"right branch has shrunk"
argument_list|)
switch|switch
condition|(
operator|(
operator|*
name|ppr_p
operator|)
operator|->
name|bal
condition|)
block|{
case|case
literal|1
case|:
name|MSG
argument_list|(
literal|"was imbalanced, fixed implicitly"
argument_list|)
argument_list|(
operator|*
name|ppr_p
argument_list|)
operator|->
name|bal
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|MSG
argument_list|(
literal|"was okay, is now one off"
argument_list|)
argument_list|(
operator|*
name|ppr_p
argument_list|)
operator|->
name|bal
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|pi_balance
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
name|MSG
argument_list|(
literal|"was already off, this is too much"
argument_list|)
name|p1
operator|=
operator|(
operator|*
name|ppr_p
operator|)
operator|->
name|left
expr_stmt|;
name|b1
operator|=
name|p1
operator|->
name|bal
expr_stmt|;
if|if
condition|(
name|b1
operator|<=
literal|0
condition|)
block|{
name|MSG
argument_list|(
literal|"single LL"
argument_list|)
argument_list|(
operator|*
name|ppr_p
argument_list|)
operator|->
name|left
operator|=
name|p1
operator|->
name|right
expr_stmt|;
name|p1
operator|->
name|right
operator|=
operator|*
name|ppr_p
expr_stmt|;
if|if
condition|(
name|b1
operator|==
literal|0
condition|)
block|{
name|MSG
argument_list|(
literal|"b1 == 0"
argument_list|)
argument_list|(
operator|*
name|ppr_p
argument_list|)
operator|->
name|bal
operator|=
operator|-
literal|1
expr_stmt|;
name|p1
operator|->
name|bal
operator|=
literal|1
expr_stmt|;
operator|*
name|pi_balance
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|MSG
argument_list|(
literal|"b1 != 0"
argument_list|)
argument_list|(
operator|*
name|ppr_p
argument_list|)
operator|->
name|bal
operator|=
literal|0
expr_stmt|;
name|p1
operator|->
name|bal
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|ppr_p
operator|=
name|p1
expr_stmt|;
block|}
else|else
block|{
name|MSG
argument_list|(
literal|"double LR"
argument_list|)
name|p2
operator|=
name|p1
operator|->
name|right
expr_stmt|;
name|b2
operator|=
name|p2
operator|->
name|bal
expr_stmt|;
name|p1
operator|->
name|right
operator|=
name|p2
operator|->
name|left
expr_stmt|;
name|p2
operator|->
name|left
operator|=
name|p1
expr_stmt|;
operator|(
operator|*
name|ppr_p
operator|)
operator|->
name|left
operator|=
name|p2
operator|->
name|right
expr_stmt|;
name|p2
operator|->
name|right
operator|=
operator|*
name|ppr_p
expr_stmt|;
if|if
condition|(
name|b2
operator|==
operator|-
literal|1
condition|)
operator|(
operator|*
name|ppr_p
operator|)
operator|->
name|bal
operator|=
literal|1
expr_stmt|;
else|else
operator|(
operator|*
name|ppr_p
operator|)
operator|->
name|bal
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|b2
operator|==
literal|1
condition|)
name|p1
operator|->
name|bal
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|p1
operator|->
name|bal
operator|=
literal|0
expr_stmt|;
operator|*
name|ppr_p
operator|=
name|p2
expr_stmt|;
name|p2
operator|->
name|bal
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|RETV
block|}
end_function

end_unit

