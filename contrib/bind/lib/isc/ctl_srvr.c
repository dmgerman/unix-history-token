begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: ctl_srvr.c,v 8.25 2001/05/29 05:49:27 marka Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Copyright (c) 1998,1999 by Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/* Extern. */
end_comment

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<isc/assertions.h>
end_include

begin_include
include|#
directive|include
file|<isc/ctl.h>
end_include

begin_include
include|#
directive|include
file|<isc/eventlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/list.h>
end_include

begin_include
include|#
directive|include
file|<isc/logging.h>
end_include

begin_include
include|#
directive|include
file|<isc/memcluster.h>
end_include

begin_include
include|#
directive|include
file|"ctl_p.h"
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SPRINTF_CHAR
end_ifdef

begin_define
define|#
directive|define
name|SPRINTF
parameter_list|(
name|x
parameter_list|)
value|strlen(sprintf
comment|/**/
value|x)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SPRINTF
parameter_list|(
name|x
parameter_list|)
value|((size_t)sprintf x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Macros. */
end_comment

begin_define
define|#
directive|define
name|lastverb_p
parameter_list|(
name|verb
parameter_list|)
value|(verb->name == NULL || verb->func == NULL)
end_define

begin_define
define|#
directive|define
name|address_expr
value|ctl_sa_ntop((struct sockaddr *)&sess->sa, \ 					    tmp, sizeof tmp, ctx->logger)
end_define

begin_comment
comment|/* Types. */
end_comment

begin_enum
enum|enum
name|state
block|{
name|available
init|=
literal|0
block|,
name|initializing
block|,
name|writing
block|,
name|reading
block|,
name|reading_data
block|,
name|processing
block|,
name|idling
block|,
name|quitting
block|,
name|closing
block|}
enum|;
end_enum

begin_union
union|union
name|sa_un
block|{
name|struct
name|sockaddr_in
name|in
decl_stmt|;
ifndef|#
directive|ifndef
name|NO_SOCKADDR_UN
name|struct
name|sockaddr_un
name|un
decl_stmt|;
endif|#
directive|endif
block|}
union|;
end_union

begin_struct
struct|struct
name|ctl_sess
block|{
name|LINK
argument_list|(
argument|struct ctl_sess
argument_list|)
name|link
expr_stmt|;
name|struct
name|ctl_sctx
modifier|*
name|ctx
decl_stmt|;
name|enum
name|state
name|state
decl_stmt|;
name|int
name|sock
decl_stmt|;
name|union
name|sa_un
name|sa
decl_stmt|;
name|evFileID
name|rdID
decl_stmt|;
name|evStreamID
name|wrID
decl_stmt|;
name|evTimerID
name|rdtiID
decl_stmt|;
name|evTimerID
name|wrtiID
decl_stmt|;
name|struct
name|ctl_buf
name|inbuf
decl_stmt|;
name|struct
name|ctl_buf
name|outbuf
decl_stmt|;
specifier|const
name|struct
name|ctl_verb
modifier|*
name|verb
decl_stmt|;
name|u_int
name|helpcode
decl_stmt|;
specifier|const
name|void
modifier|*
name|respctx
decl_stmt|;
name|u_int
name|respflags
decl_stmt|;
name|ctl_srvrdone
name|donefunc
decl_stmt|;
name|void
modifier|*
name|uap
decl_stmt|;
name|void
modifier|*
name|csctx
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ctl_sctx
block|{
name|evContext
name|ev
decl_stmt|;
name|void
modifier|*
name|uctx
decl_stmt|;
name|u_int
name|unkncode
decl_stmt|;
name|u_int
name|timeoutcode
decl_stmt|;
specifier|const
name|struct
name|ctl_verb
modifier|*
name|verbs
decl_stmt|;
specifier|const
name|struct
name|ctl_verb
modifier|*
name|connverb
decl_stmt|;
name|int
name|sock
decl_stmt|;
name|int
name|max_sess
decl_stmt|;
name|int
name|cur_sess
decl_stmt|;
name|struct
name|timespec
name|timeout
decl_stmt|;
name|ctl_logfunc
name|logger
decl_stmt|;
name|evConnID
name|acID
decl_stmt|;
name|LIST
argument_list|(
argument|struct ctl_sess
argument_list|)
name|sess
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Forward. */
end_comment

begin_function_decl
specifier|static
name|void
name|ctl_accept
parameter_list|(
name|evContext
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_close
parameter_list|(
name|struct
name|ctl_sess
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_new_state
parameter_list|(
name|struct
name|ctl_sess
modifier|*
parameter_list|,
name|enum
name|state
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_start_read
parameter_list|(
name|struct
name|ctl_sess
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_stop_read
parameter_list|(
name|struct
name|ctl_sess
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_readable
parameter_list|(
name|evContext
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_rdtimeout
parameter_list|(
name|evContext
parameter_list|,
name|void
modifier|*
parameter_list|,
name|struct
name|timespec
parameter_list|,
name|struct
name|timespec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_wrtimeout
parameter_list|(
name|evContext
parameter_list|,
name|void
modifier|*
parameter_list|,
name|struct
name|timespec
parameter_list|,
name|struct
name|timespec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_docommand
parameter_list|(
name|struct
name|ctl_sess
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_writedone
parameter_list|(
name|evContext
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_morehelp
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
parameter_list|,
name|struct
name|ctl_sess
modifier|*
parameter_list|,
specifier|const
name|struct
name|ctl_verb
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|u_int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_signal_done
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
parameter_list|,
name|struct
name|ctl_sess
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Private data. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|state_names
index|[]
init|=
block|{
literal|"available"
block|,
literal|"initializing"
block|,
literal|"writing"
block|,
literal|"reading"
block|,
literal|"reading_data"
block|,
literal|"processing"
block|,
literal|"idling"
block|,
literal|"quitting"
block|,
literal|"closing"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|space
index|[]
init|=
literal|" "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ctl_verb
name|fakehelpverb
init|=
block|{
literal|"fakehelp"
block|,
name|ctl_morehelp
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Public. */
end_comment

begin_comment
comment|/*  * void  * ctl_server()  *	create, condition, and start a listener on the control port.  */
end_comment

begin_function
name|struct
name|ctl_sctx
modifier|*
name|ctl_server
parameter_list|(
name|evContext
name|lev
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|sap
parameter_list|,
name|size_t
name|sap_len
parameter_list|,
specifier|const
name|struct
name|ctl_verb
modifier|*
name|verbs
parameter_list|,
name|u_int
name|unkncode
parameter_list|,
name|u_int
name|timeoutcode
parameter_list|,
name|u_int
name|timeout
parameter_list|,
name|int
name|backlog
parameter_list|,
name|int
name|max_sess
parameter_list|,
name|ctl_logfunc
name|logger
parameter_list|,
name|void
modifier|*
name|uctx
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|me
index|[]
init|=
literal|"ctl_server"
decl_stmt|;
specifier|static
specifier|const
name|int
name|on
init|=
literal|1
decl_stmt|;
specifier|const
name|struct
name|ctl_verb
modifier|*
name|connverb
decl_stmt|;
name|struct
name|ctl_sctx
modifier|*
name|ctx
decl_stmt|;
name|int
name|save_errno
decl_stmt|;
if|if
condition|(
name|logger
operator|==
name|NULL
condition|)
name|logger
operator|=
name|ctl_logger
expr_stmt|;
for|for
control|(
name|connverb
operator|=
name|verbs
init|;
name|connverb
operator|->
name|name
operator|!=
name|NULL
operator|&&
name|connverb
operator|->
name|func
operator|!=
name|NULL
condition|;
name|connverb
operator|++
control|)
if|if
condition|(
name|connverb
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|connverb
operator|->
name|func
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: no connection verb found"
argument_list|,
name|me
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ctx
operator|=
name|memget
argument_list|(
sizeof|sizeof
expr|*
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: getmem: %s"
argument_list|,
name|me
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ctx
operator|->
name|ev
operator|=
name|lev
expr_stmt|;
name|ctx
operator|->
name|uctx
operator|=
name|uctx
expr_stmt|;
name|ctx
operator|->
name|unkncode
operator|=
name|unkncode
expr_stmt|;
name|ctx
operator|->
name|timeoutcode
operator|=
name|timeoutcode
expr_stmt|;
name|ctx
operator|->
name|verbs
operator|=
name|verbs
expr_stmt|;
name|ctx
operator|->
name|timeout
operator|=
name|evConsTime
argument_list|(
name|timeout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|logger
operator|=
name|logger
expr_stmt|;
name|ctx
operator|->
name|connverb
operator|=
name|connverb
expr_stmt|;
name|ctx
operator|->
name|max_sess
operator|=
name|max_sess
expr_stmt|;
name|ctx
operator|->
name|cur_sess
operator|=
literal|0
expr_stmt|;
name|INIT_LIST
argument_list|(
name|ctx
operator|->
name|sess
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|sock
operator|=
name|socket
argument_list|(
name|sap
operator|->
name|sa_family
argument_list|,
name|SOCK_STREAM
argument_list|,
name|PF_UNSPEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|sock
operator|>
name|evHighestFD
argument_list|(
name|ctx
operator|->
name|ev
argument_list|)
condition|)
block|{
name|ctx
operator|->
name|sock
operator|=
operator|-
literal|1
expr_stmt|;
name|errno
operator|=
name|ENOTSOCK
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|sock
operator|<
literal|0
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: socket: %s"
argument_list|,
name|me
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|ctx
argument_list|,
sizeof|sizeof
expr|*
name|ctx
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|ctx
operator|->
name|sock
operator|>
name|evHighestFD
argument_list|(
name|lev
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|ctx
operator|->
name|sock
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: file descriptor> evHighestFD"
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENFILE
expr_stmt|;
name|memput
argument_list|(
name|ctx
argument_list|,
sizeof|sizeof
expr|*
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|NO_UNIX_REUSEADDR
if|if
condition|(
name|sap
operator|->
name|sa_family
operator|!=
name|AF_UNIX
condition|)
endif|#
directive|endif
if|if
condition|(
name|setsockopt
argument_list|(
name|ctx
operator|->
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
name|on
argument_list|)
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_warning
argument_list|,
literal|"%s: setsockopt(REUSEADDR): %s"
argument_list|,
name|me
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bind
argument_list|(
name|ctx
operator|->
name|sock
argument_list|,
name|sap
argument_list|,
name|sap_len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|char
name|tmp
index|[
name|MAX_NTOP
index|]
decl_stmt|;
name|save_errno
operator|=
name|errno
expr_stmt|;
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: bind: %s: %s"
argument_list|,
name|me
argument_list|,
name|ctl_sa_ntop
argument_list|(
operator|(
specifier|const
expr|struct
name|sockaddr
operator|*
operator|)
name|sap
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
name|tmp
argument_list|,
name|ctx
operator|->
name|logger
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ctx
operator|->
name|sock
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|ctx
argument_list|,
sizeof|sizeof
expr|*
name|ctx
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|ctx
operator|->
name|sock
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_warning
argument_list|,
literal|"%s: fcntl: %s"
argument_list|,
name|me
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|evListen
argument_list|(
name|lev
argument_list|,
name|ctx
operator|->
name|sock
argument_list|,
name|backlog
argument_list|,
name|ctl_accept
argument_list|,
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|acID
argument_list|)
operator|<
literal|0
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: evListen(fd %d): %s"
argument_list|,
name|me
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ctx
operator|->
name|sock
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ctx
operator|->
name|sock
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|ctx
argument_list|,
sizeof|sizeof
expr|*
name|ctx
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_debug
argument_list|,
literal|"%s: new ctx %p, sock %d"
argument_list|,
name|me
argument_list|,
name|ctx
argument_list|,
name|ctx
operator|->
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ctx
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * void  * ctl_endserver(ctx)  *	if the control listener is open, close it.  clean out all eventlib  *	stuff.  close all active sessions.  */
end_comment

begin_function
name|void
name|ctl_endserver
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
name|ctx
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|me
index|[]
init|=
literal|"ctl_endserver"
decl_stmt|;
name|struct
name|ctl_sess
modifier|*
name|this
decl_stmt|,
modifier|*
name|next
decl_stmt|;
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_debug
argument_list|,
literal|"%s: ctx %p, sock %d, acID %p, sess %p"
argument_list|,
name|me
argument_list|,
name|ctx
argument_list|,
name|ctx
operator|->
name|sock
argument_list|,
name|ctx
operator|->
name|acID
operator|.
name|opaque
argument_list|,
name|ctx
operator|->
name|sess
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|acID
operator|.
name|opaque
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|evCancelConn
argument_list|(
name|ctx
operator|->
name|ev
argument_list|,
name|ctx
operator|->
name|acID
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|acID
operator|.
name|opaque
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|sock
operator|!=
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|ctx
operator|->
name|sock
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|sock
operator|=
operator|-
literal|1
expr_stmt|;
block|}
for|for
control|(
name|this
operator|=
name|HEAD
argument_list|(
name|ctx
operator|->
name|sess
argument_list|)
init|;
name|this
operator|!=
name|NULL
condition|;
name|this
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT
argument_list|(
name|this
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ctl_close
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|memput
argument_list|(
name|ctx
argument_list|,
sizeof|sizeof
expr|*
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If body is non-NULL then it we add a "." line after it.  * Caller must have  escaped lines with leading ".".  */
end_comment

begin_function
name|void
name|ctl_response
parameter_list|(
name|struct
name|ctl_sess
modifier|*
name|sess
parameter_list|,
name|u_int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|text
parameter_list|,
name|u_int
name|flags
parameter_list|,
specifier|const
name|void
modifier|*
name|respctx
parameter_list|,
name|ctl_srvrdone
name|donefunc
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
specifier|const
name|char
modifier|*
name|body
parameter_list|,
name|size_t
name|bodylen
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|me
index|[]
init|=
literal|"ctl_response"
decl_stmt|;
name|struct
name|iovec
name|iov
index|[
literal|3
index|]
decl_stmt|,
modifier|*
name|iovp
init|=
name|iov
decl_stmt|;
name|struct
name|ctl_sctx
modifier|*
name|ctx
init|=
name|sess
operator|->
name|ctx
decl_stmt|;
name|char
name|tmp
index|[
name|MAX_NTOP
index|]
decl_stmt|,
modifier|*
name|pc
decl_stmt|;
name|int
name|n
decl_stmt|;
name|REQUIRE
argument_list|(
name|sess
operator|->
name|state
operator|==
name|initializing
operator|||
name|sess
operator|->
name|state
operator|==
name|processing
operator|||
name|sess
operator|->
name|state
operator|==
name|reading_data
operator|||
name|sess
operator|->
name|state
operator|==
name|writing
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sess
operator|->
name|wrtiID
operator|.
name|opaque
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sess
operator|->
name|wrID
operator|.
name|opaque
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ctl_new_state
argument_list|(
name|sess
argument_list|,
name|writing
argument_list|,
name|me
argument_list|)
expr_stmt|;
name|sess
operator|->
name|donefunc
operator|=
name|donefunc
expr_stmt|;
name|sess
operator|->
name|uap
operator|=
name|uap
expr_stmt|;
if|if
condition|(
operator|!
name|allocated_p
argument_list|(
name|sess
operator|->
name|outbuf
argument_list|)
operator|&&
name|ctl_bufget
argument_list|(
operator|&
name|sess
operator|->
name|outbuf
argument_list|,
name|ctx
operator|->
name|logger
argument_list|)
operator|<
literal|0
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: %s: cant get an output buffer"
argument_list|,
name|me
argument_list|,
name|address_expr
argument_list|)
expr_stmt|;
goto|goto
name|untimely
goto|;
block|}
if|if
condition|(
sizeof|sizeof
expr|"000-\r\n"
operator|+
name|strlen
argument_list|(
name|text
argument_list|)
operator|>
name|MAX_LINELEN
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: %s: output buffer ovf, closing"
argument_list|,
name|me
argument_list|,
name|address_expr
argument_list|)
expr_stmt|;
goto|goto
name|untimely
goto|;
block|}
name|sess
operator|->
name|outbuf
operator|.
name|used
operator|=
name|SPRINTF
argument_list|(
operator|(
name|sess
operator|->
name|outbuf
operator|.
name|text
operator|,
literal|"%03d%c%s\r\n"
operator|,
name|code
operator|,
operator|(
name|flags
operator|&
name|CTL_MORE
operator|)
operator|!=
literal|0
condition|?
literal|'-'
else|:
literal|' '
operator|,
name|text
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|pc
operator|=
name|sess
operator|->
name|outbuf
operator|.
name|text
operator|,
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|(
name|int
operator|)
name|sess
operator|->
name|outbuf
operator|.
name|used
operator|-
literal|2
condition|;
name|pc
operator|++
operator|,
name|n
operator|++
control|)
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|pc
argument_list|)
operator|||
operator|!
name|isprint
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|pc
argument_list|)
condition|)
operator|*
name|pc
operator|=
literal|'\040'
expr_stmt|;
operator|*
name|iovp
operator|++
operator|=
name|evConsIovec
argument_list|(
name|sess
operator|->
name|outbuf
operator|.
name|text
argument_list|,
name|sess
operator|->
name|outbuf
operator|.
name|used
argument_list|)
expr_stmt|;
if|if
condition|(
name|body
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|DE_CONST
argument_list|(
name|body
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
operator|*
name|iovp
operator|++
operator|=
name|evConsIovec
argument_list|(
name|tmp
argument_list|,
name|bodylen
argument_list|)
expr_stmt|;
name|DE_CONST
argument_list|(
literal|".\r\n"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
operator|*
name|iovp
operator|++
operator|=
name|evConsIovec
argument_list|(
name|tmp
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_debug
argument_list|,
literal|"%s: [%d] %s"
argument_list|,
name|me
argument_list|,
name|sess
operator|->
name|outbuf
operator|.
name|used
argument_list|,
name|sess
operator|->
name|outbuf
operator|.
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|evWrite
argument_list|(
name|ctx
operator|->
name|ev
argument_list|,
name|sess
operator|->
name|sock
argument_list|,
name|iov
argument_list|,
name|iovp
operator|-
name|iov
argument_list|,
name|ctl_writedone
argument_list|,
name|sess
argument_list|,
operator|&
name|sess
operator|->
name|wrID
argument_list|)
operator|<
literal|0
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: %s: evWrite: %s"
argument_list|,
name|me
argument_list|,
name|address_expr
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|untimely
goto|;
block|}
if|if
condition|(
name|evSetIdleTimer
argument_list|(
name|ctx
operator|->
name|ev
argument_list|,
name|ctl_wrtimeout
argument_list|,
name|sess
argument_list|,
name|ctx
operator|->
name|timeout
argument_list|,
operator|&
name|sess
operator|->
name|wrtiID
argument_list|)
operator|<
literal|0
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: %s: evSetIdleTimer: %s"
argument_list|,
name|me
argument_list|,
name|address_expr
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|untimely
goto|;
block|}
if|if
condition|(
name|evTimeRW
argument_list|(
name|ctx
operator|->
name|ev
argument_list|,
name|sess
operator|->
name|wrID
argument_list|,
name|sess
operator|->
name|wrtiID
argument_list|)
operator|<
literal|0
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: %s: evTimeRW: %s"
argument_list|,
name|me
argument_list|,
name|address_expr
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|untimely
label|:
name|ctl_signal_done
argument_list|(
name|ctx
argument_list|,
name|sess
argument_list|)
expr_stmt|;
name|ctl_close
argument_list|(
name|sess
argument_list|)
expr_stmt|;
return|return;
block|}
name|sess
operator|->
name|respctx
operator|=
name|respctx
expr_stmt|;
name|sess
operator|->
name|respflags
operator|=
name|flags
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctl_sendhelp
parameter_list|(
name|struct
name|ctl_sess
modifier|*
name|sess
parameter_list|,
name|u_int
name|code
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|me
index|[]
init|=
literal|"ctl_sendhelp"
decl_stmt|;
name|struct
name|ctl_sctx
modifier|*
name|ctx
init|=
name|sess
operator|->
name|ctx
decl_stmt|;
name|sess
operator|->
name|helpcode
operator|=
name|code
expr_stmt|;
name|sess
operator|->
name|verb
operator|=
operator|&
name|fakehelpverb
expr_stmt|;
name|ctl_morehelp
argument_list|(
name|ctx
argument_list|,
name|sess
argument_list|,
name|NULL
argument_list|,
name|me
argument_list|,
name|CTL_MORE
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|ctx
operator|->
name|verbs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|ctl_getcsctx
parameter_list|(
name|struct
name|ctl_sess
modifier|*
name|sess
parameter_list|)
block|{
return|return
operator|(
name|sess
operator|->
name|csctx
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|ctl_setcsctx
parameter_list|(
name|struct
name|ctl_sess
modifier|*
name|sess
parameter_list|,
name|void
modifier|*
name|csctx
parameter_list|)
block|{
name|void
modifier|*
name|old
init|=
name|sess
operator|->
name|csctx
decl_stmt|;
name|sess
operator|->
name|csctx
operator|=
name|csctx
expr_stmt|;
return|return
operator|(
name|old
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Private functions. */
end_comment

begin_function
specifier|static
name|void
name|ctl_accept
parameter_list|(
name|evContext
name|lev
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|int
name|fd
parameter_list|,
specifier|const
name|void
modifier|*
name|lav
parameter_list|,
name|int
name|lalen
parameter_list|,
specifier|const
name|void
modifier|*
name|rav
parameter_list|,
name|int
name|ralen
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|me
index|[]
init|=
literal|"ctl_accept"
decl_stmt|;
name|struct
name|ctl_sctx
modifier|*
name|ctx
init|=
name|uap
decl_stmt|;
name|struct
name|ctl_sess
modifier|*
name|sess
init|=
name|NULL
decl_stmt|;
name|char
name|tmp
index|[
name|MAX_NTOP
index|]
decl_stmt|;
name|UNUSED
argument_list|(
name|lev
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|lalen
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|ralen
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: accept: %s"
argument_list|,
name|me
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ctx
operator|->
name|cur_sess
operator|==
name|ctx
operator|->
name|max_sess
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: %s: too many control sessions"
argument_list|,
name|me
argument_list|,
name|ctl_sa_ntop
argument_list|(
operator|(
specifier|const
expr|struct
name|sockaddr
operator|*
operator|)
name|rav
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
name|tmp
argument_list|,
name|ctx
operator|->
name|logger
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
name|sess
operator|=
name|memget
argument_list|(
sizeof|sizeof
expr|*
name|sess
argument_list|)
expr_stmt|;
if|if
condition|(
name|sess
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: memget: %s"
argument_list|,
name|me
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_warning
argument_list|,
literal|"%s: fcntl: %s"
argument_list|,
name|me
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ctx
operator|->
name|cur_sess
operator|++
expr_stmt|;
name|INIT_LINK
argument_list|(
name|sess
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|APPEND
argument_list|(
name|ctx
operator|->
name|sess
argument_list|,
name|sess
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|sess
operator|->
name|ctx
operator|=
name|ctx
expr_stmt|;
name|sess
operator|->
name|sock
operator|=
name|fd
expr_stmt|;
name|sess
operator|->
name|wrID
operator|.
name|opaque
operator|=
name|NULL
expr_stmt|;
name|sess
operator|->
name|rdID
operator|.
name|opaque
operator|=
name|NULL
expr_stmt|;
name|sess
operator|->
name|wrtiID
operator|.
name|opaque
operator|=
name|NULL
expr_stmt|;
name|sess
operator|->
name|rdtiID
operator|.
name|opaque
operator|=
name|NULL
expr_stmt|;
name|sess
operator|->
name|respctx
operator|=
name|NULL
expr_stmt|;
name|sess
operator|->
name|csctx
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
operator|(
specifier|const
expr|struct
name|sockaddr
operator|*
operator|)
name|rav
operator|)
operator|->
name|sa_family
operator|==
name|AF_UNIX
condition|)
name|ctl_sa_copy
argument_list|(
operator|(
specifier|const
expr|struct
name|sockaddr
operator|*
operator|)
name|lav
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sess
operator|->
name|sa
argument_list|)
expr_stmt|;
else|else
name|ctl_sa_copy
argument_list|(
operator|(
specifier|const
expr|struct
name|sockaddr
operator|*
operator|)
name|rav
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sess
operator|->
name|sa
argument_list|)
expr_stmt|;
name|sess
operator|->
name|donefunc
operator|=
name|NULL
expr_stmt|;
name|buffer_init
argument_list|(
name|sess
operator|->
name|inbuf
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
name|sess
operator|->
name|outbuf
argument_list|)
expr_stmt|;
name|sess
operator|->
name|state
operator|=
name|available
expr_stmt|;
name|ctl_new_state
argument_list|(
name|sess
argument_list|,
name|initializing
argument_list|,
name|me
argument_list|)
expr_stmt|;
name|sess
operator|->
name|verb
operator|=
name|ctx
operator|->
name|connverb
expr_stmt|;
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_debug
argument_list|,
literal|"%s: %s: accepting (fd %d)"
argument_list|,
name|me
argument_list|,
name|address_expr
argument_list|,
name|sess
operator|->
name|sock
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ctx
operator|->
name|connverb
operator|->
name|func
call|)
argument_list|(
name|ctx
argument_list|,
name|sess
argument_list|,
name|ctx
operator|->
name|connverb
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
operator|(
specifier|const
expr|struct
name|sockaddr
operator|*
operator|)
name|rav
argument_list|,
name|ctx
operator|->
name|uctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_new_state
parameter_list|(
name|struct
name|ctl_sess
modifier|*
name|sess
parameter_list|,
name|enum
name|state
name|new_state
parameter_list|,
specifier|const
name|char
modifier|*
name|reason
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|me
index|[]
init|=
literal|"ctl_new_state"
decl_stmt|;
name|struct
name|ctl_sctx
modifier|*
name|ctx
init|=
name|sess
operator|->
name|ctx
decl_stmt|;
name|char
name|tmp
index|[
name|MAX_NTOP
index|]
decl_stmt|;
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_debug
argument_list|,
literal|"%s: %s: %s -> %s (%s)"
argument_list|,
name|me
argument_list|,
name|address_expr
argument_list|,
name|state_names
index|[
name|sess
operator|->
name|state
index|]
argument_list|,
name|state_names
index|[
name|new_state
index|]
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|sess
operator|->
name|state
operator|=
name|new_state
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_close
parameter_list|(
name|struct
name|ctl_sess
modifier|*
name|sess
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|me
index|[]
init|=
literal|"ctl_close"
decl_stmt|;
name|struct
name|ctl_sctx
modifier|*
name|ctx
init|=
name|sess
operator|->
name|ctx
decl_stmt|;
name|char
name|tmp
index|[
name|MAX_NTOP
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|sess
operator|->
name|state
operator|==
name|initializing
operator|||
name|sess
operator|->
name|state
operator|==
name|writing
operator|||
name|sess
operator|->
name|state
operator|==
name|reading
operator|||
name|sess
operator|->
name|state
operator|==
name|processing
operator|||
name|sess
operator|->
name|state
operator|==
name|reading_data
operator|||
name|sess
operator|->
name|state
operator|==
name|idling
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sess
operator|->
name|sock
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sess
operator|->
name|state
operator|==
name|reading
operator|||
name|sess
operator|->
name|state
operator|==
name|reading_data
condition|)
name|ctl_stop_read
argument_list|(
name|sess
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sess
operator|->
name|state
operator|==
name|writing
condition|)
block|{
if|if
condition|(
name|sess
operator|->
name|wrID
operator|.
name|opaque
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|evCancelRW
argument_list|(
name|ctx
operator|->
name|ev
argument_list|,
name|sess
operator|->
name|wrID
argument_list|)
expr_stmt|;
name|sess
operator|->
name|wrID
operator|.
name|opaque
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sess
operator|->
name|wrtiID
operator|.
name|opaque
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|evClearIdleTimer
argument_list|(
name|ctx
operator|->
name|ev
argument_list|,
name|sess
operator|->
name|wrtiID
argument_list|)
expr_stmt|;
name|sess
operator|->
name|wrtiID
operator|.
name|opaque
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|ctl_new_state
argument_list|(
name|sess
argument_list|,
name|closing
argument_list|,
name|me
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sess
operator|->
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocated_p
argument_list|(
name|sess
operator|->
name|inbuf
argument_list|)
condition|)
name|ctl_bufput
argument_list|(
operator|&
name|sess
operator|->
name|inbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocated_p
argument_list|(
name|sess
operator|->
name|outbuf
argument_list|)
condition|)
name|ctl_bufput
argument_list|(
operator|&
name|sess
operator|->
name|outbuf
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_debug
argument_list|,
literal|"%s: %s: closed (fd %d)"
argument_list|,
name|me
argument_list|,
name|address_expr
argument_list|,
name|sess
operator|->
name|sock
argument_list|)
expr_stmt|;
name|UNLINK
argument_list|(
name|ctx
operator|->
name|sess
argument_list|,
name|sess
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|sess
argument_list|,
sizeof|sizeof
expr|*
name|sess
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|cur_sess
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_start_read
parameter_list|(
name|struct
name|ctl_sess
modifier|*
name|sess
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|me
index|[]
init|=
literal|"ctl_start_read"
decl_stmt|;
name|struct
name|ctl_sctx
modifier|*
name|ctx
init|=
name|sess
operator|->
name|ctx
decl_stmt|;
name|char
name|tmp
index|[
name|MAX_NTOP
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|sess
operator|->
name|state
operator|==
name|initializing
operator|||
name|sess
operator|->
name|state
operator|==
name|writing
operator|||
name|sess
operator|->
name|state
operator|==
name|processing
operator|||
name|sess
operator|->
name|state
operator|==
name|idling
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sess
operator|->
name|rdtiID
operator|.
name|opaque
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sess
operator|->
name|rdID
operator|.
name|opaque
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|sess
operator|->
name|inbuf
operator|.
name|used
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|evSetIdleTimer
argument_list|(
name|ctx
operator|->
name|ev
argument_list|,
name|ctl_rdtimeout
argument_list|,
name|sess
argument_list|,
name|ctx
operator|->
name|timeout
argument_list|,
operator|&
name|sess
operator|->
name|rdtiID
argument_list|)
operator|<
literal|0
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: %s: evSetIdleTimer: %s"
argument_list|,
name|me
argument_list|,
name|address_expr
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ctl_close
argument_list|(
name|sess
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|evSelectFD
argument_list|(
name|ctx
operator|->
name|ev
argument_list|,
name|sess
operator|->
name|sock
argument_list|,
name|EV_READ
argument_list|,
name|ctl_readable
argument_list|,
name|sess
argument_list|,
operator|&
name|sess
operator|->
name|rdID
argument_list|)
operator|<
literal|0
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: %s: evSelectFD: %s"
argument_list|,
name|me
argument_list|,
name|address_expr
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|ctl_new_state
argument_list|(
name|sess
argument_list|,
name|reading
argument_list|,
name|me
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_stop_read
parameter_list|(
name|struct
name|ctl_sess
modifier|*
name|sess
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|me
index|[]
init|=
literal|"ctl_stop_read"
decl_stmt|;
name|struct
name|ctl_sctx
modifier|*
name|ctx
init|=
name|sess
operator|->
name|ctx
decl_stmt|;
name|REQUIRE
argument_list|(
name|sess
operator|->
name|state
operator|==
name|reading
operator|||
name|sess
operator|->
name|state
operator|==
name|reading_data
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sess
operator|->
name|rdID
operator|.
name|opaque
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|evDeselectFD
argument_list|(
name|ctx
operator|->
name|ev
argument_list|,
name|sess
operator|->
name|rdID
argument_list|)
expr_stmt|;
name|sess
operator|->
name|rdID
operator|.
name|opaque
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sess
operator|->
name|rdtiID
operator|.
name|opaque
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|evClearIdleTimer
argument_list|(
name|ctx
operator|->
name|ev
argument_list|,
name|sess
operator|->
name|rdtiID
argument_list|)
expr_stmt|;
name|sess
operator|->
name|rdtiID
operator|.
name|opaque
operator|=
name|NULL
expr_stmt|;
block|}
name|ctl_new_state
argument_list|(
name|sess
argument_list|,
name|idling
argument_list|,
name|me
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_readable
parameter_list|(
name|evContext
name|lev
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|evmask
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|me
index|[]
init|=
literal|"ctl_readable"
decl_stmt|;
name|struct
name|ctl_sess
modifier|*
name|sess
init|=
name|uap
decl_stmt|;
name|struct
name|ctl_sctx
modifier|*
name|ctx
init|=
name|sess
operator|->
name|ctx
decl_stmt|;
name|char
modifier|*
name|eos
decl_stmt|,
name|tmp
index|[
name|MAX_NTOP
index|]
decl_stmt|;
name|ssize_t
name|n
decl_stmt|;
name|REQUIRE
argument_list|(
name|sess
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|fd
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|evmask
operator|==
name|EV_READ
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sess
operator|->
name|state
operator|==
name|reading
operator|||
name|sess
operator|->
name|state
operator|==
name|reading_data
argument_list|)
expr_stmt|;
name|evTouchIdleTimer
argument_list|(
name|lev
argument_list|,
name|sess
operator|->
name|rdtiID
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allocated_p
argument_list|(
name|sess
operator|->
name|inbuf
argument_list|)
operator|&&
name|ctl_bufget
argument_list|(
operator|&
name|sess
operator|->
name|inbuf
argument_list|,
name|ctx
operator|->
name|logger
argument_list|)
operator|<
literal|0
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: %s: cant get an input buffer"
argument_list|,
name|me
argument_list|,
name|address_expr
argument_list|)
expr_stmt|;
name|ctl_close
argument_list|(
name|sess
argument_list|)
expr_stmt|;
return|return;
block|}
name|n
operator|=
name|read
argument_list|(
name|sess
operator|->
name|sock
argument_list|,
name|sess
operator|->
name|inbuf
operator|.
name|text
operator|+
name|sess
operator|->
name|inbuf
operator|.
name|used
argument_list|,
name|MAX_LINELEN
operator|-
name|sess
operator|->
name|inbuf
operator|.
name|used
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_debug
argument_list|,
literal|"%s: %s: read: %s"
argument_list|,
name|me
argument_list|,
name|address_expr
argument_list|,
operator|(
name|n
operator|==
literal|0
operator|)
condition|?
literal|"Unexpected EOF"
else|:
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ctl_close
argument_list|(
name|sess
argument_list|)
expr_stmt|;
return|return;
block|}
name|sess
operator|->
name|inbuf
operator|.
name|used
operator|+=
name|n
expr_stmt|;
name|eos
operator|=
name|memchr
argument_list|(
name|sess
operator|->
name|inbuf
operator|.
name|text
argument_list|,
literal|'\n'
argument_list|,
name|sess
operator|->
name|inbuf
operator|.
name|used
argument_list|)
expr_stmt|;
if|if
condition|(
name|eos
operator|!=
name|NULL
operator|&&
name|eos
operator|!=
name|sess
operator|->
name|inbuf
operator|.
name|text
operator|&&
name|eos
index|[
operator|-
literal|1
index|]
operator|==
literal|'\r'
condition|)
block|{
name|eos
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|sess
operator|->
name|respflags
operator|&
name|CTL_DATA
operator|)
operator|!=
literal|0
condition|)
block|{
name|INSIST
argument_list|(
name|sess
operator|->
name|verb
operator|!=
name|NULL
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sess
operator|->
name|verb
operator|->
name|func
call|)
argument_list|(
name|sess
operator|->
name|ctx
argument_list|,
name|sess
argument_list|,
name|sess
operator|->
name|verb
argument_list|,
name|sess
operator|->
name|inbuf
operator|.
name|text
argument_list|,
name|CTL_DATA
argument_list|,
name|sess
operator|->
name|respctx
argument_list|,
name|sess
operator|->
name|ctx
operator|->
name|uctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctl_stop_read
argument_list|(
name|sess
argument_list|)
expr_stmt|;
name|ctl_docommand
argument_list|(
name|sess
argument_list|)
expr_stmt|;
block|}
name|sess
operator|->
name|inbuf
operator|.
name|used
operator|-=
operator|(
operator|(
name|eos
operator|-
name|sess
operator|->
name|inbuf
operator|.
name|text
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|sess
operator|->
name|inbuf
operator|.
name|used
operator|==
literal|0
condition|)
name|ctl_bufput
argument_list|(
operator|&
name|sess
operator|->
name|inbuf
argument_list|)
expr_stmt|;
else|else
name|memmove
argument_list|(
name|sess
operator|->
name|inbuf
operator|.
name|text
argument_list|,
name|eos
operator|+
literal|1
argument_list|,
name|sess
operator|->
name|inbuf
operator|.
name|used
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sess
operator|->
name|inbuf
operator|.
name|used
operator|==
name|MAX_LINELEN
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: %s: line too long, closing"
argument_list|,
name|me
argument_list|,
name|address_expr
argument_list|)
expr_stmt|;
name|ctl_close
argument_list|(
name|sess
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_wrtimeout
parameter_list|(
name|evContext
name|lev
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|struct
name|timespec
name|due
parameter_list|,
name|struct
name|timespec
name|itv
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|me
index|[]
init|=
literal|"ctl_wrtimeout"
decl_stmt|;
name|struct
name|ctl_sess
modifier|*
name|sess
init|=
name|uap
decl_stmt|;
name|struct
name|ctl_sctx
modifier|*
name|ctx
init|=
name|sess
operator|->
name|ctx
decl_stmt|;
name|char
name|tmp
index|[
name|MAX_NTOP
index|]
decl_stmt|;
name|UNUSED
argument_list|(
name|lev
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|due
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|itv
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sess
operator|->
name|state
operator|==
name|writing
argument_list|)
expr_stmt|;
name|sess
operator|->
name|wrtiID
operator|.
name|opaque
operator|=
name|NULL
expr_stmt|;
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_warning
argument_list|,
literal|"%s: %s: write timeout, closing"
argument_list|,
name|me
argument_list|,
name|address_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sess
operator|->
name|wrID
operator|.
name|opaque
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|evCancelRW
argument_list|(
name|ctx
operator|->
name|ev
argument_list|,
name|sess
operator|->
name|wrID
argument_list|)
expr_stmt|;
name|sess
operator|->
name|wrID
operator|.
name|opaque
operator|=
name|NULL
expr_stmt|;
block|}
name|ctl_signal_done
argument_list|(
name|ctx
argument_list|,
name|sess
argument_list|)
expr_stmt|;
name|ctl_new_state
argument_list|(
name|sess
argument_list|,
name|processing
argument_list|,
name|me
argument_list|)
expr_stmt|;
name|ctl_close
argument_list|(
name|sess
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_rdtimeout
parameter_list|(
name|evContext
name|lev
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|struct
name|timespec
name|due
parameter_list|,
name|struct
name|timespec
name|itv
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|me
index|[]
init|=
literal|"ctl_rdtimeout"
decl_stmt|;
name|struct
name|ctl_sess
modifier|*
name|sess
init|=
name|uap
decl_stmt|;
name|struct
name|ctl_sctx
modifier|*
name|ctx
init|=
name|sess
operator|->
name|ctx
decl_stmt|;
name|char
name|tmp
index|[
name|MAX_NTOP
index|]
decl_stmt|;
name|UNUSED
argument_list|(
name|lev
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|due
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|itv
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sess
operator|->
name|state
operator|==
name|reading
argument_list|)
expr_stmt|;
name|sess
operator|->
name|rdtiID
operator|.
name|opaque
operator|=
name|NULL
expr_stmt|;
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_warning
argument_list|,
literal|"%s: %s: timeout, closing"
argument_list|,
name|me
argument_list|,
name|address_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sess
operator|->
name|state
operator|==
name|reading
operator|||
name|sess
operator|->
name|state
operator|==
name|reading_data
condition|)
name|ctl_stop_read
argument_list|(
name|sess
argument_list|)
expr_stmt|;
name|ctl_signal_done
argument_list|(
name|ctx
argument_list|,
name|sess
argument_list|)
expr_stmt|;
name|ctl_new_state
argument_list|(
name|sess
argument_list|,
name|processing
argument_list|,
name|me
argument_list|)
expr_stmt|;
name|ctl_response
argument_list|(
name|sess
argument_list|,
name|ctx
operator|->
name|timeoutcode
argument_list|,
literal|"Timeout."
argument_list|,
name|CTL_EXIT
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_docommand
parameter_list|(
name|struct
name|ctl_sess
modifier|*
name|sess
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|me
index|[]
init|=
literal|"ctl_docommand"
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|rest
decl_stmt|,
name|tmp
index|[
name|MAX_NTOP
index|]
decl_stmt|;
name|struct
name|ctl_sctx
modifier|*
name|ctx
init|=
name|sess
operator|->
name|ctx
decl_stmt|;
specifier|const
name|struct
name|ctl_verb
modifier|*
name|verb
decl_stmt|;
name|REQUIRE
argument_list|(
name|allocated_p
argument_list|(
name|sess
operator|->
name|inbuf
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_debug
argument_list|,
literal|"%s: %s: \"%s\" [%u]"
argument_list|,
name|me
argument_list|,
name|address_expr
argument_list|,
name|sess
operator|->
name|inbuf
operator|.
name|text
argument_list|,
operator|(
name|u_int
operator|)
name|sess
operator|->
name|inbuf
operator|.
name|used
argument_list|)
expr_stmt|;
name|ctl_new_state
argument_list|(
name|sess
argument_list|,
name|processing
argument_list|,
name|me
argument_list|)
expr_stmt|;
name|name
operator|=
name|sess
operator|->
name|inbuf
operator|.
name|text
operator|+
name|strspn
argument_list|(
name|sess
operator|->
name|inbuf
operator|.
name|text
argument_list|,
name|space
argument_list|)
expr_stmt|;
name|rest
operator|=
name|name
operator|+
name|strcspn
argument_list|(
name|name
argument_list|,
name|space
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|rest
operator|!=
literal|'\0'
condition|)
block|{
operator|*
name|rest
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|rest
operator|+=
name|strspn
argument_list|(
name|rest
argument_list|,
name|space
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|verb
operator|=
name|ctx
operator|->
name|verbs
init|;
name|verb
operator|!=
name|NULL
operator|&&
name|verb
operator|->
name|name
operator|!=
name|NULL
operator|&&
name|verb
operator|->
name|func
operator|!=
name|NULL
condition|;
name|verb
operator|++
control|)
if|if
condition|(
name|verb
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|verb
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|verb
operator|!=
name|NULL
operator|&&
name|verb
operator|->
name|name
operator|!=
name|NULL
operator|&&
name|verb
operator|->
name|func
operator|!=
name|NULL
condition|)
block|{
name|sess
operator|->
name|verb
operator|=
name|verb
expr_stmt|;
call|(
modifier|*
name|verb
operator|->
name|func
call|)
argument_list|(
name|ctx
argument_list|,
name|sess
argument_list|,
name|verb
argument_list|,
name|rest
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|uctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
literal|1100
index|]
decl_stmt|;
if|if
condition|(
sizeof|sizeof
expr|"Unrecognized command \"\" (args \"\")"
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|rest
argument_list|)
operator|>
sizeof|sizeof
name|buf
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"Unrecognized command (buf ovf)"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Unrecognized command \"%s\" (args \"%s\")"
argument_list|,
name|name
argument_list|,
name|rest
argument_list|)
expr_stmt|;
name|ctl_response
argument_list|(
name|sess
argument_list|,
name|ctx
operator|->
name|unkncode
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_writedone
parameter_list|(
name|evContext
name|lev
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|bytes
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|me
index|[]
init|=
literal|"ctl_writedone"
decl_stmt|;
name|struct
name|ctl_sess
modifier|*
name|sess
init|=
name|uap
decl_stmt|;
name|struct
name|ctl_sctx
modifier|*
name|ctx
init|=
name|sess
operator|->
name|ctx
decl_stmt|;
name|char
name|tmp
index|[
name|MAX_NTOP
index|]
decl_stmt|;
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|UNUSED
argument_list|(
name|lev
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|uap
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sess
operator|->
name|state
operator|==
name|writing
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|fd
operator|==
name|sess
operator|->
name|sock
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sess
operator|->
name|wrtiID
operator|.
name|opaque
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sess
operator|->
name|wrID
operator|.
name|opaque
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|evClearIdleTimer
argument_list|(
name|ctx
operator|->
name|ev
argument_list|,
name|sess
operator|->
name|wrtiID
argument_list|)
expr_stmt|;
name|sess
operator|->
name|wrtiID
operator|.
name|opaque
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bytes
operator|<
literal|0
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|logger
call|)
argument_list|(
name|ctl_error
argument_list|,
literal|"%s: %s: %s"
argument_list|,
name|me
argument_list|,
name|address_expr
argument_list|,
name|strerror
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
name|ctl_close
argument_list|(
name|sess
argument_list|)
expr_stmt|;
return|return;
block|}
name|INSIST
argument_list|(
name|allocated_p
argument_list|(
name|sess
operator|->
name|outbuf
argument_list|)
argument_list|)
expr_stmt|;
name|ctl_bufput
argument_list|(
operator|&
name|sess
operator|->
name|outbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sess
operator|->
name|respflags
operator|&
name|CTL_EXIT
operator|)
operator|!=
literal|0
condition|)
block|{
name|ctl_signal_done
argument_list|(
name|ctx
argument_list|,
name|sess
argument_list|)
expr_stmt|;
name|ctl_close
argument_list|(
name|sess
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|sess
operator|->
name|respflags
operator|&
name|CTL_MORE
operator|)
operator|!=
literal|0
condition|)
block|{
name|INSIST
argument_list|(
name|sess
operator|->
name|verb
operator|!=
name|NULL
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sess
operator|->
name|verb
operator|->
name|func
call|)
argument_list|(
name|sess
operator|->
name|ctx
argument_list|,
name|sess
argument_list|,
name|sess
operator|->
name|verb
argument_list|,
literal|""
argument_list|,
name|CTL_MORE
argument_list|,
name|sess
operator|->
name|respctx
argument_list|,
name|sess
operator|->
name|ctx
operator|->
name|uctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctl_signal_done
argument_list|(
name|ctx
argument_list|,
name|sess
argument_list|)
expr_stmt|;
name|ctl_start_read
argument_list|(
name|sess
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_morehelp
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
name|ctx
parameter_list|,
name|struct
name|ctl_sess
modifier|*
name|sess
parameter_list|,
specifier|const
name|struct
name|ctl_verb
modifier|*
name|verb
parameter_list|,
specifier|const
name|char
modifier|*
name|text
parameter_list|,
name|u_int
name|respflags
parameter_list|,
specifier|const
name|void
modifier|*
name|respctx
parameter_list|,
name|void
modifier|*
name|uctx
parameter_list|)
block|{
specifier|const
name|struct
name|ctl_verb
modifier|*
name|this
init|=
name|respctx
decl_stmt|,
modifier|*
name|next
init|=
name|this
operator|+
literal|1
decl_stmt|;
name|UNUSED
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|verb
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|uctx
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|lastverb_p
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|respflags
operator|&
name|CTL_MORE
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastverb_p
argument_list|(
name|next
argument_list|)
condition|)
name|respflags
operator|&=
operator|~
name|CTL_MORE
expr_stmt|;
name|ctl_response
argument_list|(
name|sess
argument_list|,
name|sess
operator|->
name|helpcode
argument_list|,
name|this
operator|->
name|help
argument_list|,
name|respflags
argument_list|,
name|next
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctl_signal_done
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
name|ctx
parameter_list|,
name|struct
name|ctl_sess
modifier|*
name|sess
parameter_list|)
block|{
if|if
condition|(
name|sess
operator|->
name|donefunc
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|sess
operator|->
name|donefunc
call|)
argument_list|(
name|ctx
argument_list|,
name|sess
argument_list|,
name|sess
operator|->
name|uap
argument_list|)
expr_stmt|;
name|sess
operator|->
name|donefunc
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

end_unit

