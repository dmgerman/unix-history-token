begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1996-1999 by Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1995 by International Business Machines, Inc.  *  * International Business Machines, Inc. (hereinafter called IBM) grants  * permission under its copyrights to use, copy, modify, and distribute this  * Software with or without fee, provided that the above copyright notice and  * all paragraphs of this notice appear in all copies, and that the name of IBM  * not be used in connection with the marketing of any product incorporating  * the Software or modifications thereof, without specific, written prior  * permission.  *  * To the extent it has a right to do so, IBM grants an immunity from suit  * under its patents, if any, for the use, sale or manufacture of products to  * the extent that such products are used for performing Domain Name System  * dynamic updates in TCP/IP networks by means of the Software.  No immunity is  * granted for any product per se or for any other function of any product.  *  * THE SOFTWARE IS PROVIDED "AS IS", AND IBM DISCLAIMS ALL WARRANTIES,  * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  * PARTICULAR PURPOSE.  IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL,  * DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER ARISING  * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE, EVEN  * IF IBM IS APPRISED OF THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LINT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|CODECENTER
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: base64.c,v 8.7 1999/10/13 16:39:33 vixie Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_define
define|#
directive|define
name|Assert
parameter_list|(
name|Cond
parameter_list|)
value|if (!(Cond)) abort()
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
name|Base64
index|[]
init|=
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|Pad64
init|=
literal|'='
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (From RFC1521 and draft-ietf-dnssec-secext-03.txt)    The following encoding technique is taken from RFC 1521 by Borenstein    and Freed.  It is reproduced here in a slightly edited form for    convenience.     A 65-character subset of US-ASCII is used, enabling 6 bits to be    represented per printable character. (The extra 65th character, "=",    is used to signify a special processing function.)     The encoding process represents 24-bit groups of input bits as output    strings of 4 encoded characters. Proceeding from left to right, a    24-bit input group is formed by concatenating 3 8-bit input groups.    These 24 bits are then treated as 4 concatenated 6-bit groups, each    of which is translated into a single digit in the base64 alphabet.     Each 6-bit group is used as an index into an array of 64 printable    characters. The character referenced by the index is placed in the    output string.                           Table 1: The Base64 Alphabet        Value Encoding  Value Encoding  Value Encoding  Value Encoding           0 A            17 R            34 i            51 z           1 B            18 S            35 j            52 0           2 C            19 T            36 k            53 1           3 D            20 U            37 l            54 2           4 E            21 V            38 m            55 3           5 F            22 W            39 n            56 4           6 G            23 X            40 o            57 5           7 H            24 Y            41 p            58 6           8 I            25 Z            42 q            59 7           9 J            26 a            43 r            60 8          10 K            27 b            44 s            61 9          11 L            28 c            45 t            62 +          12 M            29 d            46 u            63 /          13 N            30 e            47 v          14 O            31 f            48 w         (pad) =          15 P            32 g            49 x          16 Q            33 h            50 y     Special processing is performed if fewer than 24 bits are available    at the end of the data being encoded.  A full encoding quantum is    always completed at the end of a quantity.  When fewer than 24 input    bits are available in an input group, zero bits are added (on the    right) to form an integral number of 6-bit groups.  Padding at the    end of the data is performed using the '=' character.     Since all base64 input is an integral number of octets, only the          -------------------------------------------------                           following cases can arise:            (1) the final quantum of encoding input is an integral            multiple of 24 bits; here, the final unit of encoded 	   output will be an integral multiple of 4 characters 	   with no "=" padding,        (2) the final quantum of encoding input is exactly 8 bits;            here, the final unit of encoded output will be two 	   characters followed by two "=" padding characters, or        (3) the final quantum of encoding input is exactly 16 bits;            here, the final unit of encoded output will be three 	   characters followed by one "=" padding character.    */
end_comment

begin_function
name|int
name|b64_ntop
parameter_list|(
name|u_char
specifier|const
modifier|*
name|src
parameter_list|,
name|size_t
name|srclength
parameter_list|,
name|char
modifier|*
name|target
parameter_list|,
name|size_t
name|targsize
parameter_list|)
block|{
name|size_t
name|datalength
init|=
literal|0
decl_stmt|;
name|u_char
name|input
index|[
literal|3
index|]
decl_stmt|;
name|u_char
name|output
index|[
literal|4
index|]
decl_stmt|;
name|size_t
name|i
decl_stmt|;
while|while
condition|(
literal|2
operator|<
name|srclength
condition|)
block|{
name|input
index|[
literal|0
index|]
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|input
index|[
literal|1
index|]
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|input
index|[
literal|2
index|]
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|srclength
operator|-=
literal|3
expr_stmt|;
name|output
index|[
literal|0
index|]
operator|=
name|input
index|[
literal|0
index|]
operator|>>
literal|2
expr_stmt|;
name|output
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|input
index|[
literal|0
index|]
operator|&
literal|0x03
operator|)
operator|<<
literal|4
operator|)
operator|+
operator|(
name|input
index|[
literal|1
index|]
operator|>>
literal|4
operator|)
expr_stmt|;
name|output
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|input
index|[
literal|1
index|]
operator|&
literal|0x0f
operator|)
operator|<<
literal|2
operator|)
operator|+
operator|(
name|input
index|[
literal|2
index|]
operator|>>
literal|6
operator|)
expr_stmt|;
name|output
index|[
literal|3
index|]
operator|=
name|input
index|[
literal|2
index|]
operator|&
literal|0x3f
expr_stmt|;
name|Assert
argument_list|(
name|output
index|[
literal|0
index|]
operator|<
literal|64
argument_list|)
expr_stmt|;
name|Assert
argument_list|(
name|output
index|[
literal|1
index|]
operator|<
literal|64
argument_list|)
expr_stmt|;
name|Assert
argument_list|(
name|output
index|[
literal|2
index|]
operator|<
literal|64
argument_list|)
expr_stmt|;
name|Assert
argument_list|(
name|output
index|[
literal|3
index|]
operator|<
literal|64
argument_list|)
expr_stmt|;
if|if
condition|(
name|datalength
operator|+
literal|4
operator|>
name|targsize
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|Base64
index|[
name|output
index|[
literal|0
index|]
index|]
expr_stmt|;
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|Base64
index|[
name|output
index|[
literal|1
index|]
index|]
expr_stmt|;
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|Base64
index|[
name|output
index|[
literal|2
index|]
index|]
expr_stmt|;
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|Base64
index|[
name|output
index|[
literal|3
index|]
index|]
expr_stmt|;
block|}
comment|/* Now we worry about padding. */
if|if
condition|(
literal|0
operator|!=
name|srclength
condition|)
block|{
comment|/* Get what's left. */
name|input
index|[
literal|0
index|]
operator|=
name|input
index|[
literal|1
index|]
operator|=
name|input
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|srclength
condition|;
name|i
operator|++
control|)
name|input
index|[
name|i
index|]
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|output
index|[
literal|0
index|]
operator|=
name|input
index|[
literal|0
index|]
operator|>>
literal|2
expr_stmt|;
name|output
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|input
index|[
literal|0
index|]
operator|&
literal|0x03
operator|)
operator|<<
literal|4
operator|)
operator|+
operator|(
name|input
index|[
literal|1
index|]
operator|>>
literal|4
operator|)
expr_stmt|;
name|output
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|input
index|[
literal|1
index|]
operator|&
literal|0x0f
operator|)
operator|<<
literal|2
operator|)
operator|+
operator|(
name|input
index|[
literal|2
index|]
operator|>>
literal|6
operator|)
expr_stmt|;
name|Assert
argument_list|(
name|output
index|[
literal|0
index|]
operator|<
literal|64
argument_list|)
expr_stmt|;
name|Assert
argument_list|(
name|output
index|[
literal|1
index|]
operator|<
literal|64
argument_list|)
expr_stmt|;
name|Assert
argument_list|(
name|output
index|[
literal|2
index|]
operator|<
literal|64
argument_list|)
expr_stmt|;
if|if
condition|(
name|datalength
operator|+
literal|4
operator|>
name|targsize
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|Base64
index|[
name|output
index|[
literal|0
index|]
index|]
expr_stmt|;
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|Base64
index|[
name|output
index|[
literal|1
index|]
index|]
expr_stmt|;
if|if
condition|(
name|srclength
operator|==
literal|1
condition|)
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|Pad64
expr_stmt|;
else|else
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|Base64
index|[
name|output
index|[
literal|2
index|]
index|]
expr_stmt|;
name|target
index|[
name|datalength
operator|++
index|]
operator|=
name|Pad64
expr_stmt|;
block|}
if|if
condition|(
name|datalength
operator|>=
name|targsize
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|target
index|[
name|datalength
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Returned value doesn't count \0. */
return|return
operator|(
name|datalength
operator|)
return|;
block|}
end_function

begin_comment
comment|/* skips all whitespace anywhere.    converts characters, four at a time, starting at (or after)    src from base - 64 numbers into three 8 bit bytes in the target area.    it returns the number of data bytes stored at the target, or -1 on error.  */
end_comment

begin_function
name|int
name|b64_pton
parameter_list|(
name|src
parameter_list|,
name|target
parameter_list|,
name|targsize
parameter_list|)
name|char
specifier|const
modifier|*
name|src
decl_stmt|;
name|u_char
modifier|*
name|target
decl_stmt|;
name|size_t
name|targsize
decl_stmt|;
block|{
name|int
name|tarindex
decl_stmt|,
name|state
decl_stmt|,
name|ch
decl_stmt|;
name|char
modifier|*
name|pos
decl_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
name|tarindex
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|src
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|isspace
argument_list|(
name|ch
argument_list|)
condition|)
comment|/* Skip whitespace anywhere. */
continue|continue;
if|if
condition|(
name|ch
operator|==
name|Pad64
condition|)
break|break;
name|pos
operator|=
name|strchr
argument_list|(
name|Base64
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
literal|0
condition|)
comment|/* A non-base64 character. */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|target
condition|)
block|{
if|if
condition|(
operator|(
name|size_t
operator|)
name|tarindex
operator|>=
name|targsize
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|target
index|[
name|tarindex
index|]
operator|=
operator|(
name|pos
operator|-
name|Base64
operator|)
operator|<<
literal|2
expr_stmt|;
block|}
name|state
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|target
condition|)
block|{
if|if
condition|(
operator|(
name|size_t
operator|)
name|tarindex
operator|+
literal|1
operator|>=
name|targsize
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|target
index|[
name|tarindex
index|]
operator||=
operator|(
name|pos
operator|-
name|Base64
operator|)
operator|>>
literal|4
expr_stmt|;
name|target
index|[
name|tarindex
operator|+
literal|1
index|]
operator|=
operator|(
operator|(
name|pos
operator|-
name|Base64
operator|)
operator|&
literal|0x0f
operator|)
operator|<<
literal|4
expr_stmt|;
block|}
name|tarindex
operator|++
expr_stmt|;
name|state
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|target
condition|)
block|{
if|if
condition|(
operator|(
name|size_t
operator|)
name|tarindex
operator|+
literal|1
operator|>=
name|targsize
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|target
index|[
name|tarindex
index|]
operator||=
operator|(
name|pos
operator|-
name|Base64
operator|)
operator|>>
literal|2
expr_stmt|;
name|target
index|[
name|tarindex
operator|+
literal|1
index|]
operator|=
operator|(
operator|(
name|pos
operator|-
name|Base64
operator|)
operator|&
literal|0x03
operator|)
operator|<<
literal|6
expr_stmt|;
block|}
name|tarindex
operator|++
expr_stmt|;
name|state
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|target
condition|)
block|{
if|if
condition|(
operator|(
name|size_t
operator|)
name|tarindex
operator|>=
name|targsize
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|target
index|[
name|tarindex
index|]
operator||=
operator|(
name|pos
operator|-
name|Base64
operator|)
expr_stmt|;
block|}
name|tarindex
operator|++
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* 	 * We are done decoding Base-64 chars.  Let's see if we ended 	 * on a byte boundary, and/or with erroneous trailing characters. 	 */
if|if
condition|(
name|ch
operator|==
name|Pad64
condition|)
block|{
comment|/* We got a pad char. */
name|ch
operator|=
operator|*
name|src
operator|++
expr_stmt|;
comment|/* Skip it, get next. */
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|0
case|:
comment|/* Invalid = in first position */
case|case
literal|1
case|:
comment|/* Invalid = in second position */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
literal|2
case|:
comment|/* Valid, means one byte of info */
comment|/* Skip any number of spaces. */
for|for
control|(
operator|(
name|void
operator|)
name|NULL
init|;
name|ch
operator|!=
literal|'\0'
condition|;
name|ch
operator|=
operator|*
name|src
operator|++
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
comment|/* Make sure there is another trailing = sign. */
if|if
condition|(
name|ch
operator|!=
name|Pad64
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ch
operator|=
operator|*
name|src
operator|++
expr_stmt|;
comment|/* Skip the = */
comment|/* Fall through to "single trailing =" case. */
comment|/* FALLTHROUGH */
case|case
literal|3
case|:
comment|/* Valid, means two bytes of info */
comment|/* 			 * We know this char is an =.  Is there anything but 			 * whitespace after it? 			 */
for|for
control|(
operator|(
name|void
operator|)
name|NULL
init|;
name|ch
operator|!=
literal|'\0'
condition|;
name|ch
operator|=
operator|*
name|src
operator|++
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|ch
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 			 * Now make sure for cases 2 and 3 that the "extra" 			 * bits that slopped past the last full byte were 			 * zeros.  If we don't check them, they become a 			 * subliminal channel. 			 */
if|if
condition|(
name|target
operator|&&
name|target
index|[
name|tarindex
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 		 * We ended by seeing the end of the string.  Make sure we 		 * have no partial bytes lying around. 		 */
if|if
condition|(
name|state
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|tarindex
operator|)
return|;
block|}
end_function

end_unit

