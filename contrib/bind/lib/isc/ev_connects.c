begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995-1999 by Internet Software Consortium  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/* ev_connects.c - implement asynch connect/accept for the eventlib  * vix 16sep96 [initial]  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LINT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|CODECENTER
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: ev_connects.c,v 8.32 2001/07/03 13:26:35 marka Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Import. */
end_comment

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|"fd_setsize.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<isc/eventlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/assertions.h>
end_include

begin_include
include|#
directive|include
file|"eventlib_p.h"
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_comment
comment|/* Macros. */
end_comment

begin_define
define|#
directive|define
name|GETXXXNAME
parameter_list|(
name|f
parameter_list|,
name|s
parameter_list|,
name|sa
parameter_list|,
name|len
parameter_list|)
value|( \ 	(f((s), (&sa), (&len))>= 0) ? 0 : \ 		(errno != EAFNOSUPPORT&& errno != EOPNOTSUPP) ? -1 : ( \ 			memset(&(sa), 0, sizeof (sa)), \ 			(len) = sizeof (sa), \ 			(sa).sa_family = AF_UNIX, \ 			0 \ 		) \ 	)
end_define

begin_comment
comment|/* Forward. */
end_comment

begin_function_decl
specifier|static
name|void
name|listener
parameter_list|(
name|evContext
name|ctx
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|evmask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|connector
parameter_list|(
name|evContext
name|ctx
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|evmask
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Public. */
end_comment

begin_function
name|int
name|evListen
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|maxconn
parameter_list|,
name|evConnFunc
name|func
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|evConnID
modifier|*
name|id
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
init|=
name|opaqueCtx
operator|.
name|opaque
decl_stmt|;
name|evConn
modifier|*
name|new
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|OKNEW
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|flags
operator|=
name|EV_CONN_LISTEN
expr_stmt|;
name|OK
argument_list|(
name|mode
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* side effect: validate fd. */
comment|/* 	 * Remember the nonblocking status.  We assume that either evSelectFD 	 * has not been done to this fd, or that if it has then the caller 	 * will evCancelConn before they evDeselectFD.  If our assumptions 	 * are not met, then we might restore the old nonblocking status 	 * incorrectly. 	 */
if|if
condition|(
operator|(
name|mode
operator|&
name|PORT_NONBLOCK
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_FIONBIO_IOCTL
name|int
name|on
init|=
literal|1
decl_stmt|;
name|OK
argument_list|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIONBIO
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|OK
argument_list|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|mode
operator||
name|PORT_NONBLOCK
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|new
operator|->
name|flags
operator||=
name|EV_CONN_BLOCK
expr_stmt|;
block|}
name|OK
argument_list|(
name|listen
argument_list|(
name|fd
argument_list|,
name|maxconn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|evSelectFD
argument_list|(
name|opaqueCtx
argument_list|,
name|fd
argument_list|,
name|EV_READ
argument_list|,
name|listener
argument_list|,
name|new
argument_list|,
operator|&
name|new
operator|->
name|file
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|save
init|=
name|errno
decl_stmt|;
name|FREE
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|new
operator|->
name|flags
operator||=
name|EV_CONN_SELECTED
expr_stmt|;
name|new
operator|->
name|func
operator|=
name|func
expr_stmt|;
name|new
operator|->
name|uap
operator|=
name|uap
expr_stmt|;
name|new
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|conns
operator|!=
name|NULL
condition|)
name|ctx
operator|->
name|conns
operator|->
name|prev
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|ctx
operator|->
name|conns
expr_stmt|;
name|ctx
operator|->
name|conns
operator|=
name|new
expr_stmt|;
if|if
condition|(
name|id
condition|)
name|id
operator|->
name|opaque
operator|=
name|new
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evConnect
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|,
name|int
name|fd
parameter_list|,
specifier|const
name|void
modifier|*
name|ra
parameter_list|,
name|int
name|ralen
parameter_list|,
name|evConnFunc
name|func
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|evConnID
modifier|*
name|id
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
init|=
name|opaqueCtx
operator|.
name|opaque
decl_stmt|;
name|evConn
modifier|*
name|new
decl_stmt|;
name|OKNEW
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* Do the select() first to get the socket into nonblocking mode. */
if|if
condition|(
name|evSelectFD
argument_list|(
name|opaqueCtx
argument_list|,
name|fd
argument_list|,
name|EV_MASK_ALL
argument_list|,
name|connector
argument_list|,
name|new
argument_list|,
operator|&
name|new
operator|->
name|file
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|save
init|=
name|errno
decl_stmt|;
name|FREE
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|new
operator|->
name|flags
operator||=
name|EV_CONN_SELECTED
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|fd
argument_list|,
name|ra
argument_list|,
name|ralen
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EWOULDBLOCK
operator|&&
name|errno
operator|!=
name|EAGAIN
operator|&&
name|errno
operator|!=
name|EINPROGRESS
condition|)
block|{
name|int
name|save
init|=
name|errno
decl_stmt|;
operator|(
name|void
operator|)
name|evDeselectFD
argument_list|(
name|opaqueCtx
argument_list|,
name|new
operator|->
name|file
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* No error, or EWOULDBLOCK.  select() tells when it's ready. */
name|new
operator|->
name|func
operator|=
name|func
expr_stmt|;
name|new
operator|->
name|uap
operator|=
name|uap
expr_stmt|;
name|new
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|conns
operator|!=
name|NULL
condition|)
name|ctx
operator|->
name|conns
operator|->
name|prev
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|ctx
operator|->
name|conns
expr_stmt|;
name|ctx
operator|->
name|conns
operator|=
name|new
expr_stmt|;
if|if
condition|(
name|id
condition|)
name|id
operator|->
name|opaque
operator|=
name|new
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evCancelConn
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|,
name|evConnID
name|id
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
init|=
name|opaqueCtx
operator|.
name|opaque
decl_stmt|;
name|evConn
modifier|*
name|this
init|=
name|id
operator|.
name|opaque
decl_stmt|;
name|evAccept
modifier|*
name|acc
decl_stmt|,
modifier|*
name|nxtacc
decl_stmt|;
name|int
name|mode
decl_stmt|;
if|if
condition|(
operator|(
name|this
operator|->
name|flags
operator|&
name|EV_CONN_SELECTED
operator|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|evDeselectFD
argument_list|(
name|opaqueCtx
argument_list|,
name|this
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|this
operator|->
name|flags
operator|&
name|EV_CONN_BLOCK
operator|)
operator|!=
literal|0
condition|)
block|{
name|mode
operator|=
name|fcntl
argument_list|(
name|this
operator|->
name|fd
argument_list|,
name|F_GETFL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EBADF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|USE_FIONBIO_IOCTL
name|int
name|on
init|=
literal|1
decl_stmt|;
name|OK
argument_list|(
name|ioctl
argument_list|(
name|this
operator|->
name|fd
argument_list|,
name|FIONBIO
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|OK
argument_list|(
name|fcntl
argument_list|(
name|this
operator|->
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|mode
operator||
name|PORT_NONBLOCK
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* Unlink from ctx->conns. */
if|if
condition|(
name|this
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|this
operator|->
name|prev
operator|->
name|next
operator|=
name|this
operator|->
name|next
expr_stmt|;
else|else
name|ctx
operator|->
name|conns
operator|=
name|this
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|this
operator|->
name|next
operator|!=
name|NULL
condition|)
name|this
operator|->
name|next
operator|->
name|prev
operator|=
name|this
operator|->
name|prev
expr_stmt|;
comment|/* 	 * Remove `this' from the ctx->accepts list (zero or more times). 	 */
for|for
control|(
name|acc
operator|=
name|HEAD
argument_list|(
name|ctx
operator|->
name|accepts
argument_list|)
operator|,
name|nxtacc
operator|=
name|NULL
init|;
name|acc
operator|!=
name|NULL
condition|;
name|acc
operator|=
name|nxtacc
control|)
block|{
name|nxtacc
operator|=
name|NEXT
argument_list|(
name|acc
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|acc
operator|->
name|conn
operator|==
name|this
condition|)
block|{
name|UNLINK
argument_list|(
name|ctx
operator|->
name|accepts
argument_list|,
name|acc
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|acc
operator|->
name|fd
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|acc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Wrap up and get out. */
name|FREE
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evHold
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|,
name|evConnID
name|id
parameter_list|)
block|{
name|evConn
modifier|*
name|this
init|=
name|id
operator|.
name|opaque
decl_stmt|;
if|if
condition|(
operator|(
name|this
operator|->
name|flags
operator|&
name|EV_CONN_LISTEN
operator|)
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|this
operator|->
name|flags
operator|&
name|EV_CONN_SELECTED
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|this
operator|->
name|flags
operator|&=
operator|~
name|EV_CONN_SELECTED
expr_stmt|;
return|return
operator|(
name|evDeselectFD
argument_list|(
name|opaqueCtx
argument_list|,
name|this
operator|->
name|file
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evUnhold
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|,
name|evConnID
name|id
parameter_list|)
block|{
name|evConn
modifier|*
name|this
init|=
name|id
operator|.
name|opaque
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|this
operator|->
name|flags
operator|&
name|EV_CONN_LISTEN
operator|)
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|this
operator|->
name|flags
operator|&
name|EV_CONN_SELECTED
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ret
operator|=
name|evSelectFD
argument_list|(
name|opaqueCtx
argument_list|,
name|this
operator|->
name|fd
argument_list|,
name|EV_READ
argument_list|,
name|listener
argument_list|,
name|this
argument_list|,
operator|&
name|this
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|this
operator|->
name|flags
operator||=
name|EV_CONN_SELECTED
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evTryAccept
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|,
name|evConnID
name|id
parameter_list|,
name|int
modifier|*
name|sys_errno
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
init|=
name|opaqueCtx
operator|.
name|opaque
decl_stmt|;
name|evConn
modifier|*
name|conn
init|=
name|id
operator|.
name|opaque
decl_stmt|;
name|evAccept
modifier|*
name|new
decl_stmt|;
if|if
condition|(
operator|(
name|conn
operator|->
name|flags
operator|&
name|EV_CONN_LISTEN
operator|)
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|OKNEW
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|conn
operator|=
name|conn
expr_stmt|;
name|new
operator|->
name|ralen
operator|=
sizeof|sizeof
name|new
operator|->
name|ra
expr_stmt|;
name|new
operator|->
name|fd
operator|=
name|accept
argument_list|(
name|conn
operator|->
name|fd
argument_list|,
operator|&
name|new
operator|->
name|ra
operator|.
name|sa
argument_list|,
operator|&
name|new
operator|->
name|ralen
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|fd
operator|>
name|ctx
operator|->
name|highestFD
condition|)
block|{
name|close
argument_list|(
name|new
operator|->
name|fd
argument_list|)
expr_stmt|;
name|new
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|new
operator|->
name|ioErrno
operator|=
name|ENOTSOCK
expr_stmt|;
block|}
if|if
condition|(
name|new
operator|->
name|fd
operator|>=
literal|0
condition|)
block|{
name|new
operator|->
name|lalen
operator|=
sizeof|sizeof
name|new
operator|->
name|la
expr_stmt|;
if|if
condition|(
name|GETXXXNAME
argument_list|(
name|getsockname
argument_list|,
name|new
operator|->
name|fd
argument_list|,
name|new
operator|->
name|la
operator|.
name|sa
argument_list|,
name|new
operator|->
name|lalen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|new
operator|->
name|ioErrno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|new
operator|->
name|fd
argument_list|)
expr_stmt|;
name|new
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|new
operator|->
name|ioErrno
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|new
operator|->
name|ioErrno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|FREE
argument_list|(
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|INIT_LINK
argument_list|(
name|new
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|APPEND
argument_list|(
name|ctx
operator|->
name|accepts
argument_list|,
name|new
argument_list|,
name|link
argument_list|)
expr_stmt|;
operator|*
name|sys_errno
operator|=
name|new
operator|->
name|ioErrno
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Private. */
end_comment

begin_function
specifier|static
name|void
name|listener
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|evmask
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
init|=
name|opaqueCtx
operator|.
name|opaque
decl_stmt|;
name|evConn
modifier|*
name|conn
init|=
name|uap
decl_stmt|;
union|union
block|{
name|struct
name|sockaddr
name|sa
decl_stmt|;
name|struct
name|sockaddr_in
name|in
decl_stmt|;
ifndef|#
directive|ifndef
name|NO_SOCKADDR_UN
name|struct
name|sockaddr_un
name|un
decl_stmt|;
endif|#
directive|endif
block|}
name|la
union|,
name|ra
union|;
name|int
name|new
decl_stmt|;
name|ISC_SOCKLEN_T
name|lalen
init|=
literal|0
decl_stmt|,
name|ralen
decl_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|evmask
operator|&
name|EV_READ
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ralen
operator|=
sizeof|sizeof
name|ra
expr_stmt|;
name|new
operator|=
name|accept
argument_list|(
name|fd
argument_list|,
operator|&
name|ra
operator|.
name|sa
argument_list|,
operator|&
name|ralen
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|>
name|ctx
operator|->
name|highestFD
condition|)
block|{
name|close
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
operator|-
literal|1
expr_stmt|;
name|errno
operator|=
name|ENOTSOCK
expr_stmt|;
block|}
if|if
condition|(
name|new
operator|>=
literal|0
condition|)
block|{
name|lalen
operator|=
sizeof|sizeof
name|la
expr_stmt|;
if|if
condition|(
name|GETXXXNAME
argument_list|(
name|getsockname
argument_list|,
name|new
argument_list|,
name|la
operator|.
name|sa
argument_list|,
name|lalen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|save
init|=
name|errno
decl_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save
expr_stmt|;
name|new
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
condition|)
return|return;
call|(
modifier|*
name|conn
operator|->
name|func
call|)
argument_list|(
name|opaqueCtx
argument_list|,
name|conn
operator|->
name|uap
argument_list|,
name|new
argument_list|,
operator|&
name|la
operator|.
name|sa
argument_list|,
name|lalen
argument_list|,
operator|&
name|ra
operator|.
name|sa
argument_list|,
name|ralen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|connector
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|evmask
parameter_list|)
block|{
name|evConn
modifier|*
name|conn
init|=
name|uap
decl_stmt|;
union|union
block|{
name|struct
name|sockaddr
name|sa
decl_stmt|;
name|struct
name|sockaddr_in
name|in
decl_stmt|;
ifndef|#
directive|ifndef
name|NO_SOCKADDR_UN
name|struct
name|sockaddr_un
name|un
decl_stmt|;
endif|#
directive|endif
block|}
name|la
union|,
name|ra
union|;
name|ISC_SOCKLEN_T
name|lalen
decl_stmt|,
name|ralen
decl_stmt|;
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|void
modifier|*
name|conn_uap
decl_stmt|;
name|evConnFunc
name|conn_func
decl_stmt|;
name|evConnID
name|id
decl_stmt|;
name|int
name|socket_errno
init|=
literal|0
decl_stmt|;
name|ISC_SOCKLEN_T
name|optlen
decl_stmt|;
name|UNUSED
argument_list|(
name|evmask
argument_list|)
expr_stmt|;
name|lalen
operator|=
sizeof|sizeof
name|la
expr_stmt|;
name|ralen
operator|=
sizeof|sizeof
name|ra
expr_stmt|;
name|conn_uap
operator|=
name|conn
operator|->
name|uap
expr_stmt|;
name|conn_func
operator|=
name|conn
operator|->
name|func
expr_stmt|;
name|id
operator|.
name|opaque
operator|=
name|conn
expr_stmt|;
ifdef|#
directive|ifdef
name|SO_ERROR
name|optlen
operator|=
sizeof|sizeof
name|socket_errno
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
operator|&&
name|getsockopt
argument_list|(
name|conn
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_ERROR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|socket_errno
argument_list|,
operator|&
name|optlen
argument_list|)
operator|<
literal|0
condition|)
name|socket_errno
operator|=
name|errno
expr_stmt|;
else|else
name|errno
operator|=
name|socket_errno
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|evCancelConn
argument_list|(
name|opaqueCtx
argument_list|,
name|id
argument_list|)
operator|<
literal|0
operator|||
name|socket_errno
operator|||
ifdef|#
directive|ifdef
name|NETREAD_BROKEN
literal|0
operator|||
else|#
directive|else
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|||
endif|#
directive|endif
name|GETXXXNAME
argument_list|(
name|getsockname
argument_list|,
name|fd
argument_list|,
name|la
operator|.
name|sa
argument_list|,
name|lalen
argument_list|)
operator|<
literal|0
operator|||
name|GETXXXNAME
argument_list|(
name|getpeername
argument_list|,
name|fd
argument_list|,
name|ra
operator|.
name|sa
argument_list|,
name|ralen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|save
init|=
name|errno
decl_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* XXX closing caller's fd */
name|errno
operator|=
name|save
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
call|(
modifier|*
name|conn_func
call|)
argument_list|(
name|opaqueCtx
argument_list|,
name|conn_uap
argument_list|,
name|fd
argument_list|,
operator|&
name|la
operator|.
name|sa
argument_list|,
name|lalen
argument_list|,
operator|&
name|ra
operator|.
name|sa
argument_list|,
name|ralen
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

