begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1996-1999 by Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LINT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|CODECENTER
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: logging.c,v 8.31 2001/06/18 14:44:03 marka Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<isc/assertions.h>
end_include

begin_include
include|#
directive|include
file|<isc/logging.h>
end_include

begin_include
include|#
directive|include
file|<isc/memcluster.h>
end_include

begin_include
include|#
directive|include
file|<isc/misc.h>
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|VSPRINTF_CHAR
end_ifdef

begin_define
define|#
directive|define
name|VSPRINTF
parameter_list|(
name|x
parameter_list|)
value|strlen(vsprintf
comment|/**/
value|x)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|VSPRINTF
parameter_list|(
name|x
parameter_list|)
value|((size_t)vsprintf x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"logging_p.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|int
name|syslog_priority
index|[]
init|=
block|{
name|LOG_DEBUG
block|,
name|LOG_INFO
block|,
name|LOG_NOTICE
block|,
name|LOG_WARNING
block|,
name|LOG_ERR
block|,
name|LOG_CRIT
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|months
index|[]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|level_text
index|[]
init|=
block|{
literal|"info: "
block|,
literal|"notice: "
block|,
literal|"warning: "
block|,
literal|"error: "
block|,
literal|"critical: "
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|version_rename
parameter_list|(
name|log_channel
name|chan
parameter_list|)
block|{
name|unsigned
name|int
name|ver
decl_stmt|;
name|char
name|old_name
index|[
name|PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|new_name
index|[
name|PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|ver
operator|=
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|versions
expr_stmt|;
if|if
condition|(
name|ver
operator|<
literal|1
condition|)
return|return;
if|if
condition|(
name|ver
operator|>
name|LOG_MAX_VERSIONS
condition|)
name|ver
operator|=
name|LOG_MAX_VERSIONS
expr_stmt|;
comment|/* 	 * Need to have room for '.nn' (XXX assumes LOG_MAX_VERSIONS< 100) 	 */
if|if
condition|(
name|strlen
argument_list|(
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|name
argument_list|)
operator|>
operator|(
name|PATH_MAX
operator|-
literal|3
operator|)
condition|)
return|return;
for|for
control|(
name|ver
operator|--
init|;
name|ver
operator|>
literal|0
condition|;
name|ver
operator|--
control|)
block|{
name|sprintf
argument_list|(
name|old_name
argument_list|,
literal|"%s.%d"
argument_list|,
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|name
argument_list|,
name|ver
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|new_name
argument_list|,
literal|"%s.%d"
argument_list|,
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|name
argument_list|,
name|ver
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|isc_movefile
argument_list|(
name|old_name
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|new_name
argument_list|,
literal|"%s.0"
argument_list|,
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|isc_movefile
argument_list|(
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|name
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|FILE
modifier|*
name|log_open_stream
parameter_list|(
name|log_channel
name|chan
parameter_list|)
block|{
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|regular
decl_stmt|;
if|if
condition|(
name|chan
operator|==
name|NULL
operator|||
name|chan
operator|->
name|type
operator|!=
name|log_file
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Don't open already open streams 	 */
if|if
condition|(
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|stream
operator|!=
name|NULL
condition|)
return|return
operator|(
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|stream
operator|)
return|;
if|if
condition|(
name|stat
argument_list|(
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|name
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"log_open_stream: stat of %s failed: %s"
argument_list|,
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|chan
operator|->
name|flags
operator||=
name|LOG_CHANNEL_BROKEN
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|regular
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|regular
operator|=
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IFREG
operator|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|versions
condition|)
block|{
if|if
condition|(
operator|!
name|regular
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"log_open_stream: want versions but %s isn't a regular file"
argument_list|,
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|name
argument_list|)
expr_stmt|;
name|chan
operator|->
name|flags
operator||=
name|LOG_CHANNEL_BROKEN
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|flags
operator|=
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_APPEND
expr_stmt|;
if|if
condition|(
operator|(
name|chan
operator|->
name|flags
operator|&
name|LOG_TRUNCATE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|regular
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|name
argument_list|)
expr_stmt|;
name|flags
operator||=
name|O_EXCL
expr_stmt|;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"log_open_stream: want truncation but %s isn't a regular file"
argument_list|,
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|name
argument_list|)
expr_stmt|;
name|chan
operator|->
name|flags
operator||=
name|LOG_CHANNEL_BROKEN
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|fd
operator|=
name|open
argument_list|(
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|name
argument_list|,
name|flags
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
operator||
name|S_IRGRP
operator||
name|S_IWGRP
operator||
name|S_IROTH
operator||
name|S_IWOTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"log_open_stream: open(%s) failed: %s"
argument_list|,
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|chan
operator|->
name|flags
operator||=
name|LOG_CHANNEL_BROKEN
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|stream
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"log_open_stream: fdopen() failed"
argument_list|)
expr_stmt|;
name|chan
operator|->
name|flags
operator||=
name|LOG_CHANNEL_BROKEN
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|fchown
argument_list|(
name|fd
argument_list|,
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|owner
argument_list|,
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|group
argument_list|)
expr_stmt|;
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|stream
operator|=
name|stream
expr_stmt|;
return|return
operator|(
name|stream
operator|)
return|;
block|}
end_function

begin_function
name|int
name|log_close_stream
parameter_list|(
name|log_channel
name|chan
parameter_list|)
block|{
name|FILE
modifier|*
name|stream
decl_stmt|;
if|if
condition|(
name|chan
operator|==
name|NULL
operator|||
name|chan
operator|->
name|type
operator|!=
name|log_file
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|stream
operator|=
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|stream
expr_stmt|;
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|stream
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|stream
operator|!=
name|NULL
operator|&&
name|fclose
argument_list|(
name|stream
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|log_close_debug_channels
parameter_list|(
name|log_context
name|lc
parameter_list|)
block|{
name|log_channel_list
name|lcl
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lc
operator|->
name|num_categories
condition|;
name|i
operator|++
control|)
for|for
control|(
name|lcl
operator|=
name|lc
operator|->
name|categories
index|[
name|i
index|]
init|;
name|lcl
operator|!=
name|NULL
condition|;
name|lcl
operator|=
name|lcl
operator|->
name|next
control|)
if|if
condition|(
name|lcl
operator|->
name|channel
operator|->
name|type
operator|==
name|log_file
operator|&&
name|lcl
operator|->
name|channel
operator|->
name|out
operator|.
name|file
operator|.
name|stream
operator|!=
name|NULL
operator|&&
name|lcl
operator|->
name|channel
operator|->
name|flags
operator|&
name|LOG_REQUIRE_DEBUG
condition|)
operator|(
name|void
operator|)
name|log_close_stream
argument_list|(
name|lcl
operator|->
name|channel
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|FILE
modifier|*
name|log_get_stream
parameter_list|(
name|log_channel
name|chan
parameter_list|)
block|{
if|if
condition|(
name|chan
operator|==
name|NULL
operator|||
name|chan
operator|->
name|type
operator|!=
name|log_file
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|stream
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|log_get_filename
parameter_list|(
name|log_channel
name|chan
parameter_list|)
block|{
if|if
condition|(
name|chan
operator|==
name|NULL
operator|||
name|chan
operator|->
name|type
operator|!=
name|log_file
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|name
operator|)
return|;
block|}
end_function

begin_function
name|int
name|log_check_channel
parameter_list|(
name|log_context
name|lc
parameter_list|,
name|int
name|level
parameter_list|,
name|log_channel
name|chan
parameter_list|)
block|{
name|int
name|debugging
decl_stmt|,
name|chan_level
decl_stmt|;
name|REQUIRE
argument_list|(
name|lc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|debugging
operator|=
operator|(
operator|(
name|lc
operator|->
name|flags
operator|&
name|LOG_OPTION_DEBUG
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* 	 * If not debugging, short circuit debugging messages very early. 	 */
if|if
condition|(
name|level
operator|>
literal|0
operator|&&
operator|!
name|debugging
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|chan
operator|->
name|flags
operator|&
operator|(
name|LOG_CHANNEL_BROKEN
operator||
name|LOG_CHANNEL_OFF
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Some channels only log when debugging is on. */
if|if
condition|(
operator|(
name|chan
operator|->
name|flags
operator|&
name|LOG_REQUIRE_DEBUG
operator|)
operator|&&
operator|!
name|debugging
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Some channels use the global level. */
if|if
condition|(
operator|(
name|chan
operator|->
name|flags
operator|&
name|LOG_USE_CONTEXT_LEVEL
operator|)
operator|!=
literal|0
condition|)
block|{
name|chan_level
operator|=
name|lc
operator|->
name|level
expr_stmt|;
block|}
else|else
name|chan_level
operator|=
name|chan
operator|->
name|level
expr_stmt|;
if|if
condition|(
name|level
operator|>
name|chan_level
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|log_check
parameter_list|(
name|log_context
name|lc
parameter_list|,
name|int
name|category
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|log_channel_list
name|lcl
decl_stmt|;
name|int
name|debugging
decl_stmt|;
name|REQUIRE
argument_list|(
name|lc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|debugging
operator|=
operator|(
operator|(
name|lc
operator|->
name|flags
operator|&
name|LOG_OPTION_DEBUG
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* 	 * If not debugging, short circuit debugging messages very early. 	 */
if|if
condition|(
name|level
operator|>
literal|0
operator|&&
operator|!
name|debugging
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|category
operator|<
literal|0
operator|||
name|category
operator|>
name|lc
operator|->
name|num_categories
condition|)
name|category
operator|=
literal|0
expr_stmt|;
comment|/* use default */
name|lcl
operator|=
name|lc
operator|->
name|categories
index|[
name|category
index|]
expr_stmt|;
if|if
condition|(
name|lcl
operator|==
name|NULL
condition|)
block|{
name|category
operator|=
literal|0
expr_stmt|;
name|lcl
operator|=
name|lc
operator|->
name|categories
index|[
literal|0
index|]
expr_stmt|;
block|}
for|for
control|(
comment|/* nothing */
init|;
name|lcl
operator|!=
name|NULL
condition|;
name|lcl
operator|=
name|lcl
operator|->
name|next
control|)
block|{
if|if
condition|(
name|log_check_channel
argument_list|(
name|lc
argument_list|,
name|level
argument_list|,
name|lcl
operator|->
name|channel
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|log_vwrite
parameter_list|(
name|log_context
name|lc
parameter_list|,
name|int
name|category
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
name|log_channel_list
name|lcl
decl_stmt|;
name|int
name|pri
decl_stmt|,
name|debugging
decl_stmt|,
name|did_vsprintf
init|=
literal|0
decl_stmt|;
name|int
name|original_category
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|log_channel
name|chan
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|tm
modifier|*
name|local_tm
decl_stmt|;
specifier|const
name|char
modifier|*
name|category_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|level_str
decl_stmt|;
name|char
name|time_buf
index|[
literal|256
index|]
decl_stmt|;
name|char
name|level_buf
index|[
literal|256
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|lc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|debugging
operator|=
operator|(
name|lc
operator|->
name|flags
operator|&
name|LOG_OPTION_DEBUG
operator|)
expr_stmt|;
comment|/* 	 * If not debugging, short circuit debugging messages very early. 	 */
if|if
condition|(
name|level
operator|>
literal|0
operator|&&
operator|!
name|debugging
condition|)
return|return;
if|if
condition|(
name|category
operator|<
literal|0
operator|||
name|category
operator|>
name|lc
operator|->
name|num_categories
condition|)
name|category
operator|=
literal|0
expr_stmt|;
comment|/* use default */
name|original_category
operator|=
name|category
expr_stmt|;
name|lcl
operator|=
name|lc
operator|->
name|categories
index|[
name|category
index|]
expr_stmt|;
if|if
condition|(
name|lcl
operator|==
name|NULL
condition|)
block|{
name|category
operator|=
literal|0
expr_stmt|;
name|lcl
operator|=
name|lc
operator|->
name|categories
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* 	 * Get the current time and format it. 	 */
name|time_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"gettimeofday failed in log_vwrite()"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_TIME_R
name|localtime_r
argument_list|(
operator|(
name|time_t
operator|*
operator|)
operator|&
name|tv
operator|.
name|tv_sec
argument_list|,
operator|&
name|local_tm
argument_list|)
expr_stmt|;
else|#
directive|else
name|local_tm
operator|=
name|localtime
argument_list|(
operator|(
name|time_t
operator|*
operator|)
operator|&
name|tv
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|local_tm
operator|!=
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|time_buf
argument_list|,
literal|"%02d-%s-%4d %02d:%02d:%02d.%03ld "
argument_list|,
name|local_tm
operator|->
name|tm_mday
argument_list|,
name|months
index|[
name|local_tm
operator|->
name|tm_mon
index|]
argument_list|,
name|local_tm
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|local_tm
operator|->
name|tm_hour
argument_list|,
name|local_tm
operator|->
name|tm_min
argument_list|,
name|local_tm
operator|->
name|tm_sec
argument_list|,
operator|(
name|long
operator|)
name|tv
operator|.
name|tv_usec
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Make a string representation of the current category and level 	 */
if|if
condition|(
name|lc
operator|->
name|category_names
operator|!=
name|NULL
operator|&&
name|lc
operator|->
name|category_names
index|[
name|original_category
index|]
operator|!=
name|NULL
condition|)
name|category_name
operator|=
name|lc
operator|->
name|category_names
index|[
name|original_category
index|]
expr_stmt|;
else|else
name|category_name
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|level
operator|>=
name|log_critical
condition|)
block|{
if|if
condition|(
name|level
operator|>=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|level_buf
argument_list|,
literal|"debug %d: "
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|level_str
operator|=
name|level_buf
expr_stmt|;
block|}
else|else
name|level_str
operator|=
name|level_text
index|[
operator|-
name|level
operator|-
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|level_buf
argument_list|,
literal|"level %d: "
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|level_str
operator|=
name|level_buf
expr_stmt|;
block|}
comment|/* 	 * Write the message to channels. 	 */
for|for
control|(
comment|/* nothing */
init|;
name|lcl
operator|!=
name|NULL
condition|;
name|lcl
operator|=
name|lcl
operator|->
name|next
control|)
block|{
name|chan
operator|=
name|lcl
operator|->
name|channel
expr_stmt|;
if|if
condition|(
operator|!
name|log_check_channel
argument_list|(
name|lc
argument_list|,
name|level
argument_list|,
name|chan
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|did_vsprintf
condition|)
block|{
if|if
condition|(
name|VSPRINTF
argument_list|(
operator|(
name|lc
operator|->
name|buffer
operator|,
name|format
operator|,
name|args
operator|)
argument_list|)
operator|>
name|LOG_BUFFER_SIZE
condition|)
block|{
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"memory overrun in log_vwrite()"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|did_vsprintf
operator|=
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|chan
operator|->
name|type
condition|)
block|{
case|case
name|log_syslog
case|:
if|if
condition|(
name|level
operator|>=
name|log_critical
condition|)
name|pri
operator|=
operator|(
name|level
operator|>=
literal|0
operator|)
condition|?
literal|0
else|:
operator|-
name|level
expr_stmt|;
else|else
name|pri
operator|=
operator|-
name|log_critical
expr_stmt|;
name|syslog
argument_list|(
name|chan
operator|->
name|out
operator|.
name|facility
operator||
name|syslog_priority
index|[
name|pri
index|]
argument_list|,
literal|"%s%s%s%s"
argument_list|,
operator|(
name|chan
operator|->
name|flags
operator|&
name|LOG_TIMESTAMP
operator|)
condition|?
name|time_buf
else|:
literal|""
argument_list|,
operator|(
name|chan
operator|->
name|flags
operator|&
name|LOG_PRINT_CATEGORY
operator|)
condition|?
name|category_name
else|:
literal|""
argument_list|,
operator|(
name|chan
operator|->
name|flags
operator|&
name|LOG_PRINT_LEVEL
operator|)
condition|?
name|level_str
else|:
literal|""
argument_list|,
name|lc
operator|->
name|buffer
argument_list|)
expr_stmt|;
break|break;
case|case
name|log_file
case|:
name|stream
operator|=
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|stream
expr_stmt|;
if|if
condition|(
name|stream
operator|==
name|NULL
condition|)
block|{
name|stream
operator|=
name|log_open_stream
argument_list|(
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|max_size
operator|!=
name|ULONG_MAX
condition|)
block|{
name|long
name|pos
decl_stmt|;
name|pos
operator|=
name|ftell
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
literal|0
operator|&&
operator|(
name|unsigned
name|long
operator|)
name|pos
operator|>
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|max_size
condition|)
block|{
comment|/* 					 * try to roll over the log files, 					 * ignoring all all return codes 					 * except the open (we don't want 					 * to write any more anyway) 					 */
name|log_close_stream
argument_list|(
name|chan
argument_list|)
expr_stmt|;
name|version_rename
argument_list|(
name|chan
argument_list|)
expr_stmt|;
name|stream
operator|=
name|log_open_stream
argument_list|(
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|==
name|NULL
condition|)
break|break;
block|}
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s%s%s%s\n"
argument_list|,
operator|(
name|chan
operator|->
name|flags
operator|&
name|LOG_TIMESTAMP
operator|)
condition|?
name|time_buf
else|:
literal|""
argument_list|,
operator|(
name|chan
operator|->
name|flags
operator|&
name|LOG_PRINT_CATEGORY
operator|)
condition|?
name|category_name
else|:
literal|""
argument_list|,
operator|(
name|chan
operator|->
name|flags
operator|&
name|LOG_PRINT_LEVEL
operator|)
condition|?
name|level_str
else|:
literal|""
argument_list|,
name|lc
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
name|log_null
case|:
break|break;
default|default:
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unknown channel type in log_vwrite()"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|log_write
parameter_list|(
name|log_context
name|lc
parameter_list|,
name|int
name|category
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|log_vwrite
argument_list|(
name|lc
argument_list|,
name|category
argument_list|,
name|level
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Functions to create, set, or destroy contexts  */
end_comment

begin_function
name|int
name|log_new_context
parameter_list|(
name|int
name|num_categories
parameter_list|,
name|char
modifier|*
modifier|*
name|category_names
parameter_list|,
name|log_context
modifier|*
name|lc
parameter_list|)
block|{
name|log_context
name|nlc
decl_stmt|;
name|nlc
operator|=
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|log_context
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlc
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|nlc
operator|->
name|num_categories
operator|=
name|num_categories
expr_stmt|;
name|nlc
operator|->
name|category_names
operator|=
name|category_names
expr_stmt|;
name|nlc
operator|->
name|categories
operator|=
name|memget
argument_list|(
name|num_categories
operator|*
sizeof|sizeof
argument_list|(
name|log_channel_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlc
operator|->
name|categories
operator|==
name|NULL
condition|)
block|{
name|memput
argument_list|(
name|nlc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|log_context
argument_list|)
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|memset
argument_list|(
name|nlc
operator|->
name|categories
argument_list|,
literal|'\0'
argument_list|,
name|num_categories
operator|*
sizeof|sizeof
argument_list|(
name|log_channel_list
argument_list|)
argument_list|)
expr_stmt|;
name|nlc
operator|->
name|flags
operator|=
literal|0U
expr_stmt|;
name|nlc
operator|->
name|level
operator|=
literal|0
expr_stmt|;
operator|*
name|lc
operator|=
name|nlc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|log_free_context
parameter_list|(
name|log_context
name|lc
parameter_list|)
block|{
name|log_channel_list
name|lcl
decl_stmt|,
name|lcl_next
decl_stmt|;
name|log_channel
name|chan
decl_stmt|;
name|int
name|i
decl_stmt|;
name|REQUIRE
argument_list|(
name|lc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lc
operator|->
name|num_categories
condition|;
name|i
operator|++
control|)
for|for
control|(
name|lcl
operator|=
name|lc
operator|->
name|categories
index|[
name|i
index|]
init|;
name|lcl
operator|!=
name|NULL
condition|;
name|lcl
operator|=
name|lcl_next
control|)
block|{
name|lcl_next
operator|=
name|lcl
operator|->
name|next
expr_stmt|;
name|chan
operator|=
name|lcl
operator|->
name|channel
expr_stmt|;
operator|(
name|void
operator|)
name|log_free_channel
argument_list|(
name|chan
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|lcl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|log_channel_list
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|memput
argument_list|(
name|lc
operator|->
name|categories
argument_list|,
name|lc
operator|->
name|num_categories
operator|*
sizeof|sizeof
argument_list|(
name|log_channel_list
argument_list|)
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|lc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|log_context
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|log_add_channel
parameter_list|(
name|log_context
name|lc
parameter_list|,
name|int
name|category
parameter_list|,
name|log_channel
name|chan
parameter_list|)
block|{
name|log_channel_list
name|lcl
decl_stmt|;
if|if
condition|(
name|lc
operator|==
name|NULL
operator|||
name|category
operator|<
literal|0
operator|||
name|category
operator|>=
name|lc
operator|->
name|num_categories
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|lcl
operator|=
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|log_channel_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcl
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|lcl
operator|->
name|channel
operator|=
name|chan
expr_stmt|;
name|lcl
operator|->
name|next
operator|=
name|lc
operator|->
name|categories
index|[
name|category
index|]
expr_stmt|;
name|lc
operator|->
name|categories
index|[
name|category
index|]
operator|=
name|lcl
expr_stmt|;
name|chan
operator|->
name|references
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|log_remove_channel
parameter_list|(
name|log_context
name|lc
parameter_list|,
name|int
name|category
parameter_list|,
name|log_channel
name|chan
parameter_list|)
block|{
name|log_channel_list
name|lcl
decl_stmt|,
name|prev_lcl
decl_stmt|,
name|next_lcl
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lc
operator|==
name|NULL
operator|||
name|category
operator|<
literal|0
operator|||
name|category
operator|>=
name|lc
operator|->
name|num_categories
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|prev_lcl
operator|=
name|NULL
operator|,
name|lcl
operator|=
name|lc
operator|->
name|categories
index|[
name|category
index|]
init|;
name|lcl
operator|!=
name|NULL
condition|;
name|lcl
operator|=
name|next_lcl
control|)
block|{
name|next_lcl
operator|=
name|lcl
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|lcl
operator|->
name|channel
operator|==
name|chan
condition|)
block|{
name|log_free_channel
argument_list|(
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_lcl
operator|!=
name|NULL
condition|)
name|prev_lcl
operator|->
name|next
operator|=
name|next_lcl
expr_stmt|;
else|else
name|lc
operator|->
name|categories
index|[
name|category
index|]
operator|=
name|next_lcl
expr_stmt|;
name|memput
argument_list|(
name|lcl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|log_channel_list
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * We just set found instead of returning because 			 * the channel might be on the list more than once. 			 */
name|found
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|prev_lcl
operator|=
name|lcl
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|log_option
parameter_list|(
name|log_context
name|lc
parameter_list|,
name|int
name|option
parameter_list|,
name|int
name|value
parameter_list|)
block|{
if|if
condition|(
name|lc
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|LOG_OPTION_DEBUG
case|:
if|if
condition|(
name|value
condition|)
name|lc
operator|->
name|flags
operator||=
name|option
expr_stmt|;
else|else
name|lc
operator|->
name|flags
operator|&=
operator|~
name|option
expr_stmt|;
break|break;
case|case
name|LOG_OPTION_LEVEL
case|:
name|lc
operator|->
name|level
operator|=
name|value
expr_stmt|;
break|break;
default|default:
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|log_category_is_active
parameter_list|(
name|log_context
name|lc
parameter_list|,
name|int
name|category
parameter_list|)
block|{
if|if
condition|(
name|lc
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|category
operator|>=
literal|0
operator|&&
name|category
operator|<
name|lc
operator|->
name|num_categories
operator|&&
name|lc
operator|->
name|categories
index|[
name|category
index|]
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|log_channel
name|log_new_syslog_channel
parameter_list|(
name|unsigned
name|int
name|flags
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|facility
parameter_list|)
block|{
name|log_channel
name|chan
decl_stmt|;
name|chan
operator|=
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|log_channel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|chan
operator|->
name|type
operator|=
name|log_syslog
expr_stmt|;
name|chan
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|chan
operator|->
name|level
operator|=
name|level
expr_stmt|;
name|chan
operator|->
name|out
operator|.
name|facility
operator|=
name|facility
expr_stmt|;
name|chan
operator|->
name|references
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|chan
operator|)
return|;
block|}
end_function

begin_function
name|log_channel
name|log_new_file_channel
parameter_list|(
name|unsigned
name|int
name|flags
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|,
name|unsigned
name|int
name|versions
parameter_list|,
name|unsigned
name|long
name|max_size
parameter_list|)
block|{
name|log_channel
name|chan
decl_stmt|;
name|chan
operator|=
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|log_channel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|chan
operator|->
name|type
operator|=
name|log_file
expr_stmt|;
name|chan
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|chan
operator|->
name|level
operator|=
name|level
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/*  		 * Quantize length to a multiple of 256.  There's space for the 		 * NUL, since if len is a multiple of 256, the size chosen will 		 * be the next multiple. 		 */
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|name_size
operator|=
operator|(
operator|(
name|len
operator|/
literal|256
operator|)
operator|+
literal|1
operator|)
operator|*
literal|256
expr_stmt|;
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|name
operator|=
name|memget
argument_list|(
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|name_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
name|memput
argument_list|(
name|chan
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|log_channel
argument_list|)
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* This is safe. */
name|strcpy
argument_list|(
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|name_size
operator|=
literal|0
expr_stmt|;
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
block|}
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|stream
operator|=
name|stream
expr_stmt|;
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|versions
operator|=
name|versions
expr_stmt|;
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|max_size
operator|=
name|max_size
expr_stmt|;
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|owner
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|group
operator|=
name|getgid
argument_list|()
expr_stmt|;
name|chan
operator|->
name|references
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|chan
operator|)
return|;
block|}
end_function

begin_function
name|int
name|log_set_file_owner
parameter_list|(
name|log_channel
name|chan
parameter_list|,
name|uid_t
name|owner
parameter_list|,
name|gid_t
name|group
parameter_list|)
block|{
if|if
condition|(
name|chan
operator|->
name|type
operator|!=
name|log_file
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|owner
operator|=
name|owner
expr_stmt|;
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|group
operator|=
name|group
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|log_channel
name|log_new_null_channel
parameter_list|()
block|{
name|log_channel
name|chan
decl_stmt|;
name|chan
operator|=
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|log_channel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|chan
operator|->
name|type
operator|=
name|log_null
expr_stmt|;
name|chan
operator|->
name|flags
operator|=
name|LOG_CHANNEL_OFF
expr_stmt|;
name|chan
operator|->
name|level
operator|=
name|log_info
expr_stmt|;
name|chan
operator|->
name|references
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|chan
operator|)
return|;
block|}
end_function

begin_function
name|int
name|log_inc_references
parameter_list|(
name|log_channel
name|chan
parameter_list|)
block|{
if|if
condition|(
name|chan
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|chan
operator|->
name|references
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|log_dec_references
parameter_list|(
name|log_channel
name|chan
parameter_list|)
block|{
if|if
condition|(
name|chan
operator|==
name|NULL
operator|||
name|chan
operator|->
name|references
operator|<=
literal|0
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|chan
operator|->
name|references
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|log_channel_type
name|log_get_channel_type
parameter_list|(
name|log_channel
name|chan
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|chan
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|chan
operator|->
name|type
operator|)
return|;
block|}
end_function

begin_function
name|int
name|log_free_channel
parameter_list|(
name|log_channel
name|chan
parameter_list|)
block|{
if|if
condition|(
name|chan
operator|==
name|NULL
operator|||
name|chan
operator|->
name|references
operator|<=
literal|0
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|chan
operator|->
name|references
operator|--
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|references
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|chan
operator|->
name|type
operator|==
name|log_file
condition|)
block|{
if|if
condition|(
operator|(
name|chan
operator|->
name|flags
operator|&
name|LOG_CLOSE_STREAM
operator|)
operator|&&
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|stream
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|name
operator|!=
name|NULL
condition|)
name|memput
argument_list|(
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|name
argument_list|,
name|chan
operator|->
name|out
operator|.
name|file
operator|.
name|name_size
argument_list|)
expr_stmt|;
block|}
name|memput
argument_list|(
name|chan
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|log_channel
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

