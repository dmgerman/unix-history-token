begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995-1999 by Internet Software Consortium  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/* ev_files.c - implement asynch file IO for the eventlib  * vix 11sep95 [initial]  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LINT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|CODECENTER
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: ev_files.c,v 1.21 2001/11/01 05:35:46 marka Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|"fd_setsize.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<isc/eventlib.h>
end_include

begin_include
include|#
directive|include
file|"eventlib_p.h"
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_function_decl
specifier|static
name|evFile
modifier|*
name|FindFD
parameter_list|(
specifier|const
name|evContext_p
modifier|*
name|ctx
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|eventmask
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|evSelectFD
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|eventmask
parameter_list|,
name|evFileFunc
name|func
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|evFileID
modifier|*
name|opaqueID
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
init|=
name|opaqueCtx
operator|.
name|opaque
decl_stmt|;
name|evFile
modifier|*
name|id
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|1
argument_list|,
literal|"evSelectFD(ctx %#x, fd %d, mask 0x%x, func %#x, uap %#x)\n"
argument_list|,
name|ctx
argument_list|,
name|fd
argument_list|,
name|eventmask
argument_list|,
name|func
argument_list|,
name|uap
argument_list|)
expr_stmt|;
if|if
condition|(
name|eventmask
operator|==
literal|0
operator|||
operator|(
name|eventmask
operator|&
operator|~
name|EV_MASK_ALL
operator|)
operator|!=
literal|0
condition|)
name|EV_ERR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>
name|ctx
operator|->
name|highestFD
condition|)
name|EV_ERR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
name|OK
argument_list|(
name|mode
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* side effect: validate fd. */
comment|/* 	 * The first time we touch a file descriptor, we need to check to see 	 * if the application already had it in O_NONBLOCK mode and if so, all 	 * of our deselect()'s have to leave it in O_NONBLOCK.  If not, then 	 * all but our last deselect() has to leave it in O_NONBLOCK. 	 */
name|id
operator|=
name|FindFD
argument_list|(
name|ctx
argument_list|,
name|fd
argument_list|,
name|EV_MASK_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|mode
operator|&
name|PORT_NONBLOCK
condition|)
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|ctx
operator|->
name|nonblockBefore
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|USE_FIONBIO_IOCTL
name|int
name|on
init|=
literal|1
decl_stmt|;
name|OK
argument_list|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIONBIO
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|OK
argument_list|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|mode
operator||
name|PORT_NONBLOCK
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FD_CLR
argument_list|(
name|fd
argument_list|,
operator|&
name|ctx
operator|->
name|nonblockBefore
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If this descriptor is already in use, search for it again to see 	 * if any of the eventmask bits we want to set are already captured. 	 * We cannot usefully capture the same fd event more than once in the 	 * same context. 	 */
if|if
condition|(
name|id
operator|!=
name|NULL
operator|&&
name|FindFD
argument_list|(
name|ctx
argument_list|,
name|fd
argument_list|,
name|eventmask
argument_list|)
operator|!=
name|NULL
condition|)
name|EV_ERR
argument_list|(
name|ETOOMANYREFS
argument_list|)
expr_stmt|;
comment|/* Allocate and fill. */
name|OKNEW
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|id
operator|->
name|func
operator|=
name|func
expr_stmt|;
name|id
operator|->
name|uap
operator|=
name|uap
expr_stmt|;
name|id
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|id
operator|->
name|eventmask
operator|=
name|eventmask
expr_stmt|;
comment|/* 	 * Insert at head.  Order could be important for performance if we 	 * believe that evGetNext()'s accesses to the fd_sets will be more 	 * serial and therefore more cache-lucky if the list is ordered by 	 * ``fd.''  We do not believe these things, so we don't do it. 	 * 	 * The interesting sequence is where GetNext() has cached a select() 	 * result and the caller decides to evSelectFD() on some descriptor. 	 * Since GetNext() starts at the head, it can miss new entries we add 	 * at the head.  This is not a serious problem since the event being 	 * evSelectFD()'d for has to occur before evSelectFD() is called for 	 * the file event to be considered "missed" -- a real corner case. 	 * Maintaining a "tail" pointer for ctx->files would fix this, but I'm 	 * not sure it would be ``more correct.'' 	 */
if|if
condition|(
name|ctx
operator|->
name|files
operator|!=
name|NULL
condition|)
name|ctx
operator|->
name|files
operator|->
name|prev
operator|=
name|id
expr_stmt|;
name|id
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|id
operator|->
name|next
operator|=
name|ctx
operator|->
name|files
expr_stmt|;
name|ctx
operator|->
name|files
operator|=
name|id
expr_stmt|;
comment|/* Insert into fd table. */
if|if
condition|(
name|ctx
operator|->
name|fdTable
index|[
name|fd
index|]
operator|!=
name|NULL
condition|)
name|ctx
operator|->
name|fdTable
index|[
name|fd
index|]
operator|->
name|fdprev
operator|=
name|id
expr_stmt|;
name|id
operator|->
name|fdprev
operator|=
name|NULL
expr_stmt|;
name|id
operator|->
name|fdnext
operator|=
name|ctx
operator|->
name|fdTable
index|[
name|fd
index|]
expr_stmt|;
name|ctx
operator|->
name|fdTable
index|[
name|fd
index|]
operator|=
name|id
expr_stmt|;
comment|/* Turn on the appropriate bits in the {rd,wr,ex}Next fd_set's. */
if|if
condition|(
name|eventmask
operator|&
name|EV_READ
condition|)
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|ctx
operator|->
name|rdNext
argument_list|)
expr_stmt|;
if|if
condition|(
name|eventmask
operator|&
name|EV_WRITE
condition|)
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|ctx
operator|->
name|wrNext
argument_list|)
expr_stmt|;
if|if
condition|(
name|eventmask
operator|&
name|EV_EXCEPT
condition|)
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|ctx
operator|->
name|exNext
argument_list|)
expr_stmt|;
comment|/* Update fdMax. */
if|if
condition|(
name|fd
operator|>
name|ctx
operator|->
name|fdMax
condition|)
name|ctx
operator|->
name|fdMax
operator|=
name|fd
expr_stmt|;
comment|/* Remember the ID if the caller provided us a place for it. */
if|if
condition|(
name|opaqueID
condition|)
name|opaqueID
operator|->
name|opaque
operator|=
name|id
expr_stmt|;
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|5
argument_list|,
literal|"evSelectFD(fd %d, mask 0x%x): new masks: 0x%lx 0x%lx 0x%lx\n"
argument_list|,
name|fd
argument_list|,
name|eventmask
argument_list|,
operator|(
name|u_long
operator|)
name|ctx
operator|->
name|rdNext
operator|.
name|fds_bits
index|[
literal|0
index|]
argument_list|,
operator|(
name|u_long
operator|)
name|ctx
operator|->
name|wrNext
operator|.
name|fds_bits
index|[
literal|0
index|]
argument_list|,
operator|(
name|u_long
operator|)
name|ctx
operator|->
name|exNext
operator|.
name|fds_bits
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evDeselectFD
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|,
name|evFileID
name|opaqueID
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
init|=
name|opaqueCtx
operator|.
name|opaque
decl_stmt|;
name|evFile
modifier|*
name|del
init|=
name|opaqueID
operator|.
name|opaque
decl_stmt|;
name|evFile
modifier|*
name|cur
decl_stmt|;
name|int
name|mode
decl_stmt|,
name|eventmask
decl_stmt|;
if|if
condition|(
operator|!
name|del
condition|)
block|{
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|11
argument_list|,
literal|"evDeselectFD(NULL) ignored\n"
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|1
argument_list|,
literal|"evDeselectFD(fd %d, mask 0x%x)\n"
argument_list|,
name|del
operator|->
name|fd
argument_list|,
name|del
operator|->
name|eventmask
argument_list|)
expr_stmt|;
comment|/* Get the mode.  Unless the file has been closed, errors are bad. */
name|mode
operator|=
name|fcntl
argument_list|(
name|del
operator|->
name|fd
argument_list|,
name|F_GETFL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EBADF
condition|)
name|EV_ERR
argument_list|(
name|errno
argument_list|)
expr_stmt|;
comment|/* Remove from the list of files. */
if|if
condition|(
name|del
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|del
operator|->
name|prev
operator|->
name|next
operator|=
name|del
operator|->
name|next
expr_stmt|;
else|else
name|ctx
operator|->
name|files
operator|=
name|del
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|del
operator|->
name|next
operator|!=
name|NULL
condition|)
name|del
operator|->
name|next
operator|->
name|prev
operator|=
name|del
operator|->
name|prev
expr_stmt|;
comment|/* Remove from the fd table. */
if|if
condition|(
name|del
operator|->
name|fdprev
operator|!=
name|NULL
condition|)
name|del
operator|->
name|fdprev
operator|->
name|fdnext
operator|=
name|del
operator|->
name|fdnext
expr_stmt|;
else|else
name|ctx
operator|->
name|fdTable
index|[
name|del
operator|->
name|fd
index|]
operator|=
name|del
operator|->
name|fdnext
expr_stmt|;
if|if
condition|(
name|del
operator|->
name|fdnext
operator|!=
name|NULL
condition|)
name|del
operator|->
name|fdnext
operator|->
name|fdprev
operator|=
name|del
operator|->
name|fdprev
expr_stmt|;
comment|/* 	 * If the file descriptor does not appear in any other select() entry, 	 * and if !EV_WASNONBLOCK, and if we got no EBADF when we got the mode 	 * earlier, then: restore the fd to blocking status. 	 */
if|if
condition|(
operator|!
operator|(
name|cur
operator|=
name|FindFD
argument_list|(
name|ctx
argument_list|,
name|del
operator|->
name|fd
argument_list|,
name|EV_MASK_ALL
argument_list|)
operator|)
operator|&&
operator|!
name|FD_ISSET
argument_list|(
name|del
operator|->
name|fd
argument_list|,
operator|&
name|ctx
operator|->
name|nonblockBefore
argument_list|)
operator|&&
name|mode
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 		 * Note that we won't return an error status to the caller if 		 * this fcntl() fails since (a) we've already done the work 		 * and (b) the caller didn't ask us anything about O_NONBLOCK. 		 */
ifdef|#
directive|ifdef
name|USE_FIONBIO_IOCTL
name|int
name|off
init|=
literal|1
decl_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|del
operator|->
name|fd
argument_list|,
name|FIONBIO
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|off
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|del
operator|->
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|mode
operator|&
operator|~
name|PORT_NONBLOCK
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Now find all other uses of this descriptor and OR together an event 	 * mask so that we don't turn off {rd,wr,ex}Next bits that some other 	 * file event is using.  As an optimization, stop if the event mask 	 * fills. 	 */
name|eventmask
operator|=
literal|0
expr_stmt|;
for|for
control|(
operator|(
name|void
operator|)
name|NULL
init|;
name|cur
operator|!=
name|NULL
operator|&&
name|eventmask
operator|!=
name|EV_MASK_ALL
condition|;
name|cur
operator|=
name|cur
operator|->
name|next
control|)
if|if
condition|(
name|cur
operator|->
name|fd
operator|==
name|del
operator|->
name|fd
condition|)
name|eventmask
operator||=
name|cur
operator|->
name|eventmask
expr_stmt|;
comment|/* OK, now we know which bits we can clear out. */
if|if
condition|(
operator|!
operator|(
name|eventmask
operator|&
name|EV_READ
operator|)
condition|)
block|{
name|FD_CLR
argument_list|(
name|del
operator|->
name|fd
argument_list|,
operator|&
name|ctx
operator|->
name|rdNext
argument_list|)
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|del
operator|->
name|fd
argument_list|,
operator|&
name|ctx
operator|->
name|rdLast
argument_list|)
condition|)
block|{
name|FD_CLR
argument_list|(
name|del
operator|->
name|fd
argument_list|,
operator|&
name|ctx
operator|->
name|rdLast
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|fdCount
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|eventmask
operator|&
name|EV_WRITE
operator|)
condition|)
block|{
name|FD_CLR
argument_list|(
name|del
operator|->
name|fd
argument_list|,
operator|&
name|ctx
operator|->
name|wrNext
argument_list|)
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|del
operator|->
name|fd
argument_list|,
operator|&
name|ctx
operator|->
name|wrLast
argument_list|)
condition|)
block|{
name|FD_CLR
argument_list|(
name|del
operator|->
name|fd
argument_list|,
operator|&
name|ctx
operator|->
name|wrLast
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|fdCount
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|eventmask
operator|&
name|EV_EXCEPT
operator|)
condition|)
block|{
name|FD_CLR
argument_list|(
name|del
operator|->
name|fd
argument_list|,
operator|&
name|ctx
operator|->
name|exNext
argument_list|)
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|del
operator|->
name|fd
argument_list|,
operator|&
name|ctx
operator|->
name|exLast
argument_list|)
condition|)
block|{
name|FD_CLR
argument_list|(
name|del
operator|->
name|fd
argument_list|,
operator|&
name|ctx
operator|->
name|exLast
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|fdCount
operator|--
expr_stmt|;
block|}
block|}
comment|/* If this was the maxFD, find the new one. */
if|if
condition|(
name|del
operator|->
name|fd
operator|==
name|ctx
operator|->
name|fdMax
condition|)
block|{
name|ctx
operator|->
name|fdMax
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|cur
operator|=
name|ctx
operator|->
name|files
init|;
name|cur
condition|;
name|cur
operator|=
name|cur
operator|->
name|next
control|)
if|if
condition|(
name|cur
operator|->
name|fd
operator|>
name|ctx
operator|->
name|fdMax
condition|)
name|ctx
operator|->
name|fdMax
operator|=
name|cur
operator|->
name|fd
expr_stmt|;
block|}
comment|/* If this was the fdNext, cycle that to the next entry. */
if|if
condition|(
name|del
operator|==
name|ctx
operator|->
name|fdNext
condition|)
name|ctx
operator|->
name|fdNext
operator|=
name|del
operator|->
name|next
expr_stmt|;
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|5
argument_list|,
literal|"evDeselectFD(fd %d, mask 0x%x): new masks: 0x%lx 0x%lx 0x%lx\n"
argument_list|,
name|del
operator|->
name|fd
argument_list|,
name|eventmask
argument_list|,
operator|(
name|u_long
operator|)
name|ctx
operator|->
name|rdNext
operator|.
name|fds_bits
index|[
literal|0
index|]
argument_list|,
operator|(
name|u_long
operator|)
name|ctx
operator|->
name|wrNext
operator|.
name|fds_bits
index|[
literal|0
index|]
argument_list|,
operator|(
name|u_long
operator|)
name|ctx
operator|->
name|exNext
operator|.
name|fds_bits
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Couldn't free it before now since we were using fields out of it. */
name|FREE
argument_list|(
name|del
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|evFile
modifier|*
name|FindFD
parameter_list|(
specifier|const
name|evContext_p
modifier|*
name|ctx
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|eventmask
parameter_list|)
block|{
name|evFile
modifier|*
name|id
decl_stmt|;
for|for
control|(
name|id
operator|=
name|ctx
operator|->
name|fdTable
index|[
name|fd
index|]
init|;
name|id
operator|!=
name|NULL
condition|;
name|id
operator|=
name|id
operator|->
name|fdnext
control|)
if|if
condition|(
name|id
operator|->
name|fd
operator|==
name|fd
operator|&&
operator|(
name|id
operator|->
name|eventmask
operator|&
name|eventmask
operator|)
operator|!=
literal|0
condition|)
break|break;
return|return
operator|(
name|id
operator|)
return|;
block|}
end_function

end_unit

