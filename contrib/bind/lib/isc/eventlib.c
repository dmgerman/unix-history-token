begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995-1999 by Internet Software Consortium  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/* eventlib.c - implement glue for the eventlib  * vix 09sep95 [initial]  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LINT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|CODECENTER
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: eventlib.c,v 1.44 1999/10/13 17:11:20 vixie Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|"fd_setsize.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<isc/eventlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/assertions.h>
end_include

begin_include
include|#
directive|include
file|"eventlib_p.h"
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_comment
comment|/* Forward. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_PSELECT
end_ifdef

begin_function_decl
specifier|static
name|int
name|pselect
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|struct
name|timespec
modifier|*
parameter_list|,
specifier|const
name|sigset_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Public. */
end_comment

begin_function
name|int
name|evCreate
parameter_list|(
name|evContext
modifier|*
name|opaqueCtx
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
decl_stmt|;
comment|/* Make sure the memory heap is initialized. */
if|if
condition|(
name|meminit
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EEXIST
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|OKNEW
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
comment|/* Global. */
name|ctx
operator|->
name|cur
operator|=
name|NULL
expr_stmt|;
comment|/* Debugging. */
name|ctx
operator|->
name|debug
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|output
operator|=
name|NULL
expr_stmt|;
comment|/* Connections. */
name|ctx
operator|->
name|conns
operator|=
name|NULL
expr_stmt|;
name|INIT_LIST
argument_list|(
name|ctx
operator|->
name|accepts
argument_list|)
expr_stmt|;
comment|/* Files. */
name|ctx
operator|->
name|files
operator|=
name|NULL
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|ctx
operator|->
name|rdNext
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|ctx
operator|->
name|wrNext
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|ctx
operator|->
name|exNext
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|ctx
operator|->
name|nonblockBefore
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|fdMax
operator|=
operator|-
literal|1
expr_stmt|;
name|ctx
operator|->
name|fdNext
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|fdCount
operator|=
literal|0
expr_stmt|;
comment|/* Invalidate {rd,wr,ex}Last. */
name|ctx
operator|->
name|highestFD
operator|=
name|FD_SETSIZE
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|EVENTLIB_TIME_CHECKS
name|ctx
operator|->
name|lastFdCount
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
name|ctx
operator|->
name|fdTable
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ctx
operator|->
name|fdTable
argument_list|)
expr_stmt|;
comment|/* Streams. */
name|ctx
operator|->
name|streams
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|strDone
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|strLast
operator|=
name|NULL
expr_stmt|;
comment|/* Timers. */
name|ctx
operator|->
name|lastEventTime
operator|=
name|evNowTime
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|EVENTLIB_TIME_CHECKS
name|ctx
operator|->
name|lastSelectTime
operator|=
name|ctx
operator|->
name|lastEventTime
expr_stmt|;
endif|#
directive|endif
name|ctx
operator|->
name|timers
operator|=
name|evCreateTimers
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|timers
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Waits. */
name|ctx
operator|->
name|waitLists
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|waitDone
operator|.
name|first
operator|=
name|ctx
operator|->
name|waitDone
operator|.
name|last
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|waitDone
operator|.
name|prev
operator|=
name|ctx
operator|->
name|waitDone
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|opaqueCtx
operator|->
name|opaque
operator|=
name|ctx
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|evSetDebug
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|,
name|int
name|level
parameter_list|,
name|FILE
modifier|*
name|output
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
init|=
name|opaqueCtx
operator|.
name|opaque
decl_stmt|;
name|ctx
operator|->
name|debug
operator|=
name|level
expr_stmt|;
name|ctx
operator|->
name|output
operator|=
name|output
expr_stmt|;
block|}
end_function

begin_function
name|int
name|evDestroy
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
init|=
name|opaqueCtx
operator|.
name|opaque
decl_stmt|;
name|int
name|revs
init|=
literal|424242
decl_stmt|;
comment|/* Doug Adams. */
name|evWaitList
modifier|*
name|this_wl
decl_stmt|,
modifier|*
name|next_wl
decl_stmt|;
name|evWait
modifier|*
name|this_wait
decl_stmt|,
modifier|*
name|next_wait
decl_stmt|;
comment|/* Connections. */
while|while
condition|(
name|revs
operator|--
operator|>
literal|0
operator|&&
name|ctx
operator|->
name|conns
operator|!=
name|NULL
condition|)
block|{
name|evConnID
name|id
decl_stmt|;
name|id
operator|.
name|opaque
operator|=
name|ctx
operator|->
name|conns
expr_stmt|;
operator|(
name|void
operator|)
name|evCancelConn
argument_list|(
name|opaqueCtx
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|revs
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* Streams. */
while|while
condition|(
name|revs
operator|--
operator|>
literal|0
operator|&&
name|ctx
operator|->
name|streams
operator|!=
name|NULL
condition|)
block|{
name|evStreamID
name|id
decl_stmt|;
name|id
operator|.
name|opaque
operator|=
name|ctx
operator|->
name|streams
expr_stmt|;
operator|(
name|void
operator|)
name|evCancelRW
argument_list|(
name|opaqueCtx
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
comment|/* Files. */
while|while
condition|(
name|revs
operator|--
operator|>
literal|0
operator|&&
name|ctx
operator|->
name|files
operator|!=
name|NULL
condition|)
block|{
name|evFileID
name|id
decl_stmt|;
name|id
operator|.
name|opaque
operator|=
name|ctx
operator|->
name|files
expr_stmt|;
operator|(
name|void
operator|)
name|evDeselectFD
argument_list|(
name|opaqueCtx
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|revs
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* Timers. */
name|evDestroyTimers
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
comment|/* Waits. */
for|for
control|(
name|this_wl
operator|=
name|ctx
operator|->
name|waitLists
init|;
name|revs
operator|--
operator|>
literal|0
operator|&&
name|this_wl
operator|!=
name|NULL
condition|;
name|this_wl
operator|=
name|next_wl
control|)
block|{
name|next_wl
operator|=
name|this_wl
operator|->
name|next
expr_stmt|;
for|for
control|(
name|this_wait
operator|=
name|this_wl
operator|->
name|first
init|;
name|revs
operator|--
operator|>
literal|0
operator|&&
name|this_wait
operator|!=
name|NULL
condition|;
name|this_wait
operator|=
name|next_wait
control|)
block|{
name|next_wait
operator|=
name|this_wait
operator|->
name|next
expr_stmt|;
name|FREE
argument_list|(
name|this_wait
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|this_wl
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|this_wait
operator|=
name|ctx
operator|->
name|waitDone
operator|.
name|first
init|;
name|revs
operator|--
operator|>
literal|0
operator|&&
name|this_wait
operator|!=
name|NULL
condition|;
name|this_wait
operator|=
name|next_wait
control|)
block|{
name|next_wait
operator|=
name|this_wait
operator|->
name|next
expr_stmt|;
name|FREE
argument_list|(
name|this_wait
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evGetNext
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|,
name|evEvent
modifier|*
name|opaqueEv
parameter_list|,
name|int
name|options
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
init|=
name|opaqueCtx
operator|.
name|opaque
decl_stmt|;
name|struct
name|timespec
name|nextTime
decl_stmt|;
name|evTimer
modifier|*
name|nextTimer
decl_stmt|;
name|evEvent_p
modifier|*
name|new
decl_stmt|;
name|int
name|x
decl_stmt|,
name|pselect_errno
decl_stmt|,
name|timerPast
decl_stmt|;
ifdef|#
directive|ifdef
name|EVENTLIB_TIME_CHECKS
name|struct
name|timespec
name|interval
decl_stmt|;
endif|#
directive|endif
comment|/* Ensure that exactly one of EV_POLL or EV_WAIT was specified. */
name|x
operator|=
operator|(
operator|(
name|options
operator|&
name|EV_POLL
operator|)
operator|!=
literal|0
operator|)
operator|+
operator|(
operator|(
name|options
operator|&
name|EV_WAIT
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
literal|1
condition|)
name|ERR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
comment|/* Get the time of day.  We'll do this again after select() blocks. */
name|ctx
operator|->
name|lastEventTime
operator|=
name|evNowTime
argument_list|()
expr_stmt|;
name|again
label|:
comment|/* Finished accept()'s do not require a select(). */
if|if
condition|(
operator|!
name|EMPTY
argument_list|(
name|ctx
operator|->
name|accepts
argument_list|)
condition|)
block|{
name|OKNEW
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|type
operator|=
name|Accept
expr_stmt|;
name|new
operator|->
name|u
operator|.
name|accept
operator|.
name|this
operator|=
name|HEAD
argument_list|(
name|ctx
operator|->
name|accepts
argument_list|)
expr_stmt|;
name|UNLINK
argument_list|(
name|ctx
operator|->
name|accepts
argument_list|,
name|HEAD
argument_list|(
name|ctx
operator|->
name|accepts
argument_list|)
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|opaqueEv
operator|->
name|opaque
operator|=
name|new
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Stream IO does not require a select(). */
if|if
condition|(
name|ctx
operator|->
name|strDone
operator|!=
name|NULL
condition|)
block|{
name|OKNEW
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|type
operator|=
name|Stream
expr_stmt|;
name|new
operator|->
name|u
operator|.
name|stream
operator|.
name|this
operator|=
name|ctx
operator|->
name|strDone
expr_stmt|;
name|ctx
operator|->
name|strDone
operator|=
name|ctx
operator|->
name|strDone
operator|->
name|nextDone
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|strDone
operator|==
name|NULL
condition|)
name|ctx
operator|->
name|strLast
operator|=
name|NULL
expr_stmt|;
name|opaqueEv
operator|->
name|opaque
operator|=
name|new
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Waits do not require a select(). */
if|if
condition|(
name|ctx
operator|->
name|waitDone
operator|.
name|first
operator|!=
name|NULL
condition|)
block|{
name|OKNEW
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|type
operator|=
name|Wait
expr_stmt|;
name|new
operator|->
name|u
operator|.
name|wait
operator|.
name|this
operator|=
name|ctx
operator|->
name|waitDone
operator|.
name|first
expr_stmt|;
name|ctx
operator|->
name|waitDone
operator|.
name|first
operator|=
name|ctx
operator|->
name|waitDone
operator|.
name|first
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|waitDone
operator|.
name|first
operator|==
name|NULL
condition|)
name|ctx
operator|->
name|waitDone
operator|.
name|last
operator|=
name|NULL
expr_stmt|;
name|opaqueEv
operator|->
name|opaque
operator|=
name|new
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Get the status and content of the next timer. */
if|if
condition|(
operator|(
name|nextTimer
operator|=
name|heap_element
argument_list|(
name|ctx
operator|->
name|timers
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|nextTime
operator|=
name|nextTimer
operator|->
name|due
expr_stmt|;
name|timerPast
operator|=
operator|(
name|evCmpTime
argument_list|(
name|nextTime
argument_list|,
name|ctx
operator|->
name|lastEventTime
argument_list|)
operator|<=
literal|0
operator|)
expr_stmt|;
block|}
else|else
name|timerPast
operator|=
literal|0
expr_stmt|;
comment|/* Make gcc happy. */
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|9
argument_list|,
literal|"evGetNext: fdCount %d\n"
argument_list|,
name|ctx
operator|->
name|fdCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|fdCount
operator|==
literal|0
condition|)
block|{
specifier|static
specifier|const
name|struct
name|timespec
name|NoTime
init|=
block|{
literal|0
block|,
literal|0L
block|}
decl_stmt|;
enum|enum
block|{
name|JustPoll
block|,
name|Block
block|,
name|Timer
block|}
name|m
enum|;
name|struct
name|timespec
name|t
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
comment|/* Are there any events at all? */
if|if
condition|(
operator|(
name|options
operator|&
name|EV_WAIT
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|nextTimer
operator|&&
name|ctx
operator|->
name|fdMax
operator|==
operator|-
literal|1
condition|)
name|ERR
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
comment|/* Figure out what select()'s timeout parameter should be. */
if|if
condition|(
operator|(
name|options
operator|&
name|EV_POLL
operator|)
operator|!=
literal|0
condition|)
block|{
name|m
operator|=
name|JustPoll
expr_stmt|;
name|t
operator|=
name|NoTime
expr_stmt|;
name|tp
operator|=
operator|&
name|t
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nextTimer
operator|==
name|NULL
condition|)
block|{
name|m
operator|=
name|Block
expr_stmt|;
comment|/* ``t'' unused. */
name|tp
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|timerPast
condition|)
block|{
name|m
operator|=
name|JustPoll
expr_stmt|;
name|t
operator|=
name|NoTime
expr_stmt|;
name|tp
operator|=
operator|&
name|t
expr_stmt|;
block|}
else|else
block|{
name|m
operator|=
name|Timer
expr_stmt|;
comment|/* ``t'' filled in later. */
name|tp
operator|=
operator|&
name|t
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|EVENTLIB_TIME_CHECKS
if|if
condition|(
name|ctx
operator|->
name|debug
operator|>
literal|0
condition|)
block|{
name|interval
operator|=
name|evSubTime
argument_list|(
name|ctx
operator|->
name|lastEventTime
argument_list|,
name|ctx
operator|->
name|lastSelectTime
argument_list|)
expr_stmt|;
if|if
condition|(
name|interval
operator|.
name|tv_sec
operator|>
literal|0
condition|)
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|1
argument_list|,
literal|"time between pselect() %u.%09u count %d\n"
argument_list|,
name|interval
operator|.
name|tv_sec
argument_list|,
name|interval
operator|.
name|tv_nsec
argument_list|,
name|ctx
operator|->
name|lastFdCount
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
do|do
block|{
comment|/* XXX need to copy only the bits we are using. */
name|ctx
operator|->
name|rdLast
operator|=
name|ctx
operator|->
name|rdNext
expr_stmt|;
name|ctx
operator|->
name|wrLast
operator|=
name|ctx
operator|->
name|wrNext
expr_stmt|;
name|ctx
operator|->
name|exLast
operator|=
name|ctx
operator|->
name|exNext
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|Timer
condition|)
block|{
name|INSIST
argument_list|(
name|tp
operator|==
operator|&
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|evSubTime
argument_list|(
name|nextTime
argument_list|,
name|ctx
operator|->
name|lastEventTime
argument_list|)
expr_stmt|;
block|}
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|4
argument_list|,
literal|"pselect(%d, 0x%lx, 0x%lx, 0x%lx, %d.%09ld)\n"
argument_list|,
name|ctx
operator|->
name|fdMax
operator|+
literal|1
argument_list|,
operator|(
name|u_long
operator|)
name|ctx
operator|->
name|rdLast
operator|.
name|fds_bits
index|[
literal|0
index|]
argument_list|,
operator|(
name|u_long
operator|)
name|ctx
operator|->
name|wrLast
operator|.
name|fds_bits
index|[
literal|0
index|]
argument_list|,
operator|(
name|u_long
operator|)
name|ctx
operator|->
name|exLast
operator|.
name|fds_bits
index|[
literal|0
index|]
argument_list|,
name|tp
condition|?
name|tp
operator|->
name|tv_sec
else|:
operator|-
literal|1
argument_list|,
name|tp
condition|?
name|tp
operator|->
name|tv_nsec
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX should predict system's earliness and adjust. */
name|x
operator|=
name|pselect
argument_list|(
name|ctx
operator|->
name|fdMax
operator|+
literal|1
argument_list|,
operator|&
name|ctx
operator|->
name|rdLast
argument_list|,
operator|&
name|ctx
operator|->
name|wrLast
argument_list|,
operator|&
name|ctx
operator|->
name|exLast
argument_list|,
name|tp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pselect_errno
operator|=
name|errno
expr_stmt|;
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|4
argument_list|,
literal|"select() returns %d (err: %s)\n"
argument_list|,
name|x
argument_list|,
operator|(
name|x
operator|==
operator|-
literal|1
operator|)
condition|?
name|strerror
argument_list|(
name|errno
argument_list|)
else|:
literal|"none"
argument_list|)
expr_stmt|;
comment|/* Anything but a poll can change the time. */
if|if
condition|(
name|m
operator|!=
name|JustPoll
condition|)
name|ctx
operator|->
name|lastEventTime
operator|=
name|evNowTime
argument_list|()
expr_stmt|;
comment|/* Select() likes to finish about 10ms early. */
block|}
do|while
condition|(
name|x
operator|==
literal|0
operator|&&
name|m
operator|==
name|Timer
operator|&&
name|evCmpTime
argument_list|(
name|ctx
operator|->
name|lastEventTime
argument_list|,
name|nextTime
argument_list|)
operator|<
literal|0
condition|)
do|;
ifdef|#
directive|ifdef
name|EVENTLIB_TIME_CHECKS
name|ctx
operator|->
name|lastSelectTime
operator|=
name|ctx
operator|->
name|lastEventTime
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|pselect_errno
operator|==
name|EINTR
condition|)
block|{
if|if
condition|(
operator|(
name|options
operator|&
name|EV_NULL
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|again
goto|;
name|OKNEW
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|type
operator|=
name|Null
expr_stmt|;
comment|/* No data. */
name|opaqueEv
operator|->
name|opaque
operator|=
name|new
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|pselect_errno
operator|==
name|EBADF
condition|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<=
name|ctx
operator|->
name|fdMax
condition|;
name|x
operator|++
control|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|x
argument_list|,
operator|&
name|ctx
operator|->
name|rdNext
argument_list|)
operator|==
literal|0
operator|&&
name|FD_ISSET
argument_list|(
name|x
argument_list|,
operator|&
name|ctx
operator|->
name|wrNext
argument_list|)
operator|==
literal|0
operator|&&
name|FD_ISSET
argument_list|(
name|x
argument_list|,
operator|&
name|ctx
operator|->
name|exNext
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|fstat
argument_list|(
name|x
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EBADF
condition|)
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|1
argument_list|,
literal|"EBADF: %d\n"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
name|ERR
argument_list|(
name|pselect_errno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|==
literal|0
operator|&&
operator|(
name|nextTimer
operator|&&
operator|!
name|timerPast
operator|)
operator|&&
operator|(
name|options
operator|&
name|EV_POLL
operator|)
condition|)
name|ERR
argument_list|(
name|EWOULDBLOCK
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|fdCount
operator|=
name|x
expr_stmt|;
ifdef|#
directive|ifdef
name|EVENTLIB_TIME_CHECKS
name|ctx
operator|->
name|lastFdCount
operator|=
name|x
expr_stmt|;
endif|#
directive|endif
block|}
name|INSIST
argument_list|(
name|nextTimer
operator|||
name|ctx
operator|->
name|fdCount
argument_list|)
expr_stmt|;
comment|/* Timers go first since we'd like them to be accurate. */
if|if
condition|(
name|nextTimer
operator|&&
operator|!
name|timerPast
condition|)
block|{
comment|/* Has anything happened since we blocked? */
name|timerPast
operator|=
operator|(
name|evCmpTime
argument_list|(
name|nextTime
argument_list|,
name|ctx
operator|->
name|lastEventTime
argument_list|)
operator|<=
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|nextTimer
operator|&&
name|timerPast
condition|)
block|{
name|OKNEW
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|type
operator|=
name|Timer
expr_stmt|;
name|new
operator|->
name|u
operator|.
name|timer
operator|.
name|this
operator|=
name|nextTimer
expr_stmt|;
name|opaqueEv
operator|->
name|opaque
operator|=
name|new
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* No timers, so there should be a ready file descriptor. */
name|x
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ctx
operator|->
name|fdCount
operator|>
literal|0
condition|)
block|{
name|evFile
modifier|*
name|fid
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|eventmask
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|fdNext
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|++
name|x
operator|==
literal|2
condition|)
block|{
comment|/* 				 * Hitting the end twice means that the last 				 * select() found some FD's which have since 				 * been deselected. 				 * 				 * On some systems, the count returned by 				 * selects is the total number of bits in 				 * all masks that are set, and on others it's 				 * the number of fd's that have some bit set, 				 * and on others, it's just broken.  We  				 * always assume that it's the number of 				 * bits set in all masks, because that's what 				 * the man page says it should do, and 				 * the worst that can happen is we do an 				 * extra select(). 				 */
name|ctx
operator|->
name|fdCount
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|ctx
operator|->
name|fdNext
operator|=
name|ctx
operator|->
name|files
expr_stmt|;
block|}
name|fid
operator|=
name|ctx
operator|->
name|fdNext
expr_stmt|;
name|ctx
operator|->
name|fdNext
operator|=
name|fid
operator|->
name|next
expr_stmt|;
name|fd
operator|=
name|fid
operator|->
name|fd
expr_stmt|;
name|eventmask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|ctx
operator|->
name|rdLast
argument_list|)
condition|)
name|eventmask
operator||=
name|EV_READ
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|ctx
operator|->
name|wrLast
argument_list|)
condition|)
name|eventmask
operator||=
name|EV_WRITE
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|ctx
operator|->
name|exLast
argument_list|)
condition|)
name|eventmask
operator||=
name|EV_EXCEPT
expr_stmt|;
name|eventmask
operator|&=
name|fid
operator|->
name|eventmask
expr_stmt|;
if|if
condition|(
name|eventmask
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|eventmask
operator|&
name|EV_READ
operator|)
operator|!=
literal|0
condition|)
block|{
name|FD_CLR
argument_list|(
name|fd
argument_list|,
operator|&
name|ctx
operator|->
name|rdLast
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|fdCount
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|eventmask
operator|&
name|EV_WRITE
operator|)
operator|!=
literal|0
condition|)
block|{
name|FD_CLR
argument_list|(
name|fd
argument_list|,
operator|&
name|ctx
operator|->
name|wrLast
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|fdCount
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|eventmask
operator|&
name|EV_EXCEPT
operator|)
operator|!=
literal|0
condition|)
block|{
name|FD_CLR
argument_list|(
name|fd
argument_list|,
operator|&
name|ctx
operator|->
name|exLast
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|fdCount
operator|--
expr_stmt|;
block|}
name|OKNEW
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|type
operator|=
name|File
expr_stmt|;
name|new
operator|->
name|u
operator|.
name|file
operator|.
name|this
operator|=
name|fid
expr_stmt|;
name|new
operator|->
name|u
operator|.
name|file
operator|.
name|eventmask
operator|=
name|eventmask
expr_stmt|;
name|opaqueEv
operator|->
name|opaque
operator|=
name|new
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|ctx
operator|->
name|fdCount
operator|<
literal|0
condition|)
block|{
comment|/* 		 * select()'s count is off on a number of systems, and 		 * can result in fdCount< 0. 		 */
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|4
argument_list|,
literal|"fdCount< 0 (%d)\n"
argument_list|,
name|ctx
operator|->
name|fdCount
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|fdCount
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We get here if the caller deselect()'s an FD. Gag me with a goto. */
goto|goto
name|again
goto|;
block|}
end_function

begin_function
name|int
name|evDispatch
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|,
name|evEvent
name|opaqueEv
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
init|=
name|opaqueCtx
operator|.
name|opaque
decl_stmt|;
name|evEvent_p
modifier|*
name|ev
init|=
name|opaqueEv
operator|.
name|opaque
decl_stmt|;
ifdef|#
directive|ifdef
name|EVENTLIB_TIME_CHECKS
name|void
modifier|*
name|func
decl_stmt|;
name|struct
name|timespec
name|start_time
decl_stmt|;
name|struct
name|timespec
name|interval
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EVENTLIB_TIME_CHECKS
if|if
condition|(
name|ctx
operator|->
name|debug
operator|>
literal|0
condition|)
name|start_time
operator|=
name|evNowTime
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|ctx
operator|->
name|cur
operator|=
name|ev
expr_stmt|;
switch|switch
condition|(
name|ev
operator|->
name|type
condition|)
block|{
case|case
name|Accept
case|:
block|{
name|evAccept
modifier|*
name|this
init|=
name|ev
operator|->
name|u
operator|.
name|accept
operator|.
name|this
decl_stmt|;
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|5
argument_list|,
literal|"Dispatch.Accept: fd %d -> %d, func %#x, uap %#x\n"
argument_list|,
name|this
operator|->
name|conn
operator|->
name|fd
argument_list|,
name|this
operator|->
name|fd
argument_list|,
name|this
operator|->
name|conn
operator|->
name|func
argument_list|,
name|this
operator|->
name|conn
operator|->
name|uap
argument_list|)
expr_stmt|;
name|errno
operator|=
name|this
operator|->
name|ioErrno
expr_stmt|;
call|(
name|this
operator|->
name|conn
operator|->
name|func
call|)
argument_list|(
name|opaqueCtx
argument_list|,
name|this
operator|->
name|conn
operator|->
name|uap
argument_list|,
name|this
operator|->
name|fd
argument_list|,
operator|&
name|this
operator|->
name|la
argument_list|,
name|this
operator|->
name|lalen
argument_list|,
operator|&
name|this
operator|->
name|ra
argument_list|,
name|this
operator|->
name|ralen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EVENTLIB_TIME_CHECKS
name|func
operator|=
name|this
operator|->
name|conn
operator|->
name|func
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
name|File
case|:
block|{
name|evFile
modifier|*
name|this
init|=
name|ev
operator|->
name|u
operator|.
name|file
operator|.
name|this
decl_stmt|;
name|int
name|eventmask
init|=
name|ev
operator|->
name|u
operator|.
name|file
operator|.
name|eventmask
decl_stmt|;
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|5
argument_list|,
literal|"Dispatch.File: fd %d, mask 0x%x, func %#x, uap %#x\n"
argument_list|,
name|this
operator|->
name|fd
argument_list|,
name|this
operator|->
name|eventmask
argument_list|,
name|this
operator|->
name|func
argument_list|,
name|this
operator|->
name|uap
argument_list|)
expr_stmt|;
call|(
name|this
operator|->
name|func
call|)
argument_list|(
name|opaqueCtx
argument_list|,
name|this
operator|->
name|uap
argument_list|,
name|this
operator|->
name|fd
argument_list|,
name|eventmask
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EVENTLIB_TIME_CHECKS
name|func
operator|=
name|this
operator|->
name|func
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
name|Stream
case|:
block|{
name|evStream
modifier|*
name|this
init|=
name|ev
operator|->
name|u
operator|.
name|stream
operator|.
name|this
decl_stmt|;
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|5
argument_list|,
literal|"Dispatch.Stream: fd %d, func %#x, uap %#x\n"
argument_list|,
name|this
operator|->
name|fd
argument_list|,
name|this
operator|->
name|func
argument_list|,
name|this
operator|->
name|uap
argument_list|)
expr_stmt|;
name|errno
operator|=
name|this
operator|->
name|ioErrno
expr_stmt|;
call|(
name|this
operator|->
name|func
call|)
argument_list|(
name|opaqueCtx
argument_list|,
name|this
operator|->
name|uap
argument_list|,
name|this
operator|->
name|fd
argument_list|,
name|this
operator|->
name|ioDone
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EVENTLIB_TIME_CHECKS
name|func
operator|=
name|this
operator|->
name|func
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
name|Timer
case|:
block|{
name|evTimer
modifier|*
name|this
init|=
name|ev
operator|->
name|u
operator|.
name|timer
operator|.
name|this
decl_stmt|;
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|5
argument_list|,
literal|"Dispatch.Timer: func %#x, uap %#x\n"
argument_list|,
name|this
operator|->
name|func
argument_list|,
name|this
operator|->
name|uap
argument_list|)
expr_stmt|;
call|(
name|this
operator|->
name|func
call|)
argument_list|(
name|opaqueCtx
argument_list|,
name|this
operator|->
name|uap
argument_list|,
name|this
operator|->
name|due
argument_list|,
name|this
operator|->
name|inter
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EVENTLIB_TIME_CHECKS
name|func
operator|=
name|this
operator|->
name|func
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
name|Wait
case|:
block|{
name|evWait
modifier|*
name|this
init|=
name|ev
operator|->
name|u
operator|.
name|wait
operator|.
name|this
decl_stmt|;
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|5
argument_list|,
literal|"Dispatch.Wait: tag %#x, func %#x, uap %#x\n"
argument_list|,
name|this
operator|->
name|tag
argument_list|,
name|this
operator|->
name|func
argument_list|,
name|this
operator|->
name|uap
argument_list|)
expr_stmt|;
call|(
name|this
operator|->
name|func
call|)
argument_list|(
name|opaqueCtx
argument_list|,
name|this
operator|->
name|uap
argument_list|,
name|this
operator|->
name|tag
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EVENTLIB_TIME_CHECKS
name|func
operator|=
name|this
operator|->
name|func
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
name|Null
case|:
block|{
comment|/* No work. */
ifdef|#
directive|ifdef
name|EVENTLIB_TIME_CHECKS
name|func
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
default|default:
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|EVENTLIB_TIME_CHECKS
if|if
condition|(
name|ctx
operator|->
name|debug
operator|>
literal|0
condition|)
block|{
name|interval
operator|=
name|evSubTime
argument_list|(
name|evNowTime
argument_list|()
argument_list|,
name|start_time
argument_list|)
expr_stmt|;
comment|/*  		 * Complain if it took longer than 50 milliseconds. 		 * 		 * We call getuid() to make an easy to find mark in a kernel 		 * trace. 		 */
if|if
condition|(
name|interval
operator|.
name|tv_sec
operator|>
literal|0
operator|||
name|interval
operator|.
name|tv_nsec
operator|>
literal|50000000
condition|)
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|1
argument_list|,
literal|"dispatch interval %u.%09u uid %d type %d func %p\n"
argument_list|,
name|interval
operator|.
name|tv_sec
argument_list|,
name|interval
operator|.
name|tv_nsec
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|ev
operator|->
name|type
argument_list|,
name|func
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ctx
operator|->
name|cur
operator|=
name|NULL
expr_stmt|;
name|evDrop
argument_list|(
name|opaqueCtx
argument_list|,
name|opaqueEv
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|evDrop
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|,
name|evEvent
name|opaqueEv
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
init|=
name|opaqueCtx
operator|.
name|opaque
decl_stmt|;
name|evEvent_p
modifier|*
name|ev
init|=
name|opaqueEv
operator|.
name|opaque
decl_stmt|;
switch|switch
condition|(
name|ev
operator|->
name|type
condition|)
block|{
case|case
name|Accept
case|:
block|{
name|FREE
argument_list|(
name|ev
operator|->
name|u
operator|.
name|accept
operator|.
name|this
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|File
case|:
block|{
comment|/* No work. */
break|break;
block|}
case|case
name|Stream
case|:
block|{
name|evStreamID
name|id
decl_stmt|;
name|id
operator|.
name|opaque
operator|=
name|ev
operator|->
name|u
operator|.
name|stream
operator|.
name|this
expr_stmt|;
operator|(
name|void
operator|)
name|evCancelRW
argument_list|(
name|opaqueCtx
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|Timer
case|:
block|{
name|evTimer
modifier|*
name|this
init|=
name|ev
operator|->
name|u
operator|.
name|timer
operator|.
name|this
decl_stmt|;
name|evTimerID
name|opaque
decl_stmt|;
comment|/* Check to see whether the user func cleared the timer. */
if|if
condition|(
name|heap_element
argument_list|(
name|ctx
operator|->
name|timers
argument_list|,
name|this
operator|->
name|index
argument_list|)
operator|!=
name|this
condition|)
block|{
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|5
argument_list|,
literal|"Dispatch.Timer: timer rm'd?\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Timer is still there.  Delete it if it has expired, 		 * otherwise set it according to its next interval. 		 */
if|if
condition|(
name|this
operator|->
name|inter
operator|.
name|tv_sec
operator|==
literal|0
operator|&&
name|this
operator|->
name|inter
operator|.
name|tv_nsec
operator|==
literal|0L
condition|)
block|{
name|opaque
operator|.
name|opaque
operator|=
name|this
expr_stmt|;
operator|(
name|void
operator|)
name|evClearTimer
argument_list|(
name|opaqueCtx
argument_list|,
name|opaque
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|opaque
operator|.
name|opaque
operator|=
name|this
expr_stmt|;
operator|(
name|void
operator|)
name|evResetTimer
argument_list|(
name|opaqueCtx
argument_list|,
name|opaque
argument_list|,
name|this
operator|->
name|func
argument_list|,
name|this
operator|->
name|uap
argument_list|,
name|evAddTime
argument_list|(
name|ctx
operator|->
name|lastEventTime
argument_list|,
name|this
operator|->
name|inter
argument_list|)
argument_list|,
name|this
operator|->
name|inter
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|Wait
case|:
block|{
name|FREE
argument_list|(
name|ev
operator|->
name|u
operator|.
name|wait
operator|.
name|this
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|Null
case|:
block|{
comment|/* No work. */
break|break;
block|}
default|default:
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|FREE
argument_list|(
name|ev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|evMainLoop
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|)
block|{
name|evEvent
name|event
decl_stmt|;
name|int
name|x
decl_stmt|;
while|while
condition|(
operator|(
name|x
operator|=
name|evGetNext
argument_list|(
name|opaqueCtx
argument_list|,
operator|&
name|event
argument_list|,
name|EV_WAIT
argument_list|)
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
operator|(
name|x
operator|=
name|evDispatch
argument_list|(
name|opaqueCtx
argument_list|,
name|event
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evHighestFD
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
init|=
name|opaqueCtx
operator|.
name|opaque
decl_stmt|;
return|return
operator|(
name|ctx
operator|->
name|highestFD
operator|)
return|;
block|}
end_function

begin_function
name|void
name|evPrintf
parameter_list|(
specifier|const
name|evContext_p
modifier|*
name|ctx
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|output
operator|!=
name|NULL
operator|&&
name|ctx
operator|->
name|debug
operator|>=
name|level
condition|)
block|{
name|vfprintf
argument_list|(
name|ctx
operator|->
name|output
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|ctx
operator|->
name|output
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_PSELECT
end_ifdef

begin_comment
comment|/* XXX needs to move to the porting library. */
end_comment

begin_function
specifier|static
name|int
name|pselect
parameter_list|(
name|int
name|nfds
parameter_list|,
name|void
modifier|*
name|rfds
parameter_list|,
name|void
modifier|*
name|wfds
parameter_list|,
name|void
modifier|*
name|efds
parameter_list|,
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|,
specifier|const
name|sigset_t
modifier|*
name|sigmask
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|,
modifier|*
name|tvp
decl_stmt|;
name|sigset_t
name|sigs
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|tsp
condition|)
block|{
name|tvp
operator|=
operator|&
name|tv
expr_stmt|;
name|tv
operator|=
name|evTimeVal
argument_list|(
operator|*
name|tsp
argument_list|)
expr_stmt|;
block|}
else|else
name|tvp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sigmask
condition|)
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
name|sigmask
argument_list|,
operator|&
name|sigs
argument_list|)
expr_stmt|;
name|n
operator|=
name|select
argument_list|(
name|nfds
argument_list|,
name|rfds
argument_list|,
name|wfds
argument_list|,
name|efds
argument_list|,
name|tvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigmask
condition|)
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|sigs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsp
condition|)
operator|*
name|tsp
operator|=
name|evTimeSpec
argument_list|(
name|tv
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

