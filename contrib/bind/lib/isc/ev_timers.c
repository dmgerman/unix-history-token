begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995-1999 by Internet Software Consortium  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/* ev_timers.c - implement timers for the eventlib  * vix 09sep95 [initial]  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LINT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|CODECENTER
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: ev_timers.c,v 1.32 2001/11/01 05:35:47 marka Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Import. */
end_comment

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|"fd_setsize.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<isc/assertions.h>
end_include

begin_include
include|#
directive|include
file|<isc/eventlib.h>
end_include

begin_include
include|#
directive|include
file|"eventlib_p.h"
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_comment
comment|/* Constants. */
end_comment

begin_define
define|#
directive|define
name|MILLION
value|1000000
end_define

begin_define
define|#
directive|define
name|BILLION
value|1000000000
end_define

begin_comment
comment|/* Forward. */
end_comment

begin_function_decl
specifier|static
name|int
name|due_sooner
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_index
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_timer
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_timer
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|idle_timeout
parameter_list|(
name|evContext
parameter_list|,
name|void
modifier|*
parameter_list|,
name|struct
name|timespec
parameter_list|,
name|struct
name|timespec
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Private type. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|evTimerFunc
name|func
decl_stmt|;
name|void
modifier|*
name|uap
decl_stmt|;
name|struct
name|timespec
name|lastTouched
decl_stmt|;
name|struct
name|timespec
name|max_idle
decl_stmt|;
name|evTimer
modifier|*
name|timer
decl_stmt|;
block|}
name|idle_timer
typedef|;
end_typedef

begin_comment
comment|/* Public. */
end_comment

begin_function
name|struct
name|timespec
name|evConsTime
parameter_list|(
name|time_t
name|sec
parameter_list|,
name|long
name|nsec
parameter_list|)
block|{
name|struct
name|timespec
name|x
decl_stmt|;
name|x
operator|.
name|tv_sec
operator|=
name|sec
expr_stmt|;
name|x
operator|.
name|tv_nsec
operator|=
name|nsec
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|timespec
name|evAddTime
parameter_list|(
name|struct
name|timespec
name|addend1
parameter_list|,
name|struct
name|timespec
name|addend2
parameter_list|)
block|{
name|struct
name|timespec
name|x
decl_stmt|;
name|x
operator|.
name|tv_sec
operator|=
name|addend1
operator|.
name|tv_sec
operator|+
name|addend2
operator|.
name|tv_sec
expr_stmt|;
name|x
operator|.
name|tv_nsec
operator|=
name|addend1
operator|.
name|tv_nsec
operator|+
name|addend2
operator|.
name|tv_nsec
expr_stmt|;
if|if
condition|(
name|x
operator|.
name|tv_nsec
operator|>=
name|BILLION
condition|)
block|{
name|x
operator|.
name|tv_sec
operator|++
expr_stmt|;
name|x
operator|.
name|tv_nsec
operator|-=
name|BILLION
expr_stmt|;
block|}
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|timespec
name|evSubTime
parameter_list|(
name|struct
name|timespec
name|minuend
parameter_list|,
name|struct
name|timespec
name|subtrahend
parameter_list|)
block|{
name|struct
name|timespec
name|x
decl_stmt|;
name|x
operator|.
name|tv_sec
operator|=
name|minuend
operator|.
name|tv_sec
operator|-
name|subtrahend
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|minuend
operator|.
name|tv_nsec
operator|>=
name|subtrahend
operator|.
name|tv_nsec
condition|)
name|x
operator|.
name|tv_nsec
operator|=
name|minuend
operator|.
name|tv_nsec
operator|-
name|subtrahend
operator|.
name|tv_nsec
expr_stmt|;
else|else
block|{
name|x
operator|.
name|tv_nsec
operator|=
name|BILLION
operator|-
name|subtrahend
operator|.
name|tv_nsec
operator|+
name|minuend
operator|.
name|tv_nsec
expr_stmt|;
name|x
operator|.
name|tv_sec
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evCmpTime
parameter_list|(
name|struct
name|timespec
name|a
parameter_list|,
name|struct
name|timespec
name|b
parameter_list|)
block|{
name|long
name|x
init|=
name|a
operator|.
name|tv_sec
operator|-
name|b
operator|.
name|tv_sec
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0L
condition|)
name|x
operator|=
name|a
operator|.
name|tv_nsec
operator|-
name|b
operator|.
name|tv_nsec
expr_stmt|;
return|return
operator|(
name|x
operator|<
literal|0L
condition|?
operator|(
operator|-
literal|1
operator|)
else|:
name|x
operator|>
literal|0L
condition|?
operator|(
literal|1
operator|)
else|:
operator|(
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|timespec
name|evNowTime
parameter_list|()
block|{
name|struct
name|timeval
name|now
decl_stmt|;
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|now
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|evConsTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
return|;
return|return
operator|(
name|evTimeSpec
argument_list|(
name|now
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|timespec
name|evLastEventTime
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
init|=
name|opaqueCtx
operator|.
name|opaque
decl_stmt|;
return|return
operator|(
name|ctx
operator|->
name|lastEventTime
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|timespec
name|evTimeSpec
parameter_list|(
name|struct
name|timeval
name|tv
parameter_list|)
block|{
name|struct
name|timespec
name|ts
decl_stmt|;
name|ts
operator|.
name|tv_sec
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|ts
operator|.
name|tv_nsec
operator|=
name|tv
operator|.
name|tv_usec
operator|*
literal|1000
expr_stmt|;
return|return
operator|(
name|ts
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|timeval
name|evTimeVal
parameter_list|(
name|struct
name|timespec
name|ts
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
name|ts
operator|.
name|tv_sec
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
name|ts
operator|.
name|tv_nsec
operator|/
literal|1000
expr_stmt|;
return|return
operator|(
name|tv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evSetTimer
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|,
name|evTimerFunc
name|func
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|struct
name|timespec
name|due
parameter_list|,
name|struct
name|timespec
name|inter
parameter_list|,
name|evTimerID
modifier|*
name|opaqueID
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
init|=
name|opaqueCtx
operator|.
name|opaque
decl_stmt|;
name|evTimer
modifier|*
name|id
decl_stmt|;
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|1
argument_list|,
literal|"evSetTimer(ctx %#x, func %#x, uap %#x, due %d.%09ld, inter %d.%09ld)\n"
argument_list|,
name|ctx
argument_list|,
name|func
argument_list|,
name|uap
argument_list|,
name|due
operator|.
name|tv_sec
argument_list|,
name|due
operator|.
name|tv_nsec
argument_list|,
name|inter
operator|.
name|tv_sec
argument_list|,
name|inter
operator|.
name|tv_nsec
argument_list|)
expr_stmt|;
comment|/* due={0,0} is a magic cookie meaning "now." */
if|if
condition|(
name|due
operator|.
name|tv_sec
operator|==
literal|0
operator|&&
name|due
operator|.
name|tv_nsec
operator|==
literal|0L
condition|)
name|due
operator|=
name|evNowTime
argument_list|()
expr_stmt|;
comment|/* Allocate and fill. */
name|OKNEW
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|id
operator|->
name|func
operator|=
name|func
expr_stmt|;
name|id
operator|->
name|uap
operator|=
name|uap
expr_stmt|;
name|id
operator|->
name|due
operator|=
name|due
expr_stmt|;
name|id
operator|->
name|inter
operator|=
name|inter
expr_stmt|;
if|if
condition|(
name|heap_insert
argument_list|(
name|ctx
operator|->
name|timers
argument_list|,
name|id
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Remember the ID if the caller provided us a place for it. */
if|if
condition|(
name|opaqueID
condition|)
name|opaqueID
operator|->
name|opaque
operator|=
name|id
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|debug
operator|>
literal|7
condition|)
block|{
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|7
argument_list|,
literal|"timers after evSetTimer:\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|heap_for_each
argument_list|(
name|ctx
operator|->
name|timers
argument_list|,
name|print_timer
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ctx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evClearTimer
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|,
name|evTimerID
name|id
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
init|=
name|opaqueCtx
operator|.
name|opaque
decl_stmt|;
name|evTimer
modifier|*
name|del
init|=
name|id
operator|.
name|opaque
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|cur
operator|!=
name|NULL
operator|&&
name|ctx
operator|->
name|cur
operator|->
name|type
operator|==
name|Timer
operator|&&
name|ctx
operator|->
name|cur
operator|->
name|u
operator|.
name|timer
operator|.
name|this
operator|==
name|del
condition|)
block|{
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|8
argument_list|,
literal|"deferring delete of timer (executing)\n"
argument_list|)
expr_stmt|;
comment|/* 		 * Setting the interval to zero ensures that evDrop() will 		 * clean up the timer. 		 */
name|del
operator|->
name|inter
operator|=
name|evConsTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|heap_element
argument_list|(
name|ctx
operator|->
name|timers
argument_list|,
name|del
operator|->
name|index
argument_list|)
operator|!=
name|del
condition|)
name|EV_ERR
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|heap_delete
argument_list|(
name|ctx
operator|->
name|timers
argument_list|,
name|del
operator|->
name|index
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|FREE
argument_list|(
name|del
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|debug
operator|>
literal|7
condition|)
block|{
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|7
argument_list|,
literal|"timers after evClearTimer:\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|heap_for_each
argument_list|(
name|ctx
operator|->
name|timers
argument_list|,
name|print_timer
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ctx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evResetTimer
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|,
name|evTimerID
name|id
parameter_list|,
name|evTimerFunc
name|func
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|struct
name|timespec
name|due
parameter_list|,
name|struct
name|timespec
name|inter
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
init|=
name|opaqueCtx
operator|.
name|opaque
decl_stmt|;
name|evTimer
modifier|*
name|timer
init|=
name|id
operator|.
name|opaque
decl_stmt|;
name|struct
name|timespec
name|old_due
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|heap_element
argument_list|(
name|ctx
operator|->
name|timers
argument_list|,
name|timer
operator|->
name|index
argument_list|)
operator|!=
name|timer
condition|)
name|EV_ERR
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
name|old_due
operator|=
name|timer
operator|->
name|due
expr_stmt|;
name|timer
operator|->
name|func
operator|=
name|func
expr_stmt|;
name|timer
operator|->
name|uap
operator|=
name|uap
expr_stmt|;
name|timer
operator|->
name|due
operator|=
name|due
expr_stmt|;
name|timer
operator|->
name|inter
operator|=
name|inter
expr_stmt|;
switch|switch
condition|(
name|evCmpTime
argument_list|(
name|due
argument_list|,
name|old_due
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|result
operator|=
name|heap_increased
argument_list|(
name|ctx
operator|->
name|timers
argument_list|,
name|timer
operator|->
name|index
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|result
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|result
operator|=
name|heap_decreased
argument_list|(
name|ctx
operator|->
name|timers
argument_list|,
name|timer
operator|->
name|index
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ctx
operator|->
name|debug
operator|>
literal|7
condition|)
block|{
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|7
argument_list|,
literal|"timers after evResetTimer:\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|heap_for_each
argument_list|(
name|ctx
operator|->
name|timers
argument_list|,
name|print_timer
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ctx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evSetIdleTimer
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|,
name|evTimerFunc
name|func
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|struct
name|timespec
name|max_idle
parameter_list|,
name|evTimerID
modifier|*
name|opaqueID
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
init|=
name|opaqueCtx
operator|.
name|opaque
decl_stmt|;
name|idle_timer
modifier|*
name|tt
decl_stmt|;
comment|/* Allocate and fill. */
name|OKNEW
argument_list|(
name|tt
argument_list|)
expr_stmt|;
name|tt
operator|->
name|func
operator|=
name|func
expr_stmt|;
name|tt
operator|->
name|uap
operator|=
name|uap
expr_stmt|;
name|tt
operator|->
name|lastTouched
operator|=
name|ctx
operator|->
name|lastEventTime
expr_stmt|;
name|tt
operator|->
name|max_idle
operator|=
name|max_idle
expr_stmt|;
if|if
condition|(
name|evSetTimer
argument_list|(
name|opaqueCtx
argument_list|,
name|idle_timeout
argument_list|,
name|tt
argument_list|,
name|evAddTime
argument_list|(
name|ctx
operator|->
name|lastEventTime
argument_list|,
name|max_idle
argument_list|)
argument_list|,
name|max_idle
argument_list|,
name|opaqueID
argument_list|)
operator|<
literal|0
condition|)
block|{
name|FREE
argument_list|(
name|tt
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|tt
operator|->
name|timer
operator|=
name|opaqueID
operator|->
name|opaque
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evClearIdleTimer
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|,
name|evTimerID
name|id
parameter_list|)
block|{
name|evTimer
modifier|*
name|del
init|=
name|id
operator|.
name|opaque
decl_stmt|;
name|idle_timer
modifier|*
name|tt
init|=
name|del
operator|->
name|uap
decl_stmt|;
name|FREE
argument_list|(
name|tt
argument_list|)
expr_stmt|;
return|return
operator|(
name|evClearTimer
argument_list|(
name|opaqueCtx
argument_list|,
name|id
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evResetIdleTimer
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|,
name|evTimerID
name|opaqueID
parameter_list|,
name|evTimerFunc
name|func
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|struct
name|timespec
name|max_idle
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
init|=
name|opaqueCtx
operator|.
name|opaque
decl_stmt|;
name|evTimer
modifier|*
name|timer
init|=
name|opaqueID
operator|.
name|opaque
decl_stmt|;
name|idle_timer
modifier|*
name|tt
init|=
name|timer
operator|->
name|uap
decl_stmt|;
name|tt
operator|->
name|func
operator|=
name|func
expr_stmt|;
name|tt
operator|->
name|uap
operator|=
name|uap
expr_stmt|;
name|tt
operator|->
name|lastTouched
operator|=
name|ctx
operator|->
name|lastEventTime
expr_stmt|;
name|tt
operator|->
name|max_idle
operator|=
name|max_idle
expr_stmt|;
return|return
operator|(
name|evResetTimer
argument_list|(
name|opaqueCtx
argument_list|,
name|opaqueID
argument_list|,
name|idle_timeout
argument_list|,
name|tt
argument_list|,
name|evAddTime
argument_list|(
name|ctx
operator|->
name|lastEventTime
argument_list|,
name|max_idle
argument_list|)
argument_list|,
name|max_idle
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evTouchIdleTimer
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|,
name|evTimerID
name|id
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
init|=
name|opaqueCtx
operator|.
name|opaque
decl_stmt|;
name|evTimer
modifier|*
name|t
init|=
name|id
operator|.
name|opaque
decl_stmt|;
name|idle_timer
modifier|*
name|tt
init|=
name|t
operator|->
name|uap
decl_stmt|;
name|tt
operator|->
name|lastTouched
operator|=
name|ctx
operator|->
name|lastEventTime
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Public to the rest of eventlib. */
end_comment

begin_function
name|heap_context
name|evCreateTimers
parameter_list|(
specifier|const
name|evContext_p
modifier|*
name|ctx
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|heap_new
argument_list|(
name|due_sooner
argument_list|,
name|set_index
argument_list|,
literal|2048
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|evDestroyTimers
parameter_list|(
specifier|const
name|evContext_p
modifier|*
name|ctx
parameter_list|)
block|{
operator|(
name|void
operator|)
name|heap_for_each
argument_list|(
name|ctx
operator|->
name|timers
argument_list|,
name|free_timer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|heap_free
argument_list|(
name|ctx
operator|->
name|timers
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Private. */
end_comment

begin_function
specifier|static
name|int
name|due_sooner
parameter_list|(
name|void
modifier|*
name|a
parameter_list|,
name|void
modifier|*
name|b
parameter_list|)
block|{
name|evTimer
modifier|*
name|a_timer
decl_stmt|,
modifier|*
name|b_timer
decl_stmt|;
name|a_timer
operator|=
name|a
expr_stmt|;
name|b_timer
operator|=
name|b
expr_stmt|;
return|return
operator|(
name|evCmpTime
argument_list|(
name|a_timer
operator|->
name|due
argument_list|,
name|b_timer
operator|->
name|due
argument_list|)
operator|<
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_index
parameter_list|(
name|void
modifier|*
name|what
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|evTimer
modifier|*
name|timer
decl_stmt|;
name|timer
operator|=
name|what
expr_stmt|;
name|timer
operator|->
name|index
operator|=
name|index
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_timer
parameter_list|(
name|void
modifier|*
name|what
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|)
block|{
name|evTimer
modifier|*
name|t
init|=
name|what
decl_stmt|;
name|UNUSED
argument_list|(
name|uap
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_timer
parameter_list|(
name|void
modifier|*
name|what
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|)
block|{
name|evTimer
modifier|*
name|cur
init|=
name|what
decl_stmt|;
name|evContext_p
modifier|*
name|ctx
init|=
name|uap
decl_stmt|;
name|cur
operator|=
name|what
expr_stmt|;
name|evPrintf
argument_list|(
name|ctx
argument_list|,
literal|7
argument_list|,
literal|"  func %p, uap %p, due %d.%09ld, inter %d.%09ld\n"
argument_list|,
name|cur
operator|->
name|func
argument_list|,
name|cur
operator|->
name|uap
argument_list|,
name|cur
operator|->
name|due
operator|.
name|tv_sec
argument_list|,
name|cur
operator|->
name|due
operator|.
name|tv_nsec
argument_list|,
name|cur
operator|->
name|inter
operator|.
name|tv_sec
argument_list|,
name|cur
operator|->
name|inter
operator|.
name|tv_nsec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|idle_timeout
parameter_list|(
name|evContext
name|opaqueCtx
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|struct
name|timespec
name|due
parameter_list|,
name|struct
name|timespec
name|inter
parameter_list|)
block|{
name|evContext_p
modifier|*
name|ctx
init|=
name|opaqueCtx
operator|.
name|opaque
decl_stmt|;
name|idle_timer
modifier|*
name|this
init|=
name|uap
decl_stmt|;
name|struct
name|timespec
name|idle
decl_stmt|;
name|UNUSED
argument_list|(
name|due
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|inter
argument_list|)
expr_stmt|;
name|idle
operator|=
name|evSubTime
argument_list|(
name|ctx
operator|->
name|lastEventTime
argument_list|,
name|this
operator|->
name|lastTouched
argument_list|)
expr_stmt|;
if|if
condition|(
name|evCmpTime
argument_list|(
name|idle
argument_list|,
name|this
operator|->
name|max_idle
argument_list|)
operator|>=
literal|0
condition|)
block|{
call|(
name|this
operator|->
name|func
call|)
argument_list|(
name|opaqueCtx
argument_list|,
name|this
operator|->
name|uap
argument_list|,
name|this
operator|->
name|timer
operator|->
name|due
argument_list|,
name|this
operator|->
name|max_idle
argument_list|)
expr_stmt|;
comment|/* 		 * Setting the interval to zero will cause the timer to 		 * be cleaned up in evDrop(). 		 */
name|this
operator|->
name|timer
operator|->
name|inter
operator|=
name|evConsTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* evDrop() will reschedule the timer. */
name|this
operator|->
name|timer
operator|->
name|inter
operator|=
name|evSubTime
argument_list|(
name|this
operator|->
name|max_idle
argument_list|,
name|idle
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

