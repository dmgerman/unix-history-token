begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1985, 1989  *    The Regents of the University of California.  All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * 	This product includes software developed by the University of  * 	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1993 by Digital Equipment Corporation.  *   * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Digital Equipment Corporation not be used in advertising or  * publicity pertaining to distribution of the document or software without  * specific, written prior permission.  *   * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT  * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1985,1989 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)main.c	5.42 (Berkeley) 3/3/91"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: main.c,v 8.7 1997/04/25 00:27:18 vixie Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  ******************************************************************************  *    *   main.c --  *    *	Main routine and some action routines for the name server  *	lookup program.  *  *	Andrew Cherenson  *	U.C. Berkeley Computer Science Div.  *	CS298-26, Fall 1985  *    ******************************************************************************  */
end_comment

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_include
include|#
directive|include
file|"res.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_comment
comment|/*  * Name of a top-level name server. Can be changed with   * the "set root" command.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ROOT_SERVER
end_ifndef

begin_define
define|#
directive|define
name|ROOT_SERVER
value|"a.root-servers.net."
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|rootServerName
index|[
name|NAME_LEN
index|]
init|=
name|ROOT_SERVER
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  Import the state information from the resolver library.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|__res_state
name|_res
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  Info about the most recently queried host.  */
end_comment

begin_decl_stmt
name|HostInfo
name|curHostInfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|curHostValid
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  Info about the default name server.  */
end_comment

begin_decl_stmt
name|HostInfo
modifier|*
name|defaultPtr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|defaultServer
index|[
name|NAME_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|in_addr
name|defaultAddr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  Initial name server query type is Address.  */
end_comment

begin_decl_stmt
name|int
name|queryType
init|=
name|T_A
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|queryClass
init|=
name|C_IN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Stuff for Interrupt (control-C) signal handler.  */
end_comment

begin_function_decl
specifier|extern
name|SIG_FN
name|IntrHandler
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|FILE
modifier|*
name|filePtr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|env
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Browser command for help and view.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|pager
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|CvtAddrToPtr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ReadRC
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/*  ******************************************************************************  *  *  main --  *  *	Initializes the resolver library and determines the address  *	of the initial name server. The yylex routine is used to  *	read and perform commands.  *  ******************************************************************************  */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|wantedHost
init|=
name|NULL
decl_stmt|;
name|Boolean
name|useLocalServer
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
comment|/*      *  Initialize the resolver library routines.      */
if|if
condition|(
name|res_init
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Can't initialize resolver.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*      *  Allocate space for the default server's host info and      *  find the server's address and name. If the resolver library      *  already has some addresses for a potential name server,      *  then use them. Otherwise, see if the current host has a server.      *  Command line arguments may override the choice of initial server.       */
name|defaultPtr
operator|=
operator|(
name|HostInfo
operator|*
operator|)
name|Calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|HostInfo
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Parse the arguments:      *  no args =  go into interactive mode, use default host as server      *	1 arg	=  use as host name to be looked up, default host will be server      *		   non-interactive mode      *  2 args	=  1st arg:       *		     if it is '-', then       *		        ignore but go into interactive mode      *		     else       *		         use as host name to be looked up,       *			 go into non-interactive mode      *		2nd arg: name or inet address of server      *      *	"Set" options are specified with a leading - and must come before      *	any arguments. For example, to find the well-known services for      *  a host, type "nslookup -query=wks host"      */
name|ReadRC
argument_list|()
expr_stmt|;
comment|/* look for options file */
operator|++
name|argv
expr_stmt|;
operator|--
name|argc
expr_stmt|;
comment|/* skip prog name */
while|while
condition|(
name|argc
operator|&&
operator|*
name|argv
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|)
block|{
operator|(
name|void
operator|)
name|SetOption
argument_list|(
operator|&
operator|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
operator|++
name|argv
expr_stmt|;
operator|--
name|argc
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
name|Usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|&&
operator|*
name|argv
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
name|wantedHost
operator|=
operator|*
name|argv
expr_stmt|;
comment|/* name of host to be looked up */
block|}
name|useLocalServer
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
name|struct
name|in_addr
name|addr
decl_stmt|;
comment|/* 	 * Use an explicit name server. If the hostname lookup fails, 	 * default to the server(s) in resolv.conf. 	 */
if|if
condition|(
name|inet_aton
argument_list|(
operator|*
operator|++
name|argv
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
block|{
name|_res
operator|.
name|nscount
operator|=
literal|1
expr_stmt|;
name|_res
operator|.
name|nsaddr
operator|.
name|sin_addr
operator|=
name|addr
expr_stmt|;
block|}
else|else
block|{
name|hp
operator|=
name|gethostbyname
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Can't find server address for '%s': "
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|herror
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXNS
operator|&&
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|_res
operator|.
name|nsaddr_list
index|[
name|i
index|]
operator|.
name|sin_addr
argument_list|,
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
block|}
name|_res
operator|.
name|nscount
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|_res
operator|.
name|nscount
operator|==
literal|0
operator|||
name|useLocalServer
condition|)
block|{
name|LocalServer
argument_list|(
name|defaultPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_res
operator|.
name|nscount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|_res
operator|.
name|nsaddr_list
index|[
name|i
index|]
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
block|{
name|LocalServer
argument_list|(
name|defaultPtr
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|result
operator|=
name|GetHostInfoByAddr
argument_list|(
operator|&
operator|(
name|_res
operator|.
name|nsaddr_list
index|[
name|i
index|]
operator|.
name|sin_addr
operator|)
argument_list|,
operator|&
operator|(
name|_res
operator|.
name|nsaddr_list
index|[
name|i
index|]
operator|.
name|sin_addr
operator|)
argument_list|,
name|defaultPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SUCCESS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Can't find server name for address %s: %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|_res
operator|.
name|nsaddr_list
index|[
name|i
index|]
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|DecodeError
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|defaultAddr
operator|=
name|_res
operator|.
name|nsaddr_list
index|[
name|i
index|]
operator|.
name|sin_addr
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 	 *  If we have exhausted the list, tell the user about the 	 *  command line argument to specify an address. 	 */
if|if
condition|(
name|i
operator|==
name|_res
operator|.
name|nscount
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Default servers are not available\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|strcpy
argument_list|(
name|defaultServer
argument_list|,
name|defaultPtr
operator|->
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
ifdef|#
directive|ifdef
name|DEBUG2
name|_res
operator|.
name|options
operator||=
name|RES_DEBUG2
expr_stmt|;
endif|#
directive|endif
name|_res
operator|.
name|options
operator||=
name|RES_DEBUG
expr_stmt|;
name|_res
operator|.
name|retry
operator|=
literal|2
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/*      * If we're in non-interactive mode, look up the wanted host and quit.      * Otherwise, print the initial server's name and continue with      * the initialization.      */
if|if
condition|(
name|wantedHost
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|LookupHost
argument_list|(
name|wantedHost
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PrintHostInfo
argument_list|(
name|stdout
argument_list|,
literal|"Default Server:"
argument_list|,
name|defaultPtr
argument_list|)
expr_stmt|;
name|pager
operator|=
name|getenv
argument_list|(
literal|"PAGER"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pager
operator|==
name|NULL
condition|)
block|{
name|pager
operator|=
name|_PATH_PAGERCMD
expr_stmt|;
block|}
comment|/* 	 * Setup the environment to allow the interrupt handler to return here. 	 */
operator|(
name|void
operator|)
name|setjmp
argument_list|(
name|env
argument_list|)
expr_stmt|;
comment|/*  	 * Return here after a longjmp. 	 */
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|IntrHandler
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* 	 * Read and evaluate commands. The commands are described in commands.l 	 * Yylex returns 0 when ^D or 'exit' is typed.  	 */
name|printf
argument_list|(
literal|"> "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
while|while
condition|(
name|yylex
argument_list|()
condition|)
block|{
name|printf
argument_list|(
literal|"> "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|LocalServer
argument_list|(
argument|defaultPtr
argument_list|)
end_macro

begin_decl_stmt
name|HostInfo
modifier|*
name|defaultPtr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|hostName
index|[
name|NAME_LEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|gethostname
argument_list|(
name|hostName
argument_list|,
sizeof|sizeof
argument_list|(
name|hostName
argument_list|)
argument_list|)
expr_stmt|;
name|defaultAddr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|GetHostInfoByName
argument_list|(
operator|&
name|defaultAddr
argument_list|,
name|C_IN
argument_list|,
name|T_A
argument_list|,
literal|"0.0.0.0"
argument_list|,
name|defaultPtr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|defaultPtr
operator|->
name|name
argument_list|)
expr_stmt|;
name|defaultPtr
operator|->
name|name
operator|=
name|Calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|hostName
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|defaultPtr
operator|->
name|name
argument_list|,
name|hostName
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  ******************************************************************************  *  *  Usage --  *  *	Lists the proper methods to run the program and exits.  *  ******************************************************************************  */
end_comment

begin_macro
name|Usage
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"   nslookup [-opt ...]             # interactive mode using default server\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"   nslookup [-opt ...] - server    # interactive mode using 'server'\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"   nslookup [-opt ...] host        # just look up 'host' using default server\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"   nslookup [-opt ...] host server # just look up 'host' using 'server'\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  ******************************************************************************  *  * IsAddr --  *  *	Returns TRUE if the string looks like an Internet address.  *	A string with a trailing dot is not an address, even if it looks  *	like one.  *  ******************************************************************************  */
end_comment

begin_function
name|Boolean
name|IsAddr
parameter_list|(
name|host
parameter_list|,
name|addrPtr
parameter_list|)
name|char
modifier|*
name|host
decl_stmt|;
name|struct
name|in_addr
modifier|*
name|addrPtr
decl_stmt|;
comment|/* If return TRUE, contains IP address */
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|host
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* Make sure it has only digits and dots. */
for|for
control|(
name|cp
operator|=
name|host
init|;
operator|*
name|cp
condition|;
operator|++
name|cp
control|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|*
name|cp
operator|!=
literal|'.'
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* If it has a trailing dot, don't treat it as an address. */
if|if
condition|(
operator|*
operator|--
name|cp
operator|!=
literal|'.'
condition|)
block|{
return|return
name|inet_aton
argument_list|(
name|host
argument_list|,
name|addrPtr
argument_list|)
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  ******************************************************************************  *  *  SetDefaultServer --  *  *	Changes the default name server to the one specified by  *	the first argument. The command "server name" uses the current   *	default server to lookup the info for "name". The command  *	"lserver name" uses the original server to lookup "name".  *  *  Side effects:  *	This routine will cause a core dump if the allocation requests fail.  *  *  Results:  *	SUCCESS		The default server was changed successfully.  *	NONAUTH		The server was changed but addresses of  *			other servers who know about the requested server  *			were returned.  *	Errors		No info about the new server was found or  *			requests to the current server timed-out.  *  ******************************************************************************  */
end_comment

begin_function
name|int
name|SetDefaultServer
parameter_list|(
name|string
parameter_list|,
name|local
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|Boolean
name|local
decl_stmt|;
block|{
specifier|register
name|HostInfo
modifier|*
name|newDefPtr
decl_stmt|;
name|struct
name|in_addr
modifier|*
name|servAddrPtr
decl_stmt|;
name|struct
name|in_addr
name|addr
decl_stmt|;
name|char
name|newServer
index|[
name|NAME_LEN
index|]
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*      *  Parse the command line. It maybe of the form "server name",      *  "lserver name" or just "name".      */
if|if
condition|(
name|local
condition|)
block|{
name|i
operator|=
name|sscanf
argument_list|(
name|string
argument_list|,
literal|" lserver %s"
argument_list|,
name|newServer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|sscanf
argument_list|(
name|string
argument_list|,
literal|" server %s"
argument_list|,
name|newServer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
literal|1
condition|)
block|{
name|i
operator|=
name|sscanf
argument_list|(
name|string
argument_list|,
literal|" %s"
argument_list|,
name|newServer
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"SetDefaultServer: invalid name: %s\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
block|}
comment|/*      * Allocate space for a HostInfo variable for the new server. Don't      * overwrite the old HostInfo struct because info about the new server      * might not be found and we need to have valid default server info.      */
name|newDefPtr
operator|=
operator|(
name|HostInfo
operator|*
operator|)
name|Calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|HostInfo
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      *	A 'local' lookup uses the original server that the program was      *  initialized with.      *      *  Check to see if we have the address of the server or the      *  address of a server who knows about this domain.      *  XXX For now, just use the first address in the list.      */
if|if
condition|(
name|local
condition|)
block|{
name|servAddrPtr
operator|=
operator|&
name|defaultAddr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|defaultPtr
operator|->
name|addrList
operator|!=
name|NULL
condition|)
block|{
name|servAddrPtr
operator|=
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|defaultPtr
operator|->
name|addrList
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|servAddrPtr
operator|=
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|defaultPtr
operator|->
name|servers
index|[
literal|0
index|]
operator|->
name|addrList
index|[
literal|0
index|]
expr_stmt|;
block|}
name|result
operator|=
name|ERROR
expr_stmt|;
if|if
condition|(
name|IsAddr
argument_list|(
name|newServer
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
block|{
name|result
operator|=
name|GetHostInfoByAddr
argument_list|(
name|servAddrPtr
argument_list|,
operator|&
name|addr
argument_list|,
name|newDefPtr
argument_list|)
expr_stmt|;
comment|/* If we can't get the name, fall through... */
block|}
if|if
condition|(
name|result
operator|!=
name|SUCCESS
operator|&&
name|result
operator|!=
name|NONAUTH
condition|)
block|{
name|result
operator|=
name|GetHostInfoByName
argument_list|(
name|servAddrPtr
argument_list|,
name|C_IN
argument_list|,
name|T_A
argument_list|,
name|newServer
argument_list|,
name|newDefPtr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If we ask for an A record and get none back, but get an NS        record for the NS server, this is the NONAUTH case.        We must check whether we got an IP address for the NS        server or not.  */
if|if
condition|(
operator|(
name|result
operator|==
name|SUCCESS
operator|||
name|result
operator|==
name|NONAUTH
operator|)
operator|&&
operator|(
operator|(
name|newDefPtr
operator|->
name|addrList
operator|&&
name|newDefPtr
operator|->
name|addrList
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|newDefPtr
operator|->
name|servers
operator|&&
name|newDefPtr
operator|->
name|servers
index|[
literal|0
index|]
operator|&&
name|newDefPtr
operator|->
name|servers
index|[
literal|0
index|]
operator|->
name|addrList
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* 	     *  Found info about the new server. Free the resources for 	     *  the old server. 	     */
name|FreeHostInfoPtr
argument_list|(
name|defaultPtr
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|defaultPtr
argument_list|)
expr_stmt|;
name|defaultPtr
operator|=
name|newDefPtr
expr_stmt|;
name|strcpy
argument_list|(
name|defaultServer
argument_list|,
name|defaultPtr
operator|->
name|name
argument_list|)
expr_stmt|;
name|PrintHostInfo
argument_list|(
name|stdout
argument_list|,
literal|"Default Server:"
argument_list|,
name|defaultPtr
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUCCESS
operator|)
return|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Can't find address for server %s: %s\n"
argument_list|,
name|newServer
argument_list|,
name|DecodeError
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newDefPtr
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  ******************************************************************************  *  * DoLoookup --  *  *	Common subroutine for LookupHost and LookupHostWithServer.  *  *  Results:  *	SUCCESS		- the lookup was successful.  *	Misc. Errors	- an error message is printed if the lookup failed.  *  ******************************************************************************  */
end_comment

begin_function
specifier|static
name|int
name|DoLookup
parameter_list|(
name|host
parameter_list|,
name|servPtr
parameter_list|,
name|serverName
parameter_list|)
name|char
modifier|*
name|host
decl_stmt|;
name|HostInfo
modifier|*
name|servPtr
decl_stmt|;
name|char
modifier|*
name|serverName
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|struct
name|in_addr
modifier|*
name|servAddrPtr
decl_stmt|;
name|struct
name|in_addr
name|addr
decl_stmt|;
comment|/* Skip escape character */
if|if
condition|(
name|host
index|[
literal|0
index|]
operator|==
literal|'\\'
condition|)
name|host
operator|++
expr_stmt|;
comment|/*      *  If the user gives us an address for an address query,       *  silently treat it as a PTR query. If the query type is already      *  PTR, then convert the address into the in-addr.arpa format.      *      *  Use the address of the server if it exists, otherwise use the      *	address of a server who knows about this domain.      *  XXX For now, just use the first address in the list.      */
if|if
condition|(
name|servPtr
operator|->
name|addrList
operator|!=
name|NULL
condition|)
block|{
name|servAddrPtr
operator|=
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|servPtr
operator|->
name|addrList
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|servAddrPtr
operator|=
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|servPtr
operator|->
name|servers
index|[
literal|0
index|]
operator|->
name|addrList
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/*       * RFC1123 says we "SHOULD check the string syntactically for a       * dotted-decimal number before looking it up [...]" (p. 13).      */
if|if
condition|(
name|queryType
operator|==
name|T_A
operator|&&
name|IsAddr
argument_list|(
name|host
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
block|{
name|result
operator|=
name|GetHostInfoByAddr
argument_list|(
name|servAddrPtr
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|curHostInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|queryType
operator|==
name|T_PTR
condition|)
block|{
name|CvtAddrToPtr
argument_list|(
name|host
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|GetHostInfoByName
argument_list|(
name|servAddrPtr
argument_list|,
name|queryClass
argument_list|,
name|queryType
argument_list|,
name|host
argument_list|,
operator|&
name|curHostInfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|SUCCESS
case|:
comment|/* 	     *  If the query was for an address, then the&curHostInfo 	     *  variable can be used by Finger. 	     *  There's no need to print anything for other query types 	     *  because the info has already been printed. 	     */
if|if
condition|(
name|queryType
operator|==
name|T_A
condition|)
block|{
name|curHostValid
operator|=
name|TRUE
expr_stmt|;
name|PrintHostInfo
argument_list|(
name|filePtr
argument_list|,
literal|"Name:"
argument_list|,
operator|&
name|curHostInfo
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * No Authoritative answer was available but we got names 	 * of servers who know about the host. 	 */
case|case
name|NONAUTH
case|:
name|PrintHostInfo
argument_list|(
name|filePtr
argument_list|,
literal|"Name:"
argument_list|,
operator|&
name|curHostInfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_INFO
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** No %s (%s) records available for %s\n"
argument_list|,
name|DecodeType
argument_list|(
name|queryType
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|queryType
argument_list|)
argument_list|,
name|host
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIME_OUT
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Request to %s timed-out\n"
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** %s can't find %s: %s\n"
argument_list|,
name|serverName
argument_list|,
name|host
argument_list|,
name|DecodeError
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  ******************************************************************************  *  *  LookupHost --  *  *	Asks the default name server for information about the  *	specified host or domain. The information is printed  *	if the lookup was successful.  *  *  Results:  *	ERROR		- the output file could not be opened.  *	+ results of DoLookup  *  ******************************************************************************  */
end_comment

begin_function
name|int
name|LookupHost
parameter_list|(
name|string
parameter_list|,
name|putToFile
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|Boolean
name|putToFile
decl_stmt|;
block|{
name|char
name|host
index|[
name|NAME_LEN
index|]
decl_stmt|;
name|char
name|file
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/*      *  Invalidate the current host information to prevent Finger       *  from using bogus info.      */
name|curHostValid
operator|=
name|FALSE
expr_stmt|;
comment|/*      *	 Parse the command string into the host and      *	 optional output file name.      *      */
name|sscanf
argument_list|(
name|string
argument_list|,
literal|" %s"
argument_list|,
name|host
argument_list|)
expr_stmt|;
comment|/* removes white space */
if|if
condition|(
operator|!
name|putToFile
condition|)
block|{
name|filePtr
operator|=
name|stdout
expr_stmt|;
block|}
else|else
block|{
name|filePtr
operator|=
name|OpenFile
argument_list|(
name|string
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|filePtr
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Can't open %s for writing\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
name|fprintf
argument_list|(
name|filePtr
argument_list|,
literal|"> %s\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
name|PrintHostInfo
argument_list|(
name|filePtr
argument_list|,
literal|"Server:"
argument_list|,
name|defaultPtr
argument_list|)
expr_stmt|;
name|result
operator|=
name|DoLookup
argument_list|(
name|host
argument_list|,
name|defaultPtr
argument_list|,
name|defaultServer
argument_list|)
expr_stmt|;
if|if
condition|(
name|putToFile
condition|)
block|{
name|fclose
argument_list|(
name|filePtr
argument_list|)
expr_stmt|;
name|filePtr
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  ******************************************************************************  *  *  LookupHostWithServer --  *  *	Asks the name server specified in the second argument for   *	information about the host or domain specified in the first  *	argument. The information is printed if the lookup was successful.  *  *	Address info about the requested name server is obtained  *	from the default name server. This routine will return an  *	error if the default server doesn't have info about the   *	requested server. Thus an error return status might not  *	mean the requested name server doesn't have info about the  *	requested host.  *  *	Comments from LookupHost apply here, too.  *  *  Results:  *	ERROR		- the output file could not be opened.  *	+ results of DoLookup  *  ******************************************************************************  */
end_comment

begin_function
name|int
name|LookupHostWithServer
parameter_list|(
name|string
parameter_list|,
name|putToFile
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|Boolean
name|putToFile
decl_stmt|;
block|{
name|char
name|file
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|host
index|[
name|NAME_LEN
index|]
decl_stmt|;
name|char
name|server
index|[
name|NAME_LEN
index|]
decl_stmt|;
name|int
name|result
decl_stmt|;
specifier|static
name|HostInfo
name|serverInfo
decl_stmt|;
name|curHostValid
operator|=
name|FALSE
expr_stmt|;
name|sscanf
argument_list|(
name|string
argument_list|,
literal|" %s %s"
argument_list|,
name|host
argument_list|,
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putToFile
condition|)
block|{
name|filePtr
operator|=
name|stdout
expr_stmt|;
block|}
else|else
block|{
name|filePtr
operator|=
name|OpenFile
argument_list|(
name|string
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|filePtr
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Can't open %s for writing\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
name|fprintf
argument_list|(
name|filePtr
argument_list|,
literal|"> %s\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|GetHostInfoByName
argument_list|(
name|defaultPtr
operator|->
name|addrList
condition|?
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|defaultPtr
operator|->
name|addrList
index|[
literal|0
index|]
else|:
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|defaultPtr
operator|->
name|servers
index|[
literal|0
index|]
operator|->
name|addrList
index|[
literal|0
index|]
argument_list|,
name|C_IN
argument_list|,
name|T_A
argument_list|,
name|server
argument_list|,
operator|&
name|serverInfo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SUCCESS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Can't find address for server %s: %s\n"
argument_list|,
name|server
argument_list|,
name|DecodeError
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PrintHostInfo
argument_list|(
name|filePtr
argument_list|,
literal|"Server:"
argument_list|,
operator|&
name|serverInfo
argument_list|)
expr_stmt|;
name|result
operator|=
name|DoLookup
argument_list|(
name|host
argument_list|,
operator|&
name|serverInfo
argument_list|,
name|server
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|putToFile
condition|)
block|{
name|fclose
argument_list|(
name|filePtr
argument_list|)
expr_stmt|;
name|filePtr
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  ******************************************************************************  *  *  SetOption --   *  *	This routine is used to change the state information  *	that affect the lookups. The command format is  *	   set keyword[=value]  *	Most keywords can be abbreviated. Parsing is very simplistic--  *	A value must not be separated from its keyword by white space.  *  *	Valid keywords:		Meaning:  *	all			lists current values of options.  *	ALL			lists current values of options, including  *				  hidden options.  *	[no]d2			turn on/off extra debugging mode.  *	[no]debug		turn on/off debugging mode.  *	[no]defname		use/don't use default domain name.  *	[no]search		use/don't use domain search list.  *	domain=NAME		set default domain name to NAME.  *	[no]ignore		ignore/don't ignore trunc. errors.  *	query=value		set default query type to value,  *				value is one of the query types in RFC883  *				without the leading T_.	(e.g., A, HINFO)  *	[no]recurse		use/don't use recursive lookup.  *	retry=#			set number of retries to #.  *	root=NAME		change root server to NAME.  *	time=#			set timeout length to #.  *	[no]vc			use/don't use virtual circuit.  *	port			TCP/UDP port to server.  *  * 	Deprecated:  *	[no]primary		use/don't use primary server.  *  *  Results:  *	SUCCESS		the command was parsed correctly.  *	ERROR		the command was not parsed correctly.  *  ******************************************************************************  */
end_comment

begin_function
name|int
name|SetOption
parameter_list|(
name|option
parameter_list|)
specifier|register
name|char
modifier|*
name|option
decl_stmt|;
block|{
name|char
name|type
index|[
name|NAME_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|tmp
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|option
argument_list|)
condition|)
operator|++
name|option
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"set "
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|option
operator|+=
literal|4
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|option
argument_list|)
condition|)
operator|++
name|option
expr_stmt|;
if|if
condition|(
operator|*
name|option
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Invalid set command\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"all"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ShowOptions
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"ALL"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ShowOptions
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"d2"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* d2 (more debug) */
name|_res
operator|.
name|options
operator||=
operator|(
name|RES_DEBUG
operator||
name|RES_DEBUG2
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nod2"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_DEBUG2
expr_stmt|;
name|printf
argument_list|(
literal|"d2 mode disabled; still in debug mode\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"def"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* defname */
name|_res
operator|.
name|options
operator||=
name|RES_DEFNAMES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nodef"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_DEFNAMES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"do"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* domain */
name|ptr
operator|=
name|strchr
argument_list|(
name|option
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|sscanf
argument_list|(
operator|++
name|ptr
argument_list|,
literal|"%s"
argument_list|,
name|_res
operator|.
name|defdname
argument_list|)
expr_stmt|;
name|res_re_init
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"deb"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* debug */
name|_res
operator|.
name|options
operator||=
name|RES_DEBUG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nodeb"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|options
operator|&=
operator|~
operator|(
name|RES_DEBUG
operator||
name|RES_DEBUG2
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"ig"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* ignore */
name|_res
operator|.
name|options
operator||=
name|RES_IGNTC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"noig"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_IGNTC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"po"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* port */
name|ptr
operator|=
name|strchr
argument_list|(
name|option
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|sscanf
argument_list|(
operator|++
name|ptr
argument_list|,
literal|"%hu"
argument_list|,
operator|&
name|nsport
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|deprecated
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"pri"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* primary */
name|_res
operator|.
name|options
operator||=
name|RES_PRIMARY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nopri"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_PRIMARY
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"q"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
operator|||
comment|/* querytype */
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"ty"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* type */
name|ptr
operator|=
name|strchr
argument_list|(
name|option
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|sscanf
argument_list|(
operator|++
name|ptr
argument_list|,
literal|"%s"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|queryType
operator|=
name|StringToType
argument_list|(
name|type
argument_list|,
name|queryType
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"cl"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* query class */
name|ptr
operator|=
name|strchr
argument_list|(
name|option
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|sscanf
argument_list|(
operator|++
name|ptr
argument_list|,
literal|"%s"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|queryClass
operator|=
name|StringToClass
argument_list|(
name|type
argument_list|,
name|queryClass
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"rec"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* recurse */
name|_res
operator|.
name|options
operator||=
name|RES_RECURSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"norec"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_RECURSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"ret"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* retry */
name|ptr
operator|=
name|strchr
argument_list|(
name|option
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|sscanf
argument_list|(
operator|++
name|ptr
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|>=
literal|0
condition|)
block|{
name|_res
operator|.
name|retry
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"ro"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* root */
name|ptr
operator|=
name|strchr
argument_list|(
name|option
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|sscanf
argument_list|(
operator|++
name|ptr
argument_list|,
literal|"%s"
argument_list|,
name|rootServerName
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"sea"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* search list */
name|_res
operator|.
name|options
operator||=
name|RES_DNSRCH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nosea"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_DNSRCH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"srchl"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* domain search list */
name|ptr
operator|=
name|strchr
argument_list|(
name|option
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|res_dnsrch
argument_list|(
operator|++
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"ti"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* timeout */
name|ptr
operator|=
name|strchr
argument_list|(
name|option
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|sscanf
argument_list|(
operator|++
name|ptr
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|>=
literal|0
condition|)
block|{
name|_res
operator|.
name|retrans
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"v"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* vc */
name|_res
operator|.
name|options
operator||=
name|RES_USEVC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nov"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_USEVC
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Invalid option: %s\n"
argument_list|,
name|option
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
block|}
return|return
operator|(
name|SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fake a reinitialization when the domain is changed.  */
end_comment

begin_macro
name|res_re_init
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* find components of local domain that might be searched */
name|pp
operator|=
name|_res
operator|.
name|dnsrch
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
name|_res
operator|.
name|defdname
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|_res
operator|.
name|defdname
operator|,
name|n
operator|=
literal|0
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'.'
condition|)
name|n
operator|++
expr_stmt|;
name|cp
operator|=
name|_res
operator|.
name|defdname
expr_stmt|;
for|for
control|(
init|;
name|n
operator|>=
name|LOCALDOMAINPARTS
operator|&&
name|pp
operator|<
name|_res
operator|.
name|dnsrch
operator|+
name|MAXDFLSRCH
condition|;
name|n
operator|--
control|)
block|{
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
operator|++
name|cp
expr_stmt|;
block|}
operator|*
name|pp
operator|=
literal|0
expr_stmt|;
name|_res
operator|.
name|options
operator||=
name|RES_INIT
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|SRCHLIST_SEP
value|'/'
end_define

begin_expr_stmt
name|res_dnsrch
argument_list|(
name|cp
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|int
name|n
decl_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|_res
operator|.
name|defdname
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|_res
operator|.
name|defdname
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|_res
operator|.
name|defdname
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/*      * Set search list to be blank-separated strings      * on rest of line.      */
name|cp
operator|=
name|_res
operator|.
name|defdname
expr_stmt|;
name|pp
operator|=
name|_res
operator|.
name|dnsrch
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
name|cp
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
operator|*
name|cp
operator|&&
name|pp
operator|<
name|_res
operator|.
name|dnsrch
operator|+
name|MAXDNSRCH
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
name|SRCHLIST_SEP
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
condition|)
block|{
operator|*
name|pp
operator|++
operator|=
name|cp
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|pp
index|[
operator|-
literal|1
index|]
argument_list|,
name|SRCHLIST_SEP
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  ******************************************************************************  *  *  ShowOptions --  *  *	Prints out the state information used by the resolver  *	library and other options set by the user.  *  ******************************************************************************  */
end_comment

begin_function
name|void
name|ShowOptions
parameter_list|()
block|{
specifier|register
name|char
modifier|*
modifier|*
name|cp
decl_stmt|;
name|PrintHostInfo
argument_list|(
name|stdout
argument_list|,
literal|"Default Server:"
argument_list|,
name|defaultPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|curHostValid
condition|)
block|{
name|PrintHostInfo
argument_list|(
name|stdout
argument_list|,
literal|"Host:"
argument_list|,
operator|&
name|curHostInfo
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Set options:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %sdebug  \t"
argument_list|,
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_DEBUG
operator|)
condition|?
literal|""
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %sdefname\t"
argument_list|,
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_DEFNAMES
operator|)
condition|?
literal|""
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %ssearch\t"
argument_list|,
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_DNSRCH
operator|)
condition|?
literal|""
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %srecurse\n"
argument_list|,
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_RECURSE
operator|)
condition|?
literal|""
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %sd2\t\t"
argument_list|,
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_DEBUG2
operator|)
condition|?
literal|""
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %svc\t\t"
argument_list|,
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_USEVC
operator|)
condition|?
literal|""
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %signoretc\t"
argument_list|,
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_IGNTC
operator|)
condition|?
literal|""
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  port=%u\n"
argument_list|,
name|nsport
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  querytype=%s\t"
argument_list|,
name|p_type
argument_list|(
name|queryType
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  class=%s\t"
argument_list|,
name|p_class
argument_list|(
name|queryClass
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  timeout=%d\t"
argument_list|,
name|_res
operator|.
name|retrans
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  retry=%d\n"
argument_list|,
name|_res
operator|.
name|retry
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  root=%s\n"
argument_list|,
name|rootServerName
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  domain=%s\n"
argument_list|,
name|_res
operator|.
name|defdname
argument_list|)
expr_stmt|;
name|cp
operator|=
name|_res
operator|.
name|dnsrch
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"  srchlist=%s"
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|++
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%c%s"
argument_list|,
name|SRCHLIST_SEP
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|SRCHLIST_SEP
end_undef

begin_escape
end_escape

begin_comment
comment|/*  ******************************************************************************  *  *  PrintHelp --  *  *	Displays the help file.  *  ******************************************************************************  */
end_comment

begin_function
name|void
name|PrintHelp
parameter_list|()
block|{
name|char
name|cmd
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"%s %s"
argument_list|,
name|pager
argument_list|,
name|_PATH_HELPFILE
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  ******************************************************************************  *  * CvtAddrToPtr --  *  *	Convert a dotted-decimal Internet address into the standard  *	PTR format (reversed address with .in-arpa. suffix).  *  *	Assumes the argument buffer is large enougth to hold the result.  *  ******************************************************************************  */
end_comment

begin_function
specifier|static
name|void
name|CvtAddrToPtr
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|ip
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|in_addr
name|addr
decl_stmt|;
if|if
condition|(
name|IsAddr
argument_list|(
name|name
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
block|{
name|p
operator|=
name|inet_ntoa
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|p
argument_list|,
literal|"%d.%d.%d.%d"
argument_list|,
operator|&
name|ip
index|[
literal|0
index|]
argument_list|,
operator|&
name|ip
index|[
literal|1
index|]
argument_list|,
operator|&
name|ip
index|[
literal|2
index|]
argument_list|,
operator|&
name|ip
index|[
literal|3
index|]
argument_list|)
operator|==
literal|4
condition|)
block|{
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%d.%d.%d.%d.in-addr.arpa."
argument_list|,
name|ip
index|[
literal|3
index|]
argument_list|,
name|ip
index|[
literal|2
index|]
argument_list|,
name|ip
index|[
literal|1
index|]
argument_list|,
name|ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  ******************************************************************************  *  * ReadRC --  *  *	Use the contents of ~/.nslookuprc as options.  *  ******************************************************************************  */
end_comment

begin_function
specifier|static
name|void
name|ReadRC
parameter_list|()
block|{
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|buf
index|[
name|PATH_MAX
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
name|strlen
argument_list|(
name|_PATH_NSLOOKUPRC
argument_list|)
operator|)
operator|<
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|_PATH_NSLOOKUPRC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|SetOption
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

