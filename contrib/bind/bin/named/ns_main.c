begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ns_main.c	4.55 (Berkeley) 7/1/91"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: ns_main.c,v 8.157 2002/04/13 23:26:16 marka Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Copyright (c) 1986, 1989, 1990  *    The Regents of the University of California.  All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * 	This product includes software developed by the University of  * 	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1993 by Digital Equipment Corporation.  *   * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Digital Equipment Corporation not be used in advertising or  * publicity pertaining to distribution of the document or software without  * specific, written prior permission.  *   * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT  * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1996-2000 by Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1986, 1989, 1990 The Regents of the University of California.\n"
literal|"portions Copyright (c) 1993 Digital Equipment Corporation\n"
literal|"portions Copyright (c) 1995-1999 Internet Software Consortium\n"
literal|"portions Copyright (c) 1999 Check Point Software Technologies\n"
literal|"All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Internet Name server (see RCF1035& others).  */
end_comment

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SVR4
end_ifdef

begin_comment
comment|/* XXX */
end_comment

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<irs.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<isc/eventlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/logging.h>
end_include

begin_include
include|#
directive|include
file|<isc/memcluster.h>
end_include

begin_include
include|#
directive|include
file|<isc/list.h>
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETRUSAGE
end_ifdef

begin_comment
comment|/* XXX */
end_comment

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAIN_PROGRAM
end_define

begin_include
include|#
directive|include
file|"named.h"
end_include

begin_undef
undef|#
directive|undef
name|MAIN_PROGRAM
end_undef

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|_savedg
block|{
name|struct
name|sockaddr_in
name|from
decl_stmt|;
name|int
name|dfd
decl_stmt|;
name|interface
modifier|*
name|ifp
decl_stmt|;
name|time_t
name|gen
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|u_int16_t
name|buflen
decl_stmt|;
block|}
name|savedg
typedef|;
end_typedef

begin_comment
comment|/* list of interfaces */
end_comment

begin_expr_stmt
specifier|static
name|LIST
argument_list|(
argument|struct _interface
argument_list|)
name|iflist
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|iflist_initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iflist_dont_rescan
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|drbufsize
init|=
literal|32
operator|*
literal|1024
decl_stmt|,
comment|/* UDP rcv buf size */
name|dsbufsize
init|=
literal|48
operator|*
literal|1024
decl_stmt|,
comment|/* UDP snd buf size */
name|sbufsize
init|=
literal|16
operator|*
literal|1024
decl_stmt|,
comment|/* TCP snd buf size */
ifdef|#
directive|ifdef
name|BROKEN_RECVFROM
name|nudptrans
init|=
literal|1
decl_stmt|,
else|#
directive|else
name|nudptrans
init|=
literal|20
decl_stmt|,
comment|/* #/udps per select */
endif|#
directive|endif
name|listenmax
init|=
literal|50
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int16_t
name|nsid_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int16_t
modifier|*
name|nsid_pool
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* optional query id pool */
end_comment

begin_decl_stmt
specifier|static
name|u_int16_t
modifier|*
name|nsid_vtable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* optional shuffle table */
end_comment

begin_decl_stmt
specifier|static
name|u_int32_t
name|nsid_hash_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int16_t
name|nsid_a1
decl_stmt|,
name|nsid_a2
decl_stmt|,
name|nsid_a3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int16_t
name|nsid_c1
decl_stmt|,
name|nsid_c2
decl_stmt|,
name|nsid_c3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int16_t
name|nsid_state2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nsid_algorithm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|needs
init|=
literal|0
decl_stmt|,
name|needs_exit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|handler
name|handlers
index|[
name|main_need_num
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|savedg_waitfunc
parameter_list|(
name|evContext
parameter_list|,
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|need_waitfunc
parameter_list|(
name|evContext
parameter_list|,
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|drain_rcvbuf
parameter_list|(
name|evContext
parameter_list|,
name|interface
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|drain_all_rcvbuf
parameter_list|(
name|evContext
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|qstream
modifier|*
name|sq_add
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|opensocket_d
argument_list|(
name|interface
operator|*
argument_list|)
decl_stmt|,
name|opensocket_s
argument_list|(
name|interface
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sq_query
argument_list|(
expr|struct
name|qstream
operator|*
argument_list|)
decl_stmt|,
name|dq_remove
argument_list|(
name|interface
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|sq_dowrite
parameter_list|(
name|struct
name|qstream
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|use_desired_debug
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stream_write
parameter_list|(
name|evContext
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|interface
modifier|*
name|if_find
parameter_list|(
name|struct
name|in_addr
parameter_list|,
name|u_int16_t
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|deallocate_everything
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|stream_accept
argument_list|(
name|evContext
argument_list|,
name|void
operator|*
argument_list|,
name|int
argument_list|,
specifier|const
name|void
operator|*
argument_list|,
name|int
argument_list|,
specifier|const
name|void
operator|*
argument_list|,
name|int
argument_list|)
decl_stmt|,
name|stream_getlen
argument_list|(
name|evContext
argument_list|,
name|void
operator|*
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
decl_stmt|,
name|stream_getmsg
argument_list|(
name|evContext
argument_list|,
name|void
operator|*
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
decl_stmt|,
name|datagram_read
argument_list|(
name|evContext
argument_list|,
name|void
operator|*
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
decl_stmt|,
name|dispatch_message
argument_list|(
name|u_char
operator|*
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
expr|struct
name|qstream
operator|*
argument_list|,
expr|struct
name|sockaddr_in
argument_list|,
name|int
argument_list|,
name|interface
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|stream_send
parameter_list|(
name|evContext
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|only_digits
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|init_needs
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|handle_needs
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|exit_handler
argument_list|(
name|void
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_CUSTOM
end_ifndef

begin_decl_stmt
specifier|static
name|void
name|custom_init
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|custom_shutdown
argument_list|(
name|void
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: named [-d #] [-q] [-r] [-v] [-f] [-p port] [[-b|-c] configfile]\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAN_CHANGE_ID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"             [-u (username|uid)] [-g (groupname|gid)]\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_CHROOT
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"             [-t directory]\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
name|bad_p_option
index|[]
init|=
literal|"-p remote/local obsolete; use 'listen-on' in config file to specify local"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|bad_directory
index|[]
init|=
literal|"chdir failed for directory '%s': %s"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|struct
name|group
modifier|*
name|gr
decl_stmt|;
ifdef|#
directive|ifdef
name|_AUX_SOURCE
name|set42sig
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|debugfile
operator|=
name|savestr
argument_list|(
name|_PATH_DEBUG
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|user_id
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|group_id
operator|=
name|getgid
argument_list|()
expr_stmt|;
name|ns_port
operator|=
name|htons
argument_list|(
name|NAMESERVER_PORT
argument_list|)
expr_stmt|;
name|desired_debug
operator|=
name|debug
expr_stmt|;
comment|/* BSD has a better random number generator but it's not clear 	 * that we need it here. 	 */
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|srand
argument_list|(
operator|(
operator|(
name|unsigned
operator|)
name|getpid
argument_list|()
operator|)
operator|+
operator|(
name|unsigned
operator|)
name|tt
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
literal|022
argument_list|)
expr_stmt|;
comment|/* Save argv[] before getopt() destroys it -- needed for execvp(). */
name|saved_argv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|argc
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|saved_argv
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|argc
condition|;
name|n
operator|++
control|)
block|{
name|saved_argv
index|[
name|n
index|]
operator|=
name|strdup
argument_list|(
name|argv
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|saved_argv
index|[
name|n
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|saved_argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* XXX we need to free() this for clean shutdowns. */
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"b:c:d:g:p:t:u:vw:qrf"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
if|if
condition|(
name|conffile
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|freestr
argument_list|(
name|conffile
argument_list|)
expr_stmt|;
name|conffile
operator|=
name|savestr
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|desired_debug
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|desired_debug
operator|<=
literal|0
condition|)
name|desired_debug
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* use nonstandard port number. 			 * usage: -p remote/local 			 * remote is the port number to which 			 * we send queries.  local is the port 			 * on which we listen for queries. 			 * local defaults to same as remote. 			 */
name|ns_port
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|atoi
argument_list|(
name|optarg
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|bad_p_option
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|bad_p_option
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
name|chdir
argument_list|(
name|optarg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
name|bad_directory
argument_list|,
name|optarg
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|bad_directory
argument_list|,
name|optarg
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|QRYLOG
case|case
literal|'q'
case|:
name|qrylog
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'r'
case|:
name|ns_setoption
argument_list|(
name|OPTION_NORECURSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|foreground
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|chroot_dir
operator|=
name|savestr
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s\n"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAN_CHANGE_ID
case|case
literal|'u'
case|:
name|user_name
operator|=
name|savestr
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|only_digits
argument_list|(
name|user_name
argument_list|)
condition|)
name|user_id
operator|=
name|atoi
argument_list|(
name|user_name
argument_list|)
expr_stmt|;
else|else
block|{
name|pw
operator|=
name|getpwnam
argument_list|(
name|user_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"user \"%s\" unknown\n"
argument_list|,
name|user_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|user_id
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
if|if
condition|(
name|group_name
operator|==
name|NULL
condition|)
block|{
name|char
name|name
index|[
literal|256
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%lu"
argument_list|,
operator|(
name|u_long
operator|)
name|pw
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
name|group_name
operator|=
name|savestr
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|group_id
operator|=
name|pw
operator|->
name|pw_gid
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|group_name
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|freestr
argument_list|(
name|group_name
argument_list|)
expr_stmt|;
name|group_name
operator|=
name|savestr
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|only_digits
argument_list|(
name|group_name
argument_list|)
condition|)
name|group_id
operator|=
name|atoi
argument_list|(
name|group_name
argument_list|)
expr_stmt|;
else|else
block|{
name|gr
operator|=
name|getgrnam
argument_list|(
name|group_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|gr
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"group \"%s\" unknown\n"
argument_list|,
name|group_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|group_id
operator|=
name|gr
operator|->
name|gr_gid
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* CAN_CHANGE_ID */
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
condition|)
block|{
if|if
condition|(
name|conffile
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|freestr
argument_list|(
name|conffile
argument_list|)
expr_stmt|;
name|conffile
operator|=
name|savestr
argument_list|(
operator|*
name|argv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|conffile
operator|==
name|NULL
condition|)
name|conffile
operator|=
name|savestr
argument_list|(
name|_PATH_CONF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure we don't inherit any open descriptors 	 * other than those that daemon() can deal with. 	 */
for|for
control|(
name|n
operator|=
name|sysconf
argument_list|(
name|_SC_OPEN_MAX
argument_list|)
operator|-
literal|1
init|;
name|n
operator|>=
literal|0
condition|;
name|n
operator|--
control|)
if|if
condition|(
name|n
operator|!=
name|STDIN_FILENO
operator|&&
name|n
operator|!=
name|STDOUT_FILENO
operator|&&
name|n
operator|!=
name|STDERR_FILENO
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* 	 * Chroot if desired. 	 */
if|if
condition|(
name|chroot_dir
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_CHROOT
if|if
condition|(
name|chroot
argument_list|(
name|chroot_dir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"chroot %s failed: %s\n"
argument_list|,
name|chroot_dir
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chdir
argument_list|(
literal|"/"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"chdir(\"/\") failed: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning: chroot() not available\n"
argument_list|)
expr_stmt|;
name|chroot_dir
operator|=
name|freestr
argument_list|(
name|chroot_dir
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Establish global event context. */
name|evCreate
argument_list|(
operator|&
name|ev
argument_list|)
expr_stmt|;
comment|/* Establish global resolver context. */
name|res_ninit
argument_list|(
operator|&
name|res
argument_list|)
expr_stmt|;
name|res
operator|.
name|options
operator|&=
operator|~
operator|(
name|RES_DEFNAMES
operator||
name|RES_DNSRCH
operator||
name|RES_RECURSE
operator|)
expr_stmt|;
comment|/* 	 * Set up logging. 	 */
name|n
operator|=
name|LOG_PID
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG_NOWAIT
name|n
operator||=
name|LOG_NOWAIT
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOG_NDELAY
name|n
operator||=
name|LOG_NDELAY
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|LOG_CONS
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_LOG_CONS
argument_list|)
name|n
operator||=
name|LOG_CONS
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYSLOG_42BSD
name|openlog
argument_list|(
literal|"named"
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|#
directive|else
name|openlog
argument_list|(
literal|"named"
argument_list|,
name|n
argument_list|,
name|ISC_FACILITY
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|init_logging
argument_list|()
expr_stmt|;
name|set_assertion_failure_callback
argument_list|(
name|ns_assertion_failed
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|use_desired_debug
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Perform system-dependent initialization */
name|custom_init
argument_list|()
expr_stmt|;
name|init_needs
argument_list|()
expr_stmt|;
name|init_signals
argument_list|()
expr_stmt|;
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"starting (%s).  %s"
argument_list|,
name|conffile
argument_list|,
name|Version
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize and load database. 	 */
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|buildservicelist
argument_list|()
expr_stmt|;
name|buildprotolist
argument_list|()
expr_stmt|;
name|confmtime
operator|=
name|ns_init
argument_list|(
name|conffile
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|boottime
argument_list|)
expr_stmt|;
name|resettime
operator|=
name|boottime
expr_stmt|;
name|nsid_init
argument_list|()
expr_stmt|;
comment|/* 	 * Fork and go into background now that 	 * we've done any slow initialization 	 * and are ready to answer queries. 	 */
if|if
condition|(
name|foreground
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|daemon
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"daemon: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|update_pid_file
argument_list|()
expr_stmt|;
block|}
comment|/* Check that udp checksums are on. */
name|ns_udp
argument_list|()
expr_stmt|;
comment|/* 	 * We waited until now to log this because we wanted logging to 	 * be set up the way the user prefers. 	 */
if|if
condition|(
name|chroot_dir
operator|!=
name|NULL
condition|)
name|ns_info
argument_list|(
name|ns_log_security
argument_list|,
literal|"chrooted to %s"
argument_list|,
name|chroot_dir
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAN_CHANGE_ID
comment|/* 	 * Set user and group if desired. 	 */
if|if
condition|(
name|group_name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|setgid
argument_list|(
name|group_id
argument_list|)
operator|<
literal|0
condition|)
name|ns_panic
argument_list|(
name|ns_log_security
argument_list|,
literal|1
argument_list|,
literal|"setgid(%s): %s"
argument_list|,
name|group_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ns_info
argument_list|(
name|ns_log_security
argument_list|,
literal|"group = %s"
argument_list|,
name|group_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|user_name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|getuid
argument_list|()
operator|==
literal|0
operator|&&
name|initgroups
argument_list|(
name|user_name
argument_list|,
name|group_id
argument_list|)
operator|<
literal|0
condition|)
name|ns_panic
argument_list|(
name|ns_log_security
argument_list|,
literal|1
argument_list|,
literal|"initgroups(%s, %d): %s"
argument_list|,
name|user_name
argument_list|,
operator|(
name|int
operator|)
name|group_id
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|endgrent
argument_list|()
expr_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
if|if
condition|(
name|setuid
argument_list|(
name|user_id
argument_list|)
operator|<
literal|0
condition|)
name|ns_panic
argument_list|(
name|ns_log_security
argument_list|,
literal|1
argument_list|,
literal|"setuid(%s): %s"
argument_list|,
name|user_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ns_info
argument_list|(
name|ns_log_security
argument_list|,
literal|"user = %s"
argument_list|,
name|user_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|user_id
operator|!=
literal|0
condition|)
name|iflist_dont_rescan
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CAN_CHANGE_ID */
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"Ready to answer queries."
argument_list|)
expr_stmt|;
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|prime_cache
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|needs_exit
condition|)
block|{
name|evEvent
name|event
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|15
argument_list|,
literal|"main loop"
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs
operator|!=
literal|0
condition|)
name|handle_needs
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|evGetNext
argument_list|(
name|ev
argument_list|,
operator|&
name|event
argument_list|,
name|EV_WAIT
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|INSIST_ERR
argument_list|(
name|evDispatch
argument_list|(
name|ev
argument_list|,
name|event
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|INSIST_ERR
argument_list|(
name|errno
operator|==
name|EINTR
argument_list|)
expr_stmt|;
block|}
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"named shutting down"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND_UPDATE
name|dynamic_about_to_exit
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|server_options
operator|&&
name|server_options
operator|->
name|pid_filename
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|server_options
operator|->
name|pid_filename
argument_list|)
expr_stmt|;
name|ns_logstats
argument_list|(
name|ev
argument_list|,
name|NULL
argument_list|,
name|evNowTime
argument_list|()
argument_list|,
name|evConsTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NS_OPTION_P
argument_list|(
name|OPTION_DEALLOC_ON_EXIT
argument_list|)
condition|)
name|deallocate_everything
argument_list|()
expr_stmt|;
else|else
name|shutdown_configuration
argument_list|()
expr_stmt|;
comment|/* Cleanup for system-dependent stuff */
name|custom_shutdown
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sq_closeone
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|qstream
modifier|*
name|sp
decl_stmt|,
modifier|*
name|nextsp
decl_stmt|;
name|struct
name|qstream
modifier|*
name|candidate
init|=
name|NULL
decl_stmt|;
name|time_t
name|lasttime
decl_stmt|,
name|maxctime
init|=
literal|0
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|streamq
init|;
name|sp
condition|;
name|sp
operator|=
name|nextsp
control|)
block|{
name|nextsp
operator|=
name|sp
operator|->
name|s_next
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_refcnt
condition|)
continue|continue;
name|lasttime
operator|=
name|tt
operator|.
name|tv_sec
operator|-
name|sp
operator|->
name|s_time
expr_stmt|;
if|if
condition|(
name|lasttime
operator|>=
name|VQEXPIRY
condition|)
block|{
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lasttime
operator|>
name|maxctime
condition|)
block|{
name|candidate
operator|=
name|sp
expr_stmt|;
name|maxctime
operator|=
name|lasttime
expr_stmt|;
block|}
block|}
if|if
condition|(
name|candidate
condition|)
block|{
name|sq_remove
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ns_socket
parameter_list|(
name|int
name|domain
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|protocol
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|tmp
decl_stmt|;
name|again
label|:
name|fd
operator|=
name|socket
argument_list|(
name|domain
argument_list|,
name|type
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|F_DUPFD
comment|/* XXX */
comment|/* 	 * Leave a space for stdio to work in. 	 */
if|if
condition|(
name|fd
operator|>=
literal|0
operator|&&
name|fd
operator|<=
literal|20
condition|)
block|{
name|int
name|new
decl_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_DUPFD
argument_list|,
literal|20
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"fcntl(fd, F_DUPFD, 20): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|errno
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|tmp
expr_stmt|;
name|fd
operator|=
name|new
expr_stmt|;
block|}
endif|#
directive|endif
name|tmp
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|EMFILE
condition|)
if|if
condition|(
name|sq_closeone
argument_list|()
condition|)
goto|goto
name|again
goto|;
name|errno
operator|=
name|tmp
expr_stmt|;
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|IP_OPT_BUF_SIZE
end_ifndef

begin_comment
comment|/* arbitrary size */
end_comment

begin_define
define|#
directive|define
name|IP_OPT_BUF_SIZE
value|50
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|stream_accept
parameter_list|(
name|evContext
name|lev
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|int
name|rfd
parameter_list|,
specifier|const
name|void
modifier|*
name|lav
parameter_list|,
name|int
name|lalen
parameter_list|,
specifier|const
name|void
modifier|*
name|rav
parameter_list|,
name|int
name|ralen
parameter_list|)
block|{
name|interface
modifier|*
name|ifp
init|=
name|uap
decl_stmt|;
name|struct
name|qstream
modifier|*
name|sp
decl_stmt|;
name|struct
name|iovec
name|iov
decl_stmt|;
name|ISC_SOCKLEN_T
name|len
decl_stmt|;
name|int
name|n
decl_stmt|;
specifier|const
name|int
name|on
init|=
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|IP_OPTIONS
comment|/* XXX */
name|u_char
name|ip_opts
index|[
name|IP_OPT_BUF_SIZE
index|]
decl_stmt|;
endif|#
directive|endif
specifier|const
name|struct
name|sockaddr_in
modifier|*
name|la
decl_stmt|,
modifier|*
name|ra
decl_stmt|;
name|UNUSED
argument_list|(
name|lalen
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|ralen
argument_list|)
expr_stmt|;
name|la
operator|=
operator|(
specifier|const
expr|struct
name|sockaddr_in
operator|*
operator|)
name|lav
expr_stmt|;
name|ra
operator|=
operator|(
specifier|const
expr|struct
name|sockaddr_in
operator|*
operator|)
name|rav
expr_stmt|;
name|INSIST
argument_list|(
name|ifp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|F_DUPFD
comment|/* 	 * Leave a space for stdio to work in. 	 */
if|if
condition|(
name|rfd
operator|>=
literal|0
operator|&&
name|rfd
operator|<=
literal|20
condition|)
block|{
name|int
name|new
decl_stmt|,
name|tmp
decl_stmt|;
name|new
operator|=
name|fcntl
argument_list|(
name|rfd
argument_list|,
name|F_DUPFD
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|new
operator|==
operator|-
literal|1
condition|)
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"fcntl(rfd, F_DUPFD, 20): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|rfd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|tmp
expr_stmt|;
name|rfd
operator|=
name|new
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|rfd
operator|<
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EINTR
case|:
case|case
name|EAGAIN
case|:
if|#
directive|if
operator|(
name|EWOULDBLOCK
operator|!=
name|EAGAIN
operator|)
case|case
name|EWOULDBLOCK
case|:
endif|#
directive|endif
case|case
name|ECONNABORTED
case|:
ifdef|#
directive|ifdef
name|EPROTO
case|case
name|EPROTO
case|:
endif|#
directive|endif
case|case
name|EHOSTUNREACH
case|:
case|case
name|EHOSTDOWN
case|:
case|case
name|ENETUNREACH
case|:
case|case
name|ENETDOWN
case|:
case|case
name|ECONNREFUSED
case|:
ifdef|#
directive|ifdef
name|ENONET
case|case
name|ENONET
case|:
endif|#
directive|endif
comment|/* 			 * These errors are expected and harmless, so 			 * we ignore them. 			 */
return|return;
case|case
name|EBADF
case|:
case|case
name|ENOTSOCK
case|:
case|case
name|EFAULT
case|:
comment|/* 			 * If one these happens, we're broken. 			 */
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"accept: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|EMFILE
case|:
comment|/* 			 * If we're out of file descriptors, find the least 			 * busy fd and close it.  Then we'll return to the 			 * eventlib which will call us right back. 			 */
if|if
condition|(
name|streamq
condition|)
block|{
operator|(
name|void
operator|)
name|sq_closeone
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* fall through */
default|default:
comment|/* 			 * Either we got an error we didn't expect, or we 			 * got EMFILE and didn't have anything left to close. 			 * Log it and press on. 			 */
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"accept: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Condition the socket. */
ifndef|#
directive|ifndef
name|CANNOT_SET_SNDBUF
if|if
condition|(
name|setsockopt
argument_list|(
name|rfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_SNDBUF
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|sbufsize
argument_list|,
sizeof|sizeof
name|sbufsize
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"setsockopt(rfd, SO_SNDBUF, %d): %s"
argument_list|,
name|sbufsize
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|rfd
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|setsockopt
argument_list|(
name|rfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
name|on
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"setsockopt(rfd, KEEPALIVE): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|rfd
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|USE_FIONBIO_IOCTL
if|if
condition|(
name|ioctl
argument_list|(
name|ifp
operator|->
name|dfd
argument_list|,
name|FIONBIO
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"ioctl(rfd, FIONBIO): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|rfd
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|n
operator|=
name|fcntl
argument_list|(
name|rfd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"fcntl(rfd, F_GETFL): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|rfd
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|rfd
argument_list|,
name|F_SETFL
argument_list|,
name|n
operator||
name|PORT_NONBLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"fcntl(rfd, NONBLOCK): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|rfd
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* 	 * We don't like IP options.  Turn them off if the connection came in 	 * with any.  log this event since it usually indicates a security 	 * problem. 	 */
if|#
directive|if
name|defined
argument_list|(
name|IP_OPTIONS
argument_list|)
comment|/* XXX */
name|len
operator|=
sizeof|sizeof
name|ip_opts
expr_stmt|;
if|if
condition|(
name|getsockopt
argument_list|(
name|rfd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_OPTIONS
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ip_opts
argument_list|,
operator|&
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"getsockopt(rfd, IP_OPTIONS): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|rfd
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|nameserIncr
argument_list|(
name|ra
operator|->
name|sin_addr
argument_list|,
name|nssRcvdOpts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
name|ina_ulong
argument_list|(
name|ra
operator|->
name|sin_addr
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
literal|"rcvd ip options"
argument_list|)
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"rcvd IP_OPTIONS from %s (ignored)"
argument_list|,
name|sin_ntoa
argument_list|(
operator|*
name|ra
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setsockopt
argument_list|(
name|rfd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_OPTIONS
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"setsockopt(!IP_OPTIONS): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|rfd
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Create and populate a qsp for this socket. */
if|if
condition|(
operator|(
name|sp
operator|=
name|sq_add
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|rfd
argument_list|)
expr_stmt|;
return|return;
block|}
name|sp
operator|->
name|s_rfd
operator|=
name|rfd
expr_stmt|;
comment|/* stream file descriptor */
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_time
operator|=
name|tt
operator|.
name|tv_sec
expr_stmt|;
comment|/* last transaction time */
name|sp
operator|->
name|s_from
operator|=
operator|*
name|ra
expr_stmt|;
comment|/* address to respond to */
name|sp
operator|->
name|s_ifp
operator|=
name|ifp
expr_stmt|;
name|INSIST
argument_list|(
sizeof|sizeof
name|sp
operator|->
name|s_temp
operator|>=
name|INT16SZ
argument_list|)
expr_stmt|;
name|iov
operator|=
name|evConsIovec
argument_list|(
name|sp
operator|->
name|s_temp
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|INSIST_ERR
argument_list|(
name|evRead
argument_list|(
name|lev
argument_list|,
name|rfd
argument_list|,
operator|&
name|iov
argument_list|,
literal|1
argument_list|,
name|stream_getlen
argument_list|,
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|evID_r
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|->
name|flags
operator||=
name|STREAM_READ_EV
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"IP/TCP connection from %s (fd %d)"
argument_list|,
name|sin_ntoa
argument_list|(
name|sp
operator|->
name|s_from
argument_list|)
argument_list|,
name|rfd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|tcp_send
parameter_list|(
name|struct
name|qinfo
modifier|*
name|qp
parameter_list|)
block|{
name|struct
name|qstream
modifier|*
name|sp
decl_stmt|;
name|struct
name|sockaddr_in
name|src
decl_stmt|;
name|int
name|on
init|=
literal|1
decl_stmt|,
name|n
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"tcp_send"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|ns_socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
name|PF_UNSPEC
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|SERVFAIL
operator|)
return|;
if|if
condition|(
name|fd
operator|>
name|evHighestFD
argument_list|(
name|ev
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|SERVFAIL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|sp
operator|=
name|sq_add
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|SERVFAIL
operator|)
return|;
block|}
name|sp
operator|->
name|s_rfd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|sp
operator|->
name|s_rfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"tcp_send: setsockopt(SO_REUSEADDR): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SO_REUSEPORT
if|if
condition|(
name|setsockopt
argument_list|(
name|sp
operator|->
name|s_rfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEPORT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"tcp_send: setsockopt(SO_REUSEPORT): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|src
operator|=
name|server_options
operator|->
name|query_source
expr_stmt|;
name|src
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|sp
operator|->
name|s_rfd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|src
argument_list|,
sizeof|sizeof
argument_list|(
name|src
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"tcp_send: bind(query_source): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|sp
operator|->
name|s_rfd
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SERVFAIL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|USE_FIONBIO_IOCTL
if|if
condition|(
name|ioctl
argument_list|(
name|sp
operator|->
name|s_rfd
argument_list|,
name|FIONBIO
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SERVFAIL
operator|)
return|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|n
operator|=
name|fcntl
argument_list|(
name|sp
operator|->
name|s_rfd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SERVFAIL
operator|)
return|;
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|sp
operator|->
name|s_rfd
argument_list|,
name|F_SETFL
argument_list|,
name|n
operator||
name|PORT_NONBLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SERVFAIL
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sq_openw
argument_list|(
name|sp
argument_list|,
name|qp
operator|->
name|q_msglen
operator|+
name|INT16SZ
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SERVFAIL
operator|)
return|;
block|}
if|if
condition|(
name|sq_write
argument_list|(
name|sp
argument_list|,
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SERVFAIL
operator|)
return|;
block|}
if|if
condition|(
name|setsockopt
argument_list|(
name|sp
operator|->
name|s_rfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"tcp_send: setsockopt(SO_KEEPALIVE): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_size
operator|=
operator|-
literal|1
expr_stmt|;
name|sp
operator|->
name|s_time
operator|=
name|tt
operator|.
name|tv_sec
expr_stmt|;
comment|/* last transaction time */
name|sp
operator|->
name|s_refcnt
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|flags
operator||=
name|STREAM_DONE_CLOSE
expr_stmt|;
name|sp
operator|->
name|s_from
operator|=
name|qp
operator|->
name|q_addr
index|[
name|qp
operator|->
name|q_curaddr
index|]
operator|.
name|ns_addr
expr_stmt|;
if|if
condition|(
name|evConnect
argument_list|(
name|ev
argument_list|,
name|sp
operator|->
name|s_rfd
argument_list|,
operator|&
name|sp
operator|->
name|s_from
argument_list|,
sizeof|sizeof
argument_list|(
name|sp
operator|->
name|s_from
argument_list|)
argument_list|,
name|stream_send
argument_list|,
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|evID_c
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SERVFAIL
operator|)
return|;
block|}
name|sp
operator|->
name|flags
operator||=
name|STREAM_CONNECT_EV
expr_stmt|;
return|return
operator|(
name|NOERROR
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|stream_send
parameter_list|(
name|evContext
name|lev
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|int
name|fd
parameter_list|,
specifier|const
name|void
modifier|*
name|la
parameter_list|,
name|int
name|lalen
parameter_list|,
specifier|const
name|void
modifier|*
name|ra
parameter_list|,
name|int
name|ralen
parameter_list|)
block|{
name|struct
name|qstream
modifier|*
name|sp
init|=
name|uap
decl_stmt|;
name|UNUSED
argument_list|(
name|lev
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|lalen
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|ra
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|ralen
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"stream_send"
argument_list|)
expr_stmt|;
name|sp
operator|->
name|flags
operator|&=
operator|~
name|STREAM_CONNECT_EV
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* connect failed */
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|evSelectFD
argument_list|(
name|ev
argument_list|,
name|sp
operator|->
name|s_rfd
argument_list|,
name|EV_WRITE
argument_list|,
name|stream_write
argument_list|,
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|evID_w
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
name|sp
operator|->
name|flags
operator||=
name|STREAM_WRITE_EV
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stream_write
parameter_list|(
name|evContext
name|ctx
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|evmask
parameter_list|)
block|{
name|struct
name|qstream
modifier|*
name|sp
init|=
name|uap
decl_stmt|;
name|struct
name|iovec
name|iov
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"stream_write"
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|evmask
operator|&
name|EV_WRITE
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|fd
operator|==
name|sp
operator|->
name|s_rfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sq_dowrite
argument_list|(
name|sp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sp
operator|->
name|s_wbuf_free
operator|!=
name|sp
operator|->
name|s_wbuf_send
condition|)
return|return;
if|if
condition|(
name|sp
operator|->
name|s_wbuf
condition|)
block|{
name|memput
argument_list|(
name|sp
operator|->
name|s_wbuf
argument_list|,
name|sp
operator|->
name|s_wbuf_end
operator|-
name|sp
operator|->
name|s_wbuf
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_wbuf_send
operator|=
name|sp
operator|->
name|s_wbuf_free
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|s_wbuf_end
operator|=
name|sp
operator|->
name|s_wbuf
operator|=
name|NULL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|evDeselectFD
argument_list|(
name|ev
argument_list|,
name|sp
operator|->
name|evID_w
argument_list|)
expr_stmt|;
name|sp
operator|->
name|flags
operator|&=
operator|~
name|STREAM_WRITE_EV
expr_stmt|;
name|sp
operator|->
name|s_refcnt
operator|=
literal|0
expr_stmt|;
name|iov
operator|=
name|evConsIovec
argument_list|(
name|sp
operator|->
name|s_temp
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|INSIST_ERR
argument_list|(
name|evRead
argument_list|(
name|ctx
argument_list|,
name|fd
argument_list|,
operator|&
name|iov
argument_list|,
literal|1
argument_list|,
name|stream_getlen
argument_list|,
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|evID_r
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|->
name|flags
operator||=
name|STREAM_READ_EV
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stream_getlen
parameter_list|(
name|evContext
name|lev
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|bytes
parameter_list|)
block|{
name|struct
name|qstream
modifier|*
name|sp
init|=
name|uap
decl_stmt|;
name|struct
name|iovec
name|iov
decl_stmt|;
name|UNUSED
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|sp
operator|->
name|flags
operator|&=
operator|~
name|STREAM_READ_EV
expr_stmt|;
if|if
condition|(
name|bytes
operator|!=
name|INT16SZ
condition|)
block|{
comment|/* 		 * bytes == 0 is normal EOF; see if something unusual  		 * happened. 		 */
if|if
condition|(
name|bytes
operator|<
literal|0
condition|)
block|{
comment|/* 			 * ECONNRESET happens frequently and is not worth 			 * logging. 			 */
if|if
condition|(
name|errno
operator|!=
name|ECONNRESET
condition|)
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"stream_getlen(%s): %s"
argument_list|,
name|sin_ntoa
argument_list|(
name|sp
operator|->
name|s_from
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|!=
literal|0
condition|)
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"stream_getlen(%s): unexpected byte count %d"
argument_list|,
name|sin_ntoa
argument_list|(
name|sp
operator|->
name|s_from
argument_list|)
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Unpack the size, allocate memory for the query.  This is 	 * tricky since in a low memory situation with possibly very 	 * large (64KB) queries, we want to make sure we can read at 	 * least the header since we need it to send back a SERVFAIL 	 * (owing to the out-of-memory condition). 	 */
name|sp
operator|->
name|s_size
operator|=
name|ns_get16
argument_list|(
name|sp
operator|->
name|s_temp
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|5
argument_list|,
literal|"stream message: %d bytes"
argument_list|,
name|sp
operator|->
name|s_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_size
operator|<
name|HFIXEDSZ
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"stream_getlen(%s): request too small"
argument_list|,
name|sin_ntoa
argument_list|(
name|sp
operator|->
name|s_from
argument_list|)
argument_list|)
expr_stmt|;
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|sp
operator|->
name|flags
operator|&
name|STREAM_MALLOC
operator|)
condition|)
block|{
name|sp
operator|->
name|s_bufsize
operator|=
literal|64
operator|*
literal|1024
operator|-
literal|1
expr_stmt|;
comment|/* maximum tcp message size */
name|sp
operator|->
name|s_buf
operator|=
operator|(
name|u_char
operator|*
operator|)
name|memget
argument_list|(
name|sp
operator|->
name|s_bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_buf
operator|!=
name|NULL
condition|)
name|sp
operator|->
name|flags
operator||=
name|STREAM_MALLOC
expr_stmt|;
else|else
block|{
name|sp
operator|->
name|s_buf
operator|=
name|sp
operator|->
name|s_temp
expr_stmt|;
name|sp
operator|->
name|s_bufsize
operator|=
name|HFIXEDSZ
expr_stmt|;
block|}
block|}
name|iov
operator|=
name|evConsIovec
argument_list|(
name|sp
operator|->
name|s_buf
argument_list|,
operator|(
name|sp
operator|->
name|s_size
operator|<=
name|sp
operator|->
name|s_bufsize
operator|)
condition|?
name|sp
operator|->
name|s_size
else|:
name|sp
operator|->
name|s_bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|evRead
argument_list|(
name|lev
argument_list|,
name|sp
operator|->
name|s_rfd
argument_list|,
operator|&
name|iov
argument_list|,
literal|1
argument_list|,
name|stream_getmsg
argument_list|,
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|evID_r
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"evRead(fd %d): %s"
argument_list|,
name|sp
operator|->
name|s_rfd
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|flags
operator||=
name|STREAM_READ_EV
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stream_getmsg
parameter_list|(
name|evContext
name|lev
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|bytes
parameter_list|)
block|{
name|struct
name|qstream
modifier|*
name|sp
init|=
name|uap
decl_stmt|;
name|UNUSED
argument_list|(
name|lev
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|sp
operator|->
name|flags
operator|&=
operator|~
name|STREAM_READ_EV
expr_stmt|;
if|if
condition|(
name|bytes
operator|==
operator|-
literal|1
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"stream_getmsg(%s): %s"
argument_list|,
name|sin_ntoa
argument_list|(
name|sp
operator|->
name|s_from
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_time
operator|=
name|tt
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|ns_wouldlog
argument_list|(
name|ns_log_default
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|5
argument_list|,
literal|"sp %p rfd %d size %d time %ld next %p"
argument_list|,
name|sp
argument_list|,
name|sp
operator|->
name|s_rfd
argument_list|,
name|sp
operator|->
name|s_size
argument_list|,
operator|(
name|long
operator|)
name|sp
operator|->
name|s_time
argument_list|,
name|sp
operator|->
name|s_next
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|5
argument_list|,
literal|"\tbufsize %d bytes %d"
argument_list|,
name|sp
operator|->
name|s_bufsize
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Do we have enough memory for the query?  If not, and if we have a 	 * query id, then we will send a SERVFAIL error back to the client. 	 */
if|if
condition|(
name|bytes
operator|!=
name|sp
operator|->
name|s_size
condition|)
block|{
name|HEADER
modifier|*
name|hp
init|=
operator|(
name|HEADER
operator|*
operator|)
name|sp
operator|->
name|s_buf
decl_stmt|;
name|hp
operator|->
name|qr
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|ra
operator|=
operator|(
name|NS_OPTION_P
argument_list|(
name|OPTION_NORECURSE
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|qdcount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
name|writestream
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|s_buf
argument_list|,
name|HFIXEDSZ
argument_list|)
expr_stmt|;
name|sp
operator|->
name|flags
operator||=
name|STREAM_DONE_CLOSE
expr_stmt|;
return|return;
block|}
name|nameserIncr
argument_list|(
name|sp
operator|->
name|s_from
operator|.
name|sin_addr
argument_list|,
name|nssRcvdTCP
argument_list|)
expr_stmt|;
name|sq_query
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|dispatch_message
argument_list|(
name|sp
operator|->
name|s_buf
argument_list|,
name|bytes
argument_list|,
name|sp
operator|->
name|s_bufsize
argument_list|,
name|sp
argument_list|,
name|sp
operator|->
name|s_from
argument_list|,
operator|-
literal|1
argument_list|,
name|sp
operator|->
name|s_ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|datagram_read
parameter_list|(
name|evContext
name|lev
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|evmask
parameter_list|)
block|{
name|interface
modifier|*
name|ifp
init|=
name|uap
decl_stmt|;
name|struct
name|sockaddr_in
name|from
decl_stmt|;
name|ISC_SOCKLEN_T
name|from_len
init|=
sizeof|sizeof
name|from
decl_stmt|;
name|int
name|n
decl_stmt|,
name|nudp
decl_stmt|;
union|union
block|{
name|HEADER
name|h
decl_stmt|;
comment|/* Force alignment of 'buf'. */
name|u_char
name|buf
index|[
name|EDNS_MESSAGE_SZ
operator|+
literal|1
index|]
decl_stmt|;
block|}
name|u
union|;
name|UNUSED
argument_list|(
name|lev
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|evmask
argument_list|)
expr_stmt|;
name|tt
operator|=
name|evTimeVal
argument_list|(
name|evNowTime
argument_list|()
argument_list|)
expr_stmt|;
name|nudp
operator|=
literal|0
expr_stmt|;
name|more
label|:
name|n
operator|=
name|recvfrom
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|u
operator|.
name|buf
argument_list|,
sizeof|sizeof
name|u
operator|.
name|buf
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
operator|&
name|from_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EINTR
case|:
case|case
name|EAGAIN
case|:
if|#
directive|if
operator|(
name|EWOULDBLOCK
operator|!=
name|EAGAIN
operator|)
case|case
name|EWOULDBLOCK
case|:
endif|#
directive|endif
case|case
name|EHOSTUNREACH
case|:
case|case
name|EHOSTDOWN
case|:
case|case
name|ENETUNREACH
case|:
case|case
name|ENETDOWN
case|:
case|case
name|ECONNREFUSED
case|:
ifdef|#
directive|ifdef
name|ENONET
case|case
name|ENONET
case|:
endif|#
directive|endif
comment|/* 			 * These errors are expected and harmless, so we 			 * ignore them. 			 */
return|return;
default|default:
comment|/* 			 * An error we don't expect.  Log it and press 			 * on. 			 */
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"recvfrom: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Handle bogosity on systems that need it. */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|ns_wouldlog
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"datagram from %s, fd %d, len %d"
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
name|fd
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
name|EDNS_MESSAGE_SZ
condition|)
block|{
comment|/* 		 * The message is too big.  It's probably a response to 		 * one of our questions, so we truncate it and press on. 		 */
name|n
operator|=
name|trunc_adjust
argument_list|(
name|u
operator|.
name|buf
argument_list|,
name|EDNS_MESSAGE_SZ
argument_list|,
name|EDNS_MESSAGE_SZ
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"truncated oversize UDP packet"
argument_list|)
expr_stmt|;
block|}
name|dispatch_message
argument_list|(
name|u
operator|.
name|buf
argument_list|,
name|n
argument_list|,
name|EDNS_MESSAGE_SZ
argument_list|,
name|NULL
argument_list|,
name|from
argument_list|,
name|fd
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|nudp
operator|<
name|nudptrans
condition|)
goto|goto
name|more
goto|;
block|}
end_function

begin_function
specifier|static
name|void
name|savedg_waitfunc
parameter_list|(
name|evContext
name|ctx
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
specifier|const
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|savedg
modifier|*
name|dg
init|=
operator|(
name|savedg
operator|*
operator|)
name|uap
decl_stmt|;
name|UNUSED
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EMPTY
argument_list|(
name|iflist
argument_list|)
operator|&&
name|HEAD
argument_list|(
name|iflist
argument_list|)
operator|->
name|gen
operator|==
name|dg
operator|->
name|gen
condition|)
block|{
name|u_char
name|buf
index|[
name|EDNS_MESSAGE_SZ
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|dg
operator|->
name|buf
argument_list|,
name|dg
operator|->
name|buflen
argument_list|)
expr_stmt|;
name|dispatch_message
argument_list|(
name|buf
argument_list|,
name|dg
operator|->
name|buflen
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|NULL
argument_list|,
name|dg
operator|->
name|from
argument_list|,
name|dg
operator|->
name|dfd
argument_list|,
name|dg
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
name|memput
argument_list|(
name|dg
operator|->
name|buf
argument_list|,
name|dg
operator|->
name|buflen
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|dg
argument_list|,
sizeof|sizeof
expr|*
name|dg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dispatch_message
parameter_list|(
name|u_char
modifier|*
name|msg
parameter_list|,
name|int
name|msglen
parameter_list|,
name|int
name|buflen
parameter_list|,
name|struct
name|qstream
modifier|*
name|qsp
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|,
name|int
name|dfd
parameter_list|,
name|interface
modifier|*
name|ifp
parameter_list|)
block|{
name|HEADER
modifier|*
name|hp
init|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
decl_stmt|;
if|if
condition|(
name|msglen
operator|<
name|HFIXEDSZ
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"dropping undersize message"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qsp
condition|)
block|{
name|qsp
operator|->
name|flags
operator||=
name|STREAM_DONE_CLOSE
expr_stmt|;
name|sq_done
argument_list|(
name|qsp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|server_options
operator|->
name|blackhole_acl
operator|!=
name|NULL
operator|&&
name|ip_match_address
argument_list|(
name|server_options
operator|->
name|blackhole_acl
argument_list|,
name|from
operator|.
name|sin_addr
argument_list|)
operator|==
literal|1
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"dropping blackholed %s from %s"
argument_list|,
name|hp
operator|->
name|qr
condition|?
literal|"response"
else|:
literal|"query"
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qsp
condition|)
block|{
name|qsp
operator|->
name|flags
operator||=
name|STREAM_DONE_CLOSE
expr_stmt|;
name|sq_done
argument_list|(
name|qsp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* Drop UDP packets from port zero.  They are invariable forged. */
if|if
condition|(
name|qsp
operator|==
name|NULL
operator|&&
name|ntohs
argument_list|(
name|from
operator|.
name|sin_port
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_security
argument_list|,
literal|"dropping source port zero packet from %s"
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hp
operator|->
name|qr
condition|)
block|{
name|ns_resp
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|,
name|from
argument_list|,
name|qsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|qsp
condition|)
name|sq_done
argument_list|(
name|qsp
argument_list|)
expr_stmt|;
comment|/* Now is a safe time for housekeeping. */
if|if
condition|(
name|needs_prime_cache
condition|)
name|prime_cache
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
name|ns_req
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|,
name|buflen
argument_list|,
name|qsp
argument_list|,
name|from
argument_list|,
name|dfd
argument_list|)
expr_stmt|;
else|else
block|{
name|ns_notice
argument_list|(
name|ns_log_security
argument_list|,
literal|"refused query on non-query socket from %s"
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qsp
condition|)
block|{
name|qsp
operator|->
name|flags
operator||=
name|STREAM_DONE_CLOSE
expr_stmt|;
name|sq_done
argument_list|(
name|qsp
argument_list|)
expr_stmt|;
block|}
comment|/* XXX Send refusal here. */
block|}
block|}
end_function

begin_function
name|void
name|getnetconf
parameter_list|(
name|int
name|periodic_scan
parameter_list|)
block|{
name|struct
name|ifconf
name|ifc
decl_stmt|;
name|struct
name|ifreq
name|ifreq
decl_stmt|;
name|struct
name|in_addr
name|ina
decl_stmt|;
name|interface
modifier|*
name|ifp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cplim
decl_stmt|;
specifier|static
name|int
name|bufsiz
init|=
literal|4095
decl_stmt|;
name|time_t
name|my_generation
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|int
name|s
decl_stmt|,
name|cpsize
decl_stmt|,
name|n
decl_stmt|;
name|int
name|found
decl_stmt|;
name|listen_info
name|li
decl_stmt|;
name|ip_match_element
name|ime
decl_stmt|;
name|u_char
modifier|*
name|mask_ptr
decl_stmt|;
name|struct
name|in_addr
name|mask
decl_stmt|;
if|if
condition|(
name|iflist_initialized
condition|)
block|{
if|if
condition|(
name|iflist_dont_rescan
condition|)
return|return;
block|}
else|else
block|{
name|INIT_LIST
argument_list|(
name|iflist
argument_list|)
expr_stmt|;
name|iflist_initialized
operator|=
literal|1
expr_stmt|;
block|}
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"getnetconf(generation %lu)"
argument_list|,
operator|(
name|u_long
operator|)
name|my_generation
argument_list|)
expr_stmt|;
comment|/* Get interface list from system. */
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|periodic_scan
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"socket(SOCK_RAW): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"socket(SOCK_RAW): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|local_addresses
operator|!=
name|NULL
condition|)
name|free_ip_match_list
argument_list|(
name|local_addresses
argument_list|)
expr_stmt|;
name|local_addresses
operator|=
name|new_ip_match_list
argument_list|()
expr_stmt|;
if|if
condition|(
name|local_networks
operator|!=
name|NULL
condition|)
name|free_ip_match_list
argument_list|(
name|local_networks
argument_list|)
expr_stmt|;
name|local_networks
operator|=
name|new_ip_match_list
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|buf
operator|=
name|memget
argument_list|(
name|bufsiz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"memget(interface)"
argument_list|)
expr_stmt|;
name|ifc
operator|.
name|ifc_len
operator|=
name|bufsiz
expr_stmt|;
name|ifc
operator|.
name|ifc_buf
operator|=
name|buf
expr_stmt|;
ifdef|#
directive|ifdef
name|IRIX_EMUL_IOCTL_SIOCGIFCONF
comment|/* 		 * This is a fix for IRIX OS in which the call to ioctl with 		 * the flag SIOCGIFCONF may not return an entry for all the 		 * interfaces like most flavors of Unix. 		 */
if|if
condition|(
name|emul_ioctl
argument_list|(
operator|&
name|ifc
argument_list|)
operator|>=
literal|0
condition|)
break|break;
else|#
directive|else
if|if
condition|(
operator|(
name|n
operator|=
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFCONF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifc
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 			 * Some OS's just return what will fit rather 			 * than set EINVAL if the buffer is too small 			 * to fit all the interfaces in.  If  			 * ifc.ifc_len is too near to the end of the 			 * buffer we will grow it just in case and 			 * retry. 			 */
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|ifc
operator|.
name|ifc_len
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|ifreq
argument_list|)
argument_list|)
operator|<
name|bufsiz
condition|)
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|n
operator|==
operator|-
literal|1
operator|)
operator|&&
name|errno
operator|!=
name|EINVAL
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"get interface configuration: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufsiz
operator|>
literal|1000000
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"get interface configuration: maximum buffer size exceeded"
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|buf
argument_list|,
name|bufsiz
argument_list|)
expr_stmt|;
name|bufsiz
operator|+=
literal|4096
expr_stmt|;
block|}
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|2
argument_list|,
literal|"getnetconf: SIOCGIFCONF: ifc_len = %d"
argument_list|,
name|ifc
operator|.
name|ifc_len
argument_list|)
expr_stmt|;
comment|/* Parse system's interface list and open some sockets. */
name|cplim
operator|=
name|buf
operator|+
name|ifc
operator|.
name|ifc_len
expr_stmt|;
comment|/* skip over if's with big ifr_addr's */
for|for
control|(
name|cp
operator|=
name|buf
init|;
name|cp
operator|<
name|cplim
condition|;
name|cp
operator|+=
name|cpsize
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|ifreq
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
name|ifreq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SA_LEN
ifdef|#
directive|ifdef
name|FIX_ZERO_SA_LEN
if|if
condition|(
name|ifreq
operator|.
name|ifr_addr
operator|.
name|sa_len
operator|==
literal|0
condition|)
name|ifreq
operator|.
name|ifr_addr
operator|.
name|sa_len
operator|=
literal|16
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_MINIMUM_IFREQ
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|2
argument_list|,
literal|"%s sa_len = %d"
argument_list|,
name|ifreq
operator|.
name|ifr_name
argument_list|,
operator|(
name|int
operator|)
name|ifreq
operator|.
name|ifr_addr
operator|.
name|sa_len
argument_list|)
expr_stmt|;
name|cpsize
operator|=
sizeof|sizeof
name|ifreq
expr_stmt|;
if|if
condition|(
name|ifreq
operator|.
name|ifr_addr
operator|.
name|sa_len
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
condition|)
name|cpsize
operator|+=
operator|(
name|int
operator|)
name|ifreq
operator|.
name|ifr_addr
operator|.
name|sa_len
operator|-
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|cpsize
operator|=
sizeof|sizeof
name|ifreq
operator|.
name|ifr_name
operator|+
name|ifreq
operator|.
name|ifr_addr
operator|.
name|sa_len
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_MINIMUM_IFREQ */
elif|#
directive|elif
name|defined
name|SIOCGIFCONF_ADDR
name|cpsize
operator|=
sizeof|sizeof
name|ifreq
expr_stmt|;
else|#
directive|else
name|cpsize
operator|=
sizeof|sizeof
name|ifreq
operator|.
name|ifr_name
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"get interface addr (%s): %s"
argument_list|,
name|ifreq
operator|.
name|ifr_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
name|ifreq
operator|.
name|ifr_addr
operator|.
name|sa_family
operator|!=
name|AF_INET
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|2
argument_list|,
literal|"getnetconf: %s AF %d != INET"
argument_list|,
name|ifreq
operator|.
name|ifr_name
argument_list|,
name|ifreq
operator|.
name|ifr_addr
operator|.
name|sa_family
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ina
operator|=
name|ina_get
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_addr
operator|)
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"getnetconf: considering %s [%s]"
argument_list|,
name|ifreq
operator|.
name|ifr_name
argument_list|,
name|inet_ntoa
argument_list|(
name|ina
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Don't test IFF_UP, packets may still be received at this 		 * address if any other interface is up. 		 */
if|if
condition|(
name|ina_hlong
argument_list|(
name|ina
argument_list|)
operator|==
name|INADDR_ANY
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|2
argument_list|,
literal|"getnetconf: INADDR_ANY, ignoring."
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|INSIST
argument_list|(
name|server_options
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|server_options
operator|->
name|listen_list
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|li
operator|=
name|server_options
operator|->
name|listen_list
operator|->
name|first
init|;
name|li
operator|!=
name|NULL
condition|;
name|li
operator|=
name|li
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ip_match_address
argument_list|(
name|li
operator|->
name|list
argument_list|,
name|ina
argument_list|)
operator|>
literal|0
condition|)
block|{
name|found
operator|++
expr_stmt|;
comment|/*  				 * Look for an already existing source 				 * interface address/port pair. 				 * This happens mostly when reinitializing. 				 * Also, if the machine has multiple point to 				 * point interfaces, then the local address 				 * may appear more than once. 				 */
name|ifp
operator|=
name|if_find
argument_list|(
name|ina
argument_list|,
name|li
operator|->
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"dup interface addr [%s].%u (%s)"
argument_list|,
name|inet_ntoa
argument_list|(
name|ina
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|li
operator|->
name|port
argument_list|)
argument_list|,
name|ifreq
operator|.
name|ifr_name
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|gen
operator|=
name|my_generation
expr_stmt|;
continue|continue;
block|}
name|ifp
operator|=
operator|(
name|interface
operator|*
operator|)
name|memget
argument_list|(
sizeof|sizeof
expr|*
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ifp
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"memget(interface)"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|ifp
argument_list|)
expr_stmt|;
name|INIT_LINK
argument_list|(
name|ifp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|APPEND
argument_list|(
name|iflist
argument_list|,
name|ifp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|addr
operator|=
name|ina
expr_stmt|;
name|ifp
operator|->
name|port
operator|=
name|li
operator|->
name|port
expr_stmt|;
name|ifp
operator|->
name|gen
operator|=
name|my_generation
expr_stmt|;
name|ifp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|dfd
operator|=
operator|-
literal|1
expr_stmt|;
name|ifp
operator|->
name|sfd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|opensocket_d
argument_list|(
name|ifp
argument_list|)
operator|<
literal|0
operator|||
name|opensocket_s
argument_list|(
name|ifp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|dq_remove
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"listening on [%s].%u (%s)"
argument_list|,
name|inet_ntoa
argument_list|(
name|ina
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|li
operator|->
name|port
argument_list|)
argument_list|,
name|ifreq
operator|.
name|ifr_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"not listening on addr [%s] (%s)"
argument_list|,
name|inet_ntoa
argument_list|(
name|ina
argument_list|)
argument_list|,
name|ifreq
operator|.
name|ifr_name
argument_list|)
expr_stmt|;
comment|/* 		 * Add this interface's address to the list of local 		 * addresses if we haven't added it already. 		 */
if|if
condition|(
name|ip_match_address
argument_list|(
name|local_addresses
argument_list|,
name|ina
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ime
operator|=
name|new_ip_match_pattern
argument_list|(
name|ina
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|add_to_ip_match_list
argument_list|(
name|local_addresses
argument_list|,
name|ime
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Get interface flags. 		 */
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"get interface flags: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|ifreq
operator|.
name|ifr_flags
operator|&
name|IFF_POINTOPOINT
operator|)
condition|)
block|{
comment|/* 			 * The local network for a PPP link is just the 			 * two ends of the link, so for each endpoint we 			 * add a pattern that will only match the endpoint. 			 */
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFDSTADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"get dst addr: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mask
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_BROADCAST
argument_list|)
expr_stmt|;
comment|/* 			 * Our end. 			 * 			 * Only add it if we haven't seen it before. 			 */
if|if
condition|(
name|ip_match_network
argument_list|(
name|local_networks
argument_list|,
name|ina
argument_list|,
name|mask
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ime
operator|=
name|new_ip_match_pattern
argument_list|(
name|ina
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|add_to_ip_match_list
argument_list|(
name|local_networks
argument_list|,
name|ime
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * The other end. 			 */
name|ina
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_addr
operator|)
operator|->
name|sin_addr
expr_stmt|;
comment|/* 			 * Only add it if we haven't seen it before. 			 */
if|if
condition|(
name|ip_match_network
argument_list|(
name|local_networks
argument_list|,
name|ina
argument_list|,
name|mask
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ime
operator|=
name|new_ip_match_pattern
argument_list|(
name|ina
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|add_to_ip_match_list
argument_list|(
name|local_networks
argument_list|,
name|ime
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * Add this interface's network and netmask to the 			 * list of local networks. 			 */
ifdef|#
directive|ifdef
name|SIOCGIFNETMASK
comment|/* XXX */
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFNETMASK
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"get netmask: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * Use ina_get because the ifreq structure might not 			 * be aligned. 			 */
name|mask_ptr
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_addr
operator|)
operator|->
name|sin_addr
expr_stmt|;
name|mask
operator|=
name|ina_get
argument_list|(
name|mask_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|mask
operator|=
name|net_mask
argument_list|(
name|ina
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ina
operator|.
name|s_addr
operator|&=
name|mask
operator|.
name|s_addr
expr_stmt|;
comment|/* make network address */
comment|/* 			 * Only add it if we haven't seen it before. 			 */
if|if
condition|(
name|ip_match_network
argument_list|(
name|local_networks
argument_list|,
name|ina
argument_list|,
name|mask
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ime
operator|=
name|new_ip_match_mask
argument_list|(
name|ina
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|add_to_ip_match_list
argument_list|(
name|local_networks
argument_list|,
name|ime
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|buf
argument_list|,
name|bufsiz
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|7
argument_list|,
literal|"local addresses:"
argument_list|)
expr_stmt|;
name|dprint_ip_match_list
argument_list|(
name|ns_log_default
argument_list|,
name|local_addresses
argument_list|,
literal|2
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|7
argument_list|,
literal|"local networks:"
argument_list|)
expr_stmt|;
name|dprint_ip_match_list
argument_list|(
name|ns_log_default
argument_list|,
name|local_networks
argument_list|,
literal|2
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 	 * now go through the iflist and delete anything that 	 * does not have the current generation number.  this is 	 * how we catch interfaces that go away or change their 	 * addresses.  note that 0.0.0.0 is the wildcard element 	 * and should never be deleted by this code. 	 */
name|dq_remove_gen
argument_list|(
name|my_generation
argument_list|)
expr_stmt|;
if|if
condition|(
name|EMPTY
argument_list|(
name|iflist
argument_list|)
condition|)
name|ns_warning
argument_list|(
name|ns_log_default
argument_list|,
literal|"not listening on any interfaces"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* opensocket_d(ifp)  *	Open datagram socket bound to interface address.  * Returns:  *	0 on success.  *	-1 on failure.  */
end_comment

begin_function
specifier|static
name|int
name|opensocket_d
parameter_list|(
name|interface
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|sockaddr_in
name|nsa
decl_stmt|;
specifier|const
name|int
name|on
init|=
literal|1
decl_stmt|;
name|ISC_SOCKLEN_T
name|m
decl_stmt|;
name|int
name|n
decl_stmt|;
name|memset
argument_list|(
operator|&
name|nsa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|nsa
argument_list|)
expr_stmt|;
name|nsa
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|nsa
operator|.
name|sin_addr
operator|=
name|ifp
operator|->
name|addr
expr_stmt|;
name|nsa
operator|.
name|sin_port
operator|=
name|ifp
operator|->
name|port
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|dfd
operator|=
name|ns_socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"socket(SOCK_DGRAM): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ifp
operator|->
name|dfd
operator|>
name|evHighestFD
argument_list|(
name|ev
argument_list|)
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"socket too high: %d"
argument_list|,
name|ifp
operator|->
name|dfd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ifp
operator|->
name|dfd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|USE_FIONBIO_IOCTL
if|if
condition|(
name|ioctl
argument_list|(
name|ifp
operator|->
name|dfd
argument_list|,
name|FIONBIO
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"ioctl(ifp->dfd, FIONBIO): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|ifp
operator|->
name|dfd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|n
operator|=
name|fcntl
argument_list|(
name|ifp
operator|->
name|dfd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"fcntl(ifp->dfd, F_GETFL): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|ifp
operator|->
name|dfd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|ifp
operator|->
name|dfd
argument_list|,
name|F_SETFL
argument_list|,
name|n
operator||
name|PORT_NONBLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"fcntl(ifp->dfd, NONBLOCK): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|ifp
operator|->
name|dfd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|fcntl
argument_list|(
name|ifp
operator|->
name|dfd
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"F_SETFD: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ifp
operator|->
name|dfd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"ifp->addr %s d_dfd %d"
argument_list|,
name|sin_ntoa
argument_list|(
name|nsa
argument_list|)
argument_list|,
name|ifp
operator|->
name|dfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|ifp
operator|->
name|dfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"setsockopt(REUSEADDR): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX press on regardless, this is not too serious. */
block|}
ifdef|#
directive|ifdef
name|SO_RCVBUF
comment|/* XXX */
name|m
operator|=
sizeof|sizeof
name|n
expr_stmt|;
if|if
condition|(
operator|(
name|getsockopt
argument_list|(
name|ifp
operator|->
name|dfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVBUF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|n
argument_list|,
operator|&
name|m
argument_list|)
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|m
operator|==
sizeof|sizeof
name|n
operator|)
operator|&&
operator|(
name|n
operator|<
name|drbufsize
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|ifp
operator|->
name|dfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVBUF
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|drbufsize
argument_list|,
sizeof|sizeof
name|drbufsize
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SO_RCVBUF */
ifndef|#
directive|ifndef
name|CANNOT_SET_SNDBUF
if|if
condition|(
name|setsockopt
argument_list|(
name|ifp
operator|->
name|dfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_SNDBUF
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|dsbufsize
argument_list|,
sizeof|sizeof
name|dsbufsize
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"setsockopt(dfd=%d, SO_SNDBUF, %d): %s"
argument_list|,
name|ifp
operator|->
name|dfd
argument_list|,
name|dsbufsize
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX press on regardless, this is not too serious. */
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SO_BSDCOMPAT
if|if
condition|(
name|setsockopt
argument_list|(
name|ifp
operator|->
name|dfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_BSDCOMPAT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
name|on
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"setsockopt(dfd=%d, SO_BSDCOMPAT): %s"
argument_list|,
name|ifp
operator|->
name|dfd
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|bind
argument_list|(
name|ifp
operator|->
name|dfd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|nsa
argument_list|,
sizeof|sizeof
name|nsa
argument_list|)
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"bind(dfd=%d, %s): %s"
argument_list|,
name|ifp
operator|->
name|dfd
argument_list|,
name|sin_ntoa
argument_list|(
name|nsa
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|evSelectFD
argument_list|(
name|ev
argument_list|,
name|ifp
operator|->
name|dfd
argument_list|,
name|EV_READ
argument_list|,
name|datagram_read
argument_list|,
name|ifp
argument_list|,
operator|&
name|ifp
operator|->
name|evID_d
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"evSelectFD(dfd=%d): %s"
argument_list|,
name|ifp
operator|->
name|dfd
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ifp
operator|->
name|flags
operator||=
name|INTERFACE_FILE_VALID
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drain_rcvbuf
parameter_list|(
name|evContext
name|ctx
parameter_list|,
name|interface
modifier|*
name|ifp
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
modifier|*
name|mread
parameter_list|,
name|int
modifier|*
name|mstore
parameter_list|)
block|{
name|int
name|drop
init|=
literal|0
decl_stmt|;
name|drop
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|*
name|mread
operator|>
literal|0
condition|;
operator|(
operator|*
name|mread
operator|)
operator|--
control|)
block|{
union|union
block|{
name|HEADER
name|h
decl_stmt|;
name|u_char
name|buf
index|[
name|EDNS_MESSAGE_SZ
operator|+
literal|1
index|]
decl_stmt|;
block|}
name|u
union|;
name|struct
name|sockaddr_in
name|from
decl_stmt|;
name|ISC_SOCKLEN_T
name|from_len
init|=
sizeof|sizeof
name|from
decl_stmt|;
name|savedg
modifier|*
name|dg
decl_stmt|;
name|int
name|n
decl_stmt|;
name|n
operator|=
name|recvfrom
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|u
operator|.
name|buf
argument_list|,
sizeof|sizeof
name|u
operator|.
name|buf
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
operator|&
name|from_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
break|break;
comment|/* Socket buffer assumed empty. */
name|drop
operator|++
expr_stmt|;
comment|/* Pessimistic assumption. */
if|if
condition|(
name|n
operator|>
name|EDNS_MESSAGE_SZ
condition|)
continue|continue;
comment|/* Oversize message - EDNS0 needed. */
if|if
condition|(
name|from
operator|.
name|sin_family
operator|!=
name|AF_INET
condition|)
continue|continue;
comment|/* Not IPv4 - IPv6 needed. */
if|if
condition|(
name|u
operator|.
name|h
operator|.
name|opcode
operator|==
name|ns_o_query
operator|&&
name|u
operator|.
name|h
operator|.
name|qr
operator|==
literal|0
condition|)
continue|continue;
comment|/* Query - what we're here to axe. */
if|if
condition|(
operator|*
name|mstore
operator|<=
literal|0
condition|)
continue|continue;
comment|/* Reached storage quota, ignore. */
if|if
condition|(
operator|(
name|dg
operator|=
name|memget
argument_list|(
sizeof|sizeof
expr|*
name|dg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* No memory - probably fatal. */
if|if
condition|(
operator|(
name|dg
operator|->
name|buf
operator|=
name|memget
argument_list|(
name|n
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|memput
argument_list|(
name|dg
argument_list|,
sizeof|sizeof
expr|*
name|dg
argument_list|)
expr_stmt|;
continue|continue;
comment|/* No memory - probably fatal. */
block|}
name|dg
operator|->
name|from
operator|=
name|from
expr_stmt|;
name|dg
operator|->
name|dfd
operator|=
name|fd
expr_stmt|;
name|dg
operator|->
name|ifp
operator|=
name|ifp
expr_stmt|;
name|dg
operator|->
name|gen
operator|=
name|ifp
operator|->
name|gen
expr_stmt|;
name|dg
operator|->
name|buflen
operator|=
name|n
expr_stmt|;
name|memcpy
argument_list|(
name|dg
operator|->
name|buf
argument_list|,
name|u
operator|.
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|evWaitFor
argument_list|(
name|ctx
argument_list|,
operator|(
name|void
operator|*
operator|)
name|drain_all_rcvbuf
argument_list|,
name|savedg_waitfunc
argument_list|,
name|dg
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|memput
argument_list|(
name|dg
operator|->
name|buf
argument_list|,
name|dg
operator|->
name|buflen
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|dg
argument_list|,
sizeof|sizeof
expr|*
name|dg
argument_list|)
expr_stmt|;
continue|continue;
comment|/* No memory - probably fatal. */
block|}
name|drop
operator|--
expr_stmt|;
comment|/* Pessimism was inappropriate. */
operator|(
operator|*
name|mstore
operator|)
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|drop
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drain_all_rcvbuf
parameter_list|(
name|evContext
name|ctx
parameter_list|)
block|{
name|interface
modifier|*
name|ifp
decl_stmt|;
name|int
name|mread
init|=
name|MAX_SYNCDRAIN
decl_stmt|;
name|int
name|mstore
init|=
name|MAX_SYNCSTORE
decl_stmt|;
name|int
name|drop
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ifp
operator|=
name|HEAD
argument_list|(
name|iflist
argument_list|)
init|;
name|ifp
operator|!=
name|NULL
condition|;
name|ifp
operator|=
name|NEXT
argument_list|(
name|ifp
argument_list|,
name|link
argument_list|)
control|)
if|if
condition|(
name|ifp
operator|->
name|dfd
operator|!=
operator|-
literal|1
condition|)
name|drop
operator|+=
name|drain_rcvbuf
argument_list|(
name|ctx
argument_list|,
name|ifp
argument_list|,
name|ifp
operator|->
name|dfd
argument_list|,
operator|&
name|mread
argument_list|,
operator|&
name|mstore
argument_list|)
expr_stmt|;
if|if
condition|(
name|mstore
operator|<
name|MAX_SYNCSTORE
condition|)
name|INSIST_ERR
argument_list|(
name|evDo
argument_list|(
name|ctx
argument_list|,
operator|(
name|void
operator|*
operator|)
name|drain_all_rcvbuf
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|drop
operator|)
return|;
block|}
end_function

begin_comment
comment|/* opensocket_s(ifp)  *	Open stream (listener) socket bound to interface address.  * Returns:  *	0 on success.  *	-1 on failure.  */
end_comment

begin_function
specifier|static
name|int
name|opensocket_s
parameter_list|(
name|interface
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|sockaddr_in
name|nsa
decl_stmt|;
specifier|const
name|int
name|on
init|=
literal|1
decl_stmt|;
name|int
name|n
decl_stmt|;
name|memset
argument_list|(
operator|&
name|nsa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|nsa
argument_list|)
expr_stmt|;
name|nsa
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|nsa
operator|.
name|sin_addr
operator|=
name|ifp
operator|->
name|addr
expr_stmt|;
name|nsa
operator|.
name|sin_port
operator|=
name|ifp
operator|->
name|port
expr_stmt|;
comment|/* 	 * Open stream (listener) port. 	 */
name|n
operator|=
literal|0
expr_stmt|;
name|again
label|:
if|if
condition|(
operator|(
name|ifp
operator|->
name|sfd
operator|=
name|ns_socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"socket(SOCK_STREAM): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ifp
operator|->
name|sfd
operator|>
name|evHighestFD
argument_list|(
name|ev
argument_list|)
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"socket too high: %d"
argument_list|,
name|ifp
operator|->
name|sfd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ifp
operator|->
name|sfd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|ifp
operator|->
name|sfd
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"F_SETFD: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ifp
operator|->
name|sfd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|setsockopt
argument_list|(
name|ifp
operator|->
name|sfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
name|on
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"setsockopt(REUSEADDR): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Consider that your first warning of trouble to come. */
block|}
if|if
condition|(
name|bind
argument_list|(
name|ifp
operator|->
name|sfd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|nsa
argument_list|,
sizeof|sizeof
name|nsa
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EADDRINUSE
operator|||
operator|++
name|n
operator|>
literal|4
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EADDRINUSE
condition|)
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"There may be a name server already running on %s"
argument_list|,
name|sin_ntoa
argument_list|(
name|nsa
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"bind(sfd=%d, %s): %s"
argument_list|,
name|ifp
operator|->
name|sfd
argument_list|,
name|sin_ntoa
argument_list|(
name|nsa
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Retry opening the socket a few times */
name|close
argument_list|(
name|ifp
operator|->
name|sfd
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|sfd
operator|=
operator|-
literal|1
expr_stmt|;
name|sleep
argument_list|(
literal|30
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|evListen
argument_list|(
name|ev
argument_list|,
name|ifp
operator|->
name|sfd
argument_list|,
name|listenmax
argument_list|,
name|stream_accept
argument_list|,
name|ifp
argument_list|,
operator|&
name|ifp
operator|->
name|evID_s
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"evListen(sfd=%d): %s"
argument_list|,
name|ifp
operator|->
name|sfd
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ifp
operator|->
name|flags
operator||=
name|INTERFACE_CONN_VALID
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* opensocket_f()  *	Open datagram socket bound to no particular interface; use for ns_forw  *	and sysquery.  */
end_comment

begin_function
name|void
name|opensocket_f
parameter_list|()
block|{
specifier|static
name|struct
name|sockaddr_in
name|prev_qsrc
decl_stmt|;
specifier|static
name|int
name|been_here
decl_stmt|;
specifier|static
name|interface
modifier|*
name|prev_ifp
decl_stmt|;
name|struct
name|sockaddr_in
name|nsa
decl_stmt|;
specifier|const
name|int
name|on
init|=
literal|1
decl_stmt|;
name|ISC_SOCKLEN_T
name|n
decl_stmt|;
name|int
name|need_close
decl_stmt|;
name|interface
modifier|*
name|ifp
decl_stmt|;
name|need_close
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|been_here
condition|)
block|{
if|if
condition|(
name|prev_ifp
operator|!=
name|NULL
condition|)
name|prev_ifp
operator|->
name|flags
operator|&=
operator|~
name|INTERFACE_FORWARDING
expr_stmt|;
elseif|else
if|if
condition|(
name|server_options
operator|->
name|query_source
operator|.
name|sin_port
operator|==
name|htons
argument_list|(
literal|0
argument_list|)
operator|||
name|prev_qsrc
operator|.
name|sin_addr
operator|.
name|s_addr
operator|!=
name|server_options
operator|->
name|query_source
operator|.
name|sin_addr
operator|.
name|s_addr
operator|||
name|prev_qsrc
operator|.
name|sin_port
operator|!=
name|server_options
operator|->
name|query_source
operator|.
name|sin_port
condition|)
name|need_close
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|ds
operator|=
operator|-
literal|1
expr_stmt|;
name|been_here
operator|=
literal|1
expr_stmt|;
name|INSIST
argument_list|(
name|server_options
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_close
condition|)
block|{
name|evDeselectFD
argument_list|(
name|ev
argument_list|,
name|ds_evID
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ds
argument_list|)
expr_stmt|;
name|ds
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 	 * If we're already listening on the query_source address and port, 	 * we don't need to open another socket.  We mark the interface, so 	 * we'll notice we're in trouble if it goes away. 	 */
name|ifp
operator|=
name|if_find
argument_list|(
name|server_options
operator|->
name|query_source
operator|.
name|sin_addr
argument_list|,
name|server_options
operator|->
name|query_source
operator|.
name|sin_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|ifp
operator|->
name|flags
operator||=
name|INTERFACE_FORWARDING
expr_stmt|;
name|prev_ifp
operator|=
name|ifp
expr_stmt|;
name|ds
operator|=
name|ifp
operator|->
name|dfd
expr_stmt|;
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"forwarding source address is %s"
argument_list|,
name|sin_ntoa
argument_list|(
name|server_options
operator|->
name|query_source
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If we're already using the correct query source, we're done. 	 */
if|if
condition|(
name|ds
operator|>=
literal|0
condition|)
return|return;
name|prev_qsrc
operator|=
name|server_options
operator|->
name|query_source
expr_stmt|;
name|prev_ifp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|ds
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"socket(SOCK_DGRAM): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|>
name|evHighestFD
argument_list|(
name|ev
argument_list|)
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"socket too high: %d"
argument_list|,
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|ds
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"F_SETFD: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|ds
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
name|on
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"setsockopt(REUSEADDR): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX press on regardless, this is not too serious. */
block|}
ifdef|#
directive|ifdef
name|SO_BSDCOMPAT
if|if
condition|(
name|setsockopt
argument_list|(
name|ds
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_BSDCOMPAT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
name|on
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"setsockopt(BSDCOMPAT): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX press on regardless, this is not too serious. */
block|}
endif|#
directive|endif
if|if
condition|(
name|bind
argument_list|(
name|ds
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|server_options
operator|->
name|query_source
argument_list|,
sizeof|sizeof
name|server_options
operator|->
name|query_source
argument_list|)
operator|<
literal|0
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|0
argument_list|,
literal|"opensocket_f: bind(%s): %s"
argument_list|,
name|sin_ntoa
argument_list|(
name|server_options
operator|->
name|query_source
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
sizeof|sizeof
name|nsa
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|ds
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|nsa
argument_list|,
operator|&
name|n
argument_list|)
operator|<
literal|0
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"opensocket_f: getsockaddr: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"fwd ds %d addr %s"
argument_list|,
name|ds
argument_list|,
name|sin_ntoa
argument_list|(
name|nsa
argument_list|)
argument_list|)
expr_stmt|;
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"Forwarding source address is %s"
argument_list|,
name|sin_ntoa
argument_list|(
name|nsa
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|evSelectFD
argument_list|(
name|ev
argument_list|,
name|ds
argument_list|,
name|EV_READ
argument_list|,
name|datagram_read
argument_list|,
name|NULL
argument_list|,
operator|&
name|ds_evID
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"evSelectFD(fd %d): %s"
argument_list|,
name|ds
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX: should probably use a different FileFunc that only accepts 	 *	responses, since requests on this socket make no sense. 	 */
block|}
end_function

begin_function
specifier|static
name|void
name|setdebug
parameter_list|(
name|int
name|new_debug
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|int
name|old_debug
decl_stmt|;
if|if
condition|(
operator|!
name|new_debug
condition|)
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"Debug off"
argument_list|)
expr_stmt|;
name|old_debug
operator|=
name|debug
expr_stmt|;
name|debug
operator|=
name|new_debug
expr_stmt|;
name|log_option
argument_list|(
name|log_ctx
argument_list|,
name|LOG_OPTION_DEBUG
argument_list|,
name|debug
argument_list|)
expr_stmt|;
name|log_option
argument_list|(
name|log_ctx
argument_list|,
name|LOG_OPTION_LEVEL
argument_list|,
name|debug
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_debug
operator|&&
operator|!
name|debug
condition|)
name|log_close_debug_channels
argument_list|(
name|log_ctx
argument_list|)
expr_stmt|;
name|evSetDebug
argument_list|(
name|ev
argument_list|,
name|debug
argument_list|,
name|log_get_stream
argument_list|(
name|eventlib_channel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
if|if
condition|(
operator|!
name|old_debug
condition|)
name|open_special_channels
argument_list|()
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"Debug level %d"
argument_list|,
name|debug
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|old_debug
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"Version = %s"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"conffile = %s"
argument_list|,
name|conffile
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ** Routines for managing stream queue */
end_comment

begin_function
specifier|static
name|struct
name|qstream
modifier|*
name|sq_add
parameter_list|()
block|{
name|struct
name|qstream
modifier|*
name|sqp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sqp
operator|=
operator|(
expr|struct
name|qstream
operator|*
operator|)
name|memget
argument_list|(
sizeof|sizeof
expr|*
name|sqp
argument_list|)
operator|)
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"sq_add: memget: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|memset
argument_list|(
name|sqp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|sqp
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"sq_add(%#lx)"
argument_list|,
operator|(
name|u_long
operator|)
name|sqp
argument_list|)
expr_stmt|;
name|sqp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* XXX should init other fields too? */
name|sqp
operator|->
name|s_next
operator|=
name|streamq
expr_stmt|;
name|streamq
operator|=
name|sqp
expr_stmt|;
return|return
operator|(
name|sqp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* sq_remove(qp)  *	remove stream queue structure `qp'.  *	no current queries may refer to this stream when it is removed.  * side effects:  *	memory is deallocated.  sockets are closed.  lists are relinked.  */
end_comment

begin_function
name|void
name|sq_remove
parameter_list|(
name|struct
name|qstream
modifier|*
name|qp
parameter_list|)
block|{
name|struct
name|qstream
modifier|*
name|qsp
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|2
argument_list|,
literal|"sq_remove(%#lx, %d) rfcnt=%d"
argument_list|,
operator|(
name|u_long
operator|)
name|qp
argument_list|,
name|qp
operator|->
name|s_rfd
argument_list|,
name|qp
operator|->
name|s_refcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|s_wbuf
operator|!=
name|NULL
condition|)
block|{
name|memput
argument_list|(
name|qp
operator|->
name|s_wbuf
argument_list|,
name|qp
operator|->
name|s_wbuf_end
operator|-
name|qp
operator|->
name|s_wbuf
argument_list|)
expr_stmt|;
name|qp
operator|->
name|s_wbuf_send
operator|=
name|qp
operator|->
name|s_wbuf_free
operator|=
name|NULL
expr_stmt|;
name|qp
operator|->
name|s_wbuf_end
operator|=
name|qp
operator|->
name|s_wbuf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|qp
operator|->
name|flags
operator|&
name|STREAM_MALLOC
condition|)
name|memput
argument_list|(
name|qp
operator|->
name|s_buf
argument_list|,
name|qp
operator|->
name|s_bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|flags
operator|&
name|STREAM_READ_EV
condition|)
name|INSIST_ERR
argument_list|(
name|evCancelRW
argument_list|(
name|ev
argument_list|,
name|qp
operator|->
name|evID_r
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|flags
operator|&
name|STREAM_WRITE_EV
condition|)
name|INSIST_ERR
argument_list|(
name|evDeselectFD
argument_list|(
name|ev
argument_list|,
name|qp
operator|->
name|evID_w
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|flags
operator|&
name|STREAM_CONNECT_EV
condition|)
name|INSIST_ERR
argument_list|(
name|evCancelConn
argument_list|(
name|ev
argument_list|,
name|qp
operator|->
name|evID_c
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|flags
operator|&
name|STREAM_AXFR
operator|||
name|qp
operator|->
name|flags
operator|&
name|STREAM_AXFRIXFR
condition|)
name|ns_freexfr
argument_list|(
name|qp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|qp
operator|->
name|s_rfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|==
name|streamq
condition|)
name|streamq
operator|=
name|qp
operator|->
name|s_next
expr_stmt|;
else|else
block|{
for|for
control|(
name|qsp
operator|=
name|streamq
init|;
name|qsp
operator|&&
operator|(
name|qsp
operator|->
name|s_next
operator|!=
name|qp
operator|)
condition|;
name|qsp
operator|=
name|qsp
operator|->
name|s_next
control|)
operator|(
name|void
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|qsp
condition|)
name|qsp
operator|->
name|s_next
operator|=
name|qp
operator|->
name|s_next
expr_stmt|;
block|}
name|memput
argument_list|(
name|qp
argument_list|,
sizeof|sizeof
expr|*
name|qp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* void  * sq_flush(allbut)  *	call sq_remove() on all open streams except `allbut'  * side effects:  *	global list `streamq' modified  * idiocy:  *	is N^2 due to the scan inside of sq_remove()  */
end_comment

begin_function
name|void
name|sq_flush
parameter_list|(
name|struct
name|qstream
modifier|*
name|allbut
parameter_list|)
block|{
name|struct
name|qstream
modifier|*
name|sp
decl_stmt|,
modifier|*
name|spnext
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|streamq
init|;
name|sp
operator|!=
name|NULL
condition|;
name|sp
operator|=
name|spnext
control|)
block|{
name|spnext
operator|=
name|sp
operator|->
name|s_next
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
name|allbut
condition|)
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* int  * sq_openw(qs, buflen)  *	add a write buffer to a stream  * return:  *	0 = success  *	-1 = failure (check errno)  */
end_comment

begin_function
name|int
name|sq_openw
parameter_list|(
name|struct
name|qstream
modifier|*
name|qs
parameter_list|,
name|int
name|buflen
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DO_SO_LINGER
comment|/* XXX */
specifier|static
specifier|const
name|struct
name|linger
name|ll
init|=
block|{
literal|1
block|,
literal|120
block|}
decl_stmt|;
endif|#
directive|endif
name|INSIST
argument_list|(
name|qs
operator|->
name|s_wbuf
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|qs
operator|->
name|s_wbuf
operator|=
operator|(
name|u_char
operator|*
operator|)
name|memget
argument_list|(
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|qs
operator|->
name|s_wbuf
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|qs
operator|->
name|s_wbuf_send
operator|=
name|qs
operator|->
name|s_wbuf
expr_stmt|;
name|qs
operator|->
name|s_wbuf_free
operator|=
name|qs
operator|->
name|s_wbuf
expr_stmt|;
name|qs
operator|->
name|s_wbuf_end
operator|=
name|qs
operator|->
name|s_wbuf
operator|+
name|buflen
expr_stmt|;
ifdef|#
directive|ifdef
name|DO_SO_LINGER
comment|/* XXX */
comment|/* kernels that map pages for IO end up failing if the pipe is full 	 * at exit and we take away the final buffer.  this is really a kernel 	 * bug but it's harmless on systems that are not broken, so... 	 */
name|setsockopt
argument_list|(
name|qs
operator|->
name|s_rfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_LINGER
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ll
argument_list|,
sizeof|sizeof
name|ll
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* static void  * sq_dowrite(qs)  *	try to submit data to the system, remove it from our queue.  */
end_comment

begin_function
specifier|static
name|int
name|sq_dowrite
parameter_list|(
name|struct
name|qstream
modifier|*
name|qs
parameter_list|)
block|{
if|if
condition|(
name|qs
operator|->
name|s_wbuf_free
operator|>
name|qs
operator|->
name|s_wbuf_send
condition|)
block|{
name|int
name|n
init|=
name|write
argument_list|(
name|qs
operator|->
name|s_rfd
argument_list|,
name|qs
operator|->
name|s_wbuf_send
argument_list|,
name|qs
operator|->
name|s_wbuf_free
operator|-
name|qs
operator|->
name|s_wbuf_send
argument_list|)
decl_stmt|;
name|INSIST
argument_list|(
name|qs
operator|->
name|s_wbuf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
operator|&&
name|errno
operator|!=
name|EAGAIN
if|#
directive|if
operator|(
name|EWOULDBLOCK
operator|!=
name|EAGAIN
operator|)
operator|&&
name|errno
operator|!=
name|EWOULDBLOCK
endif|#
directive|endif
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|qs
operator|->
name|s_wbuf_send
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|qs
operator|->
name|s_wbuf_free
operator|>
name|qs
operator|->
name|s_wbuf_send
condition|)
block|{
comment|/* XXX: need some kind of delay here during which the 			 *	socket will be deselected so we don't spin. 			 */
name|n
operator|=
name|qs
operator|->
name|s_wbuf_free
operator|-
name|qs
operator|->
name|s_wbuf_send
expr_stmt|;
name|memmove
argument_list|(
name|qs
operator|->
name|s_wbuf
argument_list|,
name|qs
operator|->
name|s_wbuf_send
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|qs
operator|->
name|s_wbuf_send
operator|=
name|qs
operator|->
name|s_wbuf
expr_stmt|;
name|qs
operator|->
name|s_wbuf_free
operator|=
name|qs
operator|->
name|s_wbuf
operator|+
name|n
expr_stmt|;
block|}
block|}
if|if
condition|(
name|qs
operator|->
name|s_wbuf_free
operator|==
name|qs
operator|->
name|s_wbuf_send
condition|)
name|qs
operator|->
name|s_wbuf_free
operator|=
name|qs
operator|->
name|s_wbuf_send
operator|=
name|qs
operator|->
name|s_wbuf
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* void  * sq_flushw(qs)  *	called when the socket becomes writable and we want to flush our  *	buffers and the system's socket buffers.  use as a closure with  *	sq_writeh().  */
end_comment

begin_function
name|void
name|sq_flushw
parameter_list|(
name|struct
name|qstream
modifier|*
name|qs
parameter_list|)
block|{
if|if
condition|(
name|qs
operator|->
name|s_wbuf_free
operator|==
name|qs
operator|->
name|s_wbuf_send
condition|)
block|{
name|sq_writeh
argument_list|(
name|qs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sq_done
argument_list|(
name|qs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* static void  * sq_writable(ctx, uap, fd, evmask)  *	glue between eventlib closures and qstream closures  */
end_comment

begin_function
specifier|static
name|void
name|sq_writable
parameter_list|(
name|evContext
name|ctx
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|evmask
parameter_list|)
block|{
name|struct
name|qstream
modifier|*
name|qs
init|=
name|uap
decl_stmt|;
name|UNUSED
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|evmask
operator|&
name|EV_WRITE
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|fd
operator|==
name|qs
operator|->
name|s_rfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sq_dowrite
argument_list|(
name|qs
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sq_remove
argument_list|(
name|qs
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|qs
operator|->
name|s_wbuf_closure
operator|&&
name|qs
operator|->
name|s_wbuf_end
operator|-
name|qs
operator|->
name|s_wbuf_free
operator|>=
name|HFIXEDSZ
operator|+
literal|2
condition|)
comment|/* XXX guess */
call|(
modifier|*
name|qs
operator|->
name|s_wbuf_closure
call|)
argument_list|(
name|qs
argument_list|)
expr_stmt|;
if|if
condition|(
name|sq_dowrite
argument_list|(
name|qs
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sq_remove
argument_list|(
name|qs
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* int  * sq_writeh(qs, closure)  *	register a closure to be called when a stream becomes writable  * return:  *	0 = success  *	-1 = failure (check errno)  */
end_comment

begin_function
name|int
name|sq_writeh
parameter_list|(
name|struct
name|qstream
modifier|*
name|qs
parameter_list|,
name|sq_closure
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
condition|)
block|{
if|if
condition|(
operator|!
name|qs
operator|->
name|s_wbuf_closure
condition|)
block|{
if|if
condition|(
name|evSelectFD
argument_list|(
name|ev
argument_list|,
name|qs
operator|->
name|s_rfd
argument_list|,
name|EV_WRITE
argument_list|,
name|sq_writable
argument_list|,
name|qs
argument_list|,
operator|&
name|qs
operator|->
name|evID_w
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|qs
operator|->
name|flags
operator||=
name|STREAM_WRITE_EV
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|evDeselectFD
argument_list|(
name|ev
argument_list|,
name|qs
operator|->
name|evID_w
argument_list|)
expr_stmt|;
name|qs
operator|->
name|flags
operator|&=
operator|~
name|STREAM_WRITE_EV
expr_stmt|;
block|}
name|qs
operator|->
name|s_wbuf_closure
operator|=
name|c
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* int  * sq_write(qs, buf, len)  *	queue a message onto the stream, prepended by a two byte length field  * return:  *	0 = success  *	-1 = failure (check errno; E2BIG means we can't handle this right now)  */
end_comment

begin_function
name|int
name|sq_write
parameter_list|(
name|struct
name|qstream
modifier|*
name|qs
parameter_list|,
specifier|const
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|INSIST
argument_list|(
name|qs
operator|->
name|s_wbuf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|NS_INT16SZ
operator|+
name|len
operator|>
name|qs
operator|->
name|s_wbuf_end
operator|-
name|qs
operator|->
name|s_wbuf_free
condition|)
block|{
if|if
condition|(
name|sq_dowrite
argument_list|(
name|qs
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|NS_INT16SZ
operator|+
name|len
operator|>
name|qs
operator|->
name|s_wbuf_end
operator|-
name|qs
operator|->
name|s_wbuf_free
condition|)
block|{
name|errno
operator|=
name|E2BIG
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|__putshort
argument_list|(
name|len
argument_list|,
name|qs
operator|->
name|s_wbuf_free
argument_list|)
expr_stmt|;
name|qs
operator|->
name|s_wbuf_free
operator|+=
name|NS_INT16SZ
expr_stmt|;
name|memcpy
argument_list|(
name|qs
operator|->
name|s_wbuf_free
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|qs
operator|->
name|s_wbuf_free
operator|+=
name|len
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initiate query on stream;  * mark as referenced and stop selecting for input.  */
end_comment

begin_function
specifier|static
name|void
name|sq_query
parameter_list|(
name|struct
name|qstream
modifier|*
name|sp
parameter_list|)
block|{
name|sp
operator|->
name|s_refcnt
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Note that the current request on a stream has completed,  * and that we should continue looking for requests on the stream.  */
end_comment

begin_function
name|void
name|sq_done
parameter_list|(
name|struct
name|qstream
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|iovec
name|iov
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_wbuf
operator|!=
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|sp
operator|->
name|s_wbuf_send
operator|==
name|sp
operator|->
name|s_wbuf_free
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|sp
operator|->
name|s_wbuf
argument_list|,
name|sp
operator|->
name|s_wbuf_end
operator|-
name|sp
operator|->
name|s_wbuf
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_wbuf_send
operator|=
name|sp
operator|->
name|s_wbuf_free
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|s_wbuf_end
operator|=
name|sp
operator|->
name|s_wbuf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|flags
operator|&
name|STREAM_AXFR
operator|||
name|sp
operator|->
name|flags
operator|&
name|STREAM_AXFRIXFR
condition|)
name|ns_freexfr
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_refcnt
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|s_time
operator|=
name|tt
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|flags
operator|&
name|STREAM_DONE_CLOSE
condition|)
block|{
comment|/* XXX */
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
name|iov
operator|=
name|evConsIovec
argument_list|(
name|sp
operator|->
name|s_temp
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|evRead
argument_list|(
name|ev
argument_list|,
name|sp
operator|->
name|s_rfd
argument_list|,
operator|&
name|iov
argument_list|,
literal|1
argument_list|,
name|stream_getlen
argument_list|,
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|evID_r
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"evRead(fd %d): %s"
argument_list|,
name|sp
operator|->
name|s_rfd
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|flags
operator||=
name|STREAM_READ_EV
expr_stmt|;
block|}
end_function

begin_comment
comment|/* void  * dq_remove_gen(gen)  *	close/deallocate all the udp sockets (except 0.0.0.0) which are  *	not from the current generation.  * side effects:  *	global list `iflist' is modified.  */
end_comment

begin_function
name|void
name|dq_remove_gen
parameter_list|(
name|time_t
name|gen
parameter_list|)
block|{
name|interface
modifier|*
name|this
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|this
operator|=
name|HEAD
argument_list|(
name|iflist
argument_list|)
init|;
name|this
operator|!=
name|NULL
condition|;
name|this
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT
argument_list|(
name|this
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|->
name|gen
operator|!=
name|gen
operator|&&
name|ina_hlong
argument_list|(
name|this
operator|->
name|addr
argument_list|)
operator|!=
name|INADDR_ANY
condition|)
name|dq_remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* void  * dq_remove_all()  *	close/deallocate all interfaces.  * side effects:  *	global list `iflist' is modified.  */
end_comment

begin_function
name|void
name|dq_remove_all
parameter_list|()
block|{
name|interface
modifier|*
name|this
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|this
operator|=
name|HEAD
argument_list|(
name|iflist
argument_list|)
init|;
name|this
operator|!=
name|NULL
condition|;
name|this
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT
argument_list|(
name|this
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/*  		 * Clear the forwarding flag so we don't panic the server. 		 */
name|this
operator|->
name|flags
operator|&=
operator|~
name|INTERFACE_FORWARDING
expr_stmt|;
name|dq_remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* void  * dq_remove(interface *this)  *	close/deallocate an interface's sockets.  called on errors  *	or if the interface disappears.  * side effects:  *	global list `iflist' is modified.  */
end_comment

begin_function
specifier|static
name|void
name|dq_remove
parameter_list|(
name|interface
modifier|*
name|this
parameter_list|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"deleting interface [%s].%u"
argument_list|,
name|inet_ntoa
argument_list|(
name|this
operator|->
name|addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|this
operator|->
name|port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|this
operator|->
name|flags
operator|&
name|INTERFACE_FORWARDING
operator|)
operator|!=
literal|0
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|0
argument_list|,
literal|"forwarding interface [%s].%u gone"
argument_list|,
name|inet_ntoa
argument_list|(
name|this
operator|->
name|addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|this
operator|->
name|port
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Deallocate fields. */
if|if
condition|(
operator|(
name|this
operator|->
name|flags
operator|&
name|INTERFACE_FILE_VALID
operator|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|evDeselectFD
argument_list|(
name|ev
argument_list|,
name|this
operator|->
name|evID_d
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|->
name|dfd
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|this
operator|->
name|dfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|this
operator|->
name|flags
operator|&
name|INTERFACE_CONN_VALID
operator|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|evCancelConn
argument_list|(
name|ev
argument_list|,
name|this
operator|->
name|evID_s
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|->
name|sfd
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|this
operator|->
name|sfd
argument_list|)
expr_stmt|;
name|UNLINK
argument_list|(
name|iflist
argument_list|,
name|this
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|this
argument_list|,
sizeof|sizeof
expr|*
name|this
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* struct in_addr  * net_mask(ina)  *	makes a classful assumption in a classless world, and returns it.  */
end_comment

begin_function
name|struct
name|in_addr
name|net_mask
parameter_list|(
name|struct
name|in_addr
name|ina
parameter_list|)
block|{
name|u_long
name|hl
init|=
name|ina_hlong
argument_list|(
name|ina
argument_list|)
decl_stmt|;
name|struct
name|in_addr
name|ret
decl_stmt|;
if|if
condition|(
name|IN_CLASSA
argument_list|(
name|hl
argument_list|)
condition|)
name|hl
operator|=
name|IN_CLASSA_NET
expr_stmt|;
elseif|else
if|if
condition|(
name|IN_CLASSB
argument_list|(
name|hl
argument_list|)
condition|)
name|hl
operator|=
name|IN_CLASSB_NET
expr_stmt|;
elseif|else
if|if
condition|(
name|IN_CLASSC
argument_list|(
name|hl
argument_list|)
condition|)
name|hl
operator|=
name|IN_CLASSC_NET
expr_stmt|;
else|else
name|hl
operator|=
name|INADDR_BROADCAST
expr_stmt|;
name|ina_ulong
argument_list|(
name|ret
argument_list|)
operator|=
name|htonl
argument_list|(
name|hl
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* aIsUs(addr)  *	scan our list of interface addresses for "addr".  * returns:  *	0: address isn't one of our interfaces  *>0: address is one of our interfaces, or INADDR_ANY  */
end_comment

begin_function
name|int
name|aIsUs
parameter_list|(
name|struct
name|in_addr
name|addr
parameter_list|)
block|{
if|if
condition|(
name|ina_hlong
argument_list|(
name|addr
argument_list|)
operator|==
name|INADDR_ANY
operator|||
name|if_find
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* interface *  * if_find(addr, port)  *	scan our list of interface addresses for "addr" and port.  *      port == 0 means match any port  * returns:  *	pointer to interface with this address/port, or NULL if there isn't  *      one.  */
end_comment

begin_function
specifier|static
name|interface
modifier|*
name|if_find
parameter_list|(
name|struct
name|in_addr
name|addr
parameter_list|,
name|u_int16_t
name|port
parameter_list|)
block|{
name|interface
modifier|*
name|ifp
decl_stmt|;
for|for
control|(
name|ifp
operator|=
name|HEAD
argument_list|(
name|iflist
argument_list|)
init|;
name|ifp
operator|!=
name|NULL
condition|;
name|ifp
operator|=
name|NEXT
argument_list|(
name|ifp
argument_list|,
name|link
argument_list|)
control|)
if|if
condition|(
name|ina_equal
argument_list|(
name|addr
argument_list|,
name|ifp
operator|->
name|addr
argument_list|)
condition|)
if|if
condition|(
name|port
operator|==
literal|0
operator|||
name|ifp
operator|->
name|port
operator|==
name|port
condition|)
break|break;
return|return
operator|(
name|ifp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * These are here in case we ever want to get more clever, like perhaps  * using a bitmap to keep track of outstanding queries and a random  * allocation scheme to make it a little harder to predict them.  Note  * that the resolver will need the same protection so the cleverness  * should be put there rather than here; this is just an interface layer.  *  * This is true but ... most clients only send out a few queries, they  * use varying port numbers, and the queries aren't sent to the outside  * world which we know is full of spoofers.  Doing a good job of randomizing  * ids may also be to expensive for each client. Queries forwarded by the  * server always come from the same port (unless you let 8.x pick a port  * and restart it periodically - maybe it should open several and use  * them randomly).  The server sends out lots more queries, and if it's  * cache is corrupted, it has the potential to affect more clients.  * NOTE: - randomizing the ID or source port doesn't help a bit if the  * queries can be sniffed.  *                             -- DL  */
end_comment

begin_comment
comment|/*  * Allow the user to pick one of two ID randomization algorithms.  *  * The first algorithm is an adaptation of the sequence shuffling  * algorithm discovered by Carter Bays and S. D. Durham [ACM Trans. Math.  * Software 2 (1976), 59-64], as documented as Algorithm B in Chapter  * 3.2.2 in Volume 2 of Knuth's "The Art of Computer Programming".  We use  * a randomly selected linear congruential random number generator with a  * modulus of 2^16, whose increment is a randomly picked odd number, and  * whose multiplier is picked from a set which meets the following  * criteria:  *     Is of the form 8*n+5, which ensures "high potency" according to  *     principle iii in the summary chapter 3.6.  This form also has a  *     gcd(a-1,m) of 4 which is good according to principle iv.  *  *     Is between 0.01 and 0.99 times the modulus as specified by  *     principle iv.  *  *     Passes the spectral test "with flying colors" (ut>= 1) in  *     dimensions 2 through 6 as calculated by Algorithm S in Chapter  *     3.3.4 and the ratings calculated by formula 35 in section E.  *  *     Of the multipliers that pass this test, pick the set that is  *     best according to the theoretical bounds of the serial  *     correlation test.  This was calculated using a simplified  *     version of Knuth's Theorem K in Chapter 3.3.3.  *  * These criteria may not be important for this use, but we might as well  * pick from the best generators since there are so many possible ones and  * we don't have that many random bits to do the picking.  *  * We use a modulus of 2^16 instead of something bigger so that we will  * tend to cycle through all the possible IDs before repeating any,  * however the shuffling will perturb this somewhat.  Theoretically there  * is no minimimum interval between two uses of the same ID, but in  * practice it seems to be>64000.  *  * Our adaptatation  of Algorithm B mixes the hash state which has  * captured various random events into the shuffler to perturb the  * sequence.  *  * One disadvantage of this algorithm is that if the generator parameters  * were to be guessed, it would be possible to mount a limited brute force  * attack on the ID space since the IDs are only shuffled within a limited  * range.  *  * The second algorithm uses the same random number generator to populate  * a pool of 65536 IDs.  The hash state is used to pick an ID from a window  * of 4096 IDs in this pool, then the chosen ID is swapped with the ID  * at the beginning of the window and the window position is advanced.  * This means that the interval between uses of the ID will be no less  * than 65536-4096.  The ID sequence in the pool will become more random  * over time.  *  * For both algorithms, two more linear congruential random number generators  * are selected.  The ID from the first part of algorithm is used to seed  * the first of these generators, and its output is used to seed the second.  * The strategy is use these generators as 1 to 1 hashes to obfuscate the  * properties of the generator used in the first part of either algorithm.  *  * The first algorithm may be suitable for use in a client resolver since  * its memory requirements are fairly low and it's pretty random out of  * the box.  It is somewhat succeptible to a limited brute force attack,  * so the second algorithm is probably preferable for a longer running  * program that issues a large number of queries and has time to randomize  * the pool.  */
end_comment

begin_define
define|#
directive|define
name|NSID_SHUFFLE_TABLE_SIZE
value|100
end_define

begin_comment
comment|/* Suggested by Knuth */
end_comment

begin_comment
comment|/*  * Pick one of the next 4096 IDs in the pool.  * There is a tradeoff here between randomness and how often and ID is reused.  */
end_comment

begin_define
define|#
directive|define
name|NSID_LOOKAHEAD
value|4096
end_define

begin_comment
comment|/* Must be a power of 2 */
end_comment

begin_define
define|#
directive|define
name|NSID_SHUFFLE_ONLY
value|1
end_define

begin_comment
comment|/* algorithm 1 */
end_comment

begin_define
define|#
directive|define
name|NSID_USE_POOL
value|2
end_define

begin_comment
comment|/* algorithm 2 */
end_comment

begin_comment
comment|/*  * Keep a running hash of various bits of data that we'll use to  * stir the ID pool or perturb the ID generator  */
end_comment

begin_function
name|void
name|nsid_hash
parameter_list|(
name|u_char
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
comment|/* 	 * Hash function similar to the one we use for hashing names. 	 * We don't fold case or toss the upper bit here, though. 	 * This hash doesn't do much interesting when fed binary zeros, 	 * so there may be a better hash function. 	 * This function doesn't need to be very strong since we're 	 * only using it to stir the pool, but it should be reasonably 	 * fast. 	 */
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|nsid_hash_state
operator|=
name|HASHROTATE
argument_list|(
name|nsid_hash_state
argument_list|)
expr_stmt|;
name|nsid_hash_state
operator|+=
operator|*
name|data
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Table of good linear congruential multipliers for modulus 2^16  * in order of increasing serial correlation bounds (so trim from  * the end).  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u_int16_t
name|nsid_multiplier_table
index|[]
init|=
block|{
literal|17565
block|,
literal|25013
block|,
literal|11733
block|,
literal|19877
block|,
literal|23989
block|,
literal|23997
block|,
literal|24997
block|,
literal|25421
block|,
literal|26781
block|,
literal|27413
block|,
literal|35901
block|,
literal|35917
block|,
literal|35973
block|,
literal|36229
block|,
literal|38317
block|,
literal|38437
block|,
literal|39941
block|,
literal|40493
block|,
literal|41853
block|,
literal|46317
block|,
literal|50581
block|,
literal|51429
block|,
literal|53453
block|,
literal|53805
block|,
literal|11317
block|,
literal|11789
block|,
literal|12045
block|,
literal|12413
block|,
literal|14277
block|,
literal|14821
block|,
literal|14917
block|,
literal|18989
block|,
literal|19821
block|,
literal|23005
block|,
literal|23533
block|,
literal|23573
block|,
literal|23693
block|,
literal|27549
block|,
literal|27709
block|,
literal|28461
block|,
literal|29365
block|,
literal|35605
block|,
literal|37693
block|,
literal|37757
block|,
literal|38309
block|,
literal|41285
block|,
literal|45261
block|,
literal|47061
block|,
literal|47269
block|,
literal|48133
block|,
literal|48597
block|,
literal|50277
block|,
literal|50717
block|,
literal|50757
block|,
literal|50805
block|,
literal|51341
block|,
literal|51413
block|,
literal|51581
block|,
literal|51597
block|,
literal|53445
block|,
literal|11493
block|,
literal|14229
block|,
literal|20365
block|,
literal|20653
block|,
literal|23485
block|,
literal|25541
block|,
literal|27429
block|,
literal|29421
block|,
literal|30173
block|,
literal|35445
block|,
literal|35653
block|,
literal|36789
block|,
literal|36797
block|,
literal|37109
block|,
literal|37157
block|,
literal|37669
block|,
literal|38661
block|,
literal|39773
block|,
literal|40397
block|,
literal|41837
block|,
literal|41877
block|,
literal|45293
block|,
literal|47277
block|,
literal|47845
block|,
literal|49853
block|,
literal|51085
block|,
literal|51349
block|,
literal|54085
block|,
literal|56933
block|,
literal|8877
block|,
literal|8973
block|,
literal|9885
block|,
literal|11365
block|,
literal|11813
block|,
literal|13581
block|,
literal|13589
block|,
literal|13613
block|,
literal|14109
block|,
literal|14317
block|,
literal|15765
block|,
literal|15789
block|,
literal|16925
block|,
literal|17069
block|,
literal|17205
block|,
literal|17621
block|,
literal|17941
block|,
literal|19077
block|,
literal|19381
block|,
literal|20245
block|,
literal|22845
block|,
literal|23733
block|,
literal|24869
block|,
literal|25453
block|,
literal|27213
block|,
literal|28381
block|,
literal|28965
block|,
literal|29245
block|,
literal|29997
block|,
literal|30733
block|,
literal|30901
block|,
literal|34877
block|,
literal|35485
block|,
literal|35613
block|,
literal|36133
block|,
literal|36661
block|,
literal|36917
block|,
literal|38597
block|,
literal|40285
block|,
literal|40693
block|,
literal|41413
block|,
literal|41541
block|,
literal|41637
block|,
literal|42053
block|,
literal|42349
block|,
literal|45245
block|,
literal|45469
block|,
literal|46493
block|,
literal|48205
block|,
literal|48613
block|,
literal|50861
block|,
literal|51861
block|,
literal|52877
block|,
literal|53933
block|,
literal|54397
block|,
literal|55669
block|,
literal|56453
block|,
literal|56965
block|,
literal|58021
block|,
literal|7757
block|,
literal|7781
block|,
literal|8333
block|,
literal|9661
block|,
literal|12229
block|,
literal|14373
block|,
literal|14453
block|,
literal|17549
block|,
literal|18141
block|,
literal|19085
block|,
literal|20773
block|,
literal|23701
block|,
literal|24205
block|,
literal|24333
block|,
literal|25261
block|,
literal|25317
block|,
literal|27181
block|,
literal|30117
block|,
literal|30477
block|,
literal|34757
block|,
literal|34885
block|,
literal|35565
block|,
literal|35885
block|,
literal|36541
block|,
literal|37957
block|,
literal|39733
block|,
literal|39813
block|,
literal|41157
block|,
literal|41893
block|,
literal|42317
block|,
literal|46621
block|,
literal|48117
block|,
literal|48181
block|,
literal|49525
block|,
literal|55261
block|,
literal|55389
block|,
literal|56845
block|,
literal|7045
block|,
literal|7749
block|,
literal|7965
block|,
literal|8469
block|,
literal|9133
block|,
literal|9549
block|,
literal|9789
block|,
literal|10173
block|,
literal|11181
block|,
literal|11285
block|,
literal|12253
block|,
literal|13453
block|,
literal|13533
block|,
literal|13757
block|,
literal|14477
block|,
literal|15053
block|,
literal|16901
block|,
literal|17213
block|,
literal|17269
block|,
literal|17525
block|,
literal|17629
block|,
literal|18605
block|,
literal|19013
block|,
literal|19829
block|,
literal|19933
block|,
literal|20069
block|,
literal|20093
block|,
literal|23261
block|,
literal|23333
block|,
literal|24949
block|,
literal|25309
block|,
literal|27613
block|,
literal|28453
block|,
literal|28709
block|,
literal|29301
block|,
literal|29541
block|,
literal|34165
block|,
literal|34413
block|,
literal|37301
block|,
literal|37773
block|,
literal|38045
block|,
literal|38405
block|,
literal|41077
block|,
literal|41781
block|,
literal|41925
block|,
literal|42717
block|,
literal|44437
block|,
literal|44525
block|,
literal|44613
block|,
literal|45933
block|,
literal|45941
block|,
literal|47077
block|,
literal|50077
block|,
literal|50893
block|,
literal|52117
block|,
literal|5293
block|,
literal|55069
block|,
literal|55989
block|,
literal|58125
block|,
literal|59205
block|,
literal|6869
block|,
literal|14685
block|,
literal|15453
block|,
literal|16821
block|,
literal|17045
block|,
literal|17613
block|,
literal|18437
block|,
literal|21029
block|,
literal|22773
block|,
literal|22909
block|,
literal|25445
block|,
literal|25757
block|,
literal|26541
block|,
literal|30709
block|,
literal|30909
block|,
literal|31093
block|,
literal|31149
block|,
literal|37069
block|,
literal|37725
block|,
literal|37925
block|,
literal|38949
block|,
literal|39637
block|,
literal|39701
block|,
literal|40765
block|,
literal|40861
block|,
literal|42965
block|,
literal|44813
block|,
literal|45077
block|,
literal|45733
block|,
literal|47045
block|,
literal|50093
block|,
literal|52861
block|,
literal|52957
block|,
literal|54181
block|,
literal|56325
block|,
literal|56365
block|,
literal|56381
block|,
literal|56877
block|,
literal|57013
block|,
literal|5741
block|,
literal|58101
block|,
literal|58669
block|,
literal|8613
block|,
literal|10045
block|,
literal|10261
block|,
literal|10653
block|,
literal|10733
block|,
literal|11461
block|,
literal|12261
block|,
literal|14069
block|,
literal|15877
block|,
literal|17757
block|,
literal|21165
block|,
literal|23885
block|,
literal|24701
block|,
literal|26429
block|,
literal|26645
block|,
literal|27925
block|,
literal|28765
block|,
literal|29197
block|,
literal|30189
block|,
literal|31293
block|,
literal|39781
block|,
literal|39909
block|,
literal|40365
block|,
literal|41229
block|,
literal|41453
block|,
literal|41653
block|,
literal|42165
block|,
literal|42365
block|,
literal|47421
block|,
literal|48029
block|,
literal|48085
block|,
literal|52773
block|,
literal|5573
block|,
literal|57037
block|,
literal|57637
block|,
literal|58341
block|,
literal|58357
block|,
literal|58901
block|,
literal|6357
block|,
literal|7789
block|,
literal|9093
block|,
literal|10125
block|,
literal|10709
block|,
literal|10765
block|,
literal|11957
block|,
literal|12469
block|,
literal|13437
block|,
literal|13509
block|,
literal|14773
block|,
literal|15437
block|,
literal|15773
block|,
literal|17813
block|,
literal|18829
block|,
literal|19565
block|,
literal|20237
block|,
literal|23461
block|,
literal|23685
block|,
literal|23725
block|,
literal|23941
block|,
literal|24877
block|,
literal|25461
block|,
literal|26405
block|,
literal|29509
block|,
literal|30285
block|,
literal|35181
block|,
literal|37229
block|,
literal|37893
block|,
literal|38565
block|,
literal|40293
block|,
literal|44189
block|,
literal|44581
block|,
literal|45701
block|,
literal|47381
block|,
literal|47589
block|,
literal|48557
block|,
literal|4941
block|,
literal|51069
block|,
literal|5165
block|,
literal|52797
block|,
literal|53149
block|,
literal|5341
block|,
literal|56301
block|,
literal|56765
block|,
literal|58581
block|,
literal|59493
block|,
literal|59677
block|,
literal|6085
block|,
literal|6349
block|,
literal|8293
block|,
literal|8501
block|,
literal|8517
block|,
literal|11597
block|,
literal|11709
block|,
literal|12589
block|,
literal|12693
block|,
literal|13517
block|,
literal|14909
block|,
literal|17397
block|,
literal|18085
block|,
literal|21101
block|,
literal|21269
block|,
literal|22717
block|,
literal|25237
block|,
literal|25661
block|,
literal|29189
block|,
literal|30101
block|,
literal|31397
block|,
literal|33933
block|,
literal|34213
block|,
literal|34661
block|,
literal|35533
block|,
literal|36493
block|,
literal|37309
block|,
literal|40037
block|,
literal|4189
block|,
literal|42909
block|,
literal|44309
block|,
literal|44357
block|,
literal|44389
block|,
literal|4541
block|,
literal|45461
block|,
literal|46445
block|,
literal|48237
block|,
literal|54149
block|,
literal|55301
block|,
literal|55853
block|,
literal|56621
block|,
literal|56717
block|,
literal|56901
block|,
literal|5813
block|,
literal|58437
block|,
literal|12493
block|,
literal|15365
block|,
literal|15989
block|,
literal|17829
block|,
literal|18229
block|,
literal|19341
block|,
literal|21013
block|,
literal|21357
block|,
literal|22925
block|,
literal|24885
block|,
literal|26053
block|,
literal|27581
block|,
literal|28221
block|,
literal|28485
block|,
literal|30605
block|,
literal|30613
block|,
literal|30789
block|,
literal|35437
block|,
literal|36285
block|,
literal|37189
block|,
literal|3941
block|,
literal|41797
block|,
literal|4269
block|,
literal|42901
block|,
literal|43293
block|,
literal|44645
block|,
literal|45221
block|,
literal|46893
block|,
literal|4893
block|,
literal|50301
block|,
literal|50325
block|,
literal|5189
block|,
literal|52109
block|,
literal|53517
block|,
literal|54053
block|,
literal|54485
block|,
literal|5525
block|,
literal|55949
block|,
literal|56973
block|,
literal|59069
block|,
literal|59421
block|,
literal|60733
block|,
literal|61253
block|,
literal|6421
block|,
literal|6701
block|,
literal|6709
block|,
literal|7101
block|,
literal|8669
block|,
literal|15797
block|,
literal|19221
block|,
literal|19837
block|,
literal|20133
block|,
literal|20957
block|,
literal|21293
block|,
literal|21461
block|,
literal|22461
block|,
literal|29085
block|,
literal|29861
block|,
literal|30869
block|,
literal|34973
block|,
literal|36469
block|,
literal|37565
block|,
literal|38125
block|,
literal|38829
block|,
literal|39469
block|,
literal|40061
block|,
literal|40117
block|,
literal|44093
block|,
literal|47429
block|,
literal|48341
block|,
literal|50597
block|,
literal|51757
block|,
literal|5541
block|,
literal|57629
block|,
literal|58405
block|,
literal|59621
block|,
literal|59693
block|,
literal|59701
block|,
literal|61837
block|,
literal|7061
block|,
literal|10421
block|,
literal|11949
block|,
literal|15405
block|,
literal|20861
block|,
literal|25397
block|,
literal|25509
block|,
literal|25893
block|,
literal|26037
block|,
literal|28629
block|,
literal|28869
block|,
literal|29605
block|,
literal|30213
block|,
literal|34205
block|,
literal|35637
block|,
literal|36365
block|,
literal|37285
block|,
literal|3773
block|,
literal|39117
block|,
literal|4021
block|,
literal|41061
block|,
literal|42653
block|,
literal|44509
block|,
literal|4461
block|,
literal|44829
block|,
literal|4725
block|,
literal|5125
block|,
literal|52269
block|,
literal|56469
block|,
literal|59085
block|,
literal|5917
block|,
literal|60973
block|,
literal|8349
block|,
literal|17725
block|,
literal|18637
block|,
literal|19773
block|,
literal|20293
block|,
literal|21453
block|,
literal|22533
block|,
literal|24285
block|,
literal|26333
block|,
literal|26997
block|,
literal|31501
block|,
literal|34541
block|,
literal|34805
block|,
literal|37509
block|,
literal|38477
block|,
literal|41333
block|,
literal|44125
block|,
literal|46285
block|,
literal|46997
block|,
literal|47637
block|,
literal|48173
block|,
literal|4925
block|,
literal|50253
block|,
literal|50381
block|,
literal|50917
block|,
literal|51205
block|,
literal|51325
block|,
literal|52165
block|,
literal|52229
block|,
literal|5253
block|,
literal|5269
block|,
literal|53509
block|,
literal|56253
block|,
literal|56341
block|,
literal|5821
block|,
literal|58373
block|,
literal|60301
block|,
literal|61653
block|,
literal|61973
block|,
literal|62373
block|,
literal|8397
block|,
literal|11981
block|,
literal|14341
block|,
literal|14509
block|,
literal|15077
block|,
literal|22261
block|,
literal|22429
block|,
literal|24261
block|,
literal|28165
block|,
literal|28685
block|,
literal|30661
block|,
literal|34021
block|,
literal|34445
block|,
literal|39149
block|,
literal|3917
block|,
literal|43013
block|,
literal|43317
block|,
literal|44053
block|,
literal|44101
block|,
literal|4533
block|,
literal|49541
block|,
literal|49981
block|,
literal|5277
block|,
literal|54477
block|,
literal|56357
block|,
literal|57261
block|,
literal|57765
block|,
literal|58573
block|,
literal|59061
block|,
literal|60197
block|,
literal|61197
block|,
literal|62189
block|,
literal|7725
block|,
literal|8477
block|,
literal|9565
block|,
literal|10229
block|,
literal|11437
block|,
literal|14613
block|,
literal|14709
block|,
literal|16813
block|,
literal|20029
block|,
literal|20677
block|,
literal|31445
block|,
literal|3165
block|,
literal|31957
block|,
literal|3229
block|,
literal|33541
block|,
literal|36645
block|,
literal|3805
block|,
literal|38973
block|,
literal|3965
block|,
literal|4029
block|,
literal|44293
block|,
literal|44557
block|,
literal|46245
block|,
literal|48917
block|,
literal|4909
block|,
literal|51749
block|,
literal|53709
block|,
literal|55733
block|,
literal|56445
block|,
literal|5925
block|,
literal|6093
block|,
literal|61053
block|,
literal|62637
block|,
literal|8661
block|,
literal|9109
block|,
literal|10821
block|,
literal|11389
block|,
literal|13813
block|,
literal|14325
block|,
literal|15501
block|,
literal|16149
block|,
literal|18845
block|,
literal|22669
block|,
literal|26437
block|,
literal|29869
block|,
literal|31837
block|,
literal|33709
block|,
literal|33973
block|,
literal|34173
block|,
literal|3677
block|,
literal|3877
block|,
literal|3981
block|,
literal|39885
block|,
literal|42117
block|,
literal|4421
block|,
literal|44221
block|,
literal|44245
block|,
literal|44693
block|,
literal|46157
block|,
literal|47309
block|,
literal|5005
block|,
literal|51461
block|,
literal|52037
block|,
literal|55333
block|,
literal|55693
block|,
literal|56277
block|,
literal|58949
block|,
literal|6205
block|,
literal|62141
block|,
literal|62469
block|,
literal|6293
block|,
literal|10101
block|,
literal|12509
block|,
literal|14029
block|,
literal|17997
block|,
literal|20469
block|,
literal|21149
block|,
literal|25221
block|,
literal|27109
block|,
literal|2773
block|,
literal|2877
block|,
literal|29405
block|,
literal|31493
block|,
literal|31645
block|,
literal|4077
block|,
literal|42005
block|,
literal|42077
block|,
literal|42469
block|,
literal|42501
block|,
literal|44013
block|,
literal|48653
block|,
literal|49349
block|,
literal|4997
block|,
literal|50101
block|,
literal|55405
block|,
literal|56957
block|,
literal|58037
block|,
literal|59429
block|,
literal|60749
block|,
literal|61797
block|,
literal|62381
block|,
literal|62837
block|,
literal|6605
block|,
literal|10541
block|,
literal|23981
block|,
literal|24533
block|,
literal|2701
block|,
literal|27333
block|,
literal|27341
block|,
literal|31197
block|,
literal|33805
block|,
literal|3621
block|,
literal|37381
block|,
literal|3749
block|,
literal|3829
block|,
literal|38533
block|,
literal|42613
block|,
literal|44381
block|,
literal|45901
block|,
literal|48517
block|,
literal|51269
block|,
literal|57725
block|,
literal|59461
block|,
literal|60045
block|,
literal|62029
block|,
literal|13805
block|,
literal|14013
block|,
literal|15461
block|,
literal|16069
block|,
literal|16157
block|,
literal|18573
block|,
literal|2309
block|,
literal|23501
block|,
literal|28645
block|,
literal|3077
block|,
literal|31541
block|,
literal|36357
block|,
literal|36877
block|,
literal|3789
block|,
literal|39429
block|,
literal|39805
block|,
literal|47685
block|,
literal|47949
block|,
literal|49413
block|,
literal|5485
block|,
literal|56757
block|,
literal|57549
block|,
literal|57805
block|,
literal|58317
block|,
literal|59549
block|,
literal|62213
block|,
literal|62613
block|,
literal|62853
block|,
literal|62933
block|,
literal|8909
block|,
literal|12941
block|,
literal|16677
block|,
literal|20333
block|,
literal|21541
block|,
literal|24429
block|,
literal|26077
block|,
literal|26421
block|,
literal|2885
block|,
literal|31269
block|,
literal|33381
block|,
literal|3661
block|,
literal|40925
block|,
literal|42925
block|,
literal|45173
block|,
literal|4525
block|,
literal|4709
block|,
literal|53133
block|,
literal|55941
block|,
literal|57413
block|,
literal|57797
block|,
literal|62125
block|,
literal|62237
block|,
literal|62733
block|,
literal|6773
block|,
literal|12317
block|,
literal|13197
block|,
literal|16533
block|,
literal|16933
block|,
literal|18245
block|,
literal|2213
block|,
literal|2477
block|,
literal|29757
block|,
literal|33293
block|,
literal|35517
block|,
literal|40133
block|,
literal|40749
block|,
literal|4661
block|,
literal|49941
block|,
literal|62757
block|,
literal|7853
block|,
literal|8149
block|,
literal|8573
block|,
literal|11029
block|,
literal|13421
block|,
literal|21549
block|,
literal|22709
block|,
literal|22725
block|,
literal|24629
block|,
literal|2469
block|,
literal|26125
block|,
literal|2669
block|,
literal|34253
block|,
literal|36709
block|,
literal|41013
block|,
literal|45597
block|,
literal|46637
block|,
literal|52285
block|,
literal|52333
block|,
literal|54685
block|,
literal|59013
block|,
literal|60997
block|,
literal|61189
block|,
literal|61981
block|,
literal|62605
block|,
literal|62821
block|,
literal|7077
block|,
literal|7525
block|,
literal|8781
block|,
literal|10861
block|,
literal|15277
block|,
literal|2205
block|,
literal|22077
block|,
literal|28517
block|,
literal|28949
block|,
literal|32109
block|,
literal|33493
block|,
literal|3685
block|,
literal|39197
block|,
literal|39869
block|,
literal|42621
block|,
literal|44997
block|,
literal|48565
block|,
literal|5221
block|,
literal|57381
block|,
literal|61749
block|,
literal|62317
block|,
literal|63245
block|,
literal|63381
block|,
literal|23149
block|,
literal|2549
block|,
literal|28661
block|,
literal|31653
block|,
literal|33885
block|,
literal|36341
block|,
literal|37053
block|,
literal|39517
block|,
literal|42805
block|,
literal|45853
block|,
literal|48997
block|,
literal|59349
block|,
literal|60053
block|,
literal|62509
block|,
literal|63069
block|,
literal|6525
block|,
literal|1893
block|,
literal|20181
block|,
literal|2365
block|,
literal|24893
block|,
literal|27397
block|,
literal|31357
block|,
literal|32277
block|,
literal|33357
block|,
literal|34437
block|,
literal|36677
block|,
literal|37661
block|,
literal|43469
block|,
literal|43917
block|,
literal|50997
block|,
literal|53869
block|,
literal|5653
block|,
literal|13221
block|,
literal|16741
block|,
literal|17893
block|,
literal|2157
block|,
literal|28653
block|,
literal|31789
block|,
literal|35301
block|,
literal|35821
block|,
literal|61613
block|,
literal|62245
block|,
literal|12405
block|,
literal|14517
block|,
literal|17453
block|,
literal|18421
block|,
literal|3149
block|,
literal|3205
block|,
literal|40341
block|,
literal|4109
block|,
literal|43941
block|,
literal|46869
block|,
literal|48837
block|,
literal|50621
block|,
literal|57405
block|,
literal|60509
block|,
literal|62877
block|,
literal|8157
block|,
literal|12933
block|,
literal|12957
block|,
literal|16501
block|,
literal|19533
block|,
literal|3461
block|,
literal|36829
block|,
literal|52357
block|,
literal|58189
block|,
literal|58293
block|,
literal|63053
block|,
literal|17109
block|,
literal|1933
block|,
literal|32157
block|,
literal|37701
block|,
literal|59005
block|,
literal|61621
block|,
literal|13029
block|,
literal|15085
block|,
literal|16493
block|,
literal|32317
block|,
literal|35093
block|,
literal|5061
block|,
literal|51557
block|,
literal|62221
block|,
literal|20765
block|,
literal|24613
block|,
literal|2629
block|,
literal|30861
block|,
literal|33197
block|,
literal|33749
block|,
literal|35365
block|,
literal|37933
block|,
literal|40317
block|,
literal|48045
block|,
literal|56229
block|,
literal|61157
block|,
literal|63797
block|,
literal|7917
block|,
literal|17965
block|,
literal|1917
block|,
literal|1973
block|,
literal|20301
block|,
literal|2253
block|,
literal|33157
block|,
literal|58629
block|,
literal|59861
block|,
literal|61085
block|,
literal|63909
block|,
literal|8141
block|,
literal|9221
block|,
literal|14757
block|,
literal|1581
block|,
literal|21637
block|,
literal|26557
block|,
literal|33869
block|,
literal|34285
block|,
literal|35733
block|,
literal|40933
block|,
literal|42517
block|,
literal|43501
block|,
literal|53653
block|,
literal|61885
block|,
literal|63805
block|,
literal|7141
block|,
literal|21653
block|,
literal|54973
block|,
literal|31189
block|,
literal|60061
block|,
literal|60341
block|,
literal|63357
block|,
literal|16045
block|,
literal|2053
block|,
literal|26069
block|,
literal|33997
block|,
literal|43901
block|,
literal|54565
block|,
literal|63837
block|,
literal|8949
block|,
literal|17909
block|,
literal|18693
block|,
literal|32349
block|,
literal|33125
block|,
literal|37293
block|,
literal|48821
block|,
literal|49053
block|,
literal|51309
block|,
literal|64037
block|,
literal|7117
block|,
literal|1445
block|,
literal|20405
block|,
literal|23085
block|,
literal|26269
block|,
literal|26293
block|,
literal|27349
block|,
literal|32381
block|,
literal|33141
block|,
literal|34525
block|,
literal|36461
block|,
literal|37581
block|,
literal|43525
block|,
literal|4357
block|,
literal|43877
block|,
literal|5069
block|,
literal|55197
block|,
literal|63965
block|,
literal|9845
block|,
literal|12093
block|,
literal|2197
block|,
literal|2229
block|,
literal|32165
block|,
literal|33469
block|,
literal|40981
block|,
literal|42397
block|,
literal|8749
block|,
literal|10853
block|,
literal|1453
block|,
literal|18069
block|,
literal|21693
block|,
literal|30573
block|,
literal|36261
block|,
literal|37421
block|,
literal|42533
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NSID_MULT_TABLE_SIZE
define|\
value|((sizeof nsid_multiplier_table)/(sizeof nsid_multiplier_table[0]))
end_define

begin_function
name|void
name|nsid_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timeval
name|now
decl_stmt|;
name|pid_t
name|mypid
decl_stmt|;
name|u_int16_t
name|a1ndx
decl_stmt|,
name|a2ndx
decl_stmt|,
name|a3ndx
decl_stmt|,
name|c1ndx
decl_stmt|,
name|c2ndx
decl_stmt|,
name|c3ndx
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|nsid_algorithm
operator|!=
literal|0
condition|)
return|return;
name|gettimeofday
argument_list|(
operator|&
name|now
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mypid
operator|=
name|getpid
argument_list|()
expr_stmt|;
comment|/* Initialize the state */
name|nsid_hash_state
operator|=
literal|0
expr_stmt|;
name|nsid_hash
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|now
argument_list|,
sizeof|sizeof
name|now
argument_list|)
expr_stmt|;
name|nsid_hash
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|mypid
argument_list|,
sizeof|sizeof
name|mypid
argument_list|)
expr_stmt|;
comment|/* 	 * Select our random number generators and initial seed. 	 * We could really use more random bits at this point, 	 * but we'll try to make a silk purse out of a sows ear ... 	 */
comment|/* generator 1 */
name|a1ndx
operator|=
operator|(
operator|(
name|u_long
operator|)
name|NSID_MULT_TABLE_SIZE
operator|*
operator|(
name|nsid_hash_state
operator|&
literal|0xFFFF
operator|)
operator|)
operator|>>
literal|16
expr_stmt|;
name|nsid_a1
operator|=
name|nsid_multiplier_table
index|[
name|a1ndx
index|]
expr_stmt|;
name|c1ndx
operator|=
operator|(
name|nsid_hash_state
operator|>>
literal|9
operator|)
operator|&
literal|0x7FFF
expr_stmt|;
name|nsid_c1
operator|=
literal|2
operator|*
name|c1ndx
operator|+
literal|1
expr_stmt|;
comment|/* generator 2, distinct from 1 */
name|a2ndx
operator|=
operator|(
call|(
name|u_long
call|)
argument_list|(
name|NSID_MULT_TABLE_SIZE
operator|-
literal|1
argument_list|)
operator|*
operator|(
operator|(
name|nsid_hash_state
operator|>>
literal|10
operator|)
operator|&
literal|0xFFFF
operator|)
operator|)
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|a2ndx
operator|>=
name|a1ndx
condition|)
name|a2ndx
operator|++
expr_stmt|;
name|nsid_a2
operator|=
name|nsid_multiplier_table
index|[
name|a2ndx
index|]
expr_stmt|;
name|c2ndx
operator|=
name|nsid_hash_state
operator|%
literal|32767
expr_stmt|;
if|if
condition|(
name|c2ndx
operator|>=
name|c1ndx
condition|)
name|c2ndx
operator|++
expr_stmt|;
name|nsid_c2
operator|=
literal|2
operator|*
name|c2ndx
operator|+
literal|1
expr_stmt|;
comment|/* generator 3, distinct from 1 and 2 */
name|a3ndx
operator|=
operator|(
call|(
name|u_long
call|)
argument_list|(
name|NSID_MULT_TABLE_SIZE
operator|-
literal|2
argument_list|)
operator|*
operator|(
operator|(
name|nsid_hash_state
operator|>>
literal|20
operator|)
operator|&
literal|0xFFFF
operator|)
operator|)
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|a3ndx
operator|>=
name|a1ndx
operator|||
name|a3ndx
operator|>=
name|a2ndx
condition|)
name|a3ndx
operator|++
expr_stmt|;
if|if
condition|(
name|a3ndx
operator|>=
name|a1ndx
operator|&&
name|a3ndx
operator|>=
name|a2ndx
condition|)
name|a3ndx
operator|++
expr_stmt|;
name|nsid_a3
operator|=
name|nsid_multiplier_table
index|[
name|a3ndx
index|]
expr_stmt|;
name|c3ndx
operator|=
name|nsid_hash_state
operator|%
literal|32766
expr_stmt|;
if|if
condition|(
name|c3ndx
operator|>=
name|c1ndx
operator|||
name|c3ndx
operator|>=
name|c2ndx
condition|)
name|c3ndx
operator|++
expr_stmt|;
if|if
condition|(
name|c3ndx
operator|>=
name|c1ndx
operator|&&
name|c3ndx
operator|>=
name|c2ndx
condition|)
name|c3ndx
operator|++
expr_stmt|;
name|nsid_c3
operator|=
literal|2
operator|*
name|c3ndx
operator|+
literal|1
expr_stmt|;
name|nsid_state
operator|=
operator|(
operator|(
name|nsid_hash_state
operator|>>
literal|16
operator|)
operator|^
operator|(
name|nsid_hash_state
operator|)
operator|)
operator|&
literal|0xFFFF
expr_stmt|;
comment|/* Do the algorithm specific initialization */
name|INSIST
argument_list|(
name|server_options
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|NS_OPTION_P
argument_list|(
name|OPTION_USE_ID_POOL
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Algorithm 1 */
name|nsid_algorithm
operator|=
name|NSID_SHUFFLE_ONLY
expr_stmt|;
name|nsid_vtable
operator|=
name|memget
argument_list|(
name|NSID_SHUFFLE_TABLE_SIZE
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nsid_vtable
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"memget(nsid_vtable)"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSID_SHUFFLE_TABLE_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|nsid_vtable
index|[
name|i
index|]
operator|=
name|nsid_state
expr_stmt|;
name|nsid_state
operator|=
operator|(
operator|(
operator|(
name|u_long
operator|)
name|nsid_a1
operator|*
name|nsid_state
operator|)
operator|+
name|nsid_c1
operator|)
operator|&
literal|0xFFFF
expr_stmt|;
block|}
name|nsid_state2
operator|=
name|nsid_state
expr_stmt|;
block|}
else|else
block|{
comment|/* Algorithm 2 */
name|nsid_algorithm
operator|=
name|NSID_USE_POOL
expr_stmt|;
name|nsid_pool
operator|=
name|memget
argument_list|(
literal|0x10000
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nsid_pool
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"memget(nsid_pool)"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|nsid_pool
index|[
name|i
index|]
operator|=
name|nsid_state
expr_stmt|;
name|nsid_state
operator|=
operator|(
operator|(
operator|(
name|u_long
operator|)
name|nsid_a1
operator|*
name|nsid_state
operator|)
operator|+
name|nsid_c1
operator|)
operator|&
literal|0xFFFF
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0xFFFF
condition|)
break|break;
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|NSID_RANGE_MASK
value|(NSID_LOOKAHEAD - 1)
end_define

begin_define
define|#
directive|define
name|NSID_POOL_MASK
value|0xFFFF
end_define

begin_comment
comment|/* used to wrap the pool index */
end_comment

begin_function
name|u_int16_t
name|nsid_next
parameter_list|()
block|{
name|u_int16_t
name|id
decl_stmt|,
name|compressed_hash
decl_stmt|;
name|compressed_hash
operator|=
operator|(
operator|(
name|nsid_hash_state
operator|>>
literal|16
operator|)
operator|^
operator|(
name|nsid_hash_state
operator|)
operator|)
operator|&
literal|0xFFFF
expr_stmt|;
if|if
condition|(
name|nsid_algorithm
operator|==
name|NSID_SHUFFLE_ONLY
condition|)
block|{
name|u_int16_t
name|j
decl_stmt|;
comment|/* 		 * This is the original Algorithm B 		 * j = ((u_long) NSID_SHUFFLE_TABLE_SIZE * nsid_state2) 		 *>> 16; 		 * 		 * We'll perturb it with some random stuff  ... 		 */
name|j
operator|=
operator|(
operator|(
name|u_long
operator|)
name|NSID_SHUFFLE_TABLE_SIZE
operator|*
operator|(
name|nsid_state2
operator|^
name|compressed_hash
operator|)
operator|)
operator|>>
literal|16
expr_stmt|;
name|nsid_state2
operator|=
name|id
operator|=
name|nsid_vtable
index|[
name|j
index|]
expr_stmt|;
name|nsid_state
operator|=
operator|(
operator|(
operator|(
name|u_long
operator|)
name|nsid_a1
operator|*
name|nsid_state
operator|)
operator|+
name|nsid_c1
operator|)
operator|&
literal|0xFFFF
expr_stmt|;
name|nsid_vtable
index|[
name|j
index|]
operator|=
name|nsid_state
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nsid_algorithm
operator|==
name|NSID_USE_POOL
condition|)
block|{
name|u_int16_t
name|pick
decl_stmt|;
name|pick
operator|=
name|compressed_hash
operator|&
name|NSID_RANGE_MASK
expr_stmt|;
name|id
operator|=
name|nsid_pool
index|[
operator|(
name|nsid_state
operator|+
name|pick
operator|)
operator|&
name|NSID_POOL_MASK
index|]
expr_stmt|;
if|if
condition|(
name|pick
operator|!=
literal|0
condition|)
block|{
comment|/* Swap two IDs to stir the pool */
name|nsid_pool
index|[
operator|(
name|nsid_state
operator|+
name|pick
operator|)
operator|&
name|NSID_POOL_MASK
index|]
operator|=
name|nsid_pool
index|[
name|nsid_state
index|]
expr_stmt|;
name|nsid_pool
index|[
name|nsid_state
index|]
operator|=
name|id
expr_stmt|;
block|}
comment|/* increment the base pointer into the pool */
if|if
condition|(
name|nsid_state
operator|==
literal|65535
condition|)
name|nsid_state
operator|=
literal|0
expr_stmt|;
else|else
name|nsid_state
operator|++
expr_stmt|;
block|}
else|else
block|{
name|id
operator|=
literal|0
expr_stmt|;
comment|/* silence compiler */
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"Unknown ID algorithm"
argument_list|)
expr_stmt|;
block|}
comment|/* Now lets obfuscate ... */
name|id
operator|=
operator|(
operator|(
operator|(
name|u_long
operator|)
name|nsid_a2
operator|*
name|id
operator|)
operator|+
name|nsid_c2
operator|)
operator|&
literal|0xFFFF
expr_stmt|;
name|id
operator|=
operator|(
operator|(
operator|(
name|u_long
operator|)
name|nsid_a3
operator|*
name|id
operator|)
operator|+
name|nsid_c3
operator|)
operator|&
literal|0xFFFF
expr_stmt|;
return|return
operator|(
name|id
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Note: this function CAN'T deallocate the saved_argv[]. */
end_comment

begin_function
specifier|static
name|void
name|deallocate_everything
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|write_open
argument_list|(
name|server_options
operator|->
name|memstats_filename
argument_list|)
expr_stmt|;
name|ns_freestats
argument_list|()
expr_stmt|;
name|qflush
argument_list|()
expr_stmt|;
name|sq_flush
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|free_addinfo
argument_list|()
expr_stmt|;
name|ns_shutdown
argument_list|()
expr_stmt|;
name|dq_remove_all
argument_list|()
expr_stmt|;
name|db_lame_destroy
argument_list|()
expr_stmt|;
if|if
condition|(
name|local_addresses
operator|!=
name|NULL
condition|)
name|free_ip_match_list
argument_list|(
name|local_addresses
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_networks
operator|!=
name|NULL
condition|)
name|free_ip_match_list
argument_list|(
name|local_networks
argument_list|)
expr_stmt|;
name|destroyservicelist
argument_list|()
expr_stmt|;
name|destroyprotolist
argument_list|()
expr_stmt|;
name|shutdown_logging
argument_list|()
expr_stmt|;
name|evDestroy
argument_list|(
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
name|conffile
operator|!=
name|NULL
condition|)
name|freestr
argument_list|(
name|conffile
argument_list|)
expr_stmt|;
name|conffile
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|debugfile
operator|!=
name|NULL
condition|)
name|freestr
argument_list|(
name|debugfile
argument_list|)
expr_stmt|;
name|debugfile
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|user_name
operator|!=
name|NULL
condition|)
name|freestr
argument_list|(
name|user_name
argument_list|)
expr_stmt|;
name|user_name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|group_name
operator|!=
name|NULL
condition|)
name|freestr
argument_list|(
name|group_name
argument_list|)
expr_stmt|;
name|group_name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|chroot_dir
operator|!=
name|NULL
condition|)
name|freestr
argument_list|(
name|chroot_dir
argument_list|)
expr_stmt|;
name|chroot_dir
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nsid_pool
operator|!=
name|NULL
condition|)
name|memput
argument_list|(
name|nsid_pool
argument_list|,
literal|0x10000
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|nsid_pool
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nsid_vtable
operator|!=
name|NULL
condition|)
name|memput
argument_list|(
name|nsid_vtable
argument_list|,
name|NSID_SHUFFLE_TABLE_SIZE
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|nsid_vtable
operator|=
name|NULL
expr_stmt|;
name|irs_destroy
argument_list|()
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
block|{
name|memstats
argument_list|(
name|f
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|memactive
argument_list|()
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ns_restart
parameter_list|(
name|void
parameter_list|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"named restarting"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND_UPDATE
name|dynamic_about_to_exit
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|server_options
operator|&&
name|server_options
operator|->
name|pid_filename
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|server_options
operator|->
name|pid_filename
argument_list|)
expr_stmt|;
name|ns_logstats
argument_list|(
name|ev
argument_list|,
name|NULL
argument_list|,
name|evNowTime
argument_list|()
argument_list|,
name|evConsTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NS_OPTION_P
argument_list|(
name|OPTION_DEALLOC_ON_EXIT
argument_list|)
condition|)
name|deallocate_everything
argument_list|()
expr_stmt|;
else|else
name|shutdown_configuration
argument_list|()
expr_stmt|;
name|execvp
argument_list|(
name|saved_argv
index|[
literal|0
index|]
argument_list|,
name|saved_argv
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|use_desired_debug
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|sigset_t
name|set
decl_stmt|;
comment|/* Protect against race conditions by blocking debugging signals. */
if|if
condition|(
name|sigemptyset
argument_list|(
operator|&
name|set
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_os
argument_list|,
literal|"sigemptyset failed in use_desired_debug: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGUSR1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_os
argument_list|,
literal|"sigaddset SIGUSR1 failed in use_desired_debug: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGUSR2
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_os
argument_list|,
literal|"sigaddset SIGUSR2 failed in use_desired_debug: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|set
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_os
argument_list|,
literal|"sigprocmask to block USR1 and USR2 failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|setdebug
argument_list|(
name|desired_debug
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigprocmask
argument_list|(
name|SIG_UNBLOCK
argument_list|,
operator|&
name|set
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|ns_error
argument_list|(
name|ns_log_os
argument_list|,
literal|"sigprocmask to unblock USR1 and USR2 failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|toggle_qrylog
parameter_list|(
name|void
parameter_list|)
block|{
name|qrylog
operator|=
operator|!
name|qrylog
expr_stmt|;
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"query log %s\n"
argument_list|,
name|qrylog
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wild
parameter_list|(
name|void
parameter_list|)
block|{
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"wild need"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is a functional interface to the global needs and options.  */
end_comment

begin_function
specifier|static
name|void
name|init_needs
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|need
decl_stmt|;
for|for
control|(
name|need
operator|=
literal|0
init|;
name|need
operator|<
name|main_need_num
condition|;
name|need
operator|++
control|)
name|handlers
index|[
name|need
index|]
operator|=
name|wild
expr_stmt|;
name|handlers
index|[
name|main_need_zreload
index|]
operator|=
name|ns_zreload
expr_stmt|;
name|handlers
index|[
name|main_need_reload
index|]
operator|=
name|ns_reload
expr_stmt|;
name|handlers
index|[
name|main_need_reconfig
index|]
operator|=
name|ns_reconfig
expr_stmt|;
name|handlers
index|[
name|main_need_endxfer
index|]
operator|=
name|endxfer
expr_stmt|;
name|handlers
index|[
name|main_need_zoneload
index|]
operator|=
name|loadxfer
expr_stmt|;
name|handlers
index|[
name|main_need_dump
index|]
operator|=
name|doadump
expr_stmt|;
name|handlers
index|[
name|main_need_statsdump
index|]
operator|=
name|ns_stats
expr_stmt|;
name|handlers
index|[
name|main_need_statsdumpandclear
index|]
operator|=
name|ns_stats_dumpandclear
expr_stmt|;
name|handlers
index|[
name|main_need_exit
index|]
operator|=
name|exit_handler
expr_stmt|;
name|handlers
index|[
name|main_need_qrylog
index|]
operator|=
name|toggle_qrylog
expr_stmt|;
name|handlers
index|[
name|main_need_debug
index|]
operator|=
name|use_desired_debug
expr_stmt|;
name|handlers
index|[
name|main_need_restart
index|]
operator|=
name|ns_restart
expr_stmt|;
name|handlers
index|[
name|main_need_reap
index|]
operator|=
name|reapchild
expr_stmt|;
name|handlers
index|[
name|main_need_noexpired
index|]
operator|=
name|ns_noexpired
expr_stmt|;
name|handlers
index|[
name|main_need_tryxfer
index|]
operator|=
name|tryxfer
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_needs
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|need
decl_stmt|,
name|queued
init|=
literal|0
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|15
argument_list|,
literal|"handle_needs()"
argument_list|)
expr_stmt|;
name|block_signals
argument_list|()
expr_stmt|;
for|for
control|(
name|need
operator|=
literal|0
init|;
name|need
operator|<
name|main_need_num
condition|;
name|need
operator|++
control|)
if|if
condition|(
operator|(
name|needs
operator|&
operator|(
literal|1
operator|<<
name|need
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|INSIST_ERR
argument_list|(
name|evWaitFor
argument_list|(
name|ev
argument_list|,
operator|(
name|void
operator|*
operator|)
name|handle_needs
argument_list|,
name|need_waitfunc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|handlers
index|[
name|need
index|]
argument_list|,
name|NULL
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|queued
operator|++
expr_stmt|;
block|}
name|needs
operator|=
literal|0
expr_stmt|;
name|unblock_signals
argument_list|()
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|15
argument_list|,
literal|"handle_needs(): queued %d"
argument_list|,
name|queued
argument_list|)
expr_stmt|;
if|if
condition|(
name|queued
operator|!=
literal|0
condition|)
block|{
name|INSIST_ERR
argument_list|(
name|evDo
argument_list|(
name|ev
argument_list|,
operator|(
name|void
operator|*
operator|)
name|handle_needs
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"ns_handle_needs: queued == 0"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|need_waitfunc
parameter_list|(
name|evContext
name|ctx
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
specifier|const
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|handler
name|hand
init|=
operator|(
name|handler
operator|)
name|uap
decl_stmt|;
name|time_t
name|begin
decl_stmt|;
name|long
name|syncdelay
decl_stmt|;
name|UNUSED
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|begin
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
call|(
modifier|*
name|hand
call|)
argument_list|()
expr_stmt|;
name|syncdelay
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
operator|-
name|begin
expr_stmt|;
if|if
condition|(
name|syncdelay
operator|>
name|MAX_SYNCDELAY
condition|)
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"drained %d queries (delay %ld sec)"
argument_list|,
name|drain_all_rcvbuf
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|syncdelay
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ns_need
parameter_list|(
name|enum
name|need
name|need
parameter_list|)
block|{
name|block_signals
argument_list|()
expr_stmt|;
name|ns_need_unsafe
argument_list|(
name|need
argument_list|)
expr_stmt|;
name|unblock_signals
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Note: this function should only be called with signals blocked. */
end_comment

begin_function
name|void
name|ns_need_unsafe
parameter_list|(
name|enum
name|need
name|need
parameter_list|)
block|{
name|needs
operator||=
operator|(
literal|1
operator|<<
name|need
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|exit_handler
parameter_list|(
name|void
parameter_list|)
block|{
name|needs_exit
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ns_setoption
parameter_list|(
name|int
name|option
parameter_list|)
block|{
name|ns_warning
argument_list|(
name|ns_log_default
argument_list|,
literal|"used obsolete ns_setoption(%d)"
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|writestream
parameter_list|(
name|struct
name|qstream
modifier|*
name|sp
parameter_list|,
specifier|const
name|u_char
modifier|*
name|msg
parameter_list|,
name|int
name|msglen
parameter_list|)
block|{
if|if
condition|(
name|sq_openw
argument_list|(
name|sp
argument_list|,
name|msglen
operator|+
name|INT16SZ
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sq_write
argument_list|(
name|sp
argument_list|,
name|msg
argument_list|,
name|msglen
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
name|sq_writeh
argument_list|(
name|sp
argument_list|,
name|sq_flushw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|only_digits
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|s
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__BOUNDS_CHECKING_ON
argument_list|)
end_if

begin_comment
comment|/* Use bounds checking malloc, etc. */
end_comment

begin_function
name|void
modifier|*
name|memget
parameter_list|(
name|size_t
name|len
parameter_list|)
block|{
return|return
operator|(
name|malloc
argument_list|(
name|len
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|memput
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|free
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|meminit
parameter_list|(
name|size_t
name|init_max_size
parameter_list|,
name|size_t
name|target_size
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|memget_debug
parameter_list|(
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|__memget
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: memget(%lu) -> %p\n"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
operator|(
name|u_long
operator|)
name|size
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_function
name|void
name|memput_debug
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: memput(%p, %lu)\n"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|ptr
argument_list|,
operator|(
name|u_long
operator|)
name|size
argument_list|)
expr_stmt|;
name|__memput
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|memstats
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|)
block|{
name|fputs
argument_list|(
literal|"No memstats\n"
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_CUSTOM
end_ifndef

begin_comment
comment|/* Standard implementation has nothing here */
end_comment

begin_function
specifier|static
name|void
name|custom_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Noop. */
block|}
end_function

begin_function
specifier|static
name|void
name|custom_shutdown
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Noop. */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

