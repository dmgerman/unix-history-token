begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ns_main.c	4.55 (Berkeley) 7/1/91"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: ns_main.c,v 8.65 1998/04/06 23:45:32 halley Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Copyright (c) 1986, 1989, 1990  *    The Regents of the University of California.  All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * 	This product includes software developed by the University of  * 	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1993 by Digital Equipment Corporation.  *   * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Digital Equipment Corporation not be used in advertising or  * publicity pertaining to distribution of the document or software without  * specific, written prior permission.  *   * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT  * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1996, 1997 by Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1986, 1989, 1990 The Regents of the University of California.\n\  portions Copyright (c) 1993 Digital Equipment Corporation\n\  portions Copyright (c) 1995, 1996, 1997 Internet Software Consortium\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Internet Name server (see RCF1035& others).  */
end_comment

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SVR4
end_ifdef

begin_comment
comment|/* XXX */
end_comment

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<isc/eventlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/logging.h>
end_include

begin_include
include|#
directive|include
file|<isc/memcluster.h>
end_include

begin_include
include|#
directive|include
file|<isc/list.h>
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETRUSAGE
end_ifdef

begin_comment
comment|/* XXX */
end_comment

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAIN_PROGRAM
end_define

begin_include
include|#
directive|include
file|"named.h"
end_include

begin_undef
undef|#
directive|undef
name|MAIN_PROGRAM
end_undef

begin_comment
comment|/* list of interfaces */
end_comment

begin_expr_stmt
specifier|static
name|LIST
argument_list|(
argument|struct _interface
argument_list|)
name|iflist
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|iflist_initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* UDP receive, TCP send buffer size */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int
name|rbufsize
init|=
literal|8
operator|*
literal|1024
decl_stmt|,
comment|/* TCP send window size */
name|sbufsize
init|=
literal|16
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int16_t
name|nsid_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|needs
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|qstream
modifier|*
name|sq_add
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|opensocket_d
argument_list|(
name|interface
operator|*
argument_list|)
decl_stmt|,
name|opensocket_s
argument_list|(
name|interface
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sq_query
argument_list|(
expr|struct
name|qstream
operator|*
argument_list|)
decl_stmt|,
name|dq_remove
argument_list|(
name|interface
operator|*
argument_list|)
decl_stmt|,
name|ns_handle_needs
argument_list|(
name|void
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|sq_dowrite
parameter_list|(
name|struct
name|qstream
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|use_desired_debug
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stream_write
parameter_list|(
name|evContext
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|interface
modifier|*
name|if_find
parameter_list|(
name|struct
name|in_addr
parameter_list|,
name|u_int16_t
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sq_here
parameter_list|(
name|struct
name|qstream
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|stream_accept
argument_list|(
name|evContext
argument_list|,
name|void
operator|*
argument_list|,
name|int
argument_list|,
specifier|const
name|void
operator|*
argument_list|,
name|int
argument_list|,
specifier|const
name|void
operator|*
argument_list|,
name|int
argument_list|)
decl_stmt|,
name|stream_getlen
argument_list|(
name|evContext
argument_list|,
name|void
operator|*
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
decl_stmt|,
name|stream_getmsg
argument_list|(
name|evContext
argument_list|,
name|void
operator|*
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
decl_stmt|,
name|datagram_read
argument_list|(
name|evContext
argument_list|,
name|void
operator|*
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
decl_stmt|,
name|dispatch_message
argument_list|(
name|u_char
operator|*
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
expr|struct
name|qstream
operator|*
argument_list|,
expr|struct
name|sockaddr_in
argument_list|,
name|int
argument_list|,
name|interface
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|stream_send
parameter_list|(
name|evContext
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_signals
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_signal_handler
parameter_list|(
name|int
parameter_list|,
name|SIG_FN
function_decl|(
modifier|*
function_decl|)
parameter_list|()
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|only_digits
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: named [-d #] [-q] [-r] [-f] [-p port] [[-b|-c] configfile]\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAN_CHANGE_ID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"             [-u (username|uid)] [-g (groupname|gid)]\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_CHROOT
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"             [-t directory]\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|bad_p_option
index|[]
init|=
literal|"-p remote/local obsolete; use 'listen-on' in config file to specify local"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|bad_directory
index|[]
init|=
literal|"chdir failed for directory '%s': %s"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|char
modifier|*
name|envp
index|[]
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|udpcnt
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
name|struct
name|qstream
modifier|*
name|sp
decl_stmt|;
name|interface
modifier|*
name|ifp
decl_stmt|;
specifier|const
name|int
name|on
init|=
literal|1
decl_stmt|;
name|int
name|rfd
decl_stmt|,
name|size
decl_stmt|,
name|len
decl_stmt|,
name|debug_option
decl_stmt|;
name|char
modifier|*
modifier|*
name|argp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* file descriptor for pid file */
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|struct
name|group
modifier|*
name|gr
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_GETRUSAGE
name|struct
name|rlimit
name|rl
decl_stmt|;
endif|#
directive|endif
name|user_id
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|group_id
operator|=
name|getgid
argument_list|()
expr_stmt|;
name|ns_port
operator|=
name|htons
argument_list|(
name|NAMESERVER_PORT
argument_list|)
expr_stmt|;
name|desired_debug
operator|=
name|debug
expr_stmt|;
comment|/* BSD has a better random number generator but it's not clear 	 * that we need it here. 	 */
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|srand
argument_list|(
operator|(
operator|(
name|unsigned
operator|)
name|getpid
argument_list|()
operator|)
operator|+
operator|(
name|unsigned
operator|)
name|tt
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
literal|022
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"b:c:d:g:p:t:u:w:qrf"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
if|if
condition|(
name|conffile
operator|!=
name|NULL
condition|)
name|freestr
argument_list|(
name|conffile
argument_list|)
expr_stmt|;
name|conffile
operator|=
name|savestr
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|desired_debug
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|desired_debug
operator|<=
literal|0
condition|)
name|desired_debug
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* use nonstandard port number. 			 * usage: -p remote/local 			 * remote is the port number to which 			 * we send queries.  local is the port 			 * on which we listen for queries. 			 * local defaults to same as remote. 			 */
name|ns_port
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|atoi
argument_list|(
name|optarg
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|bad_p_option
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|bad_p_option
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
name|chdir
argument_list|(
name|optarg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
name|bad_directory
argument_list|,
name|optarg
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|bad_directory
argument_list|,
name|optarg
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|QRYLOG
case|case
literal|'q'
case|:
name|qrylog
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'r'
case|:
name|ns_setoption
argument_list|(
name|OPTION_NORECURSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|foreground
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|chroot_dir
operator|=
name|savestr
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|CAN_CHANGE_ID
case|case
literal|'u'
case|:
name|user_name
operator|=
name|savestr
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|only_digits
argument_list|(
name|user_name
argument_list|)
condition|)
name|user_id
operator|=
name|atoi
argument_list|(
name|user_name
argument_list|)
expr_stmt|;
else|else
block|{
name|pw
operator|=
name|getpwnam
argument_list|(
name|user_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"user \"%s\" unknown\n"
argument_list|,
name|user_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|user_id
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
if|if
condition|(
name|group_name
operator|==
name|NULL
condition|)
block|{
name|char
name|name
index|[
literal|256
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%lu"
argument_list|,
operator|(
name|u_long
operator|)
name|pw
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
name|group_name
operator|=
name|savestr
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|group_id
operator|=
name|pw
operator|->
name|pw_gid
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|group_name
operator|!=
name|NULL
condition|)
name|freestr
argument_list|(
name|group_name
argument_list|)
expr_stmt|;
name|group_name
operator|=
name|savestr
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|only_digits
argument_list|(
name|group_name
argument_list|)
condition|)
name|group_id
operator|=
name|atoi
argument_list|(
name|group_name
argument_list|)
expr_stmt|;
else|else
block|{
name|gr
operator|=
name|getgrnam
argument_list|(
name|group_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|gr
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"group \"%s\" unknown\n"
argument_list|,
name|group_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|group_id
operator|=
name|gr
operator|->
name|gr_gid
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* CAN_CHANGE_ID */
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
condition|)
block|{
if|if
condition|(
name|conffile
operator|!=
name|NULL
condition|)
name|freestr
argument_list|(
name|conffile
argument_list|)
expr_stmt|;
name|conffile
operator|=
name|savestr
argument_list|(
operator|*
name|argv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|conffile
operator|==
name|NULL
condition|)
name|conffile
operator|=
name|savestr
argument_list|(
name|_PATH_CONF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure we don't inherit any open descriptors 	 * other than those that daemon() can deal with. 	 */
for|for
control|(
name|n
operator|=
name|sysconf
argument_list|(
name|_SC_OPEN_MAX
argument_list|)
operator|-
literal|1
init|;
name|n
operator|>=
literal|0
condition|;
name|n
operator|--
control|)
if|if
condition|(
name|n
operator|!=
name|STDIN_FILENO
operator|&&
name|n
operator|!=
name|STDOUT_FILENO
operator|&&
name|n
operator|!=
name|STDERR_FILENO
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* 	 * Chroot if desired. 	 */
if|if
condition|(
name|chroot_dir
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_CHROOT
if|if
condition|(
name|chroot
argument_list|(
name|chroot_dir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"chroot %s failed: %s\n"
argument_list|,
name|chroot_dir
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chdir
argument_list|(
literal|"/"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"chdir(\"/\") failed: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning: chroot() not available\n"
argument_list|)
expr_stmt|;
name|freestr
argument_list|(
name|chroot_dir
argument_list|)
expr_stmt|;
name|chroot_dir
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Establish global event context. */
name|evCreate
argument_list|(
operator|&
name|ev
argument_list|)
expr_stmt|;
comment|/* 	 * Set up logging. 	 */
name|n
operator|=
name|LOG_PID
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG_NOWAIT
name|n
operator||=
name|LOG_NOWAIT
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOG_NDELAY
name|n
operator||=
name|LOG_NDELAY
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|LOG_CONS
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_LOG_CONS
argument_list|)
name|n
operator||=
name|LOG_CONS
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYSLOG_42BSD
name|openlog
argument_list|(
literal|"named"
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|#
directive|else
name|openlog
argument_list|(
literal|"named"
argument_list|,
name|n
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|init_logging
argument_list|()
expr_stmt|;
name|set_assertion_failure_callback
argument_list|(
name|ns_assertion_failed
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|use_desired_debug
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|init_signals
argument_list|()
expr_stmt|;
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"starting.  %s"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
name|_res
operator|.
name|options
operator|&=
operator|~
operator|(
name|RES_DEFNAMES
operator||
name|RES_DNSRCH
operator||
name|RES_RECURSE
operator|)
expr_stmt|;
name|nsid_init
argument_list|()
expr_stmt|;
comment|/* 	 * Initialize and load database. 	 */
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|buildservicelist
argument_list|()
expr_stmt|;
name|buildprotolist
argument_list|()
expr_stmt|;
name|ns_init
argument_list|(
name|conffile
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|boottime
argument_list|)
expr_stmt|;
name|resettime
operator|=
name|boottime
expr_stmt|;
comment|/* 	 * Fork and go into background now that 	 * we've done any slow initialization 	 * and are ready to answer queries. 	 */
if|if
condition|(
name|foreground
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|daemon
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"daemon: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|update_pid_file
argument_list|()
expr_stmt|;
block|}
comment|/* Check that udp checksums are on. */
name|ns_udp
argument_list|()
expr_stmt|;
comment|/* 	 * We waited until now to log this because we wanted logging to 	 * be set up the way the user prefers. 	 */
if|if
condition|(
name|chroot_dir
operator|!=
name|NULL
condition|)
name|ns_info
argument_list|(
name|ns_log_security
argument_list|,
literal|"chrooted to %s"
argument_list|,
name|chroot_dir
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAN_CHANGE_ID
comment|/* 	 * Set user and group if desired. 	 */
if|if
condition|(
name|group_name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|setgid
argument_list|(
name|group_id
argument_list|)
operator|<
literal|0
condition|)
name|ns_panic
argument_list|(
name|ns_log_security
argument_list|,
literal|1
argument_list|,
literal|"setgid(%s): %s"
argument_list|,
name|group_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ns_info
argument_list|(
name|ns_log_security
argument_list|,
literal|"group = %s"
argument_list|,
name|group_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|user_name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|getuid
argument_list|()
operator|==
literal|0
operator|&&
name|initgroups
argument_list|(
name|user_name
argument_list|,
name|group_id
argument_list|)
operator|<
literal|0
condition|)
name|ns_panic
argument_list|(
name|ns_log_security
argument_list|,
literal|1
argument_list|,
literal|"initgroups(%s, %d): %s"
argument_list|,
name|user_name
argument_list|,
operator|(
name|int
operator|)
name|group_id
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|endgrent
argument_list|()
expr_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
if|if
condition|(
name|setuid
argument_list|(
name|user_id
argument_list|)
operator|<
literal|0
condition|)
name|ns_panic
argument_list|(
name|ns_log_security
argument_list|,
literal|1
argument_list|,
literal|"setuid(%s): %s"
argument_list|,
name|user_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ns_info
argument_list|(
name|ns_log_security
argument_list|,
literal|"user = %s"
argument_list|,
name|user_name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CAN_CHANGE_ID */
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"Ready to answer queries."
argument_list|)
expr_stmt|;
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|prime_cache
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|evEvent
name|event
decl_stmt|;
if|if
condition|(
name|needs
condition|)
name|ns_handle_needs
argument_list|()
expr_stmt|;
name|INSIST_ERR
argument_list|(
name|evGetNext
argument_list|(
name|ev
argument_list|,
operator|&
name|event
argument_list|,
name|EV_WAIT
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|INSIST_ERR
argument_list|(
name|evDispatch
argument_list|(
name|ev
argument_list|,
name|event
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|IP_OPT_BUF_SIZE
end_ifndef

begin_comment
comment|/* arbitrary size */
end_comment

begin_define
define|#
directive|define
name|IP_OPT_BUF_SIZE
value|50
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|stream_accept
parameter_list|(
name|evContext
name|lev
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|int
name|rfd
parameter_list|,
specifier|const
name|void
modifier|*
name|lav
parameter_list|,
name|int
name|lalen
parameter_list|,
specifier|const
name|void
modifier|*
name|rav
parameter_list|,
name|int
name|ralen
parameter_list|)
block|{
name|interface
modifier|*
name|ifp
init|=
name|uap
decl_stmt|;
name|struct
name|qstream
modifier|*
name|sp
decl_stmt|;
name|struct
name|iovec
name|iov
decl_stmt|;
name|int
name|n
decl_stmt|,
name|len
decl_stmt|;
specifier|const
name|int
name|on
init|=
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|IP_OPTIONS
comment|/* XXX */
name|u_char
name|ip_opts
index|[
name|IP_OPT_BUF_SIZE
index|]
decl_stmt|;
endif|#
directive|endif
specifier|const
name|struct
name|sockaddr_in
modifier|*
name|la
decl_stmt|,
modifier|*
name|ra
decl_stmt|;
name|la
operator|=
operator|(
specifier|const
expr|struct
name|sockaddr_in
operator|*
operator|)
name|lav
expr_stmt|;
name|ra
operator|=
operator|(
specifier|const
expr|struct
name|sockaddr_in
operator|*
operator|)
name|rav
expr_stmt|;
name|INSIST
argument_list|(
name|ifp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rfd
operator|<
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EINTR
case|:
case|case
name|EAGAIN
case|:
if|#
directive|if
operator|(
name|EWOULDBLOCK
operator|!=
name|EAGAIN
operator|)
case|case
name|EWOULDBLOCK
case|:
endif|#
directive|endif
case|case
name|ECONNABORTED
case|:
ifdef|#
directive|ifdef
name|EPROTO
case|case
name|EPROTO
case|:
endif|#
directive|endif
case|case
name|EHOSTUNREACH
case|:
case|case
name|EHOSTDOWN
case|:
case|case
name|ENETUNREACH
case|:
case|case
name|ENETDOWN
case|:
case|case
name|ECONNREFUSED
case|:
ifdef|#
directive|ifdef
name|ENONET
case|case
name|ENONET
case|:
endif|#
directive|endif
comment|/* 			 * These errors are expected and harmless, so 			 * we ignore them. 			 */
return|return;
case|case
name|EBADF
case|:
case|case
name|ENOTSOCK
case|:
case|case
name|EFAULT
case|:
comment|/* 			 * If one these happens, we're broken. 			 */
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"accept: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|EMFILE
case|:
comment|/* 			 * If we're out of file descriptors, find the least 			 * busy fd and close it.  Then we'll return to the 			 * eventlib which will call us right back. 			 */
if|if
condition|(
name|streamq
condition|)
block|{
name|struct
name|qstream
modifier|*
name|nextsp
decl_stmt|;
name|struct
name|qstream
modifier|*
name|candidate
init|=
name|NULL
decl_stmt|;
name|time_t
name|lasttime
decl_stmt|,
name|maxctime
init|=
literal|0
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|streamq
init|;
name|sp
condition|;
name|sp
operator|=
name|nextsp
control|)
block|{
name|nextsp
operator|=
name|sp
operator|->
name|s_next
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_refcnt
condition|)
continue|continue;
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|lasttime
operator|=
name|tt
operator|.
name|tv_sec
operator|-
name|sp
operator|->
name|s_time
expr_stmt|;
if|if
condition|(
name|lasttime
operator|>=
name|VQEXPIRY
condition|)
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lasttime
operator|>
name|maxctime
condition|)
block|{
name|candidate
operator|=
name|sp
expr_stmt|;
name|maxctime
operator|=
name|lasttime
expr_stmt|;
block|}
block|}
if|if
condition|(
name|candidate
condition|)
name|sq_remove
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* fall through */
default|default:
comment|/* 			 * Either we got an error we didn't expect, or we 			 * got EMFILE and didn't have anything left to close. 			 * Log it and press on. 			 */
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"accept: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Condition the socket. */
comment|/* XXX clean up */
if|#
directive|if
literal|0
block|if ((n = fcntl(rfd, F_GETFL, 0)) == -1) { 		ns_info(ns_log_default, "fcntl(rfd, F_GETFL): %s", 			strerror(errno)); 		(void) close(rfd); 		return; 	} 	if (fcntl(rfd, F_SETFL, n|PORT_NONBLOCK) == -1) { 		ns_info(ns_log_default, "fcntl(rfd, NONBLOCK): %s", 			strerror(errno)); 		(void) close(rfd); 		return; 	}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|CANNOT_SET_SNDBUF
if|if
condition|(
name|setsockopt
argument_list|(
name|rfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_SNDBUF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sbufsize
argument_list|,
sizeof|sizeof
name|sbufsize
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"setsockopt(rfd, SO_SNDBUF, %d): %s"
argument_list|,
name|sbufsize
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|rfd
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|setsockopt
argument_list|(
name|rfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
name|on
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"setsockopt(rfd, KEEPALIVE): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|rfd
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * We don't like IP options.  Turn them off if the connection came in 	 * with any.  log this event since it usually indicates a security 	 * problem. 	 */
if|#
directive|if
name|defined
argument_list|(
name|IP_OPTIONS
argument_list|)
comment|/* XXX */
name|len
operator|=
sizeof|sizeof
name|ip_opts
expr_stmt|;
if|if
condition|(
name|getsockopt
argument_list|(
name|rfd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_OPTIONS
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ip_opts
argument_list|,
operator|&
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"getsockopt(rfd, IP_OPTIONS): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|rfd
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|nameserIncr
argument_list|(
name|ra
operator|->
name|sin_addr
argument_list|,
name|nssRcvdOpts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
name|ina_ulong
argument_list|(
name|ra
operator|->
name|sin_addr
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
literal|"rcvd ip options"
argument_list|)
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"rcvd IP_OPTIONS from %s (ignored)"
argument_list|,
name|sin_ntoa
argument_list|(
operator|*
name|ra
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setsockopt
argument_list|(
name|rfd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_OPTIONS
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"setsockopt(!IP_OPTIONS): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|rfd
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Create and populate a qsp for this socket. */
if|if
condition|(
operator|(
name|sp
operator|=
name|sq_add
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|rfd
argument_list|)
expr_stmt|;
return|return;
block|}
name|sp
operator|->
name|s_rfd
operator|=
name|rfd
expr_stmt|;
comment|/* stream file descriptor */
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_time
operator|=
name|tt
operator|.
name|tv_sec
expr_stmt|;
comment|/* last transaction time */
name|sp
operator|->
name|s_from
operator|=
operator|*
name|ra
expr_stmt|;
comment|/* address to respond to */
name|sp
operator|->
name|s_ifp
operator|=
name|ifp
expr_stmt|;
name|INSIST
argument_list|(
sizeof|sizeof
name|sp
operator|->
name|s_temp
operator|>=
name|INT16SZ
argument_list|)
expr_stmt|;
name|iov
operator|=
name|evConsIovec
argument_list|(
name|sp
operator|->
name|s_temp
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|INSIST_ERR
argument_list|(
name|evRead
argument_list|(
name|lev
argument_list|,
name|rfd
argument_list|,
operator|&
name|iov
argument_list|,
literal|1
argument_list|,
name|stream_getlen
argument_list|,
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|evID_r
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|->
name|flags
operator||=
name|STREAM_READ_EV
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"IP/TCP connection from %s (fd %d)"
argument_list|,
name|sin_ntoa
argument_list|(
name|sp
operator|->
name|s_from
argument_list|)
argument_list|,
name|rfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|tcp_send
parameter_list|(
name|struct
name|qinfo
modifier|*
name|qp
parameter_list|)
block|{
name|struct
name|qstream
modifier|*
name|sp
decl_stmt|;
name|int
name|on
init|=
literal|1
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"tcp_send"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|sq_add
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|SERVFAIL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|sp
operator|->
name|s_rfd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
name|PF_UNSPEC
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SERVFAIL
operator|)
return|;
block|}
if|if
condition|(
name|sq_openw
argument_list|(
name|sp
argument_list|,
name|qp
operator|->
name|q_msglen
operator|+
name|INT16SZ
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SERVFAIL
operator|)
return|;
block|}
if|if
condition|(
name|sq_write
argument_list|(
name|sp
argument_list|,
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SERVFAIL
operator|)
return|;
block|}
if|if
condition|(
name|setsockopt
argument_list|(
name|sp
operator|->
name|s_rfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"tcp_send: setsockopt(rfd, SO_KEEPALIVE): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_size
operator|=
operator|-
literal|1
expr_stmt|;
name|sp
operator|->
name|s_time
operator|=
name|tt
operator|.
name|tv_sec
expr_stmt|;
comment|/* last transaction time */
name|sp
operator|->
name|s_refcnt
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|flags
operator||=
name|STREAM_DONE_CLOSE
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_fwd
condition|)
name|sp
operator|->
name|s_from
operator|=
name|qp
operator|->
name|q_fwd
operator|->
name|fwdaddr
expr_stmt|;
else|else
name|sp
operator|->
name|s_from
operator|=
name|qp
operator|->
name|q_addr
index|[
name|qp
operator|->
name|q_curaddr
index|]
operator|.
name|ns_addr
expr_stmt|;
if|if
condition|(
name|evConnect
argument_list|(
name|ev
argument_list|,
name|sp
operator|->
name|s_rfd
argument_list|,
operator|&
name|sp
operator|->
name|s_from
argument_list|,
sizeof|sizeof
argument_list|(
name|sp
operator|->
name|s_from
argument_list|)
argument_list|,
name|stream_send
argument_list|,
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|evID_c
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SERVFAIL
operator|)
return|;
block|}
name|sp
operator|->
name|flags
operator||=
name|STREAM_CONNECT_EV
expr_stmt|;
return|return
operator|(
name|NOERROR
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|stream_send
parameter_list|(
name|evContext
name|lev
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|int
name|fd
parameter_list|,
specifier|const
name|void
modifier|*
name|la
parameter_list|,
name|int
name|lalen
parameter_list|,
specifier|const
name|void
modifier|*
name|ra
parameter_list|,
name|int
name|ralen
parameter_list|)
block|{
name|struct
name|qstream
modifier|*
name|sp
init|=
name|uap
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"stream_send"
argument_list|)
expr_stmt|;
name|sp
operator|->
name|flags
operator|&=
operator|~
name|STREAM_CONNECT_EV
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* connect failed */
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|evSelectFD
argument_list|(
name|ev
argument_list|,
name|sp
operator|->
name|s_rfd
argument_list|,
name|EV_WRITE
argument_list|,
name|stream_write
argument_list|,
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|evID_w
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
name|sp
operator|->
name|flags
operator||=
name|STREAM_WRITE_EV
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stream_write
parameter_list|(
name|evContext
name|ctx
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|evmask
parameter_list|)
block|{
name|struct
name|qstream
modifier|*
name|sp
init|=
name|uap
decl_stmt|;
name|struct
name|iovec
name|iov
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"stream_write"
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|evmask
operator|&
name|EV_WRITE
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|fd
operator|==
name|sp
operator|->
name|s_rfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sq_dowrite
argument_list|(
name|sp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sp
operator|->
name|s_wbuf_free
operator|!=
name|sp
operator|->
name|s_wbuf_send
condition|)
return|return;
if|if
condition|(
name|sp
operator|->
name|s_wbuf
condition|)
block|{
name|memput
argument_list|(
name|sp
operator|->
name|s_wbuf
argument_list|,
name|sp
operator|->
name|s_wbuf_end
operator|-
name|sp
operator|->
name|s_wbuf
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_wbuf
operator|=
name|NULL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|evDeselectFD
argument_list|(
name|ev
argument_list|,
name|sp
operator|->
name|evID_w
argument_list|)
expr_stmt|;
name|sp
operator|->
name|flags
operator|&=
operator|~
name|STREAM_WRITE_EV
expr_stmt|;
name|sp
operator|->
name|s_refcnt
operator|=
literal|0
expr_stmt|;
name|iov
operator|=
name|evConsIovec
argument_list|(
name|sp
operator|->
name|s_temp
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|INSIST_ERR
argument_list|(
name|evRead
argument_list|(
name|ctx
argument_list|,
name|fd
argument_list|,
operator|&
name|iov
argument_list|,
literal|1
argument_list|,
name|stream_getlen
argument_list|,
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|evID_r
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|->
name|flags
operator||=
name|STREAM_READ_EV
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stream_getlen
parameter_list|(
name|evContext
name|lev
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|bytes
parameter_list|)
block|{
name|struct
name|qstream
modifier|*
name|sp
init|=
name|uap
decl_stmt|;
name|struct
name|iovec
name|iov
decl_stmt|;
name|sp
operator|->
name|flags
operator|&=
operator|~
name|STREAM_READ_EV
expr_stmt|;
if|if
condition|(
name|bytes
operator|!=
name|INT16SZ
condition|)
block|{
comment|/* 		 * bytes == 0 is normal EOF; see if something unusual  		 * happened. 		 */
if|if
condition|(
name|bytes
operator|<
literal|0
condition|)
block|{
comment|/* 			 * ECONNRESET happens frequently and is not worth 			 * logging. 			 */
if|if
condition|(
name|errno
operator|!=
name|ECONNRESET
condition|)
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"stream_getlen(%s): %s"
argument_list|,
name|sin_ntoa
argument_list|(
name|sp
operator|->
name|s_from
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|!=
literal|0
condition|)
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"stream_getlen(%s): unexpected byte count %d"
argument_list|,
name|sin_ntoa
argument_list|(
name|sp
operator|->
name|s_from
argument_list|)
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Unpack the size, allocate memory for the query.  This is 	 * tricky since in a low memory situation with possibly very 	 * large (64KB) queries, we want to make sure we can read at 	 * least the header since we need it to send back a SERVFAIL 	 * (owing to the out-of-memory condition). 	 */
name|sp
operator|->
name|s_size
operator|=
name|ns_get16
argument_list|(
name|sp
operator|->
name|s_temp
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|5
argument_list|,
literal|"stream message: %d bytes"
argument_list|,
name|sp
operator|->
name|s_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sp
operator|->
name|flags
operator|&
name|STREAM_MALLOC
operator|)
condition|)
block|{
name|sp
operator|->
name|s_bufsize
operator|=
literal|64
operator|*
literal|1024
operator|-
literal|1
expr_stmt|;
comment|/* maximum tcp message size */
name|sp
operator|->
name|s_buf
operator|=
operator|(
name|u_char
operator|*
operator|)
name|memget
argument_list|(
name|sp
operator|->
name|s_bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_buf
operator|!=
name|NULL
condition|)
name|sp
operator|->
name|flags
operator||=
name|STREAM_MALLOC
expr_stmt|;
else|else
block|{
name|sp
operator|->
name|s_buf
operator|=
name|sp
operator|->
name|s_temp
expr_stmt|;
name|sp
operator|->
name|s_bufsize
operator|=
name|HFIXEDSZ
expr_stmt|;
block|}
block|}
name|iov
operator|=
name|evConsIovec
argument_list|(
name|sp
operator|->
name|s_buf
argument_list|,
name|sp
operator|->
name|s_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|evRead
argument_list|(
name|lev
argument_list|,
name|sp
operator|->
name|s_rfd
argument_list|,
operator|&
name|iov
argument_list|,
literal|1
argument_list|,
name|stream_getmsg
argument_list|,
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|evID_r
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"evRead(fd %d): %s"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sp
operator|->
name|s_rfd
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|flags
operator||=
name|STREAM_READ_EV
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stream_getmsg
parameter_list|(
name|evContext
name|lev
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|bytes
parameter_list|)
block|{
name|struct
name|qstream
modifier|*
name|sp
init|=
name|uap
decl_stmt|;
name|int
name|buflen
decl_stmt|,
name|n
decl_stmt|;
name|sp
operator|->
name|flags
operator|&=
operator|~
name|STREAM_READ_EV
expr_stmt|;
if|if
condition|(
name|bytes
operator|==
operator|-
literal|1
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"stream_getmsg(%s): %s"
argument_list|,
name|sin_ntoa
argument_list|(
name|sp
operator|->
name|s_from
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_time
operator|=
name|tt
operator|.
name|tv_sec
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|5
argument_list|,
literal|"sp %#x rfd %d size %d time %d next %#x"
argument_list|,
name|sp
argument_list|,
name|sp
operator|->
name|s_rfd
argument_list|,
name|sp
operator|->
name|s_size
argument_list|,
name|sp
operator|->
name|s_time
argument_list|,
name|sp
operator|->
name|s_next
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|5
argument_list|,
literal|"\tbufsize %d bytes %d"
argument_list|,
name|sp
operator|->
name|s_bufsize
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
comment|/* 	 * Do we have enough memory for the query?  If not, and if we have a 	 * query id, then we will send a SERVFAIL error back to the client. 	 */
if|if
condition|(
name|bytes
operator|!=
name|sp
operator|->
name|s_size
condition|)
block|{
name|HEADER
modifier|*
name|hp
init|=
operator|(
name|HEADER
operator|*
operator|)
name|sp
operator|->
name|s_buf
decl_stmt|;
name|hp
operator|->
name|qr
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|ra
operator|=
operator|(
name|NS_OPTION_P
argument_list|(
name|OPTION_NORECURSE
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|qdcount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
name|writestream
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|s_buf
argument_list|,
name|HFIXEDSZ
argument_list|)
expr_stmt|;
name|sp
operator|->
name|flags
operator||=
name|STREAM_DONE_CLOSE
expr_stmt|;
return|return;
block|}
name|nameserIncr
argument_list|(
name|sp
operator|->
name|s_from
operator|.
name|sin_addr
argument_list|,
name|nssRcvdTCP
argument_list|)
expr_stmt|;
name|sq_query
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|dispatch_message
argument_list|(
name|sp
operator|->
name|s_buf
argument_list|,
name|bytes
argument_list|,
name|sp
operator|->
name|s_bufsize
argument_list|,
name|sp
argument_list|,
name|sp
operator|->
name|s_from
argument_list|,
operator|-
literal|1
argument_list|,
name|sp
operator|->
name|s_ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|datagram_read
parameter_list|(
name|evContext
name|lev
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|evmask
parameter_list|)
block|{
name|interface
modifier|*
name|ifp
init|=
name|uap
decl_stmt|;
name|struct
name|sockaddr_in
name|from
decl_stmt|;
name|int
name|from_len
init|=
sizeof|sizeof
name|from
decl_stmt|;
name|int
name|n
decl_stmt|;
union|union
block|{
name|HEADER
name|h
decl_stmt|;
comment|/* Force alignment of 'buf'. */
name|u_char
name|buf
index|[
name|PACKETSZ
operator|+
literal|1
index|]
decl_stmt|;
block|}
name|u
union|;
name|n
operator|=
name|recvfrom
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|u
operator|.
name|buf
argument_list|,
sizeof|sizeof
name|u
operator|.
name|buf
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
operator|&
name|from_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EINTR
case|:
case|case
name|EAGAIN
case|:
if|#
directive|if
operator|(
name|EWOULDBLOCK
operator|!=
name|EAGAIN
operator|)
case|case
name|EWOULDBLOCK
case|:
endif|#
directive|endif
case|case
name|EHOSTUNREACH
case|:
case|case
name|EHOSTDOWN
case|:
case|case
name|ENETUNREACH
case|:
case|case
name|ENETDOWN
case|:
case|case
name|ECONNREFUSED
case|:
ifdef|#
directive|ifdef
name|ENONET
case|case
name|ENONET
case|:
endif|#
directive|endif
comment|/* 			 * These errors are expected and harmless, so we 			 * ignore them. 			 */
return|return;
case|case
name|EBADF
case|:
case|case
name|ENOTCONN
case|:
case|case
name|ENOTSOCK
case|:
case|case
name|EFAULT
case|:
comment|/* 			 * If one these happens, we're broken. 			 */
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"recvfrom: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
default|default:
comment|/* 			 * An error we don't expect.  Log it and press 			 * on. 			 */
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"recvfrom: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
ifndef|#
directive|ifndef
name|BSD
comment|/* Handle bogosity on systems that need it. */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return;
endif|#
directive|endif
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"datagram from %s, fd %d, len %d"
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
name|fd
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|PACKETSZ
condition|)
block|{
comment|/* 		 * The message is too big.  It's probably a response to 		 * one of our questions, so we truncate it and press on. 		 */
name|n
operator|=
name|trunc_adjust
argument_list|(
name|u
operator|.
name|buf
argument_list|,
name|PACKETSZ
argument_list|,
name|PACKETSZ
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"truncated oversize UDP packet"
argument_list|)
expr_stmt|;
block|}
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
comment|/* Keep 'tt' current. */
name|dispatch_message
argument_list|(
name|u
operator|.
name|buf
argument_list|,
name|n
argument_list|,
name|PACKETSZ
argument_list|,
name|NULL
argument_list|,
name|from
argument_list|,
name|fd
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dispatch_message
parameter_list|(
name|u_char
modifier|*
name|msg
parameter_list|,
name|int
name|msglen
parameter_list|,
name|int
name|buflen
parameter_list|,
name|struct
name|qstream
modifier|*
name|qsp
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|,
name|int
name|dfd
parameter_list|,
name|interface
modifier|*
name|ifp
parameter_list|)
block|{
name|HEADER
modifier|*
name|hp
init|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
decl_stmt|;
if|if
condition|(
name|msglen
operator|<
name|HFIXEDSZ
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"dropping undersize message"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hp
operator|->
name|qr
condition|)
block|{
name|ns_resp
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|,
name|from
argument_list|,
name|qsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|qsp
condition|)
name|sq_done
argument_list|(
name|qsp
argument_list|)
expr_stmt|;
comment|/* Now is a safe time for housekeeping. */
if|if
condition|(
name|needs_prime_cache
condition|)
name|prime_cache
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
name|ns_req
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|,
name|buflen
argument_list|,
name|qsp
argument_list|,
name|from
argument_list|,
name|dfd
argument_list|)
expr_stmt|;
else|else
block|{
name|ns_notice
argument_list|(
name|ns_log_security
argument_list|,
literal|"refused query on non-query socket from %s"
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX Send refusal here. */
block|}
block|}
end_function

begin_function
name|void
name|getnetconf
parameter_list|(
name|int
name|periodic_scan
parameter_list|)
block|{
name|struct
name|ifconf
name|ifc
decl_stmt|;
name|struct
name|ifreq
name|ifreq
decl_stmt|;
name|struct
name|in_addr
name|ina
decl_stmt|;
name|interface
modifier|*
name|ifp
decl_stmt|;
name|char
name|buf
index|[
literal|32768
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cplim
decl_stmt|;
name|u_int32_t
name|nm
decl_stmt|;
name|time_t
name|my_generation
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|int
name|s
decl_stmt|,
name|cpsize
decl_stmt|;
name|int
name|found
decl_stmt|;
name|listen_info
name|li
decl_stmt|;
name|u_int16_t
name|port
decl_stmt|;
name|ip_match_element
name|ime
decl_stmt|;
name|u_char
modifier|*
name|mask_ptr
decl_stmt|;
name|struct
name|in_addr
name|mask
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"getnetconf(generation %lu)"
argument_list|,
operator|(
name|u_long
operator|)
name|my_generation
argument_list|)
expr_stmt|;
comment|/* Get interface list from system. */
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|periodic_scan
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"socket(SOCK_RAW): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"socket(SOCK_RAW): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|iflist_initialized
condition|)
block|{
name|INIT_LIST
argument_list|(
name|iflist
argument_list|)
expr_stmt|;
name|iflist_initialized
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|local_addresses
operator|!=
name|NULL
condition|)
name|free_ip_match_list
argument_list|(
name|local_addresses
argument_list|)
expr_stmt|;
name|local_addresses
operator|=
name|new_ip_match_list
argument_list|()
expr_stmt|;
if|if
condition|(
name|local_networks
operator|!=
name|NULL
condition|)
name|free_ip_match_list
argument_list|(
name|local_networks
argument_list|)
expr_stmt|;
name|local_networks
operator|=
name|new_ip_match_list
argument_list|()
expr_stmt|;
name|ifc
operator|.
name|ifc_len
operator|=
sizeof|sizeof
name|buf
expr_stmt|;
name|ifc
operator|.
name|ifc_buf
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFCONF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifc
argument_list|)
operator|<
literal|0
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"get interface configuration: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|2
argument_list|,
literal|"getnetconf: SIOCGIFCONF: ifc_len = %d"
argument_list|,
name|ifc
operator|.
name|ifc_len
argument_list|)
expr_stmt|;
comment|/* Parse system's interface list and open some sockets. */
name|cplim
operator|=
name|buf
operator|+
name|ifc
operator|.
name|ifc_len
expr_stmt|;
comment|/* skip over if's with big ifr_addr's */
for|for
control|(
name|cp
operator|=
name|buf
init|;
name|cp
operator|<
name|cplim
condition|;
name|cp
operator|+=
name|cpsize
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|ifreq
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
name|ifreq
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|HAVE_SA_LEN
ifdef|#
directive|ifdef
name|FIX_ZERO_SA_LEN
if|if
condition|(
name|ifreq
operator|.
name|ifr_addr
operator|.
name|sa_len
operator|==
literal|0
condition|)
name|ifreq
operator|.
name|ifr_addr
operator|.
name|sa_len
operator|=
literal|16
expr_stmt|;
endif|#
directive|endif
name|cpsize
operator|=
sizeof|sizeof
name|ifreq
operator|.
name|ifr_name
operator|+
name|ifreq
operator|.
name|ifr_addr
operator|.
name|sa_len
expr_stmt|;
elif|#
directive|elif
name|defined
name|SIOCGIFCONF_ADDR
name|cpsize
operator|=
sizeof|sizeof
name|ifreq
expr_stmt|;
else|#
directive|else
name|cpsize
operator|=
sizeof|sizeof
name|ifreq
operator|.
name|ifr_name
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"get interface addr (%s): %s"
argument_list|,
name|ifreq
operator|.
name|ifr_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
name|ina
operator|=
name|ina_get
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_addr
operator|)
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifreq
operator|.
name|ifr_addr
operator|.
name|sa_family
operator|!=
name|AF_INET
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|2
argument_list|,
literal|"getnetconf: af %d != INET"
argument_list|,
name|ifreq
operator|.
name|ifr_addr
operator|.
name|sa_family
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"getnetconf: considering %s [%s]"
argument_list|,
name|ifreq
operator|.
name|ifr_name
argument_list|,
name|inet_ntoa
argument_list|(
name|ina
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Don't test IFF_UP, packets may still be received at this 		 * address if any other interface is up. 		 */
if|if
condition|(
name|ina_hlong
argument_list|(
name|ina
argument_list|)
operator|==
name|INADDR_ANY
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|2
argument_list|,
literal|"getnetconf: INADDR_ANY, ignoring."
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|INSIST
argument_list|(
name|server_options
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|server_options
operator|->
name|listen_list
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|li
operator|=
name|server_options
operator|->
name|listen_list
operator|->
name|first
init|;
name|li
operator|!=
name|NULL
condition|;
name|li
operator|=
name|li
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ip_match_address
argument_list|(
name|li
operator|->
name|list
argument_list|,
name|ina
argument_list|)
operator|>
literal|0
condition|)
block|{
name|found
operator|++
expr_stmt|;
comment|/*  				 * Look for an already existing source 				 * interface address/port pair. 				 * This happens mostly when reinitializing. 				 * Also, if the machine has multiple point to 				 * point interfaces, then the local address 				 * may appear more than once. 				 */
name|ifp
operator|=
name|if_find
argument_list|(
name|ina
argument_list|,
name|li
operator|->
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"dup interface addr [%s].%u (%s)"
argument_list|,
name|inet_ntoa
argument_list|(
name|ina
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|li
operator|->
name|port
argument_list|)
argument_list|,
name|ifreq
operator|.
name|ifr_name
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|gen
operator|=
name|my_generation
expr_stmt|;
continue|continue;
block|}
name|ifp
operator|=
operator|(
name|interface
operator|*
operator|)
name|memget
argument_list|(
sizeof|sizeof
expr|*
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ifp
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"memget(interface)"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|ifp
argument_list|)
expr_stmt|;
name|APPEND
argument_list|(
name|iflist
argument_list|,
name|ifp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|addr
operator|=
name|ina
expr_stmt|;
name|ifp
operator|->
name|port
operator|=
name|li
operator|->
name|port
expr_stmt|;
name|ifp
operator|->
name|gen
operator|=
name|my_generation
expr_stmt|;
name|ifp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|dfd
operator|=
operator|-
literal|1
expr_stmt|;
name|ifp
operator|->
name|sfd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|opensocket_d
argument_list|(
name|ifp
argument_list|)
operator|<
literal|0
operator|||
name|opensocket_s
argument_list|(
name|ifp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|dq_remove
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"listening on [%s].%u (%s)"
argument_list|,
name|inet_ntoa
argument_list|(
name|ina
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|li
operator|->
name|port
argument_list|)
argument_list|,
name|ifreq
operator|.
name|ifr_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"not listening on addr [%s] (%s)"
argument_list|,
name|inet_ntoa
argument_list|(
name|ina
argument_list|)
argument_list|,
name|ifreq
operator|.
name|ifr_name
argument_list|)
expr_stmt|;
comment|/* 		 * Add this interface's address to the list of local 		 * addresses if we haven't added it already. 		 */
if|if
condition|(
name|ip_match_address
argument_list|(
name|local_addresses
argument_list|,
name|ina
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ime
operator|=
name|new_ip_match_pattern
argument_list|(
name|ina
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|add_to_ip_match_list
argument_list|(
name|local_addresses
argument_list|,
name|ime
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Get interface flags. 		 */
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"get interface flags: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|ifreq
operator|.
name|ifr_flags
operator|&
name|IFF_POINTOPOINT
operator|)
condition|)
block|{
comment|/* 			 * The local network for a PPP link is just the 			 * two ends of the link, so for each endpoint we 			 * add a pattern that will only match the endpoint. 			 */
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFDSTADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"get dst addr: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mask
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_BROADCAST
argument_list|)
expr_stmt|;
comment|/* 			 * Our end. 			 * 			 * Only add it if we haven't seen it before. 			 */
if|if
condition|(
name|ip_match_network
argument_list|(
name|local_networks
argument_list|,
name|ina
argument_list|,
name|mask
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ime
operator|=
name|new_ip_match_pattern
argument_list|(
name|ina
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|add_to_ip_match_list
argument_list|(
name|local_networks
argument_list|,
name|ime
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * The other end. 			 */
name|ina
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_addr
operator|)
operator|->
name|sin_addr
expr_stmt|;
comment|/* 			 * Only add it if we haven't seen it before. 			 */
if|if
condition|(
name|ip_match_network
argument_list|(
name|local_networks
argument_list|,
name|ina
argument_list|,
name|mask
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ime
operator|=
name|new_ip_match_pattern
argument_list|(
name|ina
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|add_to_ip_match_list
argument_list|(
name|local_networks
argument_list|,
name|ime
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * Add this interface's network and netmask to the 			 * list of local networks. 			 */
ifdef|#
directive|ifdef
name|SIOCGIFNETMASK
comment|/* XXX */
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFNETMASK
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"get netmask: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * Use ina_get because the ifreq structure might not 			 * be aligned. 			 */
name|mask_ptr
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_addr
operator|)
operator|->
name|sin_addr
expr_stmt|;
name|mask
operator|=
name|ina_get
argument_list|(
name|mask_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|mask
operator|=
name|net_mask
argument_list|(
name|ina
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ina
operator|.
name|s_addr
operator|&=
name|mask
operator|.
name|s_addr
expr_stmt|;
comment|/* make network address */
comment|/* 			 * Only add it if we haven't seen it before. 			 */
if|if
condition|(
name|ip_match_network
argument_list|(
name|local_networks
argument_list|,
name|ina
argument_list|,
name|mask
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ime
operator|=
name|new_ip_match_mask
argument_list|(
name|ina
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|add_to_ip_match_list
argument_list|(
name|local_networks
argument_list|,
name|ime
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|7
argument_list|,
literal|"local addresses:"
argument_list|)
expr_stmt|;
name|dprint_ip_match_list
argument_list|(
name|ns_log_default
argument_list|,
name|local_addresses
argument_list|,
literal|2
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|7
argument_list|,
literal|"local networks:"
argument_list|)
expr_stmt|;
name|dprint_ip_match_list
argument_list|(
name|ns_log_default
argument_list|,
name|local_networks
argument_list|,
literal|2
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 	 * now go through the iflist and delete anything that 	 * does not have the current generation number.  this is 	 * how we catch interfaces that go away or change their 	 * addresses.  note that 0.0.0.0 is the wildcard element 	 * and should never be deleted by this code. 	 */
name|dq_remove_gen
argument_list|(
name|my_generation
argument_list|)
expr_stmt|;
if|if
condition|(
name|EMPTY
argument_list|(
name|iflist
argument_list|)
condition|)
name|ns_warning
argument_list|(
name|ns_log_default
argument_list|,
literal|"not listening on any interfaces"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* opensocket_d(ifp)  *	Open datagram socket bound to interface address.  * Returns:  *	0 on success.  *	-1 on failure.  */
end_comment

begin_function
specifier|static
name|int
name|opensocket_d
parameter_list|(
name|interface
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|sockaddr_in
name|nsa
decl_stmt|;
specifier|const
name|int
name|on
init|=
literal|1
decl_stmt|;
name|int
name|m
decl_stmt|,
name|n
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|memset
argument_list|(
operator|&
name|nsa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|nsa
argument_list|)
expr_stmt|;
name|nsa
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|nsa
operator|.
name|sin_addr
operator|=
name|ifp
operator|->
name|addr
expr_stmt|;
name|nsa
operator|.
name|sin_port
operator|=
name|ifp
operator|->
name|port
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|dfd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"socket(SOCK_DGRAM): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|F_DUPFD
comment|/* XXX */
comment|/* 	 * Leave a space for stdio to work in. 	 */
if|if
condition|(
operator|(
name|fd
operator|=
name|fcntl
argument_list|(
name|ifp
operator|->
name|dfd
argument_list|,
name|F_DUPFD
argument_list|,
literal|20
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|ifp
operator|->
name|dfd
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|dfd
operator|=
name|fd
expr_stmt|;
block|}
else|else
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"fcntl(dfd, F_DUPFD, 20): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"ifp->addr %s d_dfd %d"
argument_list|,
name|sin_ntoa
argument_list|(
name|nsa
argument_list|)
argument_list|,
name|ifp
operator|->
name|dfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|ifp
operator|->
name|dfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"setsockopt(REUSEADDR): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX press on regardless, this is not too serious. */
block|}
ifdef|#
directive|ifdef
name|SO_RCVBUF
comment|/* XXX */
name|m
operator|=
sizeof|sizeof
name|n
expr_stmt|;
if|if
condition|(
operator|(
name|getsockopt
argument_list|(
name|ifp
operator|->
name|dfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVBUF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|n
argument_list|,
operator|&
name|m
argument_list|)
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|m
operator|==
sizeof|sizeof
name|n
operator|)
operator|&&
operator|(
name|n
operator|<
name|rbufsize
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|ifp
operator|->
name|dfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVBUF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rbufsize
argument_list|,
sizeof|sizeof
argument_list|(
name|rbufsize
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SO_RCVBUF */
if|if
condition|(
name|bind
argument_list|(
name|ifp
operator|->
name|dfd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|nsa
argument_list|,
sizeof|sizeof
name|nsa
argument_list|)
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"bind(dfd=%d, %s): %s"
argument_list|,
name|ifp
operator|->
name|dfd
argument_list|,
name|sin_ntoa
argument_list|(
name|nsa
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|evSelectFD
argument_list|(
name|ev
argument_list|,
name|ifp
operator|->
name|dfd
argument_list|,
name|EV_READ
argument_list|,
name|datagram_read
argument_list|,
name|ifp
argument_list|,
operator|&
name|ifp
operator|->
name|evID_d
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"evSelectFD(dfd=%d): %s"
argument_list|,
name|ifp
operator|->
name|dfd
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ifp
operator|->
name|flags
operator||=
name|INTERFACE_FILE_VALID
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* opensocket_s(ifp)  *	Open stream (listener) socket bound to interface address.  * Returns:  *	0 on success.  *	-1 on failure.  */
end_comment

begin_function
specifier|static
name|int
name|opensocket_s
parameter_list|(
name|interface
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|sockaddr_in
name|nsa
decl_stmt|;
specifier|const
name|int
name|on
init|=
literal|1
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|memset
argument_list|(
operator|&
name|nsa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|nsa
argument_list|)
expr_stmt|;
name|nsa
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|nsa
operator|.
name|sin_addr
operator|=
name|ifp
operator|->
name|addr
expr_stmt|;
name|nsa
operator|.
name|sin_port
operator|=
name|ifp
operator|->
name|port
expr_stmt|;
comment|/* 	 * Open stream (listener) port. 	 */
name|n
operator|=
literal|0
expr_stmt|;
name|again
label|:
if|if
condition|(
operator|(
name|ifp
operator|->
name|sfd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"socket(SOCK_STREAM): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|F_DUPFD
comment|/* XXX */
comment|/* 	 * Leave a space for stdio to work in. 	 */
if|if
condition|(
operator|(
name|fd
operator|=
name|fcntl
argument_list|(
name|ifp
operator|->
name|sfd
argument_list|,
name|F_DUPFD
argument_list|,
literal|20
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|ifp
operator|->
name|sfd
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|sfd
operator|=
name|fd
expr_stmt|;
block|}
else|else
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"fcntl(sfd, F_DUPFD, 20): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|setsockopt
argument_list|(
name|ifp
operator|->
name|sfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
name|on
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"setsockopt(REUSEADDR): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Consider that your first warning of trouble to come. */
block|}
if|if
condition|(
name|bind
argument_list|(
name|ifp
operator|->
name|sfd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|nsa
argument_list|,
sizeof|sizeof
name|nsa
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EADDRINUSE
operator|||
operator|++
name|n
operator|>
literal|4
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EADDRINUSE
condition|)
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"There may be a name server already running on %s"
argument_list|,
name|sin_ntoa
argument_list|(
name|nsa
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"bind(sfd=%d, %s): %s"
argument_list|,
name|ifp
operator|->
name|sfd
argument_list|,
name|sin_ntoa
argument_list|(
name|nsa
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Retry opening the socket a few times */
name|close
argument_list|(
name|ifp
operator|->
name|sfd
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|sfd
operator|=
operator|-
literal|1
expr_stmt|;
name|sleep
argument_list|(
literal|30
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|evListen
argument_list|(
name|ev
argument_list|,
name|ifp
operator|->
name|sfd
argument_list|,
literal|5
comment|/*XXX*/
argument_list|,
name|stream_accept
argument_list|,
name|ifp
argument_list|,
operator|&
name|ifp
operator|->
name|evID_s
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"evListen(sfd=%d): %s"
argument_list|,
name|ifp
operator|->
name|sfd
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ifp
operator|->
name|flags
operator||=
name|INTERFACE_CONN_VALID
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* opensocket_f()  *	Open datagram socket bound to no particular interface; use for ns_forw  *	and sysquery.  */
end_comment

begin_function
name|void
name|opensocket_f
parameter_list|()
block|{
specifier|static
name|struct
name|sockaddr_in
name|prev_qsrc
decl_stmt|;
specifier|static
name|int
name|been_here
decl_stmt|;
specifier|static
name|interface
modifier|*
name|prev_ifp
decl_stmt|;
name|struct
name|sockaddr_in
name|nsa
decl_stmt|;
specifier|const
name|int
name|on
init|=
literal|1
decl_stmt|;
name|int
name|n
decl_stmt|,
name|need_close
decl_stmt|;
name|interface
modifier|*
name|ifp
decl_stmt|;
name|need_close
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|been_here
condition|)
block|{
if|if
condition|(
name|prev_ifp
operator|!=
name|NULL
condition|)
name|prev_ifp
operator|->
name|flags
operator|&=
operator|~
name|INTERFACE_FORWARDING
expr_stmt|;
elseif|else
if|if
condition|(
name|server_options
operator|->
name|query_source
operator|.
name|sin_port
operator|==
name|htons
argument_list|(
literal|0
argument_list|)
operator|||
name|prev_qsrc
operator|.
name|sin_addr
operator|.
name|s_addr
operator|!=
name|server_options
operator|->
name|query_source
operator|.
name|sin_addr
operator|.
name|s_addr
operator|||
name|prev_qsrc
operator|.
name|sin_port
operator|!=
name|server_options
operator|->
name|query_source
operator|.
name|sin_port
condition|)
name|need_close
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|ds
operator|=
operator|-
literal|1
expr_stmt|;
name|been_here
operator|=
literal|1
expr_stmt|;
name|INSIST
argument_list|(
name|server_options
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_close
condition|)
block|{
name|evDeselectFD
argument_list|(
name|ev
argument_list|,
name|ds_evID
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ds
argument_list|)
expr_stmt|;
name|ds
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 	 * If we're already listening on the query_source address and port, 	 * we don't need to open another socket.  We mark the interface, so 	 * we'll notice we're in trouble if it goes away. 	 */
name|ifp
operator|=
name|if_find
argument_list|(
name|server_options
operator|->
name|query_source
operator|.
name|sin_addr
argument_list|,
name|server_options
operator|->
name|query_source
operator|.
name|sin_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|ifp
operator|->
name|flags
operator||=
name|INTERFACE_FORWARDING
expr_stmt|;
name|prev_ifp
operator|=
name|ifp
expr_stmt|;
name|ds
operator|=
name|ifp
operator|->
name|dfd
expr_stmt|;
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"forwarding source address is %s"
argument_list|,
name|sin_ntoa
argument_list|(
name|server_options
operator|->
name|query_source
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If we're already using the correct query source, we're done. 	 */
if|if
condition|(
name|ds
operator|>=
literal|0
condition|)
return|return;
name|prev_qsrc
operator|=
name|server_options
operator|->
name|query_source
expr_stmt|;
name|prev_ifp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|ds
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"socket(SOCK_DGRAM): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|ds
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
name|on
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"setsockopt(REUSEADDR): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX press on regardless, this is not too serious. */
block|}
if|if
condition|(
name|bind
argument_list|(
name|ds
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|server_options
operator|->
name|query_source
argument_list|,
sizeof|sizeof
name|server_options
operator|->
name|query_source
argument_list|)
operator|<
literal|0
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"opensocket_f: bind(%s): %s"
argument_list|,
name|sin_ntoa
argument_list|(
name|server_options
operator|->
name|query_source
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
sizeof|sizeof
name|nsa
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|ds
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|nsa
argument_list|,
operator|&
name|n
argument_list|)
operator|<
literal|0
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"opensocket_f: getsockaddr: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"fwd ds %d addr %s"
argument_list|,
name|ds
argument_list|,
name|sin_ntoa
argument_list|(
name|nsa
argument_list|)
argument_list|)
expr_stmt|;
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"Forwarding source address is %s"
argument_list|,
name|sin_ntoa
argument_list|(
name|nsa
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|evSelectFD
argument_list|(
name|ev
argument_list|,
name|ds
argument_list|,
name|EV_READ
argument_list|,
name|datagram_read
argument_list|,
name|NULL
argument_list|,
operator|&
name|ds_evID
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"evSelectFD(fd %d): %s"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ds
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX: should probably use a different FileFunc that only accepts 	 *	responses, since requests on this socket make no sense. 	 */
block|}
end_function

begin_function
specifier|static
name|void
name|setdebug
parameter_list|(
name|int
name|new_debug
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|int
name|old_debug
decl_stmt|;
if|if
condition|(
operator|!
name|new_debug
condition|)
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"Debug off"
argument_list|)
expr_stmt|;
name|old_debug
operator|=
name|debug
expr_stmt|;
name|debug
operator|=
name|new_debug
expr_stmt|;
name|log_option
argument_list|(
name|log_ctx
argument_list|,
name|LOG_OPTION_DEBUG
argument_list|,
name|debug
argument_list|)
expr_stmt|;
name|log_option
argument_list|(
name|log_ctx
argument_list|,
name|LOG_OPTION_LEVEL
argument_list|,
name|debug
argument_list|)
expr_stmt|;
name|evSetDebug
argument_list|(
name|ev
argument_list|,
name|debug
argument_list|,
name|log_get_stream
argument_list|(
name|eventlib_channel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
if|if
condition|(
operator|!
name|old_debug
condition|)
name|open_special_channels
argument_list|()
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"Debug level %d"
argument_list|,
name|debug
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|old_debug
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"Version = %s"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"conffile = %s"
argument_list|,
name|conffile
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|SIG_FN
name|onhup
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|ns_need
argument_list|(
name|MAIN_NEED_RELOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|SIG_FN
name|onintr
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|ns_need
argument_list|(
name|MAIN_NEED_EXIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|SIG_FN
name|setdumpflg
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|ns_need
argument_list|(
name|MAIN_NEED_DUMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|static
name|SIG_FN
name|setIncrDbgFlg
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|desired_debug
operator|++
expr_stmt|;
name|ns_need
argument_list|(
name|MAIN_NEED_DEBUG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|SIG_FN
name|setNoDbgFlg
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|desired_debug
operator|=
literal|0
expr_stmt|;
name|ns_need
argument_list|(
name|MAIN_NEED_DEBUG
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*DEBUG*/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|QRYLOG
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
end_if

begin_function
specifier|static
name|SIG_FN
name|setQrylogFlg
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|ns_need
argument_list|(
name|MAIN_NEED_QRYLOG
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*QRYLOG&& SIGWINCH*/
end_comment

begin_function
specifier|static
name|SIG_FN
name|setstatsflg
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|ns_need
argument_list|(
name|MAIN_NEED_STATSDUMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|SIG_FN
name|discard_pipe
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SIGPIPE_ONE_SHOT
name|int
name|saved_errno
init|=
name|errno
decl_stmt|;
name|set_signal_handler
argument_list|(
name|SIGPIPE
argument_list|,
name|discard_pipe
argument_list|)
expr_stmt|;
name|errno
operator|=
name|saved_errno
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ** Routines for managing stream queue */
end_comment

begin_function
specifier|static
name|struct
name|qstream
modifier|*
name|sq_add
parameter_list|()
block|{
name|struct
name|qstream
modifier|*
name|sqp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sqp
operator|=
operator|(
expr|struct
name|qstream
operator|*
operator|)
name|memget
argument_list|(
sizeof|sizeof
expr|*
name|sqp
argument_list|)
operator|)
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"sq_add: memget: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|memset
argument_list|(
name|sqp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|sqp
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"sq_add(%#lx)"
argument_list|,
operator|(
name|u_long
operator|)
name|sqp
argument_list|)
expr_stmt|;
name|sqp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* XXX should init other fields too? */
name|sqp
operator|->
name|s_next
operator|=
name|streamq
expr_stmt|;
name|streamq
operator|=
name|sqp
expr_stmt|;
return|return
operator|(
name|sqp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* sq_remove(qp)  *	remove stream queue structure `qp'.  *	no current queries may refer to this stream when it is removed.  * side effects:  *	memory is deallocated.  sockets are closed.  lists are relinked.  */
end_comment

begin_function
name|void
name|sq_remove
parameter_list|(
name|struct
name|qstream
modifier|*
name|qp
parameter_list|)
block|{
name|struct
name|qstream
modifier|*
name|qsp
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|2
argument_list|,
literal|"sq_remove(%#lx, %d) rfcnt=%d"
argument_list|,
operator|(
name|u_long
operator|)
name|qp
argument_list|,
name|qp
operator|->
name|s_rfd
argument_list|,
name|qp
operator|->
name|s_refcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|s_wbuf
operator|!=
name|NULL
condition|)
block|{
name|memput
argument_list|(
name|qp
operator|->
name|s_wbuf
argument_list|,
name|qp
operator|->
name|s_wbuf_end
operator|-
name|qp
operator|->
name|s_wbuf
argument_list|)
expr_stmt|;
name|qp
operator|->
name|s_wbuf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|qp
operator|->
name|flags
operator|&
name|STREAM_MALLOC
condition|)
name|memput
argument_list|(
name|qp
operator|->
name|s_buf
argument_list|,
name|qp
operator|->
name|s_bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|flags
operator|&
name|STREAM_READ_EV
condition|)
name|INSIST_ERR
argument_list|(
name|evCancelRW
argument_list|(
name|ev
argument_list|,
name|qp
operator|->
name|evID_r
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|flags
operator|&
name|STREAM_WRITE_EV
condition|)
name|INSIST_ERR
argument_list|(
name|evDeselectFD
argument_list|(
name|ev
argument_list|,
name|qp
operator|->
name|evID_w
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|flags
operator|&
name|STREAM_CONNECT_EV
condition|)
name|INSIST_ERR
argument_list|(
name|evCancelConn
argument_list|(
name|ev
argument_list|,
name|qp
operator|->
name|evID_c
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|flags
operator|&
name|STREAM_AXFR
condition|)
name|ns_freexfr
argument_list|(
name|qp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|qp
operator|->
name|s_rfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|==
name|streamq
condition|)
name|streamq
operator|=
name|qp
operator|->
name|s_next
expr_stmt|;
else|else
block|{
for|for
control|(
name|qsp
operator|=
name|streamq
init|;
name|qsp
operator|&&
operator|(
name|qsp
operator|->
name|s_next
operator|!=
name|qp
operator|)
condition|;
name|qsp
operator|=
name|qsp
operator|->
name|s_next
control|)
operator|(
name|void
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|qsp
condition|)
name|qsp
operator|->
name|s_next
operator|=
name|qp
operator|->
name|s_next
expr_stmt|;
block|}
name|memput
argument_list|(
name|qp
argument_list|,
sizeof|sizeof
expr|*
name|qp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* void  * sq_flush(allbut)  *	call sq_remove() on all open streams except `allbut'  * side effects:  *	global list `streamq' modified  * idiocy:  *	is N^2 due to the scan inside of sq_remove()  */
end_comment

begin_function
name|void
name|sq_flush
parameter_list|(
name|struct
name|qstream
modifier|*
name|allbut
parameter_list|)
block|{
name|struct
name|qstream
modifier|*
name|sp
decl_stmt|,
modifier|*
name|spnext
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|streamq
init|;
name|sp
operator|!=
name|NULL
condition|;
name|sp
operator|=
name|spnext
control|)
block|{
name|spnext
operator|=
name|sp
operator|->
name|s_next
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
name|allbut
condition|)
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* int  * sq_openw(qs, buflen)  *	add a write buffer to a stream  * return:  *	0 = success  *	-1 = failure (check errno)  */
end_comment

begin_function
name|int
name|sq_openw
parameter_list|(
name|struct
name|qstream
modifier|*
name|qs
parameter_list|,
name|int
name|buflen
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SO_LINGER
comment|/* XXX */
specifier|static
specifier|const
name|struct
name|linger
name|ll
init|=
block|{
literal|1
block|,
literal|120
block|}
decl_stmt|;
endif|#
directive|endif
name|INSIST
argument_list|(
name|qs
operator|->
name|s_wbuf
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|qs
operator|->
name|s_wbuf
operator|=
operator|(
name|u_char
operator|*
operator|)
name|memget
argument_list|(
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|qs
operator|->
name|s_wbuf
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|qs
operator|->
name|s_wbuf_send
operator|=
name|qs
operator|->
name|s_wbuf
expr_stmt|;
name|qs
operator|->
name|s_wbuf_free
operator|=
name|qs
operator|->
name|s_wbuf
expr_stmt|;
name|qs
operator|->
name|s_wbuf_end
operator|=
name|qs
operator|->
name|s_wbuf
operator|+
name|buflen
expr_stmt|;
ifdef|#
directive|ifdef
name|SO_LINGER
comment|/* XXX */
comment|/* kernels that map pages for IO end up failing if the pipe is full 	 * at exit and we take away the final buffer.  this is really a kernel 	 * bug but it's harmless on systems that are not broken, so... 	 */
name|setsockopt
argument_list|(
name|qs
operator|->
name|s_rfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_LINGER
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ll
argument_list|,
sizeof|sizeof
name|ll
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* static void  * sq_dowrite(qs)  *	try to submit data to the system, remove it from our queue.  */
end_comment

begin_function
specifier|static
name|int
name|sq_dowrite
parameter_list|(
name|struct
name|qstream
modifier|*
name|qs
parameter_list|)
block|{
if|if
condition|(
name|qs
operator|->
name|s_wbuf_free
operator|>
name|qs
operator|->
name|s_wbuf_send
condition|)
block|{
name|int
name|n
init|=
name|write
argument_list|(
name|qs
operator|->
name|s_rfd
argument_list|,
name|qs
operator|->
name|s_wbuf_send
argument_list|,
name|qs
operator|->
name|s_wbuf_free
operator|-
name|qs
operator|->
name|s_wbuf_send
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
operator|&&
name|errno
operator|!=
name|EAGAIN
if|#
directive|if
operator|(
name|EWOULDBLOCK
operator|!=
name|EAGAIN
operator|)
operator|&&
name|errno
operator|!=
name|EWOULDBLOCK
endif|#
directive|endif
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|qs
operator|->
name|s_wbuf_send
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|qs
operator|->
name|s_wbuf_free
operator|>
name|qs
operator|->
name|s_wbuf_send
condition|)
block|{
comment|/* XXX: need some kind of delay here during which the 			 *	socket will be deselected so we don't spin. 			 */
name|n
operator|=
name|qs
operator|->
name|s_wbuf_free
operator|-
name|qs
operator|->
name|s_wbuf_send
expr_stmt|;
name|memmove
argument_list|(
name|qs
operator|->
name|s_wbuf
argument_list|,
name|qs
operator|->
name|s_wbuf_send
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|qs
operator|->
name|s_wbuf_send
operator|=
name|qs
operator|->
name|s_wbuf
expr_stmt|;
name|qs
operator|->
name|s_wbuf_free
operator|=
name|qs
operator|->
name|s_wbuf
operator|+
name|n
expr_stmt|;
block|}
block|}
if|if
condition|(
name|qs
operator|->
name|s_wbuf_free
operator|==
name|qs
operator|->
name|s_wbuf_send
condition|)
name|qs
operator|->
name|s_wbuf_free
operator|=
name|qs
operator|->
name|s_wbuf_send
operator|=
name|qs
operator|->
name|s_wbuf
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* void  * sq_flushw(qs)  *	called when the socket becomes writable and we want to flush our  *	buffers and the system's socket buffers.  use as a closure with  *	sq_writeh().  */
end_comment

begin_function
name|void
name|sq_flushw
parameter_list|(
name|struct
name|qstream
modifier|*
name|qs
parameter_list|)
block|{
if|if
condition|(
name|qs
operator|->
name|s_wbuf_free
operator|==
name|qs
operator|->
name|s_wbuf_send
condition|)
block|{
name|sq_writeh
argument_list|(
name|qs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sq_done
argument_list|(
name|qs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* static void  * sq_writable(ctx, uap, fd, evmask)  *	glue between eventlib closures and qstream closures  */
end_comment

begin_function
specifier|static
name|void
name|sq_writable
parameter_list|(
name|evContext
name|ctx
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|evmask
parameter_list|)
block|{
name|struct
name|qstream
modifier|*
name|qs
init|=
name|uap
decl_stmt|;
name|INSIST
argument_list|(
name|evmask
operator|&
name|EV_WRITE
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|fd
operator|==
name|qs
operator|->
name|s_rfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sq_dowrite
argument_list|(
name|qs
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sq_remove
argument_list|(
name|qs
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|qs
operator|->
name|s_wbuf_closure
operator|&&
name|qs
operator|->
name|s_wbuf_end
operator|-
name|qs
operator|->
name|s_wbuf_free
operator|>=
name|HFIXEDSZ
operator|+
literal|2
condition|)
comment|/* XXX guess */
call|(
modifier|*
name|qs
operator|->
name|s_wbuf_closure
call|)
argument_list|(
name|qs
argument_list|)
expr_stmt|;
if|if
condition|(
name|sq_dowrite
argument_list|(
name|qs
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sq_remove
argument_list|(
name|qs
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* int  * sq_writeh(qs, closure)  *	register a closure to be called when a stream becomes writable  * return:  *	0 = success  *	-1 = failure (check errno)  */
end_comment

begin_function
name|int
name|sq_writeh
parameter_list|(
name|struct
name|qstream
modifier|*
name|qs
parameter_list|,
name|sq_closure
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
condition|)
block|{
if|if
condition|(
operator|!
name|qs
operator|->
name|s_wbuf_closure
condition|)
block|{
if|if
condition|(
name|evSelectFD
argument_list|(
name|ev
argument_list|,
name|qs
operator|->
name|s_rfd
argument_list|,
name|EV_WRITE
argument_list|,
name|sq_writable
argument_list|,
name|qs
argument_list|,
operator|&
name|qs
operator|->
name|evID_w
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|qs
operator|->
name|flags
operator||=
name|STREAM_WRITE_EV
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|evDeselectFD
argument_list|(
name|ev
argument_list|,
name|qs
operator|->
name|evID_w
argument_list|)
expr_stmt|;
name|qs
operator|->
name|flags
operator|&=
operator|~
name|STREAM_WRITE_EV
expr_stmt|;
block|}
name|qs
operator|->
name|s_wbuf_closure
operator|=
name|c
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* int  * sq_write(qs, buf, len)  *	queue a message onto the stream, prepended by a two byte length field  * return:  *	0 = success  *	-1 = failure (check errno; E2BIG means we can't handle this right now)  */
end_comment

begin_function
name|int
name|sq_write
parameter_list|(
name|struct
name|qstream
modifier|*
name|qs
parameter_list|,
specifier|const
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|INSIST
argument_list|(
name|qs
operator|->
name|s_wbuf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|NS_INT16SZ
operator|+
name|len
operator|>
name|qs
operator|->
name|s_wbuf_end
operator|-
name|qs
operator|->
name|s_wbuf_free
condition|)
block|{
if|if
condition|(
name|sq_dowrite
argument_list|(
name|qs
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|NS_INT16SZ
operator|+
name|len
operator|>
name|qs
operator|->
name|s_wbuf_end
operator|-
name|qs
operator|->
name|s_wbuf_free
condition|)
block|{
name|errno
operator|=
name|E2BIG
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|__putshort
argument_list|(
name|len
argument_list|,
name|qs
operator|->
name|s_wbuf_free
argument_list|)
expr_stmt|;
name|qs
operator|->
name|s_wbuf_free
operator|+=
name|NS_INT16SZ
expr_stmt|;
name|memcpy
argument_list|(
name|qs
operator|->
name|s_wbuf_free
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|qs
operator|->
name|s_wbuf_free
operator|+=
name|len
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* int  * sq_here(sp)  *	determine whether stream 'sp' is still on the streamq  * return:  *	boolean: is it here?  */
end_comment

begin_function
specifier|static
name|int
name|sq_here
parameter_list|(
name|struct
name|qstream
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|qstream
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|streamq
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|s_next
control|)
if|if
condition|(
name|t
operator|==
name|sp
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initiate query on stream;  * mark as referenced and stop selecting for input.  */
end_comment

begin_function
specifier|static
name|void
name|sq_query
parameter_list|(
name|struct
name|qstream
modifier|*
name|sp
parameter_list|)
block|{
name|sp
operator|->
name|s_refcnt
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Note that the current request on a stream has completed,  * and that we should continue looking for requests on the stream.  */
end_comment

begin_function
name|void
name|sq_done
parameter_list|(
name|struct
name|qstream
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|iovec
name|iov
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_wbuf
operator|!=
name|NULL
condition|)
block|{
name|memput
argument_list|(
name|sp
operator|->
name|s_wbuf
argument_list|,
name|sp
operator|->
name|s_wbuf_end
operator|-
name|sp
operator|->
name|s_wbuf
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_wbuf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|flags
operator|&
name|STREAM_AXFR
condition|)
name|ns_freexfr
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_refcnt
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|s_time
operator|=
name|tt
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|flags
operator|&
name|STREAM_DONE_CLOSE
condition|)
block|{
comment|/* XXX */
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
name|iov
operator|=
name|evConsIovec
argument_list|(
name|sp
operator|->
name|s_temp
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|evRead
argument_list|(
name|ev
argument_list|,
name|sp
operator|->
name|s_rfd
argument_list|,
operator|&
name|iov
argument_list|,
literal|1
argument_list|,
name|stream_getlen
argument_list|,
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|evID_r
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"evRead(fd %d): %s"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sp
operator|->
name|s_rfd
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|flags
operator||=
name|STREAM_READ_EV
expr_stmt|;
block|}
end_function

begin_comment
comment|/* void  * dq_remove_gen(gen)  *	close/deallocate all the udp sockets (except 0.0.0.0) which are  *	not from the current generation.  * side effects:  *	global list `iflist' is modified.  */
end_comment

begin_function
name|void
name|dq_remove_gen
parameter_list|(
name|time_t
name|gen
parameter_list|)
block|{
name|interface
modifier|*
name|this
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|this
operator|=
name|HEAD
argument_list|(
name|iflist
argument_list|)
init|;
name|this
operator|!=
name|NULL
condition|;
name|this
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT
argument_list|(
name|this
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|->
name|gen
operator|!=
name|gen
operator|&&
name|ina_hlong
argument_list|(
name|this
operator|->
name|addr
argument_list|)
operator|!=
name|INADDR_ANY
condition|)
name|dq_remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* void  * dq_remove_all()  *	close/deallocate all interfaces.  * side effects:  *	global list `iflist' is modified.  */
end_comment

begin_function
name|void
name|dq_remove_all
parameter_list|()
block|{
name|interface
modifier|*
name|this
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|this
operator|=
name|HEAD
argument_list|(
name|iflist
argument_list|)
init|;
name|this
operator|!=
name|NULL
condition|;
name|this
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT
argument_list|(
name|this
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/*  		 * Clear the forwarding flag so we don't panic the server. 		 */
name|this
operator|->
name|flags
operator|&=
operator|~
name|INTERFACE_FORWARDING
expr_stmt|;
name|dq_remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* void  * dq_remove(interface *this)  *	close/deallocate an interface's sockets.  called on errors  *	or if the interface disappears.  * side effects:  *	global list `iflist' is modified.  */
end_comment

begin_function
specifier|static
name|void
name|dq_remove
parameter_list|(
name|interface
modifier|*
name|this
parameter_list|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"deleting interface [%s].%u"
argument_list|,
name|inet_ntoa
argument_list|(
name|this
operator|->
name|addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|this
operator|->
name|port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|this
operator|->
name|flags
operator|&
name|INTERFACE_FORWARDING
operator|)
operator|!=
literal|0
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|0
argument_list|,
literal|"forwarding interface [%s].%u gone"
argument_list|,
name|inet_ntoa
argument_list|(
name|this
operator|->
name|addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|this
operator|->
name|port
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Deallocate fields. */
if|if
condition|(
operator|(
name|this
operator|->
name|flags
operator|&
name|INTERFACE_FILE_VALID
operator|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|evDeselectFD
argument_list|(
name|ev
argument_list|,
name|this
operator|->
name|evID_d
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|->
name|dfd
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|this
operator|->
name|dfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|this
operator|->
name|flags
operator|&
name|INTERFACE_CONN_VALID
operator|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|evCancelConn
argument_list|(
name|ev
argument_list|,
name|this
operator|->
name|evID_s
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|->
name|sfd
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|this
operator|->
name|sfd
argument_list|)
expr_stmt|;
name|UNLINK
argument_list|(
name|iflist
argument_list|,
name|this
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|this
argument_list|,
sizeof|sizeof
expr|*
name|this
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* struct in_addr  * net_mask(ina)  *	makes a classful assumption in a classless world, and returns it.  */
end_comment

begin_function
name|struct
name|in_addr
name|net_mask
parameter_list|(
name|struct
name|in_addr
name|ina
parameter_list|)
block|{
name|u_long
name|hl
init|=
name|ina_hlong
argument_list|(
name|ina
argument_list|)
decl_stmt|;
name|struct
name|in_addr
name|ret
decl_stmt|;
if|if
condition|(
name|IN_CLASSA
argument_list|(
name|hl
argument_list|)
condition|)
name|hl
operator|=
name|IN_CLASSA_NET
expr_stmt|;
elseif|else
if|if
condition|(
name|IN_CLASSB
argument_list|(
name|hl
argument_list|)
condition|)
name|hl
operator|=
name|IN_CLASSB_NET
expr_stmt|;
elseif|else
if|if
condition|(
name|IN_CLASSC
argument_list|(
name|hl
argument_list|)
condition|)
name|hl
operator|=
name|IN_CLASSC_NET
expr_stmt|;
else|else
name|hl
operator|=
name|INADDR_BROADCAST
expr_stmt|;
name|ina_ulong
argument_list|(
name|ret
argument_list|)
operator|=
name|htonl
argument_list|(
name|hl
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* aIsUs(addr)  *	scan our list of interface addresses for "addr".  * returns:  *	0: address isn't one of our interfaces  *>0: address is one of our interfaces, or INADDR_ANY  */
end_comment

begin_function
name|int
name|aIsUs
parameter_list|(
name|struct
name|in_addr
name|addr
parameter_list|)
block|{
name|interface
modifier|*
name|ifp
decl_stmt|;
if|if
condition|(
name|ina_hlong
argument_list|(
name|addr
argument_list|)
operator|==
name|INADDR_ANY
operator|||
name|if_find
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* interface *  * if_find(addr, port)  *	scan our list of interface addresses for "addr" and port.  *      port == 0 means match any port  * returns:  *	pointer to interface with this address/port, or NULL if there isn't  *      one.  */
end_comment

begin_function
specifier|static
name|interface
modifier|*
name|if_find
parameter_list|(
name|struct
name|in_addr
name|addr
parameter_list|,
name|u_int16_t
name|port
parameter_list|)
block|{
name|interface
modifier|*
name|ifp
decl_stmt|;
for|for
control|(
name|ifp
operator|=
name|HEAD
argument_list|(
name|iflist
argument_list|)
init|;
name|ifp
operator|!=
name|NULL
condition|;
name|ifp
operator|=
name|NEXT
argument_list|(
name|ifp
argument_list|,
name|link
argument_list|)
control|)
if|if
condition|(
name|ina_equal
argument_list|(
name|addr
argument_list|,
name|ifp
operator|->
name|addr
argument_list|)
condition|)
if|if
condition|(
name|port
operator|==
literal|0
operator|||
name|ifp
operator|->
name|port
operator|==
name|port
condition|)
break|break;
return|return
operator|(
name|ifp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * These are here in case we ever want to get more clever, like perhaps  * using a bitmap to keep track of outstanding queries and a random  * allocation scheme to make it a little harder to predict them.  Note  * that the resolver will need the same protection so the cleverness  * should be put there rather than here; this is just an interface layer.  */
end_comment

begin_function
name|void
name|nsid_init
parameter_list|()
block|{
name|nsid_state
operator|=
name|res_randomid
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|u_int16_t
name|nsid_next
parameter_list|()
block|{
if|if
condition|(
name|nsid_state
operator|==
literal|65535
condition|)
name|nsid_state
operator|=
literal|0
expr_stmt|;
else|else
name|nsid_state
operator|++
expr_stmt|;
return|return
operator|(
name|nsid_state
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|deallocate_everything
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|write_open
argument_list|(
name|server_options
operator|->
name|memstats_filename
argument_list|)
expr_stmt|;
name|ns_freestats
argument_list|()
expr_stmt|;
name|qflush
argument_list|()
expr_stmt|;
name|sq_flush
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|free_addinfo
argument_list|()
expr_stmt|;
name|ns_shutdown
argument_list|()
expr_stmt|;
name|dq_remove_all
argument_list|()
expr_stmt|;
if|if
condition|(
name|local_addresses
operator|!=
name|NULL
condition|)
name|free_ip_match_list
argument_list|(
name|local_addresses
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_networks
operator|!=
name|NULL
condition|)
name|free_ip_match_list
argument_list|(
name|local_networks
argument_list|)
expr_stmt|;
name|destroyservicelist
argument_list|()
expr_stmt|;
name|destroyprotolist
argument_list|()
expr_stmt|;
name|shutdown_logging
argument_list|()
expr_stmt|;
name|evDestroy
argument_list|(
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
name|conffile
operator|!=
name|NULL
condition|)
name|freestr
argument_list|(
name|conffile
argument_list|)
expr_stmt|;
if|if
condition|(
name|user_name
operator|!=
name|NULL
condition|)
name|freestr
argument_list|(
name|user_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|group_name
operator|!=
name|NULL
condition|)
name|freestr
argument_list|(
name|group_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|chroot_dir
operator|!=
name|NULL
condition|)
name|freestr
argument_list|(
name|chroot_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
block|{
name|memstats
argument_list|(
name|f
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ns_exit
parameter_list|(
name|void
parameter_list|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"named shutting down"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND_UPDATE
name|dynamic_about_to_exit
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|server_options
operator|&&
name|server_options
operator|->
name|pid_filename
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|server_options
operator|->
name|pid_filename
argument_list|)
expr_stmt|;
name|ns_logstats
argument_list|(
name|ev
argument_list|,
name|NULL
argument_list|,
name|evNowTime
argument_list|()
argument_list|,
name|evConsTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NS_OPTION_P
argument_list|(
name|OPTION_DEALLOC_ON_EXIT
argument_list|)
condition|)
name|deallocate_everything
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|use_desired_debug
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|sigset_t
name|set
decl_stmt|;
name|int
name|bad
decl_stmt|;
comment|/* protect against race conditions by blocking debugging signals */
if|if
condition|(
name|sigemptyset
argument_list|(
operator|&
name|set
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_os
argument_list|,
literal|"sigemptyset failed in use_desired_debug: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGUSR1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_os
argument_list|,
literal|"sigaddset SIGUSR1 failed in use_desired_debug: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGUSR2
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_os
argument_list|,
literal|"sigaddset SIGUSR2 failed in use_desired_debug: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|set
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_os
argument_list|,
literal|"sigprocmask to block USR1 and USR2 failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|setdebug
argument_list|(
name|desired_debug
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigprocmask
argument_list|(
name|SIG_UNBLOCK
argument_list|,
operator|&
name|set
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|ns_error
argument_list|(
name|ns_log_os
argument_list|,
literal|"sigprocmask to unblock USR1 and USR2 failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|toggle_qrylog
parameter_list|(
name|void
parameter_list|)
block|{
name|qrylog
operator|=
operator|!
name|qrylog
expr_stmt|;
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"query log %s\n"
argument_list|,
name|qrylog
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BIND_NOTIFY
end_ifdef

begin_function
specifier|static
name|void
name|do_notify_after_load
parameter_list|(
name|void
parameter_list|)
block|{
name|evDo
argument_list|(
name|ev
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|notify_after_load
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This is a functional interface to the global needs and options.  */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
name|need_handler
block|{
name|int
name|need
decl_stmt|;
name|void
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
block|}
name|need_handlers
index|[]
init|=
block|{
block|{
name|MAIN_NEED_RELOAD
block|,
name|ns_reload
block|}
block|,
block|{
name|MAIN_NEED_MAINT
block|,
name|ns_maint
block|}
block|,
block|{
name|MAIN_NEED_ENDXFER
block|,
name|endxfer
block|}
block|,
block|{
name|MAIN_NEED_ZONELOAD
block|,
name|loadxfer
block|}
block|,
block|{
name|MAIN_NEED_DUMP
block|,
name|doadump
block|}
block|,
block|{
name|MAIN_NEED_STATSDUMP
block|,
name|ns_stats
block|}
block|,
block|{
name|MAIN_NEED_EXIT
block|,
name|ns_exit
block|}
block|,
block|{
name|MAIN_NEED_QRYLOG
block|,
name|toggle_qrylog
block|}
block|,
block|{
name|MAIN_NEED_DEBUG
block|,
name|use_desired_debug
block|}
block|,
ifdef|#
directive|ifdef
name|BIND_NOTIFY
block|{
name|MAIN_NEED_NOTIFY
block|,
name|do_notify_after_load
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_function
name|void
name|ns_setoption
parameter_list|(
name|int
name|option
parameter_list|)
block|{
name|ns_warning
argument_list|(
name|ns_log_default
argument_list|,
literal|"used obsolete ns_setoption(%d)"
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ns_need
parameter_list|(
name|int
name|need
parameter_list|)
block|{
name|needs
operator||=
name|need
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ns_need_p
parameter_list|(
name|int
name|need
parameter_list|)
block|{
return|return
operator|(
operator|(
name|needs
operator|&
name|need
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ns_handle_needs
parameter_list|()
block|{
specifier|const
name|struct
name|need_handler
modifier|*
name|nhp
decl_stmt|;
for|for
control|(
name|nhp
operator|=
name|need_handlers
init|;
name|nhp
operator|->
name|need
operator|&&
name|nhp
operator|->
name|handler
condition|;
name|nhp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|needs
operator|&
name|nhp
operator|->
name|need
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Turn off flag first, handler might turn it back on. 			 */
name|needs
operator|&=
operator|~
name|nhp
operator|->
name|need
expr_stmt|;
call|(
modifier|*
name|nhp
operator|->
name|handler
call|)
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|writestream
parameter_list|(
name|struct
name|qstream
modifier|*
name|sp
parameter_list|,
specifier|const
name|u_char
modifier|*
name|msg
parameter_list|,
name|int
name|msglen
parameter_list|)
block|{
if|if
condition|(
name|sq_openw
argument_list|(
name|sp
argument_list|,
name|msglen
operator|+
name|INT16SZ
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sq_write
argument_list|(
name|sp
argument_list|,
name|msg
argument_list|,
name|msglen
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sq_remove
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
name|sq_writeh
argument_list|(
name|sp
argument_list|,
name|sq_flushw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_signal_handler
parameter_list|(
name|int
name|sig
parameter_list|,
name|SIG_FN
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|()
parameter_list|)
block|{
name|struct
name|sigaction
name|sa
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|sa
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sa_handler
operator|=
name|handler
expr_stmt|;
if|if
condition|(
name|sigemptyset
argument_list|(
operator|&
name|sa
operator|.
name|sa_mask
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_os
argument_list|,
literal|"sigemptyset failed in set_signal_handler(%d): %s"
argument_list|,
name|sig
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sigaction
argument_list|(
name|sig
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|ns_error
argument_list|(
name|ns_log_os
argument_list|,
literal|"sigaction failed in set_signal_handler(%d): %s"
argument_list|,
name|sig
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_signals
parameter_list|()
block|{
name|set_signal_handler
argument_list|(
name|SIGINT
argument_list|,
name|setdumpflg
argument_list|)
expr_stmt|;
name|set_signal_handler
argument_list|(
name|SIGILL
argument_list|,
name|setstatsflg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|set_signal_handler
argument_list|(
name|SIGUSR1
argument_list|,
name|setIncrDbgFlg
argument_list|)
expr_stmt|;
name|set_signal_handler
argument_list|(
name|SIGUSR2
argument_list|,
name|setNoDbgFlg
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|set_signal_handler
argument_list|(
name|SIGHUP
argument_list|,
name|onhup
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|&&
name|defined
argument_list|(
name|QRYLOG
argument_list|)
comment|/* XXX */
name|set_signal_handler
argument_list|(
name|SIGWINCH
argument_list|,
name|setQrylogFlg
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|set_signal_handler
argument_list|(
name|SIGCHLD
argument_list|,
name|reapchild
argument_list|)
expr_stmt|;
name|set_signal_handler
argument_list|(
name|SIGPIPE
argument_list|,
name|discard_pipe
argument_list|)
expr_stmt|;
name|set_signal_handler
argument_list|(
name|SIGTERM
argument_list|,
name|onintr
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SIGXFSZ
argument_list|)
comment|/* XXX */
comment|/* Wierd DEC Hesiodism, harmless. */
name|set_signal_handler
argument_list|(
name|SIGXFSZ
argument_list|,
name|onhup
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|only_digits
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|s
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

