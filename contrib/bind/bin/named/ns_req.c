begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ns_req.c	4.47 (Berkeley) 7/1/91"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: ns_req.c,v 8.46 1998/03/27 00:21:03 halley Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Copyright (c) 1986, 1988, 1990  *    The Regents of the University of California.  All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * 	This product includes software developed by the University of  * 	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1993 by Digital Equipment Corporation.  *   * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Digital Equipment Corporation not be used in advertising or  * publicity pertaining to distribution of the document or software without  * specific, written prior permission.  *   * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT  * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1995 by International Business Machines, Inc.  *  * International Business Machines, Inc. (hereinafter called IBM) grants  * permission under its copyrights to use, copy, modify, and distribute this  * Software with or without fee, provided that the above copyright notice and  * all paragraphs of this notice appear in all copies, and that the name of IBM  * not be used in connection with the marketing of any product incorporating  * the Software or modifications thereof, without specific, written prior  * permission.  *  * To the extent it has a right to do so, IBM grants an immunity from suit  * under its patents, if any, for the use, sale or manufacture of products to  * the extent that such products are used for performing Domain Name System  * dynamic updates in TCP/IP networks by means of the Software.  No immunity is  * granted for any product per se or for any other function of any product.  *  * THE SOFTWARE IS PROVIDED "AS IS", AND IBM DISCLAIMS ALL WARRANTIES,  * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  * PARTICULAR PURPOSE.  IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL,  * DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER ARISING  * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE, EVEN  * IF IBM IS APPRISED OF THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1996, 1997 by Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<isc/eventlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/logging.h>
end_include

begin_include
include|#
directive|include
file|<isc/memcluster.h>
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_include
include|#
directive|include
file|"named.h"
end_include

begin_struct
struct|struct
name|addinfo
block|{
name|char
modifier|*
name|a_dname
decl_stmt|;
comment|/* domain name */
name|char
modifier|*
name|a_rname
decl_stmt|;
comment|/* referred by */
name|u_int16_t
name|a_rtype
decl_stmt|;
comment|/* referred by */
name|u_int16_t
name|a_class
decl_stmt|;
comment|/* class for address */
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|BIND_UPDATE
end_ifndef

begin_enum
enum|enum
name|req_action
block|{
name|Finish
block|,
name|Refuse
block|,
name|Return
block|}
enum|;
end_enum

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|addinfo
name|addinfo
index|[
name|NADDRECS
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|addname
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|u_int16_t
parameter_list|,
name|u_int16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|copyCharString
parameter_list|(
name|u_char
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|req_action
name|req_query
parameter_list|(
name|HEADER
modifier|*
name|hp
parameter_list|,
name|u_char
modifier|*
modifier|*
name|cpp
parameter_list|,
name|u_char
modifier|*
name|eom
parameter_list|,
name|struct
name|qstream
modifier|*
name|qsp
parameter_list|,
name|int
modifier|*
name|buflenp
parameter_list|,
name|int
modifier|*
name|msglenp
parameter_list|,
name|u_char
modifier|*
name|msg
parameter_list|,
name|int
name|dfd
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|req_action
name|req_iquery
parameter_list|(
name|HEADER
modifier|*
name|hp
parameter_list|,
name|u_char
modifier|*
modifier|*
name|cpp
parameter_list|,
name|u_char
modifier|*
name|eom
parameter_list|,
name|int
modifier|*
name|buflenp
parameter_list|,
name|u_char
modifier|*
name|msg
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|BIND_NOTIFY
end_ifdef

begin_function_decl
specifier|static
name|enum
name|req_action
name|req_notify
parameter_list|(
name|HEADER
modifier|*
name|hp
parameter_list|,
name|u_char
modifier|*
modifier|*
name|cpp
parameter_list|,
name|u_char
modifier|*
name|eom
parameter_list|,
name|u_char
modifier|*
name|msg
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Process request using database; assemble and send response.  */
end_comment

begin_function
name|void
name|ns_req
parameter_list|(
name|u_char
modifier|*
name|msg
parameter_list|,
name|int
name|msglen
parameter_list|,
name|int
name|buflen
parameter_list|,
name|struct
name|qstream
modifier|*
name|qsp
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|,
name|int
name|dfd
parameter_list|)
block|{
name|HEADER
modifier|*
name|hp
init|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|eom
decl_stmt|;
name|enum
name|req_action
name|action
decl_stmt|;
name|int
name|n
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_packet
argument_list|,
literal|3
argument_list|,
literal|"ns_req(from %s)"
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|fp_nquery
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|,
name|log_get_stream
argument_list|(
name|packet_channel
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * It's not a response so these bits have no business 	 * being set. will later simplify work if we can 	 * safely assume these are always 0 when a query 	 * comes in. 	 */
name|hp
operator|->
name|aa
operator|=
name|hp
operator|->
name|ra
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NOERROR
expr_stmt|;
name|cp
operator|=
name|msg
operator|+
name|HFIXEDSZ
expr_stmt|;
name|eom
operator|=
name|msg
operator|+
name|msglen
expr_stmt|;
name|buflen
operator|-=
name|HFIXEDSZ
expr_stmt|;
name|free_addinfo
argument_list|()
expr_stmt|;
comment|/* sets addcount to zero */
name|dnptrs
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|hp
operator|->
name|opcode
condition|)
block|{
case|case
name|ns_o_query
case|:
name|action
operator|=
name|req_query
argument_list|(
name|hp
argument_list|,
operator|&
name|cp
argument_list|,
name|eom
argument_list|,
name|qsp
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|msglen
argument_list|,
name|msg
argument_list|,
name|dfd
argument_list|,
name|from
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_o_iquery
case|:
name|action
operator|=
name|req_iquery
argument_list|(
name|hp
argument_list|,
operator|&
name|cp
argument_list|,
name|eom
argument_list|,
operator|&
name|buflen
argument_list|,
name|msg
argument_list|,
name|from
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|BIND_NOTIFY
case|case
name|ns_o_notify
case|:
name|action
operator|=
name|req_notify
argument_list|(
name|hp
argument_list|,
operator|&
name|cp
argument_list|,
name|eom
argument_list|,
name|msg
argument_list|,
name|from
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BIND_UPDATE
case|case
name|ns_o_update
case|:
name|action
operator|=
name|req_update
argument_list|(
name|hp
argument_list|,
name|cp
argument_list|,
name|eom
argument_list|,
name|msg
argument_list|,
name|qsp
argument_list|,
name|dfd
argument_list|,
name|from
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* BIND_UPDATE */
default|default:
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"ns_req: Opcode %d not implemented"
argument_list|,
name|hp
operator|->
name|opcode
argument_list|)
expr_stmt|;
comment|/* XXX - should syslog, limited by haveComplained */
name|hp
operator|->
name|qdcount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NOTIMP
expr_stmt|;
name|action
operator|=
name|Finish
expr_stmt|;
block|}
comment|/* 	 * vector via internal opcode.  (yes, it was even uglier before.) 	 */
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|Return
case|:
return|return;
case|case
name|Refuse
case|:
name|hp
operator|->
name|rcode
operator|=
name|REFUSED
expr_stmt|;
name|cp
operator|=
name|eom
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|Finish
case|:
comment|/* rest of the function handles this case */
break|break;
default|default:
name|panic
argument_list|(
literal|"ns_req: bad action variable"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
comment|/* 	 * apply final polish 	 */
name|hp
operator|->
name|qr
operator|=
literal|1
expr_stmt|;
comment|/* set Response flag */
name|hp
operator|->
name|ra
operator|=
operator|(
name|NS_OPTION_P
argument_list|(
name|OPTION_NORECURSE
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|n
operator|=
name|doaddinfo
argument_list|(
name|hp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"ns_req: answer -> %s fd=%d id=%d size=%d"
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
operator|(
name|qsp
operator|==
name|NULL
operator|)
condition|?
name|dfd
else|:
name|qsp
operator|->
name|s_rfd
argument_list|,
name|ntohs
argument_list|(
name|hp
operator|->
name|id
argument_list|)
argument_list|,
name|cp
operator|-
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>=
literal|10
condition|)
name|fp_nquery
argument_list|(
name|msg
argument_list|,
name|cp
operator|-
name|msg
argument_list|,
name|log_get_stream
argument_list|(
name|packet_channel
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUG*/
if|if
condition|(
name|qsp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sendto
argument_list|(
name|dfd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|msg
argument_list|,
name|cp
operator|-
name|msg
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
sizeof|sizeof
argument_list|(
name|from
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
name|ina_ulong
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|sendtoStr
argument_list|)
condition|)
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"ns_req: sendto(%s): %s"
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|,
name|nssSendtoErr
argument_list|)
expr_stmt|;
block|}
name|nameserIncr
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|,
name|nssSentAns
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|rcode
operator|==
name|NXDOMAIN
condition|)
name|nameserIncr
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|,
name|nssSentNXD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hp
operator|->
name|aa
condition|)
name|nameserIncr
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|,
name|nssSentNaAns
argument_list|)
expr_stmt|;
block|}
else|else
name|writestream
argument_list|(
name|qsp
argument_list|,
name|msg
argument_list|,
name|cp
operator|-
name|msg
argument_list|)
expr_stmt|;
comment|/* Is now a safe time? */
if|if
condition|(
name|needs_prime_cache
condition|)
name|prime_cache
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BIND_NOTIFY
end_ifdef

begin_function
name|int
name|findZonePri
parameter_list|(
specifier|const
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|,
specifier|const
name|struct
name|sockaddr_in
name|from
parameter_list|)
block|{
name|struct
name|in_addr
name|ina
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ina
operator|=
name|from
operator|.
name|sin_addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|u_int
operator|)
name|i
operator|<
name|zp
operator|->
name|z_addrcnt
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ina_equal
argument_list|(
name|zp
operator|->
name|z_addr
index|[
name|i
index|]
argument_list|,
name|ina
argument_list|)
condition|)
return|return
operator|(
name|i
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|req_action
name|req_notify
parameter_list|(
name|HEADER
modifier|*
name|hp
parameter_list|,
name|u_char
modifier|*
modifier|*
name|cpp
parameter_list|,
name|u_char
modifier|*
name|eom
parameter_list|,
name|u_char
modifier|*
name|msg
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|type
decl_stmt|,
name|class
decl_stmt|,
name|zn
decl_stmt|;
name|char
name|dnbuf
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
init|=
name|hashtab
decl_stmt|;
comment|/* lookup relative to root */
comment|/* valid notify's have one question and zero answers */
if|if
condition|(
operator|(
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
operator|!=
literal|1
operator|)
operator|||
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
operator|!=
literal|0
operator|||
name|ntohs
argument_list|(
name|hp
operator|->
name|nscount
argument_list|)
operator|!=
literal|0
operator|||
name|ntohs
argument_list|(
name|hp
operator|->
name|arcount
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_notify
argument_list|,
literal|1
argument_list|,
literal|"FORMERR Notify header counts wrong"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|qdcount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
operator|*
name|cpp
argument_list|,
name|dnbuf
argument_list|,
sizeof|sizeof
name|dnbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_notify
argument_list|,
literal|1
argument_list|,
literal|"FORMERR Query expand name failed"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
operator|*
name|cpp
operator|+
literal|2
operator|*
name|INT16SZ
operator|>
name|eom
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_notify
argument_list|,
literal|1
argument_list|,
literal|"FORMERR notify too short"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
name|GETSHORT
argument_list|(
name|type
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
name|ns_info
argument_list|(
name|ns_log_notify
argument_list|,
literal|"rcvd NOTIFY(%s, %s, %s) from %s"
argument_list|,
name|dnbuf
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX - when answers are allowed, we'll need to do compression 	 * correctly here, and we will need to check for packet underflow. 	 */
name|np
operator|=
name|nlookup
argument_list|(
name|dnbuf
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|np
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_notify
argument_list|,
literal|"rcvd NOTIFY for \"%s\", name not in cache"
argument_list|,
name|dnbuf
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
name|zn
operator|=
name|findMyZone
argument_list|(
name|np
argument_list|,
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|zn
operator|==
name|DB_Z_CACHE
operator|||
name|zones
index|[
name|zn
index|]
operator|.
name|z_type
operator|!=
name|z_slave
condition|)
block|{
comment|/* this can come if a user did an AXFR of some zone somewhere 		 * and that zone's server now wants to tell us that the SOA 		 * has changed.  AXFR's always come from nonpriv ports so it 		 * isn't possible to know whether it was the server or just 		 * "dig".  this condition can be avoided by using secure zones 		 * since that way only real secondaries can AXFR from you. 		 */
name|ns_info
argument_list|(
name|ns_log_notify
argument_list|,
literal|"NOTIFY for non-secondary name (%s), from %s"
argument_list|,
name|dnbuf
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|refuse
goto|;
block|}
if|if
condition|(
name|findZonePri
argument_list|(
operator|&
name|zones
index|[
name|zn
index|]
argument_list|,
name|from
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_notify
argument_list|,
literal|"NOTIFY from non-master server (zone %s), from %s"
argument_list|,
name|zones
index|[
name|zn
index|]
operator|.
name|z_origin
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|refuse
goto|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_SOA
case|:
if|if
condition|(
name|strcasecmp
argument_list|(
name|dnbuf
argument_list|,
name|zones
index|[
name|zn
index|]
operator|.
name|z_origin
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_notify
argument_list|,
literal|"NOTIFY(SOA) for non-origin (%s), from %s"
argument_list|,
name|dnbuf
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|refuse
goto|;
block|}
if|if
condition|(
name|zones
index|[
name|zn
index|]
operator|.
name|z_flags
operator|&
operator|(
name|Z_NEED_RELOAD
operator||
name|Z_NEED_XFER
operator||
name|Z_QSERIAL
operator||
name|Z_XFER_RUNNING
operator|)
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_notify
argument_list|,
literal|"NOTIFY(SOA) for zone already xferring (%s)"
argument_list|,
name|dnbuf
argument_list|)
expr_stmt|;
goto|goto
name|noerror
goto|;
block|}
name|zones
index|[
name|zn
index|]
operator|.
name|z_time
operator|=
name|tt
operator|.
name|tv_sec
expr_stmt|;
name|qserial_query
argument_list|(
operator|&
name|zones
index|[
name|zn
index|]
argument_list|)
expr_stmt|;
name|sched_zone_maint
argument_list|(
operator|&
name|zones
index|[
name|zn
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* unimplemented, but it's not a protocol error, just 		 * something to be ignored. 		 */
break|break;
block|}
name|noerror
label|:
name|hp
operator|->
name|rcode
operator|=
name|NOERROR
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
name|refuse
label|:
name|hp
operator|->
name|rcode
operator|=
name|REFUSED
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*BIND_NOTIFY*/
end_comment

begin_function
specifier|static
name|enum
name|req_action
name|req_query
parameter_list|(
name|HEADER
modifier|*
name|hp
parameter_list|,
name|u_char
modifier|*
modifier|*
name|cpp
parameter_list|,
name|u_char
modifier|*
name|eom
parameter_list|,
name|struct
name|qstream
modifier|*
name|qsp
parameter_list|,
name|int
modifier|*
name|buflenp
parameter_list|,
name|int
modifier|*
name|msglenp
parameter_list|,
name|u_char
modifier|*
name|msg
parameter_list|,
name|int
name|dfd
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|class
decl_stmt|,
name|type
decl_stmt|,
name|count
decl_stmt|,
name|zone
decl_stmt|,
name|foundname
decl_stmt|,
name|founddata
decl_stmt|,
name|omsglen
decl_stmt|,
name|cname
decl_stmt|;
name|u_int16_t
name|id
decl_stmt|;
name|u_char
modifier|*
modifier|*
name|dpp
decl_stmt|,
modifier|*
name|omsg
decl_stmt|,
modifier|*
name|answers
decl_stmt|;
name|char
name|dnbuf
index|[
name|MAXDNAME
index|]
decl_stmt|,
modifier|*
name|dname
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|struct
name|databuf
modifier|*
name|nsp
index|[
name|NSMAX
index|]
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|,
modifier|*
name|anp
decl_stmt|;
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|nameserIncr
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|,
name|nssRcvdQ
argument_list|)
expr_stmt|;
name|nsp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|dpp
operator|=
name|dnptrs
expr_stmt|;
operator|*
name|dpp
operator|++
operator|=
name|msg
expr_stmt|;
operator|*
name|dpp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Make gcc happy. 	 */
name|omsglen
operator|=
literal|0
expr_stmt|;
name|omsg
operator|=
name|NULL
expr_stmt|;
name|id
operator|=
literal|0
expr_stmt|;
comment|/* valid queries have one question and zero answers */
if|if
condition|(
operator|(
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
operator|!=
literal|1
operator|)
operator|||
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
operator|!=
literal|0
operator|||
name|ntohs
argument_list|(
name|hp
operator|->
name|nscount
argument_list|)
operator|!=
literal|0
operator|||
name|ntohs
argument_list|(
name|hp
operator|->
name|arcount
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"FORMERR Query header counts wrong"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|qdcount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
comment|/* 	 * Get domain name, class, and type. 	 */
if|if
condition|(
operator|(
operator|*
operator|*
name|cpp
operator|&
name|INDIR_MASK
operator|)
operator|==
literal|0
condition|)
operator|*
name|dpp
operator|++
operator|=
operator|*
name|cpp
expr_stmt|;
comment|/* remember name for compression */
operator|*
name|dpp
operator|=
name|NULL
expr_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
operator|*
name|cpp
argument_list|,
name|dnbuf
argument_list|,
sizeof|sizeof
name|dnbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"FORMERR Query expand name failed"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
operator|*
name|cpp
operator|+
literal|2
operator|*
name|INT16SZ
operator|>
name|eom
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"FORMERR Query message length short"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
name|GETSHORT
argument_list|(
name|type
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cpp
operator|<
name|eom
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|6
argument_list|,
literal|"message length> received message"
argument_list|)
expr_stmt|;
operator|*
name|msglenp
operator|=
operator|*
name|cpp
operator|-
name|msg
expr_stmt|;
block|}
name|qtypeIncr
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* 	 * Process query. 	 */
if|if
condition|(
name|type
operator|==
name|T_AXFR
condition|)
block|{
comment|/* Refuse request if not a TCP connection. */
if|if
condition|(
name|qsp
operator|==
name|NULL
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"rejected UDP AXFR from %s for \"%s\""
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
operator|*
name|dnbuf
condition|?
name|dnbuf
else|:
literal|"."
argument_list|)
expr_stmt|;
return|return
operator|(
name|Refuse
operator|)
return|;
block|}
comment|/* The position of this is subtle. */
name|nameserIncr
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|,
name|nssRcvdAXFR
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
literal|0
expr_stmt|;
comment|/* Recursion not possible. */
block|}
operator|*
name|buflenp
operator|-=
operator|*
name|msglenp
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|founddata
operator|=
literal|0
expr_stmt|;
name|dname
operator|=
name|dnbuf
expr_stmt|;
name|cname
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|QRYLOG
if|if
condition|(
name|qrylog
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_queries
argument_list|,
literal|"XX /%s/%s/%s"
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|)
argument_list|,
operator|(
name|dname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|?
literal|"."
else|:
name|dname
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*QRYLOG*/
name|try_again
label|:
name|foundname
operator|=
literal|0
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"req: nlookup(%s) id %d type=%d class=%d"
argument_list|,
name|dname
argument_list|,
name|ntohs
argument_list|(
name|hp
operator|->
name|id
argument_list|)
argument_list|,
name|type
argument_list|,
name|class
argument_list|)
expr_stmt|;
name|htp
operator|=
name|hashtab
expr_stmt|;
comment|/* lookup relative to root */
if|if
condition|(
operator|(
name|anp
operator|=
name|np
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fname
operator|=
literal|""
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"req: %s '%s' as '%s' (cname=%d)"
argument_list|,
name|np
operator|==
name|NULL
condition|?
literal|"missed"
else|:
literal|"found"
argument_list|,
name|dname
argument_list|,
name|fname
argument_list|,
name|cname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|YPKLUDGE
comment|/* Some braindamaged resolver software will not  	   recognize internet addresses in dot notation and  	   send out address  queries for "names" such as  	   128.93.8.1.  This kludge will prevent those  	   from flooding higher level servers. 	   We simply claim to be authoritative and that 	   the domain doesn't exist. 	   Note that we could return the address but we 	   don't do that in order to encourage that broken 	   software is fixed. 	*/
if|if
condition|(
operator|!
name|np
operator|&&
name|type
operator|==
name|T_A
operator|&&
name|class
operator|==
name|C_IN
operator|&&
name|dname
condition|)
block|{
name|struct
name|in_addr
name|ina
decl_stmt|;
if|if
condition|(
name|inet_aton
argument_list|(
name|dname
argument_list|,
operator|&
name|ina
argument_list|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"ypkludge: hit as '%s'"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/*YPKLUDGE*/
comment|/* 	 * Begin Access Control Point 	 */
name|zone
operator|=
name|DB_Z_CACHE
expr_stmt|;
if|if
condition|(
name|np
condition|)
block|{
name|struct
name|namebuf
modifier|*
name|access_np
decl_stmt|;
comment|/* 		 * Find out which zone this will be answered from.  Note 		 * that we look for a zone with the same class as ours. 		 * The np that we found in the database might not be the 		 * one we asked for (i.e. dname might not equal fname).  This 		 * is OK, since if a name doesn't exist, we need to go up 		 * the tree until we find the closest enclosing zone that 		 * is of the same class. 		 */
for|for
control|(
name|access_np
operator|=
name|np
init|;
name|access_np
operator|!=
name|NULL
condition|;
name|access_np
operator|=
name|np_parent
argument_list|(
name|access_np
argument_list|)
control|)
block|{
name|dp
operator|=
name|access_np
operator|->
name|n_data
expr_stmt|;
while|while
condition|(
name|dp
operator|&&
name|dp
operator|->
name|d_class
operator|!=
name|class
condition|)
name|dp
operator|=
name|dp
operator|->
name|d_next
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
name|zone
operator|=
name|dp
operator|->
name|d_zone
expr_stmt|;
break|break;
block|}
block|}
block|}
name|zp
operator|=
operator|&
name|zones
index|[
name|zone
index|]
expr_stmt|;
comment|/* 	 * Are queries allowed from this host? 	 */
if|if
condition|(
name|type
operator|!=
name|T_AXFR
condition|)
block|{
name|ip_match_list
name|query_acl
decl_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_query_acl
operator|!=
name|NULL
condition|)
name|query_acl
operator|=
name|zp
operator|->
name|z_query_acl
expr_stmt|;
else|else
name|query_acl
operator|=
name|server_options
operator|->
name|query_acl
expr_stmt|;
if|if
condition|(
name|query_acl
operator|!=
name|NULL
operator|&&
operator|!
name|ip_address_allowed
argument_list|(
name|query_acl
argument_list|,
name|from
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_security
argument_list|,
literal|"unapproved query from %s for \"%s\""
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
operator|*
name|dname
condition|?
name|dname
else|:
literal|"."
argument_list|)
expr_stmt|;
return|return
operator|(
name|Refuse
operator|)
return|;
block|}
block|}
else|else
block|{
name|ip_match_list
name|transfer_acl
decl_stmt|;
comment|/* Do they have permission to do a zone transfer? */
if|if
condition|(
name|zp
operator|->
name|z_transfer_acl
operator|!=
name|NULL
condition|)
name|transfer_acl
operator|=
name|zp
operator|->
name|z_transfer_acl
expr_stmt|;
else|else
name|transfer_acl
operator|=
name|server_options
operator|->
name|transfer_acl
expr_stmt|;
if|if
condition|(
name|transfer_acl
operator|!=
name|NULL
operator|&&
operator|!
name|ip_address_allowed
argument_list|(
name|transfer_acl
argument_list|,
name|from
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_security
argument_list|,
literal|"unapproved AXFR from %s for \"%s\" (acl)"
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
operator|*
name|dname
condition|?
name|dname
else|:
literal|"."
argument_list|)
expr_stmt|;
return|return
operator|(
name|Refuse
operator|)
return|;
block|}
comment|/* Are we authoritative? */
if|if
condition|(
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_AUTH
operator|)
operator|==
literal|0
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_security
argument_list|,
literal|"unapproved AXFR from %s for \"%s\" (not auth)"
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
operator|*
name|dname
condition|?
name|dname
else|:
literal|"."
argument_list|)
expr_stmt|;
return|return
operator|(
name|Refuse
operator|)
return|;
block|}
comment|/* Is the name at a zone cut? */
if|if
condition|(
name|strcasecmp
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|dname
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_security
argument_list|,
literal|"unapproved AXFR from %s for \"%s\" (not zone top)"
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
operator|*
name|dname
condition|?
name|dname
else|:
literal|"."
argument_list|)
expr_stmt|;
return|return
operator|(
name|Refuse
operator|)
return|;
block|}
name|ns_info
argument_list|(
name|ns_log_security
argument_list|,
literal|"approved AXFR from %s for \"%s\""
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
operator|*
name|dname
condition|?
name|dname
else|:
literal|"."
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * End Access Control Point 	 */
comment|/* 	 * Yow! 	 */
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|dnbuf
argument_list|,
literal|"VERSION.BIND"
argument_list|)
operator|&&
name|class
operator|==
name|C_CHAOS
operator|&&
name|type
operator|==
name|T_TXT
condition|)
block|{
name|u_char
modifier|*
name|tp
decl_stmt|;
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NOERROR
expr_stmt|;
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|ra
operator|=
literal|0
expr_stmt|;
name|copyCharString
argument_list|(
name|cpp
argument_list|,
literal|"VERSION"
argument_list|)
expr_stmt|;
comment|/* Name */
name|copyCharString
argument_list|(
name|cpp
argument_list|,
literal|"BIND"
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|*
name|cpp
operator|)
operator|++
operator|=
literal|0x00
expr_stmt|;
name|PUTSHORT
argument_list|(
name|T_TXT
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
comment|/* Type */
name|PUTSHORT
argument_list|(
name|C_CHAOS
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
comment|/* Class */
name|PUTLONG
argument_list|(
literal|0
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
comment|/* TTL */
name|tp
operator|=
operator|*
name|cpp
expr_stmt|;
comment|/* Temp RdLength */
name|PUTSHORT
argument_list|(
literal|0
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
name|copyCharString
argument_list|(
name|cpp
argument_list|,
name|ShortVersion
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
operator|*
name|cpp
operator|)
operator|-
operator|(
name|tp
operator|+
name|INT16SZ
operator|)
argument_list|,
name|tp
argument_list|)
expr_stmt|;
comment|/* Real RdLength */
operator|*
name|msglenp
operator|=
operator|*
name|cpp
operator|-
name|msg
expr_stmt|;
comment|/* Total message length */
return|return
operator|(
name|Finish
operator|)
return|;
block|}
comment|/* 	 * If we don't know anything about the requested name, 	 * go look for nameservers. 	 */
if|if
condition|(
operator|!
name|np
operator|||
name|fname
operator|!=
name|dname
condition|)
goto|goto
name|fetchns
goto|;
name|foundname
operator|++
expr_stmt|;
name|answers
operator|=
operator|*
name|cpp
expr_stmt|;
name|count
operator|=
operator|*
name|cpp
operator|-
name|msg
expr_stmt|;
comment|/* Look for NXDOMAIN record with appropriate class 	 * if found return immediately 	 */
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|!
name|stale
argument_list|(
name|dp
argument_list|)
operator|&&
operator|(
name|dp
operator|->
name|d_rcode
operator|==
name|NXDOMAIN
operator|)
operator|&&
operator|(
name|dp
operator|->
name|d_class
operator|==
name|class
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|RETURNSOA
name|n
operator|=
name|finddata
argument_list|(
name|np
argument_list|,
name|class
argument_list|,
name|T_SOA
argument_list|,
name|hp
argument_list|,
operator|&
name|dname
argument_list|,
name|buflenp
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|count
condition|)
block|{
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|n
expr_stmt|;
operator|*
name|msglenp
operator|+=
name|n
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|rcode
operator|==
name|NOERROR_NODATA
condition|)
block|{
comment|/* this should not occur */
name|hp
operator|->
name|rcode
operator|=
name|NOERROR
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
block|}
endif|#
directive|endif
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
comment|/*  			 * XXX forcing AA all the time isn't right, but 			 * we have to work that way by default 			 * for compatibility with older servers. 			 */
if|if
condition|(
operator|!
name|NS_OPTION_P
argument_list|(
name|OPTION_NONAUTH_NXDOMAIN
argument_list|)
condition|)
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"NXDOMAIN aa = %d"
argument_list|,
name|hp
operator|->
name|aa
argument_list|)
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
block|}
comment|/* 	 * If not NXDOMAIN, the NOERROR_NODATA record might be 	 * anywhere in the chain.  Have to go through the grind. 	 */
name|n
operator|=
name|finddata
argument_list|(
name|np
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|hp
argument_list|,
operator|&
name|dname
argument_list|,
name|buflenp
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
comment|/* 		 * NO data available.  Refuse AXFR requests, or 		 * look for better servers for other requests. 		 */
if|if
condition|(
name|type
operator|==
name|T_AXFR
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"T_AXFR refused: no data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|Refuse
operator|)
return|;
block|}
goto|goto
name|fetchns
goto|;
block|}
if|if
condition|(
name|hp
operator|->
name|rcode
operator|==
name|NOERROR_NODATA
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|NOERROR
expr_stmt|;
ifdef|#
directive|ifdef
name|RETURNSOA
if|if
condition|(
name|count
condition|)
block|{
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|n
expr_stmt|;
operator|*
name|msglenp
operator|+=
name|n
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|founddata
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|n
expr_stmt|;
operator|*
name|msglenp
operator|+=
name|n
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
operator|+
operator|(
name|u_int16_t
operator|)
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|!=
name|dname
operator|&&
name|type
operator|!=
name|T_CNAME
operator|&&
name|type
operator|!=
name|T_ANY
condition|)
block|{
if|if
condition|(
name|cname
operator|++
operator|>=
name|MAXCNAMES
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"resp: leaving, MAXCNAMES exceeded"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
goto|goto
name|try_again
goto|;
block|}
name|founddata
operator|=
literal|1
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"req: foundname=%d, count=%d, founddata=%d, cname=%d"
argument_list|,
name|foundname
argument_list|,
name|count
argument_list|,
name|founddata
argument_list|,
name|cname
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_AXFR
condition|)
block|{
name|ns_xfr
argument_list|(
name|qsp
argument_list|,
name|np
argument_list|,
name|zone
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|hp
operator|->
name|opcode
argument_list|,
name|ntohs
argument_list|(
name|hp
operator|->
name|id
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|Return
operator|)
return|;
block|}
name|fetchns
label|:
comment|/* 	 * If we're already out of room in the response, we're done. 	 */
if|if
condition|(
name|hp
operator|->
name|tc
condition|)
return|return
operator|(
name|Finish
operator|)
return|;
comment|/*  	 * Look for name servers to refer to and fill in the authority  	 * section or record the address for forwarding the query  	 * (recursion desired).  	 */
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
name|nsp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|findns
argument_list|(
operator|&
name|np
argument_list|,
name|class
argument_list|,
name|nsp
argument_list|,
operator|&
name|count
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
name|NXDOMAIN
case|:
comment|/* We are authoritative for this np. */
if|if
condition|(
operator|!
name|foundname
condition|)
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"req: leaving (%s, rcode %d)"
argument_list|,
name|dname
argument_list|,
name|hp
operator|->
name|rcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|!=
name|C_ANY
condition|)
block|{
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|np
operator|&&
operator|(
operator|!
name|foundname
operator|||
operator|!
name|founddata
operator|)
condition|)
block|{
name|n
operator|=
name|doaddauth
argument_list|(
name|hp
argument_list|,
operator|*
name|cpp
argument_list|,
operator|*
name|buflenp
argument_list|,
name|np
argument_list|,
name|nsp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|n
expr_stmt|;
ifdef|#
directive|ifdef
name|ADDAUTH
block|}
elseif|else
if|if
condition|(
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* don't add NS records for NOERROR NODATA 				   as some servers can get confused */
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|findns
argument_list|(
operator|&
name|np
argument_list|,
name|class
argument_list|,
name|nsp
argument_list|,
operator|&
name|count
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|NXDOMAIN
case|:
case|case
name|SERVFAIL
case|:
break|break;
default|default:
if|if
condition|(
name|np
operator|&&
operator|(
name|type
operator|!=
name|T_NS
operator|||
name|np
operator|!=
name|anp
operator|)
condition|)
block|{
name|n
operator|=
name|add_data
argument_list|(
name|np
argument_list|,
name|nsp
argument_list|,
operator|*
name|cpp
argument_list|,
operator|*
name|buflenp
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
name|n
operator|=
operator|(
operator|-
name|n
operator|)
expr_stmt|;
block|}
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|n
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|count
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/*ADDAUTH*/
block|}
block|}
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
case|case
name|SERVFAIL
case|:
comment|/* We're authoritative but the zone isn't loaded. */
if|if
condition|(
operator|!
name|founddata
operator|&&
operator|!
operator|(
name|NS_OPTION_P
argument_list|(
name|OPTION_FORWARD_ONLY
argument_list|)
operator|&&
name|server_options
operator|->
name|fwdtab
operator|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
block|}
comment|/* 	 *  If we successfully found the answer in the cache, 	 *  or this is not a recursive query, or we are purposely 	 *  never recursing, then add the nameserver references 	 *  ("authority section") here and we're done. 	 */
if|if
condition|(
name|founddata
operator|||
operator|!
name|hp
operator|->
name|rd
operator|||
name|NS_OPTION_P
argument_list|(
name|OPTION_NORECURSE
argument_list|)
condition|)
block|{
comment|/* 		 * If the qtype was NS, and the np of the authority is 		 * the same as the np of the data, we don't need to add 		 * another copy of the answer here in the authority 		 * section. 		 */
if|if
condition|(
operator|!
name|founddata
operator|||
name|type
operator|!=
name|T_NS
operator|||
name|anp
operator|!=
name|np
condition|)
block|{
name|n
operator|=
name|add_data
argument_list|(
name|np
argument_list|,
name|nsp
argument_list|,
operator|*
name|cpp
argument_list|,
operator|*
name|buflenp
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
name|n
operator|=
operator|(
operator|-
name|n
operator|)
expr_stmt|;
block|}
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|n
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|count
argument_list|)
expr_stmt|;
block|}
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
comment|/* Our caller will handle the Additional section. */
return|return
operator|(
name|Finish
operator|)
return|;
block|}
comment|/* 	 *  At this point, we don't have the answer, but we do 	 *  have some NS's to try.  If the user would like us 	 *  to recurse, create the initial query.  If a cname 	 *  is involved, we need to build a new query and save 	 *  the old one in cmsg/cmsglen. 	 */
if|if
condition|(
name|cname
condition|)
block|{
name|omsg
operator|=
operator|(
name|u_char
operator|*
operator|)
name|memget
argument_list|(
operator|(
name|unsigned
operator|)
operator|*
name|msglenp
argument_list|)
expr_stmt|;
if|if
condition|(
name|omsg
operator|==
name|NULL
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"ns_req: Out Of Memory"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
name|id
operator|=
name|hp
operator|->
name|id
expr_stmt|;
name|omsglen
operator|=
operator|*
name|msglenp
expr_stmt|;
name|memcpy
argument_list|(
name|omsg
argument_list|,
name|msg
argument_list|,
name|omsglen
argument_list|)
expr_stmt|;
name|n
operator|=
name|res_mkquery
argument_list|(
name|QUERY
argument_list|,
name|dname
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|msg
argument_list|,
operator|*
name|msglenp
operator|+
operator|*
name|buflenp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"res_mkquery(%s) failed"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
operator|*
name|msglenp
operator|=
name|n
expr_stmt|;
block|}
name|n
operator|=
name|ns_forw
argument_list|(
name|nsp
argument_list|,
name|msg
argument_list|,
operator|*
name|msglenp
argument_list|,
name|from
argument_list|,
name|qsp
argument_list|,
name|dfd
argument_list|,
operator|&
name|qp
argument_list|,
name|dname
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|np
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|FW_OK
operator|&&
name|cname
condition|)
name|memput
argument_list|(
name|omsg
argument_list|,
name|omsglen
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|FW_OK
case|:
if|if
condition|(
name|cname
condition|)
block|{
name|qp
operator|->
name|q_cname
operator|=
name|cname
expr_stmt|;
name|qp
operator|->
name|q_cmsg
operator|=
name|omsg
expr_stmt|;
name|qp
operator|->
name|q_cmsglen
operator|=
name|omsglen
expr_stmt|;
name|qp
operator|->
name|q_id
operator|=
name|id
expr_stmt|;
block|}
break|break;
case|case
name|FW_DUP
case|:
break|break;
comment|/* Duplicate request dropped */
case|case
name|FW_NOSERVER
case|:
comment|/*  		 * Don't go into an infinite loop if  		 * the admin gave root NS records in the cache 		 * file without giving address records 		 * for the root servers. 		 */
if|if
condition|(
name|np
condition|)
block|{
if|if
condition|(
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"ns_req: no address for root server"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|&&
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|T_NS
argument_list|)
condition|)
break|break;
if|if
condition|(
name|dp
condition|)
block|{
comment|/* 				 * we know the child zone exists but are 				 * missing glue. 				 * 				 * nslookup has called sysquery() to get the 				 * missing glue. 				 * 				 * for UDP, drop the response and let the 				 * client retry.  for TCP, we should probably 				 * (XXX) hold open the TCP connection for a 				 * while in case the sysquery() comes back 				 * soon.  meanwhile we SERVFAIL. 				 */
if|if
condition|(
name|qsp
condition|)
goto|goto
name|do_servfail
goto|;
break|break;
block|}
name|np
operator|=
name|np_parent
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
goto|goto
name|fetchns
goto|;
comment|/* Try again. */
case|case
name|FW_SERVFAIL
case|:
name|do_servfail
label|:
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
return|return
operator|(
name|Return
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|req_action
name|req_iquery
parameter_list|(
name|HEADER
modifier|*
name|hp
parameter_list|,
name|u_char
modifier|*
modifier|*
name|cpp
parameter_list|,
name|u_char
modifier|*
name|eom
parameter_list|,
name|int
modifier|*
name|buflenp
parameter_list|,
name|u_char
modifier|*
name|msg
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|)
block|{
name|int
name|dlen
decl_stmt|,
name|alen
decl_stmt|,
name|n
decl_stmt|,
name|type
decl_stmt|,
name|class
decl_stmt|,
name|count
decl_stmt|;
name|char
name|dnbuf
index|[
name|MAXDNAME
index|]
decl_stmt|,
name|anbuf
index|[
name|PACKETSZ
index|]
decl_stmt|,
modifier|*
name|data
decl_stmt|,
modifier|*
name|fname
decl_stmt|;
name|nameserIncr
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|,
name|nssRcvdIQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
operator|!=
literal|1
operator|||
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
operator|!=
literal|0
operator|||
name|ntohs
argument_list|(
name|hp
operator|->
name|nscount
argument_list|)
operator|!=
literal|0
operator|||
name|ntohs
argument_list|(
name|hp
operator|->
name|arcount
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"FORMERR IQuery header counts wrong"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|qdcount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
comment|/* 	 * Skip domain name, get class, and type. 	 */
if|if
condition|(
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
operator|*
name|cpp
argument_list|,
name|eom
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"FORMERR IQuery packet name problem"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
operator|*
name|cpp
operator|+
literal|3
operator|*
name|INT16SZ
operator|+
name|INT32SZ
operator|>
name|eom
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"FORMERR IQuery message too short"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
name|GETSHORT
argument_list|(
name|type
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
operator|*
name|cpp
operator|+=
name|INT32SZ
expr_stmt|;
comment|/* ttl */
name|GETSHORT
argument_list|(
name|dlen
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
operator|*
name|cpp
operator|+=
name|dlen
expr_stmt|;
if|if
condition|(
operator|*
name|cpp
operator|!=
name|eom
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"FORMERR IQuery message length off"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
comment|/* 	 * not all inverse queries are handled. 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
if|if
condition|(
operator|!
name|NS_OPTION_P
argument_list|(
name|OPTION_FAKE_IQUERY
argument_list|)
operator|||
name|dlen
operator|!=
name|INT32SZ
condition|)
return|return
operator|(
name|Refuse
operator|)
return|;
break|break;
default|default:
return|return
operator|(
name|Refuse
operator|)
return|;
block|}
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"req: IQuery class %d type %d"
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|fname
operator|=
operator|(
name|char
operator|*
operator|)
name|msg
operator|+
name|HFIXEDSZ
expr_stmt|;
name|alen
operator|=
operator|(
name|char
operator|*
operator|)
operator|*
name|cpp
operator|-
name|fname
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|alen
operator|>
sizeof|sizeof
name|anbuf
condition|)
return|return
operator|(
name|Refuse
operator|)
return|;
name|memcpy
argument_list|(
name|anbuf
argument_list|,
name|fname
argument_list|,
name|alen
argument_list|)
expr_stmt|;
name|data
operator|=
name|anbuf
operator|+
name|alen
operator|-
name|dlen
expr_stmt|;
operator|*
name|cpp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|fname
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|HFIXEDSZ
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|QRYLOG
if|if
condition|(
name|qrylog
condition|)
block|{
name|char
name|tmp
index|[
sizeof|sizeof
expr|"255.255.255.255"]
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|ns_info
argument_list|(
name|ns_log_queries
argument_list|,
literal|"XX /%s/%s/-%s"
argument_list|,
name|tmp
argument_list|,
name|inet_ntoa
argument_list|(
name|ina_get
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|data
argument_list|)
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*QRYLOG*/
comment|/* 	 * We can only get here if the option "fake-iquery" is on in the boot 	 * file. 	 * 	 * What we do here is send back a bogus response of "[dottedquad]". 	 * A better strategy would be to turn this into a PTR query, but that 	 * would legitimize inverse queries in a way they do not deserve. 	 */
name|sprintf
argument_list|(
name|dnbuf
argument_list|,
literal|"[%s]"
argument_list|,
name|inet_ntoa
argument_list|(
name|ina_get
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|data
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|QFIXEDSZ
expr_stmt|;
name|n
operator|=
name|dn_comp
argument_list|(
name|dnbuf
argument_list|,
operator|*
name|cpp
argument_list|,
operator|*
name|buflenp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|type
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|class
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|n
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"req: IQuery %d records"
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|hp
operator|->
name|qdcount
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|alen
operator|>
operator|*
name|buflenp
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
name|memcpy
argument_list|(
operator|*
name|cpp
argument_list|,
name|anbuf
argument_list|,
name|alen
argument_list|)
expr_stmt|;
operator|*
name|cpp
operator|+=
name|alen
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Test a datum for validity and return non-zero if it is out of date.  */
end_comment

begin_function
name|int
name|stale
parameter_list|(
name|struct
name|databuf
modifier|*
name|dp
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
init|=
operator|&
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
decl_stmt|;
switch|switch
condition|(
name|zp
operator|->
name|z_type
condition|)
block|{
case|case
name|z_master
case|:
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|STUBS
case|case
name|z_stub
case|:
comment|/* root stub zones have DB_F_HINT set */
if|if
condition|(
name|dp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* FALLTROUGH */
endif|#
directive|endif
case|case
name|z_slave
case|:
comment|/* 		 * Check to see whether a secondary zone has expired or 		 * time warped; if so clear authority flag for zone, 		 * schedule the zone for immediate maintenance, and 		 * return true. 		 */
if|if
condition|(
call|(
name|int32_t
call|)
argument_list|(
name|tt
operator|.
name|tv_sec
operator|-
name|zp
operator|->
name|z_lastupdate
argument_list|)
operator|>
operator|(
name|int32_t
operator|)
name|zp
operator|->
name|z_expire
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"stale: secondary zone %s expired"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
operator|(
name|u_long
operator|)
name|zp
argument_list|,
operator|(
name|u_long
operator|)
name|stale
argument_list|)
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"secondary zone \"%s\" expired"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
block|}
name|zp
operator|->
name|z_flags
operator|&=
operator|~
name|Z_AUTH
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|zp
operator|->
name|z_flags
operator|&
operator|(
name|Z_QSERIAL
operator||
name|Z_XFER_RUNNING
operator|)
operator|)
condition|)
block|{
name|zp
operator|->
name|z_time
operator|=
name|tt
operator|.
name|tv_sec
expr_stmt|;
name|sched_zone_maint
argument_list|(
name|zp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zp
operator|->
name|z_lastupdate
operator|>
name|tt
operator|.
name|tv_sec
condition|)
block|{
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
operator|(
name|u_long
operator|)
name|zp
argument_list|,
operator|(
name|u_long
operator|)
name|stale
argument_list|)
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"secondary zone \"%s\" time warp"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
block|}
name|zp
operator|->
name|z_flags
operator|&=
operator|~
name|Z_AUTH
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|zp
operator|->
name|z_flags
operator|&
operator|(
name|Z_QSERIAL
operator||
name|Z_XFER_RUNNING
operator|)
operator|)
condition|)
block|{
name|zp
operator|->
name|z_time
operator|=
name|tt
operator|.
name|tv_sec
expr_stmt|;
name|sched_zone_maint
argument_list|(
name|zp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|z_hint
case|:
if|if
condition|(
name|dp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
operator|||
name|dp
operator|->
name|d_ttl
operator|>=
operator|(
name|u_int32_t
operator|)
name|tt
operator|.
name|tv_sec
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"stale: ttl %d %ld (x%lx)"
argument_list|,
name|dp
operator|->
name|d_ttl
argument_list|,
call|(
name|long
call|)
argument_list|(
name|dp
operator|->
name|d_ttl
operator|-
name|tt
operator|.
name|tv_sec
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|dp
operator|->
name|d_flags
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
default|default:
comment|/* FALLTHROUGH */
empty_stmt|;
block|}
name|panic
argument_list|(
literal|"stale: impossible condition"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Make gcc happy. */
block|}
end_function

begin_comment
comment|/*  * Copy databuf into a resource record for replies.  * Return size of RR if OK, -1 if buffer is full.  */
end_comment

begin_function
name|int
name|make_rr
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|databuf
modifier|*
name|dp
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|buflen
parameter_list|,
name|int
name|doadd
parameter_list|,
name|u_char
modifier|*
modifier|*
name|comp_ptrs
parameter_list|,
name|u_char
modifier|*
modifier|*
name|edp
parameter_list|)
block|{
name|u_char
modifier|*
name|cp
decl_stmt|;
name|u_char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|int32_t
name|n
decl_stmt|;
name|int16_t
name|type
init|=
name|dp
operator|->
name|d_type
decl_stmt|;
name|u_int32_t
name|ttl
decl_stmt|;
ifdef|#
directive|ifdef
name|BIND_UPDATE
name|u_int32_t
name|serial
decl_stmt|;
endif|#
directive|endif
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|5
argument_list|,
literal|"make_rr(%s, %lx, %lx, %d, %d) %d zone %d ttl %lu"
argument_list|,
name|name
argument_list|,
operator|(
name|u_long
operator|)
name|dp
argument_list|,
operator|(
name|u_long
operator|)
name|buf
argument_list|,
name|buflen
argument_list|,
name|doadd
argument_list|,
name|dp
operator|->
name|d_size
argument_list|,
name|dp
operator|->
name|d_zone
argument_list|,
operator|(
name|u_long
operator|)
name|dp
operator|->
name|d_ttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_rcode
ifdef|#
directive|ifdef
name|RETURNSOA
operator|&&
name|dp
operator|->
name|d_size
operator|==
literal|0
endif|#
directive|endif
condition|)
name|panic
argument_list|(
literal|"make_rr: impossible d_rcode value"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|zp
operator|=
operator|&
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
expr_stmt|;
comment|/* check for outdated RR before updating comp_ptrs[] by dn_comp() */
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_CACHE
condition|)
block|{
if|if
condition|(
operator|(
name|dp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
operator|)
operator|!=
literal|0
operator|||
name|dp
operator|->
name|d_ttl
operator|<
operator|(
name|u_int32_t
operator|)
name|tt
operator|.
name|tv_sec
condition|)
block|{
name|ttl
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|ttl
operator|=
name|dp
operator|->
name|d_ttl
operator|-
operator|(
name|u_int32_t
operator|)
name|tt
operator|.
name|tv_sec
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dp
operator|->
name|d_ttl
operator|!=
name|USE_MINIMUM
condition|)
name|ttl
operator|=
name|dp
operator|->
name|d_ttl
expr_stmt|;
else|else
name|ttl
operator|=
name|zp
operator|->
name|z_minimum
expr_stmt|;
comment|/* really default */
block|}
name|buflen
operator|-=
name|RRFIXEDSZ
expr_stmt|;
if|if
condition|(
name|buflen
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|RETURNSOA
if|if
condition|(
name|dp
operator|->
name|d_rcode
condition|)
block|{
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
expr_stmt|;
name|name
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|name
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|name
operator|+=
literal|5
operator|*
name|INT32SZ
expr_stmt|;
name|type
operator|=
name|T_SOA
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|n
operator|=
name|dn_comp
argument_list|(
name|name
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|,
name|comp_ptrs
argument_list|,
name|edp
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|=
name|buf
operator|+
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
if|if
condition|(
name|buflen
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|dp
operator|->
name|d_class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|PUTLONG
argument_list|(
name|ttl
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|cp
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_CNAME
case|:
case|case
name|T_MG
case|:
case|case
name|T_MR
case|:
case|case
name|T_PTR
case|:
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
name|comp_ptrs
argument_list|,
name|edp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
break|break;
case|case
name|T_MB
case|:
case|case
name|T_NS
case|:
comment|/* Store domain name in answer */
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
name|comp_ptrs
argument_list|,
name|edp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|doadd
condition|)
name|addname
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|dp
operator|->
name|d_class
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_SOA
case|:
case|case
name|T_MINFO
case|:
case|case
name|T_RP
case|:
name|cp1
operator|=
name|dp
operator|->
name|d_data
expr_stmt|;
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
name|comp_ptrs
argument_list|,
name|edp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|type
operator|==
name|T_SOA
condition|?
name|n
operator|+
literal|5
operator|*
name|INT32SZ
else|:
name|n
expr_stmt|;
if|if
condition|(
name|buflen
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
name|comp_ptrs
argument_list|,
name|edp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
block|{
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND_UPDATE
if|if
condition|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_NEED_SOAUPDATE
condition|)
if|if
condition|(
name|incr_serial
argument_list|(
name|zp
argument_list|)
operator|<
literal|0
condition|)
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"error updating serial number for %s from %d"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|zp
operator|->
name|z_serial
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|n
operator|=
literal|5
operator|*
name|INT32SZ
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
name|n
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|cp
operator|-
name|sp
operator|)
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_NAPTR
case|:
comment|/* cp1 == our data/ cp == data of RR */
name|cp1
operator|=
name|dp
operator|->
name|d_data
expr_stmt|;
comment|/* copy order */
name|buflen
operator|-=
name|INT16SZ
expr_stmt|;
if|if
condition|(
name|buflen
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
name|cp1
operator|+=
name|INT16SZ
expr_stmt|;
name|n
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|cp
operator|-
name|sp
operator|)
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"current size n = %u"
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* copy preference */
name|buflen
operator|-=
name|INT16SZ
expr_stmt|;
if|if
condition|(
name|buflen
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
name|cp1
operator|+=
name|INT16SZ
expr_stmt|;
name|n
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|cp
operator|-
name|sp
operator|)
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"current size n = %u"
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* Flags */
name|n
operator|=
operator|*
name|cp1
operator|++
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"size of n at flags = %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|buflen
operator|-=
name|n
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|buflen
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|cp
operator|++
operator|=
name|n
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
name|n
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|cp
operator|-
name|sp
operator|)
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"current size n = %u"
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* Service */
name|n
operator|=
operator|*
name|cp1
operator|++
expr_stmt|;
name|buflen
operator|-=
name|n
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|buflen
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|cp
operator|++
operator|=
name|n
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
name|n
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|cp
operator|-
name|sp
operator|)
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"current size n = %u"
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* Regexp */
name|n
operator|=
operator|*
name|cp1
operator|++
expr_stmt|;
name|buflen
operator|-=
name|n
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|buflen
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|cp
operator|++
operator|=
name|n
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
name|n
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|cp
operator|-
name|sp
operator|)
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"current size n = %u"
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* Replacement */
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"Replacement = %s"
argument_list|,
name|cp1
argument_list|)
expr_stmt|;
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
name|dnptrs
argument_list|,
name|edp
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"dn_comp's n = %u"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* save data length */
name|n
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|cp
operator|-
name|sp
operator|)
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"saved size n = %u"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MX
case|:
case|case
name|T_AFSDB
case|:
case|case
name|T_RT
case|:
case|case
name|T_SRV
case|:
comment|/* cp1 == our data/ cp == data of RR */
name|cp1
operator|=
name|dp
operator|->
name|d_data
expr_stmt|;
if|if
condition|(
operator|(
name|buflen
operator|-=
name|INT16SZ
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* copy preference */
name|memcpy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
name|cp1
operator|+=
name|INT16SZ
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SRV
condition|)
block|{
name|buflen
operator|-=
name|INT16SZ
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|buflen
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|INT16SZ
operator|*
literal|2
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
operator|*
literal|2
expr_stmt|;
name|cp1
operator|+=
name|INT16SZ
operator|*
literal|2
expr_stmt|;
block|}
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
name|comp_ptrs
argument_list|,
name|edp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* save data length */
name|n
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|cp
operator|-
name|sp
operator|)
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|doadd
condition|)
name|addname
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|dp
operator|->
name|d_class
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_PX
case|:
name|cp1
operator|=
name|dp
operator|->
name|d_data
expr_stmt|;
if|if
condition|(
operator|(
name|buflen
operator|-=
name|INT16SZ
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* copy preference */
name|memcpy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
name|cp1
operator|+=
name|INT16SZ
expr_stmt|;
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
name|comp_ptrs
argument_list|,
name|edp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
name|comp_ptrs
argument_list|,
name|edp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* save data length */
name|n
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|cp
operator|-
name|sp
operator|)
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_SIG
case|:
comment|/* cp1 == our data; cp == data of target RR */
name|cp1
operator|=
name|dp
operator|->
name|d_data
expr_stmt|;
comment|/* first just copy over the type_covered, algorithm, */
comment|/* labels, orig ttl, two timestamps, and the footprint */
if|if
condition|(
operator|(
name|dp
operator|->
name|d_size
operator|-
literal|18
operator|)
operator|>
name|buflen
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* out of room! */
name|memcpy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|18
expr_stmt|;
name|cp1
operator|+=
literal|18
expr_stmt|;
name|buflen
operator|-=
literal|18
expr_stmt|;
comment|/* then the signer's name */
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* finally, we copy over the variable-length signature */
name|n
operator|=
name|dp
operator|->
name|d_size
operator|-
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|cp1
operator|-
name|dp
operator|->
name|d_data
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|buflen
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* out of room! */
name|memcpy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* save data length& return */
name|n
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|cp
operator|-
name|sp
operator|)
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|sp
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|dp
operator|->
name|d_size
operator|>
name|buflen
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|dp
operator|->
name|d_data
argument_list|,
name|dp
operator|->
name|d_size
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|dp
operator|->
name|d_size
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|dp
operator|->
name|d_size
expr_stmt|;
block|}
return|return
operator|(
name|cp
operator|-
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|addname
parameter_list|(
specifier|const
name|char
modifier|*
name|dname
parameter_list|,
specifier|const
name|char
modifier|*
name|rname
parameter_list|,
name|u_int16_t
name|rtype
parameter_list|,
name|u_int16_t
name|class
parameter_list|)
block|{
name|struct
name|addinfo
modifier|*
name|ap
decl_stmt|;
name|int
name|n
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|addinfo
operator|,
name|n
operator|=
name|addcount
init|;
operator|--
name|n
operator|>=
literal|0
condition|;
name|ap
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|,
name|dname
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* add domain name to additional section */
if|if
condition|(
name|addcount
operator|<
name|NADDRECS
condition|)
block|{
name|addcount
operator|++
expr_stmt|;
name|ap
operator|->
name|a_dname
operator|=
name|savestr
argument_list|(
name|dname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_rname
operator|=
name|savestr
argument_list|(
name|rname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_rtype
operator|=
name|rtype
expr_stmt|;
name|ap
operator|->
name|a_class
operator|=
name|class
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Lookup addresses for names in addinfo and put into the message's  * additional section.  */
end_comment

begin_function
name|int
name|doaddinfo
parameter_list|(
name|HEADER
modifier|*
name|hp
parameter_list|,
name|u_char
modifier|*
name|msg
parameter_list|,
name|int
name|msglen
parameter_list|)
block|{
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|struct
name|addinfo
modifier|*
name|ap
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|n
decl_stmt|,
name|count
decl_stmt|;
if|if
condition|(
operator|!
name|addcount
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"doaddinfo() addcount = %d"
argument_list|,
name|addcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|tc
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|4
argument_list|,
literal|"doaddinfo(): tc already set, bailing"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|msg
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|addinfo
init|;
operator|--
name|addcount
operator|>=
literal|0
condition|;
name|ap
operator|++
control|)
block|{
name|int
name|foundany
init|=
literal|0
decl_stmt|,
name|foundcname
init|=
literal|0
decl_stmt|,
name|save_count
init|=
name|count
decl_stmt|,
name|save_msglen
init|=
name|msglen
decl_stmt|;
name|u_char
modifier|*
name|save_cp
init|=
name|cp
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"do additional \"%s\" (from \"%s\")"
argument_list|,
name|ap
operator|->
name|a_dname
argument_list|,
name|ap
operator|->
name|a_rname
argument_list|)
expr_stmt|;
name|htp
operator|=
name|hashtab
expr_stmt|;
comment|/* because "nlookup" stomps on arg. */
name|np
operator|=
name|nlookup
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
operator|||
name|fname
operator|!=
name|ap
operator|->
name|a_dname
condition|)
goto|goto
name|next_rr
goto|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"found it"
argument_list|)
expr_stmt|;
comment|/* look for the data */
name|delete_stale
argument_list|(
name|np
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_rcode
condition|)
continue|continue;
if|if
condition|(
name|match
argument_list|(
name|dp
argument_list|,
operator|(
name|int
operator|)
name|ap
operator|->
name|a_class
argument_list|,
name|T_CNAME
argument_list|)
operator|||
name|match
argument_list|(
name|dp
argument_list|,
name|C_IN
argument_list|,
name|T_CNAME
argument_list|)
condition|)
block|{
name|foundcname
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|match
argument_list|(
name|dp
argument_list|,
operator|(
name|int
operator|)
name|ap
operator|->
name|a_class
argument_list|,
name|T_A
argument_list|)
operator|&&
operator|!
name|match
argument_list|(
name|dp
argument_list|,
name|C_IN
argument_list|,
name|T_A
argument_list|)
operator|&&
operator|!
name|match
argument_list|(
name|dp
argument_list|,
operator|(
name|int
operator|)
name|ap
operator|->
name|a_class
argument_list|,
name|T_AAAA
argument_list|)
operator|&&
operator|!
name|match
argument_list|(
name|dp
argument_list|,
name|C_IN
argument_list|,
name|T_AAAA
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|foundany
operator|++
expr_stmt|;
comment|/* 			 *  Should be smart and eliminate duplicate 			 *  data here.	XXX 			 */
if|if
condition|(
operator|(
name|n
operator|=
name|make_rr
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|,
name|dp
argument_list|,
name|cp
argument_list|,
name|msglen
argument_list|,
literal|0
argument_list|,
name|dnptrs
argument_list|,
name|dnptrs_end
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* truncation in the additional-data section 				 * is not all that serious.  we do not set TC, 				 * since the answer and authority sections are 				 * OK; however, since we're not setting TC we 				 * have to make sure that none of the RR's for 				 * this name go out (!TC implies that all 				 * {name,type} appearances are complete -- and 				 * since we only do A RR's here, the name is 				 * the key).	vixie, 23apr93 				 */
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|5
argument_list|,
literal|"addinfo: not enough room, remaining msglen = %d"
argument_list|,
name|save_msglen
argument_list|)
expr_stmt|;
name|cp
operator|=
name|save_cp
expr_stmt|;
name|msglen
operator|=
name|save_msglen
expr_stmt|;
name|count
operator|=
name|save_count
expr_stmt|;
break|break;
block|}
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|5
argument_list|,
literal|"addinfo: adding address data n = %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|msglen
operator|-=
name|n
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|next_rr
label|:
if|if
condition|(
operator|!
name|NS_OPTION_P
argument_list|(
name|OPTION_NOFETCHGLUE
argument_list|)
operator|&&
operator|!
name|foundcname
operator|&&
operator|!
name|foundany
condition|)
block|{
comment|/* ask a real server for this info */
operator|(
name|void
operator|)
name|sysquery
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|,
operator|(
name|int
operator|)
name|ap
operator|->
name|a_class
argument_list|,
name|T_A
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|QUERY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|foundcname
condition|)
block|{
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
name|nhash
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|)
argument_list|,
name|nhash
argument_list|(
name|ap
operator|->
name|a_rname
argument_list|)
argument_list|)
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_cname
argument_list|,
literal|"\"%s %s %s\" points to a CNAME (%s)"
argument_list|,
name|ap
operator|->
name|a_rname
argument_list|,
name|p_class
argument_list|(
name|ap
operator|->
name|a_class
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|ap
operator|->
name|a_rtype
argument_list|)
argument_list|,
name|ap
operator|->
name|a_dname
argument_list|)
expr_stmt|;
block|}
block|}
name|freestr
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|)
expr_stmt|;
name|freestr
argument_list|(
name|ap
operator|->
name|a_rname
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|arcount
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|-
name|msg
operator|)
return|;
block|}
end_function

begin_function
name|int
name|doaddauth
parameter_list|(
name|HEADER
modifier|*
name|hp
parameter_list|,
name|u_char
modifier|*
name|cp
parameter_list|,
name|int
name|buflen
parameter_list|,
name|struct
name|namebuf
modifier|*
name|np
parameter_list|,
name|struct
name|databuf
modifier|*
name|dp
parameter_list|)
block|{
name|char
name|dnbuf
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|getname
argument_list|(
name|np
argument_list|,
name|dnbuf
argument_list|,
sizeof|sizeof
name|dnbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|stale
argument_list|(
name|dp
argument_list|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"doaddauth: can't add stale '%s' (%d)"
argument_list|,
name|dnbuf
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|n
operator|=
name|make_rr
argument_list|(
name|dnbuf
argument_list|,
name|dp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
literal|1
argument_list|,
name|dnptrs
argument_list|,
name|dnptrs_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"doaddauth: can't add oversize '%s' (%d) (n=%d)"
argument_list|,
name|dnbuf
argument_list|,
name|buflen
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|hp
operator|->
name|nscount
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
name|void
name|free_addinfo
parameter_list|()
block|{
name|struct
name|addinfo
modifier|*
name|ap
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|addinfo
init|;
operator|--
name|addcount
operator|>=
literal|0
condition|;
name|ap
operator|++
control|)
block|{
name|freestr
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|)
expr_stmt|;
name|freestr
argument_list|(
name|ap
operator|->
name|a_rname
argument_list|)
expr_stmt|;
block|}
name|addcount
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|free_nsp
parameter_list|(
name|struct
name|databuf
modifier|*
modifier|*
name|nsp
parameter_list|)
block|{
while|while
condition|(
operator|*
name|nsp
condition|)
block|{
name|DRCNTDEC
argument_list|(
operator|*
name|nsp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|nsp
operator|)
operator|->
name|d_rcnt
condition|)
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"free_nsp: %s rcnt %d"
argument_list|,
operator|(
operator|*
name|nsp
operator|)
operator|->
name|d_data
argument_list|,
operator|(
operator|*
name|nsp
operator|)
operator|->
name|d_rcnt
argument_list|)
expr_stmt|;
else|else
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"free_nsp: %s rcnt %d delayed"
argument_list|,
operator|(
operator|*
name|nsp
operator|)
operator|->
name|d_data
argument_list|,
operator|(
operator|*
name|nsp
operator|)
operator|->
name|d_rcnt
argument_list|)
expr_stmt|;
name|db_freedata
argument_list|(
operator|*
name|nsp
argument_list|)
expr_stmt|;
comment|/* delayed free */
block|}
operator|*
name|nsp
operator|++
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|copyCharString
parameter_list|(
name|u_char
modifier|*
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|src
argument_list|)
operator|&
literal|0xff
decl_stmt|;
operator|*
operator|(
operator|*
name|dst
operator|)
operator|++
operator|=
operator|(
name|u_char
operator|)
name|len
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|dst
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
name|dst
operator|+=
name|len
expr_stmt|;
block|}
end_function

end_unit

